Implementation smell,Namespace,Class,File,Method,Description
Long Method,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOf,The method has 102 lines of code.
Long Method,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,LastIndexOf,The method has 100 lines of code.
Long Method,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOfAny,The method has 121 lines of code.
Long Method,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOfAny,The method has 125 lines of code.
Long Method,System,Number,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Number\Number.cs,NumberToDouble,The method has 122 lines of code.
Long Method,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,DecodeFromUtf8,The method has 111 lines of code.
Long Method,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeG,The method has 134 lines of code.
Long Method,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The method has 228 lines of code.
Long Method,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetR,The method has 177 lines of code.
Long Method,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseGuidCore,The method has 118 lines of code.
Long Method,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseInt32D,The method has 124 lines of code.
Long Method,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseUInt32D,The method has 104 lines of code.
Long Method,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseNumber,The method has 189 lines of code.
Long Method,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseTimeSpanBigG,The method has 107 lines of code.
Long Method,System.Buffers.Text,TimeSpanSplitter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.TimeSpanSplitter.cs,TrySplitTimeSpan,The method has 129 lines of code.
Complex Method,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOf,Cyclomatic complexity of the method is 17
Complex Method,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,LastIndexOf,Cyclomatic complexity of the method is 17
Complex Method,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,SequenceEqual,Cyclomatic complexity of the method is 18
Complex Method,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOf,Cyclomatic complexity of the method is 13
Complex Method,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,LastIndexOf,Cyclomatic complexity of the method is 13
Complex Method,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOfAny,Cyclomatic complexity of the method is 22
Complex Method,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOfAny,Cyclomatic complexity of the method is 22
Complex Method,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,SequenceEqual,Cyclomatic complexity of the method is 10
Complex Method,System,Number,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Number\Number.cs,NumberToDouble,Cyclomatic complexity of the method is 19
Complex Method,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,DecodeFromUtf8,Cyclomatic complexity of the method is 12
Complex Method,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDecimalE,Cyclomatic complexity of the method is 9
Complex Method,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDecimalF,Cyclomatic complexity of the method is 10
Complex Method,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDecimalG,Cyclomatic complexity of the method is 11
Complex Method,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormat,Cyclomatic complexity of the method is 10
Complex Method,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatInt64D,Cyclomatic complexity of the method is 9
Complex Method,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatInt64N,Cyclomatic complexity of the method is 8
Complex Method,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatUInt64X,Cyclomatic complexity of the method is 9
Complex Method,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetDefault,Cyclomatic complexity of the method is 10
Complex Method,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeG,Cyclomatic complexity of the method is 14
Complex Method,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,Cyclomatic complexity of the method is 24
Complex Method,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetR,Cyclomatic complexity of the method is 17
Complex Method,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseGuidCore,Cyclomatic complexity of the method is 19
Complex Method,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseSByteD,Cyclomatic complexity of the method is 14
Complex Method,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseInt16D,Cyclomatic complexity of the method is 18
Complex Method,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseInt32D,Cyclomatic complexity of the method is 29
Complex Method,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseInt64D,Cyclomatic complexity of the method is 8
Complex Method,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseByteD,Cyclomatic complexity of the method is 12
Complex Method,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseUInt16D,Cyclomatic complexity of the method is 16
Complex Method,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseUInt32D,Cyclomatic complexity of the method is 26
Complex Method,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseNumber,Cyclomatic complexity of the method is 24
Complex Method,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseTimeSpanBigG,Cyclomatic complexity of the method is 17
Complex Method,System.Buffers.Text,TimeSpanSplitter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.TimeSpanSplitter.cs,TrySplitTimeSpan,Cyclomatic complexity of the method is 12
Long Parameter List,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOfAny,The method has 5 parameters. Parameters: searchSpace' value0' value1' value2' length
Long Parameter List,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,DecodeFromUtf8,The method has 5 parameters. Parameters: utf8' bytes' consumed' written' isFinalBlock
Long Parameter List,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,EncodeToUtf8,The method has 5 parameters. Parameters: bytes' utf8' consumed' written' isFinalBlock
Long Parameter List,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDecimalE,The method has 5 parameters. Parameters: number' buffer' bytesWritten' precision' exponentSymbol
Long Parameter List,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatInt64,The method has 5 parameters. Parameters: value' mask' buffer' bytesWritten' format
Long Parameter List,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatUInt64X,The method has 5 parameters. Parameters: value' precision' useLower' buffer' bytesWritten
Long Parameter List,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryCreateDateTimeOffset,The method has 5 parameters. Parameters: dateTime' offsetNegative' offsetHours' offsetMinutes' value
Long Parameter List,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryCreateDateTimeOffset,The method has 11 parameters. Parameters: year' month' day' hour' minute' second' fraction' offsetNegative' offsetHours' offsetMinutes' value
Long Parameter List,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryCreateDateTimeOffsetInterpretingDataAsLocalTime,The method has 8 parameters. Parameters: year' month' day' hour' minute' second' fraction' value
Long Parameter List,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryCreateDateTime,The method has 9 parameters. Parameters: year' month' day' hour' minute' second' fraction' kind' value
Long Parameter List,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseAsSpecialFloatingPoint,The method has 6 parameters. Parameters: text' positiveInfinity' negativeInfinity' nan' value' bytesConsumed
Long Parameter List,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseGuidCore,The method has 6 parameters. Parameters: text' ends' begin' end' value' bytesConsumed
Long Parameter List,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseNumber,The method has 5 parameters. Parameters: text' number' bytesConsumed' options' textUsedExponentNotation
Long Parameter List,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryCreateTimeSpan,The method has 7 parameters. Parameters: isNegative' days' hours' minutes' seconds' fraction' timeSpan
Long Identifier,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseNumber,The length of the parameter startIndexNonLeadingDigitsBeforeDecimal is 39.
Long Identifier,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseNumber,The length of the parameter numNonLeadingDigitsBeforeDecimal is 32.
Long Identifier,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseNumber,The length of the parameter numNonLeadingDigitsBeforeDecimalToCopy is 38.
Long Identifier,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseNumber,The length of the parameter startIndexOfDigitsAfterDecimalToCopy is 36.
Long Statement,System,MemoryExtensions,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\MemoryExtensions.cs,IndexOf,The length of the statement  "            return SpanHelpers.IndexOf<T>(ref span.DangerousGetPinnableReference()' span.Length' ref value.DangerousGetPinnableReference()' value.Length); " is 142.
Long Statement,System,MemoryExtensions,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\MemoryExtensions.cs,LastIndexOf,The length of the statement  "            return SpanHelpers.LastIndexOf<T>(ref span.DangerousGetPinnableReference()' span.Length' ref value.DangerousGetPinnableReference()' value.Length); " is 146.
Long Statement,System,MemoryExtensions,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\MemoryExtensions.cs,SequenceEqual,The length of the statement  "            return length == second.Length && SpanHelpers.SequenceEqual(ref first.DangerousGetPinnableReference()' ref second.DangerousGetPinnableReference()' length); " is 155.
Long Statement,System,MemoryExtensions,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\MemoryExtensions.cs,IndexOf,The length of the statement  "            return SpanHelpers.IndexOf<T>(ref span.DangerousGetPinnableReference()' span.Length' ref value.DangerousGetPinnableReference()' value.Length); " is 142.
Long Statement,System,MemoryExtensions,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\MemoryExtensions.cs,LastIndexOf,The length of the statement  "            return SpanHelpers.LastIndexOf<T>(ref span.DangerousGetPinnableReference()' span.Length' ref value.DangerousGetPinnableReference()' value.Length); " is 146.
Long Statement,System,MemoryExtensions,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\MemoryExtensions.cs,IndexOfAny,The length of the statement  "            return SpanHelpers.IndexOfAny(ref span.DangerousGetPinnableReference()' span.Length' ref values.DangerousGetPinnableReference()' values.Length); " is 144.
Long Statement,System,MemoryExtensions,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\MemoryExtensions.cs,IndexOfAny,The length of the statement  "            return SpanHelpers.IndexOfAny(ref span.DangerousGetPinnableReference()' span.Length' ref values.DangerousGetPinnableReference()' values.Length); " is 144.
Long Statement,System,MemoryExtensions,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\MemoryExtensions.cs,SequenceEqual,The length of the statement  "            return length == second.Length && SpanHelpers.SequenceEqual(ref first.DangerousGetPinnableReference()' ref second.DangerousGetPinnableReference()' length); " is 155.
Long Statement,System,MemoryExtensions,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\MemoryExtensions.cs,StartsWith,The length of the statement  "            return valueLength <= span.Length && SpanHelpers.SequenceEqual(ref span.DangerousGetPinnableReference()' ref value.DangerousGetPinnableReference()' valueLength); " is 161.
Long Statement,System,MemoryExtensions,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\MemoryExtensions.cs,StartsWith,The length of the statement  "            return valueLength <= span.Length && SpanHelpers.SequenceEqual(ref span.DangerousGetPinnableReference()' ref value.DangerousGetPinnableReference()' valueLength); " is 161.
Long Statement,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOf,The length of the statement  "                Debug.Assert(0 <= index && index <= searchSpaceLength); // Ensures no deceptive underflows in the computation of "remainingSearchSpaceLength". " is 142.
Long Statement,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,LastIndexOf,The length of the statement  "                Debug.Assert(0 <= index && index <= searchSpaceLength); // Ensures no deceptive underflows in the computation of "remainingSearchSpaceLength". " is 142.
Long Statement,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOf,The length of the statement  "                Debug.Assert(0 <= index && index <= searchSpaceLength); // Ensures no deceptive underflows in the computation of "remainingSearchSpaceLength". " is 142.
Long Statement,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOf,The length of the statement  "                    var vMatches = Vector.Equals(vComparison' Unsafe.ReadUnaligned<Vector<byte>>(ref Unsafe.AddByteOffset(ref searchSpace' index))); " is 128.
Long Statement,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,LastIndexOf,The length of the statement  "                Debug.Assert(0 <= index && index <= searchSpaceLength); // Ensures no deceptive underflows in the computation of "remainingSearchSpaceLength". " is 142.
Long Statement,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,LastIndexOf,The length of the statement  "                    var vMatches = Vector.Equals(vComparison' Unsafe.ReadUnaligned<Vector<byte>>(ref Unsafe.AddByteOffset(ref searchSpace' index - Vector<byte>.Count))); " is 149.
Long Statement,System,ThrowHelper,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\ThrowHelper.cs,CreateArgumentOutOfRangeException_PrecisionTooLarge,The length of the statement  "{ return new ArgumentOutOfRangeException("precision"' SR.Format(SR.Argument_PrecisionTooLarge' StandardFormat.MaxPrecision)); }" is 127.
Long Statement,System,Number,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Number\Number.cs,NumberBufferToDecimal,The length of the statement  "                // To avoid risking an app-compat issue with pre 4.5 (where some app was illegally using Reflection to examine the internal scale bits)' we'll only force " is 153.
Long Statement,System,Number,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Number\Number.cs,NumberBufferToDecimal,The length of the statement  "                            // If we got here' the magnitude portion overflowed and wrapped back to 0 as the magnitude was already at the MaxValue point: " is 125.
Long Statement,System,Number,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Number\Number.cs,NumberBufferToDecimal,The length of the statement  "                return false; // Rounding may have caused its own overflow. For example' parsing "0.792281625142643375935439503355e29" will get here. " is 133.
Long Statement,System,Number,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Number\Number.cs,DecimalToNumber,The length of the statement  "            // Starting from the least significant bits' carve off nine decimal digits at a time and string-ize them (using the end of the " is 126.
Long Statement,System,Number,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Number\Number.cs,DecimalToNumber,The length of the statement  "            // We've finally whittled the decimal down to uint.MaxValue or less. Write the remaining digits but make sure no leading zeros get written. " is 139.
Long Statement,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,DecodeFromUtf8,The length of the statement  "            // Last bytes could have padding characters' so process them separately and treat them as valid only if isFinalBlock is true " is 124.
Long Statement,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormat,The length of the statement  "                        // This DEBUG segment exists to close a code coverage hole inside TryFormatDecimalG(). Because we don't call RoundNumber() on this path' we have no way to feed " is 159.
Long Statement,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormat,The length of the statement  "                        // TryFormatDecimalG() a number where trailing zeros before the decimal point have been cropped. So if the chance comes up' we'll crop the zeroes " is 145.
Long Statement,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormat,The length of the statement  "                        Debug.Assert(!(number.Digits[0] == 0 && number.IsNegative));   // For Decimals' -0 must print as normal 0. As it happens' Number.RoundNumber already ensures this invariant. " is 172.
Long Statement,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormat,The length of the statement  "                        Debug.Assert(!(number.Digits[0] == 0 && number.IsNegative));   // For Decimals' -0 must print as normal 0. As it happens' Number.RoundNumber already ensures this invariant. " is 172.
Long Statement,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDecimalE,The length of the statement  "                buffer[dstIndex++] = (byte)'0';  // Special case: number before the decimal point is exactly 0: Number does not store the zero in this case. " is 140.
Long Statement,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDecimalE,The length of the statement  "            Debug.Assert(exponent < Number.DECIMAL_PRECISION' "If you're trying to reuse this routine for double/float' you'll need to review the code carefully for Decimal-specific assumptions."); " is 185.
Long Statement,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDecimalF,The length of the statement  "                + ((precision == 0) ? 0 : (precision + 1)); // if specified precision != 0' the decimal point and the digits after the decimal point (padded with zeroes if needed) " is 163.
Long Statement,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDecimalG,The length of the statement  "                    numBytesNeeded += 1 + (-scale); // A fraction of the form 0.ddd. Need to emit the non-stored 0 before the decimal point plus (-scale) leading 0's after the decimal point. " is 170.
Long Statement,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDecimalG,The length of the statement  "                numBytesNeeded = ((scale <= 0) ? 1 : scale); // An integral. Just emit the digits before the decimal point (minimum 1) and no decimal point. " is 140.
Long Statement,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatFloatingPoint,The length of the statement  "                Debug.Assert(utf16Text[i] < 128' "A culture-invariant ToString() of a floating point expected to produce ASCII characters only."); " is 130.
Long Statement,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatInt64,The length of the statement  "                        throw new NotSupportedException(SR.Argument_GWithPrecisionNotSupported); // With a precision' 'G' can produce exponential format' even for integers. " is 148.
Long Statement,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatInt64N,The length of the statement  "                    Debug.Assert(success' "TryFormatInt64N already did a full buffer length check so this subcall should never have failed."); " is 122.
Long Statement,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatUInt64,The length of the statement  "                        throw new NotSupportedException(SR.Argument_GWithPrecisionNotSupported); // With a precision' 'G' can produce exponential format' even for integers. " is 148.
Long Statement,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormat,The length of the statement  "                            fractionDigits = (longForm || constant) ? Utf8Constants.DateTimeNumFractionDigits : FormattingHelpers.CountFractionDigits(fraction); " is 132.
Long Statement,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParse,The length of the statement  "                        value = dateTimeOffset.DateTime;  // (returns a DateTimeKind.Unspecified to match DateTime.ParseExact(). Maybe better to return UtcDateTime instead?) " is 149.
Long Statement,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParse,The length of the statement  "                        value = dateTimeOffset.DateTime;  // (returns a DateTimeKind.Unspecified to match DateTime.ParseExact(). Maybe better to return UtcDateTime instead?) " is 149.
Long Statement,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetDefault,The length of the statement  "            if (!TryCreateDateTimeOffset(dateTime: dateTime' offsetNegative: sign == Utf8Constants.Minus' offsetHours: offsetHours' offsetMinutes: offsetMinutes' out value)) " is 161.
Long Statement,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeG,The length of the statement  "            if (!TryCreateDateTimeOffsetInterpretingDataAsLocalTime(year: year' month: month' day: day' hour: hour' minute: minute' second: second' fraction: 0' out valueAsOffset)) " is 168.
Long Statement,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryCreateDateTimeOffset,The length of the statement  "                // If we got here' the combination of the DateTime + UTC offset strayed outside the 1..9999 year range. This case seems rare enough " is 131.
Long Statement,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryCreateDateTimeOffset,The length of the statement  "                // that it's better to catch the exception rather than replicate DateTime's range checking (which it's going to do anyway.) " is 123.
Long Statement,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryCreateDateTimeOffset,The length of the statement  "            if (!TryCreateDateTime(year: year' month: month' day: day' hour: hour' minute: minute' second: second' fraction: fraction' kind: DateTimeKind.Unspecified' out DateTime dateTime)) " is 178.
Long Statement,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryCreateDateTimeOffset,The length of the statement  "            if (!TryCreateDateTimeOffset(dateTime: dateTime' offsetNegative: offsetNegative' offsetHours: offsetHours' offsetMinutes: offsetMinutes' out value)) " is 148.
Long Statement,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryCreateDateTimeOffsetInterpretingDataAsLocalTime,The length of the statement  "            if (!TryCreateDateTime(year: year' month: month' day: day' hour: hour' minute: minute' second: second' fraction: fraction' DateTimeKind.Local' out DateTime dateTime)) " is 166.
Long Statement,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryCreateDateTimeOffsetInterpretingDataAsLocalTime,The length of the statement  "                // If we got here' the combination of the DateTime + UTC offset strayed outside the 1..9999 year range. This case seems rare enough " is 131.
Long Statement,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryCreateDateTimeOffsetInterpretingDataAsLocalTime,The length of the statement  "                // that it's better to catch the exception rather than replicate DateTime's range checking (which it's going to do anyway.) " is 123.
Long Statement,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryCreateDateTime,The length of the statement  "            Debug.Assert(year <= 9999); // All of our callers to date parse the year from fixed 4-digit fields so this value is trusted. " is 124.
Long Statement,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryCreateDateTime,The length of the statement  "            Debug.Assert(fraction >= 0 && fraction <= Utf8Constants.MaxDateTimeFraction); // All of our callers to date parse the fraction from fixed 7-digit fields so this value is trusted. " is 178.
Long Statement,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryCreateDateTime,The length of the statement  "            int totalDays = (yearMinusOne * 365) + (yearMinusOne / 4) - (yearMinusOne / 100) + (yearMinusOne / 400) + days[month - 1] + day - 1; " is 132.
Long Statement,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The length of the statement  "                fraction = (int)(digit1 * 1000000 + digit2 * 100000 + digit3 * 10000 + digit4 * 1000 + digit5 * 100 + digit6 * 10 + digit7); " is 124.
Long Statement,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The length of the statement  "                if (!TryCreateDateTimeOffsetInterpretingDataAsLocalTime(year: year' month: month' day: day' hour: hour' minute: minute' second: second' fraction: fraction' out value)) " is 167.
Long Statement,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The length of the statement  "                if (!TryCreateDateTimeOffset(year: year' month: month' day: day' hour: hour' minute: minute' second: second' fraction: fraction' offsetNegative: false' offsetHours: 0' offsetMinutes: 0' out value)) " is 197.
Long Statement,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The length of the statement  "            if (!TryCreateDateTimeOffset(year: year' month: month' day: day' hour: hour' minute: minute' second: second' fraction: fraction' offsetNegative: offsetChar == Utf8Constants.Minus' offsetHours: offsetHours' offsetMinutes: offsetMinutes' out value)) " is 247.
Long Statement,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetR,The length of the statement  "            if (!TryCreateDateTimeOffset(year: year' month: month' day: day' hour: hour' minute: minute' second: second' fraction: 0' offsetNegative: false' offsetHours: 0' offsetMinutes: 0' out dateTimeOffset)) " is 199.
Long Statement,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParse,The length of the statement  "            // More compat with .NET behavior - whether or not a 0 keeps the negative sign depends on whether it an "integer" 0 or a "fractional" 0 " is 135.
Long Statement,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParse,The length of the statement  "            return TryParseAsSpecialFloatingPoint<float>(text' float.PositiveInfinity' float.NegativeInfinity' float.NaN' out value' out bytesConsumed); " is 140.
Long Statement,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParse,The length of the statement  "            return TryParseAsSpecialFloatingPoint<double>(text' double.PositiveInfinity' double.NegativeInfinity' double.NaN' out value' out bytesConsumed); " is 144.
Long Statement,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseUInt16X,The length of the statement  "                // Length is greater than Parsers.Int16OverflowLengthHex; overflow is only possible after Parsers.Int16OverflowLengthHex " is 120.
Long Statement,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseUInt32X,The length of the statement  "                // Length is greater than Parsers.Int32OverflowLengthHex; overflow is only possible after Parsers.Int32OverflowLengthHex " is 120.
Long Statement,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseUInt64X,The length of the statement  "                // Length is greater than Parsers.Int64OverflowLengthHex; overflow is only possible after Parsers.Int64OverflowLengthHex " is 120.
Long Statement,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseNumber,The length of the statement  "            Debug.Assert(number.Digits[0] == 0 && number.Scale == 0 && !number.IsNegative' "Number not initialized to default(NumberBuffer)"); " is 130.
Long Statement,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseNumber,The length of the statement  "                    // Not copied any digits to the Number struct yet. This means we must continue discarding leading zeroes even though they appeared after the decimal point. " is 155.
Long Statement,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseNumber,The length of the statement  "                int numDigitsAfterDecimalToCopy = Math.Min(srcIndex - startIndexOfDigitsAfterDecimalToCopy' NumberBuffer.BufferSize - dstIndex - 1); " is 132.
Long Statement,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseNumber,The length of the statement  "                // We "should" really NUL terminate' but there are multiple places we'd have to do this and it is a precondition that the caller pass in a fully zero=initialized Number. " is 169.
Long Statement,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseTimeSpanBigG,The length of the statement  "            if (!TryCreateTimeSpan(isNegative: isNegative' days: days' hours: hours' minutes: minutes' seconds: seconds' fraction: fraction' out value)) " is 140.
Long Statement,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseTimeSpanBigG,The length of the statement  "            // There cannot legally be a sixth number. If the next character is a period or colon' treat this as a error as it's likely " is 123.
Long Statement,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseTimeSpanC,The length of the statement  "                    success = TryCreateTimeSpan(isNegative: isNegative' days: s.V1' hours: 0' minutes: 0' seconds: 0' fraction: 0' out value); " is 122.
Long Statement,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseTimeSpanC,The length of the statement  "                    success = TryCreateTimeSpan(isNegative: isNegative' days: 0' hours: s.V1' minutes: s.V2' seconds: 0' fraction: 0' out value); " is 125.
Long Statement,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseTimeSpanC,The length of the statement  "                    success = TryCreateTimeSpan(isNegative: isNegative' days: s.V1' hours: s.V2' minutes: s.V3' seconds: 0' fraction: 0' out value); " is 128.
Long Statement,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseTimeSpanC,The length of the statement  "                    success = TryCreateTimeSpan(isNegative: isNegative' days: 0' hours: s.V1' minutes: s.V2' seconds: s.V3' fraction: 0' out value); " is 128.
Long Statement,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseTimeSpanC,The length of the statement  "                    success = TryCreateTimeSpan(isNegative: isNegative' days: s.V1' hours: s.V2' minutes: s.V3' seconds: s.V4' fraction: 0' out value); " is 131.
Long Statement,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseTimeSpanC,The length of the statement  "                    success = TryCreateTimeSpan(isNegative: isNegative' days: 0' hours: s.V1' minutes: s.V2' seconds: s.V3' fraction: s.V4' out value); " is 131.
Long Statement,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseTimeSpanC,The length of the statement  "                    success = TryCreateTimeSpan(isNegative: isNegative' days: s.V1' hours: s.V2' minutes: s.V3' seconds: s.V4' fraction: s.V5' out value); " is 134.
Long Statement,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryCreateTimeSpan,The length of the statement  "            Debug.Assert(fraction <= Utf8Constants.MaxDateTimeFraction); // This value comes from TryParseTimeSpanFraction() which already rejects any fraction string longer than 7 digits. " is 176.
Long Statement,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryCreateTimeSpan,The length of the statement  "            long millisecondsWithoutFraction = (((long)days) * 3600 * 24 + ((long)hours) * 3600 + ((long)minutes) * 60 + seconds) * 1000; " is 125.
Long Statement,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseTimeSpanLittleG,The length of the statement  "                    success = TryCreateTimeSpan(isNegative: isNegative' days: s.V1' hours: 0' minutes: 0' seconds: 0' fraction: 0' out value); " is 122.
Long Statement,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseTimeSpanLittleG,The length of the statement  "                    success = TryCreateTimeSpan(isNegative: isNegative' days: 0' hours: s.V1' minutes: s.V2' seconds: 0' fraction: 0' out value); " is 125.
Long Statement,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseTimeSpanLittleG,The length of the statement  "                    success = TryCreateTimeSpan(isNegative: isNegative' days: 0' hours: s.V1' minutes: s.V2' seconds: s.V3' fraction: 0' out value); " is 128.
Long Statement,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseTimeSpanLittleG,The length of the statement  "                    success = TryCreateTimeSpan(isNegative: isNegative' days: s.V1' hours: s.V2' minutes: s.V3' seconds: s.V4' fraction: 0' out value); " is 131.
Long Statement,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseTimeSpanLittleG,The length of the statement  "                    success = TryCreateTimeSpan(isNegative: isNegative' days: 0' hours: s.V1' minutes: s.V2' seconds: s.V3' fraction: s.V4' out value); " is 131.
Long Statement,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseTimeSpanLittleG,The length of the statement  "                    success = TryCreateTimeSpan(isNegative: isNegative' days: s.V1' hours: s.V2' minutes: s.V3' seconds: s.V4' fraction: s.V5' out value); " is 134.
Long Statement,System.Buffers.Text,TimeSpanSplitter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.TimeSpanSplitter.cs,TrySplitTimeSpan,The length of the statement  "                // From here' we terminate on anything that's not a digit' ':' or '.' The '.' is only allowed after at least three components have " is 130.
Long Statement,System.Buffers.Text,TimeSpanSplitter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.TimeSpanSplitter.cs,TrySplitTimeSpan,The length of the statement  "                // been specified. If we see it earlier' we'll assume that's an error and fail out rather than treating it as the end of data. " is 126.
Long Statement,System.Buffers.Text,TimeSpanSplitter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.TimeSpanSplitter.cs,TrySplitTimeSpan,The length of the statement  "                // Split out the second number (if any) For the 'c' format' a period might validly appear here as it;s used both to separate the day and the fraction - however' " is 160.
Long Statement,System.Buffers.Text,TimeSpanSplitter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.TimeSpanSplitter.cs,TrySplitTimeSpan,The length of the statement  "                // the fraction is always the fourth component at earliest' so if we do see a period at this stage' always parse the integer as a regular integer' not as " is 153.
Long Statement,System.Buffers.Text,TimeSpanSplitter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.TimeSpanSplitter.cs,TrySplitTimeSpan,The length of the statement  "                // There cannot legally be a sixth number. If the next character is a period or colon' treat this as a error as it's likely " is 123.
Complex Conditional,System,Number,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Number\Number.cs,NumberBufferToDecimal,The conditional expression  "((e > 0) || ((*p != 0) && (e > -28))) &&                         ((d.High < 0x19999999) || ((d.High == 0x19999999) &&                                                    ((d.Mid < 0x99999999) || ((d.Mid == 0x99999999) &&                                                                              ((d.Low < 0x99999999) || ((d.Low == 0x99999999) &&                                                                                                        (*p <= '5')))))))"  is complex.
Complex Conditional,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParse,The conditional expression  "(text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e')"  is complex.
Complex Conditional,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParse,The conditional expression  "(text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e')"  is complex.
Complex Conditional,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeG,The conditional expression  "digit1 > 9 || digit2 > 9 || digit3 > 9 || digit4 > 9"  is complex.
Complex Conditional,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The conditional expression  "digit1 > 9 || digit2 > 9 || digit3 > 9 || digit4 > 9"  is complex.
Complex Conditional,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The conditional expression  "digit1 > 9 || digit2 > 9 || digit3 > 9 || digit4 > 9 || digit5 > 9 || digit6 > 9 || digit7 > 9"  is complex.
Complex Conditional,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetR,The conditional expression  "digit1 > 9 || digit2 > 9 || digit3 > 9 || digit4 > 9"  is complex.
Complex Conditional,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseAsSpecialFloatingPoint,The conditional expression  "text.Length >= 8 &&                  text[0] == 'I' && text[1] == 'n' && text[2] == 'f' && text[3] == 'i' &&                  text[4] == 'n' && text[5] == 'i' && text[6] == 't' && text[7] == 'y'"  is complex.
Complex Conditional,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseAsSpecialFloatingPoint,The conditional expression  "text.Length >= 9 &&                  text[0] == Utf8Constants.Minus &&                  text[1] == 'I' && text[2] == 'n' && text[3] == 'f' && text[4] == 'i' &&                  text[5] == 'n' && text[6] == 'i' && text[7] == 't' && text[8] == 'y'"  is complex.
Complex Conditional,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseAsSpecialFloatingPoint,The conditional expression  "text.Length >= 3 &&                  text[0] == 'N' && text[1] == 'a' && text[2] == 'N'"  is complex.
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOf,The following statement contains a magic number: while (length >= 8)              {                  length -= 8;                    if (value.Equals(Unsafe.Add(ref searchSpace' index)))                      goto Found;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 1)))                      goto Found1;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 2)))                      goto Found2;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 3)))                      goto Found3;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 4)))                      goto Found4;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 5)))                      goto Found5;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 6)))                      goto Found6;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 7)))                      goto Found7;                    index += 8;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOf,The following statement contains a magic number: while (length >= 8)              {                  length -= 8;                    if (value.Equals(Unsafe.Add(ref searchSpace' index)))                      goto Found;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 1)))                      goto Found1;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 2)))                      goto Found2;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 3)))                      goto Found3;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 4)))                      goto Found4;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 5)))                      goto Found5;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 6)))                      goto Found6;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 7)))                      goto Found7;                    index += 8;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOf,The following statement contains a magic number: while (length >= 8)              {                  length -= 8;                    if (value.Equals(Unsafe.Add(ref searchSpace' index)))                      goto Found;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 1)))                      goto Found1;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 2)))                      goto Found2;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 3)))                      goto Found3;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 4)))                      goto Found4;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 5)))                      goto Found5;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 6)))                      goto Found6;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 7)))                      goto Found7;                    index += 8;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOf,The following statement contains a magic number: while (length >= 8)              {                  length -= 8;                    if (value.Equals(Unsafe.Add(ref searchSpace' index)))                      goto Found;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 1)))                      goto Found1;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 2)))                      goto Found2;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 3)))                      goto Found3;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 4)))                      goto Found4;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 5)))                      goto Found5;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 6)))                      goto Found6;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 7)))                      goto Found7;                    index += 8;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOf,The following statement contains a magic number: while (length >= 8)              {                  length -= 8;                    if (value.Equals(Unsafe.Add(ref searchSpace' index)))                      goto Found;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 1)))                      goto Found1;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 2)))                      goto Found2;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 3)))                      goto Found3;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 4)))                      goto Found4;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 5)))                      goto Found5;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 6)))                      goto Found6;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 7)))                      goto Found7;                    index += 8;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOf,The following statement contains a magic number: while (length >= 8)              {                  length -= 8;                    if (value.Equals(Unsafe.Add(ref searchSpace' index)))                      goto Found;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 1)))                      goto Found1;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 2)))                      goto Found2;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 3)))                      goto Found3;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 4)))                      goto Found4;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 5)))                      goto Found5;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 6)))                      goto Found6;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 7)))                      goto Found7;                    index += 8;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOf,The following statement contains a magic number: while (length >= 8)              {                  length -= 8;                    if (value.Equals(Unsafe.Add(ref searchSpace' index)))                      goto Found;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 1)))                      goto Found1;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 2)))                      goto Found2;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 3)))                      goto Found3;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 4)))                      goto Found4;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 5)))                      goto Found5;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 6)))                      goto Found6;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 7)))                      goto Found7;                    index += 8;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOf,The following statement contains a magic number: while (length >= 8)              {                  length -= 8;                    if (value.Equals(Unsafe.Add(ref searchSpace' index)))                      goto Found;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 1)))                      goto Found1;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 2)))                      goto Found2;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 3)))                      goto Found3;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 4)))                      goto Found4;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 5)))                      goto Found5;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 6)))                      goto Found6;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 7)))                      goto Found7;                    index += 8;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOf,The following statement contains a magic number: while (length >= 8)              {                  length -= 8;                    if (value.Equals(Unsafe.Add(ref searchSpace' index)))                      goto Found;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 1)))                      goto Found1;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 2)))                      goto Found2;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 3)))                      goto Found3;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 4)))                      goto Found4;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 5)))                      goto Found5;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 6)))                      goto Found6;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 7)))                      goto Found7;                    index += 8;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOf,The following statement contains a magic number: if (length >= 4)              {                  length -= 4;                    if (value.Equals(Unsafe.Add(ref searchSpace' index)))                      goto Found;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 1)))                      goto Found1;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 2)))                      goto Found2;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 3)))                      goto Found3;                    index += 4;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOf,The following statement contains a magic number: if (length >= 4)              {                  length -= 4;                    if (value.Equals(Unsafe.Add(ref searchSpace' index)))                      goto Found;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 1)))                      goto Found1;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 2)))                      goto Found2;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 3)))                      goto Found3;                    index += 4;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOf,The following statement contains a magic number: if (length >= 4)              {                  length -= 4;                    if (value.Equals(Unsafe.Add(ref searchSpace' index)))                      goto Found;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 1)))                      goto Found1;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 2)))                      goto Found2;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 3)))                      goto Found3;                    index += 4;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOf,The following statement contains a magic number: if (length >= 4)              {                  length -= 4;                    if (value.Equals(Unsafe.Add(ref searchSpace' index)))                      goto Found;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 1)))                      goto Found1;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 2)))                      goto Found2;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 3)))                      goto Found3;                    index += 4;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOf,The following statement contains a magic number: if (length >= 4)              {                  length -= 4;                    if (value.Equals(Unsafe.Add(ref searchSpace' index)))                      goto Found;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 1)))                      goto Found1;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 2)))                      goto Found2;                  if (value.Equals(Unsafe.Add(ref searchSpace' index + 3)))                      goto Found3;                    index += 4;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOf,The following statement contains a magic number: Found2:              return (int)(byte*)(index + 2);
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOf,The following statement contains a magic number: Found3:              return (int)(byte*)(index + 3);
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOf,The following statement contains a magic number: Found4:              return (int)(byte*)(index + 4);
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOf,The following statement contains a magic number: Found5:              return (int)(byte*)(index + 5);
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOf,The following statement contains a magic number: Found6:              return (int)(byte*)(index + 6);
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOf,The following statement contains a magic number: Found7:              return (int)(byte*)(index + 7);
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,LastIndexOf,The following statement contains a magic number: while (length >= 8)              {                  length -= 8;                    if (value.Equals(Unsafe.Add(ref searchSpace' length + 7)))                      goto Found7;                  if (value.Equals(Unsafe.Add(ref searchSpace' length + 6)))                      goto Found6;                  if (value.Equals(Unsafe.Add(ref searchSpace' length + 5)))                      goto Found5;                  if (value.Equals(Unsafe.Add(ref searchSpace' length + 4)))                      goto Found4;                  if (value.Equals(Unsafe.Add(ref searchSpace' length + 3)))                      goto Found3;                  if (value.Equals(Unsafe.Add(ref searchSpace' length + 2)))                      goto Found2;                  if (value.Equals(Unsafe.Add(ref searchSpace' length + 1)))                      goto Found1;                  if (value.Equals(Unsafe.Add(ref searchSpace' length)))                      goto Found;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,LastIndexOf,The following statement contains a magic number: while (length >= 8)              {                  length -= 8;                    if (value.Equals(Unsafe.Add(ref searchSpace' length + 7)))                      goto Found7;                  if (value.Equals(Unsafe.Add(ref searchSpace' length + 6)))                      goto Found6;                  if (value.Equals(Unsafe.Add(ref searchSpace' length + 5)))                      goto Found5;                  if (value.Equals(Unsafe.Add(ref searchSpace' length + 4)))                      goto Found4;                  if (value.Equals(Unsafe.Add(ref searchSpace' length + 3)))                      goto Found3;                  if (value.Equals(Unsafe.Add(ref searchSpace' length + 2)))                      goto Found2;                  if (value.Equals(Unsafe.Add(ref searchSpace' length + 1)))                      goto Found1;                  if (value.Equals(Unsafe.Add(ref searchSpace' length)))                      goto Found;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,LastIndexOf,The following statement contains a magic number: while (length >= 8)              {                  length -= 8;                    if (value.Equals(Unsafe.Add(ref searchSpace' length + 7)))                      goto Found7;                  if (value.Equals(Unsafe.Add(ref searchSpace' length + 6)))                      goto Found6;                  if (value.Equals(Unsafe.Add(ref searchSpace' length + 5)))                      goto Found5;                  if (value.Equals(Unsafe.Add(ref searchSpace' length + 4)))                      goto Found4;                  if (value.Equals(Unsafe.Add(ref searchSpace' length + 3)))                      goto Found3;                  if (value.Equals(Unsafe.Add(ref searchSpace' length + 2)))                      goto Found2;                  if (value.Equals(Unsafe.Add(ref searchSpace' length + 1)))                      goto Found1;                  if (value.Equals(Unsafe.Add(ref searchSpace' length)))                      goto Found;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,LastIndexOf,The following statement contains a magic number: while (length >= 8)              {                  length -= 8;                    if (value.Equals(Unsafe.Add(ref searchSpace' length + 7)))                      goto Found7;                  if (value.Equals(Unsafe.Add(ref searchSpace' length + 6)))                      goto Found6;                  if (value.Equals(Unsafe.Add(ref searchSpace' length + 5)))                      goto Found5;                  if (value.Equals(Unsafe.Add(ref searchSpace' length + 4)))                      goto Found4;                  if (value.Equals(Unsafe.Add(ref searchSpace' length + 3)))                      goto Found3;                  if (value.Equals(Unsafe.Add(ref searchSpace' length + 2)))                      goto Found2;                  if (value.Equals(Unsafe.Add(ref searchSpace' length + 1)))                      goto Found1;                  if (value.Equals(Unsafe.Add(ref searchSpace' length)))                      goto Found;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,LastIndexOf,The following statement contains a magic number: while (length >= 8)              {                  length -= 8;                    if (value.Equals(Unsafe.Add(ref searchSpace' length + 7)))                      goto Found7;                  if (value.Equals(Unsafe.Add(ref searchSpace' length + 6)))                      goto Found6;                  if (value.Equals(Unsafe.Add(ref searchSpace' length + 5)))                      goto Found5;                  if (value.Equals(Unsafe.Add(ref searchSpace' length + 4)))                      goto Found4;                  if (value.Equals(Unsafe.Add(ref searchSpace' length + 3)))                      goto Found3;                  if (value.Equals(Unsafe.Add(ref searchSpace' length + 2)))                      goto Found2;                  if (value.Equals(Unsafe.Add(ref searchSpace' length + 1)))                      goto Found1;                  if (value.Equals(Unsafe.Add(ref searchSpace' length)))                      goto Found;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,LastIndexOf,The following statement contains a magic number: while (length >= 8)              {                  length -= 8;                    if (value.Equals(Unsafe.Add(ref searchSpace' length + 7)))                      goto Found7;                  if (value.Equals(Unsafe.Add(ref searchSpace' length + 6)))                      goto Found6;                  if (value.Equals(Unsafe.Add(ref searchSpace' length + 5)))                      goto Found5;                  if (value.Equals(Unsafe.Add(ref searchSpace' length + 4)))                      goto Found4;                  if (value.Equals(Unsafe.Add(ref searchSpace' length + 3)))                      goto Found3;                  if (value.Equals(Unsafe.Add(ref searchSpace' length + 2)))                      goto Found2;                  if (value.Equals(Unsafe.Add(ref searchSpace' length + 1)))                      goto Found1;                  if (value.Equals(Unsafe.Add(ref searchSpace' length)))                      goto Found;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,LastIndexOf,The following statement contains a magic number: while (length >= 8)              {                  length -= 8;                    if (value.Equals(Unsafe.Add(ref searchSpace' length + 7)))                      goto Found7;                  if (value.Equals(Unsafe.Add(ref searchSpace' length + 6)))                      goto Found6;                  if (value.Equals(Unsafe.Add(ref searchSpace' length + 5)))                      goto Found5;                  if (value.Equals(Unsafe.Add(ref searchSpace' length + 4)))                      goto Found4;                  if (value.Equals(Unsafe.Add(ref searchSpace' length + 3)))                      goto Found3;                  if (value.Equals(Unsafe.Add(ref searchSpace' length + 2)))                      goto Found2;                  if (value.Equals(Unsafe.Add(ref searchSpace' length + 1)))                      goto Found1;                  if (value.Equals(Unsafe.Add(ref searchSpace' length)))                      goto Found;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,LastIndexOf,The following statement contains a magic number: while (length >= 8)              {                  length -= 8;                    if (value.Equals(Unsafe.Add(ref searchSpace' length + 7)))                      goto Found7;                  if (value.Equals(Unsafe.Add(ref searchSpace' length + 6)))                      goto Found6;                  if (value.Equals(Unsafe.Add(ref searchSpace' length + 5)))                      goto Found5;                  if (value.Equals(Unsafe.Add(ref searchSpace' length + 4)))                      goto Found4;                  if (value.Equals(Unsafe.Add(ref searchSpace' length + 3)))                      goto Found3;                  if (value.Equals(Unsafe.Add(ref searchSpace' length + 2)))                      goto Found2;                  if (value.Equals(Unsafe.Add(ref searchSpace' length + 1)))                      goto Found1;                  if (value.Equals(Unsafe.Add(ref searchSpace' length)))                      goto Found;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,LastIndexOf,The following statement contains a magic number: if (length >= 4)              {                  length -= 4;                    if (value.Equals(Unsafe.Add(ref searchSpace' length + 3)))                      goto Found3;                  if (value.Equals(Unsafe.Add(ref searchSpace' length + 2)))                      goto Found2;                  if (value.Equals(Unsafe.Add(ref searchSpace' length + 1)))                      goto Found1;                  if (value.Equals(Unsafe.Add(ref searchSpace' length)))                      goto Found;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,LastIndexOf,The following statement contains a magic number: if (length >= 4)              {                  length -= 4;                    if (value.Equals(Unsafe.Add(ref searchSpace' length + 3)))                      goto Found3;                  if (value.Equals(Unsafe.Add(ref searchSpace' length + 2)))                      goto Found2;                  if (value.Equals(Unsafe.Add(ref searchSpace' length + 1)))                      goto Found1;                  if (value.Equals(Unsafe.Add(ref searchSpace' length)))                      goto Found;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,LastIndexOf,The following statement contains a magic number: if (length >= 4)              {                  length -= 4;                    if (value.Equals(Unsafe.Add(ref searchSpace' length + 3)))                      goto Found3;                  if (value.Equals(Unsafe.Add(ref searchSpace' length + 2)))                      goto Found2;                  if (value.Equals(Unsafe.Add(ref searchSpace' length + 1)))                      goto Found1;                  if (value.Equals(Unsafe.Add(ref searchSpace' length)))                      goto Found;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,LastIndexOf,The following statement contains a magic number: if (length >= 4)              {                  length -= 4;                    if (value.Equals(Unsafe.Add(ref searchSpace' length + 3)))                      goto Found3;                  if (value.Equals(Unsafe.Add(ref searchSpace' length + 2)))                      goto Found2;                  if (value.Equals(Unsafe.Add(ref searchSpace' length + 1)))                      goto Found1;                  if (value.Equals(Unsafe.Add(ref searchSpace' length)))                      goto Found;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,LastIndexOf,The following statement contains a magic number: Found2:              return length + 2;
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,LastIndexOf,The following statement contains a magic number: Found3:              return length + 3;
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,LastIndexOf,The following statement contains a magic number: Found4:              return length + 4;
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,LastIndexOf,The following statement contains a magic number: Found5:              return length + 5;
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,LastIndexOf,The following statement contains a magic number: Found6:              return length + 6;
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,LastIndexOf,The following statement contains a magic number: Found7:              return length + 7;
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,SequenceEqual,The following statement contains a magic number: while (length >= 8)              {                  length -= 8;                    if (!Unsafe.Add(ref first' index).Equals(Unsafe.Add(ref second' index)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 1).Equals(Unsafe.Add(ref second' index + 1)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 2).Equals(Unsafe.Add(ref second' index + 2)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 3).Equals(Unsafe.Add(ref second' index + 3)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 4).Equals(Unsafe.Add(ref second' index + 4)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 5).Equals(Unsafe.Add(ref second' index + 5)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 6).Equals(Unsafe.Add(ref second' index + 6)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 7).Equals(Unsafe.Add(ref second' index + 7)))                      goto NotEqual;                    index += 8;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,SequenceEqual,The following statement contains a magic number: while (length >= 8)              {                  length -= 8;                    if (!Unsafe.Add(ref first' index).Equals(Unsafe.Add(ref second' index)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 1).Equals(Unsafe.Add(ref second' index + 1)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 2).Equals(Unsafe.Add(ref second' index + 2)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 3).Equals(Unsafe.Add(ref second' index + 3)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 4).Equals(Unsafe.Add(ref second' index + 4)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 5).Equals(Unsafe.Add(ref second' index + 5)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 6).Equals(Unsafe.Add(ref second' index + 6)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 7).Equals(Unsafe.Add(ref second' index + 7)))                      goto NotEqual;                    index += 8;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,SequenceEqual,The following statement contains a magic number: while (length >= 8)              {                  length -= 8;                    if (!Unsafe.Add(ref first' index).Equals(Unsafe.Add(ref second' index)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 1).Equals(Unsafe.Add(ref second' index + 1)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 2).Equals(Unsafe.Add(ref second' index + 2)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 3).Equals(Unsafe.Add(ref second' index + 3)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 4).Equals(Unsafe.Add(ref second' index + 4)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 5).Equals(Unsafe.Add(ref second' index + 5)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 6).Equals(Unsafe.Add(ref second' index + 6)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 7).Equals(Unsafe.Add(ref second' index + 7)))                      goto NotEqual;                    index += 8;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,SequenceEqual,The following statement contains a magic number: while (length >= 8)              {                  length -= 8;                    if (!Unsafe.Add(ref first' index).Equals(Unsafe.Add(ref second' index)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 1).Equals(Unsafe.Add(ref second' index + 1)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 2).Equals(Unsafe.Add(ref second' index + 2)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 3).Equals(Unsafe.Add(ref second' index + 3)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 4).Equals(Unsafe.Add(ref second' index + 4)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 5).Equals(Unsafe.Add(ref second' index + 5)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 6).Equals(Unsafe.Add(ref second' index + 6)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 7).Equals(Unsafe.Add(ref second' index + 7)))                      goto NotEqual;                    index += 8;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,SequenceEqual,The following statement contains a magic number: while (length >= 8)              {                  length -= 8;                    if (!Unsafe.Add(ref first' index).Equals(Unsafe.Add(ref second' index)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 1).Equals(Unsafe.Add(ref second' index + 1)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 2).Equals(Unsafe.Add(ref second' index + 2)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 3).Equals(Unsafe.Add(ref second' index + 3)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 4).Equals(Unsafe.Add(ref second' index + 4)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 5).Equals(Unsafe.Add(ref second' index + 5)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 6).Equals(Unsafe.Add(ref second' index + 6)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 7).Equals(Unsafe.Add(ref second' index + 7)))                      goto NotEqual;                    index += 8;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,SequenceEqual,The following statement contains a magic number: while (length >= 8)              {                  length -= 8;                    if (!Unsafe.Add(ref first' index).Equals(Unsafe.Add(ref second' index)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 1).Equals(Unsafe.Add(ref second' index + 1)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 2).Equals(Unsafe.Add(ref second' index + 2)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 3).Equals(Unsafe.Add(ref second' index + 3)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 4).Equals(Unsafe.Add(ref second' index + 4)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 5).Equals(Unsafe.Add(ref second' index + 5)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 6).Equals(Unsafe.Add(ref second' index + 6)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 7).Equals(Unsafe.Add(ref second' index + 7)))                      goto NotEqual;                    index += 8;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,SequenceEqual,The following statement contains a magic number: while (length >= 8)              {                  length -= 8;                    if (!Unsafe.Add(ref first' index).Equals(Unsafe.Add(ref second' index)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 1).Equals(Unsafe.Add(ref second' index + 1)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 2).Equals(Unsafe.Add(ref second' index + 2)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 3).Equals(Unsafe.Add(ref second' index + 3)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 4).Equals(Unsafe.Add(ref second' index + 4)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 5).Equals(Unsafe.Add(ref second' index + 5)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 6).Equals(Unsafe.Add(ref second' index + 6)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 7).Equals(Unsafe.Add(ref second' index + 7)))                      goto NotEqual;                    index += 8;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,SequenceEqual,The following statement contains a magic number: while (length >= 8)              {                  length -= 8;                    if (!Unsafe.Add(ref first' index).Equals(Unsafe.Add(ref second' index)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 1).Equals(Unsafe.Add(ref second' index + 1)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 2).Equals(Unsafe.Add(ref second' index + 2)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 3).Equals(Unsafe.Add(ref second' index + 3)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 4).Equals(Unsafe.Add(ref second' index + 4)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 5).Equals(Unsafe.Add(ref second' index + 5)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 6).Equals(Unsafe.Add(ref second' index + 6)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 7).Equals(Unsafe.Add(ref second' index + 7)))                      goto NotEqual;                    index += 8;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,SequenceEqual,The following statement contains a magic number: while (length >= 8)              {                  length -= 8;                    if (!Unsafe.Add(ref first' index).Equals(Unsafe.Add(ref second' index)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 1).Equals(Unsafe.Add(ref second' index + 1)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 2).Equals(Unsafe.Add(ref second' index + 2)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 3).Equals(Unsafe.Add(ref second' index + 3)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 4).Equals(Unsafe.Add(ref second' index + 4)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 5).Equals(Unsafe.Add(ref second' index + 5)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 6).Equals(Unsafe.Add(ref second' index + 6)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 7).Equals(Unsafe.Add(ref second' index + 7)))                      goto NotEqual;                    index += 8;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,SequenceEqual,The following statement contains a magic number: while (length >= 8)              {                  length -= 8;                    if (!Unsafe.Add(ref first' index).Equals(Unsafe.Add(ref second' index)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 1).Equals(Unsafe.Add(ref second' index + 1)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 2).Equals(Unsafe.Add(ref second' index + 2)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 3).Equals(Unsafe.Add(ref second' index + 3)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 4).Equals(Unsafe.Add(ref second' index + 4)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 5).Equals(Unsafe.Add(ref second' index + 5)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 6).Equals(Unsafe.Add(ref second' index + 6)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 7).Equals(Unsafe.Add(ref second' index + 7)))                      goto NotEqual;                    index += 8;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,SequenceEqual,The following statement contains a magic number: while (length >= 8)              {                  length -= 8;                    if (!Unsafe.Add(ref first' index).Equals(Unsafe.Add(ref second' index)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 1).Equals(Unsafe.Add(ref second' index + 1)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 2).Equals(Unsafe.Add(ref second' index + 2)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 3).Equals(Unsafe.Add(ref second' index + 3)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 4).Equals(Unsafe.Add(ref second' index + 4)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 5).Equals(Unsafe.Add(ref second' index + 5)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 6).Equals(Unsafe.Add(ref second' index + 6)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 7).Equals(Unsafe.Add(ref second' index + 7)))                      goto NotEqual;                    index += 8;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,SequenceEqual,The following statement contains a magic number: while (length >= 8)              {                  length -= 8;                    if (!Unsafe.Add(ref first' index).Equals(Unsafe.Add(ref second' index)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 1).Equals(Unsafe.Add(ref second' index + 1)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 2).Equals(Unsafe.Add(ref second' index + 2)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 3).Equals(Unsafe.Add(ref second' index + 3)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 4).Equals(Unsafe.Add(ref second' index + 4)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 5).Equals(Unsafe.Add(ref second' index + 5)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 6).Equals(Unsafe.Add(ref second' index + 6)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 7).Equals(Unsafe.Add(ref second' index + 7)))                      goto NotEqual;                    index += 8;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,SequenceEqual,The following statement contains a magic number: while (length >= 8)              {                  length -= 8;                    if (!Unsafe.Add(ref first' index).Equals(Unsafe.Add(ref second' index)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 1).Equals(Unsafe.Add(ref second' index + 1)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 2).Equals(Unsafe.Add(ref second' index + 2)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 3).Equals(Unsafe.Add(ref second' index + 3)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 4).Equals(Unsafe.Add(ref second' index + 4)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 5).Equals(Unsafe.Add(ref second' index + 5)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 6).Equals(Unsafe.Add(ref second' index + 6)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 7).Equals(Unsafe.Add(ref second' index + 7)))                      goto NotEqual;                    index += 8;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,SequenceEqual,The following statement contains a magic number: while (length >= 8)              {                  length -= 8;                    if (!Unsafe.Add(ref first' index).Equals(Unsafe.Add(ref second' index)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 1).Equals(Unsafe.Add(ref second' index + 1)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 2).Equals(Unsafe.Add(ref second' index + 2)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 3).Equals(Unsafe.Add(ref second' index + 3)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 4).Equals(Unsafe.Add(ref second' index + 4)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 5).Equals(Unsafe.Add(ref second' index + 5)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 6).Equals(Unsafe.Add(ref second' index + 6)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 7).Equals(Unsafe.Add(ref second' index + 7)))                      goto NotEqual;                    index += 8;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,SequenceEqual,The following statement contains a magic number: while (length >= 8)              {                  length -= 8;                    if (!Unsafe.Add(ref first' index).Equals(Unsafe.Add(ref second' index)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 1).Equals(Unsafe.Add(ref second' index + 1)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 2).Equals(Unsafe.Add(ref second' index + 2)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 3).Equals(Unsafe.Add(ref second' index + 3)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 4).Equals(Unsafe.Add(ref second' index + 4)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 5).Equals(Unsafe.Add(ref second' index + 5)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 6).Equals(Unsafe.Add(ref second' index + 6)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 7).Equals(Unsafe.Add(ref second' index + 7)))                      goto NotEqual;                    index += 8;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,SequenceEqual,The following statement contains a magic number: if (length >= 4)              {                  length -= 4;                    if (!Unsafe.Add(ref first' index).Equals(Unsafe.Add(ref second' index)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 1).Equals(Unsafe.Add(ref second' index + 1)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 2).Equals(Unsafe.Add(ref second' index + 2)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 3).Equals(Unsafe.Add(ref second' index + 3)))                      goto NotEqual;                    index += 4;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,SequenceEqual,The following statement contains a magic number: if (length >= 4)              {                  length -= 4;                    if (!Unsafe.Add(ref first' index).Equals(Unsafe.Add(ref second' index)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 1).Equals(Unsafe.Add(ref second' index + 1)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 2).Equals(Unsafe.Add(ref second' index + 2)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 3).Equals(Unsafe.Add(ref second' index + 3)))                      goto NotEqual;                    index += 4;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,SequenceEqual,The following statement contains a magic number: if (length >= 4)              {                  length -= 4;                    if (!Unsafe.Add(ref first' index).Equals(Unsafe.Add(ref second' index)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 1).Equals(Unsafe.Add(ref second' index + 1)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 2).Equals(Unsafe.Add(ref second' index + 2)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 3).Equals(Unsafe.Add(ref second' index + 3)))                      goto NotEqual;                    index += 4;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,SequenceEqual,The following statement contains a magic number: if (length >= 4)              {                  length -= 4;                    if (!Unsafe.Add(ref first' index).Equals(Unsafe.Add(ref second' index)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 1).Equals(Unsafe.Add(ref second' index + 1)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 2).Equals(Unsafe.Add(ref second' index + 2)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 3).Equals(Unsafe.Add(ref second' index + 3)))                      goto NotEqual;                    index += 4;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,SequenceEqual,The following statement contains a magic number: if (length >= 4)              {                  length -= 4;                    if (!Unsafe.Add(ref first' index).Equals(Unsafe.Add(ref second' index)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 1).Equals(Unsafe.Add(ref second' index + 1)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 2).Equals(Unsafe.Add(ref second' index + 2)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 3).Equals(Unsafe.Add(ref second' index + 3)))                      goto NotEqual;                    index += 4;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,SequenceEqual,The following statement contains a magic number: if (length >= 4)              {                  length -= 4;                    if (!Unsafe.Add(ref first' index).Equals(Unsafe.Add(ref second' index)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 1).Equals(Unsafe.Add(ref second' index + 1)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 2).Equals(Unsafe.Add(ref second' index + 2)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 3).Equals(Unsafe.Add(ref second' index + 3)))                      goto NotEqual;                    index += 4;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,SequenceEqual,The following statement contains a magic number: if (length >= 4)              {                  length -= 4;                    if (!Unsafe.Add(ref first' index).Equals(Unsafe.Add(ref second' index)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 1).Equals(Unsafe.Add(ref second' index + 1)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 2).Equals(Unsafe.Add(ref second' index + 2)))                      goto NotEqual;                  if (!Unsafe.Add(ref first' index + 3).Equals(Unsafe.Add(ref second' index + 3)))                      goto NotEqual;                    index += 4;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOf,The following statement contains a magic number: if (Vector.IsHardwareAccelerated && length >= Vector<byte>.Count * 2)              {                  unchecked                  {                      int unaligned = (int)(byte*)Unsafe.AsPointer(ref searchSpace) & (Vector<byte>.Count - 1);                      nLength = (IntPtr)(uint)((Vector<byte>.Count - unaligned) & (Vector<byte>.Count - 1));                  }              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOf,The following statement contains a magic number: SequentialScan:  #endif              while ((byte*)nLength >= (byte*)8)              {                  nLength -= 8;                    if (uValue == Unsafe.Add(ref searchSpace' index))                      goto Found;                  if (uValue == Unsafe.Add(ref searchSpace' index + 1))                      goto Found1;                  if (uValue == Unsafe.Add(ref searchSpace' index + 2))                      goto Found2;                  if (uValue == Unsafe.Add(ref searchSpace' index + 3))                      goto Found3;                  if (uValue == Unsafe.Add(ref searchSpace' index + 4))                      goto Found4;                  if (uValue == Unsafe.Add(ref searchSpace' index + 5))                      goto Found5;                  if (uValue == Unsafe.Add(ref searchSpace' index + 6))                      goto Found6;                  if (uValue == Unsafe.Add(ref searchSpace' index + 7))                      goto Found7;                    index += 8;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOf,The following statement contains a magic number: SequentialScan:  #endif              while ((byte*)nLength >= (byte*)8)              {                  nLength -= 8;                    if (uValue == Unsafe.Add(ref searchSpace' index))                      goto Found;                  if (uValue == Unsafe.Add(ref searchSpace' index + 1))                      goto Found1;                  if (uValue == Unsafe.Add(ref searchSpace' index + 2))                      goto Found2;                  if (uValue == Unsafe.Add(ref searchSpace' index + 3))                      goto Found3;                  if (uValue == Unsafe.Add(ref searchSpace' index + 4))                      goto Found4;                  if (uValue == Unsafe.Add(ref searchSpace' index + 5))                      goto Found5;                  if (uValue == Unsafe.Add(ref searchSpace' index + 6))                      goto Found6;                  if (uValue == Unsafe.Add(ref searchSpace' index + 7))                      goto Found7;                    index += 8;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOf,The following statement contains a magic number: SequentialScan:  #endif              while ((byte*)nLength >= (byte*)8)              {                  nLength -= 8;                    if (uValue == Unsafe.Add(ref searchSpace' index))                      goto Found;                  if (uValue == Unsafe.Add(ref searchSpace' index + 1))                      goto Found1;                  if (uValue == Unsafe.Add(ref searchSpace' index + 2))                      goto Found2;                  if (uValue == Unsafe.Add(ref searchSpace' index + 3))                      goto Found3;                  if (uValue == Unsafe.Add(ref searchSpace' index + 4))                      goto Found4;                  if (uValue == Unsafe.Add(ref searchSpace' index + 5))                      goto Found5;                  if (uValue == Unsafe.Add(ref searchSpace' index + 6))                      goto Found6;                  if (uValue == Unsafe.Add(ref searchSpace' index + 7))                      goto Found7;                    index += 8;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOf,The following statement contains a magic number: SequentialScan:  #endif              while ((byte*)nLength >= (byte*)8)              {                  nLength -= 8;                    if (uValue == Unsafe.Add(ref searchSpace' index))                      goto Found;                  if (uValue == Unsafe.Add(ref searchSpace' index + 1))                      goto Found1;                  if (uValue == Unsafe.Add(ref searchSpace' index + 2))                      goto Found2;                  if (uValue == Unsafe.Add(ref searchSpace' index + 3))                      goto Found3;                  if (uValue == Unsafe.Add(ref searchSpace' index + 4))                      goto Found4;                  if (uValue == Unsafe.Add(ref searchSpace' index + 5))                      goto Found5;                  if (uValue == Unsafe.Add(ref searchSpace' index + 6))                      goto Found6;                  if (uValue == Unsafe.Add(ref searchSpace' index + 7))                      goto Found7;                    index += 8;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOf,The following statement contains a magic number: SequentialScan:  #endif              while ((byte*)nLength >= (byte*)8)              {                  nLength -= 8;                    if (uValue == Unsafe.Add(ref searchSpace' index))                      goto Found;                  if (uValue == Unsafe.Add(ref searchSpace' index + 1))                      goto Found1;                  if (uValue == Unsafe.Add(ref searchSpace' index + 2))                      goto Found2;                  if (uValue == Unsafe.Add(ref searchSpace' index + 3))                      goto Found3;                  if (uValue == Unsafe.Add(ref searchSpace' index + 4))                      goto Found4;                  if (uValue == Unsafe.Add(ref searchSpace' index + 5))                      goto Found5;                  if (uValue == Unsafe.Add(ref searchSpace' index + 6))                      goto Found6;                  if (uValue == Unsafe.Add(ref searchSpace' index + 7))                      goto Found7;                    index += 8;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOf,The following statement contains a magic number: SequentialScan:  #endif              while ((byte*)nLength >= (byte*)8)              {                  nLength -= 8;                    if (uValue == Unsafe.Add(ref searchSpace' index))                      goto Found;                  if (uValue == Unsafe.Add(ref searchSpace' index + 1))                      goto Found1;                  if (uValue == Unsafe.Add(ref searchSpace' index + 2))                      goto Found2;                  if (uValue == Unsafe.Add(ref searchSpace' index + 3))                      goto Found3;                  if (uValue == Unsafe.Add(ref searchSpace' index + 4))                      goto Found4;                  if (uValue == Unsafe.Add(ref searchSpace' index + 5))                      goto Found5;                  if (uValue == Unsafe.Add(ref searchSpace' index + 6))                      goto Found6;                  if (uValue == Unsafe.Add(ref searchSpace' index + 7))                      goto Found7;                    index += 8;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOf,The following statement contains a magic number: SequentialScan:  #endif              while ((byte*)nLength >= (byte*)8)              {                  nLength -= 8;                    if (uValue == Unsafe.Add(ref searchSpace' index))                      goto Found;                  if (uValue == Unsafe.Add(ref searchSpace' index + 1))                      goto Found1;                  if (uValue == Unsafe.Add(ref searchSpace' index + 2))                      goto Found2;                  if (uValue == Unsafe.Add(ref searchSpace' index + 3))                      goto Found3;                  if (uValue == Unsafe.Add(ref searchSpace' index + 4))                      goto Found4;                  if (uValue == Unsafe.Add(ref searchSpace' index + 5))                      goto Found5;                  if (uValue == Unsafe.Add(ref searchSpace' index + 6))                      goto Found6;                  if (uValue == Unsafe.Add(ref searchSpace' index + 7))                      goto Found7;                    index += 8;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOf,The following statement contains a magic number: SequentialScan:  #endif              while ((byte*)nLength >= (byte*)8)              {                  nLength -= 8;                    if (uValue == Unsafe.Add(ref searchSpace' index))                      goto Found;                  if (uValue == Unsafe.Add(ref searchSpace' index + 1))                      goto Found1;                  if (uValue == Unsafe.Add(ref searchSpace' index + 2))                      goto Found2;                  if (uValue == Unsafe.Add(ref searchSpace' index + 3))                      goto Found3;                  if (uValue == Unsafe.Add(ref searchSpace' index + 4))                      goto Found4;                  if (uValue == Unsafe.Add(ref searchSpace' index + 5))                      goto Found5;                  if (uValue == Unsafe.Add(ref searchSpace' index + 6))                      goto Found6;                  if (uValue == Unsafe.Add(ref searchSpace' index + 7))                      goto Found7;                    index += 8;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOf,The following statement contains a magic number: SequentialScan:  #endif              while ((byte*)nLength >= (byte*)8)              {                  nLength -= 8;                    if (uValue == Unsafe.Add(ref searchSpace' index))                      goto Found;                  if (uValue == Unsafe.Add(ref searchSpace' index + 1))                      goto Found1;                  if (uValue == Unsafe.Add(ref searchSpace' index + 2))                      goto Found2;                  if (uValue == Unsafe.Add(ref searchSpace' index + 3))                      goto Found3;                  if (uValue == Unsafe.Add(ref searchSpace' index + 4))                      goto Found4;                  if (uValue == Unsafe.Add(ref searchSpace' index + 5))                      goto Found5;                  if (uValue == Unsafe.Add(ref searchSpace' index + 6))                      goto Found6;                  if (uValue == Unsafe.Add(ref searchSpace' index + 7))                      goto Found7;                    index += 8;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOf,The following statement contains a magic number: if ((byte*)nLength >= (byte*)4)              {                  nLength -= 4;                    if (uValue == Unsafe.Add(ref searchSpace' index))                      goto Found;                  if (uValue == Unsafe.Add(ref searchSpace' index + 1))                      goto Found1;                  if (uValue == Unsafe.Add(ref searchSpace' index + 2))                      goto Found2;                  if (uValue == Unsafe.Add(ref searchSpace' index + 3))                      goto Found3;                    index += 4;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOf,The following statement contains a magic number: if ((byte*)nLength >= (byte*)4)              {                  nLength -= 4;                    if (uValue == Unsafe.Add(ref searchSpace' index))                      goto Found;                  if (uValue == Unsafe.Add(ref searchSpace' index + 1))                      goto Found1;                  if (uValue == Unsafe.Add(ref searchSpace' index + 2))                      goto Found2;                  if (uValue == Unsafe.Add(ref searchSpace' index + 3))                      goto Found3;                    index += 4;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOf,The following statement contains a magic number: if ((byte*)nLength >= (byte*)4)              {                  nLength -= 4;                    if (uValue == Unsafe.Add(ref searchSpace' index))                      goto Found;                  if (uValue == Unsafe.Add(ref searchSpace' index + 1))                      goto Found1;                  if (uValue == Unsafe.Add(ref searchSpace' index + 2))                      goto Found2;                  if (uValue == Unsafe.Add(ref searchSpace' index + 3))                      goto Found3;                    index += 4;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOf,The following statement contains a magic number: if ((byte*)nLength >= (byte*)4)              {                  nLength -= 4;                    if (uValue == Unsafe.Add(ref searchSpace' index))                      goto Found;                  if (uValue == Unsafe.Add(ref searchSpace' index + 1))                      goto Found1;                  if (uValue == Unsafe.Add(ref searchSpace' index + 2))                      goto Found2;                  if (uValue == Unsafe.Add(ref searchSpace' index + 3))                      goto Found3;                    index += 4;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOf,The following statement contains a magic number: if ((byte*)nLength >= (byte*)4)              {                  nLength -= 4;                    if (uValue == Unsafe.Add(ref searchSpace' index))                      goto Found;                  if (uValue == Unsafe.Add(ref searchSpace' index + 1))                      goto Found1;                  if (uValue == Unsafe.Add(ref searchSpace' index + 2))                      goto Found2;                  if (uValue == Unsafe.Add(ref searchSpace' index + 3))                      goto Found3;                    index += 4;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOf,The following statement contains a magic number: Found2:              return (int)(byte*)(index + 2);
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOf,The following statement contains a magic number: Found3:              return (int)(byte*)(index + 3);
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOf,The following statement contains a magic number: Found4:              return (int)(byte*)(index + 4);
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOf,The following statement contains a magic number: Found5:              return (int)(byte*)(index + 5);
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOf,The following statement contains a magic number: Found6:              return (int)(byte*)(index + 6);
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOf,The following statement contains a magic number: Found7:              return (int)(byte*)(index + 7);
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,LastIndexOf,The following statement contains a magic number: if (Vector.IsHardwareAccelerated && length >= Vector<byte>.Count * 2)              {                  unchecked                  {                      int unaligned = (int)(byte*)Unsafe.AsPointer(ref searchSpace) & (Vector<byte>.Count - 1);                      nLength = (IntPtr)(((length & (Vector<byte>.Count - 1)) + unaligned) & (Vector<byte>.Count - 1));                  }              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,LastIndexOf,The following statement contains a magic number: SequentialScan:  #endif              while ((byte*)nLength >= (byte*)8)              {                  nLength -= 8;                  index -= 8;                    if (uValue == Unsafe.Add(ref searchSpace' index + 7))                      goto Found7;                  if (uValue == Unsafe.Add(ref searchSpace' index + 6))                      goto Found6;                  if (uValue == Unsafe.Add(ref searchSpace' index + 5))                      goto Found5;                  if (uValue == Unsafe.Add(ref searchSpace' index + 4))                      goto Found4;                  if (uValue == Unsafe.Add(ref searchSpace' index + 3))                      goto Found3;                  if (uValue == Unsafe.Add(ref searchSpace' index + 2))                      goto Found2;                  if (uValue == Unsafe.Add(ref searchSpace' index + 1))                      goto Found1;                  if (uValue == Unsafe.Add(ref searchSpace' index))                      goto Found;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,LastIndexOf,The following statement contains a magic number: SequentialScan:  #endif              while ((byte*)nLength >= (byte*)8)              {                  nLength -= 8;                  index -= 8;                    if (uValue == Unsafe.Add(ref searchSpace' index + 7))                      goto Found7;                  if (uValue == Unsafe.Add(ref searchSpace' index + 6))                      goto Found6;                  if (uValue == Unsafe.Add(ref searchSpace' index + 5))                      goto Found5;                  if (uValue == Unsafe.Add(ref searchSpace' index + 4))                      goto Found4;                  if (uValue == Unsafe.Add(ref searchSpace' index + 3))                      goto Found3;                  if (uValue == Unsafe.Add(ref searchSpace' index + 2))                      goto Found2;                  if (uValue == Unsafe.Add(ref searchSpace' index + 1))                      goto Found1;                  if (uValue == Unsafe.Add(ref searchSpace' index))                      goto Found;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,LastIndexOf,The following statement contains a magic number: SequentialScan:  #endif              while ((byte*)nLength >= (byte*)8)              {                  nLength -= 8;                  index -= 8;                    if (uValue == Unsafe.Add(ref searchSpace' index + 7))                      goto Found7;                  if (uValue == Unsafe.Add(ref searchSpace' index + 6))                      goto Found6;                  if (uValue == Unsafe.Add(ref searchSpace' index + 5))                      goto Found5;                  if (uValue == Unsafe.Add(ref searchSpace' index + 4))                      goto Found4;                  if (uValue == Unsafe.Add(ref searchSpace' index + 3))                      goto Found3;                  if (uValue == Unsafe.Add(ref searchSpace' index + 2))                      goto Found2;                  if (uValue == Unsafe.Add(ref searchSpace' index + 1))                      goto Found1;                  if (uValue == Unsafe.Add(ref searchSpace' index))                      goto Found;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,LastIndexOf,The following statement contains a magic number: SequentialScan:  #endif              while ((byte*)nLength >= (byte*)8)              {                  nLength -= 8;                  index -= 8;                    if (uValue == Unsafe.Add(ref searchSpace' index + 7))                      goto Found7;                  if (uValue == Unsafe.Add(ref searchSpace' index + 6))                      goto Found6;                  if (uValue == Unsafe.Add(ref searchSpace' index + 5))                      goto Found5;                  if (uValue == Unsafe.Add(ref searchSpace' index + 4))                      goto Found4;                  if (uValue == Unsafe.Add(ref searchSpace' index + 3))                      goto Found3;                  if (uValue == Unsafe.Add(ref searchSpace' index + 2))                      goto Found2;                  if (uValue == Unsafe.Add(ref searchSpace' index + 1))                      goto Found1;                  if (uValue == Unsafe.Add(ref searchSpace' index))                      goto Found;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,LastIndexOf,The following statement contains a magic number: SequentialScan:  #endif              while ((byte*)nLength >= (byte*)8)              {                  nLength -= 8;                  index -= 8;                    if (uValue == Unsafe.Add(ref searchSpace' index + 7))                      goto Found7;                  if (uValue == Unsafe.Add(ref searchSpace' index + 6))                      goto Found6;                  if (uValue == Unsafe.Add(ref searchSpace' index + 5))                      goto Found5;                  if (uValue == Unsafe.Add(ref searchSpace' index + 4))                      goto Found4;                  if (uValue == Unsafe.Add(ref searchSpace' index + 3))                      goto Found3;                  if (uValue == Unsafe.Add(ref searchSpace' index + 2))                      goto Found2;                  if (uValue == Unsafe.Add(ref searchSpace' index + 1))                      goto Found1;                  if (uValue == Unsafe.Add(ref searchSpace' index))                      goto Found;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,LastIndexOf,The following statement contains a magic number: SequentialScan:  #endif              while ((byte*)nLength >= (byte*)8)              {                  nLength -= 8;                  index -= 8;                    if (uValue == Unsafe.Add(ref searchSpace' index + 7))                      goto Found7;                  if (uValue == Unsafe.Add(ref searchSpace' index + 6))                      goto Found6;                  if (uValue == Unsafe.Add(ref searchSpace' index + 5))                      goto Found5;                  if (uValue == Unsafe.Add(ref searchSpace' index + 4))                      goto Found4;                  if (uValue == Unsafe.Add(ref searchSpace' index + 3))                      goto Found3;                  if (uValue == Unsafe.Add(ref searchSpace' index + 2))                      goto Found2;                  if (uValue == Unsafe.Add(ref searchSpace' index + 1))                      goto Found1;                  if (uValue == Unsafe.Add(ref searchSpace' index))                      goto Found;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,LastIndexOf,The following statement contains a magic number: SequentialScan:  #endif              while ((byte*)nLength >= (byte*)8)              {                  nLength -= 8;                  index -= 8;                    if (uValue == Unsafe.Add(ref searchSpace' index + 7))                      goto Found7;                  if (uValue == Unsafe.Add(ref searchSpace' index + 6))                      goto Found6;                  if (uValue == Unsafe.Add(ref searchSpace' index + 5))                      goto Found5;                  if (uValue == Unsafe.Add(ref searchSpace' index + 4))                      goto Found4;                  if (uValue == Unsafe.Add(ref searchSpace' index + 3))                      goto Found3;                  if (uValue == Unsafe.Add(ref searchSpace' index + 2))                      goto Found2;                  if (uValue == Unsafe.Add(ref searchSpace' index + 1))                      goto Found1;                  if (uValue == Unsafe.Add(ref searchSpace' index))                      goto Found;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,LastIndexOf,The following statement contains a magic number: SequentialScan:  #endif              while ((byte*)nLength >= (byte*)8)              {                  nLength -= 8;                  index -= 8;                    if (uValue == Unsafe.Add(ref searchSpace' index + 7))                      goto Found7;                  if (uValue == Unsafe.Add(ref searchSpace' index + 6))                      goto Found6;                  if (uValue == Unsafe.Add(ref searchSpace' index + 5))                      goto Found5;                  if (uValue == Unsafe.Add(ref searchSpace' index + 4))                      goto Found4;                  if (uValue == Unsafe.Add(ref searchSpace' index + 3))                      goto Found3;                  if (uValue == Unsafe.Add(ref searchSpace' index + 2))                      goto Found2;                  if (uValue == Unsafe.Add(ref searchSpace' index + 1))                      goto Found1;                  if (uValue == Unsafe.Add(ref searchSpace' index))                      goto Found;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,LastIndexOf,The following statement contains a magic number: SequentialScan:  #endif              while ((byte*)nLength >= (byte*)8)              {                  nLength -= 8;                  index -= 8;                    if (uValue == Unsafe.Add(ref searchSpace' index + 7))                      goto Found7;                  if (uValue == Unsafe.Add(ref searchSpace' index + 6))                      goto Found6;                  if (uValue == Unsafe.Add(ref searchSpace' index + 5))                      goto Found5;                  if (uValue == Unsafe.Add(ref searchSpace' index + 4))                      goto Found4;                  if (uValue == Unsafe.Add(ref searchSpace' index + 3))                      goto Found3;                  if (uValue == Unsafe.Add(ref searchSpace' index + 2))                      goto Found2;                  if (uValue == Unsafe.Add(ref searchSpace' index + 1))                      goto Found1;                  if (uValue == Unsafe.Add(ref searchSpace' index))                      goto Found;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,LastIndexOf,The following statement contains a magic number: if ((byte*)nLength >= (byte*)4)              {                  nLength -= 4;                  index -= 4;                    if (uValue == Unsafe.Add(ref searchSpace' index + 3))                      goto Found3;                  if (uValue == Unsafe.Add(ref searchSpace' index + 2))                      goto Found2;                  if (uValue == Unsafe.Add(ref searchSpace' index + 1))                      goto Found1;                  if (uValue == Unsafe.Add(ref searchSpace' index))                      goto Found;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,LastIndexOf,The following statement contains a magic number: if ((byte*)nLength >= (byte*)4)              {                  nLength -= 4;                  index -= 4;                    if (uValue == Unsafe.Add(ref searchSpace' index + 3))                      goto Found3;                  if (uValue == Unsafe.Add(ref searchSpace' index + 2))                      goto Found2;                  if (uValue == Unsafe.Add(ref searchSpace' index + 1))                      goto Found1;                  if (uValue == Unsafe.Add(ref searchSpace' index))                      goto Found;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,LastIndexOf,The following statement contains a magic number: if ((byte*)nLength >= (byte*)4)              {                  nLength -= 4;                  index -= 4;                    if (uValue == Unsafe.Add(ref searchSpace' index + 3))                      goto Found3;                  if (uValue == Unsafe.Add(ref searchSpace' index + 2))                      goto Found2;                  if (uValue == Unsafe.Add(ref searchSpace' index + 1))                      goto Found1;                  if (uValue == Unsafe.Add(ref searchSpace' index))                      goto Found;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,LastIndexOf,The following statement contains a magic number: if ((byte*)nLength >= (byte*)4)              {                  nLength -= 4;                  index -= 4;                    if (uValue == Unsafe.Add(ref searchSpace' index + 3))                      goto Found3;                  if (uValue == Unsafe.Add(ref searchSpace' index + 2))                      goto Found2;                  if (uValue == Unsafe.Add(ref searchSpace' index + 1))                      goto Found1;                  if (uValue == Unsafe.Add(ref searchSpace' index))                      goto Found;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,LastIndexOf,The following statement contains a magic number: if ((byte*)nLength >= (byte*)4)              {                  nLength -= 4;                  index -= 4;                    if (uValue == Unsafe.Add(ref searchSpace' index + 3))                      goto Found3;                  if (uValue == Unsafe.Add(ref searchSpace' index + 2))                      goto Found2;                  if (uValue == Unsafe.Add(ref searchSpace' index + 1))                      goto Found1;                  if (uValue == Unsafe.Add(ref searchSpace' index))                      goto Found;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,LastIndexOf,The following statement contains a magic number: Found2:              return (int)(byte*)(index + 2);
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,LastIndexOf,The following statement contains a magic number: Found3:              return (int)(byte*)(index + 3);
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,LastIndexOf,The following statement contains a magic number: Found4:              return (int)(byte*)(index + 4);
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,LastIndexOf,The following statement contains a magic number: Found5:              return (int)(byte*)(index + 5);
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,LastIndexOf,The following statement contains a magic number: Found6:              return (int)(byte*)(index + 6);
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,LastIndexOf,The following statement contains a magic number: Found7:              return (int)(byte*)(index + 7);
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOfAny,The following statement contains a magic number: if (Vector.IsHardwareAccelerated && length >= Vector<byte>.Count * 2)              {                  unchecked                  {                      int unaligned = (int)(byte*)Unsafe.AsPointer(ref searchSpace) & (Vector<byte>.Count - 1);                      nLength = (IntPtr)(uint)((Vector<byte>.Count - unaligned) & (Vector<byte>.Count - 1));                  }              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOfAny,The following statement contains a magic number: while ((byte*)nLength >= (byte*)8)              {                  nLength -= 8;                    lookUp = Unsafe.Add(ref searchSpace' index);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found;                  lookUp = Unsafe.Add(ref searchSpace' index + 1);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found1;                  lookUp = Unsafe.Add(ref searchSpace' index + 2);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found2;                  lookUp = Unsafe.Add(ref searchSpace' index + 3);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found3;                  lookUp = Unsafe.Add(ref searchSpace' index + 4);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found4;                  lookUp = Unsafe.Add(ref searchSpace' index + 5);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found5;                  lookUp = Unsafe.Add(ref searchSpace' index + 6);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found6;                  lookUp = Unsafe.Add(ref searchSpace' index + 7);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found7;                    index += 8;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOfAny,The following statement contains a magic number: while ((byte*)nLength >= (byte*)8)              {                  nLength -= 8;                    lookUp = Unsafe.Add(ref searchSpace' index);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found;                  lookUp = Unsafe.Add(ref searchSpace' index + 1);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found1;                  lookUp = Unsafe.Add(ref searchSpace' index + 2);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found2;                  lookUp = Unsafe.Add(ref searchSpace' index + 3);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found3;                  lookUp = Unsafe.Add(ref searchSpace' index + 4);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found4;                  lookUp = Unsafe.Add(ref searchSpace' index + 5);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found5;                  lookUp = Unsafe.Add(ref searchSpace' index + 6);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found6;                  lookUp = Unsafe.Add(ref searchSpace' index + 7);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found7;                    index += 8;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOfAny,The following statement contains a magic number: while ((byte*)nLength >= (byte*)8)              {                  nLength -= 8;                    lookUp = Unsafe.Add(ref searchSpace' index);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found;                  lookUp = Unsafe.Add(ref searchSpace' index + 1);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found1;                  lookUp = Unsafe.Add(ref searchSpace' index + 2);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found2;                  lookUp = Unsafe.Add(ref searchSpace' index + 3);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found3;                  lookUp = Unsafe.Add(ref searchSpace' index + 4);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found4;                  lookUp = Unsafe.Add(ref searchSpace' index + 5);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found5;                  lookUp = Unsafe.Add(ref searchSpace' index + 6);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found6;                  lookUp = Unsafe.Add(ref searchSpace' index + 7);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found7;                    index += 8;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOfAny,The following statement contains a magic number: while ((byte*)nLength >= (byte*)8)              {                  nLength -= 8;                    lookUp = Unsafe.Add(ref searchSpace' index);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found;                  lookUp = Unsafe.Add(ref searchSpace' index + 1);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found1;                  lookUp = Unsafe.Add(ref searchSpace' index + 2);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found2;                  lookUp = Unsafe.Add(ref searchSpace' index + 3);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found3;                  lookUp = Unsafe.Add(ref searchSpace' index + 4);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found4;                  lookUp = Unsafe.Add(ref searchSpace' index + 5);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found5;                  lookUp = Unsafe.Add(ref searchSpace' index + 6);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found6;                  lookUp = Unsafe.Add(ref searchSpace' index + 7);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found7;                    index += 8;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOfAny,The following statement contains a magic number: while ((byte*)nLength >= (byte*)8)              {                  nLength -= 8;                    lookUp = Unsafe.Add(ref searchSpace' index);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found;                  lookUp = Unsafe.Add(ref searchSpace' index + 1);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found1;                  lookUp = Unsafe.Add(ref searchSpace' index + 2);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found2;                  lookUp = Unsafe.Add(ref searchSpace' index + 3);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found3;                  lookUp = Unsafe.Add(ref searchSpace' index + 4);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found4;                  lookUp = Unsafe.Add(ref searchSpace' index + 5);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found5;                  lookUp = Unsafe.Add(ref searchSpace' index + 6);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found6;                  lookUp = Unsafe.Add(ref searchSpace' index + 7);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found7;                    index += 8;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOfAny,The following statement contains a magic number: while ((byte*)nLength >= (byte*)8)              {                  nLength -= 8;                    lookUp = Unsafe.Add(ref searchSpace' index);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found;                  lookUp = Unsafe.Add(ref searchSpace' index + 1);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found1;                  lookUp = Unsafe.Add(ref searchSpace' index + 2);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found2;                  lookUp = Unsafe.Add(ref searchSpace' index + 3);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found3;                  lookUp = Unsafe.Add(ref searchSpace' index + 4);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found4;                  lookUp = Unsafe.Add(ref searchSpace' index + 5);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found5;                  lookUp = Unsafe.Add(ref searchSpace' index + 6);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found6;                  lookUp = Unsafe.Add(ref searchSpace' index + 7);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found7;                    index += 8;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOfAny,The following statement contains a magic number: while ((byte*)nLength >= (byte*)8)              {                  nLength -= 8;                    lookUp = Unsafe.Add(ref searchSpace' index);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found;                  lookUp = Unsafe.Add(ref searchSpace' index + 1);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found1;                  lookUp = Unsafe.Add(ref searchSpace' index + 2);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found2;                  lookUp = Unsafe.Add(ref searchSpace' index + 3);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found3;                  lookUp = Unsafe.Add(ref searchSpace' index + 4);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found4;                  lookUp = Unsafe.Add(ref searchSpace' index + 5);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found5;                  lookUp = Unsafe.Add(ref searchSpace' index + 6);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found6;                  lookUp = Unsafe.Add(ref searchSpace' index + 7);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found7;                    index += 8;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOfAny,The following statement contains a magic number: while ((byte*)nLength >= (byte*)8)              {                  nLength -= 8;                    lookUp = Unsafe.Add(ref searchSpace' index);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found;                  lookUp = Unsafe.Add(ref searchSpace' index + 1);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found1;                  lookUp = Unsafe.Add(ref searchSpace' index + 2);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found2;                  lookUp = Unsafe.Add(ref searchSpace' index + 3);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found3;                  lookUp = Unsafe.Add(ref searchSpace' index + 4);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found4;                  lookUp = Unsafe.Add(ref searchSpace' index + 5);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found5;                  lookUp = Unsafe.Add(ref searchSpace' index + 6);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found6;                  lookUp = Unsafe.Add(ref searchSpace' index + 7);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found7;                    index += 8;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOfAny,The following statement contains a magic number: while ((byte*)nLength >= (byte*)8)              {                  nLength -= 8;                    lookUp = Unsafe.Add(ref searchSpace' index);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found;                  lookUp = Unsafe.Add(ref searchSpace' index + 1);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found1;                  lookUp = Unsafe.Add(ref searchSpace' index + 2);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found2;                  lookUp = Unsafe.Add(ref searchSpace' index + 3);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found3;                  lookUp = Unsafe.Add(ref searchSpace' index + 4);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found4;                  lookUp = Unsafe.Add(ref searchSpace' index + 5);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found5;                  lookUp = Unsafe.Add(ref searchSpace' index + 6);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found6;                  lookUp = Unsafe.Add(ref searchSpace' index + 7);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found7;                    index += 8;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOfAny,The following statement contains a magic number: if ((byte*)nLength >= (byte*)4)              {                  nLength -= 4;                    lookUp = Unsafe.Add(ref searchSpace' index);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found;                  lookUp = Unsafe.Add(ref searchSpace' index + 1);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found1;                  lookUp = Unsafe.Add(ref searchSpace' index + 2);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found2;                  lookUp = Unsafe.Add(ref searchSpace' index + 3);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found3;                    index += 4;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOfAny,The following statement contains a magic number: if ((byte*)nLength >= (byte*)4)              {                  nLength -= 4;                    lookUp = Unsafe.Add(ref searchSpace' index);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found;                  lookUp = Unsafe.Add(ref searchSpace' index + 1);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found1;                  lookUp = Unsafe.Add(ref searchSpace' index + 2);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found2;                  lookUp = Unsafe.Add(ref searchSpace' index + 3);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found3;                    index += 4;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOfAny,The following statement contains a magic number: if ((byte*)nLength >= (byte*)4)              {                  nLength -= 4;                    lookUp = Unsafe.Add(ref searchSpace' index);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found;                  lookUp = Unsafe.Add(ref searchSpace' index + 1);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found1;                  lookUp = Unsafe.Add(ref searchSpace' index + 2);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found2;                  lookUp = Unsafe.Add(ref searchSpace' index + 3);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found3;                    index += 4;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOfAny,The following statement contains a magic number: if ((byte*)nLength >= (byte*)4)              {                  nLength -= 4;                    lookUp = Unsafe.Add(ref searchSpace' index);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found;                  lookUp = Unsafe.Add(ref searchSpace' index + 1);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found1;                  lookUp = Unsafe.Add(ref searchSpace' index + 2);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found2;                  lookUp = Unsafe.Add(ref searchSpace' index + 3);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found3;                    index += 4;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOfAny,The following statement contains a magic number: if ((byte*)nLength >= (byte*)4)              {                  nLength -= 4;                    lookUp = Unsafe.Add(ref searchSpace' index);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found;                  lookUp = Unsafe.Add(ref searchSpace' index + 1);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found1;                  lookUp = Unsafe.Add(ref searchSpace' index + 2);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found2;                  lookUp = Unsafe.Add(ref searchSpace' index + 3);                  if (uValue0 == lookUp || uValue1 == lookUp)                      goto Found3;                    index += 4;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOfAny,The following statement contains a magic number: Found2:              return (int)(byte*)(index + 2);
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOfAny,The following statement contains a magic number: Found3:              return (int)(byte*)(index + 3);
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOfAny,The following statement contains a magic number: Found4:              return (int)(byte*)(index + 4);
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOfAny,The following statement contains a magic number: Found5:              return (int)(byte*)(index + 5);
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOfAny,The following statement contains a magic number: Found6:              return (int)(byte*)(index + 6);
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOfAny,The following statement contains a magic number: Found7:              return (int)(byte*)(index + 7);
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOfAny,The following statement contains a magic number: if (Vector.IsHardwareAccelerated && length >= Vector<byte>.Count * 2)              {                  unchecked                  {                      int unaligned = (int)(byte*)Unsafe.AsPointer(ref searchSpace) & (Vector<byte>.Count - 1);                      nLength = (IntPtr)(uint)((Vector<byte>.Count - unaligned) & (Vector<byte>.Count - 1));                  }              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOfAny,The following statement contains a magic number: while ((byte*)nLength >= (byte*)8)              {                  nLength -= 8;                    lookUp = Unsafe.Add(ref searchSpace' index);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found;                  lookUp = Unsafe.Add(ref searchSpace' index + 1);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found1;                  lookUp = Unsafe.Add(ref searchSpace' index + 2);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found2;                  lookUp = Unsafe.Add(ref searchSpace' index + 3);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found3;                  lookUp = Unsafe.Add(ref searchSpace' index + 4);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found4;                  lookUp = Unsafe.Add(ref searchSpace' index + 5);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found5;                  lookUp = Unsafe.Add(ref searchSpace' index + 6);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found6;                  lookUp = Unsafe.Add(ref searchSpace' index + 7);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found7;                    index += 8;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOfAny,The following statement contains a magic number: while ((byte*)nLength >= (byte*)8)              {                  nLength -= 8;                    lookUp = Unsafe.Add(ref searchSpace' index);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found;                  lookUp = Unsafe.Add(ref searchSpace' index + 1);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found1;                  lookUp = Unsafe.Add(ref searchSpace' index + 2);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found2;                  lookUp = Unsafe.Add(ref searchSpace' index + 3);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found3;                  lookUp = Unsafe.Add(ref searchSpace' index + 4);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found4;                  lookUp = Unsafe.Add(ref searchSpace' index + 5);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found5;                  lookUp = Unsafe.Add(ref searchSpace' index + 6);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found6;                  lookUp = Unsafe.Add(ref searchSpace' index + 7);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found7;                    index += 8;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOfAny,The following statement contains a magic number: while ((byte*)nLength >= (byte*)8)              {                  nLength -= 8;                    lookUp = Unsafe.Add(ref searchSpace' index);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found;                  lookUp = Unsafe.Add(ref searchSpace' index + 1);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found1;                  lookUp = Unsafe.Add(ref searchSpace' index + 2);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found2;                  lookUp = Unsafe.Add(ref searchSpace' index + 3);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found3;                  lookUp = Unsafe.Add(ref searchSpace' index + 4);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found4;                  lookUp = Unsafe.Add(ref searchSpace' index + 5);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found5;                  lookUp = Unsafe.Add(ref searchSpace' index + 6);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found6;                  lookUp = Unsafe.Add(ref searchSpace' index + 7);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found7;                    index += 8;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOfAny,The following statement contains a magic number: while ((byte*)nLength >= (byte*)8)              {                  nLength -= 8;                    lookUp = Unsafe.Add(ref searchSpace' index);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found;                  lookUp = Unsafe.Add(ref searchSpace' index + 1);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found1;                  lookUp = Unsafe.Add(ref searchSpace' index + 2);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found2;                  lookUp = Unsafe.Add(ref searchSpace' index + 3);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found3;                  lookUp = Unsafe.Add(ref searchSpace' index + 4);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found4;                  lookUp = Unsafe.Add(ref searchSpace' index + 5);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found5;                  lookUp = Unsafe.Add(ref searchSpace' index + 6);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found6;                  lookUp = Unsafe.Add(ref searchSpace' index + 7);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found7;                    index += 8;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOfAny,The following statement contains a magic number: while ((byte*)nLength >= (byte*)8)              {                  nLength -= 8;                    lookUp = Unsafe.Add(ref searchSpace' index);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found;                  lookUp = Unsafe.Add(ref searchSpace' index + 1);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found1;                  lookUp = Unsafe.Add(ref searchSpace' index + 2);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found2;                  lookUp = Unsafe.Add(ref searchSpace' index + 3);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found3;                  lookUp = Unsafe.Add(ref searchSpace' index + 4);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found4;                  lookUp = Unsafe.Add(ref searchSpace' index + 5);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found5;                  lookUp = Unsafe.Add(ref searchSpace' index + 6);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found6;                  lookUp = Unsafe.Add(ref searchSpace' index + 7);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found7;                    index += 8;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOfAny,The following statement contains a magic number: while ((byte*)nLength >= (byte*)8)              {                  nLength -= 8;                    lookUp = Unsafe.Add(ref searchSpace' index);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found;                  lookUp = Unsafe.Add(ref searchSpace' index + 1);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found1;                  lookUp = Unsafe.Add(ref searchSpace' index + 2);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found2;                  lookUp = Unsafe.Add(ref searchSpace' index + 3);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found3;                  lookUp = Unsafe.Add(ref searchSpace' index + 4);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found4;                  lookUp = Unsafe.Add(ref searchSpace' index + 5);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found5;                  lookUp = Unsafe.Add(ref searchSpace' index + 6);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found6;                  lookUp = Unsafe.Add(ref searchSpace' index + 7);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found7;                    index += 8;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOfAny,The following statement contains a magic number: while ((byte*)nLength >= (byte*)8)              {                  nLength -= 8;                    lookUp = Unsafe.Add(ref searchSpace' index);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found;                  lookUp = Unsafe.Add(ref searchSpace' index + 1);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found1;                  lookUp = Unsafe.Add(ref searchSpace' index + 2);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found2;                  lookUp = Unsafe.Add(ref searchSpace' index + 3);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found3;                  lookUp = Unsafe.Add(ref searchSpace' index + 4);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found4;                  lookUp = Unsafe.Add(ref searchSpace' index + 5);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found5;                  lookUp = Unsafe.Add(ref searchSpace' index + 6);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found6;                  lookUp = Unsafe.Add(ref searchSpace' index + 7);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found7;                    index += 8;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOfAny,The following statement contains a magic number: while ((byte*)nLength >= (byte*)8)              {                  nLength -= 8;                    lookUp = Unsafe.Add(ref searchSpace' index);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found;                  lookUp = Unsafe.Add(ref searchSpace' index + 1);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found1;                  lookUp = Unsafe.Add(ref searchSpace' index + 2);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found2;                  lookUp = Unsafe.Add(ref searchSpace' index + 3);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found3;                  lookUp = Unsafe.Add(ref searchSpace' index + 4);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found4;                  lookUp = Unsafe.Add(ref searchSpace' index + 5);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found5;                  lookUp = Unsafe.Add(ref searchSpace' index + 6);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found6;                  lookUp = Unsafe.Add(ref searchSpace' index + 7);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found7;                    index += 8;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOfAny,The following statement contains a magic number: while ((byte*)nLength >= (byte*)8)              {                  nLength -= 8;                    lookUp = Unsafe.Add(ref searchSpace' index);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found;                  lookUp = Unsafe.Add(ref searchSpace' index + 1);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found1;                  lookUp = Unsafe.Add(ref searchSpace' index + 2);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found2;                  lookUp = Unsafe.Add(ref searchSpace' index + 3);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found3;                  lookUp = Unsafe.Add(ref searchSpace' index + 4);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found4;                  lookUp = Unsafe.Add(ref searchSpace' index + 5);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found5;                  lookUp = Unsafe.Add(ref searchSpace' index + 6);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found6;                  lookUp = Unsafe.Add(ref searchSpace' index + 7);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found7;                    index += 8;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOfAny,The following statement contains a magic number: if ((byte*)nLength >= (byte*)4)              {                  nLength -= 4;                    lookUp = Unsafe.Add(ref searchSpace' index);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found;                  lookUp = Unsafe.Add(ref searchSpace' index + 1);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found1;                  lookUp = Unsafe.Add(ref searchSpace' index + 2);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found2;                  lookUp = Unsafe.Add(ref searchSpace' index + 3);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found3;                    index += 4;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOfAny,The following statement contains a magic number: if ((byte*)nLength >= (byte*)4)              {                  nLength -= 4;                    lookUp = Unsafe.Add(ref searchSpace' index);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found;                  lookUp = Unsafe.Add(ref searchSpace' index + 1);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found1;                  lookUp = Unsafe.Add(ref searchSpace' index + 2);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found2;                  lookUp = Unsafe.Add(ref searchSpace' index + 3);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found3;                    index += 4;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOfAny,The following statement contains a magic number: if ((byte*)nLength >= (byte*)4)              {                  nLength -= 4;                    lookUp = Unsafe.Add(ref searchSpace' index);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found;                  lookUp = Unsafe.Add(ref searchSpace' index + 1);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found1;                  lookUp = Unsafe.Add(ref searchSpace' index + 2);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found2;                  lookUp = Unsafe.Add(ref searchSpace' index + 3);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found3;                    index += 4;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOfAny,The following statement contains a magic number: if ((byte*)nLength >= (byte*)4)              {                  nLength -= 4;                    lookUp = Unsafe.Add(ref searchSpace' index);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found;                  lookUp = Unsafe.Add(ref searchSpace' index + 1);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found1;                  lookUp = Unsafe.Add(ref searchSpace' index + 2);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found2;                  lookUp = Unsafe.Add(ref searchSpace' index + 3);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found3;                    index += 4;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOfAny,The following statement contains a magic number: if ((byte*)nLength >= (byte*)4)              {                  nLength -= 4;                    lookUp = Unsafe.Add(ref searchSpace' index);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found;                  lookUp = Unsafe.Add(ref searchSpace' index + 1);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found1;                  lookUp = Unsafe.Add(ref searchSpace' index + 2);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found2;                  lookUp = Unsafe.Add(ref searchSpace' index + 3);                  if (uValue0 == lookUp || uValue1 == lookUp || uValue2 == lookUp)                      goto Found3;                    index += 4;              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOfAny,The following statement contains a magic number: Found2:              return (int)(byte*)(index + 2);
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOfAny,The following statement contains a magic number: Found3:              return (int)(byte*)(index + 3);
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOfAny,The following statement contains a magic number: Found4:              return (int)(byte*)(index + 4);
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOfAny,The following statement contains a magic number: Found5:              return (int)(byte*)(index + 5);
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOfAny,The following statement contains a magic number: Found6:              return (int)(byte*)(index + 6);
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,IndexOfAny,The following statement contains a magic number: Found7:              return (int)(byte*)(index + 7);
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,LocateFirstFoundByte,The following statement contains a magic number: return i * 8 + LocateFirstFoundByte(candidate);
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,LocateLastFoundByte,The following statement contains a magic number: return i * 8 + LocateLastFoundByte(candidate);
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,LocateFirstFoundByte,The following statement contains a magic number: unchecked              {                  // Flag least significant power of two bit                  var powerOfTwoFlag = match ^ (match - 1);                  // Shift all powers of two into the high byte and extract                  return (int)((powerOfTwoFlag * XorPowerOfTwoToHighByte) >> 57);              }
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,LocateLastFoundByte,The following statement contains a magic number: int index = 7;
Magic Number,System,SpanHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\SpanHelpers.T.cs,LocateLastFoundByte,The following statement contains a magic number: while ((long)match > 0)              {                  match = match << 8;                  index--;              }
Magic Number,System,DecimalDecCalc,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Number\Decimal.DecCalc.cs,D32DivMod1E9,The following statement contains a magic number: ulong n = (ulong)hi32 << 32 | lo32;
Magic Number,System,DecimalDecCalc,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Number\Decimal.DecCalc.cs,D32DivMod1E9,The following statement contains a magic number: lo32 = (uint)(n / 1000000000);
Magic Number,System,DecimalDecCalc,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Number\Decimal.DecCalc.cs,D32DivMod1E9,The following statement contains a magic number: return (uint)(n % 1000000000);
Magic Number,System,Number,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Number\Number.cs,NumberBufferToDecimal,The following statement contains a magic number: if (*p == 0)              {                  // To avoid risking an app-compat issue with pre 4.5 (where some app was illegally using Reflection to examine the internal scale bits)' we'll only force                  // the scale to 0 if the scale was previously positive (previously' such cases were unparsable to a bug.)                  if (e > 0)                  {                      e = 0;                  }              }              else              {                  if (e > DECIMAL_PRECISION)                      return false;                    while (((e > 0) || ((*p != 0) && (e > -28))) &&                         ((d.High < 0x19999999) || ((d.High == 0x19999999) &&                                                    ((d.Mid < 0x99999999) || ((d.Mid == 0x99999999) &&                                                                              ((d.Low < 0x99999999) || ((d.Low == 0x99999999) &&                                                                                                        (*p <= '5'))))))))                  {                      DecimalDecCalc.DecMul10(ref d);                      if (*p != 0)                          DecimalDecCalc.DecAddInt32(ref d' (uint)(*p++ - '0'));                      e--;                  }                    if (*p++ >= '5')                  {                      bool round = true;                      if ((*(p - 1) == '5') && ((*(p - 2) % 2) == 0))                      {                          // Check if previous digit is even' only if the when we are unsure whether hows to do                          // Banker's rounding. For digits > 5 we will be rounding up anyway.                          int count = 20; // Look at the next 20 digits to check to round                          while ((*p == '0') && (count != 0))                          {                              p++;                              count--;                          }                          if ((*p == '\0') || (count == 0))                              round = false;// Do nothing                      }                        if (round)                      {                          DecimalDecCalc.DecAddInt32(ref d' 1);                          if ((d.High | d.Mid | d.Low) == 0)                          {                              // If we got here' the magnitude portion overflowed and wrapped back to 0 as the magnitude was already at the MaxValue point:                              //                              //     79'228'162'514'264'337'593'543'950'335e+X                              //                              // Manually force it to the correct result:                              //                              //      7'922'816'251'426'433'759'354'395'034e+(X+1)                              //                              // This code path can be reached by trying to parse the following as a Decimal:                              //                              //      0.792281625142643375935439503355e28                              //                                d.High = 0x19999999;                              d.Mid = 0x99999999;                              d.Low = 0x9999999A;                              e++;                          }                      }                  }              }
Magic Number,System,Number,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Number\Number.cs,NumberBufferToDecimal,The following statement contains a magic number: if (*p == 0)              {                  // To avoid risking an app-compat issue with pre 4.5 (where some app was illegally using Reflection to examine the internal scale bits)' we'll only force                  // the scale to 0 if the scale was previously positive (previously' such cases were unparsable to a bug.)                  if (e > 0)                  {                      e = 0;                  }              }              else              {                  if (e > DECIMAL_PRECISION)                      return false;                    while (((e > 0) || ((*p != 0) && (e > -28))) &&                         ((d.High < 0x19999999) || ((d.High == 0x19999999) &&                                                    ((d.Mid < 0x99999999) || ((d.Mid == 0x99999999) &&                                                                              ((d.Low < 0x99999999) || ((d.Low == 0x99999999) &&                                                                                                        (*p <= '5'))))))))                  {                      DecimalDecCalc.DecMul10(ref d);                      if (*p != 0)                          DecimalDecCalc.DecAddInt32(ref d' (uint)(*p++ - '0'));                      e--;                  }                    if (*p++ >= '5')                  {                      bool round = true;                      if ((*(p - 1) == '5') && ((*(p - 2) % 2) == 0))                      {                          // Check if previous digit is even' only if the when we are unsure whether hows to do                          // Banker's rounding. For digits > 5 we will be rounding up anyway.                          int count = 20; // Look at the next 20 digits to check to round                          while ((*p == '0') && (count != 0))                          {                              p++;                              count--;                          }                          if ((*p == '\0') || (count == 0))                              round = false;// Do nothing                      }                        if (round)                      {                          DecimalDecCalc.DecAddInt32(ref d' 1);                          if ((d.High | d.Mid | d.Low) == 0)                          {                              // If we got here' the magnitude portion overflowed and wrapped back to 0 as the magnitude was already at the MaxValue point:                              //                              //     79'228'162'514'264'337'593'543'950'335e+X                              //                              // Manually force it to the correct result:                              //                              //      7'922'816'251'426'433'759'354'395'034e+(X+1)                              //                              // This code path can be reached by trying to parse the following as a Decimal:                              //                              //      0.792281625142643375935439503355e28                              //                                d.High = 0x19999999;                              d.Mid = 0x99999999;                              d.Low = 0x9999999A;                              e++;                          }                      }                  }              }
Magic Number,System,Number,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Number\Number.cs,NumberBufferToDecimal,The following statement contains a magic number: if (*p == 0)              {                  // To avoid risking an app-compat issue with pre 4.5 (where some app was illegally using Reflection to examine the internal scale bits)' we'll only force                  // the scale to 0 if the scale was previously positive (previously' such cases were unparsable to a bug.)                  if (e > 0)                  {                      e = 0;                  }              }              else              {                  if (e > DECIMAL_PRECISION)                      return false;                    while (((e > 0) || ((*p != 0) && (e > -28))) &&                         ((d.High < 0x19999999) || ((d.High == 0x19999999) &&                                                    ((d.Mid < 0x99999999) || ((d.Mid == 0x99999999) &&                                                                              ((d.Low < 0x99999999) || ((d.Low == 0x99999999) &&                                                                                                        (*p <= '5'))))))))                  {                      DecimalDecCalc.DecMul10(ref d);                      if (*p != 0)                          DecimalDecCalc.DecAddInt32(ref d' (uint)(*p++ - '0'));                      e--;                  }                    if (*p++ >= '5')                  {                      bool round = true;                      if ((*(p - 1) == '5') && ((*(p - 2) % 2) == 0))                      {                          // Check if previous digit is even' only if the when we are unsure whether hows to do                          // Banker's rounding. For digits > 5 we will be rounding up anyway.                          int count = 20; // Look at the next 20 digits to check to round                          while ((*p == '0') && (count != 0))                          {                              p++;                              count--;                          }                          if ((*p == '\0') || (count == 0))                              round = false;// Do nothing                      }                        if (round)                      {                          DecimalDecCalc.DecAddInt32(ref d' 1);                          if ((d.High | d.Mid | d.Low) == 0)                          {                              // If we got here' the magnitude portion overflowed and wrapped back to 0 as the magnitude was already at the MaxValue point:                              //                              //     79'228'162'514'264'337'593'543'950'335e+X                              //                              // Manually force it to the correct result:                              //                              //      7'922'816'251'426'433'759'354'395'034e+(X+1)                              //                              // This code path can be reached by trying to parse the following as a Decimal:                              //                              //      0.792281625142643375935439503355e28                              //                                d.High = 0x19999999;                              d.Mid = 0x99999999;                              d.Low = 0x9999999A;                              e++;                          }                      }                  }              }
Magic Number,System,Number,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Number\Number.cs,NumberBufferToDecimal,The following statement contains a magic number: if (*p == 0)              {                  // To avoid risking an app-compat issue with pre 4.5 (where some app was illegally using Reflection to examine the internal scale bits)' we'll only force                  // the scale to 0 if the scale was previously positive (previously' such cases were unparsable to a bug.)                  if (e > 0)                  {                      e = 0;                  }              }              else              {                  if (e > DECIMAL_PRECISION)                      return false;                    while (((e > 0) || ((*p != 0) && (e > -28))) &&                         ((d.High < 0x19999999) || ((d.High == 0x19999999) &&                                                    ((d.Mid < 0x99999999) || ((d.Mid == 0x99999999) &&                                                                              ((d.Low < 0x99999999) || ((d.Low == 0x99999999) &&                                                                                                        (*p <= '5'))))))))                  {                      DecimalDecCalc.DecMul10(ref d);                      if (*p != 0)                          DecimalDecCalc.DecAddInt32(ref d' (uint)(*p++ - '0'));                      e--;                  }                    if (*p++ >= '5')                  {                      bool round = true;                      if ((*(p - 1) == '5') && ((*(p - 2) % 2) == 0))                      {                          // Check if previous digit is even' only if the when we are unsure whether hows to do                          // Banker's rounding. For digits > 5 we will be rounding up anyway.                          int count = 20; // Look at the next 20 digits to check to round                          while ((*p == '0') && (count != 0))                          {                              p++;                              count--;                          }                          if ((*p == '\0') || (count == 0))                              round = false;// Do nothing                      }                        if (round)                      {                          DecimalDecCalc.DecAddInt32(ref d' 1);                          if ((d.High | d.Mid | d.Low) == 0)                          {                              // If we got here' the magnitude portion overflowed and wrapped back to 0 as the magnitude was already at the MaxValue point:                              //                              //     79'228'162'514'264'337'593'543'950'335e+X                              //                              // Manually force it to the correct result:                              //                              //      7'922'816'251'426'433'759'354'395'034e+(X+1)                              //                              // This code path can be reached by trying to parse the following as a Decimal:                              //                              //      0.792281625142643375935439503355e28                              //                                d.High = 0x19999999;                              d.Mid = 0x99999999;                              d.Low = 0x9999999A;                              e++;                          }                      }                  }              }
Magic Number,System,Number,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Number\Number.cs,DecimalToNumber,The following statement contains a magic number: while (d.Mid != 0 | d.High != 0)              {                  uint modulo1E9 = DecimalDecCalc.DecDivMod1E9(ref d);                  for (int digitCount = 0; digitCount < 9; digitCount++)                  {                      buffer[--index] = (byte)(modulo1E9 % 10 + '0');                      modulo1E9 /= 10;                  }              }
Magic Number,System,Number,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Number\Number.cs,DecimalToNumber,The following statement contains a magic number: while (d.Mid != 0 | d.High != 0)              {                  uint modulo1E9 = DecimalDecCalc.DecDivMod1E9(ref d);                  for (int digitCount = 0; digitCount < 9; digitCount++)                  {                      buffer[--index] = (byte)(modulo1E9 % 10 + '0');                      modulo1E9 /= 10;                  }              }
Magic Number,System,Number,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Number\Number.cs,DecimalToNumber,The following statement contains a magic number: while (d.Mid != 0 | d.High != 0)              {                  uint modulo1E9 = DecimalDecCalc.DecDivMod1E9(ref d);                  for (int digitCount = 0; digitCount < 9; digitCount++)                  {                      buffer[--index] = (byte)(modulo1E9 % 10 + '0');                      modulo1E9 /= 10;                  }              }
Magic Number,System,Number,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Number\Number.cs,DecimalToNumber,The following statement contains a magic number: while (remainder != 0)              {                  buffer[--index] = (byte)(remainder % 10 + '0');                  remainder /= 10;              }
Magic Number,System,Number,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Number\Number.cs,DecimalToNumber,The following statement contains a magic number: while (remainder != 0)              {                  buffer[--index] = (byte)(remainder % 10 + '0');                  remainder /= 10;              }
Magic Number,System,Number,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Number\Number.cs,Mul64Lossy,The following statement contains a magic number: ulong val = Mul32x32To64((uint)(a >> 32)' (uint)(b >> 32)) +                  (Mul32x32To64((uint)(a >> 32)' (uint)(b)) >> 32) +                  (Mul32x32To64((uint)(a)' (uint)(b >> 32)) >> 32);
Magic Number,System,Number,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Number\Number.cs,Mul64Lossy,The following statement contains a magic number: ulong val = Mul32x32To64((uint)(a >> 32)' (uint)(b >> 32)) +                  (Mul32x32To64((uint)(a >> 32)' (uint)(b)) >> 32) +                  (Mul32x32To64((uint)(a)' (uint)(b >> 32)) >> 32);
Magic Number,System,Number,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Number\Number.cs,Mul64Lossy,The following statement contains a magic number: ulong val = Mul32x32To64((uint)(a >> 32)' (uint)(b >> 32)) +                  (Mul32x32To64((uint)(a >> 32)' (uint)(b)) >> 32) +                  (Mul32x32To64((uint)(a)' (uint)(b >> 32)) >> 32);
Magic Number,System,Number,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Number\Number.cs,Mul64Lossy,The following statement contains a magic number: ulong val = Mul32x32To64((uint)(a >> 32)' (uint)(b >> 32)) +                  (Mul32x32To64((uint)(a >> 32)' (uint)(b)) >> 32) +                  (Mul32x32To64((uint)(a)' (uint)(b >> 32)) >> 32);
Magic Number,System,Number,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Number\Number.cs,Mul64Lossy,The following statement contains a magic number: ulong val = Mul32x32To64((uint)(a >> 32)' (uint)(b >> 32)) +                  (Mul32x32To64((uint)(a >> 32)' (uint)(b)) >> 32) +                  (Mul32x32To64((uint)(a)' (uint)(b >> 32)) >> 32);
Magic Number,System,Number,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Number\Number.cs,Mul64Lossy,The following statement contains a magic number: ulong val = Mul32x32To64((uint)(a >> 32)' (uint)(b >> 32)) +                  (Mul32x32To64((uint)(a >> 32)' (uint)(b)) >> 32) +                  (Mul32x32To64((uint)(a)' (uint)(b >> 32)) >> 32);
Magic Number,System,Number,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Number\Number.cs,NumberToDouble,The following statement contains a magic number: count = Math.Min(remaining' 9);
Magic Number,System,Number,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Number\Number.cs,NumberToDouble,The following statement contains a magic number: if (remaining > 0)              {                  count = Math.Min(remaining' 9);                  remaining -= count;                    // get the denormalized power of 10                  uint mult = (uint)(s_rgval64Power10[count - 1] >> (64 - s_rgexp64Power10[count - 1]));                  val = Mul32x32To64((uint)val' mult) + DigitsToInt(src.Slice(9)' count);              }
Magic Number,System,Number,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Number\Number.cs,NumberToDouble,The following statement contains a magic number: if (remaining > 0)              {                  count = Math.Min(remaining' 9);                  remaining -= count;                    // get the denormalized power of 10                  uint mult = (uint)(s_rgval64Power10[count - 1] >> (64 - s_rgexp64Power10[count - 1]));                  val = Mul32x32To64((uint)val' mult) + DigitsToInt(src.Slice(9)' count);              }
Magic Number,System,Number,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Number\Number.cs,NumberToDouble,The following statement contains a magic number: if (remaining > 0)              {                  count = Math.Min(remaining' 9);                  remaining -= count;                    // get the denormalized power of 10                  uint mult = (uint)(s_rgval64Power10[count - 1] >> (64 - s_rgexp64Power10[count - 1]));                  val = Mul32x32To64((uint)val' mult) + DigitsToInt(src.Slice(9)' count);              }
Magic Number,System,Number,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Number\Number.cs,NumberToDouble,The following statement contains a magic number: if (absscale >= 22 * 16)              {                  // overflow / underflow                  ulong result = (scale > 0) ? 0x7FF0000000000000 : 0ul;                  if (number.IsNegative)                      result |= 0x8000000000000000;                  return *(double*)&result;              }
Magic Number,System,Number,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Number\Number.cs,NumberToDouble,The following statement contains a magic number: if (absscale >= 22 * 16)              {                  // overflow / underflow                  ulong result = (scale > 0) ? 0x7FF0000000000000 : 0ul;                  if (number.IsNegative)                      result |= 0x8000000000000000;                  return *(double*)&result;              }
Magic Number,System,Number,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Number\Number.cs,NumberToDouble,The following statement contains a magic number: exp = 64;
Magic Number,System,Number,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Number\Number.cs,NumberToDouble,The following statement contains a magic number: if ((val & 0xFFFFFFFF00000000) == 0)              { val <<= 32; exp -= 32; }
Magic Number,System,Number,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Number\Number.cs,NumberToDouble,The following statement contains a magic number: if ((val & 0xFFFFFFFF00000000) == 0)              { val <<= 32; exp -= 32; }
Magic Number,System,Number,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Number\Number.cs,NumberToDouble,The following statement contains a magic number: if ((val & 0xFFFF000000000000) == 0)              { val <<= 16; exp -= 16; }
Magic Number,System,Number,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Number\Number.cs,NumberToDouble,The following statement contains a magic number: if ((val & 0xFFFF000000000000) == 0)              { val <<= 16; exp -= 16; }
Magic Number,System,Number,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Number\Number.cs,NumberToDouble,The following statement contains a magic number: if ((val & 0xFF00000000000000) == 0)              { val <<= 8; exp -= 8; }
Magic Number,System,Number,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Number\Number.cs,NumberToDouble,The following statement contains a magic number: if ((val & 0xFF00000000000000) == 0)              { val <<= 8; exp -= 8; }
Magic Number,System,Number,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Number\Number.cs,NumberToDouble,The following statement contains a magic number: if ((val & 0xF000000000000000) == 0)              { val <<= 4; exp -= 4; }
Magic Number,System,Number,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Number\Number.cs,NumberToDouble,The following statement contains a magic number: if ((val & 0xF000000000000000) == 0)              { val <<= 4; exp -= 4; }
Magic Number,System,Number,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Number\Number.cs,NumberToDouble,The following statement contains a magic number: if ((val & 0xC000000000000000) == 0)              { val <<= 2; exp -= 2; }
Magic Number,System,Number,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Number\Number.cs,NumberToDouble,The following statement contains a magic number: if ((val & 0xC000000000000000) == 0)              { val <<= 2; exp -= 2; }
Magic Number,System,Number,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Number\Number.cs,NumberToDouble,The following statement contains a magic number: index = absscale & 15;
Magic Number,System,Number,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Number\Number.cs,NumberToDouble,The following statement contains a magic number: if (index != 0)              {                  int multexp = s_rgexp64Power10[index - 1];                  // the exponents are shared between the inverted and regular table                  exp += (scale < 0) ? (-multexp + 1) : multexp;                    ulong multval = s_rgval64Power10[index + ((scale < 0) ? 15 : 0) - 1];                  val = Mul64Lossy(val' multval' ref exp);              }
Magic Number,System,Number,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Number\Number.cs,NumberToDouble,The following statement contains a magic number: index = absscale >> 4;
Magic Number,System,Number,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Number\Number.cs,NumberToDouble,The following statement contains a magic number: if (index != 0)              {                  int multexp = s_rgexp64Power10By16[index - 1];                  // the exponents are shared between the inverted and regular table                  exp += (scale < 0) ? (-multexp + 1) : multexp;                    ulong multval = s_rgval64Power10By16[index + ((scale < 0) ? 21 : 0) - 1];                  val = Mul64Lossy(val' multval' ref exp);              }
Magic Number,System,Number,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Number\Number.cs,NumberToDouble,The following statement contains a magic number: if (((int)val & (1 << 10)) != 0)              {                  // IEEE round to even                  ulong tmp = val + ((1 << 10) - 1) + (ulong)(((int)val >> 11) & 1);                  if (tmp < val)                  {                      // overflow                      tmp = (tmp >> 1) | 0x8000000000000000;                      exp += 1;                  }                  val = tmp;              }
Magic Number,System,Number,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Number\Number.cs,NumberToDouble,The following statement contains a magic number: if (((int)val & (1 << 10)) != 0)              {                  // IEEE round to even                  ulong tmp = val + ((1 << 10) - 1) + (ulong)(((int)val >> 11) & 1);                  if (tmp < val)                  {                      // overflow                      tmp = (tmp >> 1) | 0x8000000000000000;                      exp += 1;                  }                  val = tmp;              }
Magic Number,System,Number,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Number\Number.cs,NumberToDouble,The following statement contains a magic number: if (((int)val & (1 << 10)) != 0)              {                  // IEEE round to even                  ulong tmp = val + ((1 << 10) - 1) + (ulong)(((int)val >> 11) & 1);                  if (tmp < val)                  {                      // overflow                      tmp = (tmp >> 1) | 0x8000000000000000;                      exp += 1;                  }                  val = tmp;              }
Magic Number,System,Number,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Number\Number.cs,NumberToDouble,The following statement contains a magic number: if (exp <= 0)              {                  if (exp == -52 && (val >= 0x8000000000000058))                  {                      // round X where {Epsilon > X >= 2.470328229206232730000000E-324} up to Epsilon (instead of down to zero)                      val = 0x0000000000000001;                  }                  else if (exp <= -52)                  {                      // underflow                      val = 0;                  }                  else                  {                      // denormalized                      val >>= (-exp + 11 + 1);                  }              }              else if (exp >= 0x7FF)              {                  // overflow                  val = 0x7FF0000000000000;              }              else              {                  // normal postive exponent case                  val = ((ulong)exp << 52) + ((val >> 11) & 0x000FFFFFFFFFFFFF);              }
Magic Number,System,Number,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Number\Number.cs,NumberToDouble,The following statement contains a magic number: if (exp <= 0)              {                  if (exp == -52 && (val >= 0x8000000000000058))                  {                      // round X where {Epsilon > X >= 2.470328229206232730000000E-324} up to Epsilon (instead of down to zero)                      val = 0x0000000000000001;                  }                  else if (exp <= -52)                  {                      // underflow                      val = 0;                  }                  else                  {                      // denormalized                      val >>= (-exp + 11 + 1);                  }              }              else if (exp >= 0x7FF)              {                  // overflow                  val = 0x7FF0000000000000;              }              else              {                  // normal postive exponent case                  val = ((ulong)exp << 52) + ((val >> 11) & 0x000FFFFFFFFFFFFF);              }
Magic Number,System,Number,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Number\Number.cs,NumberToDouble,The following statement contains a magic number: if (exp <= 0)              {                  if (exp == -52 && (val >= 0x8000000000000058))                  {                      // round X where {Epsilon > X >= 2.470328229206232730000000E-324} up to Epsilon (instead of down to zero)                      val = 0x0000000000000001;                  }                  else if (exp <= -52)                  {                      // underflow                      val = 0;                  }                  else                  {                      // denormalized                      val >>= (-exp + 11 + 1);                  }              }              else if (exp >= 0x7FF)              {                  // overflow                  val = 0x7FF0000000000000;              }              else              {                  // normal postive exponent case                  val = ((ulong)exp << 52) + ((val >> 11) & 0x000FFFFFFFFFFFFF);              }
Magic Number,System,Number,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Number\Number.cs,NumberToDouble,The following statement contains a magic number: if (exp <= 0)              {                  if (exp == -52 && (val >= 0x8000000000000058))                  {                      // round X where {Epsilon > X >= 2.470328229206232730000000E-324} up to Epsilon (instead of down to zero)                      val = 0x0000000000000001;                  }                  else if (exp <= -52)                  {                      // underflow                      val = 0;                  }                  else                  {                      // denormalized                      val >>= (-exp + 11 + 1);                  }              }              else if (exp >= 0x7FF)              {                  // overflow                  val = 0x7FF0000000000000;              }              else              {                  // normal postive exponent case                  val = ((ulong)exp << 52) + ((val >> 11) & 0x000FFFFFFFFFFFFF);              }
Magic Number,System,Number,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Number\Number.cs,NumberToDouble,The following statement contains a magic number: if (exp <= 0)              {                  if (exp == -52 && (val >= 0x8000000000000058))                  {                      // round X where {Epsilon > X >= 2.470328229206232730000000E-324} up to Epsilon (instead of down to zero)                      val = 0x0000000000000001;                  }                  else if (exp <= -52)                  {                      // underflow                      val = 0;                  }                  else                  {                      // denormalized                      val >>= (-exp + 11 + 1);                  }              }              else if (exp >= 0x7FF)              {                  // overflow                  val = 0x7FF0000000000000;              }              else              {                  // normal postive exponent case                  val = ((ulong)exp << 52) + ((val >> 11) & 0x000FFFFFFFFFFFFF);              }
Magic Number,System,DoubleHelper,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Number\Number.FormatAndParse.cs,Exponent,The following statement contains a magic number: return (*((uint*)&d + 1) >> 20) & 0x000007ff;
Magic Number,System,DoubleHelper,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Number\Number.FormatAndParse.cs,Mantissa,The following statement contains a magic number: return (*((uint*)&d)) | ((ulong)(*((uint*)&d + 1) & 0x000fffff) << 32);
Magic Number,System,DoubleHelper,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Number\Number.FormatAndParse.cs,Sign,The following statement contains a magic number: return (*((uint*)&d + 1) >> 31) != 0;
Magic Number,System.Buffers,StandardFormat,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\StandardFormat.cs,Parse,The following statement contains a magic number: if (format.Length == 1)              {                  precision = NoPrecision;              }              else              {                  uint parsedPrecision = 0;                  for (int srcIndex = 1; srcIndex < format.Length; srcIndex++)                  {                      uint digit = format[srcIndex] - 48u; // '0'                      if (digit > 9)                          throw new FormatException(SR.Format(SR.Argument_CannotParsePrecision' MaxPrecision));                        parsedPrecision = parsedPrecision * 10 + digit;                      if (parsedPrecision > MaxPrecision)                          throw new FormatException(SR.Format(SR.Argument_PrecisionTooLarge' MaxPrecision));                  }                    precision = (byte)parsedPrecision;              }
Magic Number,System.Buffers,StandardFormat,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\StandardFormat.cs,Parse,The following statement contains a magic number: if (format.Length == 1)              {                  precision = NoPrecision;              }              else              {                  uint parsedPrecision = 0;                  for (int srcIndex = 1; srcIndex < format.Length; srcIndex++)                  {                      uint digit = format[srcIndex] - 48u; // '0'                      if (digit > 9)                          throw new FormatException(SR.Format(SR.Argument_CannotParsePrecision' MaxPrecision));                        parsedPrecision = parsedPrecision * 10 + digit;                      if (parsedPrecision > MaxPrecision)                          throw new FormatException(SR.Format(SR.Argument_PrecisionTooLarge' MaxPrecision));                  }                    precision = (byte)parsedPrecision;              }
Magic Number,System.Buffers,StandardFormat,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\StandardFormat.cs,ToString,The following statement contains a magic number: unsafe              {                  const int MaxLength = 4;                  char* pBuffer = stackalloc char[MaxLength];                    int dstIndex = 0;                  char symbol = Symbol;                  if (symbol != default)                  {                      pBuffer[dstIndex++] = symbol;                        byte precision = Precision;                      if (precision != NoPrecision)                      {                          if (precision >= 100)                          {                              pBuffer[dstIndex++] = (char)('0' + (precision / 100) % 10);                              precision = (byte)(precision % 100);                          }                            if (precision >= 10)                          {                              pBuffer[dstIndex++] = (char)('0' + (precision / 10) % 10);                              precision = (byte)(precision % 10);                          }                            pBuffer[dstIndex++] = (char)('0' + precision);                      }                  }                    Debug.Assert(dstIndex <= MaxLength);                    return new string(pBuffer' startIndex: 0' length: dstIndex);              }
Magic Number,System.Buffers,StandardFormat,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\StandardFormat.cs,ToString,The following statement contains a magic number: unsafe              {                  const int MaxLength = 4;                  char* pBuffer = stackalloc char[MaxLength];                    int dstIndex = 0;                  char symbol = Symbol;                  if (symbol != default)                  {                      pBuffer[dstIndex++] = symbol;                        byte precision = Precision;                      if (precision != NoPrecision)                      {                          if (precision >= 100)                          {                              pBuffer[dstIndex++] = (char)('0' + (precision / 100) % 10);                              precision = (byte)(precision % 100);                          }                            if (precision >= 10)                          {                              pBuffer[dstIndex++] = (char)('0' + (precision / 10) % 10);                              precision = (byte)(precision % 10);                          }                            pBuffer[dstIndex++] = (char)('0' + precision);                      }                  }                    Debug.Assert(dstIndex <= MaxLength);                    return new string(pBuffer' startIndex: 0' length: dstIndex);              }
Magic Number,System.Buffers,StandardFormat,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\StandardFormat.cs,ToString,The following statement contains a magic number: unsafe              {                  const int MaxLength = 4;                  char* pBuffer = stackalloc char[MaxLength];                    int dstIndex = 0;                  char symbol = Symbol;                  if (symbol != default)                  {                      pBuffer[dstIndex++] = symbol;                        byte precision = Precision;                      if (precision != NoPrecision)                      {                          if (precision >= 100)                          {                              pBuffer[dstIndex++] = (char)('0' + (precision / 100) % 10);                              precision = (byte)(precision % 100);                          }                            if (precision >= 10)                          {                              pBuffer[dstIndex++] = (char)('0' + (precision / 10) % 10);                              precision = (byte)(precision % 10);                          }                            pBuffer[dstIndex++] = (char)('0' + precision);                      }                  }                    Debug.Assert(dstIndex <= MaxLength);                    return new string(pBuffer' startIndex: 0' length: dstIndex);              }
Magic Number,System.Buffers,StandardFormat,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\StandardFormat.cs,ToString,The following statement contains a magic number: unsafe              {                  const int MaxLength = 4;                  char* pBuffer = stackalloc char[MaxLength];                    int dstIndex = 0;                  char symbol = Symbol;                  if (symbol != default)                  {                      pBuffer[dstIndex++] = symbol;                        byte precision = Precision;                      if (precision != NoPrecision)                      {                          if (precision >= 100)                          {                              pBuffer[dstIndex++] = (char)('0' + (precision / 100) % 10);                              precision = (byte)(precision % 100);                          }                            if (precision >= 10)                          {                              pBuffer[dstIndex++] = (char)('0' + (precision / 10) % 10);                              precision = (byte)(precision % 10);                          }                            pBuffer[dstIndex++] = (char)('0' + precision);                      }                  }                    Debug.Assert(dstIndex <= MaxLength);                    return new string(pBuffer' startIndex: 0' length: dstIndex);              }
Magic Number,System.Buffers,StandardFormat,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\StandardFormat.cs,ToString,The following statement contains a magic number: unsafe              {                  const int MaxLength = 4;                  char* pBuffer = stackalloc char[MaxLength];                    int dstIndex = 0;                  char symbol = Symbol;                  if (symbol != default)                  {                      pBuffer[dstIndex++] = symbol;                        byte precision = Precision;                      if (precision != NoPrecision)                      {                          if (precision >= 100)                          {                              pBuffer[dstIndex++] = (char)('0' + (precision / 100) % 10);                              precision = (byte)(precision % 100);                          }                            if (precision >= 10)                          {                              pBuffer[dstIndex++] = (char)('0' + (precision / 10) % 10);                              precision = (byte)(precision % 10);                          }                            pBuffer[dstIndex++] = (char)('0' + precision);                      }                  }                    Debug.Assert(dstIndex <= MaxLength);                    return new string(pBuffer' startIndex: 0' length: dstIndex);              }
Magic Number,System.Buffers,StandardFormat,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\StandardFormat.cs,ToString,The following statement contains a magic number: unsafe              {                  const int MaxLength = 4;                  char* pBuffer = stackalloc char[MaxLength];                    int dstIndex = 0;                  char symbol = Symbol;                  if (symbol != default)                  {                      pBuffer[dstIndex++] = symbol;                        byte precision = Precision;                      if (precision != NoPrecision)                      {                          if (precision >= 100)                          {                              pBuffer[dstIndex++] = (char)('0' + (precision / 100) % 10);                              precision = (byte)(precision % 100);                          }                            if (precision >= 10)                          {                              pBuffer[dstIndex++] = (char)('0' + (precision / 10) % 10);                              precision = (byte)(precision % 10);                          }                            pBuffer[dstIndex++] = (char)('0' + precision);                      }                  }                    Debug.Assert(dstIndex <= MaxLength);                    return new string(pBuffer' startIndex: 0' length: dstIndex);              }
Magic Number,System.Buffers,StandardFormat,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\StandardFormat.cs,ToString,The following statement contains a magic number: unsafe              {                  const int MaxLength = 4;                  char* pBuffer = stackalloc char[MaxLength];                    int dstIndex = 0;                  char symbol = Symbol;                  if (symbol != default)                  {                      pBuffer[dstIndex++] = symbol;                        byte precision = Precision;                      if (precision != NoPrecision)                      {                          if (precision >= 100)                          {                              pBuffer[dstIndex++] = (char)('0' + (precision / 100) % 10);                              precision = (byte)(precision % 100);                          }                            if (precision >= 10)                          {                              pBuffer[dstIndex++] = (char)('0' + (precision / 10) % 10);                              precision = (byte)(precision % 10);                          }                            pBuffer[dstIndex++] = (char)('0' + precision);                      }                  }                    Debug.Assert(dstIndex <= MaxLength);                    return new string(pBuffer' startIndex: 0' length: dstIndex);              }
Magic Number,System.Buffers,StandardFormat,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\StandardFormat.cs,ToString,The following statement contains a magic number: unsafe              {                  const int MaxLength = 4;                  char* pBuffer = stackalloc char[MaxLength];                    int dstIndex = 0;                  char symbol = Symbol;                  if (symbol != default)                  {                      pBuffer[dstIndex++] = symbol;                        byte precision = Precision;                      if (precision != NoPrecision)                      {                          if (precision >= 100)                          {                              pBuffer[dstIndex++] = (char)('0' + (precision / 100) % 10);                              precision = (byte)(precision % 100);                          }                            if (precision >= 10)                          {                              pBuffer[dstIndex++] = (char)('0' + (precision / 10) % 10);                              precision = (byte)(precision % 10);                          }                            pBuffer[dstIndex++] = (char)('0' + precision);                      }                  }                    Debug.Assert(dstIndex <= MaxLength);                    return new string(pBuffer' startIndex: 0' length: dstIndex);              }
Magic Number,System.Buffers,StandardFormat,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\StandardFormat.cs,ToString,The following statement contains a magic number: unsafe              {                  const int MaxLength = 4;                  char* pBuffer = stackalloc char[MaxLength];                    int dstIndex = 0;                  char symbol = Symbol;                  if (symbol != default)                  {                      pBuffer[dstIndex++] = symbol;                        byte precision = Precision;                      if (precision != NoPrecision)                      {                          if (precision >= 100)                          {                              pBuffer[dstIndex++] = (char)('0' + (precision / 100) % 10);                              precision = (byte)(precision % 100);                          }                            if (precision >= 10)                          {                              pBuffer[dstIndex++] = (char)('0' + (precision / 10) % 10);                              precision = (byte)(precision % 10);                          }                            pBuffer[dstIndex++] = (char)('0' + precision);                      }                  }                    Debug.Assert(dstIndex <= MaxLength);                    return new string(pBuffer' startIndex: 0' length: dstIndex);              }
Magic Number,System.Buffers.Binary,BinaryPrimitives,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Binary\Reader.cs,ReverseEndianness,The following statement contains a magic number: return (short)((value & 0x00FF) << 8 | (value & 0xFF00) >> 8);
Magic Number,System.Buffers.Binary,BinaryPrimitives,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Binary\Reader.cs,ReverseEndianness,The following statement contains a magic number: return (short)((value & 0x00FF) << 8 | (value & 0xFF00) >> 8);
Magic Number,System.Buffers.Binary,BinaryPrimitives,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Binary\Reader.cs,ReverseEndianness,The following statement contains a magic number: return (ushort)((value & 0x00FFU) << 8 | (value & 0xFF00U) >> 8);
Magic Number,System.Buffers.Binary,BinaryPrimitives,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Binary\Reader.cs,ReverseEndianness,The following statement contains a magic number: return (ushort)((value & 0x00FFU) << 8 | (value & 0xFF00U) >> 8);
Magic Number,System.Buffers.Binary,BinaryPrimitives,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Binary\Reader.cs,ReverseEndianness,The following statement contains a magic number: value = (value << 16) | (value >> 16);
Magic Number,System.Buffers.Binary,BinaryPrimitives,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Binary\Reader.cs,ReverseEndianness,The following statement contains a magic number: value = (value << 16) | (value >> 16);
Magic Number,System.Buffers.Binary,BinaryPrimitives,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Binary\Reader.cs,ReverseEndianness,The following statement contains a magic number: value = (value & 0x00FF00FF) << 8 | (value & 0xFF00FF00) >> 8;
Magic Number,System.Buffers.Binary,BinaryPrimitives,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Binary\Reader.cs,ReverseEndianness,The following statement contains a magic number: value = (value & 0x00FF00FF) << 8 | (value & 0xFF00FF00) >> 8;
Magic Number,System.Buffers.Binary,BinaryPrimitives,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Binary\Reader.cs,ReverseEndianness,The following statement contains a magic number: value = (value << 32) | (value >> 32);
Magic Number,System.Buffers.Binary,BinaryPrimitives,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Binary\Reader.cs,ReverseEndianness,The following statement contains a magic number: value = (value << 32) | (value >> 32);
Magic Number,System.Buffers.Binary,BinaryPrimitives,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Binary\Reader.cs,ReverseEndianness,The following statement contains a magic number: value = (value & 0x0000FFFF0000FFFF) << 16 | (value & 0xFFFF0000FFFF0000) >> 16;
Magic Number,System.Buffers.Binary,BinaryPrimitives,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Binary\Reader.cs,ReverseEndianness,The following statement contains a magic number: value = (value & 0x0000FFFF0000FFFF) << 16 | (value & 0xFFFF0000FFFF0000) >> 16;
Magic Number,System.Buffers.Binary,BinaryPrimitives,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Binary\Reader.cs,ReverseEndianness,The following statement contains a magic number: value = (value & 0x00FF00FF00FF00FF) << 8 | (value & 0xFF00FF00FF00FF00) >> 8;
Magic Number,System.Buffers.Binary,BinaryPrimitives,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Binary\Reader.cs,ReverseEndianness,The following statement contains a magic number: value = (value & 0x00FF00FF00FF00FF) << 8 | (value & 0xFF00FF00FF00FF00) >> 8;
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,DecodeFromUtf8,The following statement contains a magic number: int skipLastChunk = isFinalBlock ? 4 : 0;
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,DecodeFromUtf8,The following statement contains a magic number: if (destLength >= GetMaxDecodedFromUtf8Length(srcLength))              {                  maxSrcLength = srcLength - skipLastChunk;              }              else              {                  // This should never overflow since destLength here is less than int.MaxValue / 4 * 3 (i.e. 1610612733)                  // Therefore' (destLength / 3) * 4 will always be less than 2147483641                  maxSrcLength = (destLength / 3) * 4;              }
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,DecodeFromUtf8,The following statement contains a magic number: if (destLength >= GetMaxDecodedFromUtf8Length(srcLength))              {                  maxSrcLength = srcLength - skipLastChunk;              }              else              {                  // This should never overflow since destLength here is less than int.MaxValue / 4 * 3 (i.e. 1610612733)                  // Therefore' (destLength / 3) * 4 will always be less than 2147483641                  maxSrcLength = (destLength / 3) * 4;              }
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,DecodeFromUtf8,The following statement contains a magic number: while (sourceIndex < maxSrcLength)              {                  int result = Decode(ref Unsafe.Add(ref srcBytes' sourceIndex)' ref decodingMap);                  if (result < 0)                      goto InvalidExit;                  WriteThreeLowOrderBytes(ref Unsafe.Add(ref destBytes' destIndex)' result);                  destIndex += 3;                  sourceIndex += 4;              }
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,DecodeFromUtf8,The following statement contains a magic number: while (sourceIndex < maxSrcLength)              {                  int result = Decode(ref Unsafe.Add(ref srcBytes' sourceIndex)' ref decodingMap);                  if (result < 0)                      goto InvalidExit;                  WriteThreeLowOrderBytes(ref Unsafe.Add(ref destBytes' destIndex)' result);                  destIndex += 3;                  sourceIndex += 4;              }
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,DecodeFromUtf8,The following statement contains a magic number: int i0 = Unsafe.Add(ref srcBytes' srcLength - 4);
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,DecodeFromUtf8,The following statement contains a magic number: int i1 = Unsafe.Add(ref srcBytes' srcLength - 3);
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,DecodeFromUtf8,The following statement contains a magic number: int i2 = Unsafe.Add(ref srcBytes' srcLength - 2);
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,DecodeFromUtf8,The following statement contains a magic number: i0 <<= 18;
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,DecodeFromUtf8,The following statement contains a magic number: i1 <<= 12;
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,DecodeFromUtf8,The following statement contains a magic number: if (i3 != EncodingPad)              {                  i2 = Unsafe.Add(ref decodingMap' i2);                  i3 = Unsafe.Add(ref decodingMap' i3);                    i2 <<= 6;                    i0 |= i3;                  i0 |= i2;                    if (i0 < 0)                      goto InvalidExit;                  if (destIndex > destLength - 3)                      goto DestinationSmallExit;                  WriteThreeLowOrderBytes(ref Unsafe.Add(ref destBytes' destIndex)' i0);                  destIndex += 3;              }              else if (i2 != EncodingPad)              {                  i2 = Unsafe.Add(ref decodingMap' i2);                    i2 <<= 6;                    i0 |= i2;                    if (i0 < 0)                      goto InvalidExit;                  if (destIndex > destLength - 2)                      goto DestinationSmallExit;                  Unsafe.Add(ref destBytes' destIndex) = (byte)(i0 >> 16);                  Unsafe.Add(ref destBytes' destIndex + 1) = (byte)(i0 >> 8);                  destIndex += 2;              }              else              {                  if (i0 < 0)                      goto InvalidExit;                  if (destIndex > destLength - 1)                      goto DestinationSmallExit;                  Unsafe.Add(ref destBytes' destIndex) = (byte)(i0 >> 16);                  destIndex += 1;              }
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,DecodeFromUtf8,The following statement contains a magic number: if (i3 != EncodingPad)              {                  i2 = Unsafe.Add(ref decodingMap' i2);                  i3 = Unsafe.Add(ref decodingMap' i3);                    i2 <<= 6;                    i0 |= i3;                  i0 |= i2;                    if (i0 < 0)                      goto InvalidExit;                  if (destIndex > destLength - 3)                      goto DestinationSmallExit;                  WriteThreeLowOrderBytes(ref Unsafe.Add(ref destBytes' destIndex)' i0);                  destIndex += 3;              }              else if (i2 != EncodingPad)              {                  i2 = Unsafe.Add(ref decodingMap' i2);                    i2 <<= 6;                    i0 |= i2;                    if (i0 < 0)                      goto InvalidExit;                  if (destIndex > destLength - 2)                      goto DestinationSmallExit;                  Unsafe.Add(ref destBytes' destIndex) = (byte)(i0 >> 16);                  Unsafe.Add(ref destBytes' destIndex + 1) = (byte)(i0 >> 8);                  destIndex += 2;              }              else              {                  if (i0 < 0)                      goto InvalidExit;                  if (destIndex > destLength - 1)                      goto DestinationSmallExit;                  Unsafe.Add(ref destBytes' destIndex) = (byte)(i0 >> 16);                  destIndex += 1;              }
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,DecodeFromUtf8,The following statement contains a magic number: if (i3 != EncodingPad)              {                  i2 = Unsafe.Add(ref decodingMap' i2);                  i3 = Unsafe.Add(ref decodingMap' i3);                    i2 <<= 6;                    i0 |= i3;                  i0 |= i2;                    if (i0 < 0)                      goto InvalidExit;                  if (destIndex > destLength - 3)                      goto DestinationSmallExit;                  WriteThreeLowOrderBytes(ref Unsafe.Add(ref destBytes' destIndex)' i0);                  destIndex += 3;              }              else if (i2 != EncodingPad)              {                  i2 = Unsafe.Add(ref decodingMap' i2);                    i2 <<= 6;                    i0 |= i2;                    if (i0 < 0)                      goto InvalidExit;                  if (destIndex > destLength - 2)                      goto DestinationSmallExit;                  Unsafe.Add(ref destBytes' destIndex) = (byte)(i0 >> 16);                  Unsafe.Add(ref destBytes' destIndex + 1) = (byte)(i0 >> 8);                  destIndex += 2;              }              else              {                  if (i0 < 0)                      goto InvalidExit;                  if (destIndex > destLength - 1)                      goto DestinationSmallExit;                  Unsafe.Add(ref destBytes' destIndex) = (byte)(i0 >> 16);                  destIndex += 1;              }
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,DecodeFromUtf8,The following statement contains a magic number: if (i3 != EncodingPad)              {                  i2 = Unsafe.Add(ref decodingMap' i2);                  i3 = Unsafe.Add(ref decodingMap' i3);                    i2 <<= 6;                    i0 |= i3;                  i0 |= i2;                    if (i0 < 0)                      goto InvalidExit;                  if (destIndex > destLength - 3)                      goto DestinationSmallExit;                  WriteThreeLowOrderBytes(ref Unsafe.Add(ref destBytes' destIndex)' i0);                  destIndex += 3;              }              else if (i2 != EncodingPad)              {                  i2 = Unsafe.Add(ref decodingMap' i2);                    i2 <<= 6;                    i0 |= i2;                    if (i0 < 0)                      goto InvalidExit;                  if (destIndex > destLength - 2)                      goto DestinationSmallExit;                  Unsafe.Add(ref destBytes' destIndex) = (byte)(i0 >> 16);                  Unsafe.Add(ref destBytes' destIndex + 1) = (byte)(i0 >> 8);                  destIndex += 2;              }              else              {                  if (i0 < 0)                      goto InvalidExit;                  if (destIndex > destLength - 1)                      goto DestinationSmallExit;                  Unsafe.Add(ref destBytes' destIndex) = (byte)(i0 >> 16);                  destIndex += 1;              }
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,DecodeFromUtf8,The following statement contains a magic number: if (i3 != EncodingPad)              {                  i2 = Unsafe.Add(ref decodingMap' i2);                  i3 = Unsafe.Add(ref decodingMap' i3);                    i2 <<= 6;                    i0 |= i3;                  i0 |= i2;                    if (i0 < 0)                      goto InvalidExit;                  if (destIndex > destLength - 3)                      goto DestinationSmallExit;                  WriteThreeLowOrderBytes(ref Unsafe.Add(ref destBytes' destIndex)' i0);                  destIndex += 3;              }              else if (i2 != EncodingPad)              {                  i2 = Unsafe.Add(ref decodingMap' i2);                    i2 <<= 6;                    i0 |= i2;                    if (i0 < 0)                      goto InvalidExit;                  if (destIndex > destLength - 2)                      goto DestinationSmallExit;                  Unsafe.Add(ref destBytes' destIndex) = (byte)(i0 >> 16);                  Unsafe.Add(ref destBytes' destIndex + 1) = (byte)(i0 >> 8);                  destIndex += 2;              }              else              {                  if (i0 < 0)                      goto InvalidExit;                  if (destIndex > destLength - 1)                      goto DestinationSmallExit;                  Unsafe.Add(ref destBytes' destIndex) = (byte)(i0 >> 16);                  destIndex += 1;              }
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,DecodeFromUtf8,The following statement contains a magic number: if (i3 != EncodingPad)              {                  i2 = Unsafe.Add(ref decodingMap' i2);                  i3 = Unsafe.Add(ref decodingMap' i3);                    i2 <<= 6;                    i0 |= i3;                  i0 |= i2;                    if (i0 < 0)                      goto InvalidExit;                  if (destIndex > destLength - 3)                      goto DestinationSmallExit;                  WriteThreeLowOrderBytes(ref Unsafe.Add(ref destBytes' destIndex)' i0);                  destIndex += 3;              }              else if (i2 != EncodingPad)              {                  i2 = Unsafe.Add(ref decodingMap' i2);                    i2 <<= 6;                    i0 |= i2;                    if (i0 < 0)                      goto InvalidExit;                  if (destIndex > destLength - 2)                      goto DestinationSmallExit;                  Unsafe.Add(ref destBytes' destIndex) = (byte)(i0 >> 16);                  Unsafe.Add(ref destBytes' destIndex + 1) = (byte)(i0 >> 8);                  destIndex += 2;              }              else              {                  if (i0 < 0)                      goto InvalidExit;                  if (destIndex > destLength - 1)                      goto DestinationSmallExit;                  Unsafe.Add(ref destBytes' destIndex) = (byte)(i0 >> 16);                  destIndex += 1;              }
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,DecodeFromUtf8,The following statement contains a magic number: if (i3 != EncodingPad)              {                  i2 = Unsafe.Add(ref decodingMap' i2);                  i3 = Unsafe.Add(ref decodingMap' i3);                    i2 <<= 6;                    i0 |= i3;                  i0 |= i2;                    if (i0 < 0)                      goto InvalidExit;                  if (destIndex > destLength - 3)                      goto DestinationSmallExit;                  WriteThreeLowOrderBytes(ref Unsafe.Add(ref destBytes' destIndex)' i0);                  destIndex += 3;              }              else if (i2 != EncodingPad)              {                  i2 = Unsafe.Add(ref decodingMap' i2);                    i2 <<= 6;                    i0 |= i2;                    if (i0 < 0)                      goto InvalidExit;                  if (destIndex > destLength - 2)                      goto DestinationSmallExit;                  Unsafe.Add(ref destBytes' destIndex) = (byte)(i0 >> 16);                  Unsafe.Add(ref destBytes' destIndex + 1) = (byte)(i0 >> 8);                  destIndex += 2;              }              else              {                  if (i0 < 0)                      goto InvalidExit;                  if (destIndex > destLength - 1)                      goto DestinationSmallExit;                  Unsafe.Add(ref destBytes' destIndex) = (byte)(i0 >> 16);                  destIndex += 1;              }
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,DecodeFromUtf8,The following statement contains a magic number: if (i3 != EncodingPad)              {                  i2 = Unsafe.Add(ref decodingMap' i2);                  i3 = Unsafe.Add(ref decodingMap' i3);                    i2 <<= 6;                    i0 |= i3;                  i0 |= i2;                    if (i0 < 0)                      goto InvalidExit;                  if (destIndex > destLength - 3)                      goto DestinationSmallExit;                  WriteThreeLowOrderBytes(ref Unsafe.Add(ref destBytes' destIndex)' i0);                  destIndex += 3;              }              else if (i2 != EncodingPad)              {                  i2 = Unsafe.Add(ref decodingMap' i2);                    i2 <<= 6;                    i0 |= i2;                    if (i0 < 0)                      goto InvalidExit;                  if (destIndex > destLength - 2)                      goto DestinationSmallExit;                  Unsafe.Add(ref destBytes' destIndex) = (byte)(i0 >> 16);                  Unsafe.Add(ref destBytes' destIndex + 1) = (byte)(i0 >> 8);                  destIndex += 2;              }              else              {                  if (i0 < 0)                      goto InvalidExit;                  if (destIndex > destLength - 1)                      goto DestinationSmallExit;                  Unsafe.Add(ref destBytes' destIndex) = (byte)(i0 >> 16);                  destIndex += 1;              }
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,DecodeFromUtf8,The following statement contains a magic number: if (i3 != EncodingPad)              {                  i2 = Unsafe.Add(ref decodingMap' i2);                  i3 = Unsafe.Add(ref decodingMap' i3);                    i2 <<= 6;                    i0 |= i3;                  i0 |= i2;                    if (i0 < 0)                      goto InvalidExit;                  if (destIndex > destLength - 3)                      goto DestinationSmallExit;                  WriteThreeLowOrderBytes(ref Unsafe.Add(ref destBytes' destIndex)' i0);                  destIndex += 3;              }              else if (i2 != EncodingPad)              {                  i2 = Unsafe.Add(ref decodingMap' i2);                    i2 <<= 6;                    i0 |= i2;                    if (i0 < 0)                      goto InvalidExit;                  if (destIndex > destLength - 2)                      goto DestinationSmallExit;                  Unsafe.Add(ref destBytes' destIndex) = (byte)(i0 >> 16);                  Unsafe.Add(ref destBytes' destIndex + 1) = (byte)(i0 >> 8);                  destIndex += 2;              }              else              {                  if (i0 < 0)                      goto InvalidExit;                  if (destIndex > destLength - 1)                      goto DestinationSmallExit;                  Unsafe.Add(ref destBytes' destIndex) = (byte)(i0 >> 16);                  destIndex += 1;              }
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,DecodeFromUtf8,The following statement contains a magic number: sourceIndex += 4;
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,GetMaxDecodedFromUtf8Length,The following statement contains a magic number: return (length >> 2) * 3;
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,GetMaxDecodedFromUtf8Length,The following statement contains a magic number: return (length >> 2) * 3;
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,DecodeFromUtf8InPlace,The following statement contains a magic number: if (bufferLength != ((bufferLength >> 2) * 4))                  goto InvalidExit;
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,DecodeFromUtf8InPlace,The following statement contains a magic number: if (bufferLength != ((bufferLength >> 2) * 4))                  goto InvalidExit;
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,DecodeFromUtf8InPlace,The following statement contains a magic number: while (sourceIndex < bufferLength - 4)              {                  int result = Decode(ref Unsafe.Add(ref bufferBytes' sourceIndex)' ref decodingMap);                  if (result < 0)                      goto InvalidExit;                  WriteThreeLowOrderBytes(ref Unsafe.Add(ref bufferBytes' destIndex)' result);                  destIndex += 3;                  sourceIndex += 4;              }
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,DecodeFromUtf8InPlace,The following statement contains a magic number: while (sourceIndex < bufferLength - 4)              {                  int result = Decode(ref Unsafe.Add(ref bufferBytes' sourceIndex)' ref decodingMap);                  if (result < 0)                      goto InvalidExit;                  WriteThreeLowOrderBytes(ref Unsafe.Add(ref bufferBytes' destIndex)' result);                  destIndex += 3;                  sourceIndex += 4;              }
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,DecodeFromUtf8InPlace,The following statement contains a magic number: while (sourceIndex < bufferLength - 4)              {                  int result = Decode(ref Unsafe.Add(ref bufferBytes' sourceIndex)' ref decodingMap);                  if (result < 0)                      goto InvalidExit;                  WriteThreeLowOrderBytes(ref Unsafe.Add(ref bufferBytes' destIndex)' result);                  destIndex += 3;                  sourceIndex += 4;              }
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,DecodeFromUtf8InPlace,The following statement contains a magic number: int i0 = Unsafe.Add(ref bufferBytes' bufferLength - 4);
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,DecodeFromUtf8InPlace,The following statement contains a magic number: int i1 = Unsafe.Add(ref bufferBytes' bufferLength - 3);
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,DecodeFromUtf8InPlace,The following statement contains a magic number: int i2 = Unsafe.Add(ref bufferBytes' bufferLength - 2);
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,DecodeFromUtf8InPlace,The following statement contains a magic number: i0 <<= 18;
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,DecodeFromUtf8InPlace,The following statement contains a magic number: i1 <<= 12;
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,DecodeFromUtf8InPlace,The following statement contains a magic number: if (i3 != EncodingPad)              {                  i2 = Unsafe.Add(ref decodingMap' i2);                  i3 = Unsafe.Add(ref decodingMap' i3);                    i2 <<= 6;                    i0 |= i3;                  i0 |= i2;                    if (i0 < 0)                      goto InvalidExit;                  WriteThreeLowOrderBytes(ref Unsafe.Add(ref bufferBytes' destIndex)' i0);                  destIndex += 3;              }              else if (i2 != EncodingPad)              {                  i2 = Unsafe.Add(ref decodingMap' i2);                    i2 <<= 6;                    i0 |= i2;                    if (i0 < 0)                      goto InvalidExit;                  Unsafe.Add(ref bufferBytes' destIndex) = (byte)(i0 >> 16);                  Unsafe.Add(ref bufferBytes' destIndex + 1) = (byte)(i0 >> 8);                  destIndex += 2;              }              else              {                  if (i0 < 0)                      goto InvalidExit;                  Unsafe.Add(ref bufferBytes' destIndex) = (byte)(i0 >> 16);                  destIndex += 1;              }
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,DecodeFromUtf8InPlace,The following statement contains a magic number: if (i3 != EncodingPad)              {                  i2 = Unsafe.Add(ref decodingMap' i2);                  i3 = Unsafe.Add(ref decodingMap' i3);                    i2 <<= 6;                    i0 |= i3;                  i0 |= i2;                    if (i0 < 0)                      goto InvalidExit;                  WriteThreeLowOrderBytes(ref Unsafe.Add(ref bufferBytes' destIndex)' i0);                  destIndex += 3;              }              else if (i2 != EncodingPad)              {                  i2 = Unsafe.Add(ref decodingMap' i2);                    i2 <<= 6;                    i0 |= i2;                    if (i0 < 0)                      goto InvalidExit;                  Unsafe.Add(ref bufferBytes' destIndex) = (byte)(i0 >> 16);                  Unsafe.Add(ref bufferBytes' destIndex + 1) = (byte)(i0 >> 8);                  destIndex += 2;              }              else              {                  if (i0 < 0)                      goto InvalidExit;                  Unsafe.Add(ref bufferBytes' destIndex) = (byte)(i0 >> 16);                  destIndex += 1;              }
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,DecodeFromUtf8InPlace,The following statement contains a magic number: if (i3 != EncodingPad)              {                  i2 = Unsafe.Add(ref decodingMap' i2);                  i3 = Unsafe.Add(ref decodingMap' i3);                    i2 <<= 6;                    i0 |= i3;                  i0 |= i2;                    if (i0 < 0)                      goto InvalidExit;                  WriteThreeLowOrderBytes(ref Unsafe.Add(ref bufferBytes' destIndex)' i0);                  destIndex += 3;              }              else if (i2 != EncodingPad)              {                  i2 = Unsafe.Add(ref decodingMap' i2);                    i2 <<= 6;                    i0 |= i2;                    if (i0 < 0)                      goto InvalidExit;                  Unsafe.Add(ref bufferBytes' destIndex) = (byte)(i0 >> 16);                  Unsafe.Add(ref bufferBytes' destIndex + 1) = (byte)(i0 >> 8);                  destIndex += 2;              }              else              {                  if (i0 < 0)                      goto InvalidExit;                  Unsafe.Add(ref bufferBytes' destIndex) = (byte)(i0 >> 16);                  destIndex += 1;              }
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,DecodeFromUtf8InPlace,The following statement contains a magic number: if (i3 != EncodingPad)              {                  i2 = Unsafe.Add(ref decodingMap' i2);                  i3 = Unsafe.Add(ref decodingMap' i3);                    i2 <<= 6;                    i0 |= i3;                  i0 |= i2;                    if (i0 < 0)                      goto InvalidExit;                  WriteThreeLowOrderBytes(ref Unsafe.Add(ref bufferBytes' destIndex)' i0);                  destIndex += 3;              }              else if (i2 != EncodingPad)              {                  i2 = Unsafe.Add(ref decodingMap' i2);                    i2 <<= 6;                    i0 |= i2;                    if (i0 < 0)                      goto InvalidExit;                  Unsafe.Add(ref bufferBytes' destIndex) = (byte)(i0 >> 16);                  Unsafe.Add(ref bufferBytes' destIndex + 1) = (byte)(i0 >> 8);                  destIndex += 2;              }              else              {                  if (i0 < 0)                      goto InvalidExit;                  Unsafe.Add(ref bufferBytes' destIndex) = (byte)(i0 >> 16);                  destIndex += 1;              }
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,DecodeFromUtf8InPlace,The following statement contains a magic number: if (i3 != EncodingPad)              {                  i2 = Unsafe.Add(ref decodingMap' i2);                  i3 = Unsafe.Add(ref decodingMap' i3);                    i2 <<= 6;                    i0 |= i3;                  i0 |= i2;                    if (i0 < 0)                      goto InvalidExit;                  WriteThreeLowOrderBytes(ref Unsafe.Add(ref bufferBytes' destIndex)' i0);                  destIndex += 3;              }              else if (i2 != EncodingPad)              {                  i2 = Unsafe.Add(ref decodingMap' i2);                    i2 <<= 6;                    i0 |= i2;                    if (i0 < 0)                      goto InvalidExit;                  Unsafe.Add(ref bufferBytes' destIndex) = (byte)(i0 >> 16);                  Unsafe.Add(ref bufferBytes' destIndex + 1) = (byte)(i0 >> 8);                  destIndex += 2;              }              else              {                  if (i0 < 0)                      goto InvalidExit;                  Unsafe.Add(ref bufferBytes' destIndex) = (byte)(i0 >> 16);                  destIndex += 1;              }
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,DecodeFromUtf8InPlace,The following statement contains a magic number: if (i3 != EncodingPad)              {                  i2 = Unsafe.Add(ref decodingMap' i2);                  i3 = Unsafe.Add(ref decodingMap' i3);                    i2 <<= 6;                    i0 |= i3;                  i0 |= i2;                    if (i0 < 0)                      goto InvalidExit;                  WriteThreeLowOrderBytes(ref Unsafe.Add(ref bufferBytes' destIndex)' i0);                  destIndex += 3;              }              else if (i2 != EncodingPad)              {                  i2 = Unsafe.Add(ref decodingMap' i2);                    i2 <<= 6;                    i0 |= i2;                    if (i0 < 0)                      goto InvalidExit;                  Unsafe.Add(ref bufferBytes' destIndex) = (byte)(i0 >> 16);                  Unsafe.Add(ref bufferBytes' destIndex + 1) = (byte)(i0 >> 8);                  destIndex += 2;              }              else              {                  if (i0 < 0)                      goto InvalidExit;                  Unsafe.Add(ref bufferBytes' destIndex) = (byte)(i0 >> 16);                  destIndex += 1;              }
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,DecodeFromUtf8InPlace,The following statement contains a magic number: if (i3 != EncodingPad)              {                  i2 = Unsafe.Add(ref decodingMap' i2);                  i3 = Unsafe.Add(ref decodingMap' i3);                    i2 <<= 6;                    i0 |= i3;                  i0 |= i2;                    if (i0 < 0)                      goto InvalidExit;                  WriteThreeLowOrderBytes(ref Unsafe.Add(ref bufferBytes' destIndex)' i0);                  destIndex += 3;              }              else if (i2 != EncodingPad)              {                  i2 = Unsafe.Add(ref decodingMap' i2);                    i2 <<= 6;                    i0 |= i2;                    if (i0 < 0)                      goto InvalidExit;                  Unsafe.Add(ref bufferBytes' destIndex) = (byte)(i0 >> 16);                  Unsafe.Add(ref bufferBytes' destIndex + 1) = (byte)(i0 >> 8);                  destIndex += 2;              }              else              {                  if (i0 < 0)                      goto InvalidExit;                  Unsafe.Add(ref bufferBytes' destIndex) = (byte)(i0 >> 16);                  destIndex += 1;              }
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,Decode,The following statement contains a magic number: int i2 = Unsafe.Add(ref encodedBytes' 2);
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,Decode,The following statement contains a magic number: int i3 = Unsafe.Add(ref encodedBytes' 3);
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,Decode,The following statement contains a magic number: i0 <<= 18;
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,Decode,The following statement contains a magic number: i1 <<= 12;
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,Decode,The following statement contains a magic number: i2 <<= 6;
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,WriteThreeLowOrderBytes,The following statement contains a magic number: destination = (byte)(value >> 16);
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,WriteThreeLowOrderBytes,The following statement contains a magic number: Unsafe.Add(ref destination' 1) = (byte)(value >> 8);
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,WriteThreeLowOrderBytes,The following statement contains a magic number: Unsafe.Add(ref destination' 2) = (byte)value;
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,EncodeToUtf8,The following statement contains a magic number: if (srcLength <= MaximumEncodeLength && destLength >= GetMaxEncodedToUtf8Length(srcLength))              {                  maxSrcLength = srcLength - 2;              }              else              {                  maxSrcLength = (destLength >> 2) * 3 - 2;              }
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,EncodeToUtf8,The following statement contains a magic number: if (srcLength <= MaximumEncodeLength && destLength >= GetMaxEncodedToUtf8Length(srcLength))              {                  maxSrcLength = srcLength - 2;              }              else              {                  maxSrcLength = (destLength >> 2) * 3 - 2;              }
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,EncodeToUtf8,The following statement contains a magic number: if (srcLength <= MaximumEncodeLength && destLength >= GetMaxEncodedToUtf8Length(srcLength))              {                  maxSrcLength = srcLength - 2;              }              else              {                  maxSrcLength = (destLength >> 2) * 3 - 2;              }
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,EncodeToUtf8,The following statement contains a magic number: if (srcLength <= MaximumEncodeLength && destLength >= GetMaxEncodedToUtf8Length(srcLength))              {                  maxSrcLength = srcLength - 2;              }              else              {                  maxSrcLength = (destLength >> 2) * 3 - 2;              }
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,EncodeToUtf8,The following statement contains a magic number: while (sourceIndex < maxSrcLength)              {                  result = Encode(ref Unsafe.Add(ref srcBytes' sourceIndex)' ref encodingMap);                  Unsafe.WriteUnaligned(ref Unsafe.Add(ref destBytes' destIndex)' result);                  destIndex += 4;                  sourceIndex += 3;              }
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,EncodeToUtf8,The following statement contains a magic number: while (sourceIndex < maxSrcLength)              {                  result = Encode(ref Unsafe.Add(ref srcBytes' sourceIndex)' ref encodingMap);                  Unsafe.WriteUnaligned(ref Unsafe.Add(ref destBytes' destIndex)' result);                  destIndex += 4;                  sourceIndex += 3;              }
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,EncodeToUtf8,The following statement contains a magic number: if (maxSrcLength != srcLength - 2)                  goto DestinationSmallExit;
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,EncodeToUtf8,The following statement contains a magic number: if (sourceIndex == srcLength - 1)              {                  result = EncodeAndPadTwo(ref Unsafe.Add(ref srcBytes' sourceIndex)' ref encodingMap);                  Unsafe.WriteUnaligned(ref Unsafe.Add(ref destBytes' destIndex)' result);                  destIndex += 4;                  sourceIndex += 1;              }              else if (sourceIndex == srcLength - 2)              {                  result = EncodeAndPadOne(ref Unsafe.Add(ref srcBytes' sourceIndex)' ref encodingMap);                  Unsafe.WriteUnaligned(ref Unsafe.Add(ref destBytes' destIndex)' result);                  destIndex += 4;                  sourceIndex += 2;              }
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,EncodeToUtf8,The following statement contains a magic number: if (sourceIndex == srcLength - 1)              {                  result = EncodeAndPadTwo(ref Unsafe.Add(ref srcBytes' sourceIndex)' ref encodingMap);                  Unsafe.WriteUnaligned(ref Unsafe.Add(ref destBytes' destIndex)' result);                  destIndex += 4;                  sourceIndex += 1;              }              else if (sourceIndex == srcLength - 2)              {                  result = EncodeAndPadOne(ref Unsafe.Add(ref srcBytes' sourceIndex)' ref encodingMap);                  Unsafe.WriteUnaligned(ref Unsafe.Add(ref destBytes' destIndex)' result);                  destIndex += 4;                  sourceIndex += 2;              }
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,EncodeToUtf8,The following statement contains a magic number: if (sourceIndex == srcLength - 1)              {                  result = EncodeAndPadTwo(ref Unsafe.Add(ref srcBytes' sourceIndex)' ref encodingMap);                  Unsafe.WriteUnaligned(ref Unsafe.Add(ref destBytes' destIndex)' result);                  destIndex += 4;                  sourceIndex += 1;              }              else if (sourceIndex == srcLength - 2)              {                  result = EncodeAndPadOne(ref Unsafe.Add(ref srcBytes' sourceIndex)' ref encodingMap);                  Unsafe.WriteUnaligned(ref Unsafe.Add(ref destBytes' destIndex)' result);                  destIndex += 4;                  sourceIndex += 2;              }
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,EncodeToUtf8,The following statement contains a magic number: if (sourceIndex == srcLength - 1)              {                  result = EncodeAndPadTwo(ref Unsafe.Add(ref srcBytes' sourceIndex)' ref encodingMap);                  Unsafe.WriteUnaligned(ref Unsafe.Add(ref destBytes' destIndex)' result);                  destIndex += 4;                  sourceIndex += 1;              }              else if (sourceIndex == srcLength - 2)              {                  result = EncodeAndPadOne(ref Unsafe.Add(ref srcBytes' sourceIndex)' ref encodingMap);                  Unsafe.WriteUnaligned(ref Unsafe.Add(ref destBytes' destIndex)' result);                  destIndex += 4;                  sourceIndex += 2;              }
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,GetMaxEncodedToUtf8Length,The following statement contains a magic number: return (((length + 2) / 3) * 4);
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,GetMaxEncodedToUtf8Length,The following statement contains a magic number: return (((length + 2) / 3) * 4);
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,GetMaxEncodedToUtf8Length,The following statement contains a magic number: return (((length + 2) / 3) * 4);
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,EncodeToUtf8InPlace,The following statement contains a magic number: int leftover = dataLength - dataLength / 3 * 3;
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,EncodeToUtf8InPlace,The following statement contains a magic number: int leftover = dataLength - dataLength / 3 * 3;
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,EncodeToUtf8InPlace,The following statement contains a magic number: int destinationIndex = encodedLength - 4;
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,EncodeToUtf8InPlace,The following statement contains a magic number: if (leftover != 0)              {                  if (leftover == 1)                  {                      result = EncodeAndPadTwo(ref Unsafe.Add(ref bufferBytes' sourceIndex)' ref encodingMap);                      Unsafe.WriteUnaligned(ref Unsafe.Add(ref bufferBytes' destinationIndex)' result);                      destinationIndex -= 4;                  }                  else                  {                      result = EncodeAndPadOne(ref Unsafe.Add(ref bufferBytes' sourceIndex)' ref encodingMap);                      Unsafe.WriteUnaligned(ref Unsafe.Add(ref bufferBytes' destinationIndex)' result);                      destinationIndex -= 4;                  }              }
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,EncodeToUtf8InPlace,The following statement contains a magic number: if (leftover != 0)              {                  if (leftover == 1)                  {                      result = EncodeAndPadTwo(ref Unsafe.Add(ref bufferBytes' sourceIndex)' ref encodingMap);                      Unsafe.WriteUnaligned(ref Unsafe.Add(ref bufferBytes' destinationIndex)' result);                      destinationIndex -= 4;                  }                  else                  {                      result = EncodeAndPadOne(ref Unsafe.Add(ref bufferBytes' sourceIndex)' ref encodingMap);                      Unsafe.WriteUnaligned(ref Unsafe.Add(ref bufferBytes' destinationIndex)' result);                      destinationIndex -= 4;                  }              }
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,EncodeToUtf8InPlace,The following statement contains a magic number: sourceIndex -= 3;
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,EncodeToUtf8InPlace,The following statement contains a magic number: while (sourceIndex >= 0)              {                  result = Encode(ref Unsafe.Add(ref bufferBytes' sourceIndex)' ref encodingMap);                  Unsafe.WriteUnaligned(ref Unsafe.Add(ref bufferBytes' destinationIndex)' result);                  destinationIndex -= 4;                  sourceIndex -= 3;              }
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,EncodeToUtf8InPlace,The following statement contains a magic number: while (sourceIndex >= 0)              {                  result = Encode(ref Unsafe.Add(ref bufferBytes' sourceIndex)' ref encodingMap);                  Unsafe.WriteUnaligned(ref Unsafe.Add(ref bufferBytes' destinationIndex)' result);                  destinationIndex -= 4;                  sourceIndex -= 3;              }
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,Encode,The following statement contains a magic number: int i = (threeBytes << 16) | (Unsafe.Add(ref threeBytes' 1) << 8) | Unsafe.Add(ref threeBytes' 2);
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,Encode,The following statement contains a magic number: int i = (threeBytes << 16) | (Unsafe.Add(ref threeBytes' 1) << 8) | Unsafe.Add(ref threeBytes' 2);
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,Encode,The following statement contains a magic number: int i = (threeBytes << 16) | (Unsafe.Add(ref threeBytes' 1) << 8) | Unsafe.Add(ref threeBytes' 2);
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,Encode,The following statement contains a magic number: int i0 = Unsafe.Add(ref encodingMap' i >> 18);
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,Encode,The following statement contains a magic number: int i1 = Unsafe.Add(ref encodingMap' (i >> 12) & 0x3F);
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,Encode,The following statement contains a magic number: int i2 = Unsafe.Add(ref encodingMap' (i >> 6) & 0x3F);
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,Encode,The following statement contains a magic number: return i0 | (i1 << 8) | (i2 << 16) | (i3 << 24);
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,Encode,The following statement contains a magic number: return i0 | (i1 << 8) | (i2 << 16) | (i3 << 24);
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,Encode,The following statement contains a magic number: return i0 | (i1 << 8) | (i2 << 16) | (i3 << 24);
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,EncodeAndPadOne,The following statement contains a magic number: int i = (twoBytes << 16) | (Unsafe.Add(ref twoBytes' 1) << 8);
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,EncodeAndPadOne,The following statement contains a magic number: int i = (twoBytes << 16) | (Unsafe.Add(ref twoBytes' 1) << 8);
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,EncodeAndPadOne,The following statement contains a magic number: int i0 = Unsafe.Add(ref encodingMap' i >> 18);
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,EncodeAndPadOne,The following statement contains a magic number: int i1 = Unsafe.Add(ref encodingMap' (i >> 12) & 0x3F);
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,EncodeAndPadOne,The following statement contains a magic number: int i2 = Unsafe.Add(ref encodingMap' (i >> 6) & 0x3F);
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,EncodeAndPadOne,The following statement contains a magic number: return i0 | (i1 << 8) | (i2 << 16) | (EncodingPad << 24);
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,EncodeAndPadOne,The following statement contains a magic number: return i0 | (i1 << 8) | (i2 << 16) | (EncodingPad << 24);
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,EncodeAndPadOne,The following statement contains a magic number: return i0 | (i1 << 8) | (i2 << 16) | (EncodingPad << 24);
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,EncodeAndPadTwo,The following statement contains a magic number: int i = (oneByte << 8);
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,EncodeAndPadTwo,The following statement contains a magic number: int i0 = Unsafe.Add(ref encodingMap' i >> 10);
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,EncodeAndPadTwo,The following statement contains a magic number: int i1 = Unsafe.Add(ref encodingMap' (i >> 4) & 0x3F);
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,EncodeAndPadTwo,The following statement contains a magic number: return i0 | (i1 << 8) | (EncodingPad << 16) | (EncodingPad << 24);
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,EncodeAndPadTwo,The following statement contains a magic number: return i0 | (i1 << 8) | (EncodingPad << 16) | (EncodingPad << 24);
Magic Number,System.Buffers.Text,Base64,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Base64Decoder.cs,EncodeAndPadTwo,The following statement contains a magic number: return i0 | (i1 << 8) | (EncodingPad << 16) | (EncodingPad << 24);
Magic Number,System.Buffers.Text,FormattingHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\FormattingHelpers.cs,WriteHexByte,The following statement contains a magic number: Unsafe.Add(ref buffer' index) = (byte)HexTable[value >> 4];
Magic Number,System.Buffers.Text,FormattingHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\FormattingHelpers.cs,WriteFractionDigits,The following statement contains a magic number: for (int i = FractionDigits; i > digitCount; i--)                  value /= 10;
Magic Number,System.Buffers.Text,FormattingHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\FormattingHelpers.cs,WriteDigits,The following statement contains a magic number: for (int i = buffer.Length - 1; i >= 1; i--)              {                  left = DivMod(left' 10' out ulong num);                  buffer[i] = (byte)('0' + num);              }
Magic Number,System.Buffers.Text,FormattingHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\FormattingHelpers.cs,WriteDigits,The following statement contains a magic number: Debug.Assert(left < 10);
Magic Number,System.Buffers.Text,FormattingHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\FormattingHelpers.cs,WriteDigits,The following statement contains a magic number: for (int i = buffer.Length - 1; i >= 1; i--)              {                  left = DivMod(left' 10' out uint num);                  buffer[i] = (byte)('0' + num);              }
Magic Number,System.Buffers.Text,FormattingHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\FormattingHelpers.cs,WriteDigits,The following statement contains a magic number: Debug.Assert(left < 10);
Magic Number,System.Buffers.Text,FormattingHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\FormattingHelpers.cs,WriteDigits,The following statement contains a magic number: for (int i = digitCount - 1; i >= 0; i--)              {                  left = DivMod(left' 10' out long num);                  Unsafe.Add(ref buffer' index + i) = (byte)('0' + num);              }
Magic Number,System.Buffers.Text,FormattingHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\FormattingHelpers.cs,WriteDigits,The following statement contains a magic number: for (int i = digitCount - 1; i >= 0; i--)              {                  left = DivMod(left' 10' out ulong num);                  Unsafe.Add(ref buffer' index + i) = (byte)('0' + num);              }
Magic Number,System.Buffers.Text,FormattingHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\FormattingHelpers.cs,CountDigits,The following statement contains a magic number: while (n != 0)              {                  n /= 10;                  digits++;              }
Magic Number,System.Buffers.Text,FormattingHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\FormattingHelpers.cs,CountDigits,The following statement contains a magic number: if (value >= 10000000)              {                  if (value >= 100000000000000)                  {                      part = (uint)(value / 100000000000000);                      digits += 14;                  }                  else                  {                      part = (uint)(value / 10000000);                      digits += 7;                  }              }              else              {                  part = (uint)value;              }
Magic Number,System.Buffers.Text,FormattingHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\FormattingHelpers.cs,CountDigits,The following statement contains a magic number: if (value >= 10000000)              {                  if (value >= 100000000000000)                  {                      part = (uint)(value / 100000000000000);                      digits += 14;                  }                  else                  {                      part = (uint)(value / 10000000);                      digits += 7;                  }              }              else              {                  part = (uint)value;              }
Magic Number,System.Buffers.Text,FormattingHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\FormattingHelpers.cs,CountDigits,The following statement contains a magic number: if (value >= 10000000)              {                  if (value >= 100000000000000)                  {                      part = (uint)(value / 100000000000000);                      digits += 14;                  }                  else                  {                      part = (uint)(value / 10000000);                      digits += 7;                  }              }              else              {                  part = (uint)value;              }
Magic Number,System.Buffers.Text,FormattingHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\FormattingHelpers.cs,CountDigits,The following statement contains a magic number: if (value >= 10000000)              {                  if (value >= 100000000000000)                  {                      part = (uint)(value / 100000000000000);                      digits += 14;                  }                  else                  {                      part = (uint)(value / 10000000);                      digits += 7;                  }              }              else              {                  part = (uint)value;              }
Magic Number,System.Buffers.Text,FormattingHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\FormattingHelpers.cs,CountDigits,The following statement contains a magic number: if (value >= 10000000)              {                  if (value >= 100000000000000)                  {                      part = (uint)(value / 100000000000000);                      digits += 14;                  }                  else                  {                      part = (uint)(value / 10000000);                      digits += 7;                  }              }              else              {                  part = (uint)value;              }
Magic Number,System.Buffers.Text,FormattingHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\FormattingHelpers.cs,CountDigits,The following statement contains a magic number: if (value >= 10000000)              {                  if (value >= 100000000000000)                  {                      part = (uint)(value / 100000000000000);                      digits += 14;                  }                  else                  {                      part = (uint)(value / 10000000);                      digits += 7;                  }              }              else              {                  part = (uint)value;              }
Magic Number,System.Buffers.Text,FormattingHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\FormattingHelpers.cs,CountDigits,The following statement contains a magic number: if (part < 10)              {                  // no-op              }              else if (part < 100)              {                  digits += 1;              }              else if (part < 1000)              {                  digits += 2;              }              else if (part < 10000)              {                  digits += 3;              }              else if (part < 100000)              {                  digits += 4;              }              else if (part < 1000000)              {                  digits += 5;              }              else              {                  Debug.Assert(part < 10000000);                  digits += 6;              }
Magic Number,System.Buffers.Text,FormattingHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\FormattingHelpers.cs,CountDigits,The following statement contains a magic number: if (part < 10)              {                  // no-op              }              else if (part < 100)              {                  digits += 1;              }              else if (part < 1000)              {                  digits += 2;              }              else if (part < 10000)              {                  digits += 3;              }              else if (part < 100000)              {                  digits += 4;              }              else if (part < 1000000)              {                  digits += 5;              }              else              {                  Debug.Assert(part < 10000000);                  digits += 6;              }
Magic Number,System.Buffers.Text,FormattingHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\FormattingHelpers.cs,CountDigits,The following statement contains a magic number: if (part < 10)              {                  // no-op              }              else if (part < 100)              {                  digits += 1;              }              else if (part < 1000)              {                  digits += 2;              }              else if (part < 10000)              {                  digits += 3;              }              else if (part < 100000)              {                  digits += 4;              }              else if (part < 1000000)              {                  digits += 5;              }              else              {                  Debug.Assert(part < 10000000);                  digits += 6;              }
Magic Number,System.Buffers.Text,FormattingHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\FormattingHelpers.cs,CountDigits,The following statement contains a magic number: if (part < 10)              {                  // no-op              }              else if (part < 100)              {                  digits += 1;              }              else if (part < 1000)              {                  digits += 2;              }              else if (part < 10000)              {                  digits += 3;              }              else if (part < 100000)              {                  digits += 4;              }              else if (part < 1000000)              {                  digits += 5;              }              else              {                  Debug.Assert(part < 10000000);                  digits += 6;              }
Magic Number,System.Buffers.Text,FormattingHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\FormattingHelpers.cs,CountDigits,The following statement contains a magic number: if (part < 10)              {                  // no-op              }              else if (part < 100)              {                  digits += 1;              }              else if (part < 1000)              {                  digits += 2;              }              else if (part < 10000)              {                  digits += 3;              }              else if (part < 100000)              {                  digits += 4;              }              else if (part < 1000000)              {                  digits += 5;              }              else              {                  Debug.Assert(part < 10000000);                  digits += 6;              }
Magic Number,System.Buffers.Text,FormattingHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\FormattingHelpers.cs,CountDigits,The following statement contains a magic number: if (part < 10)              {                  // no-op              }              else if (part < 100)              {                  digits += 1;              }              else if (part < 1000)              {                  digits += 2;              }              else if (part < 10000)              {                  digits += 3;              }              else if (part < 100000)              {                  digits += 4;              }              else if (part < 1000000)              {                  digits += 5;              }              else              {                  Debug.Assert(part < 10000000);                  digits += 6;              }
Magic Number,System.Buffers.Text,FormattingHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\FormattingHelpers.cs,CountDigits,The following statement contains a magic number: if (part < 10)              {                  // no-op              }              else if (part < 100)              {                  digits += 1;              }              else if (part < 1000)              {                  digits += 2;              }              else if (part < 10000)              {                  digits += 3;              }              else if (part < 100000)              {                  digits += 4;              }              else if (part < 1000000)              {                  digits += 5;              }              else              {                  Debug.Assert(part < 10000000);                  digits += 6;              }
Magic Number,System.Buffers.Text,FormattingHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\FormattingHelpers.cs,CountDigits,The following statement contains a magic number: if (part < 10)              {                  // no-op              }              else if (part < 100)              {                  digits += 1;              }              else if (part < 1000)              {                  digits += 2;              }              else if (part < 10000)              {                  digits += 3;              }              else if (part < 100000)              {                  digits += 4;              }              else if (part < 1000000)              {                  digits += 5;              }              else              {                  Debug.Assert(part < 10000000);                  digits += 6;              }
Magic Number,System.Buffers.Text,FormattingHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\FormattingHelpers.cs,CountDigits,The following statement contains a magic number: if (part < 10)              {                  // no-op              }              else if (part < 100)              {                  digits += 1;              }              else if (part < 1000)              {                  digits += 2;              }              else if (part < 10000)              {                  digits += 3;              }              else if (part < 100000)              {                  digits += 4;              }              else if (part < 1000000)              {                  digits += 5;              }              else              {                  Debug.Assert(part < 10000000);                  digits += 6;              }
Magic Number,System.Buffers.Text,FormattingHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\FormattingHelpers.cs,CountDigits,The following statement contains a magic number: if (part < 10)              {                  // no-op              }              else if (part < 100)              {                  digits += 1;              }              else if (part < 1000)              {                  digits += 2;              }              else if (part < 10000)              {                  digits += 3;              }              else if (part < 100000)              {                  digits += 4;              }              else if (part < 1000000)              {                  digits += 5;              }              else              {                  Debug.Assert(part < 10000000);                  digits += 6;              }
Magic Number,System.Buffers.Text,FormattingHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\FormattingHelpers.cs,CountDigits,The following statement contains a magic number: if (part < 10)              {                  // no-op              }              else if (part < 100)              {                  digits += 1;              }              else if (part < 1000)              {                  digits += 2;              }              else if (part < 10000)              {                  digits += 3;              }              else if (part < 100000)              {                  digits += 4;              }              else if (part < 1000000)              {                  digits += 5;              }              else              {                  Debug.Assert(part < 10000000);                  digits += 6;              }
Magic Number,System.Buffers.Text,FormattingHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\FormattingHelpers.cs,CountDigits,The following statement contains a magic number: if (part < 10)              {                  // no-op              }              else if (part < 100)              {                  digits += 1;              }              else if (part < 1000)              {                  digits += 2;              }              else if (part < 10000)              {                  digits += 3;              }              else if (part < 100000)              {                  digits += 4;              }              else if (part < 1000000)              {                  digits += 5;              }              else              {                  Debug.Assert(part < 10000000);                  digits += 6;              }
Magic Number,System.Buffers.Text,FormattingHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\FormattingHelpers.cs,CountDigits,The following statement contains a magic number: if (value >= 100000)              {                  value = value / 100000;                  digits += 5;              }
Magic Number,System.Buffers.Text,FormattingHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\FormattingHelpers.cs,CountDigits,The following statement contains a magic number: if (value >= 100000)              {                  value = value / 100000;                  digits += 5;              }
Magic Number,System.Buffers.Text,FormattingHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\FormattingHelpers.cs,CountDigits,The following statement contains a magic number: if (value >= 100000)              {                  value = value / 100000;                  digits += 5;              }
Magic Number,System.Buffers.Text,FormattingHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\FormattingHelpers.cs,CountDigits,The following statement contains a magic number: if (value < 10)               {                   // no-op              }              else if (value < 100)               {                  digits += 1;              }              else if (value < 1000)              {                  digits += 2;              }              else if (value < 10000)              {                  digits += 3;              }              else              {                  Debug.Assert(value < 100000);                  digits += 4;              }
Magic Number,System.Buffers.Text,FormattingHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\FormattingHelpers.cs,CountDigits,The following statement contains a magic number: if (value < 10)               {                   // no-op              }              else if (value < 100)               {                  digits += 1;              }              else if (value < 1000)              {                  digits += 2;              }              else if (value < 10000)              {                  digits += 3;              }              else              {                  Debug.Assert(value < 100000);                  digits += 4;              }
Magic Number,System.Buffers.Text,FormattingHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\FormattingHelpers.cs,CountDigits,The following statement contains a magic number: if (value < 10)               {                   // no-op              }              else if (value < 100)               {                  digits += 1;              }              else if (value < 1000)              {                  digits += 2;              }              else if (value < 10000)              {                  digits += 3;              }              else              {                  Debug.Assert(value < 100000);                  digits += 4;              }
Magic Number,System.Buffers.Text,FormattingHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\FormattingHelpers.cs,CountDigits,The following statement contains a magic number: if (value < 10)               {                   // no-op              }              else if (value < 100)               {                  digits += 1;              }              else if (value < 1000)              {                  digits += 2;              }              else if (value < 10000)              {                  digits += 3;              }              else              {                  Debug.Assert(value < 100000);                  digits += 4;              }
Magic Number,System.Buffers.Text,FormattingHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\FormattingHelpers.cs,CountDigits,The following statement contains a magic number: if (value < 10)               {                   // no-op              }              else if (value < 100)               {                  digits += 1;              }              else if (value < 1000)              {                  digits += 2;              }              else if (value < 10000)              {                  digits += 3;              }              else              {                  Debug.Assert(value < 100000);                  digits += 4;              }
Magic Number,System.Buffers.Text,FormattingHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\FormattingHelpers.cs,CountDigits,The following statement contains a magic number: if (value < 10)               {                   // no-op              }              else if (value < 100)               {                  digits += 1;              }              else if (value < 1000)              {                  digits += 2;              }              else if (value < 10000)              {                  digits += 3;              }              else              {                  Debug.Assert(value < 100000);                  digits += 4;              }
Magic Number,System.Buffers.Text,FormattingHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\FormattingHelpers.cs,CountDigits,The following statement contains a magic number: if (value < 10)               {                   // no-op              }              else if (value < 100)               {                  digits += 1;              }              else if (value < 1000)              {                  digits += 2;              }              else if (value < 10000)              {                  digits += 3;              }              else              {                  Debug.Assert(value < 100000);                  digits += 4;              }
Magic Number,System.Buffers.Text,FormattingHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\FormattingHelpers.cs,CountDigits,The following statement contains a magic number: if (value < 10)               {                   // no-op              }              else if (value < 100)               {                  digits += 1;              }              else if (value < 1000)              {                  digits += 2;              }              else if (value < 10000)              {                  digits += 3;              }              else              {                  Debug.Assert(value < 100000);                  digits += 4;              }
Magic Number,System.Buffers.Text,FormattingHelpers,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\FormattingHelpers.cs,CountFractionDigits,The following statement contains a magic number: while (left > 0 && m == 0 && count > 0)              {                  left = DivMod(left' 10' out m);                  count--;              }
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeG,The following statement contains a magic number: const int MinimumBytesNeeded = 19;
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeG,The following statement contains a magic number: if (offset != Utf8Constants.s_nullUtcOffset)              {                  bytesWritten += 7; // Space['+'|'-']hh:ss              }
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeG,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Month' 2' ref utf8Bytes' 0);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeG,The following statement contains a magic number: Unsafe.Add(ref utf8Bytes' 2) = Utf8Constants.Slash;
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeG,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Day' 2' ref utf8Bytes' 3);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeG,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Day' 2' ref utf8Bytes' 3);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeG,The following statement contains a magic number: Unsafe.Add(ref utf8Bytes' 5) = Utf8Constants.Slash;
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeG,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Year' 4' ref utf8Bytes' 6);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeG,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Year' 4' ref utf8Bytes' 6);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeG,The following statement contains a magic number: Unsafe.Add(ref utf8Bytes' 10) = Utf8Constants.Space;
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeG,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Hour' 2' ref utf8Bytes' 11);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeG,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Hour' 2' ref utf8Bytes' 11);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeG,The following statement contains a magic number: Unsafe.Add(ref utf8Bytes' 13) = Utf8Constants.Colon;
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeG,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Minute' 2' ref utf8Bytes' 14);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeG,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Minute' 2' ref utf8Bytes' 14);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeG,The following statement contains a magic number: Unsafe.Add(ref utf8Bytes' 16) = Utf8Constants.Colon;
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeG,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Second' 2' ref utf8Bytes' 17);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeG,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Second' 2' ref utf8Bytes' 17);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeG,The following statement contains a magic number: if (offset != Utf8Constants.s_nullUtcOffset)              {                  Unsafe.Add(ref utf8Bytes' 19) = Utf8Constants.Space;                    int offsetHours = offset.Hours;                  if (offsetHours >= 0)                  {                      Unsafe.Add(ref utf8Bytes' 20) = Utf8Constants.Plus;                      FormattingHelpers.WriteDigits(offsetHours' 2' ref utf8Bytes' 21);                  }                  else                  {                      Unsafe.Add(ref utf8Bytes' 20) = Utf8Constants.Minus;                      FormattingHelpers.WriteDigits(-offsetHours' 2' ref utf8Bytes' 21);                  }                    int offsetMinutes = Math.Abs(offset.Minutes);                  Unsafe.Add(ref utf8Bytes' 23) = Utf8Constants.Colon;                  FormattingHelpers.WriteDigits(offsetMinutes' 2' ref utf8Bytes' 24);              }
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeG,The following statement contains a magic number: if (offset != Utf8Constants.s_nullUtcOffset)              {                  Unsafe.Add(ref utf8Bytes' 19) = Utf8Constants.Space;                    int offsetHours = offset.Hours;                  if (offsetHours >= 0)                  {                      Unsafe.Add(ref utf8Bytes' 20) = Utf8Constants.Plus;                      FormattingHelpers.WriteDigits(offsetHours' 2' ref utf8Bytes' 21);                  }                  else                  {                      Unsafe.Add(ref utf8Bytes' 20) = Utf8Constants.Minus;                      FormattingHelpers.WriteDigits(-offsetHours' 2' ref utf8Bytes' 21);                  }                    int offsetMinutes = Math.Abs(offset.Minutes);                  Unsafe.Add(ref utf8Bytes' 23) = Utf8Constants.Colon;                  FormattingHelpers.WriteDigits(offsetMinutes' 2' ref utf8Bytes' 24);              }
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeG,The following statement contains a magic number: if (offset != Utf8Constants.s_nullUtcOffset)              {                  Unsafe.Add(ref utf8Bytes' 19) = Utf8Constants.Space;                    int offsetHours = offset.Hours;                  if (offsetHours >= 0)                  {                      Unsafe.Add(ref utf8Bytes' 20) = Utf8Constants.Plus;                      FormattingHelpers.WriteDigits(offsetHours' 2' ref utf8Bytes' 21);                  }                  else                  {                      Unsafe.Add(ref utf8Bytes' 20) = Utf8Constants.Minus;                      FormattingHelpers.WriteDigits(-offsetHours' 2' ref utf8Bytes' 21);                  }                    int offsetMinutes = Math.Abs(offset.Minutes);                  Unsafe.Add(ref utf8Bytes' 23) = Utf8Constants.Colon;                  FormattingHelpers.WriteDigits(offsetMinutes' 2' ref utf8Bytes' 24);              }
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeG,The following statement contains a magic number: if (offset != Utf8Constants.s_nullUtcOffset)              {                  Unsafe.Add(ref utf8Bytes' 19) = Utf8Constants.Space;                    int offsetHours = offset.Hours;                  if (offsetHours >= 0)                  {                      Unsafe.Add(ref utf8Bytes' 20) = Utf8Constants.Plus;                      FormattingHelpers.WriteDigits(offsetHours' 2' ref utf8Bytes' 21);                  }                  else                  {                      Unsafe.Add(ref utf8Bytes' 20) = Utf8Constants.Minus;                      FormattingHelpers.WriteDigits(-offsetHours' 2' ref utf8Bytes' 21);                  }                    int offsetMinutes = Math.Abs(offset.Minutes);                  Unsafe.Add(ref utf8Bytes' 23) = Utf8Constants.Colon;                  FormattingHelpers.WriteDigits(offsetMinutes' 2' ref utf8Bytes' 24);              }
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeG,The following statement contains a magic number: if (offset != Utf8Constants.s_nullUtcOffset)              {                  Unsafe.Add(ref utf8Bytes' 19) = Utf8Constants.Space;                    int offsetHours = offset.Hours;                  if (offsetHours >= 0)                  {                      Unsafe.Add(ref utf8Bytes' 20) = Utf8Constants.Plus;                      FormattingHelpers.WriteDigits(offsetHours' 2' ref utf8Bytes' 21);                  }                  else                  {                      Unsafe.Add(ref utf8Bytes' 20) = Utf8Constants.Minus;                      FormattingHelpers.WriteDigits(-offsetHours' 2' ref utf8Bytes' 21);                  }                    int offsetMinutes = Math.Abs(offset.Minutes);                  Unsafe.Add(ref utf8Bytes' 23) = Utf8Constants.Colon;                  FormattingHelpers.WriteDigits(offsetMinutes' 2' ref utf8Bytes' 24);              }
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeG,The following statement contains a magic number: if (offset != Utf8Constants.s_nullUtcOffset)              {                  Unsafe.Add(ref utf8Bytes' 19) = Utf8Constants.Space;                    int offsetHours = offset.Hours;                  if (offsetHours >= 0)                  {                      Unsafe.Add(ref utf8Bytes' 20) = Utf8Constants.Plus;                      FormattingHelpers.WriteDigits(offsetHours' 2' ref utf8Bytes' 21);                  }                  else                  {                      Unsafe.Add(ref utf8Bytes' 20) = Utf8Constants.Minus;                      FormattingHelpers.WriteDigits(-offsetHours' 2' ref utf8Bytes' 21);                  }                    int offsetMinutes = Math.Abs(offset.Minutes);                  Unsafe.Add(ref utf8Bytes' 23) = Utf8Constants.Colon;                  FormattingHelpers.WriteDigits(offsetMinutes' 2' ref utf8Bytes' 24);              }
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeG,The following statement contains a magic number: if (offset != Utf8Constants.s_nullUtcOffset)              {                  Unsafe.Add(ref utf8Bytes' 19) = Utf8Constants.Space;                    int offsetHours = offset.Hours;                  if (offsetHours >= 0)                  {                      Unsafe.Add(ref utf8Bytes' 20) = Utf8Constants.Plus;                      FormattingHelpers.WriteDigits(offsetHours' 2' ref utf8Bytes' 21);                  }                  else                  {                      Unsafe.Add(ref utf8Bytes' 20) = Utf8Constants.Minus;                      FormattingHelpers.WriteDigits(-offsetHours' 2' ref utf8Bytes' 21);                  }                    int offsetMinutes = Math.Abs(offset.Minutes);                  Unsafe.Add(ref utf8Bytes' 23) = Utf8Constants.Colon;                  FormattingHelpers.WriteDigits(offsetMinutes' 2' ref utf8Bytes' 24);              }
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeG,The following statement contains a magic number: if (offset != Utf8Constants.s_nullUtcOffset)              {                  Unsafe.Add(ref utf8Bytes' 19) = Utf8Constants.Space;                    int offsetHours = offset.Hours;                  if (offsetHours >= 0)                  {                      Unsafe.Add(ref utf8Bytes' 20) = Utf8Constants.Plus;                      FormattingHelpers.WriteDigits(offsetHours' 2' ref utf8Bytes' 21);                  }                  else                  {                      Unsafe.Add(ref utf8Bytes' 20) = Utf8Constants.Minus;                      FormattingHelpers.WriteDigits(-offsetHours' 2' ref utf8Bytes' 21);                  }                    int offsetMinutes = Math.Abs(offset.Minutes);                  Unsafe.Add(ref utf8Bytes' 23) = Utf8Constants.Colon;                  FormattingHelpers.WriteDigits(offsetMinutes' 2' ref utf8Bytes' 24);              }
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeG,The following statement contains a magic number: if (offset != Utf8Constants.s_nullUtcOffset)              {                  Unsafe.Add(ref utf8Bytes' 19) = Utf8Constants.Space;                    int offsetHours = offset.Hours;                  if (offsetHours >= 0)                  {                      Unsafe.Add(ref utf8Bytes' 20) = Utf8Constants.Plus;                      FormattingHelpers.WriteDigits(offsetHours' 2' ref utf8Bytes' 21);                  }                  else                  {                      Unsafe.Add(ref utf8Bytes' 20) = Utf8Constants.Minus;                      FormattingHelpers.WriteDigits(-offsetHours' 2' ref utf8Bytes' 21);                  }                    int offsetMinutes = Math.Abs(offset.Minutes);                  Unsafe.Add(ref utf8Bytes' 23) = Utf8Constants.Colon;                  FormattingHelpers.WriteDigits(offsetMinutes' 2' ref utf8Bytes' 24);              }
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeG,The following statement contains a magic number: if (offset != Utf8Constants.s_nullUtcOffset)              {                  Unsafe.Add(ref utf8Bytes' 19) = Utf8Constants.Space;                    int offsetHours = offset.Hours;                  if (offsetHours >= 0)                  {                      Unsafe.Add(ref utf8Bytes' 20) = Utf8Constants.Plus;                      FormattingHelpers.WriteDigits(offsetHours' 2' ref utf8Bytes' 21);                  }                  else                  {                      Unsafe.Add(ref utf8Bytes' 20) = Utf8Constants.Minus;                      FormattingHelpers.WriteDigits(-offsetHours' 2' ref utf8Bytes' 21);                  }                    int offsetMinutes = Math.Abs(offset.Minutes);                  Unsafe.Add(ref utf8Bytes' 23) = Utf8Constants.Colon;                  FormattingHelpers.WriteDigits(offsetMinutes' 2' ref utf8Bytes' 24);              }
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeO,The following statement contains a magic number: const int MinimumBytesNeeded = 27;
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeO,The following statement contains a magic number: if (offset == Utf8Constants.s_nullUtcOffset)              {                  kind = value.Kind;                  if (kind == DateTimeKind.Local)                  {                      offset = TimeZoneInfo.Local.GetUtcOffset(value);                      bytesWritten += 6;                  }                  else if (kind == DateTimeKind.Utc)                  {                      bytesWritten += 1;                  }              }              else              {                  bytesWritten += 6;              }
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeO,The following statement contains a magic number: if (offset == Utf8Constants.s_nullUtcOffset)              {                  kind = value.Kind;                  if (kind == DateTimeKind.Local)                  {                      offset = TimeZoneInfo.Local.GetUtcOffset(value);                      bytesWritten += 6;                  }                  else if (kind == DateTimeKind.Utc)                  {                      bytesWritten += 1;                  }              }              else              {                  bytesWritten += 6;              }
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeO,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Year' 4' ref utf8Bytes' 0);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeO,The following statement contains a magic number: Unsafe.Add(ref utf8Bytes' 4) = Utf8Constants.Minus;
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeO,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Month' 2' ref utf8Bytes' 5);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeO,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Month' 2' ref utf8Bytes' 5);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeO,The following statement contains a magic number: Unsafe.Add(ref utf8Bytes' 7) = Utf8Constants.Minus;
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeO,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Day' 2' ref utf8Bytes' 8);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeO,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Day' 2' ref utf8Bytes' 8);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeO,The following statement contains a magic number: Unsafe.Add(ref utf8Bytes' 10) = TimeMarker;
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeO,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Hour' 2' ref utf8Bytes' 11);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeO,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Hour' 2' ref utf8Bytes' 11);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeO,The following statement contains a magic number: Unsafe.Add(ref utf8Bytes' 13) = Utf8Constants.Colon;
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeO,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Minute' 2' ref utf8Bytes' 14);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeO,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Minute' 2' ref utf8Bytes' 14);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeO,The following statement contains a magic number: Unsafe.Add(ref utf8Bytes' 16) = Utf8Constants.Colon;
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeO,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Second' 2' ref utf8Bytes' 17);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeO,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Second' 2' ref utf8Bytes' 17);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeO,The following statement contains a magic number: Unsafe.Add(ref utf8Bytes' 19) = Utf8Constants.Period;
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeO,The following statement contains a magic number: FormattingHelpers.WriteDigits(fraction' Utf8Constants.DateTimeNumFractionDigits' ref utf8Bytes' 20);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeO,The following statement contains a magic number: if (kind == DateTimeKind.Local)              {                  int hours = offset.Hours;                  byte sign = Utf8Constants.Plus;                    if (offset.Hours < 0)                  {                      hours = -offset.Hours;                      sign = Utf8Constants.Minus;                  }                    Unsafe.Add(ref utf8Bytes' 27) = sign;                  FormattingHelpers.WriteDigits(hours' 2' ref utf8Bytes' 28);                  Unsafe.Add(ref utf8Bytes' 30) = Utf8Constants.Colon;                  int offsetMinutes = Math.Abs(offset.Minutes);                  FormattingHelpers.WriteDigits(offsetMinutes' 2' ref utf8Bytes' 31);              }              else if (kind == DateTimeKind.Utc)              {                  Unsafe.Add(ref utf8Bytes' 27) = UtcMarker;              }
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeO,The following statement contains a magic number: if (kind == DateTimeKind.Local)              {                  int hours = offset.Hours;                  byte sign = Utf8Constants.Plus;                    if (offset.Hours < 0)                  {                      hours = -offset.Hours;                      sign = Utf8Constants.Minus;                  }                    Unsafe.Add(ref utf8Bytes' 27) = sign;                  FormattingHelpers.WriteDigits(hours' 2' ref utf8Bytes' 28);                  Unsafe.Add(ref utf8Bytes' 30) = Utf8Constants.Colon;                  int offsetMinutes = Math.Abs(offset.Minutes);                  FormattingHelpers.WriteDigits(offsetMinutes' 2' ref utf8Bytes' 31);              }              else if (kind == DateTimeKind.Utc)              {                  Unsafe.Add(ref utf8Bytes' 27) = UtcMarker;              }
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeO,The following statement contains a magic number: if (kind == DateTimeKind.Local)              {                  int hours = offset.Hours;                  byte sign = Utf8Constants.Plus;                    if (offset.Hours < 0)                  {                      hours = -offset.Hours;                      sign = Utf8Constants.Minus;                  }                    Unsafe.Add(ref utf8Bytes' 27) = sign;                  FormattingHelpers.WriteDigits(hours' 2' ref utf8Bytes' 28);                  Unsafe.Add(ref utf8Bytes' 30) = Utf8Constants.Colon;                  int offsetMinutes = Math.Abs(offset.Minutes);                  FormattingHelpers.WriteDigits(offsetMinutes' 2' ref utf8Bytes' 31);              }              else if (kind == DateTimeKind.Utc)              {                  Unsafe.Add(ref utf8Bytes' 27) = UtcMarker;              }
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeO,The following statement contains a magic number: if (kind == DateTimeKind.Local)              {                  int hours = offset.Hours;                  byte sign = Utf8Constants.Plus;                    if (offset.Hours < 0)                  {                      hours = -offset.Hours;                      sign = Utf8Constants.Minus;                  }                    Unsafe.Add(ref utf8Bytes' 27) = sign;                  FormattingHelpers.WriteDigits(hours' 2' ref utf8Bytes' 28);                  Unsafe.Add(ref utf8Bytes' 30) = Utf8Constants.Colon;                  int offsetMinutes = Math.Abs(offset.Minutes);                  FormattingHelpers.WriteDigits(offsetMinutes' 2' ref utf8Bytes' 31);              }              else if (kind == DateTimeKind.Utc)              {                  Unsafe.Add(ref utf8Bytes' 27) = UtcMarker;              }
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeO,The following statement contains a magic number: if (kind == DateTimeKind.Local)              {                  int hours = offset.Hours;                  byte sign = Utf8Constants.Plus;                    if (offset.Hours < 0)                  {                      hours = -offset.Hours;                      sign = Utf8Constants.Minus;                  }                    Unsafe.Add(ref utf8Bytes' 27) = sign;                  FormattingHelpers.WriteDigits(hours' 2' ref utf8Bytes' 28);                  Unsafe.Add(ref utf8Bytes' 30) = Utf8Constants.Colon;                  int offsetMinutes = Math.Abs(offset.Minutes);                  FormattingHelpers.WriteDigits(offsetMinutes' 2' ref utf8Bytes' 31);              }              else if (kind == DateTimeKind.Utc)              {                  Unsafe.Add(ref utf8Bytes' 27) = UtcMarker;              }
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeO,The following statement contains a magic number: if (kind == DateTimeKind.Local)              {                  int hours = offset.Hours;                  byte sign = Utf8Constants.Plus;                    if (offset.Hours < 0)                  {                      hours = -offset.Hours;                      sign = Utf8Constants.Minus;                  }                    Unsafe.Add(ref utf8Bytes' 27) = sign;                  FormattingHelpers.WriteDigits(hours' 2' ref utf8Bytes' 28);                  Unsafe.Add(ref utf8Bytes' 30) = Utf8Constants.Colon;                  int offsetMinutes = Math.Abs(offset.Minutes);                  FormattingHelpers.WriteDigits(offsetMinutes' 2' ref utf8Bytes' 31);              }              else if (kind == DateTimeKind.Utc)              {                  Unsafe.Add(ref utf8Bytes' 27) = UtcMarker;              }
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeO,The following statement contains a magic number: if (kind == DateTimeKind.Local)              {                  int hours = offset.Hours;                  byte sign = Utf8Constants.Plus;                    if (offset.Hours < 0)                  {                      hours = -offset.Hours;                      sign = Utf8Constants.Minus;                  }                    Unsafe.Add(ref utf8Bytes' 27) = sign;                  FormattingHelpers.WriteDigits(hours' 2' ref utf8Bytes' 28);                  Unsafe.Add(ref utf8Bytes' 30) = Utf8Constants.Colon;                  int offsetMinutes = Math.Abs(offset.Minutes);                  FormattingHelpers.WriteDigits(offsetMinutes' 2' ref utf8Bytes' 31);              }              else if (kind == DateTimeKind.Utc)              {                  Unsafe.Add(ref utf8Bytes' 27) = UtcMarker;              }
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeR,The following statement contains a magic number: bytesWritten = 29;
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeR,The following statement contains a magic number: Unsafe.Add(ref utf8Bytes' 2) = dayAbbrev[2];
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeR,The following statement contains a magic number: Unsafe.Add(ref utf8Bytes' 2) = dayAbbrev[2];
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeR,The following statement contains a magic number: Unsafe.Add(ref utf8Bytes' 3) = Utf8Constants.Comma;
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeR,The following statement contains a magic number: Unsafe.Add(ref utf8Bytes' 4) = Utf8Constants.Space;
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeR,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Day' 2' ref utf8Bytes' 5);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeR,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Day' 2' ref utf8Bytes' 5);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeR,The following statement contains a magic number: Unsafe.Add(ref utf8Bytes' 7) = (byte)' ';
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeR,The following statement contains a magic number: Unsafe.Add(ref utf8Bytes' 8) = monthAbbrev[0];
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeR,The following statement contains a magic number: Unsafe.Add(ref utf8Bytes' 9) = monthAbbrev[1];
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeR,The following statement contains a magic number: Unsafe.Add(ref utf8Bytes' 10) = monthAbbrev[2];
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeR,The following statement contains a magic number: Unsafe.Add(ref utf8Bytes' 10) = monthAbbrev[2];
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeR,The following statement contains a magic number: Unsafe.Add(ref utf8Bytes' 11) = Utf8Constants.Space;
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeR,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Year' 4' ref utf8Bytes' 12);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeR,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Year' 4' ref utf8Bytes' 12);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeR,The following statement contains a magic number: Unsafe.Add(ref utf8Bytes' 16) = Utf8Constants.Space;
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeR,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Hour' 2' ref utf8Bytes' 17);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeR,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Hour' 2' ref utf8Bytes' 17);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeR,The following statement contains a magic number: Unsafe.Add(ref utf8Bytes' 19) = Utf8Constants.Colon;
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeR,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Minute' 2' ref utf8Bytes' 20);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeR,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Minute' 2' ref utf8Bytes' 20);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeR,The following statement contains a magic number: Unsafe.Add(ref utf8Bytes' 22) = Utf8Constants.Colon;
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeR,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Second' 2' ref utf8Bytes' 23);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeR,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Second' 2' ref utf8Bytes' 23);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeR,The following statement contains a magic number: Unsafe.Add(ref utf8Bytes' 25) = Utf8Constants.Space;
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeR,The following statement contains a magic number: Unsafe.Add(ref utf8Bytes' 26) = GMT1;
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeR,The following statement contains a magic number: Unsafe.Add(ref utf8Bytes' 27) = GMT2;
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeR,The following statement contains a magic number: Unsafe.Add(ref utf8Bytes' 28) = GMT3;
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeL,The following statement contains a magic number: bytesWritten = 29;
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeL,The following statement contains a magic number: Unsafe.Add(ref utf8Bytes' 2) = dayAbbrev[2];
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeL,The following statement contains a magic number: Unsafe.Add(ref utf8Bytes' 2) = dayAbbrev[2];
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeL,The following statement contains a magic number: Unsafe.Add(ref utf8Bytes' 3) = Utf8Constants.Comma;
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeL,The following statement contains a magic number: Unsafe.Add(ref utf8Bytes' 4) = Utf8Constants.Space;
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeL,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Day' 2' ref utf8Bytes' 5);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeL,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Day' 2' ref utf8Bytes' 5);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeL,The following statement contains a magic number: Unsafe.Add(ref utf8Bytes' 7) = (byte)' ';
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeL,The following statement contains a magic number: Unsafe.Add(ref utf8Bytes' 8) = monthAbbrev[0];
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeL,The following statement contains a magic number: Unsafe.Add(ref utf8Bytes' 9) = monthAbbrev[1];
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeL,The following statement contains a magic number: Unsafe.Add(ref utf8Bytes' 10) = monthAbbrev[2];
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeL,The following statement contains a magic number: Unsafe.Add(ref utf8Bytes' 10) = monthAbbrev[2];
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeL,The following statement contains a magic number: Unsafe.Add(ref utf8Bytes' 11) = Utf8Constants.Space;
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeL,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Year' 4' ref utf8Bytes' 12);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeL,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Year' 4' ref utf8Bytes' 12);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeL,The following statement contains a magic number: Unsafe.Add(ref utf8Bytes' 16) = Utf8Constants.Space;
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeL,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Hour' 2' ref utf8Bytes' 17);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeL,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Hour' 2' ref utf8Bytes' 17);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeL,The following statement contains a magic number: Unsafe.Add(ref utf8Bytes' 19) = Utf8Constants.Colon;
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeL,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Minute' 2' ref utf8Bytes' 20);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeL,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Minute' 2' ref utf8Bytes' 20);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeL,The following statement contains a magic number: Unsafe.Add(ref utf8Bytes' 22) = Utf8Constants.Colon;
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeL,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Second' 2' ref utf8Bytes' 23);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeL,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Second' 2' ref utf8Bytes' 23);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeL,The following statement contains a magic number: Unsafe.Add(ref utf8Bytes' 25) = Utf8Constants.Space;
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeL,The following statement contains a magic number: Unsafe.Add(ref utf8Bytes' 26) = GMT1Lowercase;
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeL,The following statement contains a magic number: Unsafe.Add(ref utf8Bytes' 27) = GMT2Lowercase;
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDateTimeL,The following statement contains a magic number: Unsafe.Add(ref utf8Bytes' 28) = GMT3Lowercase;
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormat,The following statement contains a magic number: switch (format.Symbol)              {                  case 'g':                  case 'G':                      {                          if (format.Precision != StandardFormat.NoPrecision)                              throw new NotSupportedException(SR.Argument_GWithPrecisionNotSupported);                          NumberBuffer number = default;                          Number.DecimalToNumber(value' ref number);                          if (number.Digits[0] == 0)                          {                              number.IsNegative = false; // For Decimals' -0 must print as normal 0.                          }                          bool success = TryFormatDecimalG(ref number' buffer' out bytesWritten);  #if DEBUG                          // This DEBUG segment exists to close a code coverage hole inside TryFormatDecimalG(). Because we don't call RoundNumber() on this path' we have no way to feed                          // TryFormatDecimalG() a number where trailing zeros before the decimal point have been cropped. So if the chance comes up' we'll crop the zeroes                          // ourselves and make a second call to ensure we get the same outcome.                          if (success)                          {                              Span<byte> digits = number.Digits;                              int numDigits = number.NumDigits;                              if (numDigits != 0 && number.Scale == numDigits && digits[numDigits - 1] == '0')                              {                                  while (numDigits != 0 && digits[numDigits - 1] == '0')                                  {                                      digits[numDigits - 1] = 0;                                      numDigits--;                                  }                                    number.CheckConsistency();                                    byte[] buffer2 = new byte[buffer.Length];                                  bool success2 = TryFormatDecimalG(ref number' buffer2' out int bytesWritten2);                                  Debug.Assert(success2);                                  Debug.Assert(bytesWritten2 == bytesWritten);                                  for (int i = 0; i < bytesWritten; i++)                                  {                                      Debug.Assert(buffer[i] == buffer2[i]);                                  }                              }                            }  #endif // DEBUG                          return success;                      }                    case 'f':                  case 'F':                      {                          NumberBuffer number = default;                          Number.DecimalToNumber(value' ref number);                          byte precision = (format.Precision == StandardFormat.NoPrecision) ? (byte)2 : format.Precision;                          Number.RoundNumber(ref number' number.Scale + precision);                          Debug.Assert(!(number.Digits[0] == 0 && number.IsNegative));   // For Decimals' -0 must print as normal 0. As it happens' Number.RoundNumber already ensures this invariant.                          return TryFormatDecimalF(ref number' buffer' out bytesWritten' precision);                      }                    case 'e':                  case 'E':                      {                          NumberBuffer number = default;                          Number.DecimalToNumber(value' ref number);                          byte precision = (format.Precision == StandardFormat.NoPrecision) ? (byte)6 : format.Precision;                          Number.RoundNumber(ref number' precision + 1);                          Debug.Assert(!(number.Digits[0] == 0 && number.IsNegative));   // For Decimals' -0 must print as normal 0. As it happens' Number.RoundNumber already ensures this invariant.                          return TryFormatDecimalE(ref number' buffer' out bytesWritten' precision' exponentSymbol: (byte)format.Symbol);                      }                    default:                      return ThrowHelper.TryFormatThrowFormatException(out bytesWritten);              }
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormat,The following statement contains a magic number: switch (format.Symbol)              {                  case 'g':                  case 'G':                      {                          if (format.Precision != StandardFormat.NoPrecision)                              throw new NotSupportedException(SR.Argument_GWithPrecisionNotSupported);                          NumberBuffer number = default;                          Number.DecimalToNumber(value' ref number);                          if (number.Digits[0] == 0)                          {                              number.IsNegative = false; // For Decimals' -0 must print as normal 0.                          }                          bool success = TryFormatDecimalG(ref number' buffer' out bytesWritten);  #if DEBUG                          // This DEBUG segment exists to close a code coverage hole inside TryFormatDecimalG(). Because we don't call RoundNumber() on this path' we have no way to feed                          // TryFormatDecimalG() a number where trailing zeros before the decimal point have been cropped. So if the chance comes up' we'll crop the zeroes                          // ourselves and make a second call to ensure we get the same outcome.                          if (success)                          {                              Span<byte> digits = number.Digits;                              int numDigits = number.NumDigits;                              if (numDigits != 0 && number.Scale == numDigits && digits[numDigits - 1] == '0')                              {                                  while (numDigits != 0 && digits[numDigits - 1] == '0')                                  {                                      digits[numDigits - 1] = 0;                                      numDigits--;                                  }                                    number.CheckConsistency();                                    byte[] buffer2 = new byte[buffer.Length];                                  bool success2 = TryFormatDecimalG(ref number' buffer2' out int bytesWritten2);                                  Debug.Assert(success2);                                  Debug.Assert(bytesWritten2 == bytesWritten);                                  for (int i = 0; i < bytesWritten; i++)                                  {                                      Debug.Assert(buffer[i] == buffer2[i]);                                  }                              }                            }  #endif // DEBUG                          return success;                      }                    case 'f':                  case 'F':                      {                          NumberBuffer number = default;                          Number.DecimalToNumber(value' ref number);                          byte precision = (format.Precision == StandardFormat.NoPrecision) ? (byte)2 : format.Precision;                          Number.RoundNumber(ref number' number.Scale + precision);                          Debug.Assert(!(number.Digits[0] == 0 && number.IsNegative));   // For Decimals' -0 must print as normal 0. As it happens' Number.RoundNumber already ensures this invariant.                          return TryFormatDecimalF(ref number' buffer' out bytesWritten' precision);                      }                    case 'e':                  case 'E':                      {                          NumberBuffer number = default;                          Number.DecimalToNumber(value' ref number);                          byte precision = (format.Precision == StandardFormat.NoPrecision) ? (byte)6 : format.Precision;                          Number.RoundNumber(ref number' precision + 1);                          Debug.Assert(!(number.Digits[0] == 0 && number.IsNegative));   // For Decimals' -0 must print as normal 0. As it happens' Number.RoundNumber already ensures this invariant.                          return TryFormatDecimalE(ref number' buffer' out bytesWritten' precision' exponentSymbol: (byte)format.Symbol);                      }                    default:                      return ThrowHelper.TryFormatThrowFormatException(out bytesWritten);              }
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDecimalE,The following statement contains a magic number: const int NumExponentDigits = 3;
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDecimalE,The following statement contains a magic number: int numBytesNeeded =                  ((number.IsNegative) ? 1 : 0) // minus sign                  + 1  // digits before the decimal point (exactly 1)                  + ((precision == 0) ? 0 : (precision + 1)) // period and the digits after the decimal point                  + 2  // 'E' or 'e' followed by '+' or '-'                  + NumExponentDigits;
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDecimalE,The following statement contains a magic number: buffer[dstIndex++] = (byte)((exponent / 10) + '0');
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatDecimalE,The following statement contains a magic number: buffer[dstIndex++] = (byte)((exponent % 10) + '0');
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatFloatingPoint,The following statement contains a magic number: for (int i = 0; i < length; i++)              {                  Debug.Assert(utf16Text[i] < 128' "A culture-invariant ToString() of a floating point expected to produce ASCII characters only.");                  buffer[i] = (byte)(utf16Text[i]);              }
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormat,The following statement contains a magic number: bytesWritten = GuidChars + (dash ? 4 : 0) + (bookEnds ? 2 : 0);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormat,The following statement contains a magic number: bytesWritten = GuidChars + (dash ? 4 : 0) + (bookEnds ? 2 : 0);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[3]' ref utf8Bytes' idx);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[2]' ref utf8Bytes' idx + 2);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[2]' ref utf8Bytes' idx + 2);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[1]' ref utf8Bytes' idx + 4);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[0]' ref utf8Bytes' idx + 6);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormat,The following statement contains a magic number: idx += 8;
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[5]' ref utf8Bytes' idx);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[4]' ref utf8Bytes' idx + 2);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[4]' ref utf8Bytes' idx + 2);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormat,The following statement contains a magic number: idx += 4;
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[7]' ref utf8Bytes' idx);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[6]' ref utf8Bytes' idx + 2);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[6]' ref utf8Bytes' idx + 2);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormat,The following statement contains a magic number: idx += 4;
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[8]' ref utf8Bytes' idx);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[9]' ref utf8Bytes' idx + 2);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[9]' ref utf8Bytes' idx + 2);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormat,The following statement contains a magic number: idx += 4;
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[10]' ref utf8Bytes' idx);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[11]' ref utf8Bytes' idx + 2);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[11]' ref utf8Bytes' idx + 2);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[12]' ref utf8Bytes' idx + 4);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[12]' ref utf8Bytes' idx + 4);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[13]' ref utf8Bytes' idx + 6);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[13]' ref utf8Bytes' idx + 6);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[14]' ref utf8Bytes' idx + 8);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[14]' ref utf8Bytes' idx + 8);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[15]' ref utf8Bytes' idx + 10);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[15]' ref utf8Bytes' idx + 10);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormat,The following statement contains a magic number: idx += 12;
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatInt64D,The following statement contains a magic number: int bytesNeeded = digitCount + (int)((value >> 63) & 1);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatInt64D,The following statement contains a magic number: if (value < 0)              {                  Unsafe.Add(ref utf8Bytes' idx++) = Utf8Constants.Minus;                    // Abs(long.MinValue) == long.MaxValue + 1' so we need to handle this specially.                  if (value == long.MinValue)                  {                      if (precision != StandardFormat.NoPrecision)                      {                          int leadingZeros = (int)precision - 19;                          while (leadingZeros-- > 0)                              Unsafe.Add(ref utf8Bytes' idx++) = (byte)'0';                      }                        Unsafe.Add(ref utf8Bytes' idx++) = (byte)'9';                      FormattingHelpers.WriteDigits(223372036854775808L' 18' ref utf8Bytes' idx);                        bytesWritten = idx + 18;                      return true;                  }                    value = -value;              }
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatInt64D,The following statement contains a magic number: if (value < 0)              {                  Unsafe.Add(ref utf8Bytes' idx++) = Utf8Constants.Minus;                    // Abs(long.MinValue) == long.MaxValue + 1' so we need to handle this specially.                  if (value == long.MinValue)                  {                      if (precision != StandardFormat.NoPrecision)                      {                          int leadingZeros = (int)precision - 19;                          while (leadingZeros-- > 0)                              Unsafe.Add(ref utf8Bytes' idx++) = (byte)'0';                      }                        Unsafe.Add(ref utf8Bytes' idx++) = (byte)'9';                      FormattingHelpers.WriteDigits(223372036854775808L' 18' ref utf8Bytes' idx);                        bytesWritten = idx + 18;                      return true;                  }                    value = -value;              }
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatInt64D,The following statement contains a magic number: if (value < 0)              {                  Unsafe.Add(ref utf8Bytes' idx++) = Utf8Constants.Minus;                    // Abs(long.MinValue) == long.MaxValue + 1' so we need to handle this specially.                  if (value == long.MinValue)                  {                      if (precision != StandardFormat.NoPrecision)                      {                          int leadingZeros = (int)precision - 19;                          while (leadingZeros-- > 0)                              Unsafe.Add(ref utf8Bytes' idx++) = (byte)'0';                      }                        Unsafe.Add(ref utf8Bytes' idx++) = (byte)'9';                      FormattingHelpers.WriteDigits(223372036854775808L' 18' ref utf8Bytes' idx);                        bytesWritten = idx + 18;                      return true;                  }                    value = -value;              }
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatInt64Default,The following statement contains a magic number: if ((ulong)value < 10)              {                  return TryFormatUInt32SingleDigit((uint)value' buffer' out bytesWritten);              }
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatInt64Default,The following statement contains a magic number: if (IntPtr.Size == 8)    // x64              {                  return TryFormatInt64MultipleDigits(value' buffer' out bytesWritten);              }              else    // x86              {                  if (value <= int.MaxValue && value >= int.MinValue)                  {                      return TryFormatInt32MultipleDigits((int)value' buffer' out bytesWritten);                  }                  else                  {                      if (value <= (long)Utf8Constants.BillionMaxUIntValue && value >= -(long)Utf8Constants.BillionMaxUIntValue)                      {                          return value < 0 ?                           TryFormatInt64MoreThanNegativeBillionMaxUInt(-value' buffer' out bytesWritten) :                          TryFormatUInt64LessThanBillionMaxUInt((ulong)value' buffer' out bytesWritten);                       }                      else                      {                          return value < 0 ?                           TryFormatInt64LessThanNegativeBillionMaxUInt(-value' buffer' out bytesWritten) :                          TryFormatUInt64MoreThanBillionMaxUInt((ulong)value' buffer' out bytesWritten);                      }                  }              }
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatInt32Default,The following statement contains a magic number: if ((uint)value < 10)              {                  return TryFormatUInt32SingleDigit((uint)value' buffer' out bytesWritten);              }
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatInt64MoreThanNegativeBillionMaxUInt,The following statement contains a magic number: Debug.Assert(digitCountOverNineDigits >= 1 && digitCountOverNineDigits <= 10);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatInt64MoreThanNegativeBillionMaxUInt,The following statement contains a magic number: int digitCount = digitCountOverNineDigits + 9;
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatInt64MoreThanNegativeBillionMaxUInt,The following statement contains a magic number: FormattingHelpers.WriteDigits(lastNineDigits' buffer.Slice(digitCountOverNineDigits + 1' 9));
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatInt64LessThanNegativeBillionMaxUInt,The following statement contains a magic number: int digitCount = digitCountOverEighteenDigits + 18;
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatInt64LessThanNegativeBillionMaxUInt,The following statement contains a magic number: FormattingHelpers.WriteDigits(middleNineDigits' buffer.Slice(digitCountOverEighteenDigits + 1' 9));
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatInt64LessThanNegativeBillionMaxUInt,The following statement contains a magic number: FormattingHelpers.WriteDigits(lastNineDigits' buffer.Slice(digitCountOverEighteenDigits + 1 + 9' 9));
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatInt64LessThanNegativeBillionMaxUInt,The following statement contains a magic number: FormattingHelpers.WriteDigits(lastNineDigits' buffer.Slice(digitCountOverEighteenDigits + 1 + 9' 9));
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatInt64N,The following statement contains a magic number: if (firstGroup == 0)              {                  firstGroup = 3;                  groupSeparators--;              }
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatInt64N,The following statement contains a magic number: int trailingZeros = (precision == StandardFormat.NoPrecision) ? 2 : precision;
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatInt64N,The following statement contains a magic number: int idx = (int)((value >> 63) & 1) + digitCount + groupSeparators;
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatInt64N,The following statement contains a magic number: while (digitCount > 3)              {                  digitCount -= 3;                  idx -= 3;                  v = FormattingHelpers.DivMod(v' 1000' out long groupValue);                  FormattingHelpers.WriteDigits(groupValue' 3' ref utf8Bytes' idx);                  Unsafe.Add(ref utf8Bytes' --idx) = Utf8Constants.Separator;              }
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatInt64N,The following statement contains a magic number: while (digitCount > 3)              {                  digitCount -= 3;                  idx -= 3;                  v = FormattingHelpers.DivMod(v' 1000' out long groupValue);                  FormattingHelpers.WriteDigits(groupValue' 3' ref utf8Bytes' idx);                  Unsafe.Add(ref utf8Bytes' --idx) = Utf8Constants.Separator;              }
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatInt64N,The following statement contains a magic number: while (digitCount > 3)              {                  digitCount -= 3;                  idx -= 3;                  v = FormattingHelpers.DivMod(v' 1000' out long groupValue);                  FormattingHelpers.WriteDigits(groupValue' 3' ref utf8Bytes' idx);                  Unsafe.Add(ref utf8Bytes' --idx) = Utf8Constants.Separator;              }
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatInt64N,The following statement contains a magic number: while (digitCount > 3)              {                  digitCount -= 3;                  idx -= 3;                  v = FormattingHelpers.DivMod(v' 1000' out long groupValue);                  FormattingHelpers.WriteDigits(groupValue' 3' ref utf8Bytes' idx);                  Unsafe.Add(ref utf8Bytes' --idx) = Utf8Constants.Separator;              }
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatInt64N,The following statement contains a magic number: while (digitCount > 3)              {                  digitCount -= 3;                  idx -= 3;                  v = FormattingHelpers.DivMod(v' 1000' out long groupValue);                  FormattingHelpers.WriteDigits(groupValue' 3' ref utf8Bytes' idx);                  Unsafe.Add(ref utf8Bytes' --idx) = Utf8Constants.Separator;              }
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatUInt64D,The following statement contains a magic number: value = FormattingHelpers.DivMod(value' 10' out ulong lastDigit);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatUInt64Default,The following statement contains a magic number: if (value < 10)              {                  return TryFormatUInt32SingleDigit((uint)value' buffer' out bytesWritten);              }
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatUInt64Default,The following statement contains a magic number: if (IntPtr.Size == 8)    // x64              {                  return TryFormatUInt64MultipleDigits(value' buffer' out bytesWritten);              }              else    // x86              {                  if (value <= uint.MaxValue)                  {                      return TryFormatUInt32MultipleDigits((uint)value' buffer' out bytesWritten);                  }                  else                  {                      if (value <= Utf8Constants.BillionMaxUIntValue)                      {                          return TryFormatUInt64LessThanBillionMaxUInt(value' buffer' out bytesWritten);                      }                      else                      {                          return TryFormatUInt64MoreThanBillionMaxUInt(value' buffer' out bytesWritten);                      }                  }              }
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatUInt32Default,The following statement contains a magic number: if (value < 10)              {                  return TryFormatUInt32SingleDigit(value' buffer' out bytesWritten);              }
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatUInt64LessThanBillionMaxUInt,The following statement contains a magic number: Debug.Assert(digitCountOverNineDigits >= 1 && digitCountOverNineDigits <= 10);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatUInt64LessThanBillionMaxUInt,The following statement contains a magic number: int digitCount = digitCountOverNineDigits + 9;
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatUInt64LessThanBillionMaxUInt,The following statement contains a magic number: FormattingHelpers.WriteDigits(lastNineDigits' buffer.Slice(digitCountOverNineDigits' 9));
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatUInt64MoreThanBillionMaxUInt,The following statement contains a magic number: Debug.Assert(digitCountOverEighteenDigits >= 1 && digitCountOverEighteenDigits <= 2);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatUInt64MoreThanBillionMaxUInt,The following statement contains a magic number: int digitCount = digitCountOverEighteenDigits + 18;
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatUInt64MoreThanBillionMaxUInt,The following statement contains a magic number: FormattingHelpers.WriteDigits(middleNineDigits' buffer.Slice(digitCountOverEighteenDigits' 9));
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatUInt64MoreThanBillionMaxUInt,The following statement contains a magic number: FormattingHelpers.WriteDigits(lastNineDigits' buffer.Slice(digitCountOverEighteenDigits + 9' 9));
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatUInt64MoreThanBillionMaxUInt,The following statement contains a magic number: FormattingHelpers.WriteDigits(lastNineDigits' buffer.Slice(digitCountOverEighteenDigits + 9' 9));
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatUInt64N,The following statement contains a magic number: value = FormattingHelpers.DivMod(value' 1000' out ulong lastGroup);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatUInt64N,The following statement contains a magic number: if (precision == StandardFormat.NoPrecision)                  precision = 2;
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatUInt64N,The following statement contains a magic number: bytesWritten += 4;
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatUInt64N,The following statement contains a magic number: FormattingHelpers.WriteDigits(lastGroup' 3' ref utf8Bytes' idx);
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatUInt64N,The following statement contains a magic number: idx += 3;
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatUInt64X,The following statement contains a magic number: if (v > 0xFFFFFFFF)              {                  digits += 8;                  v >>= 0x20;              }
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatUInt64X,The following statement contains a magic number: if (v > 0xFFFF)              {                  digits += 4;                  v >>= 0x10;              }
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatUInt64X,The following statement contains a magic number: if (v > 0xFF)              {                  digits += 2;                  v >>= 0x8;              }
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormatUInt64X,The following statement contains a magic number: for (v = value; digits-- > 0; v >>= 4)                  Unsafe.Add(ref utf8Bytes' --idx) = (byte)hexTable[(int)(v & 0xF)];
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormat,The following statement contains a magic number: switch (symbol)              {                  case 'G':                  case 'g':                  case 'c':                  case 't':                  case 'T':                      {                          bool longForm = (symbol == 'G');                          bool constant = (symbol == 't' || symbol == 'T' || symbol == 'c');                            long ticks = value.Ticks;                          int days = (int)FormattingHelpers.DivMod(ticks' TimeSpan.TicksPerDay' out long timeLeft);                            bool showSign = false;                          if (ticks < 0)                          {                              showSign = true;                              days = -days;                              timeLeft = -timeLeft;                          }                            int hours = (int)FormattingHelpers.DivMod(timeLeft' TimeSpan.TicksPerHour' out timeLeft);                          int minutes = (int)FormattingHelpers.DivMod(timeLeft' TimeSpan.TicksPerMinute' out timeLeft);                          int seconds = (int)FormattingHelpers.DivMod(timeLeft' TimeSpan.TicksPerSecond' out long fraction);                            int dayDigits = 0;                          int hourDigits = (constant || longForm || hours > 9) ? 2 : 1;                          int fractionDigits = 0;                            bytesWritten = hourDigits + 6; // [h]h:mm:ss                          if (showSign)                              bytesWritten += 1;  // [-]                          if (longForm || days > 0)                          {                              dayDigits = FormattingHelpers.CountDigits(days);                              bytesWritten += dayDigits + 1; // [d'.']                          }                          if (longForm || fraction > 0)                          {                              fractionDigits = (longForm || constant) ? Utf8Constants.DateTimeNumFractionDigits : FormattingHelpers.CountFractionDigits(fraction);                              bytesWritten += fractionDigits + 1; // ['.'fffffff] or ['.'FFFFFFF] for short-form                          }                            if (buffer.Length < bytesWritten)                          {                              bytesWritten = 0;                              return false;                          }                            ref byte utf8Bytes = ref buffer.DangerousGetPinnableReference();                          int idx = 0;                            if (showSign)                              Unsafe.Add(ref utf8Bytes' idx++) = Utf8Constants.Minus;                            if (dayDigits > 0)                          {                              FormattingHelpers.WriteDigits(days' dayDigits' ref utf8Bytes' idx);                              idx += dayDigits;                              Unsafe.Add(ref utf8Bytes' idx++) = constant ? Utf8Constants.Period : Utf8Constants.Colon;                          }                            FormattingHelpers.WriteDigits(hours' hourDigits' ref utf8Bytes' idx);                          idx += hourDigits;                          Unsafe.Add(ref utf8Bytes' idx++) = Utf8Constants.Colon;                            FormattingHelpers.WriteDigits(minutes' 2' ref utf8Bytes' idx);                          idx += 2;                          Unsafe.Add(ref utf8Bytes' idx++) = Utf8Constants.Colon;                            FormattingHelpers.WriteDigits(seconds' 2' ref utf8Bytes' idx);                          idx += 2;                            if (fractionDigits > 0)                          {                              Unsafe.Add(ref utf8Bytes' idx++) = Utf8Constants.Period;                              FormattingHelpers.WriteFractionDigits(fraction' fractionDigits' ref utf8Bytes' idx);                              idx += fractionDigits;                          }                            return true;                      }                    default:                      return ThrowHelper.TryFormatThrowFormatException(out bytesWritten);              }
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormat,The following statement contains a magic number: switch (symbol)              {                  case 'G':                  case 'g':                  case 'c':                  case 't':                  case 'T':                      {                          bool longForm = (symbol == 'G');                          bool constant = (symbol == 't' || symbol == 'T' || symbol == 'c');                            long ticks = value.Ticks;                          int days = (int)FormattingHelpers.DivMod(ticks' TimeSpan.TicksPerDay' out long timeLeft);                            bool showSign = false;                          if (ticks < 0)                          {                              showSign = true;                              days = -days;                              timeLeft = -timeLeft;                          }                            int hours = (int)FormattingHelpers.DivMod(timeLeft' TimeSpan.TicksPerHour' out timeLeft);                          int minutes = (int)FormattingHelpers.DivMod(timeLeft' TimeSpan.TicksPerMinute' out timeLeft);                          int seconds = (int)FormattingHelpers.DivMod(timeLeft' TimeSpan.TicksPerSecond' out long fraction);                            int dayDigits = 0;                          int hourDigits = (constant || longForm || hours > 9) ? 2 : 1;                          int fractionDigits = 0;                            bytesWritten = hourDigits + 6; // [h]h:mm:ss                          if (showSign)                              bytesWritten += 1;  // [-]                          if (longForm || days > 0)                          {                              dayDigits = FormattingHelpers.CountDigits(days);                              bytesWritten += dayDigits + 1; // [d'.']                          }                          if (longForm || fraction > 0)                          {                              fractionDigits = (longForm || constant) ? Utf8Constants.DateTimeNumFractionDigits : FormattingHelpers.CountFractionDigits(fraction);                              bytesWritten += fractionDigits + 1; // ['.'fffffff] or ['.'FFFFFFF] for short-form                          }                            if (buffer.Length < bytesWritten)                          {                              bytesWritten = 0;                              return false;                          }                            ref byte utf8Bytes = ref buffer.DangerousGetPinnableReference();                          int idx = 0;                            if (showSign)                              Unsafe.Add(ref utf8Bytes' idx++) = Utf8Constants.Minus;                            if (dayDigits > 0)                          {                              FormattingHelpers.WriteDigits(days' dayDigits' ref utf8Bytes' idx);                              idx += dayDigits;                              Unsafe.Add(ref utf8Bytes' idx++) = constant ? Utf8Constants.Period : Utf8Constants.Colon;                          }                            FormattingHelpers.WriteDigits(hours' hourDigits' ref utf8Bytes' idx);                          idx += hourDigits;                          Unsafe.Add(ref utf8Bytes' idx++) = Utf8Constants.Colon;                            FormattingHelpers.WriteDigits(minutes' 2' ref utf8Bytes' idx);                          idx += 2;                          Unsafe.Add(ref utf8Bytes' idx++) = Utf8Constants.Colon;                            FormattingHelpers.WriteDigits(seconds' 2' ref utf8Bytes' idx);                          idx += 2;                            if (fractionDigits > 0)                          {                              Unsafe.Add(ref utf8Bytes' idx++) = Utf8Constants.Period;                              FormattingHelpers.WriteFractionDigits(fraction' fractionDigits' ref utf8Bytes' idx);                              idx += fractionDigits;                          }                            return true;                      }                    default:                      return ThrowHelper.TryFormatThrowFormatException(out bytesWritten);              }
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormat,The following statement contains a magic number: switch (symbol)              {                  case 'G':                  case 'g':                  case 'c':                  case 't':                  case 'T':                      {                          bool longForm = (symbol == 'G');                          bool constant = (symbol == 't' || symbol == 'T' || symbol == 'c');                            long ticks = value.Ticks;                          int days = (int)FormattingHelpers.DivMod(ticks' TimeSpan.TicksPerDay' out long timeLeft);                            bool showSign = false;                          if (ticks < 0)                          {                              showSign = true;                              days = -days;                              timeLeft = -timeLeft;                          }                            int hours = (int)FormattingHelpers.DivMod(timeLeft' TimeSpan.TicksPerHour' out timeLeft);                          int minutes = (int)FormattingHelpers.DivMod(timeLeft' TimeSpan.TicksPerMinute' out timeLeft);                          int seconds = (int)FormattingHelpers.DivMod(timeLeft' TimeSpan.TicksPerSecond' out long fraction);                            int dayDigits = 0;                          int hourDigits = (constant || longForm || hours > 9) ? 2 : 1;                          int fractionDigits = 0;                            bytesWritten = hourDigits + 6; // [h]h:mm:ss                          if (showSign)                              bytesWritten += 1;  // [-]                          if (longForm || days > 0)                          {                              dayDigits = FormattingHelpers.CountDigits(days);                              bytesWritten += dayDigits + 1; // [d'.']                          }                          if (longForm || fraction > 0)                          {                              fractionDigits = (longForm || constant) ? Utf8Constants.DateTimeNumFractionDigits : FormattingHelpers.CountFractionDigits(fraction);                              bytesWritten += fractionDigits + 1; // ['.'fffffff] or ['.'FFFFFFF] for short-form                          }                            if (buffer.Length < bytesWritten)                          {                              bytesWritten = 0;                              return false;                          }                            ref byte utf8Bytes = ref buffer.DangerousGetPinnableReference();                          int idx = 0;                            if (showSign)                              Unsafe.Add(ref utf8Bytes' idx++) = Utf8Constants.Minus;                            if (dayDigits > 0)                          {                              FormattingHelpers.WriteDigits(days' dayDigits' ref utf8Bytes' idx);                              idx += dayDigits;                              Unsafe.Add(ref utf8Bytes' idx++) = constant ? Utf8Constants.Period : Utf8Constants.Colon;                          }                            FormattingHelpers.WriteDigits(hours' hourDigits' ref utf8Bytes' idx);                          idx += hourDigits;                          Unsafe.Add(ref utf8Bytes' idx++) = Utf8Constants.Colon;                            FormattingHelpers.WriteDigits(minutes' 2' ref utf8Bytes' idx);                          idx += 2;                          Unsafe.Add(ref utf8Bytes' idx++) = Utf8Constants.Colon;                            FormattingHelpers.WriteDigits(seconds' 2' ref utf8Bytes' idx);                          idx += 2;                            if (fractionDigits > 0)                          {                              Unsafe.Add(ref utf8Bytes' idx++) = Utf8Constants.Period;                              FormattingHelpers.WriteFractionDigits(fraction' fractionDigits' ref utf8Bytes' idx);                              idx += fractionDigits;                          }                            return true;                      }                    default:                      return ThrowHelper.TryFormatThrowFormatException(out bytesWritten);              }
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormat,The following statement contains a magic number: switch (symbol)              {                  case 'G':                  case 'g':                  case 'c':                  case 't':                  case 'T':                      {                          bool longForm = (symbol == 'G');                          bool constant = (symbol == 't' || symbol == 'T' || symbol == 'c');                            long ticks = value.Ticks;                          int days = (int)FormattingHelpers.DivMod(ticks' TimeSpan.TicksPerDay' out long timeLeft);                            bool showSign = false;                          if (ticks < 0)                          {                              showSign = true;                              days = -days;                              timeLeft = -timeLeft;                          }                            int hours = (int)FormattingHelpers.DivMod(timeLeft' TimeSpan.TicksPerHour' out timeLeft);                          int minutes = (int)FormattingHelpers.DivMod(timeLeft' TimeSpan.TicksPerMinute' out timeLeft);                          int seconds = (int)FormattingHelpers.DivMod(timeLeft' TimeSpan.TicksPerSecond' out long fraction);                            int dayDigits = 0;                          int hourDigits = (constant || longForm || hours > 9) ? 2 : 1;                          int fractionDigits = 0;                            bytesWritten = hourDigits + 6; // [h]h:mm:ss                          if (showSign)                              bytesWritten += 1;  // [-]                          if (longForm || days > 0)                          {                              dayDigits = FormattingHelpers.CountDigits(days);                              bytesWritten += dayDigits + 1; // [d'.']                          }                          if (longForm || fraction > 0)                          {                              fractionDigits = (longForm || constant) ? Utf8Constants.DateTimeNumFractionDigits : FormattingHelpers.CountFractionDigits(fraction);                              bytesWritten += fractionDigits + 1; // ['.'fffffff] or ['.'FFFFFFF] for short-form                          }                            if (buffer.Length < bytesWritten)                          {                              bytesWritten = 0;                              return false;                          }                            ref byte utf8Bytes = ref buffer.DangerousGetPinnableReference();                          int idx = 0;                            if (showSign)                              Unsafe.Add(ref utf8Bytes' idx++) = Utf8Constants.Minus;                            if (dayDigits > 0)                          {                              FormattingHelpers.WriteDigits(days' dayDigits' ref utf8Bytes' idx);                              idx += dayDigits;                              Unsafe.Add(ref utf8Bytes' idx++) = constant ? Utf8Constants.Period : Utf8Constants.Colon;                          }                            FormattingHelpers.WriteDigits(hours' hourDigits' ref utf8Bytes' idx);                          idx += hourDigits;                          Unsafe.Add(ref utf8Bytes' idx++) = Utf8Constants.Colon;                            FormattingHelpers.WriteDigits(minutes' 2' ref utf8Bytes' idx);                          idx += 2;                          Unsafe.Add(ref utf8Bytes' idx++) = Utf8Constants.Colon;                            FormattingHelpers.WriteDigits(seconds' 2' ref utf8Bytes' idx);                          idx += 2;                            if (fractionDigits > 0)                          {                              Unsafe.Add(ref utf8Bytes' idx++) = Utf8Constants.Period;                              FormattingHelpers.WriteFractionDigits(fraction' fractionDigits' ref utf8Bytes' idx);                              idx += fractionDigits;                          }                            return true;                      }                    default:                      return ThrowHelper.TryFormatThrowFormatException(out bytesWritten);              }
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormat,The following statement contains a magic number: switch (symbol)              {                  case 'G':                  case 'g':                  case 'c':                  case 't':                  case 'T':                      {                          bool longForm = (symbol == 'G');                          bool constant = (symbol == 't' || symbol == 'T' || symbol == 'c');                            long ticks = value.Ticks;                          int days = (int)FormattingHelpers.DivMod(ticks' TimeSpan.TicksPerDay' out long timeLeft);                            bool showSign = false;                          if (ticks < 0)                          {                              showSign = true;                              days = -days;                              timeLeft = -timeLeft;                          }                            int hours = (int)FormattingHelpers.DivMod(timeLeft' TimeSpan.TicksPerHour' out timeLeft);                          int minutes = (int)FormattingHelpers.DivMod(timeLeft' TimeSpan.TicksPerMinute' out timeLeft);                          int seconds = (int)FormattingHelpers.DivMod(timeLeft' TimeSpan.TicksPerSecond' out long fraction);                            int dayDigits = 0;                          int hourDigits = (constant || longForm || hours > 9) ? 2 : 1;                          int fractionDigits = 0;                            bytesWritten = hourDigits + 6; // [h]h:mm:ss                          if (showSign)                              bytesWritten += 1;  // [-]                          if (longForm || days > 0)                          {                              dayDigits = FormattingHelpers.CountDigits(days);                              bytesWritten += dayDigits + 1; // [d'.']                          }                          if (longForm || fraction > 0)                          {                              fractionDigits = (longForm || constant) ? Utf8Constants.DateTimeNumFractionDigits : FormattingHelpers.CountFractionDigits(fraction);                              bytesWritten += fractionDigits + 1; // ['.'fffffff] or ['.'FFFFFFF] for short-form                          }                            if (buffer.Length < bytesWritten)                          {                              bytesWritten = 0;                              return false;                          }                            ref byte utf8Bytes = ref buffer.DangerousGetPinnableReference();                          int idx = 0;                            if (showSign)                              Unsafe.Add(ref utf8Bytes' idx++) = Utf8Constants.Minus;                            if (dayDigits > 0)                          {                              FormattingHelpers.WriteDigits(days' dayDigits' ref utf8Bytes' idx);                              idx += dayDigits;                              Unsafe.Add(ref utf8Bytes' idx++) = constant ? Utf8Constants.Period : Utf8Constants.Colon;                          }                            FormattingHelpers.WriteDigits(hours' hourDigits' ref utf8Bytes' idx);                          idx += hourDigits;                          Unsafe.Add(ref utf8Bytes' idx++) = Utf8Constants.Colon;                            FormattingHelpers.WriteDigits(minutes' 2' ref utf8Bytes' idx);                          idx += 2;                          Unsafe.Add(ref utf8Bytes' idx++) = Utf8Constants.Colon;                            FormattingHelpers.WriteDigits(seconds' 2' ref utf8Bytes' idx);                          idx += 2;                            if (fractionDigits > 0)                          {                              Unsafe.Add(ref utf8Bytes' idx++) = Utf8Constants.Period;                              FormattingHelpers.WriteFractionDigits(fraction' fractionDigits' ref utf8Bytes' idx);                              idx += fractionDigits;                          }                            return true;                      }                    default:                      return ThrowHelper.TryFormatThrowFormatException(out bytesWritten);              }
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormat,The following statement contains a magic number: switch (symbol)              {                  case 'G':                  case 'g':                  case 'c':                  case 't':                  case 'T':                      {                          bool longForm = (symbol == 'G');                          bool constant = (symbol == 't' || symbol == 'T' || symbol == 'c');                            long ticks = value.Ticks;                          int days = (int)FormattingHelpers.DivMod(ticks' TimeSpan.TicksPerDay' out long timeLeft);                            bool showSign = false;                          if (ticks < 0)                          {                              showSign = true;                              days = -days;                              timeLeft = -timeLeft;                          }                            int hours = (int)FormattingHelpers.DivMod(timeLeft' TimeSpan.TicksPerHour' out timeLeft);                          int minutes = (int)FormattingHelpers.DivMod(timeLeft' TimeSpan.TicksPerMinute' out timeLeft);                          int seconds = (int)FormattingHelpers.DivMod(timeLeft' TimeSpan.TicksPerSecond' out long fraction);                            int dayDigits = 0;                          int hourDigits = (constant || longForm || hours > 9) ? 2 : 1;                          int fractionDigits = 0;                            bytesWritten = hourDigits + 6; // [h]h:mm:ss                          if (showSign)                              bytesWritten += 1;  // [-]                          if (longForm || days > 0)                          {                              dayDigits = FormattingHelpers.CountDigits(days);                              bytesWritten += dayDigits + 1; // [d'.']                          }                          if (longForm || fraction > 0)                          {                              fractionDigits = (longForm || constant) ? Utf8Constants.DateTimeNumFractionDigits : FormattingHelpers.CountFractionDigits(fraction);                              bytesWritten += fractionDigits + 1; // ['.'fffffff] or ['.'FFFFFFF] for short-form                          }                            if (buffer.Length < bytesWritten)                          {                              bytesWritten = 0;                              return false;                          }                            ref byte utf8Bytes = ref buffer.DangerousGetPinnableReference();                          int idx = 0;                            if (showSign)                              Unsafe.Add(ref utf8Bytes' idx++) = Utf8Constants.Minus;                            if (dayDigits > 0)                          {                              FormattingHelpers.WriteDigits(days' dayDigits' ref utf8Bytes' idx);                              idx += dayDigits;                              Unsafe.Add(ref utf8Bytes' idx++) = constant ? Utf8Constants.Period : Utf8Constants.Colon;                          }                            FormattingHelpers.WriteDigits(hours' hourDigits' ref utf8Bytes' idx);                          idx += hourDigits;                          Unsafe.Add(ref utf8Bytes' idx++) = Utf8Constants.Colon;                            FormattingHelpers.WriteDigits(minutes' 2' ref utf8Bytes' idx);                          idx += 2;                          Unsafe.Add(ref utf8Bytes' idx++) = Utf8Constants.Colon;                            FormattingHelpers.WriteDigits(seconds' 2' ref utf8Bytes' idx);                          idx += 2;                            if (fractionDigits > 0)                          {                              Unsafe.Add(ref utf8Bytes' idx++) = Utf8Constants.Period;                              FormattingHelpers.WriteFractionDigits(fraction' fractionDigits' ref utf8Bytes' idx);                              idx += fractionDigits;                          }                            return true;                      }                    default:                      return ThrowHelper.TryFormatThrowFormatException(out bytesWritten);              }
Magic Number,System.Buffers.Text,Utf8Formatter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Formatter\Utf8Formatter.Boolean.cs,TryFormat,The following statement contains a magic number: switch (symbol)              {                  case 'G':                  case 'g':                  case 'c':                  case 't':                  case 'T':                      {                          bool longForm = (symbol == 'G');                          bool constant = (symbol == 't' || symbol == 'T' || symbol == 'c');                            long ticks = value.Ticks;                          int days = (int)FormattingHelpers.DivMod(ticks' TimeSpan.TicksPerDay' out long timeLeft);                            bool showSign = false;                          if (ticks < 0)                          {                              showSign = true;                              days = -days;                              timeLeft = -timeLeft;                          }                            int hours = (int)FormattingHelpers.DivMod(timeLeft' TimeSpan.TicksPerHour' out timeLeft);                          int minutes = (int)FormattingHelpers.DivMod(timeLeft' TimeSpan.TicksPerMinute' out timeLeft);                          int seconds = (int)FormattingHelpers.DivMod(timeLeft' TimeSpan.TicksPerSecond' out long fraction);                            int dayDigits = 0;                          int hourDigits = (constant || longForm || hours > 9) ? 2 : 1;                          int fractionDigits = 0;                            bytesWritten = hourDigits + 6; // [h]h:mm:ss                          if (showSign)                              bytesWritten += 1;  // [-]                          if (longForm || days > 0)                          {                              dayDigits = FormattingHelpers.CountDigits(days);                              bytesWritten += dayDigits + 1; // [d'.']                          }                          if (longForm || fraction > 0)                          {                              fractionDigits = (longForm || constant) ? Utf8Constants.DateTimeNumFractionDigits : FormattingHelpers.CountFractionDigits(fraction);                              bytesWritten += fractionDigits + 1; // ['.'fffffff] or ['.'FFFFFFF] for short-form                          }                            if (buffer.Length < bytesWritten)                          {                              bytesWritten = 0;                              return false;                          }                            ref byte utf8Bytes = ref buffer.DangerousGetPinnableReference();                          int idx = 0;                            if (showSign)                              Unsafe.Add(ref utf8Bytes' idx++) = Utf8Constants.Minus;                            if (dayDigits > 0)                          {                              FormattingHelpers.WriteDigits(days' dayDigits' ref utf8Bytes' idx);                              idx += dayDigits;                              Unsafe.Add(ref utf8Bytes' idx++) = constant ? Utf8Constants.Period : Utf8Constants.Colon;                          }                            FormattingHelpers.WriteDigits(hours' hourDigits' ref utf8Bytes' idx);                          idx += hourDigits;                          Unsafe.Add(ref utf8Bytes' idx++) = Utf8Constants.Colon;                            FormattingHelpers.WriteDigits(minutes' 2' ref utf8Bytes' idx);                          idx += 2;                          Unsafe.Add(ref utf8Bytes' idx++) = Utf8Constants.Colon;                            FormattingHelpers.WriteDigits(seconds' 2' ref utf8Bytes' idx);                          idx += 2;                            if (fractionDigits > 0)                          {                              Unsafe.Add(ref utf8Bytes' idx++) = Utf8Constants.Period;                              FormattingHelpers.WriteFractionDigits(fraction' fractionDigits' ref utf8Bytes' idx);                              idx += fractionDigits;                          }                            return true;                      }                    default:                      return ThrowHelper.TryFormatThrowFormatException(out bytesWritten);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParse,The following statement contains a magic number: if (text.Length >= 4)              {                  if ((text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e'))                  {                      bytesConsumed = 4;                      value = true;                      return true;                  }                  if (text.Length >= 5)                  {                      if ((text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e'))                      {                          bytesConsumed = 5;                          value = false;                          return true;                      }                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParse,The following statement contains a magic number: if (text.Length >= 4)              {                  if ((text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e'))                  {                      bytesConsumed = 4;                      value = true;                      return true;                  }                  if (text.Length >= 5)                  {                      if ((text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e'))                      {                          bytesConsumed = 5;                          value = false;                          return true;                      }                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParse,The following statement contains a magic number: if (text.Length >= 4)              {                  if ((text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e'))                  {                      bytesConsumed = 4;                      value = true;                      return true;                  }                  if (text.Length >= 5)                  {                      if ((text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e'))                      {                          bytesConsumed = 5;                          value = false;                          return true;                      }                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParse,The following statement contains a magic number: if (text.Length >= 4)              {                  if ((text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e'))                  {                      bytesConsumed = 4;                      value = true;                      return true;                  }                  if (text.Length >= 5)                  {                      if ((text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e'))                      {                          bytesConsumed = 5;                          value = false;                          return true;                      }                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParse,The following statement contains a magic number: if (text.Length >= 4)              {                  if ((text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e'))                  {                      bytesConsumed = 4;                      value = true;                      return true;                  }                  if (text.Length >= 5)                  {                      if ((text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e'))                      {                          bytesConsumed = 5;                          value = false;                          return true;                      }                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParse,The following statement contains a magic number: if (text.Length >= 4)              {                  if ((text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e'))                  {                      bytesConsumed = 4;                      value = true;                      return true;                  }                  if (text.Length >= 5)                  {                      if ((text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e'))                      {                          bytesConsumed = 5;                          value = false;                          return true;                      }                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParse,The following statement contains a magic number: if (text.Length >= 4)              {                  if ((text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e'))                  {                      bytesConsumed = 4;                      value = true;                      return true;                  }                  if (text.Length >= 5)                  {                      if ((text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e'))                      {                          bytesConsumed = 5;                          value = false;                          return true;                      }                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParse,The following statement contains a magic number: if (text.Length >= 4)              {                  if ((text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e'))                  {                      bytesConsumed = 4;                      value = true;                      return true;                  }                  if (text.Length >= 5)                  {                      if ((text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e'))                      {                          bytesConsumed = 5;                          value = false;                          return true;                      }                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParse,The following statement contains a magic number: if (text.Length >= 4)              {                  if ((text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e'))                  {                      bytesConsumed = 4;                      value = true;                      return true;                  }                  if (text.Length >= 5)                  {                      if ((text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e'))                      {                          bytesConsumed = 5;                          value = false;                          return true;                      }                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParse,The following statement contains a magic number: if (text.Length >= 4)              {                  if ((text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e'))                  {                      bytesConsumed = 4;                      value = true;                      return true;                  }                  if (text.Length >= 5)                  {                      if ((text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e'))                      {                          bytesConsumed = 5;                          value = false;                          return true;                      }                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParse,The following statement contains a magic number: if (text.Length >= 4)              {                  if ((text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e'))                  {                      bytesConsumed = 4;                      value = true;                      return true;                  }                  if (text.Length >= 5)                  {                      if ((text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e'))                      {                          bytesConsumed = 5;                          value = false;                          return true;                      }                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParse,The following statement contains a magic number: if (text.Length >= 4)              {                  if ((text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e'))                  {                      bytesConsumed = 4;                      value = true;                      return true;                  }                  if (text.Length >= 5)                  {                      if ((text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e'))                      {                          bytesConsumed = 5;                          value = false;                          return true;                      }                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParse,The following statement contains a magic number: if (text.Length >= 4)              {                  if ((text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e'))                  {                      bytesConsumed = 4;                      value = true;                      return true;                  }                  if (text.Length >= 5)                  {                      if ((text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e'))                      {                          bytesConsumed = 5;                          value = false;                          return true;                      }                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParse,The following statement contains a magic number: if (text.Length >= 4)              {                  if ((text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e'))                  {                      bytesConsumed = 4;                      value = true;                      return true;                  }                  if (text.Length >= 5)                  {                      if ((text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e'))                      {                          bytesConsumed = 5;                          value = false;                          return true;                      }                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetDefault,The following statement contains a magic number: if (text.Length < 26)              {                  bytesConsumed = 0;                  value = default;                  return false;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetDefault,The following statement contains a magic number: if (text[19] != Utf8Constants.Space)              {                  bytesConsumed = 0;                  value = default;                  return false;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetDefault,The following statement contains a magic number: byte sign = text[20];
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetDefault,The following statement contains a magic number: {                  uint digit1 = text[21] - 48u; // '0'                  uint digit2 = text[22] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      bytesConsumed = 0;                      value = default;                      return false;                  }                    offsetHours = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetDefault,The following statement contains a magic number: {                  uint digit1 = text[21] - 48u; // '0'                  uint digit2 = text[22] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      bytesConsumed = 0;                      value = default;                      return false;                  }                    offsetHours = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetDefault,The following statement contains a magic number: {                  uint digit1 = text[21] - 48u; // '0'                  uint digit2 = text[22] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      bytesConsumed = 0;                      value = default;                      return false;                  }                    offsetHours = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetDefault,The following statement contains a magic number: {                  uint digit1 = text[21] - 48u; // '0'                  uint digit2 = text[22] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      bytesConsumed = 0;                      value = default;                      return false;                  }                    offsetHours = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetDefault,The following statement contains a magic number: {                  uint digit1 = text[21] - 48u; // '0'                  uint digit2 = text[22] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      bytesConsumed = 0;                      value = default;                      return false;                  }                    offsetHours = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetDefault,The following statement contains a magic number: if (text[23] != Utf8Constants.Colon)              {                  bytesConsumed = 0;                  value = default;                  return false;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetDefault,The following statement contains a magic number: {                  uint digit1 = text[24] - 48u; // '0'                  uint digit2 = text[25] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      bytesConsumed = 0;                      value = default;                      return false;                  }                    offsetMinutes = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetDefault,The following statement contains a magic number: {                  uint digit1 = text[24] - 48u; // '0'                  uint digit2 = text[25] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      bytesConsumed = 0;                      value = default;                      return false;                  }                    offsetMinutes = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetDefault,The following statement contains a magic number: {                  uint digit1 = text[24] - 48u; // '0'                  uint digit2 = text[25] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      bytesConsumed = 0;                      value = default;                      return false;                  }                    offsetMinutes = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetDefault,The following statement contains a magic number: {                  uint digit1 = text[24] - 48u; // '0'                  uint digit2 = text[25] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      bytesConsumed = 0;                      value = default;                      return false;                  }                    offsetMinutes = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetDefault,The following statement contains a magic number: {                  uint digit1 = text[24] - 48u; // '0'                  uint digit2 = text[25] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      bytesConsumed = 0;                      value = default;                      return false;                  }                    offsetMinutes = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetDefault,The following statement contains a magic number: bytesConsumed = 26;
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeG,The following statement contains a magic number: if (text.Length < 19)              {                  bytesConsumed = 0;                  value = default;                  valueAsOffset = default;                  return false;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeG,The following statement contains a magic number: {                  uint digit1 = text[0] - 48u; // '0'                  uint digit2 = text[1] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      bytesConsumed = 0;                      value = default;                      valueAsOffset = default;                      return false;                  }                    month = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeG,The following statement contains a magic number: {                  uint digit1 = text[0] - 48u; // '0'                  uint digit2 = text[1] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      bytesConsumed = 0;                      value = default;                      valueAsOffset = default;                      return false;                  }                    month = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeG,The following statement contains a magic number: {                  uint digit1 = text[0] - 48u; // '0'                  uint digit2 = text[1] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      bytesConsumed = 0;                      value = default;                      valueAsOffset = default;                      return false;                  }                    month = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeG,The following statement contains a magic number: if (text[2] != Utf8Constants.Slash)              {                  bytesConsumed = 0;                  value = default;                  valueAsOffset = default;                  return false;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeG,The following statement contains a magic number: {                  uint digit1 = text[3] - 48u; // '0'                  uint digit2 = text[4] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      bytesConsumed = 0;                      value = default;                      valueAsOffset = default;                      return false;                  }                    day = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeG,The following statement contains a magic number: {                  uint digit1 = text[3] - 48u; // '0'                  uint digit2 = text[4] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      bytesConsumed = 0;                      value = default;                      valueAsOffset = default;                      return false;                  }                    day = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeG,The following statement contains a magic number: {                  uint digit1 = text[3] - 48u; // '0'                  uint digit2 = text[4] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      bytesConsumed = 0;                      value = default;                      valueAsOffset = default;                      return false;                  }                    day = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeG,The following statement contains a magic number: {                  uint digit1 = text[3] - 48u; // '0'                  uint digit2 = text[4] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      bytesConsumed = 0;                      value = default;                      valueAsOffset = default;                      return false;                  }                    day = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeG,The following statement contains a magic number: {                  uint digit1 = text[3] - 48u; // '0'                  uint digit2 = text[4] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      bytesConsumed = 0;                      value = default;                      valueAsOffset = default;                      return false;                  }                    day = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeG,The following statement contains a magic number: if (text[5] != Utf8Constants.Slash)              {                  bytesConsumed = 0;                  value = default;                  valueAsOffset = default;                  return false;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeG,The following statement contains a magic number: {                  uint digit1 = text[6] - 48u; // '0'                  uint digit2 = text[7] - 48u; // '0'                  uint digit3 = text[8] - 48u; // '0'                  uint digit4 = text[9] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9 || digit3 > 9 || digit4 > 9)                  {                      bytesConsumed = 0;                      value = default;                      valueAsOffset = default;                      return false;                  }                    year = (int)(digit1 * 1000 + digit2 * 100 + digit3 * 10 + digit4);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeG,The following statement contains a magic number: {                  uint digit1 = text[6] - 48u; // '0'                  uint digit2 = text[7] - 48u; // '0'                  uint digit3 = text[8] - 48u; // '0'                  uint digit4 = text[9] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9 || digit3 > 9 || digit4 > 9)                  {                      bytesConsumed = 0;                      value = default;                      valueAsOffset = default;                      return false;                  }                    year = (int)(digit1 * 1000 + digit2 * 100 + digit3 * 10 + digit4);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeG,The following statement contains a magic number: {                  uint digit1 = text[6] - 48u; // '0'                  uint digit2 = text[7] - 48u; // '0'                  uint digit3 = text[8] - 48u; // '0'                  uint digit4 = text[9] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9 || digit3 > 9 || digit4 > 9)                  {                      bytesConsumed = 0;                      value = default;                      valueAsOffset = default;                      return false;                  }                    year = (int)(digit1 * 1000 + digit2 * 100 + digit3 * 10 + digit4);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeG,The following statement contains a magic number: {                  uint digit1 = text[6] - 48u; // '0'                  uint digit2 = text[7] - 48u; // '0'                  uint digit3 = text[8] - 48u; // '0'                  uint digit4 = text[9] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9 || digit3 > 9 || digit4 > 9)                  {                      bytesConsumed = 0;                      value = default;                      valueAsOffset = default;                      return false;                  }                    year = (int)(digit1 * 1000 + digit2 * 100 + digit3 * 10 + digit4);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeG,The following statement contains a magic number: {                  uint digit1 = text[6] - 48u; // '0'                  uint digit2 = text[7] - 48u; // '0'                  uint digit3 = text[8] - 48u; // '0'                  uint digit4 = text[9] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9 || digit3 > 9 || digit4 > 9)                  {                      bytesConsumed = 0;                      value = default;                      valueAsOffset = default;                      return false;                  }                    year = (int)(digit1 * 1000 + digit2 * 100 + digit3 * 10 + digit4);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeG,The following statement contains a magic number: {                  uint digit1 = text[6] - 48u; // '0'                  uint digit2 = text[7] - 48u; // '0'                  uint digit3 = text[8] - 48u; // '0'                  uint digit4 = text[9] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9 || digit3 > 9 || digit4 > 9)                  {                      bytesConsumed = 0;                      value = default;                      valueAsOffset = default;                      return false;                  }                    year = (int)(digit1 * 1000 + digit2 * 100 + digit3 * 10 + digit4);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeG,The following statement contains a magic number: {                  uint digit1 = text[6] - 48u; // '0'                  uint digit2 = text[7] - 48u; // '0'                  uint digit3 = text[8] - 48u; // '0'                  uint digit4 = text[9] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9 || digit3 > 9 || digit4 > 9)                  {                      bytesConsumed = 0;                      value = default;                      valueAsOffset = default;                      return false;                  }                    year = (int)(digit1 * 1000 + digit2 * 100 + digit3 * 10 + digit4);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeG,The following statement contains a magic number: {                  uint digit1 = text[6] - 48u; // '0'                  uint digit2 = text[7] - 48u; // '0'                  uint digit3 = text[8] - 48u; // '0'                  uint digit4 = text[9] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9 || digit3 > 9 || digit4 > 9)                  {                      bytesConsumed = 0;                      value = default;                      valueAsOffset = default;                      return false;                  }                    year = (int)(digit1 * 1000 + digit2 * 100 + digit3 * 10 + digit4);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeG,The following statement contains a magic number: {                  uint digit1 = text[6] - 48u; // '0'                  uint digit2 = text[7] - 48u; // '0'                  uint digit3 = text[8] - 48u; // '0'                  uint digit4 = text[9] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9 || digit3 > 9 || digit4 > 9)                  {                      bytesConsumed = 0;                      value = default;                      valueAsOffset = default;                      return false;                  }                    year = (int)(digit1 * 1000 + digit2 * 100 + digit3 * 10 + digit4);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeG,The following statement contains a magic number: {                  uint digit1 = text[6] - 48u; // '0'                  uint digit2 = text[7] - 48u; // '0'                  uint digit3 = text[8] - 48u; // '0'                  uint digit4 = text[9] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9 || digit3 > 9 || digit4 > 9)                  {                      bytesConsumed = 0;                      value = default;                      valueAsOffset = default;                      return false;                  }                    year = (int)(digit1 * 1000 + digit2 * 100 + digit3 * 10 + digit4);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeG,The following statement contains a magic number: {                  uint digit1 = text[6] - 48u; // '0'                  uint digit2 = text[7] - 48u; // '0'                  uint digit3 = text[8] - 48u; // '0'                  uint digit4 = text[9] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9 || digit3 > 9 || digit4 > 9)                  {                      bytesConsumed = 0;                      value = default;                      valueAsOffset = default;                      return false;                  }                    year = (int)(digit1 * 1000 + digit2 * 100 + digit3 * 10 + digit4);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeG,The following statement contains a magic number: if (text[10] != Utf8Constants.Space)              {                  bytesConsumed = 0;                  value = default;                  valueAsOffset = default;                  return false;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeG,The following statement contains a magic number: {                  uint digit1 = text[11] - 48u; // '0'                  uint digit2 = text[12] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      bytesConsumed = 0;                      value = default;                      valueAsOffset = default;                      return false;                  }                    hour = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeG,The following statement contains a magic number: {                  uint digit1 = text[11] - 48u; // '0'                  uint digit2 = text[12] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      bytesConsumed = 0;                      value = default;                      valueAsOffset = default;                      return false;                  }                    hour = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeG,The following statement contains a magic number: {                  uint digit1 = text[11] - 48u; // '0'                  uint digit2 = text[12] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      bytesConsumed = 0;                      value = default;                      valueAsOffset = default;                      return false;                  }                    hour = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeG,The following statement contains a magic number: {                  uint digit1 = text[11] - 48u; // '0'                  uint digit2 = text[12] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      bytesConsumed = 0;                      value = default;                      valueAsOffset = default;                      return false;                  }                    hour = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeG,The following statement contains a magic number: {                  uint digit1 = text[11] - 48u; // '0'                  uint digit2 = text[12] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      bytesConsumed = 0;                      value = default;                      valueAsOffset = default;                      return false;                  }                    hour = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeG,The following statement contains a magic number: if (text[13] != Utf8Constants.Colon)              {                  bytesConsumed = 0;                  value = default;                  valueAsOffset = default;                  return false;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeG,The following statement contains a magic number: {                  uint digit1 = text[14] - 48u; // '0'                  uint digit2 = text[15] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      bytesConsumed = 0;                      value = default;                      valueAsOffset = default;                      return false;                  }                    minute = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeG,The following statement contains a magic number: {                  uint digit1 = text[14] - 48u; // '0'                  uint digit2 = text[15] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      bytesConsumed = 0;                      value = default;                      valueAsOffset = default;                      return false;                  }                    minute = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeG,The following statement contains a magic number: {                  uint digit1 = text[14] - 48u; // '0'                  uint digit2 = text[15] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      bytesConsumed = 0;                      value = default;                      valueAsOffset = default;                      return false;                  }                    minute = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeG,The following statement contains a magic number: {                  uint digit1 = text[14] - 48u; // '0'                  uint digit2 = text[15] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      bytesConsumed = 0;                      value = default;                      valueAsOffset = default;                      return false;                  }                    minute = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeG,The following statement contains a magic number: {                  uint digit1 = text[14] - 48u; // '0'                  uint digit2 = text[15] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      bytesConsumed = 0;                      value = default;                      valueAsOffset = default;                      return false;                  }                    minute = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeG,The following statement contains a magic number: if (text[16] != Utf8Constants.Colon)              {                  bytesConsumed = 0;                  value = default;                  valueAsOffset = default;                  return false;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeG,The following statement contains a magic number: {                  uint digit1 = text[17] - 48u; // '0'                  uint digit2 = text[18] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      bytesConsumed = 0;                      value = default;                      valueAsOffset = default;                      return false;                  }                    second = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeG,The following statement contains a magic number: {                  uint digit1 = text[17] - 48u; // '0'                  uint digit2 = text[18] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      bytesConsumed = 0;                      value = default;                      valueAsOffset = default;                      return false;                  }                    second = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeG,The following statement contains a magic number: {                  uint digit1 = text[17] - 48u; // '0'                  uint digit2 = text[18] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      bytesConsumed = 0;                      value = default;                      valueAsOffset = default;                      return false;                  }                    second = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeG,The following statement contains a magic number: {                  uint digit1 = text[17] - 48u; // '0'                  uint digit2 = text[18] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      bytesConsumed = 0;                      value = default;                      valueAsOffset = default;                      return false;                  }                    second = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeG,The following statement contains a magic number: {                  uint digit1 = text[17] - 48u; // '0'                  uint digit2 = text[18] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      bytesConsumed = 0;                      value = default;                      valueAsOffset = default;                      return false;                  }                    second = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeG,The following statement contains a magic number: bytesConsumed = 19;
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryCreateDateTimeOffset,The following statement contains a magic number: if (((uint)offsetMinutes) > 59)              {                  value = default;                  return false;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryCreateDateTimeOffset,The following statement contains a magic number: long offsetTicks = (((long)offsetHours) * 3600 + ((long)offsetMinutes) * 60) * TimeSpan.TicksPerSecond;
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryCreateDateTimeOffset,The following statement contains a magic number: long offsetTicks = (((long)offsetHours) * 3600 + ((long)offsetMinutes) * 60) * TimeSpan.TicksPerSecond;
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryCreateDateTime,The following statement contains a magic number: Debug.Assert(year <= 9999);
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryCreateDateTime,The following statement contains a magic number: if ((((uint)month) - 1) >= 12)              {                  value = default;                  return false;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryCreateDateTime,The following statement contains a magic number: if (dayMinusOne >= 28 && dayMinusOne >= DateTime.DaysInMonth(year' month))              {                  value = default;                  return false;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryCreateDateTime,The following statement contains a magic number: if (((uint)hour) > 23)              {                  value = default;                  return false;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryCreateDateTime,The following statement contains a magic number: if (((uint)minute) > 59)              {                  value = default;                  return false;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryCreateDateTime,The following statement contains a magic number: if (((uint)second) > 59)              {                  value = default;                  return false;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryCreateDateTime,The following statement contains a magic number: int totalDays = (yearMinusOne * 365) + (yearMinusOne / 4) - (yearMinusOne / 100) + (yearMinusOne / 400) + days[month - 1] + day - 1;
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryCreateDateTime,The following statement contains a magic number: int totalDays = (yearMinusOne * 365) + (yearMinusOne / 4) - (yearMinusOne / 100) + (yearMinusOne / 400) + days[month - 1] + day - 1;
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryCreateDateTime,The following statement contains a magic number: int totalDays = (yearMinusOne * 365) + (yearMinusOne / 4) - (yearMinusOne / 100) + (yearMinusOne / 400) + days[month - 1] + day - 1;
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryCreateDateTime,The following statement contains a magic number: int totalDays = (yearMinusOne * 365) + (yearMinusOne / 4) - (yearMinusOne / 100) + (yearMinusOne / 400) + days[month - 1] + day - 1;
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryCreateDateTime,The following statement contains a magic number: int totalSeconds = (hour * 3600) + (minute * 60) + second;
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryCreateDateTime,The following statement contains a magic number: int totalSeconds = (hour * 3600) + (minute * 60) + second;
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: if (text.Length < 27)              {                  value = default;                  bytesConsumed = 0;                  kind = default;                  return false;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: {                  uint digit1 = text[0] - 48u; // '0'                  uint digit2 = text[1] - 48u; // '0'                  uint digit3 = text[2] - 48u; // '0'                  uint digit4 = text[3] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9 || digit3 > 9 || digit4 > 9)                  {                      value = default;                      bytesConsumed = 0;                      kind = default;                      return false;                  }                    year = (int)(digit1 * 1000 + digit2 * 100 + digit3 * 10 + digit4);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: {                  uint digit1 = text[0] - 48u; // '0'                  uint digit2 = text[1] - 48u; // '0'                  uint digit3 = text[2] - 48u; // '0'                  uint digit4 = text[3] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9 || digit3 > 9 || digit4 > 9)                  {                      value = default;                      bytesConsumed = 0;                      kind = default;                      return false;                  }                    year = (int)(digit1 * 1000 + digit2 * 100 + digit3 * 10 + digit4);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: {                  uint digit1 = text[0] - 48u; // '0'                  uint digit2 = text[1] - 48u; // '0'                  uint digit3 = text[2] - 48u; // '0'                  uint digit4 = text[3] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9 || digit3 > 9 || digit4 > 9)                  {                      value = default;                      bytesConsumed = 0;                      kind = default;                      return false;                  }                    year = (int)(digit1 * 1000 + digit2 * 100 + digit3 * 10 + digit4);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: {                  uint digit1 = text[0] - 48u; // '0'                  uint digit2 = text[1] - 48u; // '0'                  uint digit3 = text[2] - 48u; // '0'                  uint digit4 = text[3] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9 || digit3 > 9 || digit4 > 9)                  {                      value = default;                      bytesConsumed = 0;                      kind = default;                      return false;                  }                    year = (int)(digit1 * 1000 + digit2 * 100 + digit3 * 10 + digit4);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: {                  uint digit1 = text[0] - 48u; // '0'                  uint digit2 = text[1] - 48u; // '0'                  uint digit3 = text[2] - 48u; // '0'                  uint digit4 = text[3] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9 || digit3 > 9 || digit4 > 9)                  {                      value = default;                      bytesConsumed = 0;                      kind = default;                      return false;                  }                    year = (int)(digit1 * 1000 + digit2 * 100 + digit3 * 10 + digit4);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: {                  uint digit1 = text[0] - 48u; // '0'                  uint digit2 = text[1] - 48u; // '0'                  uint digit3 = text[2] - 48u; // '0'                  uint digit4 = text[3] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9 || digit3 > 9 || digit4 > 9)                  {                      value = default;                      bytesConsumed = 0;                      kind = default;                      return false;                  }                    year = (int)(digit1 * 1000 + digit2 * 100 + digit3 * 10 + digit4);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: {                  uint digit1 = text[0] - 48u; // '0'                  uint digit2 = text[1] - 48u; // '0'                  uint digit3 = text[2] - 48u; // '0'                  uint digit4 = text[3] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9 || digit3 > 9 || digit4 > 9)                  {                      value = default;                      bytesConsumed = 0;                      kind = default;                      return false;                  }                    year = (int)(digit1 * 1000 + digit2 * 100 + digit3 * 10 + digit4);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: {                  uint digit1 = text[0] - 48u; // '0'                  uint digit2 = text[1] - 48u; // '0'                  uint digit3 = text[2] - 48u; // '0'                  uint digit4 = text[3] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9 || digit3 > 9 || digit4 > 9)                  {                      value = default;                      bytesConsumed = 0;                      kind = default;                      return false;                  }                    year = (int)(digit1 * 1000 + digit2 * 100 + digit3 * 10 + digit4);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: {                  uint digit1 = text[0] - 48u; // '0'                  uint digit2 = text[1] - 48u; // '0'                  uint digit3 = text[2] - 48u; // '0'                  uint digit4 = text[3] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9 || digit3 > 9 || digit4 > 9)                  {                      value = default;                      bytesConsumed = 0;                      kind = default;                      return false;                  }                    year = (int)(digit1 * 1000 + digit2 * 100 + digit3 * 10 + digit4);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: if (text[4] != Utf8Constants.Hyphen)              {                  value = default;                  bytesConsumed = 0;                  kind = default;                  return false;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: {                  uint digit1 = text[5] - 48u; // '0'                  uint digit2 = text[6] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      value = default;                      bytesConsumed = 0;                      kind = default;                      return false;                  }                    month = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: {                  uint digit1 = text[5] - 48u; // '0'                  uint digit2 = text[6] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      value = default;                      bytesConsumed = 0;                      kind = default;                      return false;                  }                    month = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: {                  uint digit1 = text[5] - 48u; // '0'                  uint digit2 = text[6] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      value = default;                      bytesConsumed = 0;                      kind = default;                      return false;                  }                    month = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: {                  uint digit1 = text[5] - 48u; // '0'                  uint digit2 = text[6] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      value = default;                      bytesConsumed = 0;                      kind = default;                      return false;                  }                    month = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: {                  uint digit1 = text[5] - 48u; // '0'                  uint digit2 = text[6] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      value = default;                      bytesConsumed = 0;                      kind = default;                      return false;                  }                    month = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: if (text[7] != Utf8Constants.Hyphen)              {                  value = default;                  bytesConsumed = 0;                  kind = default;                  return false;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: {                  uint digit1 = text[8] - 48u; // '0'                  uint digit2 = text[9] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      value = default;                      bytesConsumed = 0;                      kind = default;                      return false;                  }                    day = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: {                  uint digit1 = text[8] - 48u; // '0'                  uint digit2 = text[9] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      value = default;                      bytesConsumed = 0;                      kind = default;                      return false;                  }                    day = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: {                  uint digit1 = text[8] - 48u; // '0'                  uint digit2 = text[9] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      value = default;                      bytesConsumed = 0;                      kind = default;                      return false;                  }                    day = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: {                  uint digit1 = text[8] - 48u; // '0'                  uint digit2 = text[9] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      value = default;                      bytesConsumed = 0;                      kind = default;                      return false;                  }                    day = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: {                  uint digit1 = text[8] - 48u; // '0'                  uint digit2 = text[9] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      value = default;                      bytesConsumed = 0;                      kind = default;                      return false;                  }                    day = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: if (text[10] != 'T')              {                  value = default;                  bytesConsumed = 0;                  kind = default;                  return false;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: {                  uint digit1 = text[11] - 48u; // '0'                  uint digit2 = text[12] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      value = default;                      bytesConsumed = 0;                      kind = default;                      return false;                  }                    hour = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: {                  uint digit1 = text[11] - 48u; // '0'                  uint digit2 = text[12] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      value = default;                      bytesConsumed = 0;                      kind = default;                      return false;                  }                    hour = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: {                  uint digit1 = text[11] - 48u; // '0'                  uint digit2 = text[12] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      value = default;                      bytesConsumed = 0;                      kind = default;                      return false;                  }                    hour = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: {                  uint digit1 = text[11] - 48u; // '0'                  uint digit2 = text[12] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      value = default;                      bytesConsumed = 0;                      kind = default;                      return false;                  }                    hour = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: {                  uint digit1 = text[11] - 48u; // '0'                  uint digit2 = text[12] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      value = default;                      bytesConsumed = 0;                      kind = default;                      return false;                  }                    hour = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: if (text[13] != Utf8Constants.Colon)              {                  value = default;                  bytesConsumed = 0;                  kind = default;                  return false;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: {                  uint digit1 = text[14] - 48u; // '0'                  uint digit2 = text[15] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      value = default;                      bytesConsumed = 0;                      kind = default;                      return false;                  }                    minute = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: {                  uint digit1 = text[14] - 48u; // '0'                  uint digit2 = text[15] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      value = default;                      bytesConsumed = 0;                      kind = default;                      return false;                  }                    minute = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: {                  uint digit1 = text[14] - 48u; // '0'                  uint digit2 = text[15] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      value = default;                      bytesConsumed = 0;                      kind = default;                      return false;                  }                    minute = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: {                  uint digit1 = text[14] - 48u; // '0'                  uint digit2 = text[15] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      value = default;                      bytesConsumed = 0;                      kind = default;                      return false;                  }                    minute = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: {                  uint digit1 = text[14] - 48u; // '0'                  uint digit2 = text[15] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      value = default;                      bytesConsumed = 0;                      kind = default;                      return false;                  }                    minute = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: if (text[16] != Utf8Constants.Colon)              {                  value = default;                  bytesConsumed = 0;                  kind = default;                  return false;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: {                  uint digit1 = text[17] - 48u; // '0'                  uint digit2 = text[18] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      value = default;                      bytesConsumed = 0;                      kind = default;                      return false;                  }                    second = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: {                  uint digit1 = text[17] - 48u; // '0'                  uint digit2 = text[18] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      value = default;                      bytesConsumed = 0;                      kind = default;                      return false;                  }                    second = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: {                  uint digit1 = text[17] - 48u; // '0'                  uint digit2 = text[18] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      value = default;                      bytesConsumed = 0;                      kind = default;                      return false;                  }                    second = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: {                  uint digit1 = text[17] - 48u; // '0'                  uint digit2 = text[18] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      value = default;                      bytesConsumed = 0;                      kind = default;                      return false;                  }                    second = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: {                  uint digit1 = text[17] - 48u; // '0'                  uint digit2 = text[18] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      value = default;                      bytesConsumed = 0;                      kind = default;                      return false;                  }                    second = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: if (text[19] != Utf8Constants.Period)              {                  value = default;                  bytesConsumed = 0;                  kind = default;                  return false;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: {                  uint digit1 = text[20] - 48u; // '0'                  uint digit2 = text[21] - 48u; // '0'                  uint digit3 = text[22] - 48u; // '0'                  uint digit4 = text[23] - 48u; // '0'                  uint digit5 = text[24] - 48u; // '0'                  uint digit6 = text[25] - 48u; // '0'                  uint digit7 = text[26] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9 || digit3 > 9 || digit4 > 9 || digit5 > 9 || digit6 > 9 || digit7 > 9)                  {                      value = default;                      bytesConsumed = 0;                      kind = default;                      return false;                  }                    fraction = (int)(digit1 * 1000000 + digit2 * 100000 + digit3 * 10000 + digit4 * 1000 + digit5 * 100 + digit6 * 10 + digit7);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: {                  uint digit1 = text[20] - 48u; // '0'                  uint digit2 = text[21] - 48u; // '0'                  uint digit3 = text[22] - 48u; // '0'                  uint digit4 = text[23] - 48u; // '0'                  uint digit5 = text[24] - 48u; // '0'                  uint digit6 = text[25] - 48u; // '0'                  uint digit7 = text[26] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9 || digit3 > 9 || digit4 > 9 || digit5 > 9 || digit6 > 9 || digit7 > 9)                  {                      value = default;                      bytesConsumed = 0;                      kind = default;                      return false;                  }                    fraction = (int)(digit1 * 1000000 + digit2 * 100000 + digit3 * 10000 + digit4 * 1000 + digit5 * 100 + digit6 * 10 + digit7);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: {                  uint digit1 = text[20] - 48u; // '0'                  uint digit2 = text[21] - 48u; // '0'                  uint digit3 = text[22] - 48u; // '0'                  uint digit4 = text[23] - 48u; // '0'                  uint digit5 = text[24] - 48u; // '0'                  uint digit6 = text[25] - 48u; // '0'                  uint digit7 = text[26] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9 || digit3 > 9 || digit4 > 9 || digit5 > 9 || digit6 > 9 || digit7 > 9)                  {                      value = default;                      bytesConsumed = 0;                      kind = default;                      return false;                  }                    fraction = (int)(digit1 * 1000000 + digit2 * 100000 + digit3 * 10000 + digit4 * 1000 + digit5 * 100 + digit6 * 10 + digit7);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: {                  uint digit1 = text[20] - 48u; // '0'                  uint digit2 = text[21] - 48u; // '0'                  uint digit3 = text[22] - 48u; // '0'                  uint digit4 = text[23] - 48u; // '0'                  uint digit5 = text[24] - 48u; // '0'                  uint digit6 = text[25] - 48u; // '0'                  uint digit7 = text[26] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9 || digit3 > 9 || digit4 > 9 || digit5 > 9 || digit6 > 9 || digit7 > 9)                  {                      value = default;                      bytesConsumed = 0;                      kind = default;                      return false;                  }                    fraction = (int)(digit1 * 1000000 + digit2 * 100000 + digit3 * 10000 + digit4 * 1000 + digit5 * 100 + digit6 * 10 + digit7);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: {                  uint digit1 = text[20] - 48u; // '0'                  uint digit2 = text[21] - 48u; // '0'                  uint digit3 = text[22] - 48u; // '0'                  uint digit4 = text[23] - 48u; // '0'                  uint digit5 = text[24] - 48u; // '0'                  uint digit6 = text[25] - 48u; // '0'                  uint digit7 = text[26] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9 || digit3 > 9 || digit4 > 9 || digit5 > 9 || digit6 > 9 || digit7 > 9)                  {                      value = default;                      bytesConsumed = 0;                      kind = default;                      return false;                  }                    fraction = (int)(digit1 * 1000000 + digit2 * 100000 + digit3 * 10000 + digit4 * 1000 + digit5 * 100 + digit6 * 10 + digit7);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: {                  uint digit1 = text[20] - 48u; // '0'                  uint digit2 = text[21] - 48u; // '0'                  uint digit3 = text[22] - 48u; // '0'                  uint digit4 = text[23] - 48u; // '0'                  uint digit5 = text[24] - 48u; // '0'                  uint digit6 = text[25] - 48u; // '0'                  uint digit7 = text[26] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9 || digit3 > 9 || digit4 > 9 || digit5 > 9 || digit6 > 9 || digit7 > 9)                  {                      value = default;                      bytesConsumed = 0;                      kind = default;                      return false;                  }                    fraction = (int)(digit1 * 1000000 + digit2 * 100000 + digit3 * 10000 + digit4 * 1000 + digit5 * 100 + digit6 * 10 + digit7);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: {                  uint digit1 = text[20] - 48u; // '0'                  uint digit2 = text[21] - 48u; // '0'                  uint digit3 = text[22] - 48u; // '0'                  uint digit4 = text[23] - 48u; // '0'                  uint digit5 = text[24] - 48u; // '0'                  uint digit6 = text[25] - 48u; // '0'                  uint digit7 = text[26] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9 || digit3 > 9 || digit4 > 9 || digit5 > 9 || digit6 > 9 || digit7 > 9)                  {                      value = default;                      bytesConsumed = 0;                      kind = default;                      return false;                  }                    fraction = (int)(digit1 * 1000000 + digit2 * 100000 + digit3 * 10000 + digit4 * 1000 + digit5 * 100 + digit6 * 10 + digit7);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: {                  uint digit1 = text[20] - 48u; // '0'                  uint digit2 = text[21] - 48u; // '0'                  uint digit3 = text[22] - 48u; // '0'                  uint digit4 = text[23] - 48u; // '0'                  uint digit5 = text[24] - 48u; // '0'                  uint digit6 = text[25] - 48u; // '0'                  uint digit7 = text[26] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9 || digit3 > 9 || digit4 > 9 || digit5 > 9 || digit6 > 9 || digit7 > 9)                  {                      value = default;                      bytesConsumed = 0;                      kind = default;                      return false;                  }                    fraction = (int)(digit1 * 1000000 + digit2 * 100000 + digit3 * 10000 + digit4 * 1000 + digit5 * 100 + digit6 * 10 + digit7);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: {                  uint digit1 = text[20] - 48u; // '0'                  uint digit2 = text[21] - 48u; // '0'                  uint digit3 = text[22] - 48u; // '0'                  uint digit4 = text[23] - 48u; // '0'                  uint digit5 = text[24] - 48u; // '0'                  uint digit6 = text[25] - 48u; // '0'                  uint digit7 = text[26] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9 || digit3 > 9 || digit4 > 9 || digit5 > 9 || digit6 > 9 || digit7 > 9)                  {                      value = default;                      bytesConsumed = 0;                      kind = default;                      return false;                  }                    fraction = (int)(digit1 * 1000000 + digit2 * 100000 + digit3 * 10000 + digit4 * 1000 + digit5 * 100 + digit6 * 10 + digit7);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: {                  uint digit1 = text[20] - 48u; // '0'                  uint digit2 = text[21] - 48u; // '0'                  uint digit3 = text[22] - 48u; // '0'                  uint digit4 = text[23] - 48u; // '0'                  uint digit5 = text[24] - 48u; // '0'                  uint digit6 = text[25] - 48u; // '0'                  uint digit7 = text[26] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9 || digit3 > 9 || digit4 > 9 || digit5 > 9 || digit6 > 9 || digit7 > 9)                  {                      value = default;                      bytesConsumed = 0;                      kind = default;                      return false;                  }                    fraction = (int)(digit1 * 1000000 + digit2 * 100000 + digit3 * 10000 + digit4 * 1000 + digit5 * 100 + digit6 * 10 + digit7);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: {                  uint digit1 = text[20] - 48u; // '0'                  uint digit2 = text[21] - 48u; // '0'                  uint digit3 = text[22] - 48u; // '0'                  uint digit4 = text[23] - 48u; // '0'                  uint digit5 = text[24] - 48u; // '0'                  uint digit6 = text[25] - 48u; // '0'                  uint digit7 = text[26] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9 || digit3 > 9 || digit4 > 9 || digit5 > 9 || digit6 > 9 || digit7 > 9)                  {                      value = default;                      bytesConsumed = 0;                      kind = default;                      return false;                  }                    fraction = (int)(digit1 * 1000000 + digit2 * 100000 + digit3 * 10000 + digit4 * 1000 + digit5 * 100 + digit6 * 10 + digit7);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: {                  uint digit1 = text[20] - 48u; // '0'                  uint digit2 = text[21] - 48u; // '0'                  uint digit3 = text[22] - 48u; // '0'                  uint digit4 = text[23] - 48u; // '0'                  uint digit5 = text[24] - 48u; // '0'                  uint digit6 = text[25] - 48u; // '0'                  uint digit7 = text[26] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9 || digit3 > 9 || digit4 > 9 || digit5 > 9 || digit6 > 9 || digit7 > 9)                  {                      value = default;                      bytesConsumed = 0;                      kind = default;                      return false;                  }                    fraction = (int)(digit1 * 1000000 + digit2 * 100000 + digit3 * 10000 + digit4 * 1000 + digit5 * 100 + digit6 * 10 + digit7);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: {                  uint digit1 = text[20] - 48u; // '0'                  uint digit2 = text[21] - 48u; // '0'                  uint digit3 = text[22] - 48u; // '0'                  uint digit4 = text[23] - 48u; // '0'                  uint digit5 = text[24] - 48u; // '0'                  uint digit6 = text[25] - 48u; // '0'                  uint digit7 = text[26] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9 || digit3 > 9 || digit4 > 9 || digit5 > 9 || digit6 > 9 || digit7 > 9)                  {                      value = default;                      bytesConsumed = 0;                      kind = default;                      return false;                  }                    fraction = (int)(digit1 * 1000000 + digit2 * 100000 + digit3 * 10000 + digit4 * 1000 + digit5 * 100 + digit6 * 10 + digit7);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: {                  uint digit1 = text[20] - 48u; // '0'                  uint digit2 = text[21] - 48u; // '0'                  uint digit3 = text[22] - 48u; // '0'                  uint digit4 = text[23] - 48u; // '0'                  uint digit5 = text[24] - 48u; // '0'                  uint digit6 = text[25] - 48u; // '0'                  uint digit7 = text[26] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9 || digit3 > 9 || digit4 > 9 || digit5 > 9 || digit6 > 9 || digit7 > 9)                  {                      value = default;                      bytesConsumed = 0;                      kind = default;                      return false;                  }                    fraction = (int)(digit1 * 1000000 + digit2 * 100000 + digit3 * 10000 + digit4 * 1000 + digit5 * 100 + digit6 * 10 + digit7);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: {                  uint digit1 = text[20] - 48u; // '0'                  uint digit2 = text[21] - 48u; // '0'                  uint digit3 = text[22] - 48u; // '0'                  uint digit4 = text[23] - 48u; // '0'                  uint digit5 = text[24] - 48u; // '0'                  uint digit6 = text[25] - 48u; // '0'                  uint digit7 = text[26] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9 || digit3 > 9 || digit4 > 9 || digit5 > 9 || digit6 > 9 || digit7 > 9)                  {                      value = default;                      bytesConsumed = 0;                      kind = default;                      return false;                  }                    fraction = (int)(digit1 * 1000000 + digit2 * 100000 + digit3 * 10000 + digit4 * 1000 + digit5 * 100 + digit6 * 10 + digit7);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: {                  uint digit1 = text[20] - 48u; // '0'                  uint digit2 = text[21] - 48u; // '0'                  uint digit3 = text[22] - 48u; // '0'                  uint digit4 = text[23] - 48u; // '0'                  uint digit5 = text[24] - 48u; // '0'                  uint digit6 = text[25] - 48u; // '0'                  uint digit7 = text[26] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9 || digit3 > 9 || digit4 > 9 || digit5 > 9 || digit6 > 9 || digit7 > 9)                  {                      value = default;                      bytesConsumed = 0;                      kind = default;                      return false;                  }                    fraction = (int)(digit1 * 1000000 + digit2 * 100000 + digit3 * 10000 + digit4 * 1000 + digit5 * 100 + digit6 * 10 + digit7);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: {                  uint digit1 = text[20] - 48u; // '0'                  uint digit2 = text[21] - 48u; // '0'                  uint digit3 = text[22] - 48u; // '0'                  uint digit4 = text[23] - 48u; // '0'                  uint digit5 = text[24] - 48u; // '0'                  uint digit6 = text[25] - 48u; // '0'                  uint digit7 = text[26] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9 || digit3 > 9 || digit4 > 9 || digit5 > 9 || digit6 > 9 || digit7 > 9)                  {                      value = default;                      bytesConsumed = 0;                      kind = default;                      return false;                  }                    fraction = (int)(digit1 * 1000000 + digit2 * 100000 + digit3 * 10000 + digit4 * 1000 + digit5 * 100 + digit6 * 10 + digit7);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: {                  uint digit1 = text[20] - 48u; // '0'                  uint digit2 = text[21] - 48u; // '0'                  uint digit3 = text[22] - 48u; // '0'                  uint digit4 = text[23] - 48u; // '0'                  uint digit5 = text[24] - 48u; // '0'                  uint digit6 = text[25] - 48u; // '0'                  uint digit7 = text[26] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9 || digit3 > 9 || digit4 > 9 || digit5 > 9 || digit6 > 9 || digit7 > 9)                  {                      value = default;                      bytesConsumed = 0;                      kind = default;                      return false;                  }                    fraction = (int)(digit1 * 1000000 + digit2 * 100000 + digit3 * 10000 + digit4 * 1000 + digit5 * 100 + digit6 * 10 + digit7);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: {                  uint digit1 = text[20] - 48u; // '0'                  uint digit2 = text[21] - 48u; // '0'                  uint digit3 = text[22] - 48u; // '0'                  uint digit4 = text[23] - 48u; // '0'                  uint digit5 = text[24] - 48u; // '0'                  uint digit6 = text[25] - 48u; // '0'                  uint digit7 = text[26] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9 || digit3 > 9 || digit4 > 9 || digit5 > 9 || digit6 > 9 || digit7 > 9)                  {                      value = default;                      bytesConsumed = 0;                      kind = default;                      return false;                  }                    fraction = (int)(digit1 * 1000000 + digit2 * 100000 + digit3 * 10000 + digit4 * 1000 + digit5 * 100 + digit6 * 10 + digit7);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: {                  uint digit1 = text[20] - 48u; // '0'                  uint digit2 = text[21] - 48u; // '0'                  uint digit3 = text[22] - 48u; // '0'                  uint digit4 = text[23] - 48u; // '0'                  uint digit5 = text[24] - 48u; // '0'                  uint digit6 = text[25] - 48u; // '0'                  uint digit7 = text[26] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9 || digit3 > 9 || digit4 > 9 || digit5 > 9 || digit6 > 9 || digit7 > 9)                  {                      value = default;                      bytesConsumed = 0;                      kind = default;                      return false;                  }                    fraction = (int)(digit1 * 1000000 + digit2 * 100000 + digit3 * 10000 + digit4 * 1000 + digit5 * 100 + digit6 * 10 + digit7);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: byte offsetChar = (text.Length <= 27) ? default : text[27];
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: byte offsetChar = (text.Length <= 27) ? default : text[27];
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: if (offsetChar != 'Z' && offsetChar != Utf8Constants.Plus && offsetChar != Utf8Constants.Minus)              {                  if (!TryCreateDateTimeOffsetInterpretingDataAsLocalTime(year: year' month: month' day: day' hour: hour' minute: minute' second: second' fraction: fraction' out value))                  {                      value = default;                      bytesConsumed = 0;                      kind = default;                      return false;                  }                  bytesConsumed = 27;                  kind = DateTimeKind.Unspecified;                  return true;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: if (offsetChar == 'Z')              {                  // Same as specifying an offset of "+00:00"' except that DateTime's Kind gets set to UTC rather than Local                  if (!TryCreateDateTimeOffset(year: year' month: month' day: day' hour: hour' minute: minute' second: second' fraction: fraction' offsetNegative: false' offsetHours: 0' offsetMinutes: 0' out value))                  {                      value = default;                      bytesConsumed = 0;                      kind = default;                      return false;                  }                    bytesConsumed = 28;                  kind = DateTimeKind.Utc;                  return true;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: if (text.Length < 33)              {                  value = default;                  bytesConsumed = 0;                  kind = default;                  return false;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: {                  uint digit1 = text[28] - 48u; // '0'                  uint digit2 = text[29] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      value = default;                      bytesConsumed = 0;                      kind = default;                      return false;                  }                    offsetHours = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: {                  uint digit1 = text[28] - 48u; // '0'                  uint digit2 = text[29] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      value = default;                      bytesConsumed = 0;                      kind = default;                      return false;                  }                    offsetHours = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: {                  uint digit1 = text[28] - 48u; // '0'                  uint digit2 = text[29] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      value = default;                      bytesConsumed = 0;                      kind = default;                      return false;                  }                    offsetHours = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: {                  uint digit1 = text[28] - 48u; // '0'                  uint digit2 = text[29] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      value = default;                      bytesConsumed = 0;                      kind = default;                      return false;                  }                    offsetHours = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: {                  uint digit1 = text[28] - 48u; // '0'                  uint digit2 = text[29] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      value = default;                      bytesConsumed = 0;                      kind = default;                      return false;                  }                    offsetHours = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: if (text[30] != Utf8Constants.Colon)              {                  value = default;                  bytesConsumed = 0;                  kind = default;                  return false;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: {                  uint digit1 = text[31] - 48u; // '0'                  uint digit2 = text[32] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      value = default;                      bytesConsumed = 0;                      kind = default;                      return false;                  }                    offsetMinutes = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: {                  uint digit1 = text[31] - 48u; // '0'                  uint digit2 = text[32] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      value = default;                      bytesConsumed = 0;                      kind = default;                      return false;                  }                    offsetMinutes = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: {                  uint digit1 = text[31] - 48u; // '0'                  uint digit2 = text[32] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      value = default;                      bytesConsumed = 0;                      kind = default;                      return false;                  }                    offsetMinutes = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: {                  uint digit1 = text[31] - 48u; // '0'                  uint digit2 = text[32] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      value = default;                      bytesConsumed = 0;                      kind = default;                      return false;                  }                    offsetMinutes = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: {                  uint digit1 = text[31] - 48u; // '0'                  uint digit2 = text[32] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      value = default;                      bytesConsumed = 0;                      kind = default;                      return false;                  }                    offsetMinutes = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetO,The following statement contains a magic number: bytesConsumed = 33;
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetR,The following statement contains a magic number: if (text.Length < 29)              {                  bytesConsumed = 0;                  dateTimeOffset = default;                  return false;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetR,The following statement contains a magic number: {                  uint dow0 = text[0] ^ caseFlipXorMask;                  uint dow1 = text[1];                  uint dow2 = text[2];                  uint comma = text[3];                  uint dowString = (dow0 << 24) | (dow1 << 16) | (dow2 << 8) | comma;                  switch (dowString)                  {                      case 0x53756E2c /* 'Sun'' */: dayOfWeek = DayOfWeek.Sunday; break;                      case 0x4d6f6e2c /* 'Mon'' */: dayOfWeek = DayOfWeek.Monday; break;                      case 0x5475652c /* 'Tue'' */: dayOfWeek = DayOfWeek.Tuesday; break;                      case 0x5765642c /* 'Wed'' */: dayOfWeek = DayOfWeek.Wednesday; break;                      case 0x5468752c /* 'Thu'' */: dayOfWeek = DayOfWeek.Thursday; break;                      case 0x4672692c /* 'Fri'' */: dayOfWeek = DayOfWeek.Friday; break;                      case 0x5361742c /* 'Sat'' */: dayOfWeek = DayOfWeek.Saturday; break;                      default:                          bytesConsumed = 0;                          dateTimeOffset = default;                          return false;                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetR,The following statement contains a magic number: {                  uint dow0 = text[0] ^ caseFlipXorMask;                  uint dow1 = text[1];                  uint dow2 = text[2];                  uint comma = text[3];                  uint dowString = (dow0 << 24) | (dow1 << 16) | (dow2 << 8) | comma;                  switch (dowString)                  {                      case 0x53756E2c /* 'Sun'' */: dayOfWeek = DayOfWeek.Sunday; break;                      case 0x4d6f6e2c /* 'Mon'' */: dayOfWeek = DayOfWeek.Monday; break;                      case 0x5475652c /* 'Tue'' */: dayOfWeek = DayOfWeek.Tuesday; break;                      case 0x5765642c /* 'Wed'' */: dayOfWeek = DayOfWeek.Wednesday; break;                      case 0x5468752c /* 'Thu'' */: dayOfWeek = DayOfWeek.Thursday; break;                      case 0x4672692c /* 'Fri'' */: dayOfWeek = DayOfWeek.Friday; break;                      case 0x5361742c /* 'Sat'' */: dayOfWeek = DayOfWeek.Saturday; break;                      default:                          bytesConsumed = 0;                          dateTimeOffset = default;                          return false;                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetR,The following statement contains a magic number: {                  uint dow0 = text[0] ^ caseFlipXorMask;                  uint dow1 = text[1];                  uint dow2 = text[2];                  uint comma = text[3];                  uint dowString = (dow0 << 24) | (dow1 << 16) | (dow2 << 8) | comma;                  switch (dowString)                  {                      case 0x53756E2c /* 'Sun'' */: dayOfWeek = DayOfWeek.Sunday; break;                      case 0x4d6f6e2c /* 'Mon'' */: dayOfWeek = DayOfWeek.Monday; break;                      case 0x5475652c /* 'Tue'' */: dayOfWeek = DayOfWeek.Tuesday; break;                      case 0x5765642c /* 'Wed'' */: dayOfWeek = DayOfWeek.Wednesday; break;                      case 0x5468752c /* 'Thu'' */: dayOfWeek = DayOfWeek.Thursday; break;                      case 0x4672692c /* 'Fri'' */: dayOfWeek = DayOfWeek.Friday; break;                      case 0x5361742c /* 'Sat'' */: dayOfWeek = DayOfWeek.Saturday; break;                      default:                          bytesConsumed = 0;                          dateTimeOffset = default;                          return false;                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetR,The following statement contains a magic number: {                  uint dow0 = text[0] ^ caseFlipXorMask;                  uint dow1 = text[1];                  uint dow2 = text[2];                  uint comma = text[3];                  uint dowString = (dow0 << 24) | (dow1 << 16) | (dow2 << 8) | comma;                  switch (dowString)                  {                      case 0x53756E2c /* 'Sun'' */: dayOfWeek = DayOfWeek.Sunday; break;                      case 0x4d6f6e2c /* 'Mon'' */: dayOfWeek = DayOfWeek.Monday; break;                      case 0x5475652c /* 'Tue'' */: dayOfWeek = DayOfWeek.Tuesday; break;                      case 0x5765642c /* 'Wed'' */: dayOfWeek = DayOfWeek.Wednesday; break;                      case 0x5468752c /* 'Thu'' */: dayOfWeek = DayOfWeek.Thursday; break;                      case 0x4672692c /* 'Fri'' */: dayOfWeek = DayOfWeek.Friday; break;                      case 0x5361742c /* 'Sat'' */: dayOfWeek = DayOfWeek.Saturday; break;                      default:                          bytesConsumed = 0;                          dateTimeOffset = default;                          return false;                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetR,The following statement contains a magic number: {                  uint dow0 = text[0] ^ caseFlipXorMask;                  uint dow1 = text[1];                  uint dow2 = text[2];                  uint comma = text[3];                  uint dowString = (dow0 << 24) | (dow1 << 16) | (dow2 << 8) | comma;                  switch (dowString)                  {                      case 0x53756E2c /* 'Sun'' */: dayOfWeek = DayOfWeek.Sunday; break;                      case 0x4d6f6e2c /* 'Mon'' */: dayOfWeek = DayOfWeek.Monday; break;                      case 0x5475652c /* 'Tue'' */: dayOfWeek = DayOfWeek.Tuesday; break;                      case 0x5765642c /* 'Wed'' */: dayOfWeek = DayOfWeek.Wednesday; break;                      case 0x5468752c /* 'Thu'' */: dayOfWeek = DayOfWeek.Thursday; break;                      case 0x4672692c /* 'Fri'' */: dayOfWeek = DayOfWeek.Friday; break;                      case 0x5361742c /* 'Sat'' */: dayOfWeek = DayOfWeek.Saturday; break;                      default:                          bytesConsumed = 0;                          dateTimeOffset = default;                          return false;                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetR,The following statement contains a magic number: if (text[4] != Utf8Constants.Space)              {                  bytesConsumed = 0;                  dateTimeOffset = default;                  return false;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetR,The following statement contains a magic number: {                  uint digit1 = text[5] - 48u; // '0'                  uint digit2 = text[6] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      bytesConsumed = 0;                      dateTimeOffset = default;                      return false;                  }                    day = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetR,The following statement contains a magic number: {                  uint digit1 = text[5] - 48u; // '0'                  uint digit2 = text[6] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      bytesConsumed = 0;                      dateTimeOffset = default;                      return false;                  }                    day = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetR,The following statement contains a magic number: {                  uint digit1 = text[5] - 48u; // '0'                  uint digit2 = text[6] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      bytesConsumed = 0;                      dateTimeOffset = default;                      return false;                  }                    day = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetR,The following statement contains a magic number: {                  uint digit1 = text[5] - 48u; // '0'                  uint digit2 = text[6] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      bytesConsumed = 0;                      dateTimeOffset = default;                      return false;                  }                    day = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetR,The following statement contains a magic number: {                  uint digit1 = text[5] - 48u; // '0'                  uint digit2 = text[6] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      bytesConsumed = 0;                      dateTimeOffset = default;                      return false;                  }                    day = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetR,The following statement contains a magic number: if (text[7] != Utf8Constants.Space)              {                  bytesConsumed = 0;                  dateTimeOffset = default;                  return false;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetR,The following statement contains a magic number: {                  uint mon0 = text[8] ^ caseFlipXorMask;                  uint mon1 = text[9];                  uint mon2 = text[10];                  uint space = text[11];                  uint monthString = (mon0 << 24) | (mon1 << 16) | (mon2 << 8) | space;                  switch (monthString)                  {                      case 0x4a616e20 /* 'Jan ' */ : month = 1; break;                      case 0x46656220 /* 'Feb ' */ : month = 2; break;                      case 0x4d617220 /* 'Mar ' */ : month = 3; break;                      case 0x41707220 /* 'Apr ' */ : month = 4; break;                      case 0x4d617920 /* 'May ' */ : month = 5; break;                      case 0x4a756e20 /* 'Jun ' */ : month = 6; break;                      case 0x4a756c20 /* 'Jul ' */ : month = 7; break;                      case 0x41756720 /* 'Aug ' */ : month = 8; break;                      case 0x53657020 /* 'Sep ' */ : month = 9; break;                      case 0x4f637420 /* 'Oct ' */ : month = 10; break;                      case 0x4e6f7620 /* 'Nov ' */ : month = 11; break;                      case 0x44656320 /* 'Dec ' */ : month = 12; break;                      default:                          bytesConsumed = 0;                          dateTimeOffset = default;                          return false;                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetR,The following statement contains a magic number: {                  uint mon0 = text[8] ^ caseFlipXorMask;                  uint mon1 = text[9];                  uint mon2 = text[10];                  uint space = text[11];                  uint monthString = (mon0 << 24) | (mon1 << 16) | (mon2 << 8) | space;                  switch (monthString)                  {                      case 0x4a616e20 /* 'Jan ' */ : month = 1; break;                      case 0x46656220 /* 'Feb ' */ : month = 2; break;                      case 0x4d617220 /* 'Mar ' */ : month = 3; break;                      case 0x41707220 /* 'Apr ' */ : month = 4; break;                      case 0x4d617920 /* 'May ' */ : month = 5; break;                      case 0x4a756e20 /* 'Jun ' */ : month = 6; break;                      case 0x4a756c20 /* 'Jul ' */ : month = 7; break;                      case 0x41756720 /* 'Aug ' */ : month = 8; break;                      case 0x53657020 /* 'Sep ' */ : month = 9; break;                      case 0x4f637420 /* 'Oct ' */ : month = 10; break;                      case 0x4e6f7620 /* 'Nov ' */ : month = 11; break;                      case 0x44656320 /* 'Dec ' */ : month = 12; break;                      default:                          bytesConsumed = 0;                          dateTimeOffset = default;                          return false;                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetR,The following statement contains a magic number: {                  uint mon0 = text[8] ^ caseFlipXorMask;                  uint mon1 = text[9];                  uint mon2 = text[10];                  uint space = text[11];                  uint monthString = (mon0 << 24) | (mon1 << 16) | (mon2 << 8) | space;                  switch (monthString)                  {                      case 0x4a616e20 /* 'Jan ' */ : month = 1; break;                      case 0x46656220 /* 'Feb ' */ : month = 2; break;                      case 0x4d617220 /* 'Mar ' */ : month = 3; break;                      case 0x41707220 /* 'Apr ' */ : month = 4; break;                      case 0x4d617920 /* 'May ' */ : month = 5; break;                      case 0x4a756e20 /* 'Jun ' */ : month = 6; break;                      case 0x4a756c20 /* 'Jul ' */ : month = 7; break;                      case 0x41756720 /* 'Aug ' */ : month = 8; break;                      case 0x53657020 /* 'Sep ' */ : month = 9; break;                      case 0x4f637420 /* 'Oct ' */ : month = 10; break;                      case 0x4e6f7620 /* 'Nov ' */ : month = 11; break;                      case 0x44656320 /* 'Dec ' */ : month = 12; break;                      default:                          bytesConsumed = 0;                          dateTimeOffset = default;                          return false;                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetR,The following statement contains a magic number: {                  uint mon0 = text[8] ^ caseFlipXorMask;                  uint mon1 = text[9];                  uint mon2 = text[10];                  uint space = text[11];                  uint monthString = (mon0 << 24) | (mon1 << 16) | (mon2 << 8) | space;                  switch (monthString)                  {                      case 0x4a616e20 /* 'Jan ' */ : month = 1; break;                      case 0x46656220 /* 'Feb ' */ : month = 2; break;                      case 0x4d617220 /* 'Mar ' */ : month = 3; break;                      case 0x41707220 /* 'Apr ' */ : month = 4; break;                      case 0x4d617920 /* 'May ' */ : month = 5; break;                      case 0x4a756e20 /* 'Jun ' */ : month = 6; break;                      case 0x4a756c20 /* 'Jul ' */ : month = 7; break;                      case 0x41756720 /* 'Aug ' */ : month = 8; break;                      case 0x53657020 /* 'Sep ' */ : month = 9; break;                      case 0x4f637420 /* 'Oct ' */ : month = 10; break;                      case 0x4e6f7620 /* 'Nov ' */ : month = 11; break;                      case 0x44656320 /* 'Dec ' */ : month = 12; break;                      default:                          bytesConsumed = 0;                          dateTimeOffset = default;                          return false;                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetR,The following statement contains a magic number: {                  uint mon0 = text[8] ^ caseFlipXorMask;                  uint mon1 = text[9];                  uint mon2 = text[10];                  uint space = text[11];                  uint monthString = (mon0 << 24) | (mon1 << 16) | (mon2 << 8) | space;                  switch (monthString)                  {                      case 0x4a616e20 /* 'Jan ' */ : month = 1; break;                      case 0x46656220 /* 'Feb ' */ : month = 2; break;                      case 0x4d617220 /* 'Mar ' */ : month = 3; break;                      case 0x41707220 /* 'Apr ' */ : month = 4; break;                      case 0x4d617920 /* 'May ' */ : month = 5; break;                      case 0x4a756e20 /* 'Jun ' */ : month = 6; break;                      case 0x4a756c20 /* 'Jul ' */ : month = 7; break;                      case 0x41756720 /* 'Aug ' */ : month = 8; break;                      case 0x53657020 /* 'Sep ' */ : month = 9; break;                      case 0x4f637420 /* 'Oct ' */ : month = 10; break;                      case 0x4e6f7620 /* 'Nov ' */ : month = 11; break;                      case 0x44656320 /* 'Dec ' */ : month = 12; break;                      default:                          bytesConsumed = 0;                          dateTimeOffset = default;                          return false;                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetR,The following statement contains a magic number: {                  uint mon0 = text[8] ^ caseFlipXorMask;                  uint mon1 = text[9];                  uint mon2 = text[10];                  uint space = text[11];                  uint monthString = (mon0 << 24) | (mon1 << 16) | (mon2 << 8) | space;                  switch (monthString)                  {                      case 0x4a616e20 /* 'Jan ' */ : month = 1; break;                      case 0x46656220 /* 'Feb ' */ : month = 2; break;                      case 0x4d617220 /* 'Mar ' */ : month = 3; break;                      case 0x41707220 /* 'Apr ' */ : month = 4; break;                      case 0x4d617920 /* 'May ' */ : month = 5; break;                      case 0x4a756e20 /* 'Jun ' */ : month = 6; break;                      case 0x4a756c20 /* 'Jul ' */ : month = 7; break;                      case 0x41756720 /* 'Aug ' */ : month = 8; break;                      case 0x53657020 /* 'Sep ' */ : month = 9; break;                      case 0x4f637420 /* 'Oct ' */ : month = 10; break;                      case 0x4e6f7620 /* 'Nov ' */ : month = 11; break;                      case 0x44656320 /* 'Dec ' */ : month = 12; break;                      default:                          bytesConsumed = 0;                          dateTimeOffset = default;                          return false;                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetR,The following statement contains a magic number: {                  uint mon0 = text[8] ^ caseFlipXorMask;                  uint mon1 = text[9];                  uint mon2 = text[10];                  uint space = text[11];                  uint monthString = (mon0 << 24) | (mon1 << 16) | (mon2 << 8) | space;                  switch (monthString)                  {                      case 0x4a616e20 /* 'Jan ' */ : month = 1; break;                      case 0x46656220 /* 'Feb ' */ : month = 2; break;                      case 0x4d617220 /* 'Mar ' */ : month = 3; break;                      case 0x41707220 /* 'Apr ' */ : month = 4; break;                      case 0x4d617920 /* 'May ' */ : month = 5; break;                      case 0x4a756e20 /* 'Jun ' */ : month = 6; break;                      case 0x4a756c20 /* 'Jul ' */ : month = 7; break;                      case 0x41756720 /* 'Aug ' */ : month = 8; break;                      case 0x53657020 /* 'Sep ' */ : month = 9; break;                      case 0x4f637420 /* 'Oct ' */ : month = 10; break;                      case 0x4e6f7620 /* 'Nov ' */ : month = 11; break;                      case 0x44656320 /* 'Dec ' */ : month = 12; break;                      default:                          bytesConsumed = 0;                          dateTimeOffset = default;                          return false;                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetR,The following statement contains a magic number: {                  uint mon0 = text[8] ^ caseFlipXorMask;                  uint mon1 = text[9];                  uint mon2 = text[10];                  uint space = text[11];                  uint monthString = (mon0 << 24) | (mon1 << 16) | (mon2 << 8) | space;                  switch (monthString)                  {                      case 0x4a616e20 /* 'Jan ' */ : month = 1; break;                      case 0x46656220 /* 'Feb ' */ : month = 2; break;                      case 0x4d617220 /* 'Mar ' */ : month = 3; break;                      case 0x41707220 /* 'Apr ' */ : month = 4; break;                      case 0x4d617920 /* 'May ' */ : month = 5; break;                      case 0x4a756e20 /* 'Jun ' */ : month = 6; break;                      case 0x4a756c20 /* 'Jul ' */ : month = 7; break;                      case 0x41756720 /* 'Aug ' */ : month = 8; break;                      case 0x53657020 /* 'Sep ' */ : month = 9; break;                      case 0x4f637420 /* 'Oct ' */ : month = 10; break;                      case 0x4e6f7620 /* 'Nov ' */ : month = 11; break;                      case 0x44656320 /* 'Dec ' */ : month = 12; break;                      default:                          bytesConsumed = 0;                          dateTimeOffset = default;                          return false;                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetR,The following statement contains a magic number: {                  uint mon0 = text[8] ^ caseFlipXorMask;                  uint mon1 = text[9];                  uint mon2 = text[10];                  uint space = text[11];                  uint monthString = (mon0 << 24) | (mon1 << 16) | (mon2 << 8) | space;                  switch (monthString)                  {                      case 0x4a616e20 /* 'Jan ' */ : month = 1; break;                      case 0x46656220 /* 'Feb ' */ : month = 2; break;                      case 0x4d617220 /* 'Mar ' */ : month = 3; break;                      case 0x41707220 /* 'Apr ' */ : month = 4; break;                      case 0x4d617920 /* 'May ' */ : month = 5; break;                      case 0x4a756e20 /* 'Jun ' */ : month = 6; break;                      case 0x4a756c20 /* 'Jul ' */ : month = 7; break;                      case 0x41756720 /* 'Aug ' */ : month = 8; break;                      case 0x53657020 /* 'Sep ' */ : month = 9; break;                      case 0x4f637420 /* 'Oct ' */ : month = 10; break;                      case 0x4e6f7620 /* 'Nov ' */ : month = 11; break;                      case 0x44656320 /* 'Dec ' */ : month = 12; break;                      default:                          bytesConsumed = 0;                          dateTimeOffset = default;                          return false;                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetR,The following statement contains a magic number: {                  uint mon0 = text[8] ^ caseFlipXorMask;                  uint mon1 = text[9];                  uint mon2 = text[10];                  uint space = text[11];                  uint monthString = (mon0 << 24) | (mon1 << 16) | (mon2 << 8) | space;                  switch (monthString)                  {                      case 0x4a616e20 /* 'Jan ' */ : month = 1; break;                      case 0x46656220 /* 'Feb ' */ : month = 2; break;                      case 0x4d617220 /* 'Mar ' */ : month = 3; break;                      case 0x41707220 /* 'Apr ' */ : month = 4; break;                      case 0x4d617920 /* 'May ' */ : month = 5; break;                      case 0x4a756e20 /* 'Jun ' */ : month = 6; break;                      case 0x4a756c20 /* 'Jul ' */ : month = 7; break;                      case 0x41756720 /* 'Aug ' */ : month = 8; break;                      case 0x53657020 /* 'Sep ' */ : month = 9; break;                      case 0x4f637420 /* 'Oct ' */ : month = 10; break;                      case 0x4e6f7620 /* 'Nov ' */ : month = 11; break;                      case 0x44656320 /* 'Dec ' */ : month = 12; break;                      default:                          bytesConsumed = 0;                          dateTimeOffset = default;                          return false;                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetR,The following statement contains a magic number: {                  uint mon0 = text[8] ^ caseFlipXorMask;                  uint mon1 = text[9];                  uint mon2 = text[10];                  uint space = text[11];                  uint monthString = (mon0 << 24) | (mon1 << 16) | (mon2 << 8) | space;                  switch (monthString)                  {                      case 0x4a616e20 /* 'Jan ' */ : month = 1; break;                      case 0x46656220 /* 'Feb ' */ : month = 2; break;                      case 0x4d617220 /* 'Mar ' */ : month = 3; break;                      case 0x41707220 /* 'Apr ' */ : month = 4; break;                      case 0x4d617920 /* 'May ' */ : month = 5; break;                      case 0x4a756e20 /* 'Jun ' */ : month = 6; break;                      case 0x4a756c20 /* 'Jul ' */ : month = 7; break;                      case 0x41756720 /* 'Aug ' */ : month = 8; break;                      case 0x53657020 /* 'Sep ' */ : month = 9; break;                      case 0x4f637420 /* 'Oct ' */ : month = 10; break;                      case 0x4e6f7620 /* 'Nov ' */ : month = 11; break;                      case 0x44656320 /* 'Dec ' */ : month = 12; break;                      default:                          bytesConsumed = 0;                          dateTimeOffset = default;                          return false;                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetR,The following statement contains a magic number: {                  uint mon0 = text[8] ^ caseFlipXorMask;                  uint mon1 = text[9];                  uint mon2 = text[10];                  uint space = text[11];                  uint monthString = (mon0 << 24) | (mon1 << 16) | (mon2 << 8) | space;                  switch (monthString)                  {                      case 0x4a616e20 /* 'Jan ' */ : month = 1; break;                      case 0x46656220 /* 'Feb ' */ : month = 2; break;                      case 0x4d617220 /* 'Mar ' */ : month = 3; break;                      case 0x41707220 /* 'Apr ' */ : month = 4; break;                      case 0x4d617920 /* 'May ' */ : month = 5; break;                      case 0x4a756e20 /* 'Jun ' */ : month = 6; break;                      case 0x4a756c20 /* 'Jul ' */ : month = 7; break;                      case 0x41756720 /* 'Aug ' */ : month = 8; break;                      case 0x53657020 /* 'Sep ' */ : month = 9; break;                      case 0x4f637420 /* 'Oct ' */ : month = 10; break;                      case 0x4e6f7620 /* 'Nov ' */ : month = 11; break;                      case 0x44656320 /* 'Dec ' */ : month = 12; break;                      default:                          bytesConsumed = 0;                          dateTimeOffset = default;                          return false;                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetR,The following statement contains a magic number: {                  uint mon0 = text[8] ^ caseFlipXorMask;                  uint mon1 = text[9];                  uint mon2 = text[10];                  uint space = text[11];                  uint monthString = (mon0 << 24) | (mon1 << 16) | (mon2 << 8) | space;                  switch (monthString)                  {                      case 0x4a616e20 /* 'Jan ' */ : month = 1; break;                      case 0x46656220 /* 'Feb ' */ : month = 2; break;                      case 0x4d617220 /* 'Mar ' */ : month = 3; break;                      case 0x41707220 /* 'Apr ' */ : month = 4; break;                      case 0x4d617920 /* 'May ' */ : month = 5; break;                      case 0x4a756e20 /* 'Jun ' */ : month = 6; break;                      case 0x4a756c20 /* 'Jul ' */ : month = 7; break;                      case 0x41756720 /* 'Aug ' */ : month = 8; break;                      case 0x53657020 /* 'Sep ' */ : month = 9; break;                      case 0x4f637420 /* 'Oct ' */ : month = 10; break;                      case 0x4e6f7620 /* 'Nov ' */ : month = 11; break;                      case 0x44656320 /* 'Dec ' */ : month = 12; break;                      default:                          bytesConsumed = 0;                          dateTimeOffset = default;                          return false;                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetR,The following statement contains a magic number: {                  uint mon0 = text[8] ^ caseFlipXorMask;                  uint mon1 = text[9];                  uint mon2 = text[10];                  uint space = text[11];                  uint monthString = (mon0 << 24) | (mon1 << 16) | (mon2 << 8) | space;                  switch (monthString)                  {                      case 0x4a616e20 /* 'Jan ' */ : month = 1; break;                      case 0x46656220 /* 'Feb ' */ : month = 2; break;                      case 0x4d617220 /* 'Mar ' */ : month = 3; break;                      case 0x41707220 /* 'Apr ' */ : month = 4; break;                      case 0x4d617920 /* 'May ' */ : month = 5; break;                      case 0x4a756e20 /* 'Jun ' */ : month = 6; break;                      case 0x4a756c20 /* 'Jul ' */ : month = 7; break;                      case 0x41756720 /* 'Aug ' */ : month = 8; break;                      case 0x53657020 /* 'Sep ' */ : month = 9; break;                      case 0x4f637420 /* 'Oct ' */ : month = 10; break;                      case 0x4e6f7620 /* 'Nov ' */ : month = 11; break;                      case 0x44656320 /* 'Dec ' */ : month = 12; break;                      default:                          bytesConsumed = 0;                          dateTimeOffset = default;                          return false;                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetR,The following statement contains a magic number: {                  uint mon0 = text[8] ^ caseFlipXorMask;                  uint mon1 = text[9];                  uint mon2 = text[10];                  uint space = text[11];                  uint monthString = (mon0 << 24) | (mon1 << 16) | (mon2 << 8) | space;                  switch (monthString)                  {                      case 0x4a616e20 /* 'Jan ' */ : month = 1; break;                      case 0x46656220 /* 'Feb ' */ : month = 2; break;                      case 0x4d617220 /* 'Mar ' */ : month = 3; break;                      case 0x41707220 /* 'Apr ' */ : month = 4; break;                      case 0x4d617920 /* 'May ' */ : month = 5; break;                      case 0x4a756e20 /* 'Jun ' */ : month = 6; break;                      case 0x4a756c20 /* 'Jul ' */ : month = 7; break;                      case 0x41756720 /* 'Aug ' */ : month = 8; break;                      case 0x53657020 /* 'Sep ' */ : month = 9; break;                      case 0x4f637420 /* 'Oct ' */ : month = 10; break;                      case 0x4e6f7620 /* 'Nov ' */ : month = 11; break;                      case 0x44656320 /* 'Dec ' */ : month = 12; break;                      default:                          bytesConsumed = 0;                          dateTimeOffset = default;                          return false;                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetR,The following statement contains a magic number: {                  uint mon0 = text[8] ^ caseFlipXorMask;                  uint mon1 = text[9];                  uint mon2 = text[10];                  uint space = text[11];                  uint monthString = (mon0 << 24) | (mon1 << 16) | (mon2 << 8) | space;                  switch (monthString)                  {                      case 0x4a616e20 /* 'Jan ' */ : month = 1; break;                      case 0x46656220 /* 'Feb ' */ : month = 2; break;                      case 0x4d617220 /* 'Mar ' */ : month = 3; break;                      case 0x41707220 /* 'Apr ' */ : month = 4; break;                      case 0x4d617920 /* 'May ' */ : month = 5; break;                      case 0x4a756e20 /* 'Jun ' */ : month = 6; break;                      case 0x4a756c20 /* 'Jul ' */ : month = 7; break;                      case 0x41756720 /* 'Aug ' */ : month = 8; break;                      case 0x53657020 /* 'Sep ' */ : month = 9; break;                      case 0x4f637420 /* 'Oct ' */ : month = 10; break;                      case 0x4e6f7620 /* 'Nov ' */ : month = 11; break;                      case 0x44656320 /* 'Dec ' */ : month = 12; break;                      default:                          bytesConsumed = 0;                          dateTimeOffset = default;                          return false;                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetR,The following statement contains a magic number: {                  uint mon0 = text[8] ^ caseFlipXorMask;                  uint mon1 = text[9];                  uint mon2 = text[10];                  uint space = text[11];                  uint monthString = (mon0 << 24) | (mon1 << 16) | (mon2 << 8) | space;                  switch (monthString)                  {                      case 0x4a616e20 /* 'Jan ' */ : month = 1; break;                      case 0x46656220 /* 'Feb ' */ : month = 2; break;                      case 0x4d617220 /* 'Mar ' */ : month = 3; break;                      case 0x41707220 /* 'Apr ' */ : month = 4; break;                      case 0x4d617920 /* 'May ' */ : month = 5; break;                      case 0x4a756e20 /* 'Jun ' */ : month = 6; break;                      case 0x4a756c20 /* 'Jul ' */ : month = 7; break;                      case 0x41756720 /* 'Aug ' */ : month = 8; break;                      case 0x53657020 /* 'Sep ' */ : month = 9; break;                      case 0x4f637420 /* 'Oct ' */ : month = 10; break;                      case 0x4e6f7620 /* 'Nov ' */ : month = 11; break;                      case 0x44656320 /* 'Dec ' */ : month = 12; break;                      default:                          bytesConsumed = 0;                          dateTimeOffset = default;                          return false;                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetR,The following statement contains a magic number: {                  uint mon0 = text[8] ^ caseFlipXorMask;                  uint mon1 = text[9];                  uint mon2 = text[10];                  uint space = text[11];                  uint monthString = (mon0 << 24) | (mon1 << 16) | (mon2 << 8) | space;                  switch (monthString)                  {                      case 0x4a616e20 /* 'Jan ' */ : month = 1; break;                      case 0x46656220 /* 'Feb ' */ : month = 2; break;                      case 0x4d617220 /* 'Mar ' */ : month = 3; break;                      case 0x41707220 /* 'Apr ' */ : month = 4; break;                      case 0x4d617920 /* 'May ' */ : month = 5; break;                      case 0x4a756e20 /* 'Jun ' */ : month = 6; break;                      case 0x4a756c20 /* 'Jul ' */ : month = 7; break;                      case 0x41756720 /* 'Aug ' */ : month = 8; break;                      case 0x53657020 /* 'Sep ' */ : month = 9; break;                      case 0x4f637420 /* 'Oct ' */ : month = 10; break;                      case 0x4e6f7620 /* 'Nov ' */ : month = 11; break;                      case 0x44656320 /* 'Dec ' */ : month = 12; break;                      default:                          bytesConsumed = 0;                          dateTimeOffset = default;                          return false;                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetR,The following statement contains a magic number: {                  uint digit1 = text[12] - 48u; // '0'                  uint digit2 = text[13] - 48u; // '0'                  uint digit3 = text[14] - 48u; // '0'                  uint digit4 = text[15] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9 || digit3 > 9 || digit4 > 9)                  {                      bytesConsumed = 0;                      dateTimeOffset = default;                      return false;                  }                    year = (int)(digit1 * 1000 + digit2 * 100 + digit3 * 10 + digit4);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetR,The following statement contains a magic number: {                  uint digit1 = text[12] - 48u; // '0'                  uint digit2 = text[13] - 48u; // '0'                  uint digit3 = text[14] - 48u; // '0'                  uint digit4 = text[15] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9 || digit3 > 9 || digit4 > 9)                  {                      bytesConsumed = 0;                      dateTimeOffset = default;                      return false;                  }                    year = (int)(digit1 * 1000 + digit2 * 100 + digit3 * 10 + digit4);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetR,The following statement contains a magic number: {                  uint digit1 = text[12] - 48u; // '0'                  uint digit2 = text[13] - 48u; // '0'                  uint digit3 = text[14] - 48u; // '0'                  uint digit4 = text[15] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9 || digit3 > 9 || digit4 > 9)                  {                      bytesConsumed = 0;                      dateTimeOffset = default;                      return false;                  }                    year = (int)(digit1 * 1000 + digit2 * 100 + digit3 * 10 + digit4);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetR,The following statement contains a magic number: {                  uint digit1 = text[12] - 48u; // '0'                  uint digit2 = text[13] - 48u; // '0'                  uint digit3 = text[14] - 48u; // '0'                  uint digit4 = text[15] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9 || digit3 > 9 || digit4 > 9)                  {                      bytesConsumed = 0;                      dateTimeOffset = default;                      return false;                  }                    year = (int)(digit1 * 1000 + digit2 * 100 + digit3 * 10 + digit4);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetR,The following statement contains a magic number: {                  uint digit1 = text[12] - 48u; // '0'                  uint digit2 = text[13] - 48u; // '0'                  uint digit3 = text[14] - 48u; // '0'                  uint digit4 = text[15] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9 || digit3 > 9 || digit4 > 9)                  {                      bytesConsumed = 0;                      dateTimeOffset = default;                      return false;                  }                    year = (int)(digit1 * 1000 + digit2 * 100 + digit3 * 10 + digit4);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetR,The following statement contains a magic number: {                  uint digit1 = text[12] - 48u; // '0'                  uint digit2 = text[13] - 48u; // '0'                  uint digit3 = text[14] - 48u; // '0'                  uint digit4 = text[15] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9 || digit3 > 9 || digit4 > 9)                  {                      bytesConsumed = 0;                      dateTimeOffset = default;                      return false;                  }                    year = (int)(digit1 * 1000 + digit2 * 100 + digit3 * 10 + digit4);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetR,The following statement contains a magic number: {                  uint digit1 = text[12] - 48u; // '0'                  uint digit2 = text[13] - 48u; // '0'                  uint digit3 = text[14] - 48u; // '0'                  uint digit4 = text[15] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9 || digit3 > 9 || digit4 > 9)                  {                      bytesConsumed = 0;                      dateTimeOffset = default;                      return false;                  }                    year = (int)(digit1 * 1000 + digit2 * 100 + digit3 * 10 + digit4);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetR,The following statement contains a magic number: {                  uint digit1 = text[12] - 48u; // '0'                  uint digit2 = text[13] - 48u; // '0'                  uint digit3 = text[14] - 48u; // '0'                  uint digit4 = text[15] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9 || digit3 > 9 || digit4 > 9)                  {                      bytesConsumed = 0;                      dateTimeOffset = default;                      return false;                  }                    year = (int)(digit1 * 1000 + digit2 * 100 + digit3 * 10 + digit4);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetR,The following statement contains a magic number: {                  uint digit1 = text[12] - 48u; // '0'                  uint digit2 = text[13] - 48u; // '0'                  uint digit3 = text[14] - 48u; // '0'                  uint digit4 = text[15] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9 || digit3 > 9 || digit4 > 9)                  {                      bytesConsumed = 0;                      dateTimeOffset = default;                      return false;                  }                    year = (int)(digit1 * 1000 + digit2 * 100 + digit3 * 10 + digit4);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetR,The following statement contains a magic number: {                  uint digit1 = text[12] - 48u; // '0'                  uint digit2 = text[13] - 48u; // '0'                  uint digit3 = text[14] - 48u; // '0'                  uint digit4 = text[15] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9 || digit3 > 9 || digit4 > 9)                  {                      bytesConsumed = 0;                      dateTimeOffset = default;                      return false;                  }                    year = (int)(digit1 * 1000 + digit2 * 100 + digit3 * 10 + digit4);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetR,The following statement contains a magic number: {                  uint digit1 = text[12] - 48u; // '0'                  uint digit2 = text[13] - 48u; // '0'                  uint digit3 = text[14] - 48u; // '0'                  uint digit4 = text[15] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9 || digit3 > 9 || digit4 > 9)                  {                      bytesConsumed = 0;                      dateTimeOffset = default;                      return false;                  }                    year = (int)(digit1 * 1000 + digit2 * 100 + digit3 * 10 + digit4);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetR,The following statement contains a magic number: if (text[16] != Utf8Constants.Space)              {                  bytesConsumed = 0;                  dateTimeOffset = default;                  return false;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetR,The following statement contains a magic number: {                  uint digit1 = text[17] - 48u; // '0'                  uint digit2 = text[18] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      bytesConsumed = 0;                      dateTimeOffset = default;                      return false;                  }                    hour = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetR,The following statement contains a magic number: {                  uint digit1 = text[17] - 48u; // '0'                  uint digit2 = text[18] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      bytesConsumed = 0;                      dateTimeOffset = default;                      return false;                  }                    hour = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetR,The following statement contains a magic number: {                  uint digit1 = text[17] - 48u; // '0'                  uint digit2 = text[18] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      bytesConsumed = 0;                      dateTimeOffset = default;                      return false;                  }                    hour = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetR,The following statement contains a magic number: {                  uint digit1 = text[17] - 48u; // '0'                  uint digit2 = text[18] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      bytesConsumed = 0;                      dateTimeOffset = default;                      return false;                  }                    hour = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetR,The following statement contains a magic number: {                  uint digit1 = text[17] - 48u; // '0'                  uint digit2 = text[18] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      bytesConsumed = 0;                      dateTimeOffset = default;                      return false;                  }                    hour = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetR,The following statement contains a magic number: if (text[19] != Utf8Constants.Colon)              {                  bytesConsumed = 0;                  dateTimeOffset = default;                  return false;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetR,The following statement contains a magic number: {                  uint digit1 = text[20] - 48u; // '0'                  uint digit2 = text[21] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      bytesConsumed = 0;                      dateTimeOffset = default;                      return false;                  }                    minute = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetR,The following statement contains a magic number: {                  uint digit1 = text[20] - 48u; // '0'                  uint digit2 = text[21] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      bytesConsumed = 0;                      dateTimeOffset = default;                      return false;                  }                    minute = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetR,The following statement contains a magic number: {                  uint digit1 = text[20] - 48u; // '0'                  uint digit2 = text[21] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      bytesConsumed = 0;                      dateTimeOffset = default;                      return false;                  }                    minute = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetR,The following statement contains a magic number: {                  uint digit1 = text[20] - 48u; // '0'                  uint digit2 = text[21] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      bytesConsumed = 0;                      dateTimeOffset = default;                      return false;                  }                    minute = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetR,The following statement contains a magic number: {                  uint digit1 = text[20] - 48u; // '0'                  uint digit2 = text[21] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      bytesConsumed = 0;                      dateTimeOffset = default;                      return false;                  }                    minute = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetR,The following statement contains a magic number: if (text[22] != Utf8Constants.Colon)              {                  bytesConsumed = 0;                  dateTimeOffset = default;                  return false;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetR,The following statement contains a magic number: {                  uint digit1 = text[23] - 48u; // '0'                  uint digit2 = text[24] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      bytesConsumed = 0;                      dateTimeOffset = default;                      return false;                  }                    second = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetR,The following statement contains a magic number: {                  uint digit1 = text[23] - 48u; // '0'                  uint digit2 = text[24] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      bytesConsumed = 0;                      dateTimeOffset = default;                      return false;                  }                    second = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetR,The following statement contains a magic number: {                  uint digit1 = text[23] - 48u; // '0'                  uint digit2 = text[24] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      bytesConsumed = 0;                      dateTimeOffset = default;                      return false;                  }                    second = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetR,The following statement contains a magic number: {                  uint digit1 = text[23] - 48u; // '0'                  uint digit2 = text[24] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      bytesConsumed = 0;                      dateTimeOffset = default;                      return false;                  }                    second = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetR,The following statement contains a magic number: {                  uint digit1 = text[23] - 48u; // '0'                  uint digit2 = text[24] - 48u; // '0'                    if (digit1 > 9 || digit2 > 9)                  {                      bytesConsumed = 0;                      dateTimeOffset = default;                      return false;                  }                    second = (int)(digit1 * 10 + digit2);              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetR,The following statement contains a magic number: {                  uint space = text[25];                  uint g = text[26] ^ caseFlipXorMask;                  uint m = text[27] ^ caseFlipXorMask;                  uint t = text[28] ^ caseFlipXorMask;                  uint gmtString = (space << 24) | (g << 16) | (m << 8) | t;                  if (gmtString != 0x20474d54 /* ' GMT' */)                  {                      bytesConsumed = 0;                      dateTimeOffset = default;                      return false;                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetR,The following statement contains a magic number: {                  uint space = text[25];                  uint g = text[26] ^ caseFlipXorMask;                  uint m = text[27] ^ caseFlipXorMask;                  uint t = text[28] ^ caseFlipXorMask;                  uint gmtString = (space << 24) | (g << 16) | (m << 8) | t;                  if (gmtString != 0x20474d54 /* ' GMT' */)                  {                      bytesConsumed = 0;                      dateTimeOffset = default;                      return false;                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetR,The following statement contains a magic number: {                  uint space = text[25];                  uint g = text[26] ^ caseFlipXorMask;                  uint m = text[27] ^ caseFlipXorMask;                  uint t = text[28] ^ caseFlipXorMask;                  uint gmtString = (space << 24) | (g << 16) | (m << 8) | t;                  if (gmtString != 0x20474d54 /* ' GMT' */)                  {                      bytesConsumed = 0;                      dateTimeOffset = default;                      return false;                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetR,The following statement contains a magic number: {                  uint space = text[25];                  uint g = text[26] ^ caseFlipXorMask;                  uint m = text[27] ^ caseFlipXorMask;                  uint t = text[28] ^ caseFlipXorMask;                  uint gmtString = (space << 24) | (g << 16) | (m << 8) | t;                  if (gmtString != 0x20474d54 /* ' GMT' */)                  {                      bytesConsumed = 0;                      dateTimeOffset = default;                      return false;                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetR,The following statement contains a magic number: {                  uint space = text[25];                  uint g = text[26] ^ caseFlipXorMask;                  uint m = text[27] ^ caseFlipXorMask;                  uint t = text[28] ^ caseFlipXorMask;                  uint gmtString = (space << 24) | (g << 16) | (m << 8) | t;                  if (gmtString != 0x20474d54 /* ' GMT' */)                  {                      bytesConsumed = 0;                      dateTimeOffset = default;                      return false;                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetR,The following statement contains a magic number: {                  uint space = text[25];                  uint g = text[26] ^ caseFlipXorMask;                  uint m = text[27] ^ caseFlipXorMask;                  uint t = text[28] ^ caseFlipXorMask;                  uint gmtString = (space << 24) | (g << 16) | (m << 8) | t;                  if (gmtString != 0x20474d54 /* ' GMT' */)                  {                      bytesConsumed = 0;                      dateTimeOffset = default;                      return false;                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetR,The following statement contains a magic number: {                  uint space = text[25];                  uint g = text[26] ^ caseFlipXorMask;                  uint m = text[27] ^ caseFlipXorMask;                  uint t = text[28] ^ caseFlipXorMask;                  uint gmtString = (space << 24) | (g << 16) | (m << 8) | t;                  if (gmtString != 0x20474d54 /* ' GMT' */)                  {                      bytesConsumed = 0;                      dateTimeOffset = default;                      return false;                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseDateTimeOffsetR,The following statement contains a magic number: bytesConsumed = 29;
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseAsSpecialFloatingPoint,The following statement contains a magic number: if (text.Length >= 8 &&                  text[0] == 'I' && text[1] == 'n' && text[2] == 'f' && text[3] == 'i' &&                  text[4] == 'n' && text[5] == 'i' && text[6] == 't' && text[7] == 'y')              {                  value = positiveInfinity;                  bytesConsumed = 8;                  return true;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseAsSpecialFloatingPoint,The following statement contains a magic number: if (text.Length >= 8 &&                  text[0] == 'I' && text[1] == 'n' && text[2] == 'f' && text[3] == 'i' &&                  text[4] == 'n' && text[5] == 'i' && text[6] == 't' && text[7] == 'y')              {                  value = positiveInfinity;                  bytesConsumed = 8;                  return true;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseAsSpecialFloatingPoint,The following statement contains a magic number: if (text.Length >= 8 &&                  text[0] == 'I' && text[1] == 'n' && text[2] == 'f' && text[3] == 'i' &&                  text[4] == 'n' && text[5] == 'i' && text[6] == 't' && text[7] == 'y')              {                  value = positiveInfinity;                  bytesConsumed = 8;                  return true;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseAsSpecialFloatingPoint,The following statement contains a magic number: if (text.Length >= 8 &&                  text[0] == 'I' && text[1] == 'n' && text[2] == 'f' && text[3] == 'i' &&                  text[4] == 'n' && text[5] == 'i' && text[6] == 't' && text[7] == 'y')              {                  value = positiveInfinity;                  bytesConsumed = 8;                  return true;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseAsSpecialFloatingPoint,The following statement contains a magic number: if (text.Length >= 8 &&                  text[0] == 'I' && text[1] == 'n' && text[2] == 'f' && text[3] == 'i' &&                  text[4] == 'n' && text[5] == 'i' && text[6] == 't' && text[7] == 'y')              {                  value = positiveInfinity;                  bytesConsumed = 8;                  return true;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseAsSpecialFloatingPoint,The following statement contains a magic number: if (text.Length >= 8 &&                  text[0] == 'I' && text[1] == 'n' && text[2] == 'f' && text[3] == 'i' &&                  text[4] == 'n' && text[5] == 'i' && text[6] == 't' && text[7] == 'y')              {                  value = positiveInfinity;                  bytesConsumed = 8;                  return true;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseAsSpecialFloatingPoint,The following statement contains a magic number: if (text.Length >= 8 &&                  text[0] == 'I' && text[1] == 'n' && text[2] == 'f' && text[3] == 'i' &&                  text[4] == 'n' && text[5] == 'i' && text[6] == 't' && text[7] == 'y')              {                  value = positiveInfinity;                  bytesConsumed = 8;                  return true;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseAsSpecialFloatingPoint,The following statement contains a magic number: if (text.Length >= 8 &&                  text[0] == 'I' && text[1] == 'n' && text[2] == 'f' && text[3] == 'i' &&                  text[4] == 'n' && text[5] == 'i' && text[6] == 't' && text[7] == 'y')              {                  value = positiveInfinity;                  bytesConsumed = 8;                  return true;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseAsSpecialFloatingPoint,The following statement contains a magic number: if (text.Length >= 9 &&                  text[0] == Utf8Constants.Minus &&                  text[1] == 'I' && text[2] == 'n' && text[3] == 'f' && text[4] == 'i' &&                  text[5] == 'n' && text[6] == 'i' && text[7] == 't' && text[8] == 'y')              {                  value = negativeInfinity;                  bytesConsumed = 9;                  return true;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseAsSpecialFloatingPoint,The following statement contains a magic number: if (text.Length >= 9 &&                  text[0] == Utf8Constants.Minus &&                  text[1] == 'I' && text[2] == 'n' && text[3] == 'f' && text[4] == 'i' &&                  text[5] == 'n' && text[6] == 'i' && text[7] == 't' && text[8] == 'y')              {                  value = negativeInfinity;                  bytesConsumed = 9;                  return true;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseAsSpecialFloatingPoint,The following statement contains a magic number: if (text.Length >= 9 &&                  text[0] == Utf8Constants.Minus &&                  text[1] == 'I' && text[2] == 'n' && text[3] == 'f' && text[4] == 'i' &&                  text[5] == 'n' && text[6] == 'i' && text[7] == 't' && text[8] == 'y')              {                  value = negativeInfinity;                  bytesConsumed = 9;                  return true;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseAsSpecialFloatingPoint,The following statement contains a magic number: if (text.Length >= 9 &&                  text[0] == Utf8Constants.Minus &&                  text[1] == 'I' && text[2] == 'n' && text[3] == 'f' && text[4] == 'i' &&                  text[5] == 'n' && text[6] == 'i' && text[7] == 't' && text[8] == 'y')              {                  value = negativeInfinity;                  bytesConsumed = 9;                  return true;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseAsSpecialFloatingPoint,The following statement contains a magic number: if (text.Length >= 9 &&                  text[0] == Utf8Constants.Minus &&                  text[1] == 'I' && text[2] == 'n' && text[3] == 'f' && text[4] == 'i' &&                  text[5] == 'n' && text[6] == 'i' && text[7] == 't' && text[8] == 'y')              {                  value = negativeInfinity;                  bytesConsumed = 9;                  return true;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseAsSpecialFloatingPoint,The following statement contains a magic number: if (text.Length >= 9 &&                  text[0] == Utf8Constants.Minus &&                  text[1] == 'I' && text[2] == 'n' && text[3] == 'f' && text[4] == 'i' &&                  text[5] == 'n' && text[6] == 'i' && text[7] == 't' && text[8] == 'y')              {                  value = negativeInfinity;                  bytesConsumed = 9;                  return true;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseAsSpecialFloatingPoint,The following statement contains a magic number: if (text.Length >= 9 &&                  text[0] == Utf8Constants.Minus &&                  text[1] == 'I' && text[2] == 'n' && text[3] == 'f' && text[4] == 'i' &&                  text[5] == 'n' && text[6] == 'i' && text[7] == 't' && text[8] == 'y')              {                  value = negativeInfinity;                  bytesConsumed = 9;                  return true;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseAsSpecialFloatingPoint,The following statement contains a magic number: if (text.Length >= 9 &&                  text[0] == Utf8Constants.Minus &&                  text[1] == 'I' && text[2] == 'n' && text[3] == 'f' && text[4] == 'i' &&                  text[5] == 'n' && text[6] == 'i' && text[7] == 't' && text[8] == 'y')              {                  value = negativeInfinity;                  bytesConsumed = 9;                  return true;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseAsSpecialFloatingPoint,The following statement contains a magic number: if (text.Length >= 9 &&                  text[0] == Utf8Constants.Minus &&                  text[1] == 'I' && text[2] == 'n' && text[3] == 'f' && text[4] == 'i' &&                  text[5] == 'n' && text[6] == 'i' && text[7] == 't' && text[8] == 'y')              {                  value = negativeInfinity;                  bytesConsumed = 9;                  return true;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseAsSpecialFloatingPoint,The following statement contains a magic number: if (text.Length >= 3 &&                  text[0] == 'N' && text[1] == 'a' && text[2] == 'N')              {                  value = nan;                  bytesConsumed = 3;                  return true;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseAsSpecialFloatingPoint,The following statement contains a magic number: if (text.Length >= 3 &&                  text[0] == 'N' && text[1] == 'a' && text[2] == 'N')              {                  value = nan;                  bytesConsumed = 3;                  return true;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseAsSpecialFloatingPoint,The following statement contains a magic number: if (text.Length >= 3 &&                  text[0] == 'N' && text[1] == 'a' && text[2] == 'N')              {                  value = nan;                  bytesConsumed = 3;                  return true;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseGuidN,The following statement contains a magic number: if (text.Length < 32)              {                  value = default;                  bytesConsumed = 0;                  return false;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseGuidN,The following statement contains a magic number: if (!TryParseUInt32X(text.Slice(0' 8)' out uint i1' out justConsumed) || justConsumed != 8)              {                  value = default;                  bytesConsumed = 0;                  return false; // 8 digits              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseGuidN,The following statement contains a magic number: if (!TryParseUInt32X(text.Slice(0' 8)' out uint i1' out justConsumed) || justConsumed != 8)              {                  value = default;                  bytesConsumed = 0;                  return false; // 8 digits              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseGuidN,The following statement contains a magic number: if (!TryParseUInt16X(text.Slice(8' 4)' out ushort i2' out justConsumed) || justConsumed != 4)              {                  value = default;                  bytesConsumed = 0;                  return false; // next 4 digits              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseGuidN,The following statement contains a magic number: if (!TryParseUInt16X(text.Slice(8' 4)' out ushort i2' out justConsumed) || justConsumed != 4)              {                  value = default;                  bytesConsumed = 0;                  return false; // next 4 digits              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseGuidN,The following statement contains a magic number: if (!TryParseUInt16X(text.Slice(8' 4)' out ushort i2' out justConsumed) || justConsumed != 4)              {                  value = default;                  bytesConsumed = 0;                  return false; // next 4 digits              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseGuidN,The following statement contains a magic number: if (!TryParseUInt16X(text.Slice(12' 4)' out ushort i3' out justConsumed) || justConsumed != 4)              {                  value = default;                  bytesConsumed = 0;                  return false; // next 4 digits              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseGuidN,The following statement contains a magic number: if (!TryParseUInt16X(text.Slice(12' 4)' out ushort i3' out justConsumed) || justConsumed != 4)              {                  value = default;                  bytesConsumed = 0;                  return false; // next 4 digits              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseGuidN,The following statement contains a magic number: if (!TryParseUInt16X(text.Slice(12' 4)' out ushort i3' out justConsumed) || justConsumed != 4)              {                  value = default;                  bytesConsumed = 0;                  return false; // next 4 digits              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseGuidN,The following statement contains a magic number: if (!TryParseUInt16X(text.Slice(16' 4)' out ushort i4' out justConsumed) || justConsumed != 4)              {                  value = default;                  bytesConsumed = 0;                  return false; // next 4 digits              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseGuidN,The following statement contains a magic number: if (!TryParseUInt16X(text.Slice(16' 4)' out ushort i4' out justConsumed) || justConsumed != 4)              {                  value = default;                  bytesConsumed = 0;                  return false; // next 4 digits              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseGuidN,The following statement contains a magic number: if (!TryParseUInt16X(text.Slice(16' 4)' out ushort i4' out justConsumed) || justConsumed != 4)              {                  value = default;                  bytesConsumed = 0;                  return false; // next 4 digits              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseGuidN,The following statement contains a magic number: if (!TryParseUInt64X(text.Slice(20)' out ulong i5' out justConsumed) || justConsumed != 12)              {                  value = default;                  bytesConsumed = 0;                  return false; // next 4 digits              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseGuidN,The following statement contains a magic number: if (!TryParseUInt64X(text.Slice(20)' out ulong i5' out justConsumed) || justConsumed != 12)              {                  value = default;                  bytesConsumed = 0;                  return false; // next 4 digits              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseGuidN,The following statement contains a magic number: bytesConsumed = 32;
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseGuidN,The following statement contains a magic number: value = new Guid((int)i1' (short)i2' (short)i3' (byte)(i4 >> 8)' (byte)i4'                  (byte)(i5 >> 40)' (byte)(i5 >> 32)' (byte)(i5 >> 24)' (byte)(i5 >> 16)' (byte)(i5 >> 8)' (byte)i5);
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseGuidN,The following statement contains a magic number: value = new Guid((int)i1' (short)i2' (short)i3' (byte)(i4 >> 8)' (byte)i4'                  (byte)(i5 >> 40)' (byte)(i5 >> 32)' (byte)(i5 >> 24)' (byte)(i5 >> 16)' (byte)(i5 >> 8)' (byte)i5);
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseGuidN,The following statement contains a magic number: value = new Guid((int)i1' (short)i2' (short)i3' (byte)(i4 >> 8)' (byte)i4'                  (byte)(i5 >> 40)' (byte)(i5 >> 32)' (byte)(i5 >> 24)' (byte)(i5 >> 16)' (byte)(i5 >> 8)' (byte)i5);
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseGuidN,The following statement contains a magic number: value = new Guid((int)i1' (short)i2' (short)i3' (byte)(i4 >> 8)' (byte)i4'                  (byte)(i5 >> 40)' (byte)(i5 >> 32)' (byte)(i5 >> 24)' (byte)(i5 >> 16)' (byte)(i5 >> 8)' (byte)i5);
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseGuidN,The following statement contains a magic number: value = new Guid((int)i1' (short)i2' (short)i3' (byte)(i4 >> 8)' (byte)i4'                  (byte)(i5 >> 40)' (byte)(i5 >> 32)' (byte)(i5 >> 24)' (byte)(i5 >> 16)' (byte)(i5 >> 8)' (byte)i5);
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseGuidN,The following statement contains a magic number: value = new Guid((int)i1' (short)i2' (short)i3' (byte)(i4 >> 8)' (byte)i4'                  (byte)(i5 >> 40)' (byte)(i5 >> 32)' (byte)(i5 >> 24)' (byte)(i5 >> 16)' (byte)(i5 >> 8)' (byte)i5);
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseGuidCore,The following statement contains a magic number: int expectedCodingUnits = 36 + (ends ? 2 : 0);
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseGuidCore,The following statement contains a magic number: int expectedCodingUnits = 36 + (ends ? 2 : 0);
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseGuidCore,The following statement contains a magic number: if (justConsumed != 8)              {                  value = default;                  bytesConsumed = 0;                  return false; // 8 digits              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseGuidCore,The following statement contains a magic number: text = text.Slice(9);
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseGuidCore,The following statement contains a magic number: if (justConsumed != 4)              {                  value = default;                  bytesConsumed = 0;                  return false; // 4 digits              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseGuidCore,The following statement contains a magic number: text = text.Slice(5);
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseGuidCore,The following statement contains a magic number: if (justConsumed != 4)              {                  value = default;                  bytesConsumed = 0;                  return false; // 4 digits              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseGuidCore,The following statement contains a magic number: text = text.Slice(5);
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseGuidCore,The following statement contains a magic number: if (justConsumed != 4)              {                  value = default;                  bytesConsumed = 0;                  return false; // 4 digits              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseGuidCore,The following statement contains a magic number: text = text.Slice(5);
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseGuidCore,The following statement contains a magic number: if (justConsumed != 12)              {                  value = default;                  bytesConsumed = 0;                  return false; // 12 digits              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseGuidCore,The following statement contains a magic number: value = new Guid((int)i1' (short)i2' (short)i3' (byte)(i4 >> 8)' (byte)i4'                  (byte)(i5 >> 40)' (byte)(i5 >> 32)' (byte)(i5 >> 24)' (byte)(i5 >> 16)' (byte)(i5 >> 8)' (byte)i5);
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseGuidCore,The following statement contains a magic number: value = new Guid((int)i1' (short)i2' (short)i3' (byte)(i4 >> 8)' (byte)i4'                  (byte)(i5 >> 40)' (byte)(i5 >> 32)' (byte)(i5 >> 24)' (byte)(i5 >> 16)' (byte)(i5 >> 8)' (byte)i5);
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseGuidCore,The following statement contains a magic number: value = new Guid((int)i1' (short)i2' (short)i3' (byte)(i4 >> 8)' (byte)i4'                  (byte)(i5 >> 40)' (byte)(i5 >> 32)' (byte)(i5 >> 24)' (byte)(i5 >> 16)' (byte)(i5 >> 8)' (byte)i5);
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseGuidCore,The following statement contains a magic number: value = new Guid((int)i1' (short)i2' (short)i3' (byte)(i4 >> 8)' (byte)i4'                  (byte)(i5 >> 40)' (byte)(i5 >> 32)' (byte)(i5 >> 24)' (byte)(i5 >> 16)' (byte)(i5 >> 8)' (byte)i5);
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseGuidCore,The following statement contains a magic number: value = new Guid((int)i1' (short)i2' (short)i3' (byte)(i4 >> 8)' (byte)i4'                  (byte)(i5 >> 40)' (byte)(i5 >> 32)' (byte)(i5 >> 24)' (byte)(i5 >> 16)' (byte)(i5 >> 8)' (byte)i5);
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseGuidCore,The following statement contains a magic number: value = new Guid((int)i1' (short)i2' (short)i3' (byte)(i4 >> 8)' (byte)i4'                  (byte)(i5 >> 40)' (byte)(i5 >> 32)' (byte)(i5 >> 24)' (byte)(i5 >> 16)' (byte)(i5 >> 8)' (byte)i5);
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseSByteD,The following statement contains a magic number: if (ParserHelpers.IsDigit(num))              {                  if (num == '0')                  {                      do                      {                          index++;                          if ((uint)index >= (uint)text.Length)                              goto Done;                          num = text[index];                      } while (num == '0');                      if (!ParserHelpers.IsDigit(num))                          goto Done;                  }                    answer = num - '0';                  index++;                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    // Potential overflow                  if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = answer * 10 + num - '0';                  // if sign < 0' (-1 * sign + 1) / 2 = 1                  // else' (-1 * sign + 1) / 2 = 0                  if ((uint)answer > (uint)sbyte.MaxValue + (-1 * sign + 1) / 2)                      goto FalseExit; // Overflow                    if ((uint)index >= (uint)text.Length)                      goto Done;                  if (!ParserHelpers.IsDigit(text[index]))                      goto Done;                    // Guaranteed overflow                  goto FalseExit;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseSByteD,The following statement contains a magic number: if (ParserHelpers.IsDigit(num))              {                  if (num == '0')                  {                      do                      {                          index++;                          if ((uint)index >= (uint)text.Length)                              goto Done;                          num = text[index];                      } while (num == '0');                      if (!ParserHelpers.IsDigit(num))                          goto Done;                  }                    answer = num - '0';                  index++;                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    // Potential overflow                  if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = answer * 10 + num - '0';                  // if sign < 0' (-1 * sign + 1) / 2 = 1                  // else' (-1 * sign + 1) / 2 = 0                  if ((uint)answer > (uint)sbyte.MaxValue + (-1 * sign + 1) / 2)                      goto FalseExit; // Overflow                    if ((uint)index >= (uint)text.Length)                      goto Done;                  if (!ParserHelpers.IsDigit(text[index]))                      goto Done;                    // Guaranteed overflow                  goto FalseExit;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseSByteD,The following statement contains a magic number: if (ParserHelpers.IsDigit(num))              {                  if (num == '0')                  {                      do                      {                          index++;                          if ((uint)index >= (uint)text.Length)                              goto Done;                          num = text[index];                      } while (num == '0');                      if (!ParserHelpers.IsDigit(num))                          goto Done;                  }                    answer = num - '0';                  index++;                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    // Potential overflow                  if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = answer * 10 + num - '0';                  // if sign < 0' (-1 * sign + 1) / 2 = 1                  // else' (-1 * sign + 1) / 2 = 0                  if ((uint)answer > (uint)sbyte.MaxValue + (-1 * sign + 1) / 2)                      goto FalseExit; // Overflow                    if ((uint)index >= (uint)text.Length)                      goto Done;                  if (!ParserHelpers.IsDigit(text[index]))                      goto Done;                    // Guaranteed overflow                  goto FalseExit;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseInt16D,The following statement contains a magic number: if (ParserHelpers.IsDigit(num))              {                  if (num == '0')                  {                      do                      {                          index++;                          if ((uint)index >= (uint)text.Length)                              goto Done;                          num = text[index];                      } while (num == '0');                      if (!ParserHelpers.IsDigit(num))                          goto Done;                  }                    answer = num - '0';                  index++;                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    // Potential overflow                  if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = answer * 10 + num - '0';                  // if sign < 0' (-1 * sign + 1) / 2 = 1                  // else' (-1 * sign + 1) / 2 = 0                  if ((uint)answer > (uint)short.MaxValue + (-1 * sign + 1) / 2)                      goto FalseExit; // Overflow                    if ((uint)index >= (uint)text.Length)                      goto Done;                  if (!ParserHelpers.IsDigit(text[index]))                      goto Done;                    // Guaranteed overflow                  goto FalseExit;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseInt16D,The following statement contains a magic number: if (ParserHelpers.IsDigit(num))              {                  if (num == '0')                  {                      do                      {                          index++;                          if ((uint)index >= (uint)text.Length)                              goto Done;                          num = text[index];                      } while (num == '0');                      if (!ParserHelpers.IsDigit(num))                          goto Done;                  }                    answer = num - '0';                  index++;                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    // Potential overflow                  if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = answer * 10 + num - '0';                  // if sign < 0' (-1 * sign + 1) / 2 = 1                  // else' (-1 * sign + 1) / 2 = 0                  if ((uint)answer > (uint)short.MaxValue + (-1 * sign + 1) / 2)                      goto FalseExit; // Overflow                    if ((uint)index >= (uint)text.Length)                      goto Done;                  if (!ParserHelpers.IsDigit(text[index]))                      goto Done;                    // Guaranteed overflow                  goto FalseExit;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseInt16D,The following statement contains a magic number: if (ParserHelpers.IsDigit(num))              {                  if (num == '0')                  {                      do                      {                          index++;                          if ((uint)index >= (uint)text.Length)                              goto Done;                          num = text[index];                      } while (num == '0');                      if (!ParserHelpers.IsDigit(num))                          goto Done;                  }                    answer = num - '0';                  index++;                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    // Potential overflow                  if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = answer * 10 + num - '0';                  // if sign < 0' (-1 * sign + 1) / 2 = 1                  // else' (-1 * sign + 1) / 2 = 0                  if ((uint)answer > (uint)short.MaxValue + (-1 * sign + 1) / 2)                      goto FalseExit; // Overflow                    if ((uint)index >= (uint)text.Length)                      goto Done;                  if (!ParserHelpers.IsDigit(text[index]))                      goto Done;                    // Guaranteed overflow                  goto FalseExit;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseInt16D,The following statement contains a magic number: if (ParserHelpers.IsDigit(num))              {                  if (num == '0')                  {                      do                      {                          index++;                          if ((uint)index >= (uint)text.Length)                              goto Done;                          num = text[index];                      } while (num == '0');                      if (!ParserHelpers.IsDigit(num))                          goto Done;                  }                    answer = num - '0';                  index++;                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    // Potential overflow                  if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = answer * 10 + num - '0';                  // if sign < 0' (-1 * sign + 1) / 2 = 1                  // else' (-1 * sign + 1) / 2 = 0                  if ((uint)answer > (uint)short.MaxValue + (-1 * sign + 1) / 2)                      goto FalseExit; // Overflow                    if ((uint)index >= (uint)text.Length)                      goto Done;                  if (!ParserHelpers.IsDigit(text[index]))                      goto Done;                    // Guaranteed overflow                  goto FalseExit;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseInt16D,The following statement contains a magic number: if (ParserHelpers.IsDigit(num))              {                  if (num == '0')                  {                      do                      {                          index++;                          if ((uint)index >= (uint)text.Length)                              goto Done;                          num = text[index];                      } while (num == '0');                      if (!ParserHelpers.IsDigit(num))                          goto Done;                  }                    answer = num - '0';                  index++;                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    // Potential overflow                  if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = answer * 10 + num - '0';                  // if sign < 0' (-1 * sign + 1) / 2 = 1                  // else' (-1 * sign + 1) / 2 = 0                  if ((uint)answer > (uint)short.MaxValue + (-1 * sign + 1) / 2)                      goto FalseExit; // Overflow                    if ((uint)index >= (uint)text.Length)                      goto Done;                  if (!ParserHelpers.IsDigit(text[index]))                      goto Done;                    // Guaranteed overflow                  goto FalseExit;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseInt32D,The following statement contains a magic number: if (ParserHelpers.IsDigit(num))              {                  if (num == '0')                  {                      do                      {                          index++;                          if ((uint)index >= (uint)text.Length)                              goto Done;                          num = text[index];                      } while (num == '0');                      if (!ParserHelpers.IsDigit(num))                          goto Done;                  }                    answer = num - '0';                  index++;                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    // Potential overflow                  if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  if (answer > int.MaxValue / 10)                      goto FalseExit; // Overflow                  answer = answer * 10 + num - '0';                  // if sign < 0' (-1 * sign + 1) / 2 = 1                  // else' (-1 * sign + 1) / 2 = 0                  if ((uint)answer > (uint)int.MaxValue + (-1 * sign + 1) / 2)                      goto FalseExit; // Overflow                    if ((uint)index >= (uint)text.Length)                      goto Done;                  if (!ParserHelpers.IsDigit(text[index]))                      goto Done;                    // Guaranteed overflow                  goto FalseExit;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseInt32D,The following statement contains a magic number: if (ParserHelpers.IsDigit(num))              {                  if (num == '0')                  {                      do                      {                          index++;                          if ((uint)index >= (uint)text.Length)                              goto Done;                          num = text[index];                      } while (num == '0');                      if (!ParserHelpers.IsDigit(num))                          goto Done;                  }                    answer = num - '0';                  index++;                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    // Potential overflow                  if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  if (answer > int.MaxValue / 10)                      goto FalseExit; // Overflow                  answer = answer * 10 + num - '0';                  // if sign < 0' (-1 * sign + 1) / 2 = 1                  // else' (-1 * sign + 1) / 2 = 0                  if ((uint)answer > (uint)int.MaxValue + (-1 * sign + 1) / 2)                      goto FalseExit; // Overflow                    if ((uint)index >= (uint)text.Length)                      goto Done;                  if (!ParserHelpers.IsDigit(text[index]))                      goto Done;                    // Guaranteed overflow                  goto FalseExit;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseInt32D,The following statement contains a magic number: if (ParserHelpers.IsDigit(num))              {                  if (num == '0')                  {                      do                      {                          index++;                          if ((uint)index >= (uint)text.Length)                              goto Done;                          num = text[index];                      } while (num == '0');                      if (!ParserHelpers.IsDigit(num))                          goto Done;                  }                    answer = num - '0';                  index++;                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    // Potential overflow                  if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  if (answer > int.MaxValue / 10)                      goto FalseExit; // Overflow                  answer = answer * 10 + num - '0';                  // if sign < 0' (-1 * sign + 1) / 2 = 1                  // else' (-1 * sign + 1) / 2 = 0                  if ((uint)answer > (uint)int.MaxValue + (-1 * sign + 1) / 2)                      goto FalseExit; // Overflow                    if ((uint)index >= (uint)text.Length)                      goto Done;                  if (!ParserHelpers.IsDigit(text[index]))                      goto Done;                    // Guaranteed overflow                  goto FalseExit;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseInt32D,The following statement contains a magic number: if (ParserHelpers.IsDigit(num))              {                  if (num == '0')                  {                      do                      {                          index++;                          if ((uint)index >= (uint)text.Length)                              goto Done;                          num = text[index];                      } while (num == '0');                      if (!ParserHelpers.IsDigit(num))                          goto Done;                  }                    answer = num - '0';                  index++;                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    // Potential overflow                  if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  if (answer > int.MaxValue / 10)                      goto FalseExit; // Overflow                  answer = answer * 10 + num - '0';                  // if sign < 0' (-1 * sign + 1) / 2 = 1                  // else' (-1 * sign + 1) / 2 = 0                  if ((uint)answer > (uint)int.MaxValue + (-1 * sign + 1) / 2)                      goto FalseExit; // Overflow                    if ((uint)index >= (uint)text.Length)                      goto Done;                  if (!ParserHelpers.IsDigit(text[index]))                      goto Done;                    // Guaranteed overflow                  goto FalseExit;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseInt32D,The following statement contains a magic number: if (ParserHelpers.IsDigit(num))              {                  if (num == '0')                  {                      do                      {                          index++;                          if ((uint)index >= (uint)text.Length)                              goto Done;                          num = text[index];                      } while (num == '0');                      if (!ParserHelpers.IsDigit(num))                          goto Done;                  }                    answer = num - '0';                  index++;                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    // Potential overflow                  if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  if (answer > int.MaxValue / 10)                      goto FalseExit; // Overflow                  answer = answer * 10 + num - '0';                  // if sign < 0' (-1 * sign + 1) / 2 = 1                  // else' (-1 * sign + 1) / 2 = 0                  if ((uint)answer > (uint)int.MaxValue + (-1 * sign + 1) / 2)                      goto FalseExit; // Overflow                    if ((uint)index >= (uint)text.Length)                      goto Done;                  if (!ParserHelpers.IsDigit(text[index]))                      goto Done;                    // Guaranteed overflow                  goto FalseExit;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseInt32D,The following statement contains a magic number: if (ParserHelpers.IsDigit(num))              {                  if (num == '0')                  {                      do                      {                          index++;                          if ((uint)index >= (uint)text.Length)                              goto Done;                          num = text[index];                      } while (num == '0');                      if (!ParserHelpers.IsDigit(num))                          goto Done;                  }                    answer = num - '0';                  index++;                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    // Potential overflow                  if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  if (answer > int.MaxValue / 10)                      goto FalseExit; // Overflow                  answer = answer * 10 + num - '0';                  // if sign < 0' (-1 * sign + 1) / 2 = 1                  // else' (-1 * sign + 1) / 2 = 0                  if ((uint)answer > (uint)int.MaxValue + (-1 * sign + 1) / 2)                      goto FalseExit; // Overflow                    if ((uint)index >= (uint)text.Length)                      goto Done;                  if (!ParserHelpers.IsDigit(text[index]))                      goto Done;                    // Guaranteed overflow                  goto FalseExit;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseInt32D,The following statement contains a magic number: if (ParserHelpers.IsDigit(num))              {                  if (num == '0')                  {                      do                      {                          index++;                          if ((uint)index >= (uint)text.Length)                              goto Done;                          num = text[index];                      } while (num == '0');                      if (!ParserHelpers.IsDigit(num))                          goto Done;                  }                    answer = num - '0';                  index++;                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    // Potential overflow                  if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  if (answer > int.MaxValue / 10)                      goto FalseExit; // Overflow                  answer = answer * 10 + num - '0';                  // if sign < 0' (-1 * sign + 1) / 2 = 1                  // else' (-1 * sign + 1) / 2 = 0                  if ((uint)answer > (uint)int.MaxValue + (-1 * sign + 1) / 2)                      goto FalseExit; // Overflow                    if ((uint)index >= (uint)text.Length)                      goto Done;                  if (!ParserHelpers.IsDigit(text[index]))                      goto Done;                    // Guaranteed overflow                  goto FalseExit;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseInt32D,The following statement contains a magic number: if (ParserHelpers.IsDigit(num))              {                  if (num == '0')                  {                      do                      {                          index++;                          if ((uint)index >= (uint)text.Length)                              goto Done;                          num = text[index];                      } while (num == '0');                      if (!ParserHelpers.IsDigit(num))                          goto Done;                  }                    answer = num - '0';                  index++;                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    // Potential overflow                  if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  if (answer > int.MaxValue / 10)                      goto FalseExit; // Overflow                  answer = answer * 10 + num - '0';                  // if sign < 0' (-1 * sign + 1) / 2 = 1                  // else' (-1 * sign + 1) / 2 = 0                  if ((uint)answer > (uint)int.MaxValue + (-1 * sign + 1) / 2)                      goto FalseExit; // Overflow                    if ((uint)index >= (uint)text.Length)                      goto Done;                  if (!ParserHelpers.IsDigit(text[index]))                      goto Done;                    // Guaranteed overflow                  goto FalseExit;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseInt32D,The following statement contains a magic number: if (ParserHelpers.IsDigit(num))              {                  if (num == '0')                  {                      do                      {                          index++;                          if ((uint)index >= (uint)text.Length)                              goto Done;                          num = text[index];                      } while (num == '0');                      if (!ParserHelpers.IsDigit(num))                          goto Done;                  }                    answer = num - '0';                  index++;                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    // Potential overflow                  if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  if (answer > int.MaxValue / 10)                      goto FalseExit; // Overflow                  answer = answer * 10 + num - '0';                  // if sign < 0' (-1 * sign + 1) / 2 = 1                  // else' (-1 * sign + 1) / 2 = 0                  if ((uint)answer > (uint)int.MaxValue + (-1 * sign + 1) / 2)                      goto FalseExit; // Overflow                    if ((uint)index >= (uint)text.Length)                      goto Done;                  if (!ParserHelpers.IsDigit(text[index]))                      goto Done;                    // Guaranteed overflow                  goto FalseExit;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseInt32D,The following statement contains a magic number: if (ParserHelpers.IsDigit(num))              {                  if (num == '0')                  {                      do                      {                          index++;                          if ((uint)index >= (uint)text.Length)                              goto Done;                          num = text[index];                      } while (num == '0');                      if (!ParserHelpers.IsDigit(num))                          goto Done;                  }                    answer = num - '0';                  index++;                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    // Potential overflow                  if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  if (answer > int.MaxValue / 10)                      goto FalseExit; // Overflow                  answer = answer * 10 + num - '0';                  // if sign < 0' (-1 * sign + 1) / 2 = 1                  // else' (-1 * sign + 1) / 2 = 0                  if ((uint)answer > (uint)int.MaxValue + (-1 * sign + 1) / 2)                      goto FalseExit; // Overflow                    if ((uint)index >= (uint)text.Length)                      goto Done;                  if (!ParserHelpers.IsDigit(text[index]))                      goto Done;                    // Guaranteed overflow                  goto FalseExit;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseInt32D,The following statement contains a magic number: if (ParserHelpers.IsDigit(num))              {                  if (num == '0')                  {                      do                      {                          index++;                          if ((uint)index >= (uint)text.Length)                              goto Done;                          num = text[index];                      } while (num == '0');                      if (!ParserHelpers.IsDigit(num))                          goto Done;                  }                    answer = num - '0';                  index++;                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    // Potential overflow                  if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  if (answer > int.MaxValue / 10)                      goto FalseExit; // Overflow                  answer = answer * 10 + num - '0';                  // if sign < 0' (-1 * sign + 1) / 2 = 1                  // else' (-1 * sign + 1) / 2 = 0                  if ((uint)answer > (uint)int.MaxValue + (-1 * sign + 1) / 2)                      goto FalseExit; // Overflow                    if ((uint)index >= (uint)text.Length)                      goto Done;                  if (!ParserHelpers.IsDigit(text[index]))                      goto Done;                    // Guaranteed overflow                  goto FalseExit;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseInt64D,The following statement contains a magic number: long firstDigit = text[indexOfFirstDigit] - 48;
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseInt64D,The following statement contains a magic number: if (firstDigit < 0 || firstDigit > 9)              {                  bytesConsumed = 0;                  value = default;                  return false;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseInt64D,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          bytesConsumed = index;                          value = ((long)parsedValue) * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + (ulong)nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          bytesConsumed = index;                          value = ((long)parsedValue) * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + (ulong)nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          bytesConsumed = index;                          value = ((long)parsedValue) * sign;                          return true;                      }                      // If parsedValue > (long.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (long.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > long.MaxValue / 10 || parsedValue == long.MaxValue / 10 && nextDigitTooLarge)                      {                          bytesConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + (ulong)nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseInt64D,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          bytesConsumed = index;                          value = ((long)parsedValue) * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + (ulong)nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          bytesConsumed = index;                          value = ((long)parsedValue) * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + (ulong)nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          bytesConsumed = index;                          value = ((long)parsedValue) * sign;                          return true;                      }                      // If parsedValue > (long.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (long.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > long.MaxValue / 10 || parsedValue == long.MaxValue / 10 && nextDigitTooLarge)                      {                          bytesConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + (ulong)nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseInt64D,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          bytesConsumed = index;                          value = ((long)parsedValue) * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + (ulong)nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          bytesConsumed = index;                          value = ((long)parsedValue) * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + (ulong)nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          bytesConsumed = index;                          value = ((long)parsedValue) * sign;                          return true;                      }                      // If parsedValue > (long.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (long.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > long.MaxValue / 10 || parsedValue == long.MaxValue / 10 && nextDigitTooLarge)                      {                          bytesConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + (ulong)nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseInt64D,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          bytesConsumed = index;                          value = ((long)parsedValue) * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + (ulong)nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          bytesConsumed = index;                          value = ((long)parsedValue) * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + (ulong)nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          bytesConsumed = index;                          value = ((long)parsedValue) * sign;                          return true;                      }                      // If parsedValue > (long.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (long.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > long.MaxValue / 10 || parsedValue == long.MaxValue / 10 && nextDigitTooLarge)                      {                          bytesConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + (ulong)nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseInt64D,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          bytesConsumed = index;                          value = ((long)parsedValue) * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + (ulong)nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          bytesConsumed = index;                          value = ((long)parsedValue) * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + (ulong)nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          bytesConsumed = index;                          value = ((long)parsedValue) * sign;                          return true;                      }                      // If parsedValue > (long.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (long.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > long.MaxValue / 10 || parsedValue == long.MaxValue / 10 && nextDigitTooLarge)                      {                          bytesConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + (ulong)nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseInt64D,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          bytesConsumed = index;                          value = ((long)parsedValue) * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + (ulong)nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          bytesConsumed = index;                          value = ((long)parsedValue) * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + (ulong)nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          bytesConsumed = index;                          value = ((long)parsedValue) * sign;                          return true;                      }                      // If parsedValue > (long.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (long.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > long.MaxValue / 10 || parsedValue == long.MaxValue / 10 && nextDigitTooLarge)                      {                          bytesConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + (ulong)nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseInt64D,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          bytesConsumed = index;                          value = ((long)parsedValue) * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + (ulong)nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          bytesConsumed = index;                          value = ((long)parsedValue) * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + (ulong)nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          bytesConsumed = index;                          value = ((long)parsedValue) * sign;                          return true;                      }                      // If parsedValue > (long.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (long.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > long.MaxValue / 10 || parsedValue == long.MaxValue / 10 && nextDigitTooLarge)                      {                          bytesConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + (ulong)nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseInt64D,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          bytesConsumed = index;                          value = ((long)parsedValue) * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + (ulong)nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          bytesConsumed = index;                          value = ((long)parsedValue) * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + (ulong)nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          bytesConsumed = index;                          value = ((long)parsedValue) * sign;                          return true;                      }                      // If parsedValue > (long.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (long.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > long.MaxValue / 10 || parsedValue == long.MaxValue / 10 && nextDigitTooLarge)                      {                          bytesConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + (ulong)nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseInt64D,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          bytesConsumed = index;                          value = ((long)parsedValue) * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + (ulong)nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          bytesConsumed = index;                          value = ((long)parsedValue) * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + (ulong)nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          bytesConsumed = index;                          value = ((long)parsedValue) * sign;                          return true;                      }                      // If parsedValue > (long.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (long.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > long.MaxValue / 10 || parsedValue == long.MaxValue / 10 && nextDigitTooLarge)                      {                          bytesConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + (ulong)nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseInt64D,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          bytesConsumed = index;                          value = ((long)parsedValue) * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + (ulong)nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          bytesConsumed = index;                          value = ((long)parsedValue) * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + (ulong)nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          bytesConsumed = index;                          value = ((long)parsedValue) * sign;                          return true;                      }                      // If parsedValue > (long.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (long.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > long.MaxValue / 10 || parsedValue == long.MaxValue / 10 && nextDigitTooLarge)                      {                          bytesConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + (ulong)nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseInt64D,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          bytesConsumed = index;                          value = ((long)parsedValue) * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + (ulong)nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          bytesConsumed = index;                          value = ((long)parsedValue) * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + (ulong)nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          bytesConsumed = index;                          value = ((long)parsedValue) * sign;                          return true;                      }                      // If parsedValue > (long.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (long.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > long.MaxValue / 10 || parsedValue == long.MaxValue / 10 && nextDigitTooLarge)                      {                          bytesConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + (ulong)nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseInt64D,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          bytesConsumed = index;                          value = ((long)parsedValue) * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + (ulong)nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          bytesConsumed = index;                          value = ((long)parsedValue) * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + (ulong)nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          bytesConsumed = index;                          value = ((long)parsedValue) * sign;                          return true;                      }                      // If parsedValue > (long.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (long.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > long.MaxValue / 10 || parsedValue == long.MaxValue / 10 && nextDigitTooLarge)                      {                          bytesConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + (ulong)nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseInt64D,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          bytesConsumed = index;                          value = ((long)parsedValue) * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + (ulong)nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          bytesConsumed = index;                          value = ((long)parsedValue) * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + (ulong)nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          bytesConsumed = index;                          value = ((long)parsedValue) * sign;                          return true;                      }                      // If parsedValue > (long.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (long.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > long.MaxValue / 10 || parsedValue == long.MaxValue / 10 && nextDigitTooLarge)                      {                          bytesConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + (ulong)nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseByteD,The following statement contains a magic number: if (ParserHelpers.IsDigit(num))              {                  if (num == '0')                  {                      do                      {                          index++;                          if ((uint)index >= (uint)text.Length)                              goto Done;                          num = text[index];                      } while (num == '0');                      if (!ParserHelpers.IsDigit(num))                          goto Done;                  }                    answer = num - '0';                  index++;                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    // Potential overflow                  if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = answer * 10 + num - '0';                  if ((uint)answer > byte.MaxValue)                      goto FalseExit; // Overflow                    if ((uint)index >= (uint)text.Length)                      goto Done;                  if (!ParserHelpers.IsDigit(text[index]))                      goto Done;                    // Guaranteed overflow                  goto FalseExit;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseByteD,The following statement contains a magic number: if (ParserHelpers.IsDigit(num))              {                  if (num == '0')                  {                      do                      {                          index++;                          if ((uint)index >= (uint)text.Length)                              goto Done;                          num = text[index];                      } while (num == '0');                      if (!ParserHelpers.IsDigit(num))                          goto Done;                  }                    answer = num - '0';                  index++;                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    // Potential overflow                  if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = answer * 10 + num - '0';                  if ((uint)answer > byte.MaxValue)                      goto FalseExit; // Overflow                    if ((uint)index >= (uint)text.Length)                      goto Done;                  if (!ParserHelpers.IsDigit(text[index]))                      goto Done;                    // Guaranteed overflow                  goto FalseExit;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseUInt16D,The following statement contains a magic number: if (ParserHelpers.IsDigit(num))              {                  if (num == '0')                  {                      do                      {                          index++;                          if ((uint)index >= (uint)text.Length)                              goto Done;                          num = text[index];                      } while (num == '0');                      if (!ParserHelpers.IsDigit(num))                          goto Done;                  }                    answer = num - '0';                  index++;                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    // Potential overflow                  if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = answer * 10 + num - '0';                  if ((uint)answer > ushort.MaxValue)                      goto FalseExit; // Overflow                    if ((uint)index >= (uint)text.Length)                      goto Done;                  if (!ParserHelpers.IsDigit(text[index]))                      goto Done;                    // Guaranteed overflow                  goto FalseExit;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseUInt16D,The following statement contains a magic number: if (ParserHelpers.IsDigit(num))              {                  if (num == '0')                  {                      do                      {                          index++;                          if ((uint)index >= (uint)text.Length)                              goto Done;                          num = text[index];                      } while (num == '0');                      if (!ParserHelpers.IsDigit(num))                          goto Done;                  }                    answer = num - '0';                  index++;                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    // Potential overflow                  if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = answer * 10 + num - '0';                  if ((uint)answer > ushort.MaxValue)                      goto FalseExit; // Overflow                    if ((uint)index >= (uint)text.Length)                      goto Done;                  if (!ParserHelpers.IsDigit(text[index]))                      goto Done;                    // Guaranteed overflow                  goto FalseExit;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseUInt16D,The following statement contains a magic number: if (ParserHelpers.IsDigit(num))              {                  if (num == '0')                  {                      do                      {                          index++;                          if ((uint)index >= (uint)text.Length)                              goto Done;                          num = text[index];                      } while (num == '0');                      if (!ParserHelpers.IsDigit(num))                          goto Done;                  }                    answer = num - '0';                  index++;                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    // Potential overflow                  if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = answer * 10 + num - '0';                  if ((uint)answer > ushort.MaxValue)                      goto FalseExit; // Overflow                    if ((uint)index >= (uint)text.Length)                      goto Done;                  if (!ParserHelpers.IsDigit(text[index]))                      goto Done;                    // Guaranteed overflow                  goto FalseExit;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseUInt16D,The following statement contains a magic number: if (ParserHelpers.IsDigit(num))              {                  if (num == '0')                  {                      do                      {                          index++;                          if ((uint)index >= (uint)text.Length)                              goto Done;                          num = text[index];                      } while (num == '0');                      if (!ParserHelpers.IsDigit(num))                          goto Done;                  }                    answer = num - '0';                  index++;                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    // Potential overflow                  if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = answer * 10 + num - '0';                  if ((uint)answer > ushort.MaxValue)                      goto FalseExit; // Overflow                    if ((uint)index >= (uint)text.Length)                      goto Done;                  if (!ParserHelpers.IsDigit(text[index]))                      goto Done;                    // Guaranteed overflow                  goto FalseExit;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseUInt32D,The following statement contains a magic number: if (ParserHelpers.IsDigit(num))              {                  if (num == '0')                  {                      do                      {                          index++;                          if ((uint)index >= (uint)text.Length)                              goto Done;                          num = text[index];                      } while (num == '0');                      if (!ParserHelpers.IsDigit(num))                          goto Done;                  }                    answer = num - '0';                  index++;                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    // Potential overflow                  if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  if (((uint)answer) > uint.MaxValue / 10 || (((uint)answer) == uint.MaxValue / 10 && num > '5'))                      goto FalseExit; // Overflow                  answer = answer * 10 + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  if (!ParserHelpers.IsDigit(text[index]))                      goto Done;                    // Guaranteed overflow                  goto FalseExit;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseUInt32D,The following statement contains a magic number: if (ParserHelpers.IsDigit(num))              {                  if (num == '0')                  {                      do                      {                          index++;                          if ((uint)index >= (uint)text.Length)                              goto Done;                          num = text[index];                      } while (num == '0');                      if (!ParserHelpers.IsDigit(num))                          goto Done;                  }                    answer = num - '0';                  index++;                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    // Potential overflow                  if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  if (((uint)answer) > uint.MaxValue / 10 || (((uint)answer) == uint.MaxValue / 10 && num > '5'))                      goto FalseExit; // Overflow                  answer = answer * 10 + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  if (!ParserHelpers.IsDigit(text[index]))                      goto Done;                    // Guaranteed overflow                  goto FalseExit;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseUInt32D,The following statement contains a magic number: if (ParserHelpers.IsDigit(num))              {                  if (num == '0')                  {                      do                      {                          index++;                          if ((uint)index >= (uint)text.Length)                              goto Done;                          num = text[index];                      } while (num == '0');                      if (!ParserHelpers.IsDigit(num))                          goto Done;                  }                    answer = num - '0';                  index++;                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    // Potential overflow                  if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  if (((uint)answer) > uint.MaxValue / 10 || (((uint)answer) == uint.MaxValue / 10 && num > '5'))                      goto FalseExit; // Overflow                  answer = answer * 10 + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  if (!ParserHelpers.IsDigit(text[index]))                      goto Done;                    // Guaranteed overflow                  goto FalseExit;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseUInt32D,The following statement contains a magic number: if (ParserHelpers.IsDigit(num))              {                  if (num == '0')                  {                      do                      {                          index++;                          if ((uint)index >= (uint)text.Length)                              goto Done;                          num = text[index];                      } while (num == '0');                      if (!ParserHelpers.IsDigit(num))                          goto Done;                  }                    answer = num - '0';                  index++;                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    // Potential overflow                  if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  if (((uint)answer) > uint.MaxValue / 10 || (((uint)answer) == uint.MaxValue / 10 && num > '5'))                      goto FalseExit; // Overflow                  answer = answer * 10 + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  if (!ParserHelpers.IsDigit(text[index]))                      goto Done;                    // Guaranteed overflow                  goto FalseExit;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseUInt32D,The following statement contains a magic number: if (ParserHelpers.IsDigit(num))              {                  if (num == '0')                  {                      do                      {                          index++;                          if ((uint)index >= (uint)text.Length)                              goto Done;                          num = text[index];                      } while (num == '0');                      if (!ParserHelpers.IsDigit(num))                          goto Done;                  }                    answer = num - '0';                  index++;                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    // Potential overflow                  if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  if (((uint)answer) > uint.MaxValue / 10 || (((uint)answer) == uint.MaxValue / 10 && num > '5'))                      goto FalseExit; // Overflow                  answer = answer * 10 + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  if (!ParserHelpers.IsDigit(text[index]))                      goto Done;                    // Guaranteed overflow                  goto FalseExit;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseUInt32D,The following statement contains a magic number: if (ParserHelpers.IsDigit(num))              {                  if (num == '0')                  {                      do                      {                          index++;                          if ((uint)index >= (uint)text.Length)                              goto Done;                          num = text[index];                      } while (num == '0');                      if (!ParserHelpers.IsDigit(num))                          goto Done;                  }                    answer = num - '0';                  index++;                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    // Potential overflow                  if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  if (((uint)answer) > uint.MaxValue / 10 || (((uint)answer) == uint.MaxValue / 10 && num > '5'))                      goto FalseExit; // Overflow                  answer = answer * 10 + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  if (!ParserHelpers.IsDigit(text[index]))                      goto Done;                    // Guaranteed overflow                  goto FalseExit;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseUInt32D,The following statement contains a magic number: if (ParserHelpers.IsDigit(num))              {                  if (num == '0')                  {                      do                      {                          index++;                          if ((uint)index >= (uint)text.Length)                              goto Done;                          num = text[index];                      } while (num == '0');                      if (!ParserHelpers.IsDigit(num))                          goto Done;                  }                    answer = num - '0';                  index++;                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    // Potential overflow                  if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  if (((uint)answer) > uint.MaxValue / 10 || (((uint)answer) == uint.MaxValue / 10 && num > '5'))                      goto FalseExit; // Overflow                  answer = answer * 10 + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  if (!ParserHelpers.IsDigit(text[index]))                      goto Done;                    // Guaranteed overflow                  goto FalseExit;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseUInt32D,The following statement contains a magic number: if (ParserHelpers.IsDigit(num))              {                  if (num == '0')                  {                      do                      {                          index++;                          if ((uint)index >= (uint)text.Length)                              goto Done;                          num = text[index];                      } while (num == '0');                      if (!ParserHelpers.IsDigit(num))                          goto Done;                  }                    answer = num - '0';                  index++;                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    // Potential overflow                  if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  if (((uint)answer) > uint.MaxValue / 10 || (((uint)answer) == uint.MaxValue / 10 && num > '5'))                      goto FalseExit; // Overflow                  answer = answer * 10 + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  if (!ParserHelpers.IsDigit(text[index]))                      goto Done;                    // Guaranteed overflow                  goto FalseExit;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseUInt32D,The following statement contains a magic number: if (ParserHelpers.IsDigit(num))              {                  if (num == '0')                  {                      do                      {                          index++;                          if ((uint)index >= (uint)text.Length)                              goto Done;                          num = text[index];                      } while (num == '0');                      if (!ParserHelpers.IsDigit(num))                          goto Done;                  }                    answer = num - '0';                  index++;                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    // Potential overflow                  if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  if (((uint)answer) > uint.MaxValue / 10 || (((uint)answer) == uint.MaxValue / 10 && num > '5'))                      goto FalseExit; // Overflow                  answer = answer * 10 + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  if (!ParserHelpers.IsDigit(text[index]))                      goto Done;                    // Guaranteed overflow                  goto FalseExit;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseUInt32D,The following statement contains a magic number: if (ParserHelpers.IsDigit(num))              {                  if (num == '0')                  {                      do                      {                          index++;                          if ((uint)index >= (uint)text.Length)                              goto Done;                          num = text[index];                      } while (num == '0');                      if (!ParserHelpers.IsDigit(num))                          goto Done;                  }                    answer = num - '0';                  index++;                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    // Potential overflow                  if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  if (((uint)answer) > uint.MaxValue / 10 || (((uint)answer) == uint.MaxValue / 10 && num > '5'))                      goto FalseExit; // Overflow                  answer = answer * 10 + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  if (!ParserHelpers.IsDigit(text[index]))                      goto Done;                    // Guaranteed overflow                  goto FalseExit;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseUInt32D,The following statement contains a magic number: if (ParserHelpers.IsDigit(num))              {                  if (num == '0')                  {                      do                      {                          index++;                          if ((uint)index >= (uint)text.Length)                              goto Done;                          num = text[index];                      } while (num == '0');                      if (!ParserHelpers.IsDigit(num))                          goto Done;                  }                    answer = num - '0';                  index++;                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  answer = 10 * answer + num - '0';                    // Potential overflow                  if ((uint)index >= (uint)text.Length)                      goto Done;                  num = text[index];                  if (!ParserHelpers.IsDigit(num))                      goto Done;                  index++;                  if (((uint)answer) > uint.MaxValue / 10 || (((uint)answer) == uint.MaxValue / 10 && num > '5'))                      goto FalseExit; // Overflow                  answer = answer * 10 + num - '0';                    if ((uint)index >= (uint)text.Length)                      goto Done;                  if (!ParserHelpers.IsDigit(text[index]))                      goto Done;                    // Guaranteed overflow                  goto FalseExit;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseUInt64D,The following statement contains a magic number: if (firstDigit > 9)              {                  bytesConsumed = 0;                  value = default;                  return false;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseUInt64D,The following statement contains a magic number: if (text.Length < ParserHelpers.Int64OverflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          bytesConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = 1; index < ParserHelpers.Int64OverflowLength - 1; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          bytesConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = ParserHelpers.Int64OverflowLength - 1; index < text.Length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          bytesConsumed = index;                          value = parsedValue;                          return true;                      }                      // If parsedValue > (ulong.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ulong.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ulong.MaxValue / 10 || (parsedValue == ulong.MaxValue / 10 && nextDigit > 5))                      {                          bytesConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseUInt64D,The following statement contains a magic number: if (text.Length < ParserHelpers.Int64OverflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          bytesConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = 1; index < ParserHelpers.Int64OverflowLength - 1; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          bytesConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = ParserHelpers.Int64OverflowLength - 1; index < text.Length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          bytesConsumed = index;                          value = parsedValue;                          return true;                      }                      // If parsedValue > (ulong.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ulong.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ulong.MaxValue / 10 || (parsedValue == ulong.MaxValue / 10 && nextDigit > 5))                      {                          bytesConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseUInt64D,The following statement contains a magic number: if (text.Length < ParserHelpers.Int64OverflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          bytesConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = 1; index < ParserHelpers.Int64OverflowLength - 1; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          bytesConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = ParserHelpers.Int64OverflowLength - 1; index < text.Length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          bytesConsumed = index;                          value = parsedValue;                          return true;                      }                      // If parsedValue > (ulong.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ulong.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ulong.MaxValue / 10 || (parsedValue == ulong.MaxValue / 10 && nextDigit > 5))                      {                          bytesConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseUInt64D,The following statement contains a magic number: if (text.Length < ParserHelpers.Int64OverflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          bytesConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = 1; index < ParserHelpers.Int64OverflowLength - 1; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          bytesConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = ParserHelpers.Int64OverflowLength - 1; index < text.Length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          bytesConsumed = index;                          value = parsedValue;                          return true;                      }                      // If parsedValue > (ulong.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ulong.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ulong.MaxValue / 10 || (parsedValue == ulong.MaxValue / 10 && nextDigit > 5))                      {                          bytesConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseUInt64D,The following statement contains a magic number: if (text.Length < ParserHelpers.Int64OverflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          bytesConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = 1; index < ParserHelpers.Int64OverflowLength - 1; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          bytesConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = ParserHelpers.Int64OverflowLength - 1; index < text.Length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          bytesConsumed = index;                          value = parsedValue;                          return true;                      }                      // If parsedValue > (ulong.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ulong.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ulong.MaxValue / 10 || (parsedValue == ulong.MaxValue / 10 && nextDigit > 5))                      {                          bytesConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseUInt64D,The following statement contains a magic number: if (text.Length < ParserHelpers.Int64OverflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          bytesConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = 1; index < ParserHelpers.Int64OverflowLength - 1; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          bytesConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = ParserHelpers.Int64OverflowLength - 1; index < text.Length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          bytesConsumed = index;                          value = parsedValue;                          return true;                      }                      // If parsedValue > (ulong.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ulong.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ulong.MaxValue / 10 || (parsedValue == ulong.MaxValue / 10 && nextDigit > 5))                      {                          bytesConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseUInt64D,The following statement contains a magic number: if (text.Length < ParserHelpers.Int64OverflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          bytesConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = 1; index < ParserHelpers.Int64OverflowLength - 1; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          bytesConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = ParserHelpers.Int64OverflowLength - 1; index < text.Length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          bytesConsumed = index;                          value = parsedValue;                          return true;                      }                      // If parsedValue > (ulong.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ulong.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ulong.MaxValue / 10 || (parsedValue == ulong.MaxValue / 10 && nextDigit > 5))                      {                          bytesConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseUInt64D,The following statement contains a magic number: if (text.Length < ParserHelpers.Int64OverflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          bytesConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = 1; index < ParserHelpers.Int64OverflowLength - 1; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          bytesConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = ParserHelpers.Int64OverflowLength - 1; index < text.Length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          bytesConsumed = index;                          value = parsedValue;                          return true;                      }                      // If parsedValue > (ulong.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ulong.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ulong.MaxValue / 10 || (parsedValue == ulong.MaxValue / 10 && nextDigit > 5))                      {                          bytesConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseUInt64D,The following statement contains a magic number: if (text.Length < ParserHelpers.Int64OverflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          bytesConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = 1; index < ParserHelpers.Int64OverflowLength - 1; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          bytesConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = ParserHelpers.Int64OverflowLength - 1; index < text.Length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          bytesConsumed = index;                          value = parsedValue;                          return true;                      }                      // If parsedValue > (ulong.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ulong.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ulong.MaxValue / 10 || (parsedValue == ulong.MaxValue / 10 && nextDigit > 5))                      {                          bytesConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseByteX,The following statement contains a magic number: if (text.Length <= ParserHelpers.ByteOverflowLengthHex)              {                  // Length is less than or equal to Parsers.ByteOverflowLengthHex; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      nextCharacter = text[index];                      nextDigit = hexLookup[nextCharacter];                      if (nextDigit == 0xFF)                      {                          bytesConsumed = index;                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = (parsedValue << 4) + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.ByteOverflowLengthHex; overflow is only possible after Parsers.ByteOverflowLengthHex                  // digits. There may be no overflow after Parsers.ByteOverflowLengthHex if there are leading zeroes.                  for (int index = 1; index < ParserHelpers.ByteOverflowLengthHex; index++)                  {                      nextCharacter = text[index];                      nextDigit = hexLookup[nextCharacter];                      if (nextDigit == 0xFF)                      {                          bytesConsumed = index;                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = (parsedValue << 4) + nextDigit;                  }                  for (int index = ParserHelpers.ByteOverflowLengthHex; index < text.Length; index++)                  {                      nextCharacter = text[index];                      nextDigit = hexLookup[nextCharacter];                      if (nextDigit == 0xFF)                      {                          bytesConsumed = index;                          value = (byte)(parsedValue);                          return true;                      }                      // If we try to append a digit to anything larger than byte.MaxValue / 0x10' there will be overflow                      if (parsedValue > byte.MaxValue / 0x10)                      {                          bytesConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = (parsedValue << 4) + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseByteX,The following statement contains a magic number: if (text.Length <= ParserHelpers.ByteOverflowLengthHex)              {                  // Length is less than or equal to Parsers.ByteOverflowLengthHex; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      nextCharacter = text[index];                      nextDigit = hexLookup[nextCharacter];                      if (nextDigit == 0xFF)                      {                          bytesConsumed = index;                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = (parsedValue << 4) + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.ByteOverflowLengthHex; overflow is only possible after Parsers.ByteOverflowLengthHex                  // digits. There may be no overflow after Parsers.ByteOverflowLengthHex if there are leading zeroes.                  for (int index = 1; index < ParserHelpers.ByteOverflowLengthHex; index++)                  {                      nextCharacter = text[index];                      nextDigit = hexLookup[nextCharacter];                      if (nextDigit == 0xFF)                      {                          bytesConsumed = index;                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = (parsedValue << 4) + nextDigit;                  }                  for (int index = ParserHelpers.ByteOverflowLengthHex; index < text.Length; index++)                  {                      nextCharacter = text[index];                      nextDigit = hexLookup[nextCharacter];                      if (nextDigit == 0xFF)                      {                          bytesConsumed = index;                          value = (byte)(parsedValue);                          return true;                      }                      // If we try to append a digit to anything larger than byte.MaxValue / 0x10' there will be overflow                      if (parsedValue > byte.MaxValue / 0x10)                      {                          bytesConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = (parsedValue << 4) + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseByteX,The following statement contains a magic number: if (text.Length <= ParserHelpers.ByteOverflowLengthHex)              {                  // Length is less than or equal to Parsers.ByteOverflowLengthHex; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      nextCharacter = text[index];                      nextDigit = hexLookup[nextCharacter];                      if (nextDigit == 0xFF)                      {                          bytesConsumed = index;                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = (parsedValue << 4) + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.ByteOverflowLengthHex; overflow is only possible after Parsers.ByteOverflowLengthHex                  // digits. There may be no overflow after Parsers.ByteOverflowLengthHex if there are leading zeroes.                  for (int index = 1; index < ParserHelpers.ByteOverflowLengthHex; index++)                  {                      nextCharacter = text[index];                      nextDigit = hexLookup[nextCharacter];                      if (nextDigit == 0xFF)                      {                          bytesConsumed = index;                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = (parsedValue << 4) + nextDigit;                  }                  for (int index = ParserHelpers.ByteOverflowLengthHex; index < text.Length; index++)                  {                      nextCharacter = text[index];                      nextDigit = hexLookup[nextCharacter];                      if (nextDigit == 0xFF)                      {                          bytesConsumed = index;                          value = (byte)(parsedValue);                          return true;                      }                      // If we try to append a digit to anything larger than byte.MaxValue / 0x10' there will be overflow                      if (parsedValue > byte.MaxValue / 0x10)                      {                          bytesConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = (parsedValue << 4) + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseUInt16X,The following statement contains a magic number: if (text.Length <= ParserHelpers.Int16OverflowLengthHex)              {                  // Length is less than or equal to Parsers.Int16OverflowLengthHex; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      nextCharacter = text[index];                      nextDigit = hexLookup[nextCharacter];                      if (nextDigit == 0xFF)                      {                          bytesConsumed = index;                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = (parsedValue << 4) + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLengthHex; overflow is only possible after Parsers.Int16OverflowLengthHex                  // digits. There may be no overflow after Parsers.Int16OverflowLengthHex if there are leading zeroes.                  for (int index = 1; index < ParserHelpers.Int16OverflowLengthHex; index++)                  {                      nextCharacter = text[index];                      nextDigit = hexLookup[nextCharacter];                      if (nextDigit == 0xFF)                      {                          bytesConsumed = index;                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = (parsedValue << 4) + nextDigit;                  }                  for (int index = ParserHelpers.Int16OverflowLengthHex; index < text.Length; index++)                  {                      nextCharacter = text[index];                      nextDigit = hexLookup[nextCharacter];                      if (nextDigit == 0xFF)                      {                          bytesConsumed = index;                          value = (ushort)(parsedValue);                          return true;                      }                      // If we try to append a digit to anything larger than ushort.MaxValue / 0x10' there will be overflow                      if (parsedValue > ushort.MaxValue / 0x10)                      {                          bytesConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = (parsedValue << 4) + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseUInt16X,The following statement contains a magic number: if (text.Length <= ParserHelpers.Int16OverflowLengthHex)              {                  // Length is less than or equal to Parsers.Int16OverflowLengthHex; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      nextCharacter = text[index];                      nextDigit = hexLookup[nextCharacter];                      if (nextDigit == 0xFF)                      {                          bytesConsumed = index;                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = (parsedValue << 4) + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLengthHex; overflow is only possible after Parsers.Int16OverflowLengthHex                  // digits. There may be no overflow after Parsers.Int16OverflowLengthHex if there are leading zeroes.                  for (int index = 1; index < ParserHelpers.Int16OverflowLengthHex; index++)                  {                      nextCharacter = text[index];                      nextDigit = hexLookup[nextCharacter];                      if (nextDigit == 0xFF)                      {                          bytesConsumed = index;                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = (parsedValue << 4) + nextDigit;                  }                  for (int index = ParserHelpers.Int16OverflowLengthHex; index < text.Length; index++)                  {                      nextCharacter = text[index];                      nextDigit = hexLookup[nextCharacter];                      if (nextDigit == 0xFF)                      {                          bytesConsumed = index;                          value = (ushort)(parsedValue);                          return true;                      }                      // If we try to append a digit to anything larger than ushort.MaxValue / 0x10' there will be overflow                      if (parsedValue > ushort.MaxValue / 0x10)                      {                          bytesConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = (parsedValue << 4) + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseUInt16X,The following statement contains a magic number: if (text.Length <= ParserHelpers.Int16OverflowLengthHex)              {                  // Length is less than or equal to Parsers.Int16OverflowLengthHex; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      nextCharacter = text[index];                      nextDigit = hexLookup[nextCharacter];                      if (nextDigit == 0xFF)                      {                          bytesConsumed = index;                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = (parsedValue << 4) + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLengthHex; overflow is only possible after Parsers.Int16OverflowLengthHex                  // digits. There may be no overflow after Parsers.Int16OverflowLengthHex if there are leading zeroes.                  for (int index = 1; index < ParserHelpers.Int16OverflowLengthHex; index++)                  {                      nextCharacter = text[index];                      nextDigit = hexLookup[nextCharacter];                      if (nextDigit == 0xFF)                      {                          bytesConsumed = index;                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = (parsedValue << 4) + nextDigit;                  }                  for (int index = ParserHelpers.Int16OverflowLengthHex; index < text.Length; index++)                  {                      nextCharacter = text[index];                      nextDigit = hexLookup[nextCharacter];                      if (nextDigit == 0xFF)                      {                          bytesConsumed = index;                          value = (ushort)(parsedValue);                          return true;                      }                      // If we try to append a digit to anything larger than ushort.MaxValue / 0x10' there will be overflow                      if (parsedValue > ushort.MaxValue / 0x10)                      {                          bytesConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = (parsedValue << 4) + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseUInt32X,The following statement contains a magic number: if (text.Length <= ParserHelpers.Int32OverflowLengthHex)              {                  // Length is less than or equal to Parsers.Int32OverflowLengthHex; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      nextCharacter = text[index];                      nextDigit = hexLookup[nextCharacter];                      if (nextDigit == 0xFF)                      {                          bytesConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = (parsedValue << 4) + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLengthHex; overflow is only possible after Parsers.Int32OverflowLengthHex                  // digits. There may be no overflow after Parsers.Int32OverflowLengthHex if there are leading zeroes.                  for (int index = 1; index < ParserHelpers.Int32OverflowLengthHex; index++)                  {                      nextCharacter = text[index];                      nextDigit = hexLookup[nextCharacter];                      if (nextDigit == 0xFF)                      {                          bytesConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = (parsedValue << 4) + nextDigit;                  }                  for (int index = ParserHelpers.Int32OverflowLengthHex; index < text.Length; index++)                  {                      nextCharacter = text[index];                      nextDigit = hexLookup[nextCharacter];                      if (nextDigit == 0xFF)                      {                          bytesConsumed = index;                          value = parsedValue;                          return true;                      }                      // If we try to append a digit to anything larger than uint.MaxValue / 0x10' there will be overflow                      if (parsedValue > uint.MaxValue / 0x10)                      {                          bytesConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = (parsedValue << 4) + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseUInt32X,The following statement contains a magic number: if (text.Length <= ParserHelpers.Int32OverflowLengthHex)              {                  // Length is less than or equal to Parsers.Int32OverflowLengthHex; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      nextCharacter = text[index];                      nextDigit = hexLookup[nextCharacter];                      if (nextDigit == 0xFF)                      {                          bytesConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = (parsedValue << 4) + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLengthHex; overflow is only possible after Parsers.Int32OverflowLengthHex                  // digits. There may be no overflow after Parsers.Int32OverflowLengthHex if there are leading zeroes.                  for (int index = 1; index < ParserHelpers.Int32OverflowLengthHex; index++)                  {                      nextCharacter = text[index];                      nextDigit = hexLookup[nextCharacter];                      if (nextDigit == 0xFF)                      {                          bytesConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = (parsedValue << 4) + nextDigit;                  }                  for (int index = ParserHelpers.Int32OverflowLengthHex; index < text.Length; index++)                  {                      nextCharacter = text[index];                      nextDigit = hexLookup[nextCharacter];                      if (nextDigit == 0xFF)                      {                          bytesConsumed = index;                          value = parsedValue;                          return true;                      }                      // If we try to append a digit to anything larger than uint.MaxValue / 0x10' there will be overflow                      if (parsedValue > uint.MaxValue / 0x10)                      {                          bytesConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = (parsedValue << 4) + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseUInt32X,The following statement contains a magic number: if (text.Length <= ParserHelpers.Int32OverflowLengthHex)              {                  // Length is less than or equal to Parsers.Int32OverflowLengthHex; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      nextCharacter = text[index];                      nextDigit = hexLookup[nextCharacter];                      if (nextDigit == 0xFF)                      {                          bytesConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = (parsedValue << 4) + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLengthHex; overflow is only possible after Parsers.Int32OverflowLengthHex                  // digits. There may be no overflow after Parsers.Int32OverflowLengthHex if there are leading zeroes.                  for (int index = 1; index < ParserHelpers.Int32OverflowLengthHex; index++)                  {                      nextCharacter = text[index];                      nextDigit = hexLookup[nextCharacter];                      if (nextDigit == 0xFF)                      {                          bytesConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = (parsedValue << 4) + nextDigit;                  }                  for (int index = ParserHelpers.Int32OverflowLengthHex; index < text.Length; index++)                  {                      nextCharacter = text[index];                      nextDigit = hexLookup[nextCharacter];                      if (nextDigit == 0xFF)                      {                          bytesConsumed = index;                          value = parsedValue;                          return true;                      }                      // If we try to append a digit to anything larger than uint.MaxValue / 0x10' there will be overflow                      if (parsedValue > uint.MaxValue / 0x10)                      {                          bytesConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = (parsedValue << 4) + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseUInt64X,The following statement contains a magic number: if (text.Length <= ParserHelpers.Int64OverflowLengthHex)              {                  // Length is less than or equal to Parsers.Int64OverflowLengthHex; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      nextCharacter = text[index];                      nextDigit = hexLookup[nextCharacter];                      if (nextDigit == 0xFF)                      {                          bytesConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = (parsedValue << 4) + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLengthHex; overflow is only possible after Parsers.Int64OverflowLengthHex                  // digits. There may be no overflow after Parsers.Int64OverflowLengthHex if there are leading zeroes.                  for (int index = 1; index < ParserHelpers.Int64OverflowLengthHex; index++)                  {                      nextCharacter = text[index];                      nextDigit = hexLookup[nextCharacter];                      if (nextDigit == 0xFF)                      {                          bytesConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = (parsedValue << 4) + nextDigit;                  }                  for (int index = ParserHelpers.Int64OverflowLengthHex; index < text.Length; index++)                  {                      nextCharacter = text[index];                      nextDigit = hexLookup[nextCharacter];                      if (nextDigit == 0xFF)                      {                          bytesConsumed = index;                          value = parsedValue;                          return true;                      }                      // If we try to append a digit to anything larger than ulong.MaxValue / 0x10' there will be overflow                      if (parsedValue > ulong.MaxValue / 0x10)                      {                          bytesConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = (parsedValue << 4) + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseUInt64X,The following statement contains a magic number: if (text.Length <= ParserHelpers.Int64OverflowLengthHex)              {                  // Length is less than or equal to Parsers.Int64OverflowLengthHex; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      nextCharacter = text[index];                      nextDigit = hexLookup[nextCharacter];                      if (nextDigit == 0xFF)                      {                          bytesConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = (parsedValue << 4) + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLengthHex; overflow is only possible after Parsers.Int64OverflowLengthHex                  // digits. There may be no overflow after Parsers.Int64OverflowLengthHex if there are leading zeroes.                  for (int index = 1; index < ParserHelpers.Int64OverflowLengthHex; index++)                  {                      nextCharacter = text[index];                      nextDigit = hexLookup[nextCharacter];                      if (nextDigit == 0xFF)                      {                          bytesConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = (parsedValue << 4) + nextDigit;                  }                  for (int index = ParserHelpers.Int64OverflowLengthHex; index < text.Length; index++)                  {                      nextCharacter = text[index];                      nextDigit = hexLookup[nextCharacter];                      if (nextDigit == 0xFF)                      {                          bytesConsumed = index;                          value = parsedValue;                          return true;                      }                      // If we try to append a digit to anything larger than ulong.MaxValue / 0x10' there will be overflow                      if (parsedValue > ulong.MaxValue / 0x10)                      {                          bytesConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = (parsedValue << 4) + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseUInt64X,The following statement contains a magic number: if (text.Length <= ParserHelpers.Int64OverflowLengthHex)              {                  // Length is less than or equal to Parsers.Int64OverflowLengthHex; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      nextCharacter = text[index];                      nextDigit = hexLookup[nextCharacter];                      if (nextDigit == 0xFF)                      {                          bytesConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = (parsedValue << 4) + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLengthHex; overflow is only possible after Parsers.Int64OverflowLengthHex                  // digits. There may be no overflow after Parsers.Int64OverflowLengthHex if there are leading zeroes.                  for (int index = 1; index < ParserHelpers.Int64OverflowLengthHex; index++)                  {                      nextCharacter = text[index];                      nextDigit = hexLookup[nextCharacter];                      if (nextDigit == 0xFF)                      {                          bytesConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = (parsedValue << 4) + nextDigit;                  }                  for (int index = ParserHelpers.Int64OverflowLengthHex; index < text.Length; index++)                  {                      nextCharacter = text[index];                      nextDigit = hexLookup[nextCharacter];                      if (nextDigit == 0xFF)                      {                          bytesConsumed = index;                          value = parsedValue;                          return true;                      }                      // If we try to append a digit to anything larger than ulong.MaxValue / 0x10' there will be overflow                      if (parsedValue > ulong.MaxValue / 0x10)                      {                          bytesConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = (parsedValue << 4) + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseNumber,The following statement contains a magic number: while (srcIndex != text.Length)              {                  c = text[srcIndex];                  if ((c - 48u) > 9)                      break;                  srcIndex++;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseNumber,The following statement contains a magic number: if (c == Utf8Constants.Period)              {                  //                  // Parse the digits after the decimal point.                  //                    srcIndex++;                  int startIndexDigitsAfterDecimal = srcIndex;                  while (srcIndex != text.Length)                  {                      c = text[srcIndex];                      if ((c - 48u) > 9)                          break;                      srcIndex++;                  }                  numDigitsAfterDecimal = srcIndex - startIndexDigitsAfterDecimal;                    int startIndexOfDigitsAfterDecimalToCopy = startIndexDigitsAfterDecimal;                  if (dstIndex == 0)                  {                      // Not copied any digits to the Number struct yet. This means we must continue discarding leading zeroes even though they appeared after the decimal point.                      while (startIndexOfDigitsAfterDecimalToCopy < srcIndex && text[startIndexOfDigitsAfterDecimalToCopy] == '0')                      {                          number.Scale--;                          startIndexOfDigitsAfterDecimalToCopy++;                      }                  }                    int numDigitsAfterDecimalToCopy = Math.Min(srcIndex - startIndexOfDigitsAfterDecimalToCopy' NumberBuffer.BufferSize - dstIndex - 1);                  text.Slice(startIndexOfDigitsAfterDecimalToCopy' numDigitsAfterDecimalToCopy).CopyTo(digits.Slice(dstIndex));                  dstIndex += numDigitsAfterDecimalToCopy;                  // We "should" really NUL terminate' but there are multiple places we'd have to do this and it is a precondition that the caller pass in a fully zero=initialized Number.                    if (srcIndex == text.Length)                  {                      if (numDigitsBeforeDecimal == 0 && numDigitsAfterDecimal == 0)                      {                          // For compatibility. You can say "5." and ".5" but you can't say "."                          bytesConsumed = 0;                          return false;                      }                        bytesConsumed = srcIndex;                      number.CheckConsistency();                      return true;                  }              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseTimeSpanFraction,The following statement contains a magic number: if (digit > 9)              {                  value = default;                  bytesConsumed = 0;                  return false;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseTimeSpanFraction,The following statement contains a magic number: while (srcIndex != text.Length)              {                  digit = text[srcIndex] - 48u; // '0'                  if (digit > 9)                      break;                  srcIndex++;                  digitCount++;                  if (digitCount > Utf8Constants.DateTimeNumFractionDigits)                  {                      // Yes' TimeSpan fraction parsing is that picky.                      value = default;                      bytesConsumed = 0;                      return false;                  }                  fraction = 10 * fraction + digit;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseTimeSpanFraction,The following statement contains a magic number: while (srcIndex != text.Length)              {                  digit = text[srcIndex] - 48u; // '0'                  if (digit > 9)                      break;                  srcIndex++;                  digitCount++;                  if (digitCount > Utf8Constants.DateTimeNumFractionDigits)                  {                      // Yes' TimeSpan fraction parsing is that picky.                      value = default;                      bytesConsumed = 0;                      return false;                  }                  fraction = 10 * fraction + digit;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseTimeSpanFraction,The following statement contains a magic number: switch (digitCount)              {                  case 7:                      break;                    case 6:                      fraction *= 10;                      break;                    case 5:                      fraction *= 100;                      break;                    case 4:                      fraction *= 1000;                      break;                    case 3:                      fraction *= 10000;                      break;                    case 2:                      fraction *= 100000;                      break;                    default:                      Debug.Assert(digitCount == 1);                      fraction *= 1000000;                      break;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseTimeSpanFraction,The following statement contains a magic number: switch (digitCount)              {                  case 7:                      break;                    case 6:                      fraction *= 10;                      break;                    case 5:                      fraction *= 100;                      break;                    case 4:                      fraction *= 1000;                      break;                    case 3:                      fraction *= 10000;                      break;                    case 2:                      fraction *= 100000;                      break;                    default:                      Debug.Assert(digitCount == 1);                      fraction *= 1000000;                      break;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseTimeSpanFraction,The following statement contains a magic number: switch (digitCount)              {                  case 7:                      break;                    case 6:                      fraction *= 10;                      break;                    case 5:                      fraction *= 100;                      break;                    case 4:                      fraction *= 1000;                      break;                    case 3:                      fraction *= 10000;                      break;                    case 2:                      fraction *= 100000;                      break;                    default:                      Debug.Assert(digitCount == 1);                      fraction *= 1000000;                      break;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseTimeSpanFraction,The following statement contains a magic number: switch (digitCount)              {                  case 7:                      break;                    case 6:                      fraction *= 10;                      break;                    case 5:                      fraction *= 100;                      break;                    case 4:                      fraction *= 1000;                      break;                    case 3:                      fraction *= 10000;                      break;                    case 2:                      fraction *= 100000;                      break;                    default:                      Debug.Assert(digitCount == 1);                      fraction *= 1000000;                      break;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseTimeSpanFraction,The following statement contains a magic number: switch (digitCount)              {                  case 7:                      break;                    case 6:                      fraction *= 10;                      break;                    case 5:                      fraction *= 100;                      break;                    case 4:                      fraction *= 1000;                      break;                    case 3:                      fraction *= 10000;                      break;                    case 2:                      fraction *= 100000;                      break;                    default:                      Debug.Assert(digitCount == 1);                      fraction *= 1000000;                      break;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseTimeSpanFraction,The following statement contains a magic number: switch (digitCount)              {                  case 7:                      break;                    case 6:                      fraction *= 10;                      break;                    case 5:                      fraction *= 100;                      break;                    case 4:                      fraction *= 1000;                      break;                    case 3:                      fraction *= 10000;                      break;                    case 2:                      fraction *= 100000;                      break;                    default:                      Debug.Assert(digitCount == 1);                      fraction *= 1000000;                      break;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseTimeSpanFraction,The following statement contains a magic number: switch (digitCount)              {                  case 7:                      break;                    case 6:                      fraction *= 10;                      break;                    case 5:                      fraction *= 100;                      break;                    case 4:                      fraction *= 1000;                      break;                    case 3:                      fraction *= 10000;                      break;                    case 2:                      fraction *= 100000;                      break;                    default:                      Debug.Assert(digitCount == 1);                      fraction *= 1000000;                      break;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseTimeSpanFraction,The following statement contains a magic number: switch (digitCount)              {                  case 7:                      break;                    case 6:                      fraction *= 10;                      break;                    case 5:                      fraction *= 100;                      break;                    case 4:                      fraction *= 1000;                      break;                    case 3:                      fraction *= 10000;                      break;                    case 2:                      fraction *= 100000;                      break;                    default:                      Debug.Assert(digitCount == 1);                      fraction *= 1000000;                      break;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseTimeSpanFraction,The following statement contains a magic number: switch (digitCount)              {                  case 7:                      break;                    case 6:                      fraction *= 10;                      break;                    case 5:                      fraction *= 100;                      break;                    case 4:                      fraction *= 1000;                      break;                    case 3:                      fraction *= 10000;                      break;                    case 2:                      fraction *= 100000;                      break;                    default:                      Debug.Assert(digitCount == 1);                      fraction *= 1000000;                      break;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseTimeSpanFraction,The following statement contains a magic number: switch (digitCount)              {                  case 7:                      break;                    case 6:                      fraction *= 10;                      break;                    case 5:                      fraction *= 100;                      break;                    case 4:                      fraction *= 1000;                      break;                    case 3:                      fraction *= 10000;                      break;                    case 2:                      fraction *= 100000;                      break;                    default:                      Debug.Assert(digitCount == 1);                      fraction *= 1000000;                      break;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseTimeSpanFraction,The following statement contains a magic number: switch (digitCount)              {                  case 7:                      break;                    case 6:                      fraction *= 10;                      break;                    case 5:                      fraction *= 100;                      break;                    case 4:                      fraction *= 1000;                      break;                    case 3:                      fraction *= 10000;                      break;                    case 2:                      fraction *= 100000;                      break;                    default:                      Debug.Assert(digitCount == 1);                      fraction *= 1000000;                      break;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseTimeSpanFraction,The following statement contains a magic number: switch (digitCount)              {                  case 7:                      break;                    case 6:                      fraction *= 10;                      break;                    case 5:                      fraction *= 100;                      break;                    case 4:                      fraction *= 1000;                      break;                    case 3:                      fraction *= 10000;                      break;                    case 2:                      fraction *= 100000;                      break;                    default:                      Debug.Assert(digitCount == 1);                      fraction *= 1000000;                      break;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryCreateTimeSpan,The following statement contains a magic number: if (hours > 23 || minutes > 59 || seconds > 59)              {                  timeSpan = default;                  return false;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryCreateTimeSpan,The following statement contains a magic number: if (hours > 23 || minutes > 59 || seconds > 59)              {                  timeSpan = default;                  return false;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryCreateTimeSpan,The following statement contains a magic number: if (hours > 23 || minutes > 59 || seconds > 59)              {                  timeSpan = default;                  return false;              }
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryCreateTimeSpan,The following statement contains a magic number: long millisecondsWithoutFraction = (((long)days) * 3600 * 24 + ((long)hours) * 3600 + ((long)minutes) * 60 + seconds) * 1000;
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryCreateTimeSpan,The following statement contains a magic number: long millisecondsWithoutFraction = (((long)days) * 3600 * 24 + ((long)hours) * 3600 + ((long)minutes) * 60 + seconds) * 1000;
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryCreateTimeSpan,The following statement contains a magic number: long millisecondsWithoutFraction = (((long)days) * 3600 * 24 + ((long)hours) * 3600 + ((long)minutes) * 60 + seconds) * 1000;
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryCreateTimeSpan,The following statement contains a magic number: long millisecondsWithoutFraction = (((long)days) * 3600 * 24 + ((long)hours) * 3600 + ((long)minutes) * 60 + seconds) * 1000;
Magic Number,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryCreateTimeSpan,The following statement contains a magic number: long millisecondsWithoutFraction = (((long)days) * 3600 * 24 + ((long)hours) * 3600 + ((long)minutes) * 60 + seconds) * 1000;
Magic Number,System.Buffers.Text,TimeSpanSplitter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.TimeSpanSplitter.cs,TrySplitTimeSpan,The following statement contains a magic number: if (result == ComponentParseResult.ParseFailure)                  {                      bytesConsumed = 0;                      return false;                  }                  else if (result == ComponentParseResult.NoMoreData)                  {                      bytesConsumed = srcIndex;                      return true;                  }                  else                  {                      Debug.Assert(result == ComponentParseResult.Colon || result == ComponentParseResult.Period);                      Separators |= ((uint)result) << 24;                  }
Magic Number,System.Buffers.Text,TimeSpanSplitter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.TimeSpanSplitter.cs,TrySplitTimeSpan,The following statement contains a magic number: if (result == ComponentParseResult.ParseFailure)                  {                      bytesConsumed = 0;                      return false;                  }                  else if (result == ComponentParseResult.NoMoreData)                  {                      bytesConsumed = srcIndex;                      return true;                  }                  else                  {                      Debug.Assert(result == ComponentParseResult.Colon || result == ComponentParseResult.Period);                      Separators |= ((uint)result) << 16;                  }
Magic Number,System.Buffers.Text,TimeSpanSplitter,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.TimeSpanSplitter.cs,TrySplitTimeSpan,The following statement contains a magic number: if (result == ComponentParseResult.ParseFailure)                  {                      bytesConsumed = 0;                      return false;                  }                  else if (result == ComponentParseResult.NoMoreData)                  {                      bytesConsumed = srcIndex;                      return true;                  }                  else                  {                      Debug.Assert(result == ComponentParseResult.Colon || result == ComponentParseResult.Period);                      Separators |= ((uint)result) << 8;                  }
Duplicate Code,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseGuidCore,The method contains a code clone-set at the following line numbers (starting from the method definition): ((48' 69)' (71' 92)' (94' 115))
Duplicate Code,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseInt32D,The method contains a code clone-set at the following line numbers (starting from the method definition): ((43' 62)' (51' 70)' (59' 78)' (67' 86)' (75' 94)' (83' 102))
Duplicate Code,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseInt32D,The method contains a code clone-set at the following line numbers (starting from the method definition): ((43' 93)' (51' 101))
Duplicate Code,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseInt32D,The method contains a code clone-set at the following line numbers (starting from the method definition): ((43' 62)' (59' 78)' (67' 86)' (75' 94)' (83' 102))
Duplicate Code,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseUInt32D,The method contains a code clone-set at the following line numbers (starting from the method definition): ((26' 45)' (34' 53)' (42' 61)' (50' 69)' (58' 77)' (66' 85))
Duplicate Code,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseUInt32D,The method contains a code clone-set at the following line numbers (starting from the method definition): ((26' 76)' (34' 84))
Duplicate Code,System.Buffers.Text,Utf8Parser,C:\selectedRepos\dotnet_corefx\src\System.Memory\src\System\Buffers\Text\Utf8Parser\Utf8Parser.Boolean.cs,TryParseUInt32D,The method contains a code clone-set at the following line numbers (starting from the method definition): ((26' 45)' (42' 61)' (50' 69)' (58' 77)' (66' 85))
