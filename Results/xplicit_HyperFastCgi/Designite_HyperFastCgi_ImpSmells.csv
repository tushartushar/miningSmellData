Implementation smell,Namespace,Class,File,Method,Description
Long Method,HyperFastCgi,MainClass,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Main.cs,Main,The method has 167 lines of code.
Long Method,HyperFastCgi.Listeners,FastCgiNetworkConnector,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Listeners\FastCgiNetworkConnector.cs,ReceiveCallback,The method has 100 lines of code.
Complex Method,HyperFastCgi,MainClass,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Main.cs,Main,Cyclomatic complexity of the method is 20
Complex Method,HyperFastCgi.Configuration,ConfigurationManager,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Configuration\ConfigurationManager.cs,GetValue,Cyclomatic complexity of the method is 8
Complex Method,HyperFastCgi.Configuration,ConfigurationManager,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Configuration\ConfigurationManager.cs,PrintHelp,Cyclomatic complexity of the method is 13
Complex Method,HyperFastCgi.Configuration,ConfigurationManager,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Configuration\ConfigurationManager.cs,LoadCommandLineArgs,Cyclomatic complexity of the method is 8
Complex Method,HyperFastCgi.Configuration,ConfigUtils,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Configuration\ConfigUtils.cs,GetApplicationsFromCommandLine,Cyclomatic complexity of the method is 8
Complex Method,HyperFastCgi.Configuration,ConfigUtils,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Configuration\ConfigUtils.cs,GetConfigsFromElement,Cyclomatic complexity of the method is 9
Complex Method,HyperFastCgi.AppHosts.AspNet,AspNetNativeWebRequest,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\AppHosts\AspNet\AspNetNativeWebRequest.cs,GetFilePath,Cyclomatic complexity of the method is 8
Complex Method,HyperFastCgi.AppHosts.AspNet,MonoWorkerRequest,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\AppHosts\AspNet\MonoWorkerRequest.cs,MapPath,Cyclomatic complexity of the method is 8
Complex Method,HyperFastCgi.Listeners,FastCgiNetworkConnector,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Listeners\FastCgiNetworkConnector.cs,ReceiveCallback,Cyclomatic complexity of the method is 10
Complex Method,HyperFastCgi.Transports,BaseManagedListenerTransport,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Transports\BaseManagedListenerTransport.cs,AddHeader,Cyclomatic complexity of the method is 9
Complex Method,Mono.WebServer,VPathToHost,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Helpers\Mono.WebServer\VPathToHost.cs,Match,Cyclomatic complexity of the method is 10
Complex Method,HyperFastCgi.Helpers,ThreadHelper,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Helpers\ThreadHelper.cs,SetThreads,Cyclomatic complexity of the method is 10
Long Parameter List,HyperFastCgi.Interfaces,IApplicationHost,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Interfaces\IApplicationHost.cs,Configure,The method has 6 parameters. Parameters: appHostConfig' webAppConfig' appServer' listenerTransport' appHostTransportType' appHostTransportConfig
Long Parameter List,HyperFastCgi.Interfaces,IApplicationHostFactory,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Interfaces\IApplicationHostFactory.cs,CreateApplicationHost,The method has 5 parameters. Parameters: appHostType' vhost' vport' vpath' path
Long Parameter List,HyperFastCgi.Interfaces,IWebListener,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Interfaces\IWebListener.cs,Configure,The method has 6 parameters. Parameters: listenerConfig' server' listenerTransport' listenerTransportConfig' appHostTransport' appHostTransportConfig
Long Parameter List,HyperFastCgi.Interfaces,IApplicationServer,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Interfaces\IApplicationServer.cs,CreateApplicationHost,The method has 6 parameters. Parameters: appHostType' appHostConfig' webAppConfig' listenerTransport' transport' transportConfig
Long Parameter List,HyperFastCgi.AppHosts.AspNet,AspNetApplicationHost,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\AppHosts\AspNet\AspNetApplicationHost.cs,Configure,The method has 6 parameters. Parameters: appHostConfig' webAppConfig' server' listenerTransport' appHostTransportType' transportConfig
Long Parameter List,HyperFastCgi.AppHosts.AspNet,AspNetNativeWebRequest,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\AppHosts\AspNet\AspNetNativeWebRequest.cs,AspNetNativeWebRequest,The method has 5 parameters. Parameters: requestId' requestNumber' appHost' transport' addTrailingSlash
Long Parameter List,HyperFastCgi.AppHosts,AppHostBase,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\AppHosts\AppHostBase.cs,Configure,The method has 6 parameters. Parameters: appHostConfig' webAppConfig' server' listenerTransport' appHostTransportType' transportConfig
Long Parameter List,HyperFastCgi.AppHosts.Raw,RawHost,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\AppHosts\Raw\RawHost.cs,Configure,The method has 6 parameters. Parameters: appHostConfig' webAppConfig' server' listenerTransport' appHostTransportType' transportConfig
Long Parameter List,HyperFastCgi.ApplicationServers,SimpleApplicationServer,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\ApplicationServers\SimpleApplicationServer.cs,CreateApplicationHost,The method has 6 parameters. Parameters: appHostType' appHostConfig' webAppConfig' listenerTransport' appHostTransportType' appHostTransportConfig
Long Parameter List,HyperFastCgi.ApplicationServers,SimpleApplicationServer,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\ApplicationServers\SimpleApplicationServer.cs,CreateAppHost,The method has 6 parameters. Parameters: appHostType' appHostConfig' appConfig' listenerTransport' appHostTransportType' appHostTransportConfig
Long Parameter List,HyperFastCgi.Listeners,ManagedFastCgiListener,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Listeners\ManagedFastCgiListener.cs,Configure,The method has 6 parameters. Parameters: conf' server' listenerTransport' listenerTransportConfig' appHostTransport' appHostTransportConfig
Long Parameter List,HyperFastCgi.Listeners,NativeListener,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Listeners\NativeListener.cs,Configure,The method has 6 parameters. Parameters: config' server' listenerTransport' listenerTransportConfig' appHostTransport' appHostTransportConfig
Long Parameter List,HyperFastCgi.Transports,BaseManagedListenerTransport,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Transports\BaseManagedListenerTransport.cs,SendStreamData,The method has 5 parameters. Parameters: listenerTag' type' requestId' data' length
Long Parameter List,HyperFastCgi.Transports,BaseManagedListenerTransport,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Transports\BaseManagedListenerTransport.cs,SendRecord,The method has 6 parameters. Parameters: listenerTag' type' requestID' bodyData' bodyIndex' bodyLength
Long Parameter List,HyperFastCgi.Transports,CombinedFastCgiListenerTransport,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Transports\CombinedFastCgiListenerTransport.cs,AppHostTransportAddServerVariable,The method has 5 parameters. Parameters: host' requestId' requestNumber' name' value
Long Parameter List,HyperFastCgi.Transports,CombinedFastCgiListenerTransport,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Transports\CombinedFastCgiListenerTransport.cs,AppHostTransportAddHeader,The method has 5 parameters. Parameters: host' requestId' requestNumber' name' value
Long Parameter List,HyperFastCgi.Transports,CombinedFastCgiListenerTransport,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Transports\CombinedFastCgiListenerTransport.cs,AppHostTransportAddBodyPart,The method has 5 parameters. Parameters: host' requestId' requestNumber' body' final
Long Parameter List,HyperFastCgi.Helpers.FastCgiProtocol,Record,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Helpers\FastCgiProtocol\Record.cs,Record,The method has 6 parameters. Parameters: version' type' requestID' bodyData' bodyIndex' bodyLength
Long Parameter List,HyperFastCgi.HostFactories,SystemWebHostFactory,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\HostFactories\SystemWebHostFactory.cs,CreateApplicationHost,The method has 5 parameters. Parameters: appHostType' vhost' vport' vpath' path
Long Identifier,HyperFastCgi.Helpers,Strings,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Helpers\Strings.cs,,The length of the parameter Server_ResponderDoesNotImplement is 32.
Long Identifier,HyperFastCgi.Helpers,Strings,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Helpers\Strings.cs,,The length of the parameter Server_ResponderLacksProperConstructor is 38.
Long Identifier,HyperFastCgi.Helpers,Strings,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Helpers\Strings.cs,,The length of the parameter Connection_RequestAlreadyExists is 31.
Long Identifier,HyperFastCgi.Helpers,Strings,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Helpers\Strings.cs,,The length of the parameter Connection_RequestDoesNotExist is 30.
Long Identifier,HyperFastCgi.Helpers,Strings,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Helpers\Strings.cs,,The length of the parameter Connection_AbortRecordReceived is 30.
Long Identifier,HyperFastCgi.Helpers,Strings,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Helpers\Strings.cs,,The length of the parameter NameValuePair_DuplicateParameter is 32.
Long Identifier,HyperFastCgi.Helpers,Strings,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Helpers\Strings.cs,,The length of the parameter NameValuePair_DictionaryContainsNonString is 41.
Long Identifier,HyperFastCgi.Helpers,Strings,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Helpers\Strings.cs,,The length of the parameter NameValuePair_LengthLessThanZero is 32.
Long Identifier,HyperFastCgi.Helpers,Strings,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Helpers\Strings.cs,,The length of the parameter ResponderRequest_IncompleteInput is 32.
Long Identifier,HyperFastCgi.Helpers,Strings,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Helpers\Strings.cs,,The length of the parameter ResponderRequest_NoContentLength is 32.
Long Identifier,HyperFastCgi.Helpers,Strings,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Helpers\Strings.cs,,The length of the parameter ResponderRequest_NoContentLengthNotNumber is 41.
Long Identifier,HyperFastCgi.Helpers,Strings,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Helpers\Strings.cs,,The length of the parameter ResponderRequest_ContentExceedsLength is 37.
Long Identifier,HyperFastCgi.Helpers,Strings,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Helpers\Strings.cs,,The length of the parameter Request_ParametersAlreadyCompleted is 34.
Long Identifier,HyperFastCgi.Helpers,Strings,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Helpers\Strings.cs,,The length of the parameter Request_StandardInputAlreadyCompleted is 37.
Long Identifier,HyperFastCgi.Helpers,Strings,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Helpers\Strings.cs,,The length of the parameter Request_FileDataAlreadyCompleted is 32.
Long Statement,HyperFastCgi,MainClass,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Main.cs,Main,The length of the statement  "					Console.WriteLine ("Only one server is supported currently. Please remove redudant <server> node from file '{0}'"' config); " is 123.
Long Statement,HyperFastCgi,MainClass,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Main.cs,Main,The length of the statement  "					Console.WriteLine ("Only one listener is supported currently. Please remove redudant <listener> node from file '{0}'"' config); " is 127.
Long Statement,HyperFastCgi.AppHosts.AspNet,MonoWorkerRequest,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\AppHosts\AspNet\MonoWorkerRequest.cs,MapPath,The length of the statement  "			if (pathLen == 0 || (inThisApp && (pathLen == hostVPathLen || (pathLen == hostVPathLen + 1 && path [pathLen - 1] == '/')))) { " is 125.
Long Statement,HyperFastCgi.AppHosts,AppHostBase,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\AppHosts\AppHostBase.cs,Configure,The length of the statement  "			Logger.Write (LogLevel.Debug' "Configured host in domain {0}' id={1}"' AppDomain.CurrentDomain.FriendlyName' AppDomain.CurrentDomain.Id); " is 137.
Long Statement,HyperFastCgi.ApplicationServers,SimpleApplicationServer,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\ApplicationServers\SimpleApplicationServer.cs,CreateApplicationHost,The length of the statement  "			return CreateAppHost (appHostType' appHostConfig' appConfig' listenerTransport' appHostTransportType' appHostTransportConfig); " is 126.
Long Statement,HyperFastCgi.ApplicationServers,SimpleApplicationServer,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\ApplicationServers\SimpleApplicationServer.cs,CreateAppHost,The length of the statement  "			Logger.Write (LogLevel.Debug' "SimpleApplicationServer.CreateAppHost vhost={0}' vport={1}"' appConfig.VHost' appConfig.VPort); " is 126.
Long Statement,HyperFastCgi.ApplicationServers,SimpleApplicationServer,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\ApplicationServers\SimpleApplicationServer.cs,CreateAppHost,The length of the statement  "				IApplicationHost host = hostFactory.CreateApplicationHost (appHostType' appConfig.VHost' appConfig.VPort' appConfig.VPath' appConfig.RealPath); " is 143.
Long Statement,HyperFastCgi.ApplicationServers,SimpleApplicationServer,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\ApplicationServers\SimpleApplicationServer.cs,OnHostUnload,The length of the statement  "					Logger.Write (LogLevel.Error' "Can't unload host {0}:{1}:{2}:{3}"' appHost.VHost' appHost.VPort' appHost.VPath' appHost.Path); " is 126.
Long Statement,HyperFastCgi.ApplicationServers,SimpleApplicationServer,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\ApplicationServers\SimpleApplicationServer.cs,OnHostUnload,The length of the statement  "					Logger.Write (LogLevel.Debug' "Domain={0} Unload host in domain {1} id={2}"' AppDomain.CurrentDomain.FriendlyName' ((IApplicationHost)sender).Domain.FriendlyName' ((IApplicationHost)sender).Domain.Id); " is 201.
Long Statement,HyperFastCgi.Listeners,FastCgiNetworkConnector,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Listeners\FastCgiNetworkConnector.cs,ProcessRecord,The length of the statement  "				Logger.Write (LogLevel.Debug' "cn={0} read header={1} reqId={2}"' cn' header [1]' (ushort)((header [2] << 8) + header [3])); " is 124.
Long Statement,HyperFastCgi.Listeners,FastCgiNetworkConnector,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Listeners\FastCgiNetworkConnector.cs,StartSendPackets,The length of the statement  "					client.BeginSend (sendState.buffer' sendState.offset' sendState.buffer.Length' SocketFlags.None' asyncSendCallback' sendState); " is 127.
Long Statement,HyperFastCgi.Listeners,FastCgiNetworkConnector,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Listeners\FastCgiNetworkConnector.cs,SendCallback,The length of the statement  "					client.BeginSend (sendState.buffer' sendState.offset' sendState.buffer.Length - sendState.offset' SocketFlags.None' asyncSendCallback' sendState); " is 146.
Long Statement,HyperFastCgi.Helpers,ThreadHelper,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Helpers\ThreadHelper.cs,SetThreads,The length of the statement  "			if ((maxWorkerThreads != 0 && maxWorkerThreads < minWorkerThreads) || (maxIOThreads != 0 && maxIOThreads < minIOThreads)) " is 121.
Complex Conditional,HyperFastCgi.AppHosts.AspNet,MonoWorkerRequest,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\AppHosts\AspNet\MonoWorkerRequest.cs,MapPath,The conditional expression  "pathLen == 0 || (inThisApp && (pathLen == hostVPathLen || (pathLen == hostVPathLen + 1 && path [pathLen - 1] == '/')))"  is complex.
Complex Conditional,HyperFastCgi.Helpers,ThreadHelper,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Helpers\ThreadHelper.cs,SetThreads,The conditional expression  "minWorkerThreads ==0 &&  minIOThreads ==0 && maxWorkerThreads ==0 && maxIOThreads == 0"  is complex.
Complex Conditional,HyperFastCgi.Helpers,ThreadHelper,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Helpers\ThreadHelper.cs,SetThreads,The conditional expression  "(maxWorkerThreads != 0 && maxWorkerThreads < minWorkerThreads) || (maxIOThreads != 0 && maxIOThreads < minIOThreads)"  is complex.
Empty Catch Block,HyperFastCgi.Listeners,ManagedFastCgiListener,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Listeners\ManagedFastCgiListener.cs,acceptCallback,The method has an empty catch block.
Empty Catch Block,HyperFastCgi.Helpers.Sockets,UnixSocket,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Helpers\Sockets\UnixSocket.cs,CreateEndPoint,The method has an empty catch block.
Empty Catch Block,HyperFastCgi.Helpers.Logging,Logger,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Helpers\Logging\Logger.cs,Close,The method has an empty catch block.
Magic Number,HyperFastCgi.Configuration,ConfigurationManager,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Configuration\ConfigurationManager.cs,PrintHelp,The following statement contains a magic number: foreach (XmlElement setting in elems) {  				string show = GetXmlValue (setting'  					              "ConsoleVisible").ToLower (  					              CultureInfo.InvariantCulture);    				if (show != "true")  					continue;    				string type = GetXmlValue (setting'  					              "Type").ToUpper (  					              CultureInfo.InvariantCulture);    				int length = 4 +  				             GetXmlValue (setting' "Name").Length +  				             (type == "BOOL" ? 14 : type.Length + 1);    				if (length > left_margin)  					left_margin = length;  			}
Magic Number,HyperFastCgi.Configuration,ConfigurationManager,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Configuration\ConfigurationManager.cs,PrintHelp,The following statement contains a magic number: foreach (XmlElement setting in elems) {  				string show = GetXmlValue (setting'  					              "ConsoleVisible").ToLower (  					              CultureInfo.InvariantCulture);    				if (show != "true")  					continue;    				string type = GetXmlValue (setting'  					              "Type").ToUpper (  					              CultureInfo.InvariantCulture);    				int length = 4 +  				             GetXmlValue (setting' "Name").Length +  				             (type == "BOOL" ? 14 : type.Length + 1);    				if (length > left_margin)  					left_margin = length;  			}
Magic Number,HyperFastCgi.Configuration,ConfigurationManager,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Configuration\ConfigurationManager.cs,PrintHelp,The following statement contains a magic number: foreach (XmlElement setting in elems) {  				string show = GetXmlValue (setting'  					              "ConsoleVisible").ToLower (  					              CultureInfo.InvariantCulture);    				if (show != "true")  					continue;    				string type = GetXmlValue (setting'  					              "Type").ToUpper (  					              CultureInfo.InvariantCulture);    				string name = GetXmlValue (setting' "Name");   				string arg = string.Format (  					             CultureInfo.InvariantCulture'  					             "  /{0}{1}"'  					             name'  					             type == "BOOL" ? "[=True|=False]" :  					"=" + type);    				Console.Write (arg);    				ArrayList values = new ArrayList ();  				foreach (XmlElement desc in setting.GetElementsByTagName ("Description"))  					RenderXml (desc' values' 0' 78 - left_margin);    				string app_setting = GetXmlValue (setting'  					                     "AppSetting");    				if (app_setting.Length > 0) {  					string val = AppSettings [app_setting];    					if (val == null || val.Length == 0)  						val = default_args [name];    					if (val == null || val.Length == 0)  						val = "none";    					values.Add (" Default Value: " + val);    					values.Add (" AppSettings Key Name: " +  					app_setting);    				}    				string env_setting = GetXmlValue (setting'  					                     "Environment");    				if (env_setting.Length > 0)  					values.Add (" Environment Variable Name: " +  					env_setting);    				values.Add (string.Empty);    				int start = arg.Length;  				foreach (string text in values) {  					for (int i = start; i < left_margin; i++)  						Console.Write (' ');  					start = 0;  					Console.WriteLine (text);  				}  			}
Magic Number,HyperFastCgi.Configuration,ConfigurationManager,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Configuration\ConfigurationManager.cs,RenderXml,The following statement contains a magic number: foreach (XmlNode node in elem.ChildNodes) {  				XmlElement child = node as XmlElement;  				switch (node.LocalName) {  				case "para":  					RenderXml (child' values' indent' length);  					values.Add (string.Empty);  					break;  				case "block":  					RenderXml (child' values' indent + 4' length);  					break;  				case "example":  					RenderXml (child' values' indent + 4' length);  					values.Add (string.Empty);  					break;  				case "code":  				case "desc":  					RenderXml (child' values' indent' length);  					break;  				case "#text":  					RenderText (node.Value' values' indent' length);  					break;  				}  			}
Magic Number,HyperFastCgi.Configuration,ConfigurationManager,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Configuration\ConfigurationManager.cs,RenderXml,The following statement contains a magic number: foreach (XmlNode node in elem.ChildNodes) {  				XmlElement child = node as XmlElement;  				switch (node.LocalName) {  				case "para":  					RenderXml (child' values' indent' length);  					values.Add (string.Empty);  					break;  				case "block":  					RenderXml (child' values' indent + 4' length);  					break;  				case "example":  					RenderXml (child' values' indent + 4' length);  					values.Add (string.Empty);  					break;  				case "code":  				case "desc":  					RenderXml (child' values' indent' length);  					break;  				case "#text":  					RenderText (node.Value' values' indent' length);  					break;  				}  			}
Magic Number,HyperFastCgi.Configuration,ConfigurationManager,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Configuration\ConfigurationManager.cs,CreateBuilder,The following statement contains a magic number: StringBuilder builder = new StringBuilder (80);
Magic Number,HyperFastCgi.Configuration,ConfigurationManager,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Configuration\ConfigurationManager.cs,LoadCommandLineArgs,The following statement contains a magic number: for (int i = 0; i < args.Length; i++) {  				// Randomize the hash a bit.  				int idx = (i + 1 < args.Length) ? i + 1 : i;  				hash ^= args [idx].GetHashCode () + i;    				string arg = args [i];  				int len = PrefixLength (arg);    				if (len > 0)  					arg = arg.Substring (len);  				else {  					Console.WriteLine (  						"Warning: \"{0}\" is not a valid argument. Ignoring."'  						args [i]);  					continue;  				}    				if (cmd_args [arg] != null)  					Console.WriteLine (  						"Warning: \"{0}\" has already been set. Overwriting."'  						args [i]);    				string[] pair = arg.Split (new char [] { '=' }'  					                 2);    				if (pair.Length == 2) {  					cmd_args.Add (pair [0]' pair [1]);  					continue;  				}    				XmlElement setting = GetSetting (arg);  				if (setting == null) {  					Console.WriteLine (  						"Warning: \"{0}\" is an unknown argument. Ignoring."'  						args [i]);  					continue;  				}    				string type = GetXmlValue (setting'  					              "Type").ToLower (  					              CultureInfo.InvariantCulture);  				string value;    				if (type == "bool")  					value = (i + 1 < args.Length &&  					(args [i + 1].ToLower () == "true" ||  					args [i + 1].ToLower () == "false")) ?  					        args [++i] : "True";  				else if (i + 1 < args.Length)  					value = args [++i];  				else {  					Console.WriteLine (  						"Warning: \"{0}\" is missing its value. Ignoring."'  						args [i]);  					continue;  				}    				cmd_args [arg] = value;  			}
Magic Number,HyperFastCgi.Configuration,ConfigurationManager,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Configuration\ConfigurationManager.cs,LoadCommandLineArgs,The following statement contains a magic number: for (int i = 0; i < args.Length; i++) {  				// Randomize the hash a bit.  				int idx = (i + 1 < args.Length) ? i + 1 : i;  				hash ^= args [idx].GetHashCode () + i;    				string arg = args [i];  				int len = PrefixLength (arg);    				if (len > 0)  					arg = arg.Substring (len);  				else {  					Console.WriteLine (  						"Warning: \"{0}\" is not a valid argument. Ignoring."'  						args [i]);  					continue;  				}    				if (cmd_args [arg] != null)  					Console.WriteLine (  						"Warning: \"{0}\" has already been set. Overwriting."'  						args [i]);    				string[] pair = arg.Split (new char [] { '=' }'  					                 2);    				if (pair.Length == 2) {  					cmd_args.Add (pair [0]' pair [1]);  					continue;  				}    				XmlElement setting = GetSetting (arg);  				if (setting == null) {  					Console.WriteLine (  						"Warning: \"{0}\" is an unknown argument. Ignoring."'  						args [i]);  					continue;  				}    				string type = GetXmlValue (setting'  					              "Type").ToLower (  					              CultureInfo.InvariantCulture);  				string value;    				if (type == "bool")  					value = (i + 1 < args.Length &&  					(args [i + 1].ToLower () == "true" ||  					args [i + 1].ToLower () == "false")) ?  					        args [++i] : "True";  				else if (i + 1 < args.Length)  					value = args [++i];  				else {  					Console.WriteLine (  						"Warning: \"{0}\" is missing its value. Ignoring."'  						args [i]);  					continue;  				}    				cmd_args [arg] = value;  			}
Magic Number,HyperFastCgi.Configuration,ConfigurationManager,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Configuration\ConfigurationManager.cs,PrefixLength,The following statement contains a magic number: if (arg.StartsWith ("--"))  				return 2;
Magic Number,HyperFastCgi.Configuration,ConfigUtils,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Configuration\ConfigUtils.cs,GetApplicationsFromCommandLine,The following statement contains a magic number: foreach (string str in apps) {  				string[] app = str.Split (':');    				if (app.Length < 2 || app.Length > 4)  					throw new ArgumentException ("Should be something like " +  						"[[hostname:]port:]VPath:realpath");    				int vport;  				string vhost;  				string vpath;  				string realpath;  				int pos = 0;    				if (app.Length >= 3) {  					vhost = app [pos++];  				} else {  					vhost = null;  				}    				if (app.Length >= 4) {  					// FIXME: support more than one listen port.  					vport = Convert.ToInt16 (app [pos++]);  				} else {  					vport = -1;  				}    				vpath = app [pos++];  				realpath = app [pos++];    				if (!vpath.EndsWith ("/"))  					vpath += "/";    				string fullPath = System.IO.Path.GetFullPath (realpath);  				applist.Add (new WebAppConfig (){VHost = vhost' VPort = vport' VPath = vpath' RealPath = fullPath });   			}
Magic Number,HyperFastCgi.Configuration,ConfigUtils,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Configuration\ConfigUtils.cs,GetApplicationsFromCommandLine,The following statement contains a magic number: foreach (string str in apps) {  				string[] app = str.Split (':');    				if (app.Length < 2 || app.Length > 4)  					throw new ArgumentException ("Should be something like " +  						"[[hostname:]port:]VPath:realpath");    				int vport;  				string vhost;  				string vpath;  				string realpath;  				int pos = 0;    				if (app.Length >= 3) {  					vhost = app [pos++];  				} else {  					vhost = null;  				}    				if (app.Length >= 4) {  					// FIXME: support more than one listen port.  					vport = Convert.ToInt16 (app [pos++]);  				} else {  					vport = -1;  				}    				vpath = app [pos++];  				realpath = app [pos++];    				if (!vpath.EndsWith ("/"))  					vpath += "/";    				string fullPath = System.IO.Path.GetFullPath (realpath);  				applist.Add (new WebAppConfig (){VHost = vhost' VPort = vport' VPath = vpath' RealPath = fullPath });   			}
Magic Number,HyperFastCgi.Configuration,ConfigUtils,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Configuration\ConfigUtils.cs,GetApplicationsFromCommandLine,The following statement contains a magic number: foreach (string str in apps) {  				string[] app = str.Split (':');    				if (app.Length < 2 || app.Length > 4)  					throw new ArgumentException ("Should be something like " +  						"[[hostname:]port:]VPath:realpath");    				int vport;  				string vhost;  				string vpath;  				string realpath;  				int pos = 0;    				if (app.Length >= 3) {  					vhost = app [pos++];  				} else {  					vhost = null;  				}    				if (app.Length >= 4) {  					// FIXME: support more than one listen port.  					vport = Convert.ToInt16 (app [pos++]);  				} else {  					vport = -1;  				}    				vpath = app [pos++];  				realpath = app [pos++];    				if (!vpath.EndsWith ("/"))  					vpath += "/";    				string fullPath = System.IO.Path.GetFullPath (realpath);  				applist.Add (new WebAppConfig (){VHost = vhost' VPort = vport' VPath = vpath' RealPath = fullPath });   			}
Magic Number,HyperFastCgi.Configuration,ConfigUtils,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Configuration\ConfigUtils.cs,GetApplicationsFromCommandLine,The following statement contains a magic number: foreach (string str in apps) {  				string[] app = str.Split (':');    				if (app.Length < 2 || app.Length > 4)  					throw new ArgumentException ("Should be something like " +  						"[[hostname:]port:]VPath:realpath");    				int vport;  				string vhost;  				string vpath;  				string realpath;  				int pos = 0;    				if (app.Length >= 3) {  					vhost = app [pos++];  				} else {  					vhost = null;  				}    				if (app.Length >= 4) {  					// FIXME: support more than one listen port.  					vport = Convert.ToInt16 (app [pos++]);  				} else {  					vport = -1;  				}    				vpath = app [pos++];  				realpath = app [pos++];    				if (!vpath.EndsWith ("/"))  					vpath += "/";    				string fullPath = System.IO.Path.GetFullPath (realpath);  				applist.Add (new WebAppConfig (){VHost = vhost' VPort = vport' VPath = vpath' RealPath = fullPath });   			}
Magic Number,HyperFastCgi.AppHosts.AspNet,AspNetNativeWebRequest,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\AppHosts\AspNet\AspNetNativeWebRequest.cs,AddressFromHostName,The following statement contains a magic number: if (host == null || host.Length > 126)  				return null;
Magic Number,HyperFastCgi.AppHosts.AspNet,MonoWorkerRequest,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\AppHosts\AspNet\MonoWorkerRequest.cs,MapPath,The following statement contains a magic number: switch (path [0]) {  			case '~':  				if (path.Length >= 2 && path [1] == '/')  					path = path.Substring (1);  				break;    			case '/':  				if (!inThisApp)  					basePath = HostPhysicalRoot;  				break;  			}
Magic Number,HyperFastCgi.AppHosts.AspNet,MonoWorkerRequest,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\AppHosts\AspNet\MonoWorkerRequest.cs,ProcessRequest,The following statement contains a magic number: try {  				HttpRuntime.ProcessRequest (this);  			} catch (HttpException ex) {  				inUnhandledException = true;  				error = ex.GetHtmlErrorMessage ();  			} catch (Exception ex) {  				inUnhandledException = true;  				HttpException hex = new HttpException (400' "Bad request"' ex);  				if (hex != null) // just a precaution  					error = hex.GetHtmlErrorMessage ();  				else  					error = String.Format (defaultExceptionHtml' ex.Message);  			}
Magic Number,HyperFastCgi.AppHosts.AspNet,MonoWorkerRequest,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\AppHosts\AspNet\MonoWorkerRequest.cs,ProcessRequest,The following statement contains a magic number: try {  				SendStatus (400' "Bad request");  				SendUnknownResponseHeader ("Connection"' "close");  				SendUnknownResponseHeader ("Date"' DateTime.Now.ToUniversalTime ().ToString ("r"));    				Encoding enc = Encoding.UTF8;  				if (enc == null)  					enc = Encoding.ASCII;    				byte[] bytes = enc.GetBytes (error);    				SendUnknownResponseHeader ("Content-Type"' "text/html; charset=" + enc.WebName);  				SendUnknownResponseHeader ("Content-Length"' bytes.Length.ToString ());  				SendResponseFromMemory (bytes' bytes.Length);  				FlushResponse (true);  			} catch (Exception ex) { // should "never" happen  				throw ex;  			}
Magic Number,HyperFastCgi.AppHosts.Raw,BaseRawRequest,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\AppHosts\Raw\BaseRawRequest.cs,PrepareHeaders,The following statement contains a magic number: return Encoding.GetEncoding (28591)  				.GetBytes (responseHeadersOutput.ToString ());
Magic Number,HyperFastCgi.AppHosts.Raw,HelloWorldRequest,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\AppHosts\Raw\HelloWorldRequest.cs,Process,The following statement contains a magic number: Status = 200;
Magic Number,HyperFastCgi.Listeners,ManagedFastCgiListener,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Listeners\ManagedFastCgiListener.cs,Listen,The following statement contains a magic number: try {  				Logger.Write (LogLevel.Debug'"Listening on port: {0}"' config.Port);  				Logger.Write (LogLevel.Debug'"Listening on address: {0}"' config.Address);    				this.listener = CreateSocket (config.Family' config.Address' config.Port);    				listener.Listen (500);  				listener.BeginAccept (accept' listener);    			} catch (Exception ex) {  				Logger.Write (LogLevel.Error' "{0}"' ex);  				return 1; //false;  			}
Magic Number,HyperFastCgi.Listeners,FastCgiNetworkConnector,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Listeners\FastCgiNetworkConnector.cs,ReceiveCallback,The following statement contains a magic number: try {  				Socket client = state.workSocket;  				//	state.offset = 0;  				SocketError socketError;    				bytesRead = client.EndReceive (ar' out socketError);    				if (socketError != SocketError.Success) {  					//					log.DebugFormat("Socket error during receving [{0}]"' socketError);  					OnDisconnected ();  					return;  				}    				// BytesRead==0 means' that socket is gracefully shutdown  				// on the other side. By the way it only means' that socket is shutdown  				// for sending data and it can wait for receiveing data. Underlying   				// Connection can still be in ESTABLISHED state' even if socket is closed  				// (in case when socket reuses connection)  				if (bytesRead <= 0) {    					//Front-end disconnected  					readShutdown=true;  					return;  				}      				if (bytesRead > 0) {  					offset = 0;    					while (offset < bytesRead /*&& !stopReceive*/) {  						if (state.State == ReadState.Header) {  							int len;  							if ((len = StateObject.headerLength - state.arrayOffset) <= bytesRead - offset) {  								//TODO: change BlockCopy to "goto" statement  								Buffer.BlockCopy (state.buffer' offset' state.header' state.arrayOffset' len);  								offset += len;  								state.arrayOffset = 0;  								state.record.Version = state.header [0];  								state.record.Type = (RecordType)state.header [1];  								state.record.RequestId = (ushort)((state.header [2] << 8) + state.header [3]);  								state.record.BodyLength = (ushort)((state.header [4] << 8) + state.header [5]);  								state.record.PaddingLength = state.header [6];  								state.record.Body = new byte[state.record.BodyLength];  								//skip reserved field header[7]  								state.State = ReadState.Body;  								if (state.record.BodyLength == 0) {  									state.State = state.record.PaddingLength != 0 ? ReadState.Padding : ReadState.Header;  									if (state.State == ReadState.Header) {  										ProcessRecord (state.header'state.record.Body);  									}  								}  							} else {  								Buffer.BlockCopy (state.buffer' offset' state.header' state.arrayOffset' bytesRead - offset);  								state.arrayOffset += (bytesRead - offset);  								offset = bytesRead;  							}    						} else if (state.State == ReadState.Body) {  							int len;  							if ((len = state.record.BodyLength - state.arrayOffset) <= bytesRead - offset) {  								Buffer.BlockCopy (state.buffer' offset' state.record.Body' state.arrayOffset' len);  								offset += len;  								state.arrayOffset = 0;    								if (state.record.PaddingLength == 0) {  									state.State = ReadState.Header;  									ProcessRecord (state.header' state.record.Body);  								} else {  									state.State = ReadState.Padding;  								}  							} else {  								Buffer.BlockCopy (state.buffer' offset' state.record.Body' state.arrayOffset' bytesRead - offset);  								state.arrayOffset += (bytesRead - offset);  								offset = bytesRead;  							}  						} else if (state.State == ReadState.Padding) {  							if (state.record.PaddingLength - state.arrayOffset <= bytesRead - offset) {  								offset += state.record.PaddingLength - state.arrayOffset;  								state.State = ReadState.Header;  								//Process Record  								ProcessRecord (state.header' state.record.Body);  							} else {  								state.arrayOffset += bytesRead - offset;  								offset = bytesRead;  							}  						} else {  							//something wrong with packet  							Logger.Write (LogLevel.Error' "Wrong packet from HTTP server");   						}  					}  				}  				if (keepAlive || !stopReceive)  					client.BeginReceive (state.buffer' 0' state.buffer.Length' 0' asyncRecieveCallback' state);  			} catch (SocketException ex) {  				Logger.Write (LogLevel.Error' "ReceiveCallback. Socket error while receivieng data: {0}"' ex.Message);  				OnDisconnected ();  			} catch (ObjectDisposedException) {  				Logger.Write (LogLevel.Error' "ReceiveCallback. Socket was closed");  				OnDisconnected ();  			} catch (Exception ex) {  				Logger.Write (LogLevel.Error' "Unhandled exception in recv {0}"' ex);  				throw;  			}
Magic Number,HyperFastCgi.Listeners,FastCgiNetworkConnector,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Listeners\FastCgiNetworkConnector.cs,ReceiveCallback,The following statement contains a magic number: try {  				Socket client = state.workSocket;  				//	state.offset = 0;  				SocketError socketError;    				bytesRead = client.EndReceive (ar' out socketError);    				if (socketError != SocketError.Success) {  					//					log.DebugFormat("Socket error during receving [{0}]"' socketError);  					OnDisconnected ();  					return;  				}    				// BytesRead==0 means' that socket is gracefully shutdown  				// on the other side. By the way it only means' that socket is shutdown  				// for sending data and it can wait for receiveing data. Underlying   				// Connection can still be in ESTABLISHED state' even if socket is closed  				// (in case when socket reuses connection)  				if (bytesRead <= 0) {    					//Front-end disconnected  					readShutdown=true;  					return;  				}      				if (bytesRead > 0) {  					offset = 0;    					while (offset < bytesRead /*&& !stopReceive*/) {  						if (state.State == ReadState.Header) {  							int len;  							if ((len = StateObject.headerLength - state.arrayOffset) <= bytesRead - offset) {  								//TODO: change BlockCopy to "goto" statement  								Buffer.BlockCopy (state.buffer' offset' state.header' state.arrayOffset' len);  								offset += len;  								state.arrayOffset = 0;  								state.record.Version = state.header [0];  								state.record.Type = (RecordType)state.header [1];  								state.record.RequestId = (ushort)((state.header [2] << 8) + state.header [3]);  								state.record.BodyLength = (ushort)((state.header [4] << 8) + state.header [5]);  								state.record.PaddingLength = state.header [6];  								state.record.Body = new byte[state.record.BodyLength];  								//skip reserved field header[7]  								state.State = ReadState.Body;  								if (state.record.BodyLength == 0) {  									state.State = state.record.PaddingLength != 0 ? ReadState.Padding : ReadState.Header;  									if (state.State == ReadState.Header) {  										ProcessRecord (state.header'state.record.Body);  									}  								}  							} else {  								Buffer.BlockCopy (state.buffer' offset' state.header' state.arrayOffset' bytesRead - offset);  								state.arrayOffset += (bytesRead - offset);  								offset = bytesRead;  							}    						} else if (state.State == ReadState.Body) {  							int len;  							if ((len = state.record.BodyLength - state.arrayOffset) <= bytesRead - offset) {  								Buffer.BlockCopy (state.buffer' offset' state.record.Body' state.arrayOffset' len);  								offset += len;  								state.arrayOffset = 0;    								if (state.record.PaddingLength == 0) {  									state.State = ReadState.Header;  									ProcessRecord (state.header' state.record.Body);  								} else {  									state.State = ReadState.Padding;  								}  							} else {  								Buffer.BlockCopy (state.buffer' offset' state.record.Body' state.arrayOffset' bytesRead - offset);  								state.arrayOffset += (bytesRead - offset);  								offset = bytesRead;  							}  						} else if (state.State == ReadState.Padding) {  							if (state.record.PaddingLength - state.arrayOffset <= bytesRead - offset) {  								offset += state.record.PaddingLength - state.arrayOffset;  								state.State = ReadState.Header;  								//Process Record  								ProcessRecord (state.header' state.record.Body);  							} else {  								state.arrayOffset += bytesRead - offset;  								offset = bytesRead;  							}  						} else {  							//something wrong with packet  							Logger.Write (LogLevel.Error' "Wrong packet from HTTP server");   						}  					}  				}  				if (keepAlive || !stopReceive)  					client.BeginReceive (state.buffer' 0' state.buffer.Length' 0' asyncRecieveCallback' state);  			} catch (SocketException ex) {  				Logger.Write (LogLevel.Error' "ReceiveCallback. Socket error while receivieng data: {0}"' ex.Message);  				OnDisconnected ();  			} catch (ObjectDisposedException) {  				Logger.Write (LogLevel.Error' "ReceiveCallback. Socket was closed");  				OnDisconnected ();  			} catch (Exception ex) {  				Logger.Write (LogLevel.Error' "Unhandled exception in recv {0}"' ex);  				throw;  			}
Magic Number,HyperFastCgi.Listeners,FastCgiNetworkConnector,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Listeners\FastCgiNetworkConnector.cs,ReceiveCallback,The following statement contains a magic number: try {  				Socket client = state.workSocket;  				//	state.offset = 0;  				SocketError socketError;    				bytesRead = client.EndReceive (ar' out socketError);    				if (socketError != SocketError.Success) {  					//					log.DebugFormat("Socket error during receving [{0}]"' socketError);  					OnDisconnected ();  					return;  				}    				// BytesRead==0 means' that socket is gracefully shutdown  				// on the other side. By the way it only means' that socket is shutdown  				// for sending data and it can wait for receiveing data. Underlying   				// Connection can still be in ESTABLISHED state' even if socket is closed  				// (in case when socket reuses connection)  				if (bytesRead <= 0) {    					//Front-end disconnected  					readShutdown=true;  					return;  				}      				if (bytesRead > 0) {  					offset = 0;    					while (offset < bytesRead /*&& !stopReceive*/) {  						if (state.State == ReadState.Header) {  							int len;  							if ((len = StateObject.headerLength - state.arrayOffset) <= bytesRead - offset) {  								//TODO: change BlockCopy to "goto" statement  								Buffer.BlockCopy (state.buffer' offset' state.header' state.arrayOffset' len);  								offset += len;  								state.arrayOffset = 0;  								state.record.Version = state.header [0];  								state.record.Type = (RecordType)state.header [1];  								state.record.RequestId = (ushort)((state.header [2] << 8) + state.header [3]);  								state.record.BodyLength = (ushort)((state.header [4] << 8) + state.header [5]);  								state.record.PaddingLength = state.header [6];  								state.record.Body = new byte[state.record.BodyLength];  								//skip reserved field header[7]  								state.State = ReadState.Body;  								if (state.record.BodyLength == 0) {  									state.State = state.record.PaddingLength != 0 ? ReadState.Padding : ReadState.Header;  									if (state.State == ReadState.Header) {  										ProcessRecord (state.header'state.record.Body);  									}  								}  							} else {  								Buffer.BlockCopy (state.buffer' offset' state.header' state.arrayOffset' bytesRead - offset);  								state.arrayOffset += (bytesRead - offset);  								offset = bytesRead;  							}    						} else if (state.State == ReadState.Body) {  							int len;  							if ((len = state.record.BodyLength - state.arrayOffset) <= bytesRead - offset) {  								Buffer.BlockCopy (state.buffer' offset' state.record.Body' state.arrayOffset' len);  								offset += len;  								state.arrayOffset = 0;    								if (state.record.PaddingLength == 0) {  									state.State = ReadState.Header;  									ProcessRecord (state.header' state.record.Body);  								} else {  									state.State = ReadState.Padding;  								}  							} else {  								Buffer.BlockCopy (state.buffer' offset' state.record.Body' state.arrayOffset' bytesRead - offset);  								state.arrayOffset += (bytesRead - offset);  								offset = bytesRead;  							}  						} else if (state.State == ReadState.Padding) {  							if (state.record.PaddingLength - state.arrayOffset <= bytesRead - offset) {  								offset += state.record.PaddingLength - state.arrayOffset;  								state.State = ReadState.Header;  								//Process Record  								ProcessRecord (state.header' state.record.Body);  							} else {  								state.arrayOffset += bytesRead - offset;  								offset = bytesRead;  							}  						} else {  							//something wrong with packet  							Logger.Write (LogLevel.Error' "Wrong packet from HTTP server");   						}  					}  				}  				if (keepAlive || !stopReceive)  					client.BeginReceive (state.buffer' 0' state.buffer.Length' 0' asyncRecieveCallback' state);  			} catch (SocketException ex) {  				Logger.Write (LogLevel.Error' "ReceiveCallback. Socket error while receivieng data: {0}"' ex.Message);  				OnDisconnected ();  			} catch (ObjectDisposedException) {  				Logger.Write (LogLevel.Error' "ReceiveCallback. Socket was closed");  				OnDisconnected ();  			} catch (Exception ex) {  				Logger.Write (LogLevel.Error' "Unhandled exception in recv {0}"' ex);  				throw;  			}
Magic Number,HyperFastCgi.Listeners,FastCgiNetworkConnector,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Listeners\FastCgiNetworkConnector.cs,ReceiveCallback,The following statement contains a magic number: try {  				Socket client = state.workSocket;  				//	state.offset = 0;  				SocketError socketError;    				bytesRead = client.EndReceive (ar' out socketError);    				if (socketError != SocketError.Success) {  					//					log.DebugFormat("Socket error during receving [{0}]"' socketError);  					OnDisconnected ();  					return;  				}    				// BytesRead==0 means' that socket is gracefully shutdown  				// on the other side. By the way it only means' that socket is shutdown  				// for sending data and it can wait for receiveing data. Underlying   				// Connection can still be in ESTABLISHED state' even if socket is closed  				// (in case when socket reuses connection)  				if (bytesRead <= 0) {    					//Front-end disconnected  					readShutdown=true;  					return;  				}      				if (bytesRead > 0) {  					offset = 0;    					while (offset < bytesRead /*&& !stopReceive*/) {  						if (state.State == ReadState.Header) {  							int len;  							if ((len = StateObject.headerLength - state.arrayOffset) <= bytesRead - offset) {  								//TODO: change BlockCopy to "goto" statement  								Buffer.BlockCopy (state.buffer' offset' state.header' state.arrayOffset' len);  								offset += len;  								state.arrayOffset = 0;  								state.record.Version = state.header [0];  								state.record.Type = (RecordType)state.header [1];  								state.record.RequestId = (ushort)((state.header [2] << 8) + state.header [3]);  								state.record.BodyLength = (ushort)((state.header [4] << 8) + state.header [5]);  								state.record.PaddingLength = state.header [6];  								state.record.Body = new byte[state.record.BodyLength];  								//skip reserved field header[7]  								state.State = ReadState.Body;  								if (state.record.BodyLength == 0) {  									state.State = state.record.PaddingLength != 0 ? ReadState.Padding : ReadState.Header;  									if (state.State == ReadState.Header) {  										ProcessRecord (state.header'state.record.Body);  									}  								}  							} else {  								Buffer.BlockCopy (state.buffer' offset' state.header' state.arrayOffset' bytesRead - offset);  								state.arrayOffset += (bytesRead - offset);  								offset = bytesRead;  							}    						} else if (state.State == ReadState.Body) {  							int len;  							if ((len = state.record.BodyLength - state.arrayOffset) <= bytesRead - offset) {  								Buffer.BlockCopy (state.buffer' offset' state.record.Body' state.arrayOffset' len);  								offset += len;  								state.arrayOffset = 0;    								if (state.record.PaddingLength == 0) {  									state.State = ReadState.Header;  									ProcessRecord (state.header' state.record.Body);  								} else {  									state.State = ReadState.Padding;  								}  							} else {  								Buffer.BlockCopy (state.buffer' offset' state.record.Body' state.arrayOffset' bytesRead - offset);  								state.arrayOffset += (bytesRead - offset);  								offset = bytesRead;  							}  						} else if (state.State == ReadState.Padding) {  							if (state.record.PaddingLength - state.arrayOffset <= bytesRead - offset) {  								offset += state.record.PaddingLength - state.arrayOffset;  								state.State = ReadState.Header;  								//Process Record  								ProcessRecord (state.header' state.record.Body);  							} else {  								state.arrayOffset += bytesRead - offset;  								offset = bytesRead;  							}  						} else {  							//something wrong with packet  							Logger.Write (LogLevel.Error' "Wrong packet from HTTP server");   						}  					}  				}  				if (keepAlive || !stopReceive)  					client.BeginReceive (state.buffer' 0' state.buffer.Length' 0' asyncRecieveCallback' state);  			} catch (SocketException ex) {  				Logger.Write (LogLevel.Error' "ReceiveCallback. Socket error while receivieng data: {0}"' ex.Message);  				OnDisconnected ();  			} catch (ObjectDisposedException) {  				Logger.Write (LogLevel.Error' "ReceiveCallback. Socket was closed");  				OnDisconnected ();  			} catch (Exception ex) {  				Logger.Write (LogLevel.Error' "Unhandled exception in recv {0}"' ex);  				throw;  			}
Magic Number,HyperFastCgi.Listeners,FastCgiNetworkConnector,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Listeners\FastCgiNetworkConnector.cs,ReceiveCallback,The following statement contains a magic number: try {  				Socket client = state.workSocket;  				//	state.offset = 0;  				SocketError socketError;    				bytesRead = client.EndReceive (ar' out socketError);    				if (socketError != SocketError.Success) {  					//					log.DebugFormat("Socket error during receving [{0}]"' socketError);  					OnDisconnected ();  					return;  				}    				// BytesRead==0 means' that socket is gracefully shutdown  				// on the other side. By the way it only means' that socket is shutdown  				// for sending data and it can wait for receiveing data. Underlying   				// Connection can still be in ESTABLISHED state' even if socket is closed  				// (in case when socket reuses connection)  				if (bytesRead <= 0) {    					//Front-end disconnected  					readShutdown=true;  					return;  				}      				if (bytesRead > 0) {  					offset = 0;    					while (offset < bytesRead /*&& !stopReceive*/) {  						if (state.State == ReadState.Header) {  							int len;  							if ((len = StateObject.headerLength - state.arrayOffset) <= bytesRead - offset) {  								//TODO: change BlockCopy to "goto" statement  								Buffer.BlockCopy (state.buffer' offset' state.header' state.arrayOffset' len);  								offset += len;  								state.arrayOffset = 0;  								state.record.Version = state.header [0];  								state.record.Type = (RecordType)state.header [1];  								state.record.RequestId = (ushort)((state.header [2] << 8) + state.header [3]);  								state.record.BodyLength = (ushort)((state.header [4] << 8) + state.header [5]);  								state.record.PaddingLength = state.header [6];  								state.record.Body = new byte[state.record.BodyLength];  								//skip reserved field header[7]  								state.State = ReadState.Body;  								if (state.record.BodyLength == 0) {  									state.State = state.record.PaddingLength != 0 ? ReadState.Padding : ReadState.Header;  									if (state.State == ReadState.Header) {  										ProcessRecord (state.header'state.record.Body);  									}  								}  							} else {  								Buffer.BlockCopy (state.buffer' offset' state.header' state.arrayOffset' bytesRead - offset);  								state.arrayOffset += (bytesRead - offset);  								offset = bytesRead;  							}    						} else if (state.State == ReadState.Body) {  							int len;  							if ((len = state.record.BodyLength - state.arrayOffset) <= bytesRead - offset) {  								Buffer.BlockCopy (state.buffer' offset' state.record.Body' state.arrayOffset' len);  								offset += len;  								state.arrayOffset = 0;    								if (state.record.PaddingLength == 0) {  									state.State = ReadState.Header;  									ProcessRecord (state.header' state.record.Body);  								} else {  									state.State = ReadState.Padding;  								}  							} else {  								Buffer.BlockCopy (state.buffer' offset' state.record.Body' state.arrayOffset' bytesRead - offset);  								state.arrayOffset += (bytesRead - offset);  								offset = bytesRead;  							}  						} else if (state.State == ReadState.Padding) {  							if (state.record.PaddingLength - state.arrayOffset <= bytesRead - offset) {  								offset += state.record.PaddingLength - state.arrayOffset;  								state.State = ReadState.Header;  								//Process Record  								ProcessRecord (state.header' state.record.Body);  							} else {  								state.arrayOffset += bytesRead - offset;  								offset = bytesRead;  							}  						} else {  							//something wrong with packet  							Logger.Write (LogLevel.Error' "Wrong packet from HTTP server");   						}  					}  				}  				if (keepAlive || !stopReceive)  					client.BeginReceive (state.buffer' 0' state.buffer.Length' 0' asyncRecieveCallback' state);  			} catch (SocketException ex) {  				Logger.Write (LogLevel.Error' "ReceiveCallback. Socket error while receivieng data: {0}"' ex.Message);  				OnDisconnected ();  			} catch (ObjectDisposedException) {  				Logger.Write (LogLevel.Error' "ReceiveCallback. Socket was closed");  				OnDisconnected ();  			} catch (Exception ex) {  				Logger.Write (LogLevel.Error' "Unhandled exception in recv {0}"' ex);  				throw;  			}
Magic Number,HyperFastCgi.Listeners,FastCgiNetworkConnector,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Listeners\FastCgiNetworkConnector.cs,ReceiveCallback,The following statement contains a magic number: try {  				Socket client = state.workSocket;  				//	state.offset = 0;  				SocketError socketError;    				bytesRead = client.EndReceive (ar' out socketError);    				if (socketError != SocketError.Success) {  					//					log.DebugFormat("Socket error during receving [{0}]"' socketError);  					OnDisconnected ();  					return;  				}    				// BytesRead==0 means' that socket is gracefully shutdown  				// on the other side. By the way it only means' that socket is shutdown  				// for sending data and it can wait for receiveing data. Underlying   				// Connection can still be in ESTABLISHED state' even if socket is closed  				// (in case when socket reuses connection)  				if (bytesRead <= 0) {    					//Front-end disconnected  					readShutdown=true;  					return;  				}      				if (bytesRead > 0) {  					offset = 0;    					while (offset < bytesRead /*&& !stopReceive*/) {  						if (state.State == ReadState.Header) {  							int len;  							if ((len = StateObject.headerLength - state.arrayOffset) <= bytesRead - offset) {  								//TODO: change BlockCopy to "goto" statement  								Buffer.BlockCopy (state.buffer' offset' state.header' state.arrayOffset' len);  								offset += len;  								state.arrayOffset = 0;  								state.record.Version = state.header [0];  								state.record.Type = (RecordType)state.header [1];  								state.record.RequestId = (ushort)((state.header [2] << 8) + state.header [3]);  								state.record.BodyLength = (ushort)((state.header [4] << 8) + state.header [5]);  								state.record.PaddingLength = state.header [6];  								state.record.Body = new byte[state.record.BodyLength];  								//skip reserved field header[7]  								state.State = ReadState.Body;  								if (state.record.BodyLength == 0) {  									state.State = state.record.PaddingLength != 0 ? ReadState.Padding : ReadState.Header;  									if (state.State == ReadState.Header) {  										ProcessRecord (state.header'state.record.Body);  									}  								}  							} else {  								Buffer.BlockCopy (state.buffer' offset' state.header' state.arrayOffset' bytesRead - offset);  								state.arrayOffset += (bytesRead - offset);  								offset = bytesRead;  							}    						} else if (state.State == ReadState.Body) {  							int len;  							if ((len = state.record.BodyLength - state.arrayOffset) <= bytesRead - offset) {  								Buffer.BlockCopy (state.buffer' offset' state.record.Body' state.arrayOffset' len);  								offset += len;  								state.arrayOffset = 0;    								if (state.record.PaddingLength == 0) {  									state.State = ReadState.Header;  									ProcessRecord (state.header' state.record.Body);  								} else {  									state.State = ReadState.Padding;  								}  							} else {  								Buffer.BlockCopy (state.buffer' offset' state.record.Body' state.arrayOffset' bytesRead - offset);  								state.arrayOffset += (bytesRead - offset);  								offset = bytesRead;  							}  						} else if (state.State == ReadState.Padding) {  							if (state.record.PaddingLength - state.arrayOffset <= bytesRead - offset) {  								offset += state.record.PaddingLength - state.arrayOffset;  								state.State = ReadState.Header;  								//Process Record  								ProcessRecord (state.header' state.record.Body);  							} else {  								state.arrayOffset += bytesRead - offset;  								offset = bytesRead;  							}  						} else {  							//something wrong with packet  							Logger.Write (LogLevel.Error' "Wrong packet from HTTP server");   						}  					}  				}  				if (keepAlive || !stopReceive)  					client.BeginReceive (state.buffer' 0' state.buffer.Length' 0' asyncRecieveCallback' state);  			} catch (SocketException ex) {  				Logger.Write (LogLevel.Error' "ReceiveCallback. Socket error while receivieng data: {0}"' ex.Message);  				OnDisconnected ();  			} catch (ObjectDisposedException) {  				Logger.Write (LogLevel.Error' "ReceiveCallback. Socket was closed");  				OnDisconnected ();  			} catch (Exception ex) {  				Logger.Write (LogLevel.Error' "Unhandled exception in recv {0}"' ex);  				throw;  			}
Magic Number,HyperFastCgi.Listeners,FastCgiNetworkConnector,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Listeners\FastCgiNetworkConnector.cs,ReceiveCallback,The following statement contains a magic number: try {  				Socket client = state.workSocket;  				//	state.offset = 0;  				SocketError socketError;    				bytesRead = client.EndReceive (ar' out socketError);    				if (socketError != SocketError.Success) {  					//					log.DebugFormat("Socket error during receving [{0}]"' socketError);  					OnDisconnected ();  					return;  				}    				// BytesRead==0 means' that socket is gracefully shutdown  				// on the other side. By the way it only means' that socket is shutdown  				// for sending data and it can wait for receiveing data. Underlying   				// Connection can still be in ESTABLISHED state' even if socket is closed  				// (in case when socket reuses connection)  				if (bytesRead <= 0) {    					//Front-end disconnected  					readShutdown=true;  					return;  				}      				if (bytesRead > 0) {  					offset = 0;    					while (offset < bytesRead /*&& !stopReceive*/) {  						if (state.State == ReadState.Header) {  							int len;  							if ((len = StateObject.headerLength - state.arrayOffset) <= bytesRead - offset) {  								//TODO: change BlockCopy to "goto" statement  								Buffer.BlockCopy (state.buffer' offset' state.header' state.arrayOffset' len);  								offset += len;  								state.arrayOffset = 0;  								state.record.Version = state.header [0];  								state.record.Type = (RecordType)state.header [1];  								state.record.RequestId = (ushort)((state.header [2] << 8) + state.header [3]);  								state.record.BodyLength = (ushort)((state.header [4] << 8) + state.header [5]);  								state.record.PaddingLength = state.header [6];  								state.record.Body = new byte[state.record.BodyLength];  								//skip reserved field header[7]  								state.State = ReadState.Body;  								if (state.record.BodyLength == 0) {  									state.State = state.record.PaddingLength != 0 ? ReadState.Padding : ReadState.Header;  									if (state.State == ReadState.Header) {  										ProcessRecord (state.header'state.record.Body);  									}  								}  							} else {  								Buffer.BlockCopy (state.buffer' offset' state.header' state.arrayOffset' bytesRead - offset);  								state.arrayOffset += (bytesRead - offset);  								offset = bytesRead;  							}    						} else if (state.State == ReadState.Body) {  							int len;  							if ((len = state.record.BodyLength - state.arrayOffset) <= bytesRead - offset) {  								Buffer.BlockCopy (state.buffer' offset' state.record.Body' state.arrayOffset' len);  								offset += len;  								state.arrayOffset = 0;    								if (state.record.PaddingLength == 0) {  									state.State = ReadState.Header;  									ProcessRecord (state.header' state.record.Body);  								} else {  									state.State = ReadState.Padding;  								}  							} else {  								Buffer.BlockCopy (state.buffer' offset' state.record.Body' state.arrayOffset' bytesRead - offset);  								state.arrayOffset += (bytesRead - offset);  								offset = bytesRead;  							}  						} else if (state.State == ReadState.Padding) {  							if (state.record.PaddingLength - state.arrayOffset <= bytesRead - offset) {  								offset += state.record.PaddingLength - state.arrayOffset;  								state.State = ReadState.Header;  								//Process Record  								ProcessRecord (state.header' state.record.Body);  							} else {  								state.arrayOffset += bytesRead - offset;  								offset = bytesRead;  							}  						} else {  							//something wrong with packet  							Logger.Write (LogLevel.Error' "Wrong packet from HTTP server");   						}  					}  				}  				if (keepAlive || !stopReceive)  					client.BeginReceive (state.buffer' 0' state.buffer.Length' 0' asyncRecieveCallback' state);  			} catch (SocketException ex) {  				Logger.Write (LogLevel.Error' "ReceiveCallback. Socket error while receivieng data: {0}"' ex.Message);  				OnDisconnected ();  			} catch (ObjectDisposedException) {  				Logger.Write (LogLevel.Error' "ReceiveCallback. Socket was closed");  				OnDisconnected ();  			} catch (Exception ex) {  				Logger.Write (LogLevel.Error' "Unhandled exception in recv {0}"' ex);  				throw;  			}
Magic Number,HyperFastCgi.Listeners,FastCgiNetworkConnector,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Listeners\FastCgiNetworkConnector.cs,ProcessRecord,The following statement contains a magic number: if (debugEnabled) {  				Logger.Write (LogLevel.Debug' "cn={0} read header={1} reqId={2}"' cn' header [1]' (ushort)((header [2] << 8) + header [3]));  			}
Magic Number,HyperFastCgi.Listeners,FastCgiNetworkConnector,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Listeners\FastCgiNetworkConnector.cs,ProcessRecord,The following statement contains a magic number: if (debugEnabled) {  				Logger.Write (LogLevel.Debug' "cn={0} read header={1} reqId={2}"' cn' header [1]' (ushort)((header [2] << 8) + header [3]));  			}
Magic Number,HyperFastCgi.Listeners,FastCgiNetworkConnector,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Listeners\FastCgiNetworkConnector.cs,ProcessRecord,The following statement contains a magic number: if (debugEnabled) {  				Logger.Write (LogLevel.Debug' "cn={0} read header={1} reqId={2}"' cn' header [1]' (ushort)((header [2] << 8) + header [3]));  			}
Magic Number,HyperFastCgi.Transports,BaseManagedListenerTransport,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Transports\BaseManagedListenerTransport.cs,Process,The following statement contains a magic number: record.RequestId = (ushort)((header [2] << 8) + header [3]);
Magic Number,HyperFastCgi.Transports,BaseManagedListenerTransport,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Transports\BaseManagedListenerTransport.cs,Process,The following statement contains a magic number: record.RequestId = (ushort)((header [2] << 8) + header [3]);
Magic Number,HyperFastCgi.Transports,BaseManagedListenerTransport,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Transports\BaseManagedListenerTransport.cs,Process,The following statement contains a magic number: record.RequestId = (ushort)((header [2] << 8) + header [3]);
Magic Number,HyperFastCgi.Transports,BaseManagedListenerTransport,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Transports\BaseManagedListenerTransport.cs,Process,The following statement contains a magic number: record.BodyLength = (ushort)((header [4] << 8) + header [5]);
Magic Number,HyperFastCgi.Transports,BaseManagedListenerTransport,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Transports\BaseManagedListenerTransport.cs,Process,The following statement contains a magic number: record.BodyLength = (ushort)((header [4] << 8) + header [5]);
Magic Number,HyperFastCgi.Transports,BaseManagedListenerTransport,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Transports\BaseManagedListenerTransport.cs,Process,The following statement contains a magic number: record.BodyLength = (ushort)((header [4] << 8) + header [5]);
Magic Number,HyperFastCgi.Transports,BaseManagedListenerTransport,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Transports\BaseManagedListenerTransport.cs,Process,The following statement contains a magic number: record.PaddingLength = header [6];
Magic Number,HyperFastCgi.Transports,BaseManagedListenerTransport,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Transports\BaseManagedListenerTransport.cs,Process,The following statement contains a magic number: if (debugEnabled) {  				Logger.Write (LogLevel.Debug' "lt={0} LT::ProcessRecord0 header={1} reqId={2}"' listenerTag'  					record.Type' (ushort)((header [2] << 8) + header [3]));  			}
Magic Number,HyperFastCgi.Transports,BaseManagedListenerTransport,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Transports\BaseManagedListenerTransport.cs,Process,The following statement contains a magic number: if (debugEnabled) {  				Logger.Write (LogLevel.Debug' "lt={0} LT::ProcessRecord0 header={1} reqId={2}"' listenerTag'  					record.Type' (ushort)((header [2] << 8) + header [3]));  			}
Magic Number,HyperFastCgi.Transports,BaseManagedListenerTransport,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Transports\BaseManagedListenerTransport.cs,Process,The following statement contains a magic number: if (debugEnabled) {  				Logger.Write (LogLevel.Debug' "lt={0} LT::ProcessRecord0 header={1} reqId={2}"' listenerTag'  					record.Type' (ushort)((header [2] << 8) + header [3]));  			}
Magic Number,HyperFastCgi.Transports,BaseManagedListenerTransport,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Transports\BaseManagedListenerTransport.cs,Process,The following statement contains a magic number: ulong hash = ((ulong)record.RequestId << 32) ^ listenerTag;
Magic Number,HyperFastCgi.Transports,BaseManagedListenerTransport,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Transports\BaseManagedListenerTransport.cs,Process,The following statement contains a magic number: if (request == null && record.Type == RecordType.BeginRequest) {  				BeginRequestBody brb = new BeginRequestBody (recordBody);  				TransportRequest req = new TransportRequest (record.RequestId);  				req.Hash = ((ulong)record.RequestId << 32) ^ listenerTag;  				req.fd = (uint)listenerTag;  				req.KeepAlive = (brb.Flags & BeginRequestFlags.KeepAlive) == BeginRequestFlags.KeepAlive;  				AddRequest (req);    				//try to find single app route  				GetRoute (req' null' -1' null);  				if (IsHostFound(req)) {  					CreateRequest (req);  				}    				FastCgiNetworkConnector connector = FastCgiNetworkConnector.GetConnector (req.fd);  				if (connector != null) {  					connector.KeepAlive = req.KeepAlive;  				}  				return stopReceive;  			}
Magic Number,HyperFastCgi.Transports,BaseManagedListenerTransport,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Transports\BaseManagedListenerTransport.cs,Process,The following statement contains a magic number: if (request != null) {  				switch (record.Type) {  				case RecordType.BeginRequest:  					break;  				case RecordType.Params:  					if (header != null) {  						if (debugEnabled) {  							Logger.Write (LogLevel.Debug' "lt={0} LT::ProcessRecord header={1} reqId={2}"' listenerTag'  								header [1]' (ushort)((header [2] << 8) + header [3]));  						}  					}    					if (recordBody != null) {  						FcgiUtils.ParseParameters (recordBody' AddHeader' request);  					} else {  						//FIXME: request.Host can be null  						HeadersSent (request);  					}    					if (debugEnabled) {  						Logger.Write (LogLevel.Debug' "lt={0} LT::ProcessRecord header={1} reqId={2}"' listenerTag'  							header [1]' (ushort)((header [2] << 8) + header [3]));  					}  					break;  				case RecordType.StandardInput:  						//Ready to process  					if (debugEnabled) {  						Logger.Write (LogLevel.Debug' "lt={0} LT::ProcessRecord header={1} reqId={2}"' listenerTag'  							header [1]' (ushort)((header [2] << 8) + header [3]));  					}  					bool final = record.BodyLength == 0;  					AddBodyPart (request' recordBody' final);  					if (final) {  						stopReceive = true;  						Process (request);  					}  					break;  				case RecordType.Data:  					break;  				case RecordType.GetValues:  					//TODO: return server values  					break;  				// Aborts a request when the server aborts.  				//TODO: make Thread.Abort for request  				case RecordType.AbortRequest:  					//FIXME: send it to the HostTransport as is  					//TODO: send error to Connector  					//TODO: send EndRequest to Connector  					//					SendError (request.RequestId' Strings.Connection_AbortRecordReceived);  					//					EndRequest (request.RequestId' -1' ProtocolStatus.RequestComplete);  					break;    				default:  				//TODO: CgiConnector.SendRecord  				//				SendRecord (new Record (Record.ProtocolVersion'  				//					RecordType.UnknownType'  				//					request.RequestId'  				//					new UnknownTypeBody (record.Type).GetData ()));  					break;  				}  			}
Magic Number,HyperFastCgi.Transports,BaseManagedListenerTransport,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Transports\BaseManagedListenerTransport.cs,Process,The following statement contains a magic number: if (request != null) {  				switch (record.Type) {  				case RecordType.BeginRequest:  					break;  				case RecordType.Params:  					if (header != null) {  						if (debugEnabled) {  							Logger.Write (LogLevel.Debug' "lt={0} LT::ProcessRecord header={1} reqId={2}"' listenerTag'  								header [1]' (ushort)((header [2] << 8) + header [3]));  						}  					}    					if (recordBody != null) {  						FcgiUtils.ParseParameters (recordBody' AddHeader' request);  					} else {  						//FIXME: request.Host can be null  						HeadersSent (request);  					}    					if (debugEnabled) {  						Logger.Write (LogLevel.Debug' "lt={0} LT::ProcessRecord header={1} reqId={2}"' listenerTag'  							header [1]' (ushort)((header [2] << 8) + header [3]));  					}  					break;  				case RecordType.StandardInput:  						//Ready to process  					if (debugEnabled) {  						Logger.Write (LogLevel.Debug' "lt={0} LT::ProcessRecord header={1} reqId={2}"' listenerTag'  							header [1]' (ushort)((header [2] << 8) + header [3]));  					}  					bool final = record.BodyLength == 0;  					AddBodyPart (request' recordBody' final);  					if (final) {  						stopReceive = true;  						Process (request);  					}  					break;  				case RecordType.Data:  					break;  				case RecordType.GetValues:  					//TODO: return server values  					break;  				// Aborts a request when the server aborts.  				//TODO: make Thread.Abort for request  				case RecordType.AbortRequest:  					//FIXME: send it to the HostTransport as is  					//TODO: send error to Connector  					//TODO: send EndRequest to Connector  					//					SendError (request.RequestId' Strings.Connection_AbortRecordReceived);  					//					EndRequest (request.RequestId' -1' ProtocolStatus.RequestComplete);  					break;    				default:  				//TODO: CgiConnector.SendRecord  				//				SendRecord (new Record (Record.ProtocolVersion'  				//					RecordType.UnknownType'  				//					request.RequestId'  				//					new UnknownTypeBody (record.Type).GetData ()));  					break;  				}  			}
Magic Number,HyperFastCgi.Transports,BaseManagedListenerTransport,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Transports\BaseManagedListenerTransport.cs,Process,The following statement contains a magic number: if (request != null) {  				switch (record.Type) {  				case RecordType.BeginRequest:  					break;  				case RecordType.Params:  					if (header != null) {  						if (debugEnabled) {  							Logger.Write (LogLevel.Debug' "lt={0} LT::ProcessRecord header={1} reqId={2}"' listenerTag'  								header [1]' (ushort)((header [2] << 8) + header [3]));  						}  					}    					if (recordBody != null) {  						FcgiUtils.ParseParameters (recordBody' AddHeader' request);  					} else {  						//FIXME: request.Host can be null  						HeadersSent (request);  					}    					if (debugEnabled) {  						Logger.Write (LogLevel.Debug' "lt={0} LT::ProcessRecord header={1} reqId={2}"' listenerTag'  							header [1]' (ushort)((header [2] << 8) + header [3]));  					}  					break;  				case RecordType.StandardInput:  						//Ready to process  					if (debugEnabled) {  						Logger.Write (LogLevel.Debug' "lt={0} LT::ProcessRecord header={1} reqId={2}"' listenerTag'  							header [1]' (ushort)((header [2] << 8) + header [3]));  					}  					bool final = record.BodyLength == 0;  					AddBodyPart (request' recordBody' final);  					if (final) {  						stopReceive = true;  						Process (request);  					}  					break;  				case RecordType.Data:  					break;  				case RecordType.GetValues:  					//TODO: return server values  					break;  				// Aborts a request when the server aborts.  				//TODO: make Thread.Abort for request  				case RecordType.AbortRequest:  					//FIXME: send it to the HostTransport as is  					//TODO: send error to Connector  					//TODO: send EndRequest to Connector  					//					SendError (request.RequestId' Strings.Connection_AbortRecordReceived);  					//					EndRequest (request.RequestId' -1' ProtocolStatus.RequestComplete);  					break;    				default:  				//TODO: CgiConnector.SendRecord  				//				SendRecord (new Record (Record.ProtocolVersion'  				//					RecordType.UnknownType'  				//					request.RequestId'  				//					new UnknownTypeBody (record.Type).GetData ()));  					break;  				}  			}
Magic Number,HyperFastCgi.Transports,BaseManagedListenerTransport,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Transports\BaseManagedListenerTransport.cs,Process,The following statement contains a magic number: if (request != null) {  				switch (record.Type) {  				case RecordType.BeginRequest:  					break;  				case RecordType.Params:  					if (header != null) {  						if (debugEnabled) {  							Logger.Write (LogLevel.Debug' "lt={0} LT::ProcessRecord header={1} reqId={2}"' listenerTag'  								header [1]' (ushort)((header [2] << 8) + header [3]));  						}  					}    					if (recordBody != null) {  						FcgiUtils.ParseParameters (recordBody' AddHeader' request);  					} else {  						//FIXME: request.Host can be null  						HeadersSent (request);  					}    					if (debugEnabled) {  						Logger.Write (LogLevel.Debug' "lt={0} LT::ProcessRecord header={1} reqId={2}"' listenerTag'  							header [1]' (ushort)((header [2] << 8) + header [3]));  					}  					break;  				case RecordType.StandardInput:  						//Ready to process  					if (debugEnabled) {  						Logger.Write (LogLevel.Debug' "lt={0} LT::ProcessRecord header={1} reqId={2}"' listenerTag'  							header [1]' (ushort)((header [2] << 8) + header [3]));  					}  					bool final = record.BodyLength == 0;  					AddBodyPart (request' recordBody' final);  					if (final) {  						stopReceive = true;  						Process (request);  					}  					break;  				case RecordType.Data:  					break;  				case RecordType.GetValues:  					//TODO: return server values  					break;  				// Aborts a request when the server aborts.  				//TODO: make Thread.Abort for request  				case RecordType.AbortRequest:  					//FIXME: send it to the HostTransport as is  					//TODO: send error to Connector  					//TODO: send EndRequest to Connector  					//					SendError (request.RequestId' Strings.Connection_AbortRecordReceived);  					//					EndRequest (request.RequestId' -1' ProtocolStatus.RequestComplete);  					break;    				default:  				//TODO: CgiConnector.SendRecord  				//				SendRecord (new Record (Record.ProtocolVersion'  				//					RecordType.UnknownType'  				//					request.RequestId'  				//					new UnknownTypeBody (record.Type).GetData ()));  					break;  				}  			}
Magic Number,HyperFastCgi.Transports,BaseManagedListenerTransport,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Transports\BaseManagedListenerTransport.cs,Process,The following statement contains a magic number: if (request != null) {  				switch (record.Type) {  				case RecordType.BeginRequest:  					break;  				case RecordType.Params:  					if (header != null) {  						if (debugEnabled) {  							Logger.Write (LogLevel.Debug' "lt={0} LT::ProcessRecord header={1} reqId={2}"' listenerTag'  								header [1]' (ushort)((header [2] << 8) + header [3]));  						}  					}    					if (recordBody != null) {  						FcgiUtils.ParseParameters (recordBody' AddHeader' request);  					} else {  						//FIXME: request.Host can be null  						HeadersSent (request);  					}    					if (debugEnabled) {  						Logger.Write (LogLevel.Debug' "lt={0} LT::ProcessRecord header={1} reqId={2}"' listenerTag'  							header [1]' (ushort)((header [2] << 8) + header [3]));  					}  					break;  				case RecordType.StandardInput:  						//Ready to process  					if (debugEnabled) {  						Logger.Write (LogLevel.Debug' "lt={0} LT::ProcessRecord header={1} reqId={2}"' listenerTag'  							header [1]' (ushort)((header [2] << 8) + header [3]));  					}  					bool final = record.BodyLength == 0;  					AddBodyPart (request' recordBody' final);  					if (final) {  						stopReceive = true;  						Process (request);  					}  					break;  				case RecordType.Data:  					break;  				case RecordType.GetValues:  					//TODO: return server values  					break;  				// Aborts a request when the server aborts.  				//TODO: make Thread.Abort for request  				case RecordType.AbortRequest:  					//FIXME: send it to the HostTransport as is  					//TODO: send error to Connector  					//TODO: send EndRequest to Connector  					//					SendError (request.RequestId' Strings.Connection_AbortRecordReceived);  					//					EndRequest (request.RequestId' -1' ProtocolStatus.RequestComplete);  					break;    				default:  				//TODO: CgiConnector.SendRecord  				//				SendRecord (new Record (Record.ProtocolVersion'  				//					RecordType.UnknownType'  				//					request.RequestId'  				//					new UnknownTypeBody (record.Type).GetData ()));  					break;  				}  			}
Magic Number,HyperFastCgi.Transports,BaseManagedListenerTransport,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Transports\BaseManagedListenerTransport.cs,Process,The following statement contains a magic number: if (request != null) {  				switch (record.Type) {  				case RecordType.BeginRequest:  					break;  				case RecordType.Params:  					if (header != null) {  						if (debugEnabled) {  							Logger.Write (LogLevel.Debug' "lt={0} LT::ProcessRecord header={1} reqId={2}"' listenerTag'  								header [1]' (ushort)((header [2] << 8) + header [3]));  						}  					}    					if (recordBody != null) {  						FcgiUtils.ParseParameters (recordBody' AddHeader' request);  					} else {  						//FIXME: request.Host can be null  						HeadersSent (request);  					}    					if (debugEnabled) {  						Logger.Write (LogLevel.Debug' "lt={0} LT::ProcessRecord header={1} reqId={2}"' listenerTag'  							header [1]' (ushort)((header [2] << 8) + header [3]));  					}  					break;  				case RecordType.StandardInput:  						//Ready to process  					if (debugEnabled) {  						Logger.Write (LogLevel.Debug' "lt={0} LT::ProcessRecord header={1} reqId={2}"' listenerTag'  							header [1]' (ushort)((header [2] << 8) + header [3]));  					}  					bool final = record.BodyLength == 0;  					AddBodyPart (request' recordBody' final);  					if (final) {  						stopReceive = true;  						Process (request);  					}  					break;  				case RecordType.Data:  					break;  				case RecordType.GetValues:  					//TODO: return server values  					break;  				// Aborts a request when the server aborts.  				//TODO: make Thread.Abort for request  				case RecordType.AbortRequest:  					//FIXME: send it to the HostTransport as is  					//TODO: send error to Connector  					//TODO: send EndRequest to Connector  					//					SendError (request.RequestId' Strings.Connection_AbortRecordReceived);  					//					EndRequest (request.RequestId' -1' ProtocolStatus.RequestComplete);  					break;    				default:  				//TODO: CgiConnector.SendRecord  				//				SendRecord (new Record (Record.ProtocolVersion'  				//					RecordType.UnknownType'  				//					request.RequestId'  				//					new UnknownTypeBody (record.Type).GetData ()));  					break;  				}  			}
Magic Number,HyperFastCgi.Transports,BaseManagedListenerTransport,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Transports\BaseManagedListenerTransport.cs,Process,The following statement contains a magic number: if (request != null) {  				switch (record.Type) {  				case RecordType.BeginRequest:  					break;  				case RecordType.Params:  					if (header != null) {  						if (debugEnabled) {  							Logger.Write (LogLevel.Debug' "lt={0} LT::ProcessRecord header={1} reqId={2}"' listenerTag'  								header [1]' (ushort)((header [2] << 8) + header [3]));  						}  					}    					if (recordBody != null) {  						FcgiUtils.ParseParameters (recordBody' AddHeader' request);  					} else {  						//FIXME: request.Host can be null  						HeadersSent (request);  					}    					if (debugEnabled) {  						Logger.Write (LogLevel.Debug' "lt={0} LT::ProcessRecord header={1} reqId={2}"' listenerTag'  							header [1]' (ushort)((header [2] << 8) + header [3]));  					}  					break;  				case RecordType.StandardInput:  						//Ready to process  					if (debugEnabled) {  						Logger.Write (LogLevel.Debug' "lt={0} LT::ProcessRecord header={1} reqId={2}"' listenerTag'  							header [1]' (ushort)((header [2] << 8) + header [3]));  					}  					bool final = record.BodyLength == 0;  					AddBodyPart (request' recordBody' final);  					if (final) {  						stopReceive = true;  						Process (request);  					}  					break;  				case RecordType.Data:  					break;  				case RecordType.GetValues:  					//TODO: return server values  					break;  				// Aborts a request when the server aborts.  				//TODO: make Thread.Abort for request  				case RecordType.AbortRequest:  					//FIXME: send it to the HostTransport as is  					//TODO: send error to Connector  					//TODO: send EndRequest to Connector  					//					SendError (request.RequestId' Strings.Connection_AbortRecordReceived);  					//					EndRequest (request.RequestId' -1' ProtocolStatus.RequestComplete);  					break;    				default:  				//TODO: CgiConnector.SendRecord  				//				SendRecord (new Record (Record.ProtocolVersion'  				//					RecordType.UnknownType'  				//					request.RequestId'  				//					new UnknownTypeBody (record.Type).GetData ()));  					break;  				}  			}
Magic Number,HyperFastCgi.Transports,BaseManagedListenerTransport,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Transports\BaseManagedListenerTransport.cs,Process,The following statement contains a magic number: if (request != null) {  				switch (record.Type) {  				case RecordType.BeginRequest:  					break;  				case RecordType.Params:  					if (header != null) {  						if (debugEnabled) {  							Logger.Write (LogLevel.Debug' "lt={0} LT::ProcessRecord header={1} reqId={2}"' listenerTag'  								header [1]' (ushort)((header [2] << 8) + header [3]));  						}  					}    					if (recordBody != null) {  						FcgiUtils.ParseParameters (recordBody' AddHeader' request);  					} else {  						//FIXME: request.Host can be null  						HeadersSent (request);  					}    					if (debugEnabled) {  						Logger.Write (LogLevel.Debug' "lt={0} LT::ProcessRecord header={1} reqId={2}"' listenerTag'  							header [1]' (ushort)((header [2] << 8) + header [3]));  					}  					break;  				case RecordType.StandardInput:  						//Ready to process  					if (debugEnabled) {  						Logger.Write (LogLevel.Debug' "lt={0} LT::ProcessRecord header={1} reqId={2}"' listenerTag'  							header [1]' (ushort)((header [2] << 8) + header [3]));  					}  					bool final = record.BodyLength == 0;  					AddBodyPart (request' recordBody' final);  					if (final) {  						stopReceive = true;  						Process (request);  					}  					break;  				case RecordType.Data:  					break;  				case RecordType.GetValues:  					//TODO: return server values  					break;  				// Aborts a request when the server aborts.  				//TODO: make Thread.Abort for request  				case RecordType.AbortRequest:  					//FIXME: send it to the HostTransport as is  					//TODO: send error to Connector  					//TODO: send EndRequest to Connector  					//					SendError (request.RequestId' Strings.Connection_AbortRecordReceived);  					//					EndRequest (request.RequestId' -1' ProtocolStatus.RequestComplete);  					break;    				default:  				//TODO: CgiConnector.SendRecord  				//				SendRecord (new Record (Record.ProtocolVersion'  				//					RecordType.UnknownType'  				//					request.RequestId'  				//					new UnknownTypeBody (record.Type).GetData ()));  					break;  				}  			}
Magic Number,HyperFastCgi.Transports,BaseManagedListenerTransport,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Transports\BaseManagedListenerTransport.cs,Process,The following statement contains a magic number: if (request != null) {  				switch (record.Type) {  				case RecordType.BeginRequest:  					break;  				case RecordType.Params:  					if (header != null) {  						if (debugEnabled) {  							Logger.Write (LogLevel.Debug' "lt={0} LT::ProcessRecord header={1} reqId={2}"' listenerTag'  								header [1]' (ushort)((header [2] << 8) + header [3]));  						}  					}    					if (recordBody != null) {  						FcgiUtils.ParseParameters (recordBody' AddHeader' request);  					} else {  						//FIXME: request.Host can be null  						HeadersSent (request);  					}    					if (debugEnabled) {  						Logger.Write (LogLevel.Debug' "lt={0} LT::ProcessRecord header={1} reqId={2}"' listenerTag'  							header [1]' (ushort)((header [2] << 8) + header [3]));  					}  					break;  				case RecordType.StandardInput:  						//Ready to process  					if (debugEnabled) {  						Logger.Write (LogLevel.Debug' "lt={0} LT::ProcessRecord header={1} reqId={2}"' listenerTag'  							header [1]' (ushort)((header [2] << 8) + header [3]));  					}  					bool final = record.BodyLength == 0;  					AddBodyPart (request' recordBody' final);  					if (final) {  						stopReceive = true;  						Process (request);  					}  					break;  				case RecordType.Data:  					break;  				case RecordType.GetValues:  					//TODO: return server values  					break;  				// Aborts a request when the server aborts.  				//TODO: make Thread.Abort for request  				case RecordType.AbortRequest:  					//FIXME: send it to the HostTransport as is  					//TODO: send error to Connector  					//TODO: send EndRequest to Connector  					//					SendError (request.RequestId' Strings.Connection_AbortRecordReceived);  					//					EndRequest (request.RequestId' -1' ProtocolStatus.RequestComplete);  					break;    				default:  				//TODO: CgiConnector.SendRecord  				//				SendRecord (new Record (Record.ProtocolVersion'  				//					RecordType.UnknownType'  				//					request.RequestId'  				//					new UnknownTypeBody (record.Type).GetData ()));  					break;  				}  			}
Magic Number,HyperFastCgi.Transports,BaseManagedListenerTransport,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Transports\BaseManagedListenerTransport.cs,SendRecord,The following statement contains a magic number: header [2] = (byte)(requestID >> 8);
Magic Number,HyperFastCgi.Transports,BaseManagedListenerTransport,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Transports\BaseManagedListenerTransport.cs,SendRecord,The following statement contains a magic number: header [2] = (byte)(requestID >> 8);
Magic Number,HyperFastCgi.Transports,BaseManagedListenerTransport,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Transports\BaseManagedListenerTransport.cs,SendRecord,The following statement contains a magic number: header [3] = (byte)(requestID & 0xFF);
Magic Number,HyperFastCgi.Transports,BaseManagedListenerTransport,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Transports\BaseManagedListenerTransport.cs,SendRecord,The following statement contains a magic number: header [4] = (byte)(bodyLength >> 8);
Magic Number,HyperFastCgi.Transports,BaseManagedListenerTransport,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Transports\BaseManagedListenerTransport.cs,SendRecord,The following statement contains a magic number: header [4] = (byte)(bodyLength >> 8);
Magic Number,HyperFastCgi.Transports,BaseManagedListenerTransport,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Transports\BaseManagedListenerTransport.cs,SendRecord,The following statement contains a magic number: header [5] = (byte)(bodyLength & 0xFF);
Magic Number,HyperFastCgi.Transports,BaseManagedListenerTransport,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Transports\BaseManagedListenerTransport.cs,SendRecord,The following statement contains a magic number: header [6] = (byte)0;
Magic Number,HyperFastCgi.Transports,BaseManagedListenerTransport,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Transports\BaseManagedListenerTransport.cs,SendRecord,The following statement contains a magic number: if (connector != null) {  				//TODO: optimize it   				Record record = new Record ();  				record.Version = header [0];  				record.Type = (RecordType)header [1];  				record.RequestId = (ushort)((header [2] << 8) + header [3]);  				record.BodyLength = (ushort)((header [4] << 8) + header [5]);  				record.PaddingLength = header [6];  				record.Body = body;    				connector.SendRecord (record);  			}
Magic Number,HyperFastCgi.Transports,BaseManagedListenerTransport,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Transports\BaseManagedListenerTransport.cs,SendRecord,The following statement contains a magic number: if (connector != null) {  				//TODO: optimize it   				Record record = new Record ();  				record.Version = header [0];  				record.Type = (RecordType)header [1];  				record.RequestId = (ushort)((header [2] << 8) + header [3]);  				record.BodyLength = (ushort)((header [4] << 8) + header [5]);  				record.PaddingLength = header [6];  				record.Body = body;    				connector.SendRecord (record);  			}
Magic Number,HyperFastCgi.Transports,BaseManagedListenerTransport,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Transports\BaseManagedListenerTransport.cs,SendRecord,The following statement contains a magic number: if (connector != null) {  				//TODO: optimize it   				Record record = new Record ();  				record.Version = header [0];  				record.Type = (RecordType)header [1];  				record.RequestId = (ushort)((header [2] << 8) + header [3]);  				record.BodyLength = (ushort)((header [4] << 8) + header [5]);  				record.PaddingLength = header [6];  				record.Body = body;    				connector.SendRecord (record);  			}
Magic Number,HyperFastCgi.Transports,BaseManagedListenerTransport,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Transports\BaseManagedListenerTransport.cs,SendRecord,The following statement contains a magic number: if (connector != null) {  				//TODO: optimize it   				Record record = new Record ();  				record.Version = header [0];  				record.Type = (RecordType)header [1];  				record.RequestId = (ushort)((header [2] << 8) + header [3]);  				record.BodyLength = (ushort)((header [4] << 8) + header [5]);  				record.PaddingLength = header [6];  				record.Body = body;    				connector.SendRecord (record);  			}
Magic Number,HyperFastCgi.Transports,BaseManagedListenerTransport,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Transports\BaseManagedListenerTransport.cs,SendRecord,The following statement contains a magic number: if (connector != null) {  				//TODO: optimize it   				Record record = new Record ();  				record.Version = header [0];  				record.Type = (RecordType)header [1];  				record.RequestId = (ushort)((header [2] << 8) + header [3]);  				record.BodyLength = (ushort)((header [4] << 8) + header [5]);  				record.PaddingLength = header [6];  				record.Body = body;    				connector.SendRecord (record);  			}
Magic Number,HyperFastCgi.Transports,BaseManagedListenerTransport,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Transports\BaseManagedListenerTransport.cs,SendRecord,The following statement contains a magic number: if (connector != null) {  				//TODO: optimize it   				Record record = new Record ();  				record.Version = header [0];  				record.Type = (RecordType)header [1];  				record.RequestId = (ushort)((header [2] << 8) + header [3]);  				record.BodyLength = (ushort)((header [4] << 8) + header [5]);  				record.PaddingLength = header [6];  				record.Body = body;    				connector.SendRecord (record);  			}
Magic Number,HyperFastCgi.Transports,BaseManagedListenerTransport,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Transports\BaseManagedListenerTransport.cs,SendRecord,The following statement contains a magic number: if (connector != null) {  				//TODO: optimize it   				Record record = new Record ();  				record.Version = header [0];  				record.Type = (RecordType)header [1];  				record.RequestId = (ushort)((header [2] << 8) + header [3]);  				record.BodyLength = (ushort)((header [4] << 8) + header [5]);  				record.PaddingLength = header [6];  				record.Body = body;    				connector.SendRecord (record);  			}
Magic Number,HyperFastCgi.Helpers.FastCgiProtocol,BeginRequestBody,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Helpers\FastCgiProtocol\BeginRequestBody.cs,BeginRequestBody,The following statement contains a magic number: if (record.BodyLength != 8)  				throw new ArgumentException (  					Strings.BeginRequestBody_WrongSize' "record");
Magic Number,HyperFastCgi.Helpers.FastCgiProtocol,BeginRequestBody,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Helpers\FastCgiProtocol\BeginRequestBody.cs,BeginRequestBody,The following statement contains a magic number: flags = (BeginRequestFlags)body [2];
Magic Number,HyperFastCgi.Helpers.FastCgiProtocol,BeginRequestBody,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Helpers\FastCgiProtocol\BeginRequestBody.cs,BeginRequestBody,The following statement contains a magic number: flags = (BeginRequestFlags)body [2];
Magic Number,HyperFastCgi.Helpers.FastCgiProtocol,EndRequestBody,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Helpers\FastCgiProtocol\EndRequestBody.cs,GetData,The following statement contains a magic number: byte[] data = new byte [8];
Magic Number,HyperFastCgi.Helpers.FastCgiProtocol,EndRequestBody,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Helpers\FastCgiProtocol\EndRequestBody.cs,GetData,The following statement contains a magic number: data [0] = (byte)((app >> 24) & 0xFF);
Magic Number,HyperFastCgi.Helpers.FastCgiProtocol,EndRequestBody,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Helpers\FastCgiProtocol\EndRequestBody.cs,GetData,The following statement contains a magic number: data [1] = (byte)((app >> 16) & 0xFF);
Magic Number,HyperFastCgi.Helpers.FastCgiProtocol,EndRequestBody,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Helpers\FastCgiProtocol\EndRequestBody.cs,GetData,The following statement contains a magic number: data [2] = (byte)((app >> 8) & 0xFF);
Magic Number,HyperFastCgi.Helpers.FastCgiProtocol,EndRequestBody,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Helpers\FastCgiProtocol\EndRequestBody.cs,GetData,The following statement contains a magic number: data [2] = (byte)((app >> 8) & 0xFF);
Magic Number,HyperFastCgi.Helpers.FastCgiProtocol,EndRequestBody,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Helpers\FastCgiProtocol\EndRequestBody.cs,GetData,The following statement contains a magic number: data [3] = (byte)((app) & 0xFF);
Magic Number,HyperFastCgi.Helpers.FastCgiProtocol,EndRequestBody,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Helpers\FastCgiProtocol\EndRequestBody.cs,GetData,The following statement contains a magic number: data [4] = (byte)protocol_status;
Magic Number,HyperFastCgi.Helpers.FastCgiProtocol,FcgiUtils,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Helpers\FastCgiProtocol\FcgiUtils.cs,ReformatHttpHeader,The following statement contains a magic number: if (name.StartsWith ("HTTP_"' StringComparison.Ordinal)) {  				char[] header = new char[name.Length - 5];    				// "HTTP_".Length  				int i = 5;  				bool upperCase = true;    				while (i < name.Length) {  					if (name [i] == '_') {  						header [i - 5] = '-';  						upperCase = true;  					} else {  						header [i - 5] = (upperCase) ? name [i] : char.ToLower (name [i]);  						upperCase = false;  					}  					i++;   				}    				return new string (header);  			}
Magic Number,HyperFastCgi.Helpers.FastCgiProtocol,FcgiUtils,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Helpers\FastCgiProtocol\FcgiUtils.cs,ReformatHttpHeader,The following statement contains a magic number: if (name.StartsWith ("HTTP_"' StringComparison.Ordinal)) {  				char[] header = new char[name.Length - 5];    				// "HTTP_".Length  				int i = 5;  				bool upperCase = true;    				while (i < name.Length) {  					if (name [i] == '_') {  						header [i - 5] = '-';  						upperCase = true;  					} else {  						header [i - 5] = (upperCase) ? name [i] : char.ToLower (name [i]);  						upperCase = false;  					}  					i++;   				}    				return new string (header);  			}
Magic Number,HyperFastCgi.Helpers.FastCgiProtocol,FcgiUtils,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Helpers\FastCgiProtocol\FcgiUtils.cs,ReformatHttpHeader,The following statement contains a magic number: if (name.StartsWith ("HTTP_"' StringComparison.Ordinal)) {  				char[] header = new char[name.Length - 5];    				// "HTTP_".Length  				int i = 5;  				bool upperCase = true;    				while (i < name.Length) {  					if (name [i] == '_') {  						header [i - 5] = '-';  						upperCase = true;  					} else {  						header [i - 5] = (upperCase) ? name [i] : char.ToLower (name [i]);  						upperCase = false;  					}  					i++;   				}    				return new string (header);  			}
Magic Number,HyperFastCgi.Helpers.FastCgiProtocol,FcgiUtils,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Helpers\FastCgiProtocol\FcgiUtils.cs,ReformatHttpHeader,The following statement contains a magic number: if (name.StartsWith ("HTTP_"' StringComparison.Ordinal)) {  				char[] header = new char[name.Length - 5];    				// "HTTP_".Length  				int i = 5;  				bool upperCase = true;    				while (i < name.Length) {  					if (name [i] == '_') {  						header [i - 5] = '-';  						upperCase = true;  					} else {  						header [i - 5] = (upperCase) ? name [i] : char.ToLower (name [i]);  						upperCase = false;  					}  					i++;   				}    				return new string (header);  			}
Magic Number,HyperFastCgi.Helpers.FastCgiProtocol,Record,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Helpers\FastCgiProtocol\Record.cs,ReadUInt16,The following statement contains a magic number: value = (ushort)(value << 8);
Magic Number,HyperFastCgi.Helpers.FastCgiProtocol,Record,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Helpers\FastCgiProtocol\Record.cs,GetRecord,The following statement contains a magic number: buffer [2] = (byte)(RequestId >> 8);
Magic Number,HyperFastCgi.Helpers.FastCgiProtocol,Record,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Helpers\FastCgiProtocol\Record.cs,GetRecord,The following statement contains a magic number: buffer [2] = (byte)(RequestId >> 8);
Magic Number,HyperFastCgi.Helpers.FastCgiProtocol,Record,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Helpers\FastCgiProtocol\Record.cs,GetRecord,The following statement contains a magic number: buffer [3] = (byte)(RequestId & 0xff);
Magic Number,HyperFastCgi.Helpers.FastCgiProtocol,Record,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Helpers\FastCgiProtocol\Record.cs,GetRecord,The following statement contains a magic number: buffer [4] = (byte)(BodyLength >> 8);
Magic Number,HyperFastCgi.Helpers.FastCgiProtocol,Record,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Helpers\FastCgiProtocol\Record.cs,GetRecord,The following statement contains a magic number: buffer [4] = (byte)(BodyLength >> 8);
Magic Number,HyperFastCgi.Helpers.FastCgiProtocol,Record,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Helpers\FastCgiProtocol\Record.cs,GetRecord,The following statement contains a magic number: buffer [5] = (byte)(BodyLength & 0xff);
Magic Number,HyperFastCgi.Helpers.FastCgiProtocol,Record,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Helpers\FastCgiProtocol\Record.cs,GetRecord,The following statement contains a magic number: buffer [6] = PaddingLength;
Magic Number,HyperFastCgi.Helpers.FastCgiProtocol,UnknownTypeBody,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Helpers\FastCgiProtocol\UnknownTypeBody.cs,GetData,The following statement contains a magic number: byte[] data = new byte [8];
Magic Number,Mono.WebServer,VPathToHost,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Helpers\Mono.WebServer\VPathToHost.cs,VPathToHost,The following statement contains a magic number: if (vhost != null && this.vhost.Length != 0 && this.vhost [0] == '*') {  				haveWildcard = true;  				if (this.vhost.Length > 2 && this.vhost [1] == '.')  					this.vhost = this.vhost.Substring (2);  			}
Magic Number,Mono.WebServer,VPathToHost,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Helpers\Mono.WebServer\VPathToHost.cs,VPathToHost,The following statement contains a magic number: if (vhost != null && this.vhost.Length != 0 && this.vhost [0] == '*') {  				haveWildcard = true;  				if (this.vhost.Length > 2 && this.vhost [1] == '.')  					this.vhost = this.vhost.Substring (2);  			}
Missing Default,HyperFastCgi.Configuration,ConfigurationManager,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Configuration\ConfigurationManager.cs,RenderXml,The following switch statement is missing a default case: switch (node.LocalName) {  				case "para":  					RenderXml (child' values' indent' length);  					values.Add (string.Empty);  					break;  				case "block":  					RenderXml (child' values' indent + 4' length);  					break;  				case "example":  					RenderXml (child' values' indent + 4' length);  					values.Add (string.Empty);  					break;  				case "code":  				case "desc":  					RenderXml (child' values' indent' length);  					break;  				case "#text":  					RenderText (node.Value' values' indent' length);  					break;  				}
Missing Default,HyperFastCgi.AppHosts.AspNet,MonoWorkerRequest,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\AppHosts\AspNet\MonoWorkerRequest.cs,MapPath,The following switch statement is missing a default case: switch (path [0]) {  			case '~':  				if (path.Length >= 2 && path [1] == '/')  					path = path.Substring (1);  				break;    			case '/':  				if (!inThisApp)  					basePath = HostPhysicalRoot;  				break;  			}
Missing Default,HyperFastCgi.AppHosts.AspNet,MonoWorkerRequest,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\AppHosts\AspNet\MonoWorkerRequest.cs,GetServerVariable,The following switch statement is missing a default case: switch (name) {  				case "CERT_COOKIE":  					if (cert_cookie == null) {  						if (client == null)  							cert_cookie = String.Empty;  						else  							cert_cookie = client.GetCertHashString ();  					}  					return cert_cookie;  				case "CERT_ISSUER":  					if (cert_issuer == null) {  						if (client == null)  							cert_issuer = String.Empty;  						else  							cert_issuer = client.Issuer;  					}  					return cert_issuer;  				case "CERT_SERIALNUMBER":  					if (cert_serial == null) {  						if (client == null)  							cert_serial = String.Empty;  						else  							cert_serial = client.GetSerialNumberString ();  					}  					return cert_serial;  				case "CERT_SUBJECT":  					if (cert_subject == null) {  						if (client == null)  							cert_subject = String.Empty;  						else  							cert_subject = client.Subject;  					}  					return cert_subject;  				}
Missing Default,HyperFastCgi.Listeners,ManagedFastCgiListener,C:\repos\xplicit_HyperFastCgi\src\HyperFastCgi\Listeners\ManagedFastCgiListener.cs,CreateSocket,The following switch statement is missing a default case: switch (sockType) {  			case AddressFamily.Unix:  				socket = new UnixSocket (address);  				break;  			case AddressFamily.InterNetwork:  				IPEndPoint localEP = new IPEndPoint (IPAddress.Parse (address)' port);  				socket = new TcpSocket (localEP);  				break;  			}
