Implementation smell,Namespace,Class,File,Method,Description
Long Method,NetLua,LuaGrammar,D:\research\architectureSmells\repos\frabert_NetLua\NetLua\LuaGrammar.cs,LuaGrammar,The method has 166 lines of code.
Complex Method,NetLua,IoLibrary,D:\research\architectureSmells\repos\frabert_NetLua\NetLua\Libraries\IoLibrary.cs,read,Cyclomatic complexity of the method is 10
Complex Method,NetLua,Lua,D:\research\architectureSmells\repos\frabert_NetLua\NetLua\Lua.cs,type,Cyclomatic complexity of the method is 8
Complex Method,NetLua,LuaCompiler,D:\research\architectureSmells\repos\frabert_NetLua\NetLua\LuaCompiler.cs,CompileBinaryExpression,Cyclomatic complexity of the method is 16
Complex Method,NetLua,LuaCompiler,D:\research\architectureSmells\repos\frabert_NetLua\NetLua\LuaCompiler.cs,CompileExpression,Cyclomatic complexity of the method is 13
Complex Method,NetLua,LuaCompiler,D:\research\architectureSmells\repos\frabert_NetLua\NetLua\LuaCompiler.cs,CompileSingleExpression,Cyclomatic complexity of the method is 13
Complex Method,NetLua,LuaCompiler,D:\research\architectureSmells\repos\frabert_NetLua\NetLua\LuaCompiler.cs,CompileStatement,Cyclomatic complexity of the method is 12
Complex Method,NetLua,LuaObject,D:\research\architectureSmells\repos\frabert_NetLua\NetLua\LuaObject.cs,FromObject,Cyclomatic complexity of the method is 18
Complex Method,NetLua,Parser,D:\research\architectureSmells\repos\frabert_NetLua\NetLua\Parser.cs,ParseRelOp,Cyclomatic complexity of the method is 9
Complex Method,NetLua,Parser,D:\research\architectureSmells\repos\frabert_NetLua\NetLua\Parser.cs,ParseLocalAssign,Cyclomatic complexity of the method is 8
Complex Method,NetLua,Parser,D:\research\architectureSmells\repos\frabert_NetLua\NetLua\Parser.cs,ParseTableConstruct,Cyclomatic complexity of the method is 8
Complex Method,NetLua,Parser,D:\research\architectureSmells\repos\frabert_NetLua\NetLua\Parser.cs,ParseExpression,Cyclomatic complexity of the method is 15
Complex Method,NetLua,Parser,D:\research\architectureSmells\repos\frabert_NetLua\NetLua\Parser.cs,ParseBlock,Cyclomatic complexity of the method is 15
Complex Method,NetLua,Parser,D:\research\architectureSmells\repos\frabert_NetLua\NetLua\Parser.cs,ParseFor,Cyclomatic complexity of the method is 8
Long Statement,NetLua,IoLibrary,D:\research\architectureSmells\repos\frabert_NetLua\NetLua\Libraries\IoLibrary.cs,io_temp,The length of the statement  "            Stream s = new FileStream(path' FileMode.Append' FileAccess.Write' FileShare.Write' Int16.MaxValue' FileOptions.DeleteOnClose); " is 127.
Long Statement,NetLua,LuaCompiler,D:\research\architectureSmells\repos\frabert_NetLua\NetLua\LuaCompiler.cs,CompileTableConstructor,The length of the statement  "                    var check = Expression.IfThenElse(loopCondition' Expression.Block(addValue' incrementCounter)' Expression.Break(@break)); " is 121.
Long Statement,NetLua,LuaCompiler,D:\research\architectureSmells\repos\frabert_NetLua\NetLua\LuaCompiler.cs,CompileFunction,The length of the statement  "            var assignNames = Expression.Assign(names' Expression.Constant(Array.ConvertAll<Argument' string>(func.Arguments.ToArray()' x => x.Name))); " is 139.
Long Statement,NetLua,LuaCompiler,D:\research\architectureSmells\repos\frabert_NetLua\NetLua\LuaCompiler.cs,CompileFunction,The length of the statement  "            var innerIf = Expression.Call(scopeVar' LuaContext_SetLocal' Expression.ArrayAccess(names' i)' Expression.Property(args' "Item"' i)); " is 133.
Long Statement,NetLua,LuaCompiler,D:\research\architectureSmells\repos\frabert_NetLua\NetLua\LuaCompiler.cs,CompileFunction,The length of the statement  "            var outerIf = Expression.Block(Expression.IfThenElse(innerCond' innerIf' innerElse)' Expression.Assign(i' Expression.Add(i' Expression.Constant(1)))); " is 150.
Long Statement,NetLua,LuaCompiler,D:\research\architectureSmells\repos\frabert_NetLua\NetLua\LuaCompiler.cs,CompileIfStat,The length of the statement  "                    var elseBlock = CompileBlock(ifstat.ElseBlock' returnTarget' breakTarget' Expression.New(LuaContext_New_parent' Context)); " is 122.
Long Statement,NetLua,LuaCompiler,D:\research\architectureSmells\repos\frabert_NetLua\NetLua\LuaCompiler.cs,CompileIfStat,The length of the statement  "                            var elseBlock = CompileBlock(ifstat.ElseBlock' returnTarget' breakTarget' Expression.New(LuaContext_New_parent' Context)); " is 122.
Long Statement,NetLua,LuaCompiler,D:\research\architectureSmells\repos\frabert_NetLua\NetLua\LuaCompiler.cs,CompileNumericFor,The length of the statement  "            var check = Expression.IfThenElse(GetAsBool(condition)' Expression.Block(setLocalVar' innerBlock' sum)' Expression.Break(@break)); " is 130.
Long Statement,NetLua,Parser,D:\research\architectureSmells\repos\frabert_NetLua\NetLua\Parser.cs,ParseExpression,The length of the statement  "                    return new Ast.NumberLiteral() { Value = (child.Token.Value is double ? (double)(child.Token.Value) : (int)(child.Token.Value)) }; " is 130.
Complex Conditional,NetLua,LuaEvents,D:\research\architectureSmells\repos\frabert_NetLua\NetLua\LuaEvents.cs,concat_event,The conditional expression  "(op1.IsString || op1.IsNumber) && (op2.IsString || op2.IsNumber)"  is complex.
Magic Number,NetLua,IoLibrary,D:\research\architectureSmells\repos\frabert_NetLua\NetLua\Libraries\IoLibrary.cs,seek,The following statement contains a magic number: var offset = args[2] | 0;
Magic Number,NetLua,Lua,D:\research\architectureSmells\repos\frabert_NetLua\NetLua\Lua.cs,rawset,The following statement contains a magic number: LuaEvents.rawset(args[0]' args[1]' args[2]);
Magic Number,NetLua,LuaCompiler,D:\research\architectureSmells\repos\frabert_NetLua\NetLua\LuaCompiler.cs,CompileGenericFor,The following statement contains a magic number: var var = GetArgument(args' 2);
Magic Number,NetLua,Parser,D:\research\architectureSmells\repos\frabert_NetLua\NetLua\Parser.cs,ParseOopCall,The following statement contains a magic number: var root = node.ChildNodes[2].ChildNodes[0];
Magic Number,NetLua,Parser,D:\research\architectureSmells\repos\frabert_NetLua\NetLua\Parser.cs,ParseLocalAssign,The following statement contains a magic number: var argsNode = child.ChildNodes[2];
Magic Number,NetLua,Parser,D:\research\architectureSmells\repos\frabert_NetLua\NetLua\Parser.cs,ParseLocalAssign,The following statement contains a magic number: var blockNode = child.ChildNodes[3];
Magic Number,NetLua,Parser,D:\research\architectureSmells\repos\frabert_NetLua\NetLua\Parser.cs,ParseRepeat,The following statement contains a magic number: Ast.IExpression condition = ParseExpression(node.ChildNodes[3]);
Magic Number,NetLua,Parser,D:\research\architectureSmells\repos\frabert_NetLua\NetLua\Parser.cs,ParseWhile,The following statement contains a magic number: return new Ast.WhileStat()                  {                      Condition = ParseExpression(node.ChildNodes[1])'                      Block = ParseDoBlock(node.ChildNodes[2])                  };
Magic Number,NetLua,Parser,D:\research\architectureSmells\repos\frabert_NetLua\NetLua\Parser.cs,ParseIf,The following statement contains a magic number: Ast.Block block = ParseBlock(node.ChildNodes[3]);
Magic Number,NetLua,Parser,D:\research\architectureSmells\repos\frabert_NetLua\NetLua\Parser.cs,ParseIf,The following statement contains a magic number: ParseTreeNode ElseifNode = node.ChildNodes[4];
Magic Number,NetLua,Parser,D:\research\architectureSmells\repos\frabert_NetLua\NetLua\Parser.cs,ParseIf,The following statement contains a magic number: ParseTreeNode ElseNode = node.ChildNodes[5];
Magic Number,NetLua,Parser,D:\research\architectureSmells\repos\frabert_NetLua\NetLua\Parser.cs,ParseIf,The following statement contains a magic number: elseif.Block = ParseBlock(childnode.ChildNodes[3]);
Magic Number,NetLua,Parser,D:\research\architectureSmells\repos\frabert_NetLua\NetLua\Parser.cs,ParseIf,The following statement contains a magic number: ElseifNode = childnode.ChildNodes[4];
Magic Number,NetLua,Parser,D:\research\architectureSmells\repos\frabert_NetLua\NetLua\Parser.cs,ParseFunctionDecl,The following statement contains a magic number: ParseTreeNode argsNode = node.ChildNodes[3].ChildNodes[0];
Magic Number,NetLua,Parser,D:\research\architectureSmells\repos\frabert_NetLua\NetLua\Parser.cs,ParseFunctionDecl,The following statement contains a magic number: ParseTreeNode chunkNode = node.ChildNodes[4];
Magic Number,NetLua,Parser,D:\research\architectureSmells\repos\frabert_NetLua\NetLua\Parser.cs,ParseFunctionDecl,The following statement contains a magic number: var nameNode = node.ChildNodes[2];
Magic Number,NetLua,Parser,D:\research\architectureSmells\repos\frabert_NetLua\NetLua\Parser.cs,ParseFunctionDef,The following statement contains a magic number: ParseTreeNode chunkNode = node.ChildNodes[2];
Magic Number,NetLua,Parser,D:\research\architectureSmells\repos\frabert_NetLua\NetLua\Parser.cs,ParseFor,The following statement contains a magic number: var block = ParseDoBlock(node.ChildNodes[2]);
Magic Number,NetLua,Parser,D:\research\architectureSmells\repos\frabert_NetLua\NetLua\Parser.cs,ParseFor,The following statement contains a magic number: cycle.Limit = ParseExpression(type.ChildNodes[2]);
Magic Number,NetLua,Parser,D:\research\architectureSmells\repos\frabert_NetLua\NetLua\Parser.cs,ParseFor,The following statement contains a magic number: var child = type.ChildNodes[3].ChildNodes[0];
Magic Number,NetLua,Parser,D:\research\architectureSmells\repos\frabert_NetLua\NetLua\Parser.cs,ParseFor,The following statement contains a magic number: type.ChildNodes[3].ChildNodes.Count > 0
Missing Default,NetLua,IoLibrary,D:\research\architectureSmells\repos\frabert_NetLua\NetLua\Libraries\IoLibrary.cs,io_open,The following switch statement is missing a default case: switch (mode.ToString())                      {                          case "r":                              faccess = FileAccess.Read; break;                          case "w":                              fmode = FileMode.Create; faccess = FileAccess.ReadWrite; break;                          case "a":                              fmode = FileMode.Append; faccess = FileAccess.Write; break;                          case "r+":                          case "w+":                          case "a+":                              // TODO: Implement rwa+                              throw new NotImplementedException();                      }
Missing Default,NetLua,IoLibrary,D:\research\architectureSmells\repos\frabert_NetLua\NetLua\Libraries\IoLibrary.cs,seek,The following switch statement is missing a default case: switch (whence.ToString())                  {                      case "cur":                          fobj.stream.Position += (long)offset; break;                      case "set":                          fobj.stream.Position = (long)offset; break;                      case "end":                          fobj.stream.Position = fobj.stream.Length + (long)offset; break;                  }
Missing Default,NetLua,Lua,D:\research\architectureSmells\repos\frabert_NetLua\NetLua\Lua.cs,type,The following switch statement is missing a default case: switch (args[0].Type)              {                  case LuaType.boolean:                      return Return("boolean");                  case LuaType.function:                      return Return("function");                  case LuaType.nil:                      return Return("nil");                  case LuaType.number:                      return Return("number");                  case LuaType.@string:                      return Return("string");                  case LuaType.table:                      return Return("table");                  case LuaType.thread:                      return Return("thread");                  case LuaType.userdata:                      return Return("userdata");              }
Missing Default,NetLua,Parser,D:\research\architectureSmells\repos\frabert_NetLua\NetLua\Parser.cs,ParseUnaryExpr,The following switch statement is missing a default case: switch (opNode.Token.ValueString)                  {                      case "not":                          op = Ast.UnaryOp.Negate; break;                      case "-":                          op = Ast.UnaryOp.Invert; break;                      case "#":                          op = Ast.UnaryOp.Length; break;                  }
