Implementation smell,Namespace,Class,File,Method,Description
Long Method,NetLua,LuaGrammar,F:\newReposMay17\frabert_NetLua\NetLua\LuaGrammar.cs,LuaGrammar,The method has 114 lines of code.
Complex Method,NetLua,IoLibrary,F:\newReposMay17\frabert_NetLua\NetLua\Libraries\IoLibrary.cs,io_open,Cyclomatic complexity of the method is 16
Complex Method,NetLua,IoLibrary,F:\newReposMay17\frabert_NetLua\NetLua\Libraries\IoLibrary.cs,seek,Cyclomatic complexity of the method is 10
Complex Method,NetLua,IoLibrary,F:\newReposMay17\frabert_NetLua\NetLua\Libraries\IoLibrary.cs,read,Cyclomatic complexity of the method is 9
Complex Method,NetLua,Lua,F:\newReposMay17\frabert_NetLua\NetLua\Lua.cs,type,Cyclomatic complexity of the method is 8
Complex Method,NetLua,LuaCompiler,F:\newReposMay17\frabert_NetLua\NetLua\LuaCompiler.cs,CompileBinaryExpression,Cyclomatic complexity of the method is 17
Complex Method,NetLua,Parser,F:\newReposMay17\frabert_NetLua\NetLua\Parser.cs,ParseRelOp,Cyclomatic complexity of the method is 21
Complex Method,NetLua,Parser,F:\newReposMay17\frabert_NetLua\NetLua\Parser.cs,ParseAddOp,Cyclomatic complexity of the method is 9
Complex Method,NetLua,Parser,F:\newReposMay17\frabert_NetLua\NetLua\Parser.cs,ParseMulOp,Cyclomatic complexity of the method is 12
Complex Method,NetLua,Parser,F:\newReposMay17\frabert_NetLua\NetLua\Parser.cs,ParseLocalAssign,Cyclomatic complexity of the method is 8
Complex Method,NetLua,Parser,F:\newReposMay17\frabert_NetLua\NetLua\Parser.cs,ParseUnaryExpr,Cyclomatic complexity of the method is 10
Complex Method,NetLua,Parser,F:\newReposMay17\frabert_NetLua\NetLua\Parser.cs,ParseTableConstruct,Cyclomatic complexity of the method is 8
Complex Method,NetLua,Parser,F:\newReposMay17\frabert_NetLua\NetLua\Parser.cs,ParseExpression,Cyclomatic complexity of the method is 12
Complex Method,NetLua,Parser,F:\newReposMay17\frabert_NetLua\NetLua\Parser.cs,ParseBlock,Cyclomatic complexity of the method is 41
Complex Method,NetLua,Parser,F:\newReposMay17\frabert_NetLua\NetLua\Parser.cs,ParseFor,Cyclomatic complexity of the method is 8
Long Statement,NetLua,IoLibrary,F:\newReposMay17\frabert_NetLua\NetLua\Libraries\IoLibrary.cs,io_temp,The length of the statement  "	Stream s = new FileStream (path' FileMode.Append' FileAccess.Write' FileShare.Write' Int16.MaxValue' FileOptions.DeleteOnClose); " is 128.
Long Statement,NetLua,LuaCompiler,F:\newReposMay17\frabert_NetLua\NetLua\LuaCompiler.cs,CompileTableConstructor,The length of the statement  "			var addValue = Expression.Call (variable' add' Expression.Add (k' Expression.Call (LuaObject_Type.GetMethod ("FromNumber")' Expression.Convert (counter' typeof(double))))' Expression.Property (value' "Item"' counter)); " is 218.
Long Statement,NetLua,LuaCompiler,F:\newReposMay17\frabert_NetLua\NetLua\LuaCompiler.cs,CompileTableConstructor,The length of the statement  "			var check = Expression.IfThenElse (loopCondition' Expression.Block (addValue' incrementCounter)' Expression.Break (@break)); " is 124.
Long Statement,NetLua,LuaCompiler,F:\newReposMay17\frabert_NetLua\NetLua\LuaCompiler.cs,CompileFunction,The length of the statement  "	var assignNames = Expression.Assign (names' Expression.Constant (Array.ConvertAll<Argument' string> (func.Arguments.ToArray ()' x => x.Name))); " is 143.
Long Statement,NetLua,LuaCompiler,F:\newReposMay17\frabert_NetLua\NetLua\LuaCompiler.cs,CompileFunction,The length of the statement  "	var innerIf = Expression.Call (scopeVar' LuaContext_SetLocal' Expression.ArrayAccess (names' i)' Expression.Property (args' "Item"' i)); " is 136.
Long Statement,NetLua,LuaCompiler,F:\newReposMay17\frabert_NetLua\NetLua\LuaCompiler.cs,CompileFunction,The length of the statement  "	var outerIf = Expression.Block (Expression.IfThenElse (innerCond' innerIf' innerElse)' Expression.Assign (i' Expression.Add (i' Expression.Constant (1)))); " is 155.
Long Statement,NetLua,LuaCompiler,F:\newReposMay17\frabert_NetLua\NetLua\LuaCompiler.cs,CompileIfStat,The length of the statement  "			var elseBlock = CompileBlock (ifstat.ElseBlock' returnTarget' breakTarget' Expression.New (LuaContext_New_parent' Context)); " is 124.
Long Statement,NetLua,LuaCompiler,F:\newReposMay17\frabert_NetLua\NetLua\LuaCompiler.cs,CompileIfStat,The length of the statement  "					var elseBlock = CompileBlock (ifstat.ElseBlock' returnTarget' breakTarget' Expression.New (LuaContext_New_parent' Context)); " is 124.
Long Statement,NetLua,LuaCompiler,F:\newReposMay17\frabert_NetLua\NetLua\LuaCompiler.cs,CompileNumericFor,The length of the statement  "	var condition = Expression.Or (Expression.And (Expression.GreaterThan (step' Expression.Constant ((LuaObject)0))' Expression.LessThanOrEqual (var' limit))' Expression.And (Expression.LessThanOrEqual (step' Expression.Constant ((LuaObject)0))' Expression.GreaterThanOrEqual (var' limit))); " is 288.
Long Statement,NetLua,LuaCompiler,F:\newReposMay17\frabert_NetLua\NetLua\LuaCompiler.cs,CompileNumericFor,The length of the statement  "	var check = Expression.IfThenElse (GetAsBool (condition)' Expression.Block (setLocalVar' innerBlock' sum)' Expression.Break (@break)); " is 134.
Long Statement,NetLua,LuaObject,F:\newReposMay17\frabert_NetLua\NetLua\LuaObject.cs,TryInvoke,The length of the statement  "	LuaObject[] passingArgs = Array.ConvertAll<object' LuaObject> (args' x => (x is LuaObject ? (LuaObject)x : LuaObject.FromObject (x))); " is 134.
Complex Conditional,NetLua,LuaEvents,F:\newReposMay17\frabert_NetLua\NetLua\LuaEvents.cs,concat_event,The conditional expression  "(op1.IsString || op1.IsNumber) && (op2.IsString || op2.IsNumber)"  is complex.
Magic Number,NetLua,Lua,F:\newReposMay17\frabert_NetLua\NetLua\Lua.cs,rawset,The following statement contains a magic number: LuaEvents.rawset (args [0]' args [1]' args [2]);  
Magic Number,NetLua,Parser,F:\newReposMay17\frabert_NetLua\NetLua\Parser.cs,ParseOopCall,The following statement contains a magic number: if (node.Term.Name == "OopCall") {  	Ast.IExpression expr = ParsePrefix (node.ChildNodes [0]);  	string name = node.ChildNodes [1].Token.ValueString;  	Ast.FunctionCall call = new Ast.FunctionCall ();  	call.Arguments.Add (expr);  	call.Function = new Ast.Variable () {  		Name = name'  		Prefix = expr  	};  	var root = node.ChildNodes [2].ChildNodes [0];  	if (root.ChildNodes.Count != 0) {  		root = root.ChildNodes [0];  		while (true) {  			call.Arguments.Add (ParseExpression (root.ChildNodes [0]));  			if (root.ChildNodes.Count == 1)  				break;  			else  				root = root.ChildNodes [1];  		}  	}  	return call;  }  
Magic Number,NetLua,Parser,F:\newReposMay17\frabert_NetLua\NetLua\Parser.cs,ParseLocalAssign,The following statement contains a magic number: if (node.Term.Name == "LocalAssignment") {  	Ast.LocalAssignment assign = new Ast.LocalAssignment ();  	var child = node.ChildNodes [1];  	if (child.ChildNodes [0].Term.Name == "LocalFunction") {  		child = child.ChildNodes [0];  		var argsNode = child.ChildNodes [2];  		var blockNode = child.ChildNodes [3];  		assign.Names.Add (child.ChildNodes [1].Token.ValueString);  		var func = new Ast.FunctionDefinition ();  		if (argsNode.ChildNodes.Count > 0) {  			argsNode = argsNode.ChildNodes [0];  			while (argsNode.ChildNodes.Count > 0) {  				string ident = argsNode.ChildNodes [0].Token.ValueString;  				func.Arguments.Add (new Ast.Argument () {  					Name = ident  				});  				if (argsNode.ChildNodes.Count == 1)  					break;  				argsNode = argsNode.ChildNodes [1];  			}  		}  		func.Body = ParseBlock (blockNode);  		assign.Values.Add (func);  		return assign;  	}  	var left = child.ChildNodes [0];  	var right = child.ChildNodes [1];  	assign.Names.Add (left.ChildNodes [0].Token.ValueString);  	left = left.ChildNodes [1];  	while (left.ChildNodes.Count > 0) {  		left = left.ChildNodes [0];  		assign.Names.Add (left.ChildNodes [0].Token.ValueString);  		left = left.ChildNodes [1];  	}  	while (right.ChildNodes.Count > 0) {  		right = right.ChildNodes [0];  		assign.Values.Add (ParseExpression (right.ChildNodes [0]));  		right = right.ChildNodes [1];  	}  	return assign;  }  
Magic Number,NetLua,Parser,F:\newReposMay17\frabert_NetLua\NetLua\Parser.cs,ParseLocalAssign,The following statement contains a magic number: if (node.Term.Name == "LocalAssignment") {  	Ast.LocalAssignment assign = new Ast.LocalAssignment ();  	var child = node.ChildNodes [1];  	if (child.ChildNodes [0].Term.Name == "LocalFunction") {  		child = child.ChildNodes [0];  		var argsNode = child.ChildNodes [2];  		var blockNode = child.ChildNodes [3];  		assign.Names.Add (child.ChildNodes [1].Token.ValueString);  		var func = new Ast.FunctionDefinition ();  		if (argsNode.ChildNodes.Count > 0) {  			argsNode = argsNode.ChildNodes [0];  			while (argsNode.ChildNodes.Count > 0) {  				string ident = argsNode.ChildNodes [0].Token.ValueString;  				func.Arguments.Add (new Ast.Argument () {  					Name = ident  				});  				if (argsNode.ChildNodes.Count == 1)  					break;  				argsNode = argsNode.ChildNodes [1];  			}  		}  		func.Body = ParseBlock (blockNode);  		assign.Values.Add (func);  		return assign;  	}  	var left = child.ChildNodes [0];  	var right = child.ChildNodes [1];  	assign.Names.Add (left.ChildNodes [0].Token.ValueString);  	left = left.ChildNodes [1];  	while (left.ChildNodes.Count > 0) {  		left = left.ChildNodes [0];  		assign.Names.Add (left.ChildNodes [0].Token.ValueString);  		left = left.ChildNodes [1];  	}  	while (right.ChildNodes.Count > 0) {  		right = right.ChildNodes [0];  		assign.Values.Add (ParseExpression (right.ChildNodes [0]));  		right = right.ChildNodes [1];  	}  	return assign;  }  
Magic Number,NetLua,Parser,F:\newReposMay17\frabert_NetLua\NetLua\Parser.cs,ParseLocalAssign,The following statement contains a magic number: if (child.ChildNodes [0].Term.Name == "LocalFunction") {  	child = child.ChildNodes [0];  	var argsNode = child.ChildNodes [2];  	var blockNode = child.ChildNodes [3];  	assign.Names.Add (child.ChildNodes [1].Token.ValueString);  	var func = new Ast.FunctionDefinition ();  	if (argsNode.ChildNodes.Count > 0) {  		argsNode = argsNode.ChildNodes [0];  		while (argsNode.ChildNodes.Count > 0) {  			string ident = argsNode.ChildNodes [0].Token.ValueString;  			func.Arguments.Add (new Ast.Argument () {  				Name = ident  			});  			if (argsNode.ChildNodes.Count == 1)  				break;  			argsNode = argsNode.ChildNodes [1];  		}  	}  	func.Body = ParseBlock (blockNode);  	assign.Values.Add (func);  	return assign;  }  
Magic Number,NetLua,Parser,F:\newReposMay17\frabert_NetLua\NetLua\Parser.cs,ParseLocalAssign,The following statement contains a magic number: if (child.ChildNodes [0].Term.Name == "LocalFunction") {  	child = child.ChildNodes [0];  	var argsNode = child.ChildNodes [2];  	var blockNode = child.ChildNodes [3];  	assign.Names.Add (child.ChildNodes [1].Token.ValueString);  	var func = new Ast.FunctionDefinition ();  	if (argsNode.ChildNodes.Count > 0) {  		argsNode = argsNode.ChildNodes [0];  		while (argsNode.ChildNodes.Count > 0) {  			string ident = argsNode.ChildNodes [0].Token.ValueString;  			func.Arguments.Add (new Ast.Argument () {  				Name = ident  			});  			if (argsNode.ChildNodes.Count == 1)  				break;  			argsNode = argsNode.ChildNodes [1];  		}  	}  	func.Body = ParseBlock (blockNode);  	assign.Values.Add (func);  	return assign;  }  
Magic Number,NetLua,Parser,F:\newReposMay17\frabert_NetLua\NetLua\Parser.cs,ParseRepeat,The following statement contains a magic number: if (node.Term.Name == "Repeat") {  	Ast.Block block = ParseBlock (node.ChildNodes [1]);  	Ast.IExpression condition = ParseExpression (node.ChildNodes [3]);  	return new Ast.RepeatStat () {  		Block = block'  		Condition = condition  	};  }  
Magic Number,NetLua,Parser,F:\newReposMay17\frabert_NetLua\NetLua\Parser.cs,ParseWhile,The following statement contains a magic number: if (node.Term.Name == "While") {  	return new Ast.WhileStat () {  		Condition = ParseExpression (node.ChildNodes [1])'  		Block = ParseDoBlock (node.ChildNodes [2])  	};  }  
Magic Number,NetLua,Parser,F:\newReposMay17\frabert_NetLua\NetLua\Parser.cs,ParseWhile,The following statement contains a magic number: return new Ast.WhileStat () {  	Condition = ParseExpression (node.ChildNodes [1])'  	Block = ParseDoBlock (node.ChildNodes [2])  };  
Magic Number,NetLua,Parser,F:\newReposMay17\frabert_NetLua\NetLua\Parser.cs,ParseIf,The following statement contains a magic number: if (node.Term.Name == "If") {  	Ast.IExpression condition = ParseExpression (node.ChildNodes [1]);  	Ast.Block block = ParseBlock (node.ChildNodes [3]);  	Ast.IfStat If = new Ast.IfStat ();  	If.Block = block;  	If.Condition = condition;  	If.ElseIfs = new List<Ast.IfStat> ();  	ParseTreeNode ElseifNode = node.ChildNodes [4];  	ParseTreeNode ElseNode = node.ChildNodes [5];  	while (ElseifNode.ChildNodes.Count != 0) {  		var childnode = ElseifNode.ChildNodes [0];  		Ast.IfStat elseif = new Ast.IfStat ();  		elseif.Condition = ParseExpression (childnode.ChildNodes [1]);  		elseif.Block = ParseBlock (childnode.ChildNodes [3]);  		If.ElseIfs.Add (elseif);  		ElseifNode = childnode.ChildNodes [4];  	}  	if (ElseNode.ChildNodes.Count != 0)  		If.ElseBlock = ParseBlock (ElseNode.ChildNodes [0].ChildNodes [1]);  	return If;  }  
Magic Number,NetLua,Parser,F:\newReposMay17\frabert_NetLua\NetLua\Parser.cs,ParseIf,The following statement contains a magic number: if (node.Term.Name == "If") {  	Ast.IExpression condition = ParseExpression (node.ChildNodes [1]);  	Ast.Block block = ParseBlock (node.ChildNodes [3]);  	Ast.IfStat If = new Ast.IfStat ();  	If.Block = block;  	If.Condition = condition;  	If.ElseIfs = new List<Ast.IfStat> ();  	ParseTreeNode ElseifNode = node.ChildNodes [4];  	ParseTreeNode ElseNode = node.ChildNodes [5];  	while (ElseifNode.ChildNodes.Count != 0) {  		var childnode = ElseifNode.ChildNodes [0];  		Ast.IfStat elseif = new Ast.IfStat ();  		elseif.Condition = ParseExpression (childnode.ChildNodes [1]);  		elseif.Block = ParseBlock (childnode.ChildNodes [3]);  		If.ElseIfs.Add (elseif);  		ElseifNode = childnode.ChildNodes [4];  	}  	if (ElseNode.ChildNodes.Count != 0)  		If.ElseBlock = ParseBlock (ElseNode.ChildNodes [0].ChildNodes [1]);  	return If;  }  
Magic Number,NetLua,Parser,F:\newReposMay17\frabert_NetLua\NetLua\Parser.cs,ParseIf,The following statement contains a magic number: if (node.Term.Name == "If") {  	Ast.IExpression condition = ParseExpression (node.ChildNodes [1]);  	Ast.Block block = ParseBlock (node.ChildNodes [3]);  	Ast.IfStat If = new Ast.IfStat ();  	If.Block = block;  	If.Condition = condition;  	If.ElseIfs = new List<Ast.IfStat> ();  	ParseTreeNode ElseifNode = node.ChildNodes [4];  	ParseTreeNode ElseNode = node.ChildNodes [5];  	while (ElseifNode.ChildNodes.Count != 0) {  		var childnode = ElseifNode.ChildNodes [0];  		Ast.IfStat elseif = new Ast.IfStat ();  		elseif.Condition = ParseExpression (childnode.ChildNodes [1]);  		elseif.Block = ParseBlock (childnode.ChildNodes [3]);  		If.ElseIfs.Add (elseif);  		ElseifNode = childnode.ChildNodes [4];  	}  	if (ElseNode.ChildNodes.Count != 0)  		If.ElseBlock = ParseBlock (ElseNode.ChildNodes [0].ChildNodes [1]);  	return If;  }  
Magic Number,NetLua,Parser,F:\newReposMay17\frabert_NetLua\NetLua\Parser.cs,ParseIf,The following statement contains a magic number: if (node.Term.Name == "If") {  	Ast.IExpression condition = ParseExpression (node.ChildNodes [1]);  	Ast.Block block = ParseBlock (node.ChildNodes [3]);  	Ast.IfStat If = new Ast.IfStat ();  	If.Block = block;  	If.Condition = condition;  	If.ElseIfs = new List<Ast.IfStat> ();  	ParseTreeNode ElseifNode = node.ChildNodes [4];  	ParseTreeNode ElseNode = node.ChildNodes [5];  	while (ElseifNode.ChildNodes.Count != 0) {  		var childnode = ElseifNode.ChildNodes [0];  		Ast.IfStat elseif = new Ast.IfStat ();  		elseif.Condition = ParseExpression (childnode.ChildNodes [1]);  		elseif.Block = ParseBlock (childnode.ChildNodes [3]);  		If.ElseIfs.Add (elseif);  		ElseifNode = childnode.ChildNodes [4];  	}  	if (ElseNode.ChildNodes.Count != 0)  		If.ElseBlock = ParseBlock (ElseNode.ChildNodes [0].ChildNodes [1]);  	return If;  }  
Magic Number,NetLua,Parser,F:\newReposMay17\frabert_NetLua\NetLua\Parser.cs,ParseIf,The following statement contains a magic number: if (node.Term.Name == "If") {  	Ast.IExpression condition = ParseExpression (node.ChildNodes [1]);  	Ast.Block block = ParseBlock (node.ChildNodes [3]);  	Ast.IfStat If = new Ast.IfStat ();  	If.Block = block;  	If.Condition = condition;  	If.ElseIfs = new List<Ast.IfStat> ();  	ParseTreeNode ElseifNode = node.ChildNodes [4];  	ParseTreeNode ElseNode = node.ChildNodes [5];  	while (ElseifNode.ChildNodes.Count != 0) {  		var childnode = ElseifNode.ChildNodes [0];  		Ast.IfStat elseif = new Ast.IfStat ();  		elseif.Condition = ParseExpression (childnode.ChildNodes [1]);  		elseif.Block = ParseBlock (childnode.ChildNodes [3]);  		If.ElseIfs.Add (elseif);  		ElseifNode = childnode.ChildNodes [4];  	}  	if (ElseNode.ChildNodes.Count != 0)  		If.ElseBlock = ParseBlock (ElseNode.ChildNodes [0].ChildNodes [1]);  	return If;  }  
Magic Number,NetLua,Parser,F:\newReposMay17\frabert_NetLua\NetLua\Parser.cs,ParseIf,The following statement contains a magic number: while (ElseifNode.ChildNodes.Count != 0) {  	var childnode = ElseifNode.ChildNodes [0];  	Ast.IfStat elseif = new Ast.IfStat ();  	elseif.Condition = ParseExpression (childnode.ChildNodes [1]);  	elseif.Block = ParseBlock (childnode.ChildNodes [3]);  	If.ElseIfs.Add (elseif);  	ElseifNode = childnode.ChildNodes [4];  }  
Magic Number,NetLua,Parser,F:\newReposMay17\frabert_NetLua\NetLua\Parser.cs,ParseIf,The following statement contains a magic number: while (ElseifNode.ChildNodes.Count != 0) {  	var childnode = ElseifNode.ChildNodes [0];  	Ast.IfStat elseif = new Ast.IfStat ();  	elseif.Condition = ParseExpression (childnode.ChildNodes [1]);  	elseif.Block = ParseBlock (childnode.ChildNodes [3]);  	If.ElseIfs.Add (elseif);  	ElseifNode = childnode.ChildNodes [4];  }  
Magic Number,NetLua,Parser,F:\newReposMay17\frabert_NetLua\NetLua\Parser.cs,ParseIf,The following statement contains a magic number: elseif.Block = ParseBlock (childnode.ChildNodes [3]);  
Magic Number,NetLua,Parser,F:\newReposMay17\frabert_NetLua\NetLua\Parser.cs,ParseIf,The following statement contains a magic number: ElseifNode = childnode.ChildNodes [4];  
Magic Number,NetLua,Parser,F:\newReposMay17\frabert_NetLua\NetLua\Parser.cs,ParseFunctionDecl,The following statement contains a magic number: if (node.Term.Name == "FunctionDecl") {  	Ast.IAssignable expr = ParseVariable (node.ChildNodes [1]);  	ParseTreeNode argsNode = node.ChildNodes [3].ChildNodes [0];  	ParseTreeNode chunkNode = node.ChildNodes [4];  	Ast.Block block = ParseBlock (chunkNode);  	Ast.FunctionDefinition def = new Ast.FunctionDefinition ();  	def.Arguments = new List<Ast.Argument> ();  	var nameNode = node.ChildNodes [2];  	if (nameNode.ChildNodes.Count > 0) {  		def.Arguments.Add (new Ast.Argument () {  			Name = "self"  		});  		expr = new Ast.Variable () {  			Name = nameNode.ChildNodes [0].Token.ValueString'  			Prefix = expr  		};  	}  	def.Body = block;  	if (argsNode.ChildNodes.Count > 0) {  		argsNode = argsNode.ChildNodes [0];  		while (argsNode.ChildNodes.Count > 0) {  			string ident = argsNode.ChildNodes [0].Token.ValueString;  			def.Arguments.Add (new Ast.Argument () {  				Name = ident  			});  			if (argsNode.ChildNodes.Count == 1)  				break;  			argsNode = argsNode.ChildNodes [1];  		}  	}  	Ast.Assignment assign = new Ast.Assignment ();  	assign.Variables.Add (expr);  	assign.Expressions.Add (def);  	return assign;  }  
Magic Number,NetLua,Parser,F:\newReposMay17\frabert_NetLua\NetLua\Parser.cs,ParseFunctionDecl,The following statement contains a magic number: if (node.Term.Name == "FunctionDecl") {  	Ast.IAssignable expr = ParseVariable (node.ChildNodes [1]);  	ParseTreeNode argsNode = node.ChildNodes [3].ChildNodes [0];  	ParseTreeNode chunkNode = node.ChildNodes [4];  	Ast.Block block = ParseBlock (chunkNode);  	Ast.FunctionDefinition def = new Ast.FunctionDefinition ();  	def.Arguments = new List<Ast.Argument> ();  	var nameNode = node.ChildNodes [2];  	if (nameNode.ChildNodes.Count > 0) {  		def.Arguments.Add (new Ast.Argument () {  			Name = "self"  		});  		expr = new Ast.Variable () {  			Name = nameNode.ChildNodes [0].Token.ValueString'  			Prefix = expr  		};  	}  	def.Body = block;  	if (argsNode.ChildNodes.Count > 0) {  		argsNode = argsNode.ChildNodes [0];  		while (argsNode.ChildNodes.Count > 0) {  			string ident = argsNode.ChildNodes [0].Token.ValueString;  			def.Arguments.Add (new Ast.Argument () {  				Name = ident  			});  			if (argsNode.ChildNodes.Count == 1)  				break;  			argsNode = argsNode.ChildNodes [1];  		}  	}  	Ast.Assignment assign = new Ast.Assignment ();  	assign.Variables.Add (expr);  	assign.Expressions.Add (def);  	return assign;  }  
Magic Number,NetLua,Parser,F:\newReposMay17\frabert_NetLua\NetLua\Parser.cs,ParseFunctionDecl,The following statement contains a magic number: if (node.Term.Name == "FunctionDecl") {  	Ast.IAssignable expr = ParseVariable (node.ChildNodes [1]);  	ParseTreeNode argsNode = node.ChildNodes [3].ChildNodes [0];  	ParseTreeNode chunkNode = node.ChildNodes [4];  	Ast.Block block = ParseBlock (chunkNode);  	Ast.FunctionDefinition def = new Ast.FunctionDefinition ();  	def.Arguments = new List<Ast.Argument> ();  	var nameNode = node.ChildNodes [2];  	if (nameNode.ChildNodes.Count > 0) {  		def.Arguments.Add (new Ast.Argument () {  			Name = "self"  		});  		expr = new Ast.Variable () {  			Name = nameNode.ChildNodes [0].Token.ValueString'  			Prefix = expr  		};  	}  	def.Body = block;  	if (argsNode.ChildNodes.Count > 0) {  		argsNode = argsNode.ChildNodes [0];  		while (argsNode.ChildNodes.Count > 0) {  			string ident = argsNode.ChildNodes [0].Token.ValueString;  			def.Arguments.Add (new Ast.Argument () {  				Name = ident  			});  			if (argsNode.ChildNodes.Count == 1)  				break;  			argsNode = argsNode.ChildNodes [1];  		}  	}  	Ast.Assignment assign = new Ast.Assignment ();  	assign.Variables.Add (expr);  	assign.Expressions.Add (def);  	return assign;  }  
Magic Number,NetLua,Parser,F:\newReposMay17\frabert_NetLua\NetLua\Parser.cs,ParseFunctionDef,The following statement contains a magic number: if (node.Term.Name == "FunctionDef") {  	ParseTreeNode argsNode = node.ChildNodes [1].ChildNodes [0];  	ParseTreeNode chunkNode = node.ChildNodes [2];  	Ast.Block block = ParseBlock (chunkNode);  	Ast.FunctionDefinition def = new Ast.FunctionDefinition ();  	def.Body = block;  	def.Arguments = new List<Ast.Argument> ();  	if (argsNode.ChildNodes.Count == 0)  		return def;  	if (argsNode.ChildNodes.Count > 0) {  		argsNode = argsNode.ChildNodes [0];  		while (argsNode.ChildNodes.Count > 0) {  			string ident = argsNode.ChildNodes [0].Token.ValueString;  			def.Arguments.Add (new Ast.Argument () {  				Name = ident  			});  			if (argsNode.ChildNodes.Count == 1)  				break;  			argsNode = argsNode.ChildNodes [1];  		}  	}  	return def;  }  
Magic Number,NetLua,Parser,F:\newReposMay17\frabert_NetLua\NetLua\Parser.cs,ParseFor,The following statement contains a magic number: if (node.Term.Name == "For") {  	var block = ParseDoBlock (node.ChildNodes [2]);  	var type = node.ChildNodes [1].ChildNodes [0];  	if (type.Term.Name == "NumericFor") {  		var cycle = new Ast.NumericFor ();  		cycle.Block = block;  		cycle.Variable = type.ChildNodes [0].Token.ValueString;  		cycle.Var = ParseExpression (type.ChildNodes [1]);  		cycle.Limit = ParseExpression (type.ChildNodes [2]);  		cycle.Step = new Ast.NumberLiteral () {  			Value = 1  		};  		if (type.ChildNodes [3].ChildNodes.Count > 0) {  			var child = type.ChildNodes [3].ChildNodes [0];  			cycle.Step = ParseExpression (child);  		}  		return cycle;  	} else {  		var cycle = new Ast.GenericFor ();  		cycle.Block = block;  		var nameList = type.ChildNodes [0];  		var exprList = type.ChildNodes [2];  		while (true) {  			var name = nameList.ChildNodes [0].Token.ValueString;  			cycle.Variables.Add (name);  			var child = nameList.ChildNodes [1];  			if (child.ChildNodes.Count > 0)  				nameList = child.ChildNodes [0];  			else  				break;  		}  		while (true) {  			var expr = ParseExpression (exprList.ChildNodes [0]);  			cycle.Expressions.Add (expr);  			var child = exprList.ChildNodes [1];  			if (child.ChildNodes.Count > 0)  				exprList = child.ChildNodes [0];  			else  				break;  		}  		return cycle;  	}  }  
Magic Number,NetLua,Parser,F:\newReposMay17\frabert_NetLua\NetLua\Parser.cs,ParseFor,The following statement contains a magic number: if (node.Term.Name == "For") {  	var block = ParseDoBlock (node.ChildNodes [2]);  	var type = node.ChildNodes [1].ChildNodes [0];  	if (type.Term.Name == "NumericFor") {  		var cycle = new Ast.NumericFor ();  		cycle.Block = block;  		cycle.Variable = type.ChildNodes [0].Token.ValueString;  		cycle.Var = ParseExpression (type.ChildNodes [1]);  		cycle.Limit = ParseExpression (type.ChildNodes [2]);  		cycle.Step = new Ast.NumberLiteral () {  			Value = 1  		};  		if (type.ChildNodes [3].ChildNodes.Count > 0) {  			var child = type.ChildNodes [3].ChildNodes [0];  			cycle.Step = ParseExpression (child);  		}  		return cycle;  	} else {  		var cycle = new Ast.GenericFor ();  		cycle.Block = block;  		var nameList = type.ChildNodes [0];  		var exprList = type.ChildNodes [2];  		while (true) {  			var name = nameList.ChildNodes [0].Token.ValueString;  			cycle.Variables.Add (name);  			var child = nameList.ChildNodes [1];  			if (child.ChildNodes.Count > 0)  				nameList = child.ChildNodes [0];  			else  				break;  		}  		while (true) {  			var expr = ParseExpression (exprList.ChildNodes [0]);  			cycle.Expressions.Add (expr);  			var child = exprList.ChildNodes [1];  			if (child.ChildNodes.Count > 0)  				exprList = child.ChildNodes [0];  			else  				break;  		}  		return cycle;  	}  }  
Magic Number,NetLua,Parser,F:\newReposMay17\frabert_NetLua\NetLua\Parser.cs,ParseFor,The following statement contains a magic number: if (node.Term.Name == "For") {  	var block = ParseDoBlock (node.ChildNodes [2]);  	var type = node.ChildNodes [1].ChildNodes [0];  	if (type.Term.Name == "NumericFor") {  		var cycle = new Ast.NumericFor ();  		cycle.Block = block;  		cycle.Variable = type.ChildNodes [0].Token.ValueString;  		cycle.Var = ParseExpression (type.ChildNodes [1]);  		cycle.Limit = ParseExpression (type.ChildNodes [2]);  		cycle.Step = new Ast.NumberLiteral () {  			Value = 1  		};  		if (type.ChildNodes [3].ChildNodes.Count > 0) {  			var child = type.ChildNodes [3].ChildNodes [0];  			cycle.Step = ParseExpression (child);  		}  		return cycle;  	} else {  		var cycle = new Ast.GenericFor ();  		cycle.Block = block;  		var nameList = type.ChildNodes [0];  		var exprList = type.ChildNodes [2];  		while (true) {  			var name = nameList.ChildNodes [0].Token.ValueString;  			cycle.Variables.Add (name);  			var child = nameList.ChildNodes [1];  			if (child.ChildNodes.Count > 0)  				nameList = child.ChildNodes [0];  			else  				break;  		}  		while (true) {  			var expr = ParseExpression (exprList.ChildNodes [0]);  			cycle.Expressions.Add (expr);  			var child = exprList.ChildNodes [1];  			if (child.ChildNodes.Count > 0)  				exprList = child.ChildNodes [0];  			else  				break;  		}  		return cycle;  	}  }  
Magic Number,NetLua,Parser,F:\newReposMay17\frabert_NetLua\NetLua\Parser.cs,ParseFor,The following statement contains a magic number: if (node.Term.Name == "For") {  	var block = ParseDoBlock (node.ChildNodes [2]);  	var type = node.ChildNodes [1].ChildNodes [0];  	if (type.Term.Name == "NumericFor") {  		var cycle = new Ast.NumericFor ();  		cycle.Block = block;  		cycle.Variable = type.ChildNodes [0].Token.ValueString;  		cycle.Var = ParseExpression (type.ChildNodes [1]);  		cycle.Limit = ParseExpression (type.ChildNodes [2]);  		cycle.Step = new Ast.NumberLiteral () {  			Value = 1  		};  		if (type.ChildNodes [3].ChildNodes.Count > 0) {  			var child = type.ChildNodes [3].ChildNodes [0];  			cycle.Step = ParseExpression (child);  		}  		return cycle;  	} else {  		var cycle = new Ast.GenericFor ();  		cycle.Block = block;  		var nameList = type.ChildNodes [0];  		var exprList = type.ChildNodes [2];  		while (true) {  			var name = nameList.ChildNodes [0].Token.ValueString;  			cycle.Variables.Add (name);  			var child = nameList.ChildNodes [1];  			if (child.ChildNodes.Count > 0)  				nameList = child.ChildNodes [0];  			else  				break;  		}  		while (true) {  			var expr = ParseExpression (exprList.ChildNodes [0]);  			cycle.Expressions.Add (expr);  			var child = exprList.ChildNodes [1];  			if (child.ChildNodes.Count > 0)  				exprList = child.ChildNodes [0];  			else  				break;  		}  		return cycle;  	}  }  
Magic Number,NetLua,Parser,F:\newReposMay17\frabert_NetLua\NetLua\Parser.cs,ParseFor,The following statement contains a magic number: if (node.Term.Name == "For") {  	var block = ParseDoBlock (node.ChildNodes [2]);  	var type = node.ChildNodes [1].ChildNodes [0];  	if (type.Term.Name == "NumericFor") {  		var cycle = new Ast.NumericFor ();  		cycle.Block = block;  		cycle.Variable = type.ChildNodes [0].Token.ValueString;  		cycle.Var = ParseExpression (type.ChildNodes [1]);  		cycle.Limit = ParseExpression (type.ChildNodes [2]);  		cycle.Step = new Ast.NumberLiteral () {  			Value = 1  		};  		if (type.ChildNodes [3].ChildNodes.Count > 0) {  			var child = type.ChildNodes [3].ChildNodes [0];  			cycle.Step = ParseExpression (child);  		}  		return cycle;  	} else {  		var cycle = new Ast.GenericFor ();  		cycle.Block = block;  		var nameList = type.ChildNodes [0];  		var exprList = type.ChildNodes [2];  		while (true) {  			var name = nameList.ChildNodes [0].Token.ValueString;  			cycle.Variables.Add (name);  			var child = nameList.ChildNodes [1];  			if (child.ChildNodes.Count > 0)  				nameList = child.ChildNodes [0];  			else  				break;  		}  		while (true) {  			var expr = ParseExpression (exprList.ChildNodes [0]);  			cycle.Expressions.Add (expr);  			var child = exprList.ChildNodes [1];  			if (child.ChildNodes.Count > 0)  				exprList = child.ChildNodes [0];  			else  				break;  		}  		return cycle;  	}  }  
Magic Number,NetLua,Parser,F:\newReposMay17\frabert_NetLua\NetLua\Parser.cs,ParseFor,The following statement contains a magic number: if (type.Term.Name == "NumericFor") {  	var cycle = new Ast.NumericFor ();  	cycle.Block = block;  	cycle.Variable = type.ChildNodes [0].Token.ValueString;  	cycle.Var = ParseExpression (type.ChildNodes [1]);  	cycle.Limit = ParseExpression (type.ChildNodes [2]);  	cycle.Step = new Ast.NumberLiteral () {  		Value = 1  	};  	if (type.ChildNodes [3].ChildNodes.Count > 0) {  		var child = type.ChildNodes [3].ChildNodes [0];  		cycle.Step = ParseExpression (child);  	}  	return cycle;  } else {  	var cycle = new Ast.GenericFor ();  	cycle.Block = block;  	var nameList = type.ChildNodes [0];  	var exprList = type.ChildNodes [2];  	while (true) {  		var name = nameList.ChildNodes [0].Token.ValueString;  		cycle.Variables.Add (name);  		var child = nameList.ChildNodes [1];  		if (child.ChildNodes.Count > 0)  			nameList = child.ChildNodes [0];  		else  			break;  	}  	while (true) {  		var expr = ParseExpression (exprList.ChildNodes [0]);  		cycle.Expressions.Add (expr);  		var child = exprList.ChildNodes [1];  		if (child.ChildNodes.Count > 0)  			exprList = child.ChildNodes [0];  		else  			break;  	}  	return cycle;  }  
Magic Number,NetLua,Parser,F:\newReposMay17\frabert_NetLua\NetLua\Parser.cs,ParseFor,The following statement contains a magic number: if (type.Term.Name == "NumericFor") {  	var cycle = new Ast.NumericFor ();  	cycle.Block = block;  	cycle.Variable = type.ChildNodes [0].Token.ValueString;  	cycle.Var = ParseExpression (type.ChildNodes [1]);  	cycle.Limit = ParseExpression (type.ChildNodes [2]);  	cycle.Step = new Ast.NumberLiteral () {  		Value = 1  	};  	if (type.ChildNodes [3].ChildNodes.Count > 0) {  		var child = type.ChildNodes [3].ChildNodes [0];  		cycle.Step = ParseExpression (child);  	}  	return cycle;  } else {  	var cycle = new Ast.GenericFor ();  	cycle.Block = block;  	var nameList = type.ChildNodes [0];  	var exprList = type.ChildNodes [2];  	while (true) {  		var name = nameList.ChildNodes [0].Token.ValueString;  		cycle.Variables.Add (name);  		var child = nameList.ChildNodes [1];  		if (child.ChildNodes.Count > 0)  			nameList = child.ChildNodes [0];  		else  			break;  	}  	while (true) {  		var expr = ParseExpression (exprList.ChildNodes [0]);  		cycle.Expressions.Add (expr);  		var child = exprList.ChildNodes [1];  		if (child.ChildNodes.Count > 0)  			exprList = child.ChildNodes [0];  		else  			break;  	}  	return cycle;  }  
Magic Number,NetLua,Parser,F:\newReposMay17\frabert_NetLua\NetLua\Parser.cs,ParseFor,The following statement contains a magic number: if (type.Term.Name == "NumericFor") {  	var cycle = new Ast.NumericFor ();  	cycle.Block = block;  	cycle.Variable = type.ChildNodes [0].Token.ValueString;  	cycle.Var = ParseExpression (type.ChildNodes [1]);  	cycle.Limit = ParseExpression (type.ChildNodes [2]);  	cycle.Step = new Ast.NumberLiteral () {  		Value = 1  	};  	if (type.ChildNodes [3].ChildNodes.Count > 0) {  		var child = type.ChildNodes [3].ChildNodes [0];  		cycle.Step = ParseExpression (child);  	}  	return cycle;  } else {  	var cycle = new Ast.GenericFor ();  	cycle.Block = block;  	var nameList = type.ChildNodes [0];  	var exprList = type.ChildNodes [2];  	while (true) {  		var name = nameList.ChildNodes [0].Token.ValueString;  		cycle.Variables.Add (name);  		var child = nameList.ChildNodes [1];  		if (child.ChildNodes.Count > 0)  			nameList = child.ChildNodes [0];  		else  			break;  	}  	while (true) {  		var expr = ParseExpression (exprList.ChildNodes [0]);  		cycle.Expressions.Add (expr);  		var child = exprList.ChildNodes [1];  		if (child.ChildNodes.Count > 0)  			exprList = child.ChildNodes [0];  		else  			break;  	}  	return cycle;  }  
Magic Number,NetLua,Parser,F:\newReposMay17\frabert_NetLua\NetLua\Parser.cs,ParseFor,The following statement contains a magic number: if (type.Term.Name == "NumericFor") {  	var cycle = new Ast.NumericFor ();  	cycle.Block = block;  	cycle.Variable = type.ChildNodes [0].Token.ValueString;  	cycle.Var = ParseExpression (type.ChildNodes [1]);  	cycle.Limit = ParseExpression (type.ChildNodes [2]);  	cycle.Step = new Ast.NumberLiteral () {  		Value = 1  	};  	if (type.ChildNodes [3].ChildNodes.Count > 0) {  		var child = type.ChildNodes [3].ChildNodes [0];  		cycle.Step = ParseExpression (child);  	}  	return cycle;  } else {  	var cycle = new Ast.GenericFor ();  	cycle.Block = block;  	var nameList = type.ChildNodes [0];  	var exprList = type.ChildNodes [2];  	while (true) {  		var name = nameList.ChildNodes [0].Token.ValueString;  		cycle.Variables.Add (name);  		var child = nameList.ChildNodes [1];  		if (child.ChildNodes.Count > 0)  			nameList = child.ChildNodes [0];  		else  			break;  	}  	while (true) {  		var expr = ParseExpression (exprList.ChildNodes [0]);  		cycle.Expressions.Add (expr);  		var child = exprList.ChildNodes [1];  		if (child.ChildNodes.Count > 0)  			exprList = child.ChildNodes [0];  		else  			break;  	}  	return cycle;  }  
Magic Number,NetLua,Parser,F:\newReposMay17\frabert_NetLua\NetLua\Parser.cs,ParseFor,The following statement contains a magic number: cycle.Limit = ParseExpression (type.ChildNodes [2]);  
Magic Number,NetLua,Parser,F:\newReposMay17\frabert_NetLua\NetLua\Parser.cs,ParseFor,The following statement contains a magic number: if (type.ChildNodes [3].ChildNodes.Count > 0) {  	var child = type.ChildNodes [3].ChildNodes [0];  	cycle.Step = ParseExpression (child);  }  
Magic Number,NetLua,Parser,F:\newReposMay17\frabert_NetLua\NetLua\Parser.cs,ParseFor,The following statement contains a magic number: if (type.ChildNodes [3].ChildNodes.Count > 0) {  	var child = type.ChildNodes [3].ChildNodes [0];  	cycle.Step = ParseExpression (child);  }  
Missing Default,NetLua,IoLibrary,F:\newReposMay17\frabert_NetLua\NetLua\Libraries\IoLibrary.cs,io_open,The following switch statement is missing a default case: switch (mode.ToString ()) {  case "r":  	faccess = FileAccess.Read;  	break;  case "w":  	fmode = FileMode.Create;  	faccess = FileAccess.ReadWrite;  	break;  case "a":  	fmode = FileMode.Append;  	faccess = FileAccess.Write;  	break;  case "r+":  case "w+":  case "a+":  	// TODO: Implement rwa+  	throw new NotImplementedException ();  }  
Missing Default,NetLua,IoLibrary,F:\newReposMay17\frabert_NetLua\NetLua\Libraries\IoLibrary.cs,seek,The following switch statement is missing a default case: switch (whence.ToString ()) {  case "cur":  	fobj.stream.Position += (long)offset;  	break;  case "set":  	fobj.stream.Position = (long)offset;  	break;  case "end":  	fobj.stream.Position = fobj.stream.Length + (long)offset;  	break;  }  
Missing Default,NetLua,Lua,F:\newReposMay17\frabert_NetLua\NetLua\Lua.cs,type,The following switch statement is missing a default case: switch (args [0].Type) {  case LuaType.boolean:  	return Return ("boolean");  case LuaType.function:  	return Return ("function");  case LuaType.nil:  	return Return ("nil");  case LuaType.number:  	return Return ("number");  case LuaType.@string:  	return Return ("string");  case LuaType.table:  	return Return ("table");  case LuaType.thread:  	return Return ("thread");  case LuaType.userdata:  	return Return ("userdata");  }  
Missing Default,NetLua,Parser,F:\newReposMay17\frabert_NetLua\NetLua\Parser.cs,ParseUnaryExpr,The following switch statement is missing a default case: switch (opNode.Token.ValueString) {  case "not":  	op = Ast.UnaryOp.Negate;  	break;  case "-":  	op = Ast.UnaryOp.Invert;  	break;  case "#":  	op = Ast.UnaryOp.Length;  	break;  }  
