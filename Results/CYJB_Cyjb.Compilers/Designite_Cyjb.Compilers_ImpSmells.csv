Implementation smell,Namespace,Class,File,Method,Description
Long Method,Cyjb.Compilers.RegularExpressions,RegexParser,C:\repos\CYJB_Cyjb.Compilers\Cyjb.Compilers\RegularExpressions\RegexParser.cs,ScanRegex,The method has 195 lines of code.
Long Method,Cyjb.Compilers.RegularExpressions,RegexParser,C:\repos\CYJB_Cyjb.Compilers\Cyjb.Compilers\RegularExpressions\RegexParser.cs,ScanCharClass,The method has 113 lines of code.
Complex Method,Cyjb.Compilers.Lexers,Dfa,C:\repos\CYJB_Cyjb.Compilers\Cyjb.Compilers\Lexers\Dfa.cs,MapGroup,Cyclomatic complexity of the method is 10
Complex Method,Cyjb.Compilers.Lexers,Dfa,C:\repos\CYJB_Cyjb.Compilers\Cyjb.Compilers\Lexers\Dfa.cs,MergeState,Cyclomatic complexity of the method is 11
Complex Method,Cyjb.Compilers.Lexers,FixedTrailingReader<T>,C:\repos\CYJB_Cyjb.Compilers\Cyjb.Compilers\Lexers\FixedTrailingReader`1.cs,InternalReadToken,Cyclomatic complexity of the method is 8
Complex Method,Cyjb.Compilers.Lexers,LexerRule<T>,C:\repos\CYJB_Cyjb.Compilers\Cyjb.Compilers\Lexers\LexerRule`1.cs,BuildNfa,Cyclomatic complexity of the method is 9
Complex Method,Cyjb.Compilers.Lexers,TokenReaderBase<T>,C:\repos\CYJB_Cyjb.Compilers\Cyjb.Compilers\Lexers\TokenReaderBase`1.cs,InternalReadToken,Cyclomatic complexity of the method is 11
Complex Method,Cyjb.Compilers.Lexers,RejectableTrailingReader<T>,C:\repos\CYJB_Cyjb.Compilers\Cyjb.Compilers\Lexers\RejectableTrailingReader`1.cs,InternalReadToken,Cyclomatic complexity of the method is 10
Complex Method,Cyjb.Compilers.Parsers,LRItemCollection<T>,C:\repos\CYJB_Cyjb.Compilers\Cyjb.Compilers\Parsers\LRItemCollection`1.cs,Equals,Cyclomatic complexity of the method is 9
Complex Method,Cyjb.Compilers.Parsers,ParserRule<T>,C:\repos\CYJB_Cyjb.Compilers\Cyjb.Compilers\Parsers\ParserRule`1.cs,SpreadForward,Cyclomatic complexity of the method is 10
Complex Method,Cyjb.Compilers.Parsers,ParserRule<T>,C:\repos\CYJB_Cyjb.Compilers\Cyjb.Compilers\Parsers\ParserRule`1.cs,LR1Closure,Cyclomatic complexity of the method is 8
Complex Method,Cyjb.Compilers.Parsers,ParserRule<T>,C:\repos\CYJB_Cyjb.Compilers\Cyjb.Compilers\Parsers\ParserRule`1.cs,BuildLRTable,Cyclomatic complexity of the method is 9
Complex Method,Cyjb.Compilers.Parsers,ParserRule<T>,C:\repos\CYJB_Cyjb.Compilers\Cyjb.Compilers\Parsers\ParserRule`1.cs,ResolveActions,Cyclomatic complexity of the method is 9
Complex Method,Cyjb.Compilers.RegularExpressions,RegexCharClass,C:\repos\CYJB_Cyjb.Compilers\Cyjb.Compilers\RegularExpressions\RegexCharClass.cs,GetDescription,Cyclomatic complexity of the method is 14
Complex Method,Cyjb.Compilers.RegularExpressions,RegexCharClass,C:\repos\CYJB_Cyjb.Compilers\Cyjb.Compilers\RegularExpressions\RegexCharClass.cs,AddUppercaseRange,Cyclomatic complexity of the method is 9
Complex Method,Cyjb.Compilers.RegularExpressions,RegexParser,C:\repos\CYJB_Cyjb.Compilers\Cyjb.Compilers\RegularExpressions\RegexParser.cs,ScanRegex,Cyclomatic complexity of the method is 10
Complex Method,Cyjb.Compilers.RegularExpressions,RegexParser,C:\repos\CYJB_Cyjb.Compilers\Cyjb.Compilers\RegularExpressions\RegexParser.cs,ScanCharClass,Cyclomatic complexity of the method is 10
Long Parameter List,Cyjb.Compilers,Production<T>,C:\repos\CYJB_Cyjb.Compilers\Cyjb.Compilers\Parsers\Production`1.cs,Production,The method has 5 parameters. Parameters: index' head' body' action' prec
Long Statement,Cyjb.Compilers,CompilerCommonExceptions,C:\repos\CYJB_Cyjb.Compilers\Cyjb.Compilers\CompilerExceptionHelper.cs,ParsingException,The length of the statement  "			return new SourceException(ExceptionResources.GetString("ParsingException"' pattern' message)' new SourceRange(start' end)); " is 124.
Complex Conditional,Cyjb.Compilers.RegularExpressions,RegexCharClass,C:\repos\CYJB_Cyjb.Compilers\Cyjb.Compilers\RegularExpressions\RegexCharClass.cs,AddCharClass,The conditional expression  "RccGetCanonical.Value(this.charClass) && thisRangeCount > 0 && ccRangeCount > 0 && 				RccSRGetFirst.Value(RccGetRangeAt.Value(cc.charClass' 0)) <= 					RccSRGetLast.Value(RccGetRangeAt.Value(this' thisRangeCount - 1))"  is complex.
Complex Conditional,Cyjb.Compilers.RegularExpressions,RegexParser,C:\repos\CYJB_Cyjb.Compilers\Cyjb.Compilers\RegularExpressions\RegexParser.cs,StartScanRegex,The conditional expression  "reader.Read() == '<' && reader.Read() == '<' &&  				reader.Read() == 'E' && reader.Read() == 'O' && reader.Read() == 'F' &&  				reader.Read() == '>' && reader.Read() == '>' && EndOfPattern"  is complex.
Complex Conditional,Cyjb.Compilers.RegularExpressions,RegexParser,C:\repos\CYJB_Cyjb.Compilers\Cyjb.Compilers\RegularExpressions\RegexParser.cs,ScanCharClass,The conditional expression  "ich == '-' && reader.Peek() == '[' && !escapedChar && !firstChar"  is complex.
Complex Conditional,Cyjb.Compilers.RegularExpressions,RegexParser,C:\repos\CYJB_Cyjb.Compilers\Cyjb.Compilers\RegularExpressions\RegexParser.cs,ScanNormalChars,The conditional expression  "!EndOfPattern &&  					(!IsStopperX(ich = reader.Peek()) || (ich == '{' && !IsTrueQuantifier() && !IsRegexName()))"  is complex.
Complex Conditional,Cyjb.Compilers.RegularExpressions,RegexParser,C:\repos\CYJB_Cyjb.Compilers\Cyjb.Compilers\RegularExpressions\RegexParser.cs,ScanNormalChars,The conditional expression  "!EndOfPattern &&  					(!IsSpecial(ich = reader.Peek()) || (ich == '{' && !IsTrueQuantifier() && !IsRegexName()))"  is complex.
Magic Number,Cyjb.Compilers.Lexers,LexerRule<T>,C:\repos\CYJB_Cyjb.Compilers\Cyjb.Compilers\Lexers\LexerRule`1.cs,FillDfa,The following statement contains a magic number: int headCnt = this.contextCount * 2;
Magic Number,Cyjb.Compilers.Lexers,LexerRule<T>,C:\repos\CYJB_Cyjb.Compilers\Cyjb.Compilers\Lexers\LexerRule`1.cs,BuildNfa,The following statement contains a magic number: foreach (Terminal<T> sym in grammar.Terminals) 			{ 				if (sym.RegularExpression is EndOfFileExp) 				{ 					continue; 				} 				sym.RegularExpression.BuildNfa(nfa); 				nfa.TailState.SymbolIndex = sym.Index; 				// 是否是行首限定的。 				bool isBeginningOfLine = false; 				AnchorExp anchorExp = sym.RegularExpression as AnchorExp; 				if (anchorExp != null) 				{ 					if (anchorExp.BeginningOfLine) 					{ 						isBeginningOfLine = true; 					} 					if (anchorExp.TrailingHeadState != null) 					{ 						// 设置向前看状态类型。 						anchorExp.TrailingHeadState.SymbolIndex = sym.Index; 						useTrailing = true; 					} 				} 				foreach (LexerContext context in sym.Context) 				{ 					if (isBeginningOfLine) 					{ 						// 行首限定规则。 						nfa[context.Index * 2 + 1].Add(nfa.HeadState); 					} 					else 					{ 						// 普通规则。 						nfa[context.Index * 2].Add(nfa.HeadState); 						nfa[context.Index * 2 + 1].Add(nfa.HeadState); 					} 				} 			}
Magic Number,Cyjb.Compilers.Lexers,LexerRule<T>,C:\repos\CYJB_Cyjb.Compilers\Cyjb.Compilers\Lexers\LexerRule`1.cs,BuildNfa,The following statement contains a magic number: foreach (Terminal<T> sym in grammar.Terminals) 			{ 				if (sym.RegularExpression is EndOfFileExp) 				{ 					continue; 				} 				sym.RegularExpression.BuildNfa(nfa); 				nfa.TailState.SymbolIndex = sym.Index; 				// 是否是行首限定的。 				bool isBeginningOfLine = false; 				AnchorExp anchorExp = sym.RegularExpression as AnchorExp; 				if (anchorExp != null) 				{ 					if (anchorExp.BeginningOfLine) 					{ 						isBeginningOfLine = true; 					} 					if (anchorExp.TrailingHeadState != null) 					{ 						// 设置向前看状态类型。 						anchorExp.TrailingHeadState.SymbolIndex = sym.Index; 						useTrailing = true; 					} 				} 				foreach (LexerContext context in sym.Context) 				{ 					if (isBeginningOfLine) 					{ 						// 行首限定规则。 						nfa[context.Index * 2 + 1].Add(nfa.HeadState); 					} 					else 					{ 						// 普通规则。 						nfa[context.Index * 2].Add(nfa.HeadState); 						nfa[context.Index * 2 + 1].Add(nfa.HeadState); 					} 				} 			}
Magic Number,Cyjb.Compilers.Lexers,LexerRule<T>,C:\repos\CYJB_Cyjb.Compilers\Cyjb.Compilers\Lexers\LexerRule`1.cs,BuildNfa,The following statement contains a magic number: foreach (Terminal<T> sym in grammar.Terminals) 			{ 				if (sym.RegularExpression is EndOfFileExp) 				{ 					continue; 				} 				sym.RegularExpression.BuildNfa(nfa); 				nfa.TailState.SymbolIndex = sym.Index; 				// 是否是行首限定的。 				bool isBeginningOfLine = false; 				AnchorExp anchorExp = sym.RegularExpression as AnchorExp; 				if (anchorExp != null) 				{ 					if (anchorExp.BeginningOfLine) 					{ 						isBeginningOfLine = true; 					} 					if (anchorExp.TrailingHeadState != null) 					{ 						// 设置向前看状态类型。 						anchorExp.TrailingHeadState.SymbolIndex = sym.Index; 						useTrailing = true; 					} 				} 				foreach (LexerContext context in sym.Context) 				{ 					if (isBeginningOfLine) 					{ 						// 行首限定规则。 						nfa[context.Index * 2 + 1].Add(nfa.HeadState); 					} 					else 					{ 						// 普通规则。 						nfa[context.Index * 2].Add(nfa.HeadState); 						nfa[context.Index * 2 + 1].Add(nfa.HeadState); 					} 				} 			}
Magic Number,Cyjb.Compilers.Lexers,LexerRule<T>,C:\repos\CYJB_Cyjb.Compilers\Cyjb.Compilers\Lexers\LexerRule`1.cs,SortStates,The following statement contains a magic number: int headCnt = this.contextCount * 2;
Magic Number,Cyjb.Compilers.Lexers,LexerRule<T>,C:\repos\CYJB_Cyjb.Compilers\Cyjb.Compilers\Lexers\LexerRule`1.cs,RemoveBeginningOfLineHeader,The following statement contains a magic number: if (this.ContainsBeginningOfLineHeader) 			{ 				this.ContainsBeginningOfLineHeader = false; 				StateData[] newStates = new StateData[this.stateCount - this.contextCount]; 				int idx = 0; 				for (int i = 0; i < this.contextCount; i++) 				{ 					newStates[idx++] = AdjustState(this.states[i + i]); 				} 				for (int i = this.contextCount * 2; i < this.stateCount; i++) 				{ 					newStates[idx++] = AdjustState(this.states[i]); 				} 				this.states = newStates; 				this.stateCount -= this.contextCount; 			}
Magic Number,Cyjb.Compilers.Lexers,LexerContext,C:\repos\CYJB_Cyjb.Compilers\Cyjb.Compilers\Lexers\LexerContext.cs,GetHashCode,The following statement contains a magic number: return 5425641 ^ this.index ^ this.contextType.GetHashCode() ^ this.label.GetHashCode();
Magic Number,Cyjb.Compilers.Lexers,TokenReaderBase<T>,C:\repos\CYJB_Cyjb.Compilers\Cyjb.Compilers\Lexers\TokenReaderBase`1.cs,InternalReadToken,The following statement contains a magic number: while (true)  			{  				if (this.Source.Peek() == -1)  				{  					// 到达了流的结尾。  					Action<ReaderController<T>> action = this.LexerRule.EofActions[context.Value];  					if (action != null)  					{  						this.DoAction(action' EndOfFileIndex);  						if (this.IsAccept)  						{  							return new Token<T>(this.controller.Id' this.controller.Text'  								Source.StartPosition' Source.StartPosition' this.controller.Value);  						}  					}  					return Token<T>.GetEndOfFile(Source.StartPosition);  				}  				// 起始状态与当前上下文相关。  				int state = this.context.Value;  				if (this.lexerRule.ContainsBeginningOfLineHeader)  				{  					state *= 2;  					if (this.Source.StartPosition.Col == 1)  					{  						// 行首规则。  						state++;  					}  				}  				if (!this.IsMore)  				{  					this.Start = Source.StartPosition;  				}  				if (InternalReadToken(state))  				{  					if (!this.IsMore && !this.IsReject)  					{  						this.Source.Drop();  					}  					if (this.IsAccept)  					{  						return new Token<T>(this.controller.Id' this.controller.Text'  							this.Start' this.Source.BeforeStartPosition' this.controller.Value);  					}  				}  				else  				{  					// 到达死状态。  					string text = this.Source.Accept();  					if (text.Length == 0)  					{  						// 如果没有匹配任何字符，强制读入一个字符，可以防止死循环出现。  						this.Source.Read();  						text = this.Source.Accept();  					}  					throw CommonExceptions.UnrecognizedToken(text'  						this.Start' this.Source.BeforeStartPosition);  				}  			}
Magic Number,Cyjb.Compilers.Parsers,LRItem<T>,C:\repos\CYJB_Cyjb.Compilers\Cyjb.Compilers\Parsers\LRItem`1.cs,ToString,The following statement contains a magic number: if (index >= production.Body.Count && forwards.Count > 0)  			{  				text.Append(" [");  				foreach (Terminal<T> sym in forwards)  				{  					text.Append(sym.ToString());  					text.Append("' ");  				}  				text.Length -= 2;  				text.Append(']');  			}
Magic Number,Cyjb.Compilers.Parsers,LRItem<T>,C:\repos\CYJB_Cyjb.Compilers\Cyjb.Compilers\Parsers\LRItem`1.cs,GetHashCode,The following statement contains a magic number: return production.GetHashCode() ^ (index << 16);
Magic Number,Cyjb.Compilers.Parsers,ParseAction,C:\repos\CYJB_Cyjb.Compilers\Cyjb.Compilers\Parsers\ParseAction.cs,GetHashCode,The following statement contains a magic number: return actionType.GetHashCode() ^ (index << 5);
Magic Number,Cyjb.Compilers.Parsers,ProductionData,C:\repos\CYJB_Cyjb.Compilers\Cyjb.Compilers\Parsers\ProductionData`1.cs,GetHashCode,The following statement contains a magic number: int hashCode = head ^ (bodySize << 5);
Magic Number,Cyjb.Compilers.RegularExpressions,RegexCharClass,C:\repos\CYJB_Cyjb.Compilers\Cyjb.Compilers\RegularExpressions\RegexCharClass.cs,GetDescription,The following statement contains a magic number: while (index < endPos) 			{ 				ch1 = charClass[index]; 				if (index + 1 < charClass.Length) 				{ 					ch2 = (char)(charClass[index + 1] - 1); 				} 				else 				{ 					ch2 = char.MaxValue; 				} 				builder.Append(CharDescription(ch1)); 				if (ch2 != ch1) 				{ 					// 字符范围。 					if (ch1 + 1 != ch2) 					{ 						builder.Append('-'); 					} 					builder.Append(CharDescription(ch2)); 				} 				index += 2; 			}
Magic Number,Cyjb.Compilers.RegularExpressions,RegexCharClass,C:\repos\CYJB_Cyjb.Compilers\Cyjb.Compilers\RegularExpressions\RegexCharClass.cs,CategoryDescription,The following statement contains a magic number: if (sch == 100) 			{ 				// SpaceConst = 100。 				return "\\s"; 			} 			else if (sch == -100) 			{ 				// NotSpaceConst = -100。 				return "\\S"; 			} 			else if (sch < 0) 			{ 				return string.Format(CultureInfo.InvariantCulture' "\\P{{{0}}}"' Categories[-sch - 1]); 			} 			else 			{ 				return string.Format(CultureInfo.InvariantCulture' "\\p{{{0}}}"' Categories[ch - 1]); 			}
Magic Number,Cyjb.Compilers.RegularExpressions,RegexCharClass,C:\repos\CYJB_Cyjb.Compilers\Cyjb.Compilers\RegularExpressions\RegexCharClass.cs,CategoryDescription,The following statement contains a magic number: if (sch == 100) 			{ 				// SpaceConst = 100。 				return "\\s"; 			} 			else if (sch == -100) 			{ 				// NotSpaceConst = -100。 				return "\\S"; 			} 			else if (sch < 0) 			{ 				return string.Format(CultureInfo.InvariantCulture' "\\P{{{0}}}"' Categories[-sch - 1]); 			} 			else 			{ 				return string.Format(CultureInfo.InvariantCulture' "\\p{{{0}}}"' Categories[ch - 1]); 			}
Magic Number,Cyjb.Compilers.RegularExpressions,RegexCharClass,C:\repos\CYJB_Cyjb.Compilers\Cyjb.Compilers\RegularExpressions\RegexCharClass.cs,AddUppercaseRange,The following statement contains a magic number: for (i = 0' iMax = ucTable.Length; i < iMax; ) 			{ 				iMid = (i + iMax) / 2; 				if (ucTable[iMid].ChMax < chMin) { i = iMid + 1; } 				else { iMax = iMid; } 			}
Magic Number,Cyjb.Compilers.RegularExpressions,RegexParser,C:\repos\CYJB_Cyjb.Compilers\Cyjb.Compilers\RegularExpressions\RegexParser.cs,ScanCharEscape,The following statement contains a magic number: switch (ich)  			{  				case 'x':  					return ScanHex(2);  				case 'u':  					return ScanHex(4);  				case 'a':  					return '\u0007';  				case 'b':  					return '\b';  				case 'e':  					return '\u001B';  				case 'f':  					return '\f';  				case 'n':  					return '\n';  				case 'r':  					return '\r';  				case 't':  					return '\t';  				case 'v':  					return '\u000B';  				case 'c':  					return ScanControl();  				default:  					char ch = (char)ich;  					if (!UseOptionEcma && RegexCharClass.IsWordChar(ch))  					{  						ThrowUnrecognizedEscape(ch);  					}  					return ch;  			}
Magic Number,Cyjb.Compilers.RegularExpressions,RegexParser,C:\repos\CYJB_Cyjb.Compilers\Cyjb.Compilers\RegularExpressions\RegexParser.cs,ScanCharEscape,The following statement contains a magic number: switch (ich)  			{  				case 'x':  					return ScanHex(2);  				case 'u':  					return ScanHex(4);  				case 'a':  					return '\u0007';  				case 'b':  					return '\b';  				case 'e':  					return '\u001B';  				case 'f':  					return '\f';  				case 'n':  					return '\n';  				case 'r':  					return '\r';  				case 't':  					return '\t';  				case 'v':  					return '\u000B';  				case 'c':  					return ScanControl();  				default:  					char ch = (char)ich;  					if (!UseOptionEcma && RegexCharClass.IsWordChar(ch))  					{  						ThrowUnrecognizedEscape(ch);  					}  					return ch;  			}
Magic Number,Cyjb.Compilers.RegularExpressions,RegexParser,C:\repos\CYJB_Cyjb.Compilers\Cyjb.Compilers\RegularExpressions\RegexParser.cs,ScanOctal,The following statement contains a magic number: int c = 3;
Magic Number,Cyjb.Compilers.RegularExpressions,RegexParser,C:\repos\CYJB_Cyjb.Compilers\Cyjb.Compilers\RegularExpressions\RegexParser.cs,ScanOctal,The following statement contains a magic number: for (i = 0; c > 0 && (uint)(d = (reader.Peek() - '0')) <= 7; c--)  			{  				reader.Read();  				i *= 8;  				i += d;  				if (UseOptionEcma && i >= 0x20)  				{  					break;  				}  			}
Magic Number,Cyjb.Compilers.RegularExpressions,RegexParser,C:\repos\CYJB_Cyjb.Compilers\Cyjb.Compilers\RegularExpressions\RegexParser.cs,ScanOctal,The following statement contains a magic number: for (i = 0; c > 0 && (uint)(d = (reader.Peek() - '0')) <= 7; c--)  			{  				reader.Read();  				i *= 8;  				i += d;  				if (UseOptionEcma && i >= 0x20)  				{  					break;  				}  			}
Magic Number,Cyjb.Compilers.RegularExpressions,RegexParser,C:\repos\CYJB_Cyjb.Compilers\Cyjb.Compilers\RegularExpressions\RegexParser.cs,ScanDecimal,The following statement contains a magic number: while ((uint)(d = (char)(reader.Peek() - '0')) <= 9)  			{  				reader.Read();  				if (i > MaxValueDiv10 || (i == MaxValueDiv10 && d > MaxValueMod10))  				{  					throw CommonExceptions.OverflowInt32();  				}  				i *= 10;  				i += d;  			}
Magic Number,Cyjb.Compilers.RegularExpressions,RegexParser,C:\repos\CYJB_Cyjb.Compilers\Cyjb.Compilers\RegularExpressions\RegexParser.cs,ScanDecimal,The following statement contains a magic number: while ((uint)(d = (char)(reader.Peek() - '0')) <= 9)  			{  				reader.Read();  				if (i > MaxValueDiv10 || (i == MaxValueDiv10 && d > MaxValueMod10))  				{  					throw CommonExceptions.OverflowInt32();  				}  				i *= 10;  				i += d;  			}
Magic Number,Cyjb.Compilers.RegularExpressions,RegexParser,C:\repos\CYJB_Cyjb.Compilers\Cyjb.Compilers\RegularExpressions\RegexParser.cs,HexDigit,The following statement contains a magic number: if ((uint)(d = ch - '0') <= 9)  			{  				return d;  			}
Magic Number,Cyjb.Compilers.RegularExpressions,RegexParser,C:\repos\CYJB_Cyjb.Compilers\Cyjb.Compilers\RegularExpressions\RegexParser.cs,HexDigit,The following statement contains a magic number: if ((uint)(d = ch - 'a') <= 5)  			{  				return d + 0xA;  			}
Magic Number,Cyjb.Compilers.RegularExpressions,RegexParser,C:\repos\CYJB_Cyjb.Compilers\Cyjb.Compilers\RegularExpressions\RegexParser.cs,HexDigit,The following statement contains a magic number: if ((uint)(d = ch - 'A') <= 5)  			{  				return d + 0xA;  			}
Magic Number,Cyjb.Compilers.RegularExpressions,RegexParser,C:\repos\CYJB_Cyjb.Compilers\Cyjb.Compilers\RegularExpressions\RegexParser.cs,IsTrueQuantifier,The following statement contains a magic number: if (ich == '{')  			{  				// 跳过数字。  				while ((ich = reader.Read()) >= '0' && ich <= '9') ;  				if (ich == -1 || reader.Index == startIdx + 2)  				{  					result = false;  				}  				else if (ich == '}')  				{  					// {n}  					result = true;  				}  				else if (ich != ''')  				{  					result = false;  				}  				else  				{  					// 跳过数字。  					while ((ich = reader.Read()) >= '0' && ich <= '9') ;  					// {n'm}  					result = (ich == '}');  				}  			}  			else  			{  				result = IsQuantifier(ich);  			}
Magic Number,Cyjb.Compilers.RegularExpressions,RegexParser,C:\repos\CYJB_Cyjb.Compilers\Cyjb.Compilers\RegularExpressions\RegexParser.cs,IsRegexName,The following statement contains a magic number: return (ich == '}' && cnt > 2);
Duplicate Code,Cyjb.Compilers.RegularExpressions,RegexParser,C:\repos\CYJB_Cyjb.Compilers\Cyjb.Compilers\RegularExpressions\RegexParser.cs,ScanBlank,The method contains a code clone-set at the following line numbers (starting from the method definition): ((9' 28)' (38' 57))
Missing Default,Cyjb.Compilers.Lexers,LexerRule<T>,C:\repos\CYJB_Cyjb.Compilers\Cyjb.Compilers\Lexers\LexerRule`1.cs,GetReader,The following switch statement is missing a default case: switch (this.trailingType) 			{ 				case TrailingType.None: 					return new SimpleReader<T>(this' source); 				case TrailingType.Fixed: 					return new FixedTrailingReader<T>(this' source); 				case TrailingType.Variable: 					return new RejectableTrailingReader<T>(this' source); 			}
Missing Default,Cyjb.Compilers.Lexers,LexerRule<T>,C:\repos\CYJB_Cyjb.Compilers\Cyjb.Compilers\Lexers\LexerRule`1.cs,GetRejectableReader,The following switch statement is missing a default case: switch (this.trailingType) 			{ 				case TrailingType.None: 					return new RejectableReader<T>(this' source); 				case TrailingType.Fixed: 				case TrailingType.Variable: 					return new RejectableTrailingReader<T>(this' source); 			}
Missing Default,Cyjb.Compilers.Parsers,LRParser<T>,C:\repos\CYJB_Cyjb.Compilers\Cyjb.Compilers\Parsers\LRParser`1.cs,Parse,The following switch statement is missing a default case: switch (action.ActionType)  				{  					case ParseActionType.Shift:  						Shift(token' action.Index);  						goto ReduceByUnique;  					case ParseActionType.Reduce:  						Reduce(action.Index);  						break;  					case ParseActionType.Accept:  						stateStack.Pop();  						result = tokenStack.Pop();  						return;  					case ParseActionType.Error:  						ReportError(state' token);  						// ErrorRecovery(state' token.Id);  						return;  				}
Missing Default,Cyjb.Compilers.Parsers,LRParser<T>,C:\repos\CYJB_Cyjb.Compilers\Cyjb.Compilers\Parsers\LRParser`1.cs,Parse,The following switch statement is missing a default case: switch (action.ActionType)  				{  					case ParseActionType.Reduce:  						Reduce(action.Index);  						break;  					case ParseActionType.Error:  						return;  				}
Missing Default,Cyjb.Compilers.Parsers,ParserRule<T>,C:\repos\CYJB_Cyjb.Compilers\Cyjb.Compilers\Parsers\ParserRule`1.cs,FindUniqueReduction,The following switch statement is missing a default case: switch (actions[i].ActionType)  				{  					case ParseActionType.Accept:  					case ParseActionType.Shift:  						return ParseAction.Error;  					case ParseActionType.Reduce:  						if (action.ActionType == ParseActionType.Error)  						{  							action = actions[i];  						}  						else if (action.Index != actions[i].Index)  						{  							return ParseAction.Error;  						}  						break;  				}
Missing Default,Cyjb.Compilers.RegularExpressions,RegexCharClass,C:\repos\CYJB_Cyjb.Compilers\Cyjb.Compilers\RegularExpressions\RegexCharClass.cs,AddUppercaseRange,The following switch statement is missing a default case: switch (uc.Operator) 				{ 					case UppercaseSet: 						chMinT = (char)uc.Data; 						chMaxT = (char)uc.Data; 						break; 					case UppercaseAdd: 						chMinT += (char)uc.Data; 						chMaxT += (char)uc.Data; 						break; 					case UppercaseBor: 						chMinT |= (char)1; 						chMaxT |= (char)1; 						break; 					case UppercaseBad: 						chMinT += (char)(chMinT & 1); 						chMaxT += (char)(chMaxT & 1); 						break; 				}
