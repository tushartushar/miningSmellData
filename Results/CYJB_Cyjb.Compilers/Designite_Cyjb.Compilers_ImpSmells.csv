Implementation smell,Namespace,Class,File,Method,Description
Long Method,Cyjb.Compilers.RegularExpressions,RegexParser,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\RegularExpressions\RegexParser.cs,ScanRegex,The method has 156 lines of code.
Complex Method,Cyjb.Compilers,NonTerminal,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\NonTerminal`1.cs,BuildProductions,Cyclomatic complexity of the method is 10
Complex Method,Cyjb.Compilers.Lexers,CharClass,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\Lexers\CharClass.cs,GetCharClass,Cyclomatic complexity of the method is 8
Complex Method,Cyjb.Compilers.Lexers,CharClass,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\Lexers\CharClass.cs,GetCharClassSet,Cyclomatic complexity of the method is 10
Complex Method,Cyjb.Compilers.Lexers,Dfa,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\Lexers\Dfa.cs,MapGroup,Cyclomatic complexity of the method is 10
Complex Method,Cyjb.Compilers.Lexers,Dfa,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\Lexers\Dfa.cs,MergeState,Cyclomatic complexity of the method is 12
Complex Method,Cyjb.Compilers.Lexers,FixedTrailingReader,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\Lexers\FixedTrailingReader`1.cs,InternalReadToken,Cyclomatic complexity of the method is 8
Complex Method,Cyjb.Compilers.Lexers,LexerRule,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\Lexers\LexerRule`1.cs,FillTrailing,Cyclomatic complexity of the method is 8
Complex Method,Cyjb.Compilers.Lexers,LexerRule,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\Lexers\LexerRule`1.cs,BuildNfa,Cyclomatic complexity of the method is 9
Complex Method,Cyjb.Compilers.Lexers,TokenReaderBase,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\Lexers\TokenReaderBase`1.cs,InternalReadToken,Cyclomatic complexity of the method is 12
Complex Method,Cyjb.Compilers.Lexers,RejectableTrailingReader,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\Lexers\RejectableTrailingReader`1.cs,InternalReadToken,Cyclomatic complexity of the method is 13
Complex Method,Cyjb.Compilers.Parsers,LRParser,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\Parsers\LRParser`1.cs,Parse,Cyclomatic complexity of the method is 18
Complex Method,Cyjb.Compilers.Parsers,LRItem,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\Parsers\LRItem`1.cs,ToString,Cyclomatic complexity of the method is 9
Complex Method,Cyjb.Compilers.Parsers,LRItemCollection,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\Parsers\LRItemCollection`1.cs,Equals,Cyclomatic complexity of the method is 9
Complex Method,Cyjb.Compilers.Parsers,ParserRule,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\Parsers\ParserRule`1.cs,SpreadForward,Cyclomatic complexity of the method is 10
Complex Method,Cyjb.Compilers.Parsers,ParserRule,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\Parsers\ParserRule`1.cs,LR1Closure,Cyclomatic complexity of the method is 9
Complex Method,Cyjb.Compilers.Parsers,ParserRule,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\Parsers\ParserRule`1.cs,BuildLRTable,Cyclomatic complexity of the method is 12
Complex Method,Cyjb.Compilers.Parsers,ParserRule,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\Parsers\ParserRule`1.cs,ResolveActions,Cyclomatic complexity of the method is 16
Complex Method,Cyjb.Compilers.Parsers,ParserRule,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\Parsers\ParserRule`1.cs,FindUniqueReduction,Cyclomatic complexity of the method is 8
Complex Method,Cyjb.Compilers.RegularExpressions,CharClassExp,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\RegularExpressions\CharClassExp.cs,ToString,Cyclomatic complexity of the method is 13
Complex Method,Cyjb.Compilers.RegularExpressions,RegexCharClass,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\RegularExpressions\RegexCharClass.cs,GetDescription,Cyclomatic complexity of the method is 15
Complex Method,Cyjb.Compilers.RegularExpressions,RegexCharClass,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\RegularExpressions\RegexCharClass.cs,AddUppercaseRange,Cyclomatic complexity of the method is 23
Complex Method,Cyjb.Compilers.RegularExpressions,RegexParser,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\RegularExpressions\RegexParser.cs,ScanRegex,Cyclomatic complexity of the method is 69
Complex Method,Cyjb.Compilers.RegularExpressions,RegexParser,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\RegularExpressions\RegexParser.cs,ScanCharClass,Cyclomatic complexity of the method is 18
Complex Method,Cyjb.Compilers.RegularExpressions,RegexParser,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\RegularExpressions\RegexParser.cs,ScanRepeat,Cyclomatic complexity of the method is 27
Complex Method,Cyjb.Compilers.RegularExpressions,RegexParser,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\RegularExpressions\RegexParser.cs,ScanBlank,Cyclomatic complexity of the method is 18
Complex Method,Cyjb.Compilers.RegularExpressions,RegexParser,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\RegularExpressions\RegexParser.cs,ScanBackslash,Cyclomatic complexity of the method is 22
Complex Method,Cyjb.Compilers.RegularExpressions,RegexParser,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\RegularExpressions\RegexParser.cs,ScanBackslash,Cyclomatic complexity of the method is 19
Complex Method,Cyjb.Compilers.RegularExpressions,RegexParser,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\RegularExpressions\RegexParser.cs,ScanCharEscape,Cyclomatic complexity of the method is 16
Complex Method,Cyjb.Compilers.RegularExpressions,RegexParser,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\RegularExpressions\RegexParser.cs,IsTrueQuantifier,Cyclomatic complexity of the method is 9
Complex Method,Cyjb.Compilers.RegularExpressions,RepeatExp,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\RegularExpressions\RepeatExp.cs,ToString,Cyclomatic complexity of the method is 9
Long Parameter List,Cyjb.Compilers,Production,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\Parsers\Production`1.cs,Production,The method has 5 parameters.
Long Statement,Cyjb.Compilers,CompilerCommonExceptions,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\CompilerExceptionHelper.cs,ParsingException,The length of the statement  "	return new SourceException (ExceptionResources.GetString ("ParsingException"' pattern' message)' new SourceRange (start' end)); " is 127.
Long Statement,Cyjb.Compilers,Grammar,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\Grammar`1.cs,CheckSymbolId,The length of the statement  "	if (EqualityComparer<T>.Default.Equals (id' Token<T>.EndOfFile) || EqualityComparer<T>.Default.Equals (id' Token<T>.Error)) { " is 125.
Long Statement,Cyjb.Compilers.Lexers,Dfa,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\Lexers\Dfa.cs,MapGroup,The length of the statement  "			foreach (IGrouping<int[]' DfaState> states in groups [i].GroupBy<DfaState' int[]> (state => MapGroupIndex (state' groupIdx)' iarrCmp)) { " is 136.
Long Statement,Cyjb.Compilers.Lexers,Dfa,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\Lexers\Dfa.cs,MinimizeCharClass,The length of the statement  "	IEnumerable<int>[] charClassGroup = 0.To (ccCnt - 1).GroupBy (i => charClassMap [i]' ListEqualityComparer<int>.Default).ToArray (); " is 131.
Long Statement,Cyjb.Compilers.Lexers,Nfa,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\Lexers\Nfa.cs,BuildDfa,The length of the statement  "	Dictionary<HashSet<NfaState>' DfaState> dfaStateMap = new Dictionary<HashSet<NfaState>' DfaState> (SetEqualityComparer<NfaState>.Default); " is 138.
Long Statement,Cyjb.Compilers.Lexers,TokenReaderBase,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\Lexers\TokenReaderBase`1.cs,InternalReadToken,The length of the statement  "					return new Token<T> (this.controller.Id' this.controller.Text' Source.StartPosition' Source.StartPosition' this.controller.Value); " is 130.
Long Statement,Cyjb.Compilers.Lexers,TokenReaderBase,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\Lexers\TokenReaderBase`1.cs,InternalReadToken,The length of the statement  "				return new Token<T> (this.controller.Id' this.controller.Text' this.Start' this.Source.BeforeStartPosition' this.controller.Value); " is 131.
Long Statement,Cyjb.Compilers.Parsers,LRParser,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\Parsers\LRParser`1.cs,Reduce,The length of the statement  "	tokenStack.Push (new Token<T> ((T)(object)(info.Head + rule.NonTerminalOffset)' null' controller.Start' controller.End' value)); " is 128.
Long Statement,Cyjb.Compilers.Parsers,ParserRule,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\Parsers\ParserRule`1.cs,FillProductions,The length of the statement  "			this.productionData [production.Index] = new ProductionData<T> (production.Head.Index' production.Body.Count' production.Action); " is 129.
Long Statement,Cyjb.Compilers.Parsers,ParserRule,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\Parsers\ParserRule`1.cs,BuildLRTable,The length of the statement  "					actions [tSym.Index + Constants.TokenOffset].Add (new Tuple<LRItem<T>' ParseAction> (item' ParseAction.Shift (targetIndex))); " is 125.
Long Statement,Cyjb.Compilers.Parsers,ParserRule,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\Parsers\ParserRule`1.cs,BuildLRTable,The length of the statement  "					actions [sym.Index + Constants.TokenOffset].Add (new Tuple<LRItem<T>' ParseAction> (item' ParseAction.Reduce (targetIndex))); " is 125.
Long Statement,Cyjb.Compilers.RegularExpressions,RegexCharClass,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\RegularExpressions\RegexCharClass.cs,AddCharClass,The length of the statement  "	} else if (RccGetCanonical.Value (this.charClass) && thisRangeCount > 0 && ccRangeCount > 0 && RccSRGetFirst.Value (RccGetRangeAt.Value (cc.charClass' 0)) <= RccSRGetLast.Value (RccGetRangeAt.Value (this' thisRangeCount - 1))) { " is 228.
Long Statement,Cyjb.Compilers.RegularExpressions,RegexParser,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\RegularExpressions\RegexParser.cs,StartScanRegex,The length of the statement  "	if (reader.Read () == '<' && reader.Read () == '<' && reader.Read () == 'E' && reader.Read () == 'O' && reader.Read () == 'F' && reader.Read () == '>' && reader.Read () == '>' && EndOfPattern) { " is 194.
Long Statement,Cyjb.Compilers.RegularExpressions,RegexParser,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\RegularExpressions\RegexParser.cs,ScanNormalChars,The length of the statement  "		while (!EndOfPattern && (!IsStopperX (ich = reader.Peek ()) || (ich == '{' && !IsTrueQuantifier () && !IsRegexName ()))) { " is 122.
Long Statement,Cyjb.Compilers.RegularExpressions,RegexParser,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\RegularExpressions\RegexParser.cs,ScanNormalChars,The length of the statement  "		while (!EndOfPattern && (!IsSpecial (ich = reader.Peek ()) || (ich == '{' && !IsTrueQuantifier () && !IsRegexName ()))) { " is 121.
Complex Conditional,Cyjb.Compilers.RegularExpressions,RegexCharClass,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\RegularExpressions\RegexCharClass.cs,AddCharClass,The conditional expression  "RccGetCanonical.Value (this.charClass) && thisRangeCount > 0 && ccRangeCount > 0 && RccSRGetFirst.Value (RccGetRangeAt.Value (cc.charClass' 0)) <= RccSRGetLast.Value (RccGetRangeAt.Value (this' thisRangeCount - 1))"  is complex.
Complex Conditional,Cyjb.Compilers.RegularExpressions,RegexParser,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\RegularExpressions\RegexParser.cs,StartScanRegex,The conditional expression  "reader.Read () == '<' && reader.Read () == '<' && reader.Read () == 'E' && reader.Read () == 'O' && reader.Read () == 'F' && reader.Read () == '>' && reader.Read () == '>' && EndOfPattern"  is complex.
Complex Conditional,Cyjb.Compilers.RegularExpressions,RegexParser,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\RegularExpressions\RegexParser.cs,ScanCharClass,The conditional expression  "ich == '-' && reader.Peek () == '[' && !escapedChar && !firstChar"  is complex.
Magic Number,Cyjb.Compilers.Lexers,LexerRule,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\Lexers\LexerRule`1.cs,BuildNfa,The following statement contains a magic number: foreach (Terminal<T> sym in grammar.Terminals) {  	if (sym.RegularExpression is EndOfFileExp) {  		continue;  	}  	sym.RegularExpression.BuildNfa (nfa);  	nfa.TailState.SymbolIndex = sym.Index;  	// 是否是行首限定的。  	bool isBeginningOfLine = false;  	AnchorExp anchorExp = sym.RegularExpression as AnchorExp;  	if (anchorExp != null) {  		if (anchorExp.BeginningOfLine) {  			isBeginningOfLine = true;  		}  		if (anchorExp.TrailingHeadState != null) {  			// 设置向前看状态类型。  			anchorExp.TrailingHeadState.SymbolIndex = sym.Index;  			useTrailing = true;  		}  	}  	foreach (LexerContext context in sym.Context) {  		if (isBeginningOfLine) {  			// 行首限定规则。  			nfa [context.Index * 2 + 1].Add (nfa.HeadState);  		} else {  			// 普通规则。  			nfa [context.Index * 2].Add (nfa.HeadState);  			nfa [context.Index * 2 + 1].Add (nfa.HeadState);  		}  	}  }  
Magic Number,Cyjb.Compilers.Lexers,LexerRule,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\Lexers\LexerRule`1.cs,BuildNfa,The following statement contains a magic number: foreach (Terminal<T> sym in grammar.Terminals) {  	if (sym.RegularExpression is EndOfFileExp) {  		continue;  	}  	sym.RegularExpression.BuildNfa (nfa);  	nfa.TailState.SymbolIndex = sym.Index;  	// 是否是行首限定的。  	bool isBeginningOfLine = false;  	AnchorExp anchorExp = sym.RegularExpression as AnchorExp;  	if (anchorExp != null) {  		if (anchorExp.BeginningOfLine) {  			isBeginningOfLine = true;  		}  		if (anchorExp.TrailingHeadState != null) {  			// 设置向前看状态类型。  			anchorExp.TrailingHeadState.SymbolIndex = sym.Index;  			useTrailing = true;  		}  	}  	foreach (LexerContext context in sym.Context) {  		if (isBeginningOfLine) {  			// 行首限定规则。  			nfa [context.Index * 2 + 1].Add (nfa.HeadState);  		} else {  			// 普通规则。  			nfa [context.Index * 2].Add (nfa.HeadState);  			nfa [context.Index * 2 + 1].Add (nfa.HeadState);  		}  	}  }  
Magic Number,Cyjb.Compilers.Lexers,LexerRule,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\Lexers\LexerRule`1.cs,BuildNfa,The following statement contains a magic number: foreach (Terminal<T> sym in grammar.Terminals) {  	if (sym.RegularExpression is EndOfFileExp) {  		continue;  	}  	sym.RegularExpression.BuildNfa (nfa);  	nfa.TailState.SymbolIndex = sym.Index;  	// 是否是行首限定的。  	bool isBeginningOfLine = false;  	AnchorExp anchorExp = sym.RegularExpression as AnchorExp;  	if (anchorExp != null) {  		if (anchorExp.BeginningOfLine) {  			isBeginningOfLine = true;  		}  		if (anchorExp.TrailingHeadState != null) {  			// 设置向前看状态类型。  			anchorExp.TrailingHeadState.SymbolIndex = sym.Index;  			useTrailing = true;  		}  	}  	foreach (LexerContext context in sym.Context) {  		if (isBeginningOfLine) {  			// 行首限定规则。  			nfa [context.Index * 2 + 1].Add (nfa.HeadState);  		} else {  			// 普通规则。  			nfa [context.Index * 2].Add (nfa.HeadState);  			nfa [context.Index * 2 + 1].Add (nfa.HeadState);  		}  	}  }  
Magic Number,Cyjb.Compilers.Lexers,LexerRule,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\Lexers\LexerRule`1.cs,BuildNfa,The following statement contains a magic number: foreach (LexerContext context in sym.Context) {  	if (isBeginningOfLine) {  		// 行首限定规则。  		nfa [context.Index * 2 + 1].Add (nfa.HeadState);  	} else {  		// 普通规则。  		nfa [context.Index * 2].Add (nfa.HeadState);  		nfa [context.Index * 2 + 1].Add (nfa.HeadState);  	}  }  
Magic Number,Cyjb.Compilers.Lexers,LexerRule,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\Lexers\LexerRule`1.cs,BuildNfa,The following statement contains a magic number: foreach (LexerContext context in sym.Context) {  	if (isBeginningOfLine) {  		// 行首限定规则。  		nfa [context.Index * 2 + 1].Add (nfa.HeadState);  	} else {  		// 普通规则。  		nfa [context.Index * 2].Add (nfa.HeadState);  		nfa [context.Index * 2 + 1].Add (nfa.HeadState);  	}  }  
Magic Number,Cyjb.Compilers.Lexers,LexerRule,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\Lexers\LexerRule`1.cs,BuildNfa,The following statement contains a magic number: foreach (LexerContext context in sym.Context) {  	if (isBeginningOfLine) {  		// 行首限定规则。  		nfa [context.Index * 2 + 1].Add (nfa.HeadState);  	} else {  		// 普通规则。  		nfa [context.Index * 2].Add (nfa.HeadState);  		nfa [context.Index * 2 + 1].Add (nfa.HeadState);  	}  }  
Magic Number,Cyjb.Compilers.Lexers,LexerRule,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\Lexers\LexerRule`1.cs,BuildNfa,The following statement contains a magic number: if (isBeginningOfLine) {  	// 行首限定规则。  	nfa [context.Index * 2 + 1].Add (nfa.HeadState);  } else {  	// 普通规则。  	nfa [context.Index * 2].Add (nfa.HeadState);  	nfa [context.Index * 2 + 1].Add (nfa.HeadState);  }  
Magic Number,Cyjb.Compilers.Lexers,LexerRule,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\Lexers\LexerRule`1.cs,BuildNfa,The following statement contains a magic number: if (isBeginningOfLine) {  	// 行首限定规则。  	nfa [context.Index * 2 + 1].Add (nfa.HeadState);  } else {  	// 普通规则。  	nfa [context.Index * 2].Add (nfa.HeadState);  	nfa [context.Index * 2 + 1].Add (nfa.HeadState);  }  
Magic Number,Cyjb.Compilers.Lexers,LexerRule,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\Lexers\LexerRule`1.cs,BuildNfa,The following statement contains a magic number: if (isBeginningOfLine) {  	// 行首限定规则。  	nfa [context.Index * 2 + 1].Add (nfa.HeadState);  } else {  	// 普通规则。  	nfa [context.Index * 2].Add (nfa.HeadState);  	nfa [context.Index * 2 + 1].Add (nfa.HeadState);  }  
Magic Number,Cyjb.Compilers.Lexers,LexerRule,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\Lexers\LexerRule`1.cs,BuildNfa,The following statement contains a magic number: nfa [context.Index * 2 + 1].Add (nfa.HeadState);  
Magic Number,Cyjb.Compilers.Lexers,LexerRule,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\Lexers\LexerRule`1.cs,BuildNfa,The following statement contains a magic number: nfa [context.Index * 2].Add (nfa.HeadState);  
Magic Number,Cyjb.Compilers.Lexers,LexerRule,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\Lexers\LexerRule`1.cs,BuildNfa,The following statement contains a magic number: nfa [context.Index * 2 + 1].Add (nfa.HeadState);  
Magic Number,Cyjb.Compilers.Lexers,LexerRule,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\Lexers\LexerRule`1.cs,RemoveBeginningOfLineHeader,The following statement contains a magic number: if (this.ContainsBeginningOfLineHeader) {  	this.ContainsBeginningOfLineHeader = false;  	StateData[] newStates = new StateData[this.stateCount - this.contextCount];  	int idx = 0;  	for (int i = 0; i < this.contextCount; i++) {  		newStates [idx++] = AdjustState (this.states [i + i]);  	}  	for (int i = this.contextCount * 2; i < this.stateCount; i++) {  		newStates [idx++] = AdjustState (this.states [i]);  	}  	this.states = newStates;  	this.stateCount -= this.contextCount;  }  
Magic Number,Cyjb.Compilers.Lexers,LexerRule,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\Lexers\LexerRule`1.cs,RemoveBeginningOfLineHeader,The following statement contains a magic number: for (int i = this.contextCount * 2; i < this.stateCount; i++) {  	newStates [idx++] = AdjustState (this.states [i]);  }  
Magic Number,Cyjb.Compilers.Lexers,LexerContext,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\Lexers\LexerContext.cs,GetHashCode,The following statement contains a magic number: return 5425641 ^ this.index ^ this.contextType.GetHashCode () ^ this.label.GetHashCode ();  
Magic Number,Cyjb.Compilers.Lexers,TokenReaderBase,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\Lexers\TokenReaderBase`1.cs,InternalReadToken,The following statement contains a magic number: while (true) {  	if (this.Source.Peek () == -1) {  		// 到达了流的结尾。  		Action<ReaderController<T>> action = this.LexerRule.EofActions [context.Value];  		if (action != null) {  			this.DoAction (action' EndOfFileIndex);  			if (this.IsAccept) {  				return new Token<T> (this.controller.Id' this.controller.Text' Source.StartPosition' Source.StartPosition' this.controller.Value);  			}  		}  		return Token<T>.GetEndOfFile (Source.StartPosition);  	}  	// 起始状态与当前上下文相关。  	int state = this.context.Value;  	if (this.lexerRule.ContainsBeginningOfLineHeader) {  		state *= 2;  		if (this.Source.StartPosition.Col == 1) {  			// 行首规则。  			state++;  		}  	}  	if (!this.IsMore) {  		this.Start = Source.StartPosition;  	}  	if (InternalReadToken (state)) {  		if (!this.IsMore && !this.IsReject) {  			this.Source.Drop ();  		}  		if (this.IsAccept) {  			return new Token<T> (this.controller.Id' this.controller.Text' this.Start' this.Source.BeforeStartPosition' this.controller.Value);  		}  	} else {  		// 到达死状态。  		string text = this.Source.Accept ();  		if (text.Length == 0) {  			// 如果没有匹配任何字符，强制读入一个字符，可以防止死循环出现。  			this.Source.Read ();  			text = this.Source.Accept ();  		}  		throw CommonExceptions.UnrecognizedToken (text' this.Start' this.Source.BeforeStartPosition);  	}  }  
Magic Number,Cyjb.Compilers.Lexers,TokenReaderBase,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\Lexers\TokenReaderBase`1.cs,InternalReadToken,The following statement contains a magic number: if (this.lexerRule.ContainsBeginningOfLineHeader) {  	state *= 2;  	if (this.Source.StartPosition.Col == 1) {  		// 行首规则。  		state++;  	}  }  
Magic Number,Cyjb.Compilers.Lexers,TokenReaderBase,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\Lexers\TokenReaderBase`1.cs,InternalReadToken,The following statement contains a magic number: state *= 2;  
Magic Number,Cyjb.Compilers.Parsers,LRItem,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\Parsers\LRItem`1.cs,ToString,The following statement contains a magic number: if (index >= production.Body.Count && forwards.Count > 0) {  	text.Append (" [");  	foreach (Terminal<T> sym in forwards) {  		text.Append (sym.ToString ());  		text.Append ("' ");  	}  	text.Length -= 2;  	text.Append (']');  }  
Magic Number,Cyjb.Compilers.Parsers,LRItem,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\Parsers\LRItem`1.cs,ToString,The following statement contains a magic number: text.Length -= 2;  
Magic Number,Cyjb.Compilers.Parsers,LRItem,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\Parsers\LRItem`1.cs,GetHashCode,The following statement contains a magic number: return production.GetHashCode () ^ (index << 16);  
Magic Number,Cyjb.Compilers.Parsers,ParseAction,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\Parsers\ParseAction.cs,GetHashCode,The following statement contains a magic number: return actionType.GetHashCode () ^ (index << 5);  
Magic Number,Cyjb.Compilers.RegularExpressions,RegexCharClass,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\RegularExpressions\RegexCharClass.cs,GetDescription,The following statement contains a magic number: while (index < endPos) {  	ch1 = charClass [index];  	if (index + 1 < charClass.Length) {  		ch2 = (char)(charClass [index + 1] - 1);  	} else {  		ch2 = char.MaxValue;  	}  	builder.Append (CharDescription (ch1));  	if (ch2 != ch1) {  		// 字符范围。  		if (ch1 + 1 != ch2) {  			builder.Append ('-');  		}  		builder.Append (CharDescription (ch2));  	}  	index += 2;  }  
Magic Number,Cyjb.Compilers.RegularExpressions,RegexCharClass,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\RegularExpressions\RegexCharClass.cs,GetDescription,The following statement contains a magic number: index += 2;  
Magic Number,Cyjb.Compilers.RegularExpressions,RegexCharClass,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\RegularExpressions\RegexCharClass.cs,CategoryDescription,The following statement contains a magic number: if (sch == 100) {  	// SpaceConst = 100。  	return "\\s";  } else if (sch == -100) {  	// NotSpaceConst = -100。  	return "\\S";  } else if (sch < 0) {  	return string.Format (CultureInfo.InvariantCulture' "\\P{{{0}}}"' Categories [-sch - 1]);  } else {  	return string.Format (CultureInfo.InvariantCulture' "\\p{{{0}}}"' Categories [ch - 1]);  }  
Magic Number,Cyjb.Compilers.RegularExpressions,RegexCharClass,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\RegularExpressions\RegexCharClass.cs,CategoryDescription,The following statement contains a magic number: if (sch == 100) {  	// SpaceConst = 100。  	return "\\s";  } else if (sch == -100) {  	// NotSpaceConst = -100。  	return "\\S";  } else if (sch < 0) {  	return string.Format (CultureInfo.InvariantCulture' "\\P{{{0}}}"' Categories [-sch - 1]);  } else {  	return string.Format (CultureInfo.InvariantCulture' "\\p{{{0}}}"' Categories [ch - 1]);  }  
Magic Number,Cyjb.Compilers.RegularExpressions,RegexCharClass,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\RegularExpressions\RegexCharClass.cs,CategoryDescription,The following statement contains a magic number: if (sch == -100) {  	// NotSpaceConst = -100。  	return "\\S";  } else if (sch < 0) {  	return string.Format (CultureInfo.InvariantCulture' "\\P{{{0}}}"' Categories [-sch - 1]);  } else {  	return string.Format (CultureInfo.InvariantCulture' "\\p{{{0}}}"' Categories [ch - 1]);  }  
Magic Number,Cyjb.Compilers.RegularExpressions,RegexCharClass,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\RegularExpressions\RegexCharClass.cs,AddUppercaseRange,The following statement contains a magic number: for (i = 0' iMax = ucTable.Length; i < iMax;) {  	iMid = (i + iMax) / 2;  	if (ucTable [iMid].ChMax < chMin) {  		i = iMid + 1;  	} else {  		iMax = iMid;  	}  }  
Magic Number,Cyjb.Compilers.RegularExpressions,RegexCharClass,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\RegularExpressions\RegexCharClass.cs,AddUppercaseRange,The following statement contains a magic number: iMid = (i + iMax) / 2;  
Magic Number,Cyjb.Compilers.RegularExpressions,RegexParser,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\RegularExpressions\RegexParser.cs,ScanCharEscape,The following statement contains a magic number: switch (ich) {  case 'x':  	return ScanHex (2);  case 'u':  	return ScanHex (4);  case 'a':  	return '\u0007';  case 'b':  	return '\b';  case 'e':  	return '\u001B';  case 'f':  	return '\f';  case 'n':  	return '\n';  case 'r':  	return '\r';  case 't':  	return '\t';  case 'v':  	return '\u000B';  case 'c':  	return ScanControl ();  default:  	char ch = (char)ich;  	if (!UseOptionEcma && RegexCharClass.IsWordChar (ch)) {  		ThrowUnrecognizedEscape (ch);  	}  	return ch;  }  
Magic Number,Cyjb.Compilers.RegularExpressions,RegexParser,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\RegularExpressions\RegexParser.cs,ScanCharEscape,The following statement contains a magic number: switch (ich) {  case 'x':  	return ScanHex (2);  case 'u':  	return ScanHex (4);  case 'a':  	return '\u0007';  case 'b':  	return '\b';  case 'e':  	return '\u001B';  case 'f':  	return '\f';  case 'n':  	return '\n';  case 'r':  	return '\r';  case 't':  	return '\t';  case 'v':  	return '\u000B';  case 'c':  	return ScanControl ();  default:  	char ch = (char)ich;  	if (!UseOptionEcma && RegexCharClass.IsWordChar (ch)) {  		ThrowUnrecognizedEscape (ch);  	}  	return ch;  }  
Magic Number,Cyjb.Compilers.RegularExpressions,RegexParser,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\RegularExpressions\RegexParser.cs,ScanCharEscape,The following statement contains a magic number: return ScanHex (2);  
Magic Number,Cyjb.Compilers.RegularExpressions,RegexParser,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\RegularExpressions\RegexParser.cs,ScanCharEscape,The following statement contains a magic number: return ScanHex (4);  
Magic Number,Cyjb.Compilers.RegularExpressions,RegexParser,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\RegularExpressions\RegexParser.cs,ScanOctal,The following statement contains a magic number: for (i = 0; c > 0 && (uint)(d = (reader.Peek () - '0')) <= 7; c--) {  	reader.Read ();  	i *= 8;  	i += d;  	if (UseOptionEcma && i >= 0x20) {  		break;  	}  }  
Magic Number,Cyjb.Compilers.RegularExpressions,RegexParser,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\RegularExpressions\RegexParser.cs,ScanOctal,The following statement contains a magic number: for (i = 0; c > 0 && (uint)(d = (reader.Peek () - '0')) <= 7; c--) {  	reader.Read ();  	i *= 8;  	i += d;  	if (UseOptionEcma && i >= 0x20) {  		break;  	}  }  
Magic Number,Cyjb.Compilers.RegularExpressions,RegexParser,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\RegularExpressions\RegexParser.cs,ScanOctal,The following statement contains a magic number: i *= 8;  
Magic Number,Cyjb.Compilers.RegularExpressions,RegexParser,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\RegularExpressions\RegexParser.cs,ScanDecimal,The following statement contains a magic number: while ((uint)(d = (char)(reader.Peek () - '0')) <= 9) {  	reader.Read ();  	if (i > MaxValueDiv10 || (i == MaxValueDiv10 && d > MaxValueMod10)) {  		throw CommonExceptions.OverflowInt32 ();  	}  	i *= 10;  	i += d;  }  
Magic Number,Cyjb.Compilers.RegularExpressions,RegexParser,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\RegularExpressions\RegexParser.cs,ScanDecimal,The following statement contains a magic number: while ((uint)(d = (char)(reader.Peek () - '0')) <= 9) {  	reader.Read ();  	if (i > MaxValueDiv10 || (i == MaxValueDiv10 && d > MaxValueMod10)) {  		throw CommonExceptions.OverflowInt32 ();  	}  	i *= 10;  	i += d;  }  
Magic Number,Cyjb.Compilers.RegularExpressions,RegexParser,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\RegularExpressions\RegexParser.cs,ScanDecimal,The following statement contains a magic number: i *= 10;  
Magic Number,Cyjb.Compilers.RegularExpressions,RegexParser,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\RegularExpressions\RegexParser.cs,HexDigit,The following statement contains a magic number: if ((uint)(d = ch - '0') <= 9) {  	return d;  }  
Magic Number,Cyjb.Compilers.RegularExpressions,RegexParser,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\RegularExpressions\RegexParser.cs,HexDigit,The following statement contains a magic number: if ((uint)(d = ch - 'a') <= 5) {  	return d + 0xA;  }  
Magic Number,Cyjb.Compilers.RegularExpressions,RegexParser,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\RegularExpressions\RegexParser.cs,HexDigit,The following statement contains a magic number: if ((uint)(d = ch - 'A') <= 5) {  	return d + 0xA;  }  
Magic Number,Cyjb.Compilers.RegularExpressions,RegexParser,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\RegularExpressions\RegexParser.cs,IsTrueQuantifier,The following statement contains a magic number: if (ich == '{') {  	// 跳过数字。  	while ((ich = reader.Read ()) >= '0' && ich <= '9')  		;  	if (ich == -1 || reader.Index == startIdx + 2) {  		result = false;  	} else if (ich == '}') {  		// {n}  		result = true;  	} else if (ich != ''') {  		result = false;  	} else {  		// 跳过数字。  		while ((ich = reader.Read ()) >= '0' && ich <= '9')  			;  		// {n'm}  		result = (ich == '}');  	}  } else {  	result = IsQuantifier (ich);  }  
Magic Number,Cyjb.Compilers.RegularExpressions,RegexParser,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\RegularExpressions\RegexParser.cs,IsTrueQuantifier,The following statement contains a magic number: if (ich == -1 || reader.Index == startIdx + 2) {  	result = false;  } else if (ich == '}') {  	// {n}  	result = true;  } else if (ich != ''') {  	result = false;  } else {  	// 跳过数字。  	while ((ich = reader.Read ()) >= '0' && ich <= '9')  		;  	// {n'm}  	result = (ich == '}');  }  
Magic Number,Cyjb.Compilers.RegularExpressions,RegexParser,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\RegularExpressions\RegexParser.cs,IsRegexName,The following statement contains a magic number: return (ich == '}' && cnt > 2);  
Missing Default,Cyjb.Compilers.Lexers,LexerRule,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\Lexers\LexerRule`1.cs,GetReader,The following switch statement is missing a default case: switch (this.trailingType) {  case TrailingType.None:  	return new SimpleReader<T> (this' source);  case TrailingType.Fixed:  	return new FixedTrailingReader<T> (this' source);  case TrailingType.Variable:  	return new RejectableTrailingReader<T> (this' source);  }  
Missing Default,Cyjb.Compilers.Lexers,LexerRule,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\Lexers\LexerRule`1.cs,GetRejectableReader,The following switch statement is missing a default case: switch (this.trailingType) {  case TrailingType.None:  	return new RejectableReader<T> (this' source);  case TrailingType.Fixed:  case TrailingType.Variable:  	return new RejectableTrailingReader<T> (this' source);  }  
Missing Default,Cyjb.Compilers.Parsers,LRParser,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\Parsers\LRParser`1.cs,Parse,The following switch statement is missing a default case: switch (action.ActionType) {  case ParseActionType.Shift:  	Shift (token' action.Index);  	goto ReduceByUnique;  case ParseActionType.Reduce:  	Reduce (action.Index);  	break;  case ParseActionType.Accept:  	stateStack.Pop ();  	result = tokenStack.Pop ();  	return;  case ParseActionType.Error:  	ReportError (state' token);  	// ErrorRecovery(state' token.Id);  	return;  }  
Missing Default,Cyjb.Compilers.Parsers,LRParser,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\Parsers\LRParser`1.cs,Parse,The following switch statement is missing a default case: switch (action.ActionType) {  case ParseActionType.Reduce:  	Reduce (action.Index);  	break;  case ParseActionType.Error:  	return;  }  
Missing Default,Cyjb.Compilers.Parsers,ParserRule,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\Parsers\ParserRule`1.cs,FindUniqueReduction,The following switch statement is missing a default case: switch (actions [i].ActionType) {  case ParseActionType.Accept:  case ParseActionType.Shift:  	return ParseAction.Error;  case ParseActionType.Reduce:  	if (action.ActionType == ParseActionType.Error) {  		action = actions [i];  	} else if (action.Index != actions [i].Index) {  		return ParseAction.Error;  	}  	break;  }  
Missing Default,Cyjb.Compilers.RegularExpressions,RegexCharClass,F:\newReposMay17\CYJB_Cyjb.Compilers\Cyjb.Compilers\RegularExpressions\RegexCharClass.cs,AddUppercaseRange,The following switch statement is missing a default case: switch (uc.Operator) {  case UppercaseSet:  	chMinT = (char)uc.Data;  	chMaxT = (char)uc.Data;  	break;  case UppercaseAdd:  	chMinT += (char)uc.Data;  	chMaxT += (char)uc.Data;  	break;  case UppercaseBor:  	chMinT |= (char)1;  	chMaxT |= (char)1;  	break;  case UppercaseBad:  	chMinT += (char)(chMinT & 1);  	chMaxT += (char)(chMaxT & 1);  	break;  }  
