Implementation smell,Namespace,Class,File,Method,Description
Long Method,NodaTime.Text,NormalizingIsoPatternImpl,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\PeriodPattern.cs,Parse,The method has 117 lines of code.
Complex Method,NodaTime,Period,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Period.cs,Between,Cyclomatic complexity of the method is 17
Complex Method,NodaTime.Fields,FixedLengthDatePeriodField,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Fields\FixedLengthDatePeriodField.cs,Add,Cyclomatic complexity of the method is 8
Complex Method,NodaTime.Text,LocalDateParseBucket,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\LocalDatePatternParser.cs,DetermineYear,Cyclomatic complexity of the method is 12
Complex Method,NodaTime.Text,LocalTimeParseBucket,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\LocalTimePatternParser.cs,DetermineHour,Cyclomatic complexity of the method is 9
Complex Method,NodaTime.Text,OffsetPatternParser,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\OffsetPatternParser.cs,ParsePartialPattern,Cyclomatic complexity of the method is 14
Complex Method,NodaTime.Text,RoundtripPatternImpl,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\PeriodPattern.cs,Parse,Cyclomatic complexity of the method is 20
Complex Method,NodaTime.Text,NormalizingIsoPatternImpl,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\PeriodPattern.cs,Parse,Cyclomatic complexity of the method is 26
Complex Method,NodaTime.Text,ZonedDateTimeParseBucket,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\ZonedDateTimePatternParser.cs,TryParseProviderZone,Cyclomatic complexity of the method is 8
Complex Method,NodaTime.Text.Patterns,PatternCursor,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\Patterns\PatternCursor.cs,GetEmbeddedPattern,Cyclomatic complexity of the method is 9
Complex Method,NodaTime.TimeZones,PartialZoneIntervalMap,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\PartialZoneIntervalMap.cs,ConvertToFullMap,Cyclomatic complexity of the method is 8
Complex Method,NodaTime.TimeZones,TzdbDateTimeZoneSource,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\TzdbDateTimeZoneSource.cs,Validate,Cyclomatic complexity of the method is 20
Long Parameter List,NodaTime,CalendarSystem,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\CalendarSystem.cs,CalendarSystem,The method has 5 parameters. Parameters: ordinal' id' name' yearMonthDayCalculator' singleEra
Long Parameter List,NodaTime,CalendarSystem,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\CalendarSystem.cs,CalendarSystem,The method has 5 parameters. Parameters: ordinal' id' name' yearMonthDayCalculator' eraCalculator
Long Parameter List,NodaTime,Duration,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Duration.cs,Duration,The method has 6 parameters. Parameters: units' paramName' minValue' maxValue' unitsPerDay' nanosPerUnit
Long Parameter List,NodaTime,Instant,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Instant.cs,FromUtc,The method has 5 parameters. Parameters: year' monthOfYear' dayOfMonth' hourOfDay' minuteOfHour
Long Parameter List,NodaTime,Instant,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Instant.cs,FromUtc,The method has 6 parameters. Parameters: year' monthOfYear' dayOfMonth' hourOfDay' minuteOfHour' secondOfMinute
Long Parameter List,NodaTime,LocalDate,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\LocalDate.cs,LocalDate,The method has 5 parameters. Parameters: era' yearOfEra' month' day' calendar
Long Parameter List,NodaTime,LocalDateTime,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\LocalDateTime.cs,LocalDateTime,The method has 5 parameters. Parameters: year' month' day' hour' minute
Long Parameter List,NodaTime,LocalDateTime,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\LocalDateTime.cs,LocalDateTime,The method has 6 parameters. Parameters: year' month' day' hour' minute' calendar
Long Parameter List,NodaTime,LocalDateTime,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\LocalDateTime.cs,LocalDateTime,The method has 6 parameters. Parameters: year' month' day' hour' minute' second
Long Parameter List,NodaTime,LocalDateTime,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\LocalDateTime.cs,LocalDateTime,The method has 7 parameters. Parameters: year' month' day' hour' minute' second' calendar
Long Parameter List,NodaTime,LocalDateTime,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\LocalDateTime.cs,LocalDateTime,The method has 7 parameters. Parameters: year' month' day' hour' minute' second' millisecond
Long Parameter List,NodaTime,LocalDateTime,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\LocalDateTime.cs,LocalDateTime,The method has 8 parameters. Parameters: year' month' day' hour' minute' second' millisecond' calendar
Long Parameter List,NodaTime,LocalTime,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\LocalTime.cs,FromHourMinuteSecondMillisecondTick,The method has 5 parameters. Parameters: hour' minute' second' millisecond' tickWithinMillisecond
Long Parameter List,NodaTime,Period,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Period.cs,Period,The method has 6 parameters. Parameters: hours' minutes' seconds' milliseconds' ticks' nanoseconds
Long Parameter List,NodaTime,Period,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Period.cs,Period,The method has 10 parameters. Parameters: years' months' weeks' days' hours' minutes' seconds' milliseconds' ticks' nanoseconds
Long Parameter List,NodaTime,Period,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Period.cs,DateComponentsBetween,The method has 7 parameters. Parameters: start' end' units' years' months' weeks' days
Long Parameter List,NodaTime,Period,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Period.cs,TimeComponentsBetween,The method has 8 parameters. Parameters: totalNanoseconds' units' hours' minutes' seconds' milliseconds' ticks' nanoseconds
Long Parameter List,NodaTime.Calendars,RegularYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\RegularYearMonthDayCalculator.cs,RegularYearMonthDayCalculator,The method has 5 parameters. Parameters: minYear' maxYear' monthsInYear' averageDaysPer10Years' daysAtStartOfYear1
Long Parameter List,NodaTime.Text,ZonedDateTimePattern,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\ZonedDateTimePattern.cs,ZonedDateTimePattern,The method has 6 parameters. Parameters: patternText' formatInfo' templateValue' resolver' zoneProvider' pattern
Long Parameter List,NodaTime.Text,ZonedDateTimePattern,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\ZonedDateTimePattern.cs,Create,The method has 5 parameters. Parameters: patternText' formatInfo' resolver' zoneProvider' templateValue
Long Parameter List,NodaTime.Text,ZonedDateTimePattern,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\ZonedDateTimePattern.cs,Create,The method has 5 parameters. Parameters: patternText' cultureInfo' resolver' zoneProvider' templateValue
Long Parameter List,NodaTime.Text.Patterns,SteppedPatternBuilder<TResult;TBucket>,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\Patterns\SteppedPatternBuilder.cs,AddParseInt64ValueAction,The method has 6 parameters. Parameters: minimumDigits' maximumDigits' patternChar' minimumValue' maximumValue' valueSetter
Long Parameter List,NodaTime.Text.Patterns,SteppedPatternBuilder<TResult;TBucket>,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\Patterns\SteppedPatternBuilder.cs,AddParseValueAction,The method has 6 parameters. Parameters: minimumDigits' maximumDigits' patternChar' minimumValue' maximumValue' valueSetter
Long Parameter List,NodaTime.Text.Patterns,SteppedPatternBuilder<TResult;TBucket>,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\Patterns\SteppedPatternBuilder.cs,HandlePaddedField,The method has 6 parameters. Parameters: maxCount' field' minValue' maxValue' getter' setter
Long Parameter List,NodaTime.Text.Patterns,SteppedPatternBuilder<TResult;TBucket>,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\Patterns\SteppedPatternBuilder.cs,AddParseLongestTextAction,The method has 5 parameters. Parameters: field' setter' compareInfo' textValues1' textValues2
Long Parameter List,NodaTime.Text.Patterns,SteppedPatternBuilder<TResult;TBucket>,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\Patterns\SteppedPatternBuilder.cs,FindLongestMatch,The method has 5 parameters. Parameters: compareInfo' cursor' values' bestIndex' longestMatch
Long Parameter List,NodaTime.Text.Patterns,SteppedPatternBuilder<TResult;TBucket>,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\Patterns\SteppedPatternBuilder.cs,AddEmbeddedLocalPartial,The method has 6 parameters. Parameters: pattern' dateBucketExtractor' timeBucketExtractor' dateExtractor' timeExtractor' dateTimeExtractor
Long Parameter List,NodaTime.Text.Patterns,SteppedPattern,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\Patterns\SteppedPatternBuilder.cs,SteppedPattern,The method has 5 parameters. Parameters: formatActions' parseActions' bucketProvider' usedFields' sample
Long Parameter List,NodaTime.Text.Patterns,TimePatternHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\Patterns\TimePatternHelper.cs,HandleHalfAmPmDesignator,The method has 6 parameters. Parameters: count' specifiedDesignator' specifiedDesignatorValue' hourOfDayGetter' amPmSetter' builder
Long Parameter List,NodaTime.TimeZones,BclAdjustmentRule,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\BclDateTimeZone.cs,BclAdjustmentRule,The method has 5 parameters. Parameters: start' end' standardOffset' savings' partialMap
Long Parameter List,NodaTime.TimeZones,PartialZoneIntervalMap,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\PartialZoneIntervalMap.cs,ForZoneInterval,The method has 5 parameters. Parameters: name' start' end' wallOffset' savings
Long Parameter List,NodaTime.TimeZones,TzdbZone1970Location,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\TzdbZone1970Location.cs,TzdbZone1970Location,The method has 5 parameters. Parameters: latitudeSeconds' longitudeSeconds' countries' zoneId' comment
Long Parameter List,NodaTime.TimeZones,TzdbZoneLocation,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\TzdbZoneLocation.cs,TzdbZoneLocation,The method has 6 parameters. Parameters: latitudeSeconds' longitudeSeconds' countryName' countryCode' zoneId' comment
Long Parameter List,NodaTime.TimeZones,ZoneInterval,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\ZoneInterval.cs,ZoneInterval,The method has 5 parameters. Parameters: name' start' end' wallOffset' savings
Long Parameter List,NodaTime.TimeZones,ZoneInterval,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\ZoneInterval.cs,ZoneInterval,The method has 5 parameters. Parameters: name' start' end' wallOffset' savings
Long Parameter List,NodaTime.TimeZones,ZoneLocalMapping,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\ZoneLocalMapping.cs,ZoneLocalMapping,The method has 5 parameters. Parameters: zone' localDateTime' earlyInterval' lateInterval' count
Long Parameter List,NodaTime.TimeZones,ZoneRecurrence,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\ZoneRecurrence.cs,ZoneRecurrence,The method has 5 parameters. Parameters: name' savings' yearOffset' fromYear' toYear
Long Parameter List,NodaTime.TimeZones,ZoneYearOffset,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\ZoneYearOffset.cs,ZoneYearOffset,The method has 6 parameters. Parameters: mode' monthOfYear' dayOfMonth' dayOfWeek' advance' timeOfDay
Long Parameter List,NodaTime.TimeZones,ZoneYearOffset,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\ZoneYearOffset.cs,ZoneYearOffset,The method has 7 parameters. Parameters: mode' monthOfYear' dayOfMonth' dayOfWeek' advance' timeOfDay' addDay
Long Parameter List,NodaTime.TimeZones,ZoneYearOffset,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\ZoneYearOffset.cs,VerifyFieldValue,The method has 5 parameters. Parameters: minimum' maximum' name' value' allowNegated
Long Parameter List,NodaTime.Utility,Preconditions,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Utility\Preconditions.cs,CheckArgument,The method has 5 parameters. Parameters: expression' parameter' messageFormat' messageArg1' messageArg2
Long Identifier,NodaTime,DateTimeZone,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\DateTimeZone.cs,,The length of the parameter FixedZoneCacheGranularitySeconds is 32.
Long Identifier,NodaTime.Calendars,BadiYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\BadiYearMonthDayCalculator.cs,GetDaysFromStartOfYearToStartOfMonth,The length of the parameter daysFromStartOfYearToStartOfMonth is 33.
Long Identifier,NodaTime.Calendars,BadiYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\BadiYearMonthDayCalculator.cs,,The length of the parameter FirstYearOfStandardizedCalendar is 31.
Long Identifier,NodaTime.Calendars,SimpleWeekYearRule,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\SimpleWeekYearRule.cs,GetWeekYearDaysSinceEpoch,The length of the parameter startOfWeekContainingStartOfCalendarYear is 40.
Long Identifier,NodaTime.Calendars,YearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\YearMonthDayCalculator.cs,GetYear,The length of the parameter daysFromCandidateStartToTarget is 30.
Long Identifier,NodaTime.Text,Patterns,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\AnnualDatePattern.cs,,The length of the parameter FullRoundtripWithoutCalendarImpl is 32.
Long Identifier,NodaTime.Text,LocalTimeParseBucket,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\LocalTimePatternParser.cs,,The length of the parameter AllTimeFieldsExceptFractionalSeconds is 36.
Long Identifier,NodaTime.Text,TextErrorMessages,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\TextErrorMessages.cs,,The length of the parameter InconsistentDayOfWeekTextValue is 30.
Long Statement,NodaTime,DateAdjusters,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\DateAdjusters.cs,AddPeriod,The length of the statement  "            Preconditions.CheckArgument(!period.HasTimeComponent' nameof(period)' "Cannot add a period with a time component to a date"); " is 125.
Long Statement,NodaTime,DateTimeZone,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\DateTimeZone.cs,MapLocal,The length of the statement  "                return new ZoneLocalMapping(this' localDateTime' GetIntervalBeforeGap(localInstant)' GetIntervalAfterGap(localInstant)' 0); " is 123.
Long Statement,NodaTime,Duration,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Duration.cs,FromNanoseconds,The length of the statement  "                throw new ArgumentOutOfRangeException(nameof(nanoseconds)' $"Value should be in range [{MinNanoseconds}-{MaxNanoseconds}]"); " is 124.
Long Statement,NodaTime,Duration,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Duration.cs,FromNanoseconds,The length of the statement  "                throw new ArgumentOutOfRangeException(nameof(nanoseconds)' $"Value should be in range [{MinNanoseconds}-{MaxNanoseconds}]"); " is 124.
Long Statement,NodaTime,Instant,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Instant.cs,FromDateTimeUtc,The length of the statement  "            Preconditions.CheckArgument(dateTime.Kind == DateTimeKind.Utc' nameof(dateTime)' "Invalid DateTime.Kind for Instant.FromDateTimeUtc"); " is 134.
Long Statement,NodaTime,LocalDate,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\LocalDate.cs,CompareTo,The length of the statement  "            Preconditions.CheckArgument(Calendar.Equals(other.Calendar)' nameof(other)' "Only values with the same calendar system can be compared"); " is 137.
Long Statement,NodaTime,LocalDate,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\LocalDate.cs,Max,The length of the statement  "            Preconditions.CheckArgument(x.Calendar.Equals(y.Calendar)' nameof(y)' "Only values with the same calendar system can be compared"); " is 131.
Long Statement,NodaTime,LocalDate,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\LocalDate.cs,Min,The length of the statement  "            Preconditions.CheckArgument(x.Calendar.Equals(y.Calendar)' nameof(y)' "Only values with the same calendar system can be compared"); " is 131.
Long Statement,NodaTime,LocalDateTime,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\LocalDateTime.cs,ToDateTimeUnspecified,The length of the statement  "            long ticks = TickArithmetic.BoundedDaysAndTickOfDayToTicks(date.DaysSinceEpoch' time.TickOfDay) + NodaConstants.BclTicksAtUnixEpoch; " is 132.
Long Statement,NodaTime,LocalDateTime,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\LocalDateTime.cs,FromDateTime,The length of the statement  "            int days = TickArithmetic.NonNegativeTicksToDaysAndTickOfDay(dateTime.Ticks' out long tickOfDay) - NodaConstants.BclDaysAtUnixEpoch; " is 132.
Long Statement,NodaTime,LocalDateTime,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\LocalDateTime.cs,FromDateTime,The length of the statement  "            int days = TickArithmetic.NonNegativeTicksToDaysAndTickOfDay(dateTime.Ticks' out long tickOfDay) - NodaConstants.BclDaysAtUnixEpoch; " is 132.
Long Statement,NodaTime,LocalDateTime,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\LocalDateTime.cs,FromDateTime,The length of the statement  "            return new LocalDateTime(new LocalDate(days' calendar)' new LocalTime(unchecked(tickOfDay * NodaConstants.NanosecondsPerTick))); " is 128.
Long Statement,NodaTime,LocalDateTime,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\LocalDateTime.cs,Max,The length of the statement  "            Preconditions.CheckArgument(x.Calendar.Equals(y.Calendar)' nameof(y)' "Only values with the same calendar system can be compared"); " is 131.
Long Statement,NodaTime,LocalDateTime,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\LocalDateTime.cs,Min,The length of the statement  "            Preconditions.CheckArgument(x.Calendar.Equals(y.Calendar)' nameof(y)' "Only values with the same calendar system can be compared"); " is 131.
Long Statement,NodaTime,Period,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Period.cs,Between,The length of the statement  "            Preconditions.CheckArgument((units & ~PeriodUnits.AllUnits) == 0' nameof(units)' "Units contains an unknown value: {0}"' units); " is 128.
Long Statement,NodaTime,Period,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Period.cs,Between,The length of the statement  "            Preconditions.CheckArgument(calendar.Equals(end.Calendar)' nameof(end)' "start and end must use the same calendar system"); " is 123.
Long Statement,NodaTime,Period,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Period.cs,Between,The length of the statement  "                TimeComponentsBetween(duration.ToInt64Nanoseconds()' units' out hours' out minutes' out seconds' out milliseconds' out ticks' out nanoseconds); " is 143.
Long Statement,NodaTime,Period,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Period.cs,Between,The length of the statement  "            Preconditions.CheckArgument((units & PeriodUnits.AllTimeUnits) == 0' nameof(units)' "Units contains time units: {0}"' units); " is 125.
Long Statement,NodaTime,Period,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Period.cs,Between,The length of the statement  "            Preconditions.CheckArgument((units & ~PeriodUnits.AllUnits) == 0' nameof(units)' "Units contains an unknown value: {0}"' units); " is 128.
Long Statement,NodaTime,Period,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Period.cs,Between,The length of the statement  "            Preconditions.CheckArgument(calendar.Equals(end.Calendar)' nameof(end)' "start and end must use the same calendar system"); " is 123.
Long Statement,NodaTime,Period,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Period.cs,Between,The length of the statement  "            Preconditions.CheckArgument((units & PeriodUnits.AllDateUnits) == 0' nameof(units)' "Units contains date units: {0}"' units); " is 125.
Long Statement,NodaTime,Period,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Period.cs,Between,The length of the statement  "            Preconditions.CheckArgument((units & ~PeriodUnits.AllUnits) == 0' nameof(units)' "Units contains an unknown value: {0}"' units); " is 128.
Long Statement,NodaTime,Period,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Period.cs,Between,The length of the statement  "            TimeComponentsBetween(remaining' units' out long hours' out long minutes' out long seconds' out long milliseconds' out long ticks' out long nanoseconds); " is 153.
Long Statement,NodaTime,Period,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Period.cs,Normalize,The length of the statement  "            return new Period(this.Years' this.Months' 0 /* weeks */' days' hours' minutes' seconds' milliseconds' 0 /* ticks */' nanoseconds); " is 131.
Long Statement,NodaTime,YearMonth,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\YearMonth.cs,CompareTo,The length of the statement  "            Preconditions.CheckArgument(Calendar.Equals(other.Calendar)' nameof(other)' "Only values with the same calendar system can be compared"); " is 137.
Long Statement,NodaTime.Calendars,GJEraCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\GJEraCalculator.cs,ValidateEra,The length of the statement  "                Preconditions.CheckArgument(false' nameof(era)' "Era {0} is not supported by this calendar; only BC and AD are supported"' era.Name); " is 133.
Long Statement,NodaTime.Calendars,HebrewYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewYearMonthDayCalculator.cs,GetYearMonthDay,The length of the statement  "            return monthNumbering == HebrewMonthNumbering.Scriptural ? scriptural : new YearMonthDay(year' HebrewMonthConverter.ScripturalToCivil(year' scriptural.Month)' scriptural.Day); " is 175.
Long Statement,NodaTime.Fields,YearsPeriodField,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Fields\YearsPeriodField.cs,Add,The length of the statement  "            Preconditions.CheckArgumentRange(nameof(value)' value' calculator.MinYear - currentYear' calculator.MaxYear - currentYear); " is 123.
Long Statement,NodaTime.Globalization,NodaFormatInfo,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Globalization\NodaFormatInfo.cs,EnsureMonthsInitialized,The length of the statement  "                longMonthGenitiveNames = ConvertGenitiveMonthArray(longMonthNames' DateTimeFormat.MonthGenitiveNames' LongInvariantMonthNames); " is 127.
Long Statement,NodaTime.Globalization,NodaFormatInfo,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Globalization\NodaFormatInfo.cs,EnsureMonthsInitialized,The length of the statement  "                shortMonthGenitiveNames = ConvertGenitiveMonthArray(shortMonthNames' DateTimeFormat.AbbreviatedMonthGenitiveNames' ShortInvariantMonthNames); " is 141.
Long Statement,NodaTime.Text,DurationPatternParser,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\DurationPatternParser.cs,ParsePattern,The length of the statement  "            return patternBuilder.Build(Duration.FromHours(1) + Duration.FromMinutes(30) + Duration.FromSeconds(5) + Duration.FromMilliseconds(500)); " is 137.
Long Statement,NodaTime.Text,DurationPatternParser,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\DurationPatternParser.cs,CreateTotalHandler,The length of the statement  "                builder.AddParseInt64ValueAction(count' 13' pattern.Current' 0' maxValue' (bucket' value) => bucket.AddUnits(value' nanosecondsPerUnit)); " is 137.
Long Statement,NodaTime.Text,DurationPatternParser,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\DurationPatternParser.cs,CreateTotalHandler,The length of the statement  "                builder.AddFormatAction((value' sb) => FormatHelper.LeftPadNonNegativeInt64(GetPositiveNanosecondUnits(value' nanosecondsPerUnit' unitsPerDay)' count' sb)); " is 156.
Long Statement,NodaTime.Text,LocalDateTimePatternParser,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\LocalDateTimePatternParser.cs,ParsePattern,The length of the statement  "                    'f' => ParseNoStandardExpansion(formatInfo.DateTimeFormat.LongDatePattern + " " + formatInfo.DateTimeFormat.ShortTimePattern)' " is 126.
Long Statement,NodaTime.Text,LocalDateTimePatternParser,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\LocalDateTimePatternParser.cs,ParsePattern,The length of the statement  "                    'g' => ParseNoStandardExpansion(formatInfo.DateTimeFormat.ShortDatePattern + " " + formatInfo.DateTimeFormat.ShortTimePattern)' " is 127.
Long Statement,NodaTime.Text,LocalDateTimePatternParser,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\LocalDateTimePatternParser.cs,ParsePattern,The length of the statement  "                    'G' => ParseNoStandardExpansion(formatInfo.DateTimeFormat.ShortDatePattern + " " + formatInfo.DateTimeFormat.LongTimePattern)' " is 126.
Long Statement,NodaTime.Text,LocalDateTimeParseBucket,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\LocalDateTimePatternParser.cs,CombineBuckets,The length of the statement  "                ParseResult<LocalDate> dateResult = dateBucket.CalculateValue(usedFields & PatternFields.AllDateFields' text' typeof(LocalDateTime)); " is 133.
Long Statement,NodaTime.Text,LocalDateTimeParseBucket,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\LocalDateTimePatternParser.cs,CombineBuckets,The length of the statement  "                ParseResult<LocalTime> timeResult = timeBucket.CalculateValue(usedFields & PatternFields.AllTimeFields' text' typeof(LocalDateTime)); " is 133.
Long Statement,NodaTime.Text,LocalTimeParseBucket,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\LocalTimePatternParser.cs,CalculateValue,The length of the statement  "                    return ParseResult<LocalTime>.ForValue(LocalTime.FromHourMinuteSecondNanosecondTrusted(Hours24' Minutes' Seconds' FractionalSeconds)); " is 134.
Long Statement,NodaTime.Text,LocalTimeParseBucket,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\LocalTimePatternParser.cs,CalculateValue,The length of the statement  "                    return ParseResult<LocalTime>.ForValue(LocalTime.FromHourMinuteSecondNanosecondTrusted(Hours24' Minutes' Seconds' FractionalSeconds)); " is 134.
Long Statement,NodaTime.Text,LocalTimeParseBucket,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\LocalTimePatternParser.cs,CalculateValue,The length of the statement  "                return ParseResult<LocalTime>.ForValue(LocalTime.FromHourMinuteSecondNanosecondTrusted(hour' Minutes' Seconds' FractionalSeconds)); " is 131.
Long Statement,NodaTime.Text,OffsetDatePatternParser,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\OffsetDatePatternParser.cs,ParsePattern,The length of the statement  "            var patternBuilder = new SteppedPatternBuilder<OffsetDate' OffsetDateParseBucket>(formatInfo' () => new OffsetDateParseBucket(templateValue)); " is 142.
Long Statement,NodaTime.Text,OffsetDateParseBucket,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\OffsetDatePatternParser.cs,CalculateValue,The length of the statement  "                ParseResult<LocalDate> dateResult = Date.CalculateValue(usedFields & PatternFields.AllDateFields' text' typeof(OffsetDate)); " is 124.
Long Statement,NodaTime.Text,OffsetDateTimePatternParser,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\OffsetDateTimePatternParser.cs,ParsePattern,The length of the statement  "            var patternBuilder = new SteppedPatternBuilder<OffsetDateTime' OffsetDateTimeParseBucket>(formatInfo' () => new OffsetDateTimeParseBucket(templateValue)); " is 154.
Long Statement,NodaTime.Text,OffsetTimePatternParser,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\OffsetTimePatternParser.cs,ParsePattern,The length of the statement  "            var patternBuilder = new SteppedPatternBuilder<OffsetTime' OffsetTimeParseBucket>(formatInfo' () => new OffsetTimeParseBucket(templateValue)); " is 142.
Long Statement,NodaTime.Text,OffsetTimeParseBucket,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\OffsetTimePatternParser.cs,CalculateValue,The length of the statement  "                ParseResult<LocalTime> timeResult = Time.CalculateValue(usedFields & PatternFields.AllTimeFields' text' typeof(OffsetTime)); " is 124.
Long Statement,NodaTime.Text,NormalizingIsoPatternImpl,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\PeriodPattern.cs,AppendFormat,The length of the statement  "                    long nanoseconds = value.Milliseconds * NanosecondsPerMillisecond + value.Ticks * NanosecondsPerTick + value.Nanoseconds; " is 121.
Long Statement,NodaTime.Text,ZonedDateTimePattern,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\ZonedDateTimePattern.cs,Create,The length of the statement  "            var pattern = new ZonedDateTimePatternParser(templateValue' resolver' zoneProvider).ParsePattern(patternText' formatInfo); " is 122.
Long Statement,NodaTime.Text.Patterns,DatePatternHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\Patterns\DatePatternHelper.cs,CreateYearOfEraHandler,The length of the statement  "                        // Just remember that we've set this particular field. We can't set it twice as we've already got the YearOfEra flag set. " is 121.
Long Statement,NodaTime.Text.Patterns,DatePatternHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\Patterns\DatePatternHelper.cs,CreateEraHandler,The length of the statement  "                // Note: currently the count is ignored. More work needed to determine whether abbreviated era names should be used for just "g". " is 129.
Long Statement,NodaTime.Text.Patterns,SteppedPatternBuilder<TResult;TBucket>,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\Patterns\SteppedPatternBuilder.cs,Build,The length of the statement  "            return new SteppedPattern(formatDelegate!' formatOnly ? null : parseActions.ToArray()' bucketProvider' usedFields' sample); " is 123.
Long Statement,NodaTime.Text.Patterns,TimePatternHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\Patterns\TimePatternHelper.cs,HandleHalfAmPmDesignator,The length of the statement  "                    int value = str.MatchCaseInsensitive(abbreviation' compareInfo' true) ? specifiedDesignatorValue : 1 - specifiedDesignatorValue; " is 128.
Long Statement,NodaTime.Text.Patterns,TimePatternHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\Patterns\TimePatternHelper.cs,HandleHalfAmPmDesignator,The length of the statement  "                int value = str.MatchCaseInsensitive(specifiedDesignator' compareInfo' true) ? specifiedDesignatorValue : 1 - specifiedDesignatorValue; " is 135.
Long Statement,NodaTime.TimeZones,BclDateTimeZone,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\BclDateTimeZone.cs,FromTimeZoneInfo,The length of the statement  "                var fixedInterval = new ZoneInterval(bclZone.StandardName' Instant.BeforeMinValue' Instant.AfterMaxValue' standardOffset' Offset.Zero); " is 135.
Long Statement,NodaTime.TimeZones,BclDateTimeZone,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\BclDateTimeZone.cs,FromTimeZoneInfo,The length of the statement  "                : (Converter<TimeZoneInfo.AdjustmentRule' BclAdjustmentRule>) (rule => BclAdjustmentRule.FromUnixAdjustmentRule(bclZone' rule)); " is 128.
Long Statement,NodaTime.TimeZones,BclDateTimeZone,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\BclDateTimeZone.cs,FromTimeZoneInfo,The length of the statement  "            Offset minRuleOffset = convertedRules.Aggregate(Offset.MaxValue' (min' rule) => Offset.Min(min' rule.Savings + rule.StandardOffset)); " is 133.
Long Statement,NodaTime.TimeZones,BclDateTimeZone,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\BclDateTimeZone.cs,FromTimeZoneInfo,The length of the statement  "            Offset maxRuleOffset = convertedRules.Aggregate(Offset.MinValue' (min' rule) => Offset.Max(min' rule.Savings + rule.StandardOffset)); " is 133.
Long Statement,NodaTime.TimeZones,BclDateTimeZone,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\BclDateTimeZone.cs,FromTimeZoneInfo,The length of the statement  "            return new BclDateTimeZone(bclZone' Offset.Min(standardOffset' minRuleOffset)' Offset.Max(standardOffset' maxRuleOffset)' cachedMap); " is 133.
Long Statement,NodaTime.TimeZones,BclDateTimeZone,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\BclDateTimeZone.cs,BuildMap,The length of the statement  "                maps.Add(PartialZoneIntervalMap.ForZoneInterval(standardName' Instant.BeforeMinValue' rules[0].Start' standardOffset' Offset.Zero)); " is 132.
Long Statement,NodaTime.TimeZones,BclDateTimeZone,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\BclDateTimeZone.cs,BuildMap,The length of the statement  "                    maps.Add(PartialZoneIntervalMap.ForZoneInterval(standardName' beforeRule.End' afterRule.Start' standardOffset' Offset.Zero)); " is 125.
Long Statement,NodaTime.TimeZones,BclDateTimeZone,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\BclDateTimeZone.cs,BuildMap,The length of the statement  "                maps.Add(PartialZoneIntervalMap.ForZoneInterval(standardName' lastRule.End' Instant.AfterMaxValue' standardOffset' Offset.Zero)); " is 129.
Long Statement,NodaTime.TimeZones,BclAdjustmentRule,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\BclDateTimeZone.cs,FromUnixAdjustmentRule,The length of the statement  "                var bclUtcStart = DateTime.SpecifyKind(bclLocalStart == DateTime.MinValue ? DateTime.MinValue : bclLocalStart - zone.BaseUtcOffset' DateTimeKind.Utc); " is 150.
Long Statement,NodaTime.TimeZones,BclAdjustmentRule,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\BclDateTimeZone.cs,FromUnixAdjustmentRule,The length of the statement  "                var bclUtcEnd = DateTime.SpecifyKind(rule.DateEnd == MaxDate ? DateTime.MaxValue : bclLocalEnd - (zone.BaseUtcOffset + bclSavings)' DateTimeKind.Utc); " is 150.
Long Statement,NodaTime.TimeZones,BclAdjustmentRule,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\BclDateTimeZone.cs,FromUnixAdjustmentRule,The length of the statement  "                // Now all the values are sensible - and in particular' now the daylight savings are in a range that can be represented by " is 122.
Long Statement,NodaTime.TimeZones,BclAdjustmentRule,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\BclDateTimeZone.cs,FromUnixAdjustmentRule,The length of the statement  "                // The representation returned to us (not the internal representation) has an end point one second before the transition. " is 121.
Long Statement,NodaTime.TimeZones,BclAdjustmentRule,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\BclDateTimeZone.cs,FromUnixAdjustmentRule,The length of the statement  "                var partialMap = PartialZoneIntervalMap.ForZoneInterval(isDst ? zone.StandardName : zone.DaylightName' nodaStart' nodaEnd' nodaWallOffset' nodaSavings); " is 152.
Long Statement,NodaTime.TimeZones,BclAdjustmentRule,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\BclDateTimeZone.cs,FromWindowsAdjustmentRule,The length of the statement  "                var start = rule.DateStart == DateTime.MinValue ? Instant.BeforeMinValue : rule.DateStart.ToLocalDateTime().WithOffset(zoneStandardOffset).ToInstant(); " is 151.
Long Statement,NodaTime.TimeZones,BclAdjustmentRule,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\BclDateTimeZone.cs,FromWindowsAdjustmentRule,The length of the statement  "                var end = rule.DateEnd == MaxDate ? Instant.AfterMaxValue : rule.DateEnd.ToLocalDateTime().PlusDays(1).WithOffset(zoneStandardOffset).ToInstant(); " is 146.
Long Statement,NodaTime.TimeZones,BclAdjustmentRule,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\BclDateTimeZone.cs,FromWindowsAdjustmentRule,The length of the statement  "                    var daylightRecurrence = new ZoneRecurrence(zone.DaylightName' savings' ConvertTransition(rule.DaylightTransitionStart)' int.MinValue' int.MaxValue); " is 149.
Long Statement,NodaTime.TimeZones,BclAdjustmentRule,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\BclDateTimeZone.cs,FromWindowsAdjustmentRule,The length of the statement  "                    var standardRecurrence = new ZoneRecurrence(zone.StandardName' Offset.Zero' ConvertTransition(rule.DaylightTransitionEnd)' int.MinValue' int.MaxValue); " is 151.
Long Statement,NodaTime.TimeZones,BclAdjustmentRule,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\BclDateTimeZone.cs,FromWindowsAdjustmentRule,The length of the statement  "                    IZoneIntervalMap recurringMap = new StandardDaylightAlternatingMap(standardOffset' standardRecurrence' daylightRecurrence); " is 123.
Long Statement,NodaTime.TimeZones,BclAdjustmentRule,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\BclDateTimeZone.cs,FromWindowsAdjustmentRule,The length of the statement  "                    // Fake 1 hour savings if the adjustment rule claims to be 0 savings. See DaylightFakingZoneIntervalMap documentation below for more details. " is 141.
Long Statement,NodaTime.TimeZones,PartialZoneIntervalMap,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\PartialZoneIntervalMap.cs,ConvertToFullMap,The length of the statement  "                    Preconditions.DebugCheckArgument(current.Start == Instant.BeforeMinValue' nameof(maps)' "First partial map must start at the beginning of time"); " is 145.
Long Statement,NodaTime.TimeZones,PartialZoneIntervalMap,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\PartialZoneIntervalMap.cs,ConvertToFullMap,The length of the statement  "                        // start of current to the first transition in next' then continue on with the next map' starting at the first transition. " is 122.
Long Statement,NodaTime.TimeZones,PartialZoneIntervalMap,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\PartialZoneIntervalMap.cs,ConvertToFullMap,The length of the statement  "            Preconditions.DebugCheckArgument(current!.End == Instant.AfterMaxValue' nameof(maps)' "Collection of maps must end at the end of time"); " is 136.
Long Statement,NodaTime.TimeZones,PrecalculatedDateTimeZone,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\PrecalculatedDateTimeZone.cs,ValidatePeriods,The length of the statement  "            Preconditions.CheckArgument(!periods[0].HasStart' nameof(periods)' "Periods in precalculated time zone must start with the beginning of time"); " is 143.
Long Statement,NodaTime.TimeZones,PrecalculatedDateTimeZone,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\PrecalculatedDateTimeZone.cs,ValidatePeriods,The length of the statement  "                Preconditions.CheckArgument(periods[i].End == periods[i + 1].Start' nameof(periods)' "Non-adjoining ZoneIntervals for precalculated time zone"); " is 144.
Long Statement,NodaTime.TimeZones,PrecalculatedDateTimeZone,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\PrecalculatedDateTimeZone.cs,ValidatePeriods,The length of the statement  "            Preconditions.CheckArgument(tailZone != null || periods[periods.Length - 1].RawEnd == Instant.AfterMaxValue' nameof(tailZone)' "Null tail zone given but periods don't cover all of time"); " is 187.
Long Statement,NodaTime.TimeZones,PrecalculatedDateTimeZone,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\PrecalculatedDateTimeZone.cs,Read,The length of the statement  "            // It's not entirely clear why we don't just assume that the first zone interval always starts at Instant.BeforeMinValue " is 120.
Long Statement,NodaTime.TimeZones,StandardDaylightAlternatingMap,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\StandardDaylightAlternatingMap.cs,GetZoneInterval,The length of the statement  "            return new ZoneInterval(recurrence.Name' previous.Instant' next.Instant' standardOffset + recurrence.Savings' recurrence.Savings); " is 130.
Long Statement,NodaTime.TimeZones,StandardDaylightAlternatingMap,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\StandardDaylightAlternatingMap.cs,NextTransition,The length of the statement  "                var previousStandardTransition = standardRecurrence.PreviousOrSameOrFail(instant' standardOffset' dstRecurrence.Savings); " is 121.
Long Statement,NodaTime.TimeZones,StandardDaylightAlternatingMap,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\StandardDaylightAlternatingMap.cs,Read,The length of the statement  "            ZoneRecurrence standardRecurrence = new ZoneRecurrence(standardName' Offset.Zero' standardYearOffset' int.MinValue' int.MaxValue); " is 130.
Long Statement,NodaTime.TimeZones,StandardDaylightAlternatingMap,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\StandardDaylightAlternatingMap.cs,Read,The length of the statement  "            ZoneRecurrence dstRecurrence = new ZoneRecurrence(daylightName' savings' daylightYearOffset' int.MinValue' int.MaxValue); " is 121.
Long Statement,NodaTime.TimeZones,TzdbDateTimeZoneSource,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\TzdbDateTimeZoneSource.cs,Validate,The length of the statement  "                        $"Windows mapping primary territory entry for Windows ID {group.Key} has TZDB ID {primaryTzdb} which does not occur in a non-primary territory"); " is 145.
Long Statement,NodaTime.TimeZones,ZoneEqualityComparer,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\ZoneEqualityComparer.cs,GetIntervals,The length of the statement  "            return CheckOption(options' Options.MatchAllTransitions) ? allIntervals : zoneIntervalComparer.CoalesceIntervals(allIntervals); " is 127.
Long Statement,NodaTime.TimeZones,ZoneRecurrence,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\ZoneRecurrence.cs,Equals,The length of the statement  "            return Savings == other.Savings && FromYear == other.FromYear && ToYear == other.ToYear && Name == other.Name && YearOffset.Equals(other.YearOffset); " is 149.
Long Statement,NodaTime.TimeZones,ZoneRecurrence,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\ZoneRecurrence.cs,Next,The length of the statement  "                // Asked for a transition after some point before the first transition: crop to first year (so we get the first transition) " is 123.
Long Statement,NodaTime.TimeZones,ZoneRecurrence,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\ZoneRecurrence.cs,Next,The length of the statement  "                return maxLocalInstant == LocalInstant.AfterMaxValue ? new Transition(Instant.AfterMaxValue' newOffset) : (Transition?) null; " is 125.
Long Statement,NodaTime.TimeZones,ZoneRecurrence,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\ZoneRecurrence.cs,Next,The length of the statement  "                // start of valid local time after applying the rule offset. For example' passing Instant.MinValue for a rule which says " is 120.
Long Statement,NodaTime.TimeZones,ZoneRecurrence,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\ZoneRecurrence.cs,Next,The length of the statement  "            // It's fine for this to be "end of time"' and it can't be "start of time" because we're at least finding a transition in -9997. " is 128.
Long Statement,NodaTime.TimeZones,ZoneRecurrence,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\ZoneRecurrence.cs,PreviousOrSame,The length of the statement  "            // It's fine for this to be "start of time"' and it can't be "end of time" because we're at latest finding a transition in 9998. " is 128.
Long Statement,NodaTime.TimeZones,ZoneRecurrence,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\ZoneRecurrence.cs,NextOrFail,The length of the statement  "                    $"Noda Time bug or bad data: Expected a transition later than {instant}; standard offset = {standardOffset}; previousSavings = {previousSavings}; recurrence = {this}"); " is 168.
Long Statement,NodaTime.TimeZones,ZoneRecurrence,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\ZoneRecurrence.cs,PreviousOrSameOrFail,The length of the statement  "                    $"Noda Time bug or bad data: Expected a transition earlier than {instant}; standard offset = {standardOffset}; previousSavings = {previousSavings}; recurrence = {this}"); " is 170.
Long Statement,NodaTime.TimeZones,ZoneYearOffset,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\ZoneYearOffset.cs,GetOccurrenceForYear,The length of the statement  "                int actualDayOfMonth = dayOfMonth > 0 ? dayOfMonth : CalendarSystem.Iso.GetDaysInMonth(year' monthOfYear) + dayOfMonth + 1; " is 123.
Long Statement,NodaTime.TimeZones.IO,DateTimeZoneReader,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\IO\DateTimeZoneReader.cs,ReadString,The length of the statement  "                        throw new InvalidNodaDataException("Unexpectedly reached end of data with " + (length - offset) + " bytes still to read"); " is 122.
Complex Conditional,NodaTime,LocalTime,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\LocalTime.cs,LocalTime,The conditional expression  "hour < 0 || hour > HoursPerDay - 1 ||                  minute < 0 || minute > MinutesPerHour - 1"  is complex.
Complex Conditional,NodaTime,LocalTime,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\LocalTime.cs,LocalTime,The conditional expression  "hour < 0 || hour > HoursPerDay - 1 ||                  minute < 0 || minute > MinutesPerHour - 1 ||                  second < 0 || second > SecondsPerMinute - 1"  is complex.
Complex Conditional,NodaTime,LocalTime,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\LocalTime.cs,LocalTime,The conditional expression  "hour < 0 || hour > HoursPerDay - 1 ||                  minute < 0 || minute > MinutesPerHour - 1 ||                  second < 0 || second > SecondsPerMinute - 1 ||                  millisecond < 0 || millisecond > MillisecondsPerSecond - 1"  is complex.
Complex Conditional,NodaTime,LocalTime,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\LocalTime.cs,FromHourMinuteSecondMillisecondTick,The conditional expression  "hour < 0 || hour > HoursPerDay - 1 ||                  minute < 0 || minute > MinutesPerHour - 1 ||                  second < 0 || second > SecondsPerMinute - 1 ||                  millisecond < 0 || millisecond > MillisecondsPerSecond - 1 ||                  tickWithinMillisecond < 0 || tickWithinMillisecond > TicksPerMillisecond - 1"  is complex.
Complex Conditional,NodaTime,LocalTime,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\LocalTime.cs,FromHourMinuteSecondTick,The conditional expression  "hour < 0 || hour > HoursPerDay - 1 ||                  minute < 0 || minute > MinutesPerHour - 1 ||                  second < 0 || second > SecondsPerMinute - 1 ||                  tickWithinSecond < 0 || tickWithinSecond > TicksPerSecond - 1"  is complex.
Complex Conditional,NodaTime,LocalTime,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\LocalTime.cs,FromHourMinuteSecondNanosecond,The conditional expression  "hour < 0 || hour > HoursPerDay - 1 ||                  minute < 0 || minute > MinutesPerHour - 1 ||                  second < 0 || second > SecondsPerMinute - 1 ||                  nanosecondWithinSecond < 0 || nanosecondWithinSecond > NanosecondsPerSecond - 1"  is complex.
Complex Conditional,NodaTime,PeriodComparer,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Period.cs,Compare,The conditional expression  "x.Months == 0 && y.Months == 0 &&                      x.Years == 0 && y.Years == 0"  is complex.
Complex Conditional,NodaTime,YearMonth,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\YearMonth.cs,YearMonth,The conditional expression  "year < MinGregorianYear || year > MaxGregorianYear || month < 1 || month > 12"  is complex.
Complex Conditional,NodaTime.Calendars,GregorianYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\GregorianYearMonthDayCalculator.cs,ValidateGregorianYearMonthDay,The conditional expression  "year < MinGregorianYear || year > MaxGregorianYear || month < 1 || month > 12"  is complex.
Complex Conditional,NodaTime.Calendars,HebrewYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewYearMonthDayCalculator.cs,SetYear,The conditional expression  "targetDay == 30 && (targetScripturalMonth == 8 || targetScripturalMonth == 9 || targetScripturalMonth == 12)"  is complex.
Complex Conditional,NodaTime.Text.Patterns,SteppedPatternBuilder<TResult;TBucket>,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\Patterns\SteppedPatternBuilder.cs,ParseCustomPattern,The conditional expression  "(current >= 'A' && current <= 'Z') || (current >= 'a' && current <= 'z') ||                          current == PatternCursor.EmbeddedPatternStart || current == PatternCursor.EmbeddedPatternEnd"  is complex.
Virtual Method Call from Constructor,NodaTime,CalendarSystem,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\CalendarSystem.cs,CalendarSystem,The constructor "CalendarSystem" calls a virtual method "GetStartOfYearInDays".
Virtual Method Call from Constructor,NodaTime,ZonedDateTime,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\ZonedDateTime.cs,ZonedDateTime,The constructor "ZonedDateTime" calls a virtual method "GetUtcOffset".
Virtual Method Call from Constructor,NodaTime,ZonedDateTime,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\ZonedDateTime.cs,ZonedDateTime,The constructor "ZonedDateTime" calls a virtual method "GetUtcOffset".
Virtual Method Call from Constructor,NodaTime,ZonedDateTime,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\ZonedDateTime.cs,ZonedDateTime,The constructor "ZonedDateTime" calls a virtual method "GetUtcOffset".
Empty Catch Block,NodaTime.TimeZones,BclDateTimeZoneSource,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\BclDateTimeZoneSource.cs,GetTimeZoneInfoLocalIdOrEmpty,The method has an empty catch block.
Magic Number,NodaTime,AnnualDate,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\AnnualDate.cs,AnnualDate,The following statement contains a magic number: GregorianYearMonthDayCalculator.ValidateGregorianYearMonthDay(2000' month' day);
Magic Number,NodaTime,CalendarSystem,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\CalendarSystem.cs,GetHebrewCalendar,The following statement contains a magic number: Preconditions.CheckArgumentRange(nameof(monthNumbering)' (int) monthNumbering' 1' 2);
Magic Number,NodaTime,CalendarSystem,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\CalendarSystem.cs,GetIslamicCalendar,The following statement contains a magic number: Preconditions.CheckArgumentRange(nameof(leapYearPattern)' (int) leapYearPattern' 1' 4);
Magic Number,NodaTime,CalendarSystem,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\CalendarSystem.cs,GetIslamicCalendar,The following statement contains a magic number: Preconditions.CheckArgumentRange(nameof(epoch)' (int) epoch' 1' 2);
Magic Number,NodaTime,CalendarSystem,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\CalendarSystem.cs,GetDayOfWeek,The following statement contains a magic number: int numericDayOfWeek = unchecked(daysSinceEpoch >= -3 ? 1 + ((daysSinceEpoch + 3) % 7)                                             : 7 + ((daysSinceEpoch + 4) % 7));
Magic Number,NodaTime,CalendarSystem,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\CalendarSystem.cs,GetDayOfWeek,The following statement contains a magic number: int numericDayOfWeek = unchecked(daysSinceEpoch >= -3 ? 1 + ((daysSinceEpoch + 3) % 7)                                             : 7 + ((daysSinceEpoch + 4) % 7));
Magic Number,NodaTime,CalendarSystem,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\CalendarSystem.cs,GetDayOfWeek,The following statement contains a magic number: int numericDayOfWeek = unchecked(daysSinceEpoch >= -3 ? 1 + ((daysSinceEpoch + 3) % 7)                                             : 7 + ((daysSinceEpoch + 4) % 7));
Magic Number,NodaTime,CalendarSystem,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\CalendarSystem.cs,GetDayOfWeek,The following statement contains a magic number: int numericDayOfWeek = unchecked(daysSinceEpoch >= -3 ? 1 + ((daysSinceEpoch + 3) % 7)                                             : 7 + ((daysSinceEpoch + 4) % 7));
Magic Number,NodaTime,CalendarSystem,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\CalendarSystem.cs,GetDayOfWeek,The following statement contains a magic number: int numericDayOfWeek = unchecked(daysSinceEpoch >= -3 ? 1 + ((daysSinceEpoch + 3) % 7)                                             : 7 + ((daysSinceEpoch + 4) % 7));
Magic Number,NodaTime,CalendarSystem,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\CalendarSystem.cs,GetDayOfWeek,The following statement contains a magic number: int numericDayOfWeek = unchecked(daysSinceEpoch >= -3 ? 1 + ((daysSinceEpoch + 3) % 7)                                             : 7 + ((daysSinceEpoch + 4) % 7));
Magic Number,NodaTime,IslamicCalendars,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\CalendarSystem.cs,IslamicCalendars,The following statement contains a magic number: ByLeapYearPatterAndEpoch = new CalendarSystem[4' 2];
Magic Number,NodaTime,IslamicCalendars,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\CalendarSystem.cs,IslamicCalendars,The following statement contains a magic number: ByLeapYearPatterAndEpoch = new CalendarSystem[4' 2];
Magic Number,NodaTime,IslamicCalendars,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\CalendarSystem.cs,IslamicCalendars,The following statement contains a magic number: CalendarOrdinal ordinal = CalendarOrdinal.IslamicAstronomicalBase15 + (i - 1) + (j - 1) * 4;
Magic Number,NodaTime,IslamicCalendars,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\CalendarSystem.cs,IslamicCalendars,The following statement contains a magic number: j <= 2
Magic Number,NodaTime,IslamicCalendars,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\CalendarSystem.cs,IslamicCalendars,The following statement contains a magic number: i <= 4
Magic Number,NodaTime,DateTimeZone,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\DateTimeZone.cs,MapLocal,The following statement contains a magic number: return new ZoneLocalMapping(this' localDateTime' earlier' interval' 2);
Magic Number,NodaTime,DateTimeZone,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\DateTimeZone.cs,MapLocal,The following statement contains a magic number: return new ZoneLocalMapping(this' localDateTime' interval' later' 2);
Magic Number,NodaTime,DateTimeZone,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\DateTimeZone.cs,AtStartOfDay,The following statement contains a magic number: switch (mapping.Count)              {                  // Midnight doesn't exist. Maybe we just skip to 1am (or whatever)' or maybe the whole day is missed.                  case 0:                      var interval = mapping.LateInterval;                      // Safe to use Start' as it can't extend to the start of time.                      var offsetDateTime = new OffsetDateTime(interval.Start' interval.WallOffset' date.Calendar);                      // It's possible that the entire day is skipped. For example' Samoa skipped December 30th 2011.                      // We know the two values are in the same calendar here' so we just need to check the YearMonthDay.                      if (offsetDateTime.YearMonthDay != date.YearMonthDay)                      {                          throw new SkippedTimeException(midnight' this);                      }                      return new ZonedDateTime(offsetDateTime' this);                  // Unambiguous or occurs twice' we can just use the offset from the earlier interval.                  case 1:                  case 2:                      return new ZonedDateTime(midnight.WithOffset(mapping.EarlyInterval.WallOffset)' this);                  default:                      throw new InvalidOperationException("This won't happen.");              }
Magic Number,NodaTime,LocalDate,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\LocalDate.cs,FromYearMonthWeekAndDay,The following statement contains a magic number: Preconditions.CheckArgumentRange(nameof(occurrence)' occurrence' 1' 5);
Magic Number,NodaTime,LocalDate,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\LocalDate.cs,FromYearMonthWeekAndDay,The following statement contains a magic number: Preconditions.CheckArgumentRange(nameof(dayOfWeek)' (int) dayOfWeek' 1' 7);
Magic Number,NodaTime,LocalDate,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\LocalDate.cs,FromYearMonthWeekAndDay,The following statement contains a magic number: week1Day += 7;
Magic Number,NodaTime,LocalDate,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\LocalDate.cs,FromYearMonthWeekAndDay,The following statement contains a magic number: int targetDay = week1Day + (occurrence - 1) * 7;
Magic Number,NodaTime,LocalDate,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\LocalDate.cs,FromYearMonthWeekAndDay,The following statement contains a magic number: targetDay -= 7;
Magic Number,NodaTime,LocalDate,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\LocalDate.cs,Next,The following statement contains a magic number: difference += 7;
Magic Number,NodaTime,LocalDate,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\LocalDate.cs,Previous,The following statement contains a magic number: difference -= 7;
Magic Number,NodaTime,OffsetDateTime,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\OffsetDateTime.cs,ToDateTimeOffset,The following statement contains a magic number: int offsetMinutes = Offset.Seconds / 60;
Magic Number,NodaTime,YearMonth,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\YearMonth.cs,YearMonth,The following statement contains a magic number: Preconditions.CheckArgumentRange(nameof(month)' month' 1' 12);
Magic Number,NodaTime,YearMonth,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\YearMonth.cs,YearMonth,The following statement contains a magic number: year < MinGregorianYear || year > MaxGregorianYear || month < 1 || month > 12
Magic Number,NodaTime,YearMonthDay,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\YearMonthDay.cs,Parse,The following statement contains a magic number: return new YearMonthDay(                  int.Parse(bits[0]' CultureInfo.InvariantCulture)'                  int.Parse(bits[1]' CultureInfo.InvariantCulture)'                  int.Parse(bits[2]' CultureInfo.InvariantCulture));
Magic Number,NodaTime,YearMonthDayCalendar,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\YearMonthDayCalendar.cs,Parse,The following statement contains a magic number: return new YearMonthDayCalendar(                  int.Parse(bits[0]' CultureInfo.InvariantCulture)'                  int.Parse(bits[1]' CultureInfo.InvariantCulture)'                  int.Parse(bits[2]' CultureInfo.InvariantCulture)'                  (CalendarOrdinal) Enum.Parse(typeof(CalendarOrdinal)' bits[3]' false));
Magic Number,NodaTime,YearMonthDayCalendar,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\YearMonthDayCalendar.cs,Parse,The following statement contains a magic number: return new YearMonthDayCalendar(                  int.Parse(bits[0]' CultureInfo.InvariantCulture)'                  int.Parse(bits[1]' CultureInfo.InvariantCulture)'                  int.Parse(bits[2]' CultureInfo.InvariantCulture)'                  (CalendarOrdinal) Enum.Parse(typeof(CalendarOrdinal)' bits[3]' false));
Magic Number,NodaTime.Calendars,BadiYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\BadiYearMonthDayCalculator.cs,GetDaysInAyyamiHa,The following statement contains a magic number: return num > 10 ? DaysInAyyamiHaInLeapYear : DaysInAyyamiHaInNormalYear;
Magic Number,NodaTime.Calendars,BadiYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\BadiYearMonthDayCalculator.cs,GetNawRuzDayInMarch,The following statement contains a magic number: return 21;
Magic Number,NodaTime.Calendars,BadiYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\BadiYearMonthDayCalculator.cs,GetNawRuzDayInMarch,The following statement contains a magic number: const int dayInMarchForOffsetToNawRuz = 19;
Magic Number,NodaTime.Calendars,BadiYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\BadiYearMonthDayCalculator.cs,GetNawRuzDayInMarch,The following statement contains a magic number: return dayInMarchForOffsetToNawRuz + (num % 10);
Magic Number,NodaTime.Calendars,BadiYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\BadiYearMonthDayCalculator.cs,CalculateStartOfYearDays,The following statement contains a magic number: var nawRuz = new LocalDate(gregorianYear' 3' GetNawRuzDayInMarch(year));
Magic Number,NodaTime.Calendars,CopticYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\CopticYearMonthDayCalculator.cs,CalculateStartOfYearDays,The following statement contains a magic number: int relativeYear = year - 1687;
Magic Number,NodaTime.Calendars,CopticYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\CopticYearMonthDayCalculator.cs,CalculateStartOfYearDays,The following statement contains a magic number: leapYears = (relativeYear + 3) >> 2;
Magic Number,NodaTime.Calendars,CopticYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\CopticYearMonthDayCalculator.cs,CalculateStartOfYearDays,The following statement contains a magic number: leapYears = (relativeYear + 3) >> 2;
Magic Number,NodaTime.Calendars,CopticYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\CopticYearMonthDayCalculator.cs,CalculateStartOfYearDays,The following statement contains a magic number: int ret = relativeYear * 365 + leapYears;
Magic Number,NodaTime.Calendars,CopticYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\CopticYearMonthDayCalculator.cs,CalculateStartOfYearDays,The following statement contains a magic number: return ret + (365 - 112);
Magic Number,NodaTime.Calendars,CopticYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\CopticYearMonthDayCalculator.cs,CalculateStartOfYearDays,The following statement contains a magic number: return ret + (365 - 112);
Magic Number,NodaTime.Calendars,GJYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\GJYearMonthDayCalculator.cs,GJYearMonthDayCalculator,The following statement contains a magic number: MinTotalDaysByMonth = new int[12];
Magic Number,NodaTime.Calendars,GJYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\GJYearMonthDayCalculator.cs,GJYearMonthDayCalculator,The following statement contains a magic number: MaxTotalDaysByMonth = new int[12];
Magic Number,NodaTime.Calendars,GJYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\GJYearMonthDayCalculator.cs,GJYearMonthDayCalculator,The following statement contains a magic number: i < 11
Magic Number,NodaTime.Calendars,GJYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\GJYearMonthDayCalculator.cs,GetYearMonthDay,The following statement contains a magic number: startOfMonth = ((d < 183)                                ? ((d < 92) ? ((d < 32) ? 0 : (d < 61) ? 31 : 60) : ((d < 122) ? 91 : (d < 153) ? 121 : 152))                                : ((d < 275)                                       ? ((d < 214) ? 182 : (d < 245) ? 213 : 244)                                       : ((d < 306) ? 274 : (d < 336) ? 305 : 335)));
Magic Number,NodaTime.Calendars,GJYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\GJYearMonthDayCalculator.cs,GetYearMonthDay,The following statement contains a magic number: startOfMonth = ((d < 183)                                ? ((d < 92) ? ((d < 32) ? 0 : (d < 61) ? 31 : 60) : ((d < 122) ? 91 : (d < 153) ? 121 : 152))                                : ((d < 275)                                       ? ((d < 214) ? 182 : (d < 245) ? 213 : 244)                                       : ((d < 306) ? 274 : (d < 336) ? 305 : 335)));
Magic Number,NodaTime.Calendars,GJYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\GJYearMonthDayCalculator.cs,GetYearMonthDay,The following statement contains a magic number: startOfMonth = ((d < 183)                                ? ((d < 92) ? ((d < 32) ? 0 : (d < 61) ? 31 : 60) : ((d < 122) ? 91 : (d < 153) ? 121 : 152))                                : ((d < 275)                                       ? ((d < 214) ? 182 : (d < 245) ? 213 : 244)                                       : ((d < 306) ? 274 : (d < 336) ? 305 : 335)));
Magic Number,NodaTime.Calendars,GJYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\GJYearMonthDayCalculator.cs,GetYearMonthDay,The following statement contains a magic number: startOfMonth = ((d < 183)                                ? ((d < 92) ? ((d < 32) ? 0 : (d < 61) ? 31 : 60) : ((d < 122) ? 91 : (d < 153) ? 121 : 152))                                : ((d < 275)                                       ? ((d < 214) ? 182 : (d < 245) ? 213 : 244)                                       : ((d < 306) ? 274 : (d < 336) ? 305 : 335)));
Magic Number,NodaTime.Calendars,GJYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\GJYearMonthDayCalculator.cs,GetYearMonthDay,The following statement contains a magic number: startOfMonth = ((d < 183)                                ? ((d < 92) ? ((d < 32) ? 0 : (d < 61) ? 31 : 60) : ((d < 122) ? 91 : (d < 153) ? 121 : 152))                                : ((d < 275)                                       ? ((d < 214) ? 182 : (d < 245) ? 213 : 244)                                       : ((d < 306) ? 274 : (d < 336) ? 305 : 335)));
Magic Number,NodaTime.Calendars,GJYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\GJYearMonthDayCalculator.cs,GetYearMonthDay,The following statement contains a magic number: startOfMonth = ((d < 183)                                ? ((d < 92) ? ((d < 32) ? 0 : (d < 61) ? 31 : 60) : ((d < 122) ? 91 : (d < 153) ? 121 : 152))                                : ((d < 275)                                       ? ((d < 214) ? 182 : (d < 245) ? 213 : 244)                                       : ((d < 306) ? 274 : (d < 336) ? 305 : 335)));
Magic Number,NodaTime.Calendars,GJYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\GJYearMonthDayCalculator.cs,GetYearMonthDay,The following statement contains a magic number: startOfMonth = ((d < 183)                                ? ((d < 92) ? ((d < 32) ? 0 : (d < 61) ? 31 : 60) : ((d < 122) ? 91 : (d < 153) ? 121 : 152))                                : ((d < 275)                                       ? ((d < 214) ? 182 : (d < 245) ? 213 : 244)                                       : ((d < 306) ? 274 : (d < 336) ? 305 : 335)));
Magic Number,NodaTime.Calendars,GJYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\GJYearMonthDayCalculator.cs,GetYearMonthDay,The following statement contains a magic number: startOfMonth = ((d < 183)                                ? ((d < 92) ? ((d < 32) ? 0 : (d < 61) ? 31 : 60) : ((d < 122) ? 91 : (d < 153) ? 121 : 152))                                : ((d < 275)                                       ? ((d < 214) ? 182 : (d < 245) ? 213 : 244)                                       : ((d < 306) ? 274 : (d < 336) ? 305 : 335)));
Magic Number,NodaTime.Calendars,GJYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\GJYearMonthDayCalculator.cs,GetYearMonthDay,The following statement contains a magic number: startOfMonth = ((d < 183)                                ? ((d < 92) ? ((d < 32) ? 0 : (d < 61) ? 31 : 60) : ((d < 122) ? 91 : (d < 153) ? 121 : 152))                                : ((d < 275)                                       ? ((d < 214) ? 182 : (d < 245) ? 213 : 244)                                       : ((d < 306) ? 274 : (d < 336) ? 305 : 335)));
Magic Number,NodaTime.Calendars,GJYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\GJYearMonthDayCalculator.cs,GetYearMonthDay,The following statement contains a magic number: startOfMonth = ((d < 183)                                ? ((d < 92) ? ((d < 32) ? 0 : (d < 61) ? 31 : 60) : ((d < 122) ? 91 : (d < 153) ? 121 : 152))                                : ((d < 275)                                       ? ((d < 214) ? 182 : (d < 245) ? 213 : 244)                                       : ((d < 306) ? 274 : (d < 336) ? 305 : 335)));
Magic Number,NodaTime.Calendars,GJYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\GJYearMonthDayCalculator.cs,GetYearMonthDay,The following statement contains a magic number: startOfMonth = ((d < 183)                                ? ((d < 92) ? ((d < 32) ? 0 : (d < 61) ? 31 : 60) : ((d < 122) ? 91 : (d < 153) ? 121 : 152))                                : ((d < 275)                                       ? ((d < 214) ? 182 : (d < 245) ? 213 : 244)                                       : ((d < 306) ? 274 : (d < 336) ? 305 : 335)));
Magic Number,NodaTime.Calendars,GJYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\GJYearMonthDayCalculator.cs,GetYearMonthDay,The following statement contains a magic number: startOfMonth = ((d < 183)                                ? ((d < 92) ? ((d < 32) ? 0 : (d < 61) ? 31 : 60) : ((d < 122) ? 91 : (d < 153) ? 121 : 152))                                : ((d < 275)                                       ? ((d < 214) ? 182 : (d < 245) ? 213 : 244)                                       : ((d < 306) ? 274 : (d < 336) ? 305 : 335)));
Magic Number,NodaTime.Calendars,GJYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\GJYearMonthDayCalculator.cs,GetYearMonthDay,The following statement contains a magic number: startOfMonth = ((d < 183)                                ? ((d < 92) ? ((d < 32) ? 0 : (d < 61) ? 31 : 60) : ((d < 122) ? 91 : (d < 153) ? 121 : 152))                                : ((d < 275)                                       ? ((d < 214) ? 182 : (d < 245) ? 213 : 244)                                       : ((d < 306) ? 274 : (d < 336) ? 305 : 335)));
Magic Number,NodaTime.Calendars,GJYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\GJYearMonthDayCalculator.cs,GetYearMonthDay,The following statement contains a magic number: startOfMonth = ((d < 183)                                ? ((d < 92) ? ((d < 32) ? 0 : (d < 61) ? 31 : 60) : ((d < 122) ? 91 : (d < 153) ? 121 : 152))                                : ((d < 275)                                       ? ((d < 214) ? 182 : (d < 245) ? 213 : 244)                                       : ((d < 306) ? 274 : (d < 336) ? 305 : 335)));
Magic Number,NodaTime.Calendars,GJYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\GJYearMonthDayCalculator.cs,GetYearMonthDay,The following statement contains a magic number: startOfMonth = ((d < 183)                                ? ((d < 92) ? ((d < 32) ? 0 : (d < 61) ? 31 : 60) : ((d < 122) ? 91 : (d < 153) ? 121 : 152))                                : ((d < 275)                                       ? ((d < 214) ? 182 : (d < 245) ? 213 : 244)                                       : ((d < 306) ? 274 : (d < 336) ? 305 : 335)));
Magic Number,NodaTime.Calendars,GJYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\GJYearMonthDayCalculator.cs,GetYearMonthDay,The following statement contains a magic number: startOfMonth = ((d < 183)                                ? ((d < 92) ? ((d < 32) ? 0 : (d < 61) ? 31 : 60) : ((d < 122) ? 91 : (d < 153) ? 121 : 152))                                : ((d < 275)                                       ? ((d < 214) ? 182 : (d < 245) ? 213 : 244)                                       : ((d < 306) ? 274 : (d < 336) ? 305 : 335)));
Magic Number,NodaTime.Calendars,GJYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\GJYearMonthDayCalculator.cs,GetYearMonthDay,The following statement contains a magic number: startOfMonth = ((d < 183)                                ? ((d < 92) ? ((d < 32) ? 0 : (d < 61) ? 31 : 60) : ((d < 122) ? 91 : (d < 153) ? 121 : 152))                                : ((d < 275)                                       ? ((d < 214) ? 182 : (d < 245) ? 213 : 244)                                       : ((d < 306) ? 274 : (d < 336) ? 305 : 335)));
Magic Number,NodaTime.Calendars,GJYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\GJYearMonthDayCalculator.cs,GetYearMonthDay,The following statement contains a magic number: startOfMonth = ((d < 183)                                ? ((d < 92) ? ((d < 32) ? 0 : (d < 61) ? 31 : 60) : ((d < 122) ? 91 : (d < 153) ? 121 : 152))                                : ((d < 275)                                       ? ((d < 214) ? 182 : (d < 245) ? 213 : 244)                                       : ((d < 306) ? 274 : (d < 336) ? 305 : 335)));
Magic Number,NodaTime.Calendars,GJYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\GJYearMonthDayCalculator.cs,GetYearMonthDay,The following statement contains a magic number: startOfMonth = ((d < 183)                                ? ((d < 92) ? ((d < 32) ? 0 : (d < 61) ? 31 : 60) : ((d < 122) ? 91 : (d < 153) ? 121 : 152))                                : ((d < 275)                                       ? ((d < 214) ? 182 : (d < 245) ? 213 : 244)                                       : ((d < 306) ? 274 : (d < 336) ? 305 : 335)));
Magic Number,NodaTime.Calendars,GJYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\GJYearMonthDayCalculator.cs,GetYearMonthDay,The following statement contains a magic number: startOfMonth = ((d < 183)                                ? ((d < 92) ? ((d < 32) ? 0 : (d < 61) ? 31 : 60) : ((d < 122) ? 91 : (d < 153) ? 121 : 152))                                : ((d < 275)                                       ? ((d < 214) ? 182 : (d < 245) ? 213 : 244)                                       : ((d < 306) ? 274 : (d < 336) ? 305 : 335)));
Magic Number,NodaTime.Calendars,GJYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\GJYearMonthDayCalculator.cs,GetYearMonthDay,The following statement contains a magic number: startOfMonth = ((d < 183)                                ? ((d < 92) ? ((d < 32) ? 0 : (d < 61) ? 31 : 60) : ((d < 122) ? 91 : (d < 153) ? 121 : 152))                                : ((d < 275)                                       ? ((d < 214) ? 182 : (d < 245) ? 213 : 244)                                       : ((d < 306) ? 274 : (d < 336) ? 305 : 335)));
Magic Number,NodaTime.Calendars,GJYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\GJYearMonthDayCalculator.cs,GetYearMonthDay,The following statement contains a magic number: startOfMonth = ((d < 183)                                ? ((d < 92) ? ((d < 32) ? 0 : (d < 61) ? 31 : 60) : ((d < 122) ? 91 : (d < 153) ? 121 : 152))                                : ((d < 275)                                       ? ((d < 214) ? 182 : (d < 245) ? 213 : 244)                                       : ((d < 306) ? 274 : (d < 336) ? 305 : 335)));
Magic Number,NodaTime.Calendars,GJYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\GJYearMonthDayCalculator.cs,GetYearMonthDay,The following statement contains a magic number: return new YearMonthDay(year' (startOfMonth / 29) + 1' dayOfMonth);
Magic Number,NodaTime.Calendars,GregorianYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\GregorianYearMonthDayCalculator.cs,GregorianYearMonthDayCalculator,The following statement contains a magic number: int yearMonthIndex = (year - FirstOptimizedYear) * 12;
Magic Number,NodaTime.Calendars,GregorianYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\GregorianYearMonthDayCalculator.cs,GregorianYearMonthDayCalculator,The following statement contains a magic number: month <= 12
Magic Number,NodaTime.Calendars,GregorianYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\GregorianYearMonthDayCalculator.cs,GetGregorianYearMonthDayCalendarFromDaysSinceEpoch,The following statement contains a magic number: int yearIndex = (daysSinceEpoch - FirstOptimizedDay) / 366;
Magic Number,NodaTime.Calendars,GregorianYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\GregorianYearMonthDayCalculator.cs,GetGregorianYearMonthDayCalendarFromDaysSinceEpoch,The following statement contains a magic number: int daysInYear = isLeap ? 366 : 365;
Magic Number,NodaTime.Calendars,GregorianYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\GregorianYearMonthDayCalculator.cs,GetGregorianYearMonthDayCalendarFromDaysSinceEpoch,The following statement contains a magic number: int daysInYear = isLeap ? 366 : 365;
Magic Number,NodaTime.Calendars,GregorianYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\GregorianYearMonthDayCalculator.cs,GetGregorianYearMonthDayCalendarFromDaysSinceEpoch,The following statement contains a magic number: startOfMonth = ((d < 182)                                    ? ((d < 91) ? ((d < 31) ? -1 : (d < 60) ? 30 : 59) : ((d < 121) ? 90 : (d < 152) ? 120 : 151))                                    : ((d < 274)                                           ? ((d < 213) ? 181 : (d < 244) ? 212 : 243)                                           : ((d < 305) ? 273 : (d < 335) ? 304 : 334)));
Magic Number,NodaTime.Calendars,GregorianYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\GregorianYearMonthDayCalculator.cs,GetGregorianYearMonthDayCalendarFromDaysSinceEpoch,The following statement contains a magic number: startOfMonth = ((d < 182)                                    ? ((d < 91) ? ((d < 31) ? -1 : (d < 60) ? 30 : 59) : ((d < 121) ? 90 : (d < 152) ? 120 : 151))                                    : ((d < 274)                                           ? ((d < 213) ? 181 : (d < 244) ? 212 : 243)                                           : ((d < 305) ? 273 : (d < 335) ? 304 : 334)));
Magic Number,NodaTime.Calendars,GregorianYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\GregorianYearMonthDayCalculator.cs,GetGregorianYearMonthDayCalendarFromDaysSinceEpoch,The following statement contains a magic number: startOfMonth = ((d < 182)                                    ? ((d < 91) ? ((d < 31) ? -1 : (d < 60) ? 30 : 59) : ((d < 121) ? 90 : (d < 152) ? 120 : 151))                                    : ((d < 274)                                           ? ((d < 213) ? 181 : (d < 244) ? 212 : 243)                                           : ((d < 305) ? 273 : (d < 335) ? 304 : 334)));
Magic Number,NodaTime.Calendars,GregorianYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\GregorianYearMonthDayCalculator.cs,GetGregorianYearMonthDayCalendarFromDaysSinceEpoch,The following statement contains a magic number: startOfMonth = ((d < 182)                                    ? ((d < 91) ? ((d < 31) ? -1 : (d < 60) ? 30 : 59) : ((d < 121) ? 90 : (d < 152) ? 120 : 151))                                    : ((d < 274)                                           ? ((d < 213) ? 181 : (d < 244) ? 212 : 243)                                           : ((d < 305) ? 273 : (d < 335) ? 304 : 334)));
Magic Number,NodaTime.Calendars,GregorianYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\GregorianYearMonthDayCalculator.cs,GetGregorianYearMonthDayCalendarFromDaysSinceEpoch,The following statement contains a magic number: startOfMonth = ((d < 182)                                    ? ((d < 91) ? ((d < 31) ? -1 : (d < 60) ? 30 : 59) : ((d < 121) ? 90 : (d < 152) ? 120 : 151))                                    : ((d < 274)                                           ? ((d < 213) ? 181 : (d < 244) ? 212 : 243)                                           : ((d < 305) ? 273 : (d < 335) ? 304 : 334)));
Magic Number,NodaTime.Calendars,GregorianYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\GregorianYearMonthDayCalculator.cs,GetGregorianYearMonthDayCalendarFromDaysSinceEpoch,The following statement contains a magic number: startOfMonth = ((d < 182)                                    ? ((d < 91) ? ((d < 31) ? -1 : (d < 60) ? 30 : 59) : ((d < 121) ? 90 : (d < 152) ? 120 : 151))                                    : ((d < 274)                                           ? ((d < 213) ? 181 : (d < 244) ? 212 : 243)                                           : ((d < 305) ? 273 : (d < 335) ? 304 : 334)));
Magic Number,NodaTime.Calendars,GregorianYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\GregorianYearMonthDayCalculator.cs,GetGregorianYearMonthDayCalendarFromDaysSinceEpoch,The following statement contains a magic number: startOfMonth = ((d < 182)                                    ? ((d < 91) ? ((d < 31) ? -1 : (d < 60) ? 30 : 59) : ((d < 121) ? 90 : (d < 152) ? 120 : 151))                                    : ((d < 274)                                           ? ((d < 213) ? 181 : (d < 244) ? 212 : 243)                                           : ((d < 305) ? 273 : (d < 335) ? 304 : 334)));
Magic Number,NodaTime.Calendars,GregorianYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\GregorianYearMonthDayCalculator.cs,GetGregorianYearMonthDayCalendarFromDaysSinceEpoch,The following statement contains a magic number: startOfMonth = ((d < 182)                                    ? ((d < 91) ? ((d < 31) ? -1 : (d < 60) ? 30 : 59) : ((d < 121) ? 90 : (d < 152) ? 120 : 151))                                    : ((d < 274)                                           ? ((d < 213) ? 181 : (d < 244) ? 212 : 243)                                           : ((d < 305) ? 273 : (d < 335) ? 304 : 334)));
Magic Number,NodaTime.Calendars,GregorianYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\GregorianYearMonthDayCalculator.cs,GetGregorianYearMonthDayCalendarFromDaysSinceEpoch,The following statement contains a magic number: startOfMonth = ((d < 182)                                    ? ((d < 91) ? ((d < 31) ? -1 : (d < 60) ? 30 : 59) : ((d < 121) ? 90 : (d < 152) ? 120 : 151))                                    : ((d < 274)                                           ? ((d < 213) ? 181 : (d < 244) ? 212 : 243)                                           : ((d < 305) ? 273 : (d < 335) ? 304 : 334)));
Magic Number,NodaTime.Calendars,GregorianYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\GregorianYearMonthDayCalculator.cs,GetGregorianYearMonthDayCalendarFromDaysSinceEpoch,The following statement contains a magic number: startOfMonth = ((d < 182)                                    ? ((d < 91) ? ((d < 31) ? -1 : (d < 60) ? 30 : 59) : ((d < 121) ? 90 : (d < 152) ? 120 : 151))                                    : ((d < 274)                                           ? ((d < 213) ? 181 : (d < 244) ? 212 : 243)                                           : ((d < 305) ? 273 : (d < 335) ? 304 : 334)));
Magic Number,NodaTime.Calendars,GregorianYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\GregorianYearMonthDayCalculator.cs,GetGregorianYearMonthDayCalendarFromDaysSinceEpoch,The following statement contains a magic number: startOfMonth = ((d < 182)                                    ? ((d < 91) ? ((d < 31) ? -1 : (d < 60) ? 30 : 59) : ((d < 121) ? 90 : (d < 152) ? 120 : 151))                                    : ((d < 274)                                           ? ((d < 213) ? 181 : (d < 244) ? 212 : 243)                                           : ((d < 305) ? 273 : (d < 335) ? 304 : 334)));
Magic Number,NodaTime.Calendars,GregorianYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\GregorianYearMonthDayCalculator.cs,GetGregorianYearMonthDayCalendarFromDaysSinceEpoch,The following statement contains a magic number: startOfMonth = ((d < 182)                                    ? ((d < 91) ? ((d < 31) ? -1 : (d < 60) ? 30 : 59) : ((d < 121) ? 90 : (d < 152) ? 120 : 151))                                    : ((d < 274)                                           ? ((d < 213) ? 181 : (d < 244) ? 212 : 243)                                           : ((d < 305) ? 273 : (d < 335) ? 304 : 334)));
Magic Number,NodaTime.Calendars,GregorianYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\GregorianYearMonthDayCalculator.cs,GetGregorianYearMonthDayCalendarFromDaysSinceEpoch,The following statement contains a magic number: startOfMonth = ((d < 182)                                    ? ((d < 91) ? ((d < 31) ? -1 : (d < 60) ? 30 : 59) : ((d < 121) ? 90 : (d < 152) ? 120 : 151))                                    : ((d < 274)                                           ? ((d < 213) ? 181 : (d < 244) ? 212 : 243)                                           : ((d < 305) ? 273 : (d < 335) ? 304 : 334)));
Magic Number,NodaTime.Calendars,GregorianYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\GregorianYearMonthDayCalculator.cs,GetGregorianYearMonthDayCalendarFromDaysSinceEpoch,The following statement contains a magic number: startOfMonth = ((d < 182)                                    ? ((d < 91) ? ((d < 31) ? -1 : (d < 60) ? 30 : 59) : ((d < 121) ? 90 : (d < 152) ? 120 : 151))                                    : ((d < 274)                                           ? ((d < 213) ? 181 : (d < 244) ? 212 : 243)                                           : ((d < 305) ? 273 : (d < 335) ? 304 : 334)));
Magic Number,NodaTime.Calendars,GregorianYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\GregorianYearMonthDayCalculator.cs,GetGregorianYearMonthDayCalendarFromDaysSinceEpoch,The following statement contains a magic number: startOfMonth = ((d < 182)                                    ? ((d < 91) ? ((d < 31) ? -1 : (d < 60) ? 30 : 59) : ((d < 121) ? 90 : (d < 152) ? 120 : 151))                                    : ((d < 274)                                           ? ((d < 213) ? 181 : (d < 244) ? 212 : 243)                                           : ((d < 305) ? 273 : (d < 335) ? 304 : 334)));
Magic Number,NodaTime.Calendars,GregorianYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\GregorianYearMonthDayCalculator.cs,GetGregorianYearMonthDayCalendarFromDaysSinceEpoch,The following statement contains a magic number: startOfMonth = ((d < 182)                                    ? ((d < 91) ? ((d < 31) ? -1 : (d < 60) ? 30 : 59) : ((d < 121) ? 90 : (d < 152) ? 120 : 151))                                    : ((d < 274)                                           ? ((d < 213) ? 181 : (d < 244) ? 212 : 243)                                           : ((d < 305) ? 273 : (d < 335) ? 304 : 334)));
Magic Number,NodaTime.Calendars,GregorianYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\GregorianYearMonthDayCalculator.cs,GetGregorianYearMonthDayCalendarFromDaysSinceEpoch,The following statement contains a magic number: startOfMonth = ((d < 182)                                    ? ((d < 91) ? ((d < 31) ? -1 : (d < 60) ? 30 : 59) : ((d < 121) ? 90 : (d < 152) ? 120 : 151))                                    : ((d < 274)                                           ? ((d < 213) ? 181 : (d < 244) ? 212 : 243)                                           : ((d < 305) ? 273 : (d < 335) ? 304 : 334)));
Magic Number,NodaTime.Calendars,GregorianYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\GregorianYearMonthDayCalculator.cs,GetGregorianYearMonthDayCalendarFromDaysSinceEpoch,The following statement contains a magic number: startOfMonth = ((d < 182)                                    ? ((d < 91) ? ((d < 31) ? -1 : (d < 60) ? 30 : 59) : ((d < 121) ? 90 : (d < 152) ? 120 : 151))                                    : ((d < 274)                                           ? ((d < 213) ? 181 : (d < 244) ? 212 : 243)                                           : ((d < 305) ? 273 : (d < 335) ? 304 : 334)));
Magic Number,NodaTime.Calendars,GregorianYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\GregorianYearMonthDayCalculator.cs,GetGregorianYearMonthDayCalendarFromDaysSinceEpoch,The following statement contains a magic number: startOfMonth = ((d < 182)                                    ? ((d < 91) ? ((d < 31) ? -1 : (d < 60) ? 30 : 59) : ((d < 121) ? 90 : (d < 152) ? 120 : 151))                                    : ((d < 274)                                           ? ((d < 213) ? 181 : (d < 244) ? 212 : 243)                                           : ((d < 305) ? 273 : (d < 335) ? 304 : 334)));
Magic Number,NodaTime.Calendars,GregorianYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\GregorianYearMonthDayCalculator.cs,GetGregorianYearMonthDayCalendarFromDaysSinceEpoch,The following statement contains a magic number: startOfMonth = ((d < 182)                                    ? ((d < 91) ? ((d < 31) ? -1 : (d < 60) ? 30 : 59) : ((d < 121) ? 90 : (d < 152) ? 120 : 151))                                    : ((d < 274)                                           ? ((d < 213) ? 181 : (d < 244) ? 212 : 243)                                           : ((d < 305) ? 273 : (d < 335) ? 304 : 334)));
Magic Number,NodaTime.Calendars,GregorianYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\GregorianYearMonthDayCalculator.cs,GetGregorianYearMonthDayCalendarFromDaysSinceEpoch,The following statement contains a magic number: startOfMonth = ((d < 182)                                    ? ((d < 91) ? ((d < 31) ? -1 : (d < 60) ? 30 : 59) : ((d < 121) ? 90 : (d < 152) ? 120 : 151))                                    : ((d < 274)                                           ? ((d < 213) ? 181 : (d < 244) ? 212 : 243)                                           : ((d < 305) ? 273 : (d < 335) ? 304 : 334)));
Magic Number,NodaTime.Calendars,GregorianYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\GregorianYearMonthDayCalculator.cs,GetGregorianYearMonthDayCalendarFromDaysSinceEpoch,The following statement contains a magic number: startOfMonth = ((d < 182)                                    ? ((d < 91) ? ((d < 31) ? -1 : (d < 60) ? 30 : 59) : ((d < 121) ? 90 : (d < 152) ? 120 : 151))                                    : ((d < 274)                                           ? ((d < 213) ? 181 : (d < 244) ? 212 : 243)                                           : ((d < 305) ? 273 : (d < 335) ? 304 : 334)));
Magic Number,NodaTime.Calendars,GregorianYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\GregorianYearMonthDayCalculator.cs,GetGregorianYearMonthDayCalendarFromDaysSinceEpoch,The following statement contains a magic number: int month = startOfMonth / 29 + 1;
Magic Number,NodaTime.Calendars,GregorianYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\GregorianYearMonthDayCalculator.cs,GetDaysSinceEpoch,The following statement contains a magic number: int yearMonthIndex = (year - FirstOptimizedYear) * 12 + monthOfYear;
Magic Number,NodaTime.Calendars,GregorianYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\GregorianYearMonthDayCalculator.cs,ValidateGregorianYearMonthDay,The following statement contains a magic number: Preconditions.CheckArgumentRange(nameof(month)' month' 1' 12);
Magic Number,NodaTime.Calendars,GregorianYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\GregorianYearMonthDayCalculator.cs,ValidateGregorianYearMonthDay,The following statement contains a magic number: year < MinGregorianYear || year > MaxGregorianYear || month < 1 || month > 12
Magic Number,NodaTime.Calendars,GregorianYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\GregorianYearMonthDayCalculator.cs,ValidateGregorianYearMonthDay,The following statement contains a magic number: day >= 1 && day <= 28
Magic Number,NodaTime.Calendars,GregorianYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\GregorianYearMonthDayCalculator.cs,ValidateGregorianYearMonthDay,The following statement contains a magic number: int daysInMonth = month == 2 && IsGregorianLeapYear(year) ? MaxDaysPerMonth[month - 1] : MinDaysPerMonth[month - 1];
Magic Number,NodaTime.Calendars,GregorianYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\GregorianYearMonthDayCalculator.cs,CalculateStartOfYearDays,The following statement contains a magic number: int leapYears = year / 100;
Magic Number,NodaTime.Calendars,GregorianYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\GregorianYearMonthDayCalculator.cs,CalculateStartOfYearDays,The following statement contains a magic number: leapYears = ((year + 3) >> 2) - leapYears + ((leapYears + 3) >> 2) - 1;
Magic Number,NodaTime.Calendars,GregorianYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\GregorianYearMonthDayCalculator.cs,CalculateStartOfYearDays,The following statement contains a magic number: leapYears = ((year + 3) >> 2) - leapYears + ((leapYears + 3) >> 2) - 1;
Magic Number,NodaTime.Calendars,GregorianYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\GregorianYearMonthDayCalculator.cs,CalculateStartOfYearDays,The following statement contains a magic number: leapYears = ((year + 3) >> 2) - leapYears + ((leapYears + 3) >> 2) - 1;
Magic Number,NodaTime.Calendars,GregorianYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\GregorianYearMonthDayCalculator.cs,CalculateStartOfYearDays,The following statement contains a magic number: leapYears = ((year + 3) >> 2) - leapYears + ((leapYears + 3) >> 2) - 1;
Magic Number,NodaTime.Calendars,GregorianYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\GregorianYearMonthDayCalculator.cs,CalculateStartOfYearDays,The following statement contains a magic number: return year * 365 + (leapYears - DaysFrom0000To1970);
Magic Number,NodaTime.Calendars,HebrewMonthConverter,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewMonthConverter.cs,CivilToScriptural,The following statement contains a magic number: return month + 6;
Magic Number,NodaTime.Calendars,HebrewMonthConverter,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewMonthConverter.cs,CivilToScriptural,The following statement contains a magic number: month < 7
Magic Number,NodaTime.Calendars,HebrewMonthConverter,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewMonthConverter.cs,CivilToScriptural,The following statement contains a magic number: return leapYear ? 13 : 1;
Magic Number,NodaTime.Calendars,HebrewMonthConverter,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewMonthConverter.cs,CivilToScriptural,The following statement contains a magic number: month == 7
Magic Number,NodaTime.Calendars,HebrewMonthConverter,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewMonthConverter.cs,CivilToScriptural,The following statement contains a magic number: return leapYear ? month - 7 : month - 6;
Magic Number,NodaTime.Calendars,HebrewMonthConverter,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewMonthConverter.cs,CivilToScriptural,The following statement contains a magic number: return leapYear ? month - 7 : month - 6;
Magic Number,NodaTime.Calendars,HebrewMonthConverter,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewMonthConverter.cs,ScripturalToCivil,The following statement contains a magic number: return month - 6;
Magic Number,NodaTime.Calendars,HebrewMonthConverter,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewMonthConverter.cs,ScripturalToCivil,The following statement contains a magic number: month >= 7
Magic Number,NodaTime.Calendars,HebrewMonthConverter,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewMonthConverter.cs,ScripturalToCivil,The following statement contains a magic number: return HebrewScripturalCalculator.IsLeapYear(year) ? month + 7 : month + 6;
Magic Number,NodaTime.Calendars,HebrewMonthConverter,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewMonthConverter.cs,ScripturalToCivil,The following statement contains a magic number: return HebrewScripturalCalculator.IsLeapYear(year) ? month + 7 : month + 6;
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: int heshvanLength = (cache & IsHeshvanLongCacheBit) != 0 ? 30 : 29;
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: int heshvanLength = (cache & IsHeshvanLongCacheBit) != 0 ? 30 : 29;
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: int kislevLength = (cache & IsKislevShortCacheBit) != 0 ? 29 : 30;
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: int kislevLength = (cache & IsKislevShortCacheBit) != 0 ? 29 : 30;
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: int firstAdarLength = isLeap ? 30 : 29;
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: int firstAdarLength = isLeap ? 30 : 29;
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: return new YearMonthDay(year' 7' dayOfYear);
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: dayOfYear < 31
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: return new YearMonthDay(year' 8' dayOfYear - 30);
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: return new YearMonthDay(year' 8' dayOfYear - 30);
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: dayOfYear < 31 + heshvanLength
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: return new YearMonthDay(year' 9' dayOfYear - 30);
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: return new YearMonthDay(year' 9' dayOfYear - 30);
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: dayOfYear < 31 + kislevLength
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: return new YearMonthDay(year' 10' dayOfYear - 30);
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: return new YearMonthDay(year' 10' dayOfYear - 30);
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: dayOfYear < 31 + 29
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: dayOfYear < 31 + 29
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: return new YearMonthDay(year' 11' dayOfYear - (30 + 29));
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: return new YearMonthDay(year' 11' dayOfYear - (30 + 29));
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: return new YearMonthDay(year' 11' dayOfYear - (30 + 29));
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: dayOfYear < 31 + 29 + 30
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: dayOfYear < 31 + 29 + 30
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: dayOfYear < 31 + 29 + 30
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: return new YearMonthDay(year' 12' dayOfYear - (30 + 29 + 30));
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: return new YearMonthDay(year' 12' dayOfYear - (30 + 29 + 30));
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: return new YearMonthDay(year' 12' dayOfYear - (30 + 29 + 30));
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: return new YearMonthDay(year' 12' dayOfYear - (30 + 29 + 30));
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: dayOfYear < 31 + 29 + 30 + firstAdarLength
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: dayOfYear < 31 + 29 + 30 + firstAdarLength
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: dayOfYear < 31 + 29 + 30 + firstAdarLength
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: return new YearMonthDay(year' 13' dayOfYear - (30 + 29 + 30));
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: return new YearMonthDay(year' 13' dayOfYear - (30 + 29 + 30));
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: return new YearMonthDay(year' 13' dayOfYear - (30 + 29 + 30));
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: return new YearMonthDay(year' 13' dayOfYear - (30 + 29 + 30));
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: dayOfYear < 31 + 29 + 30 + 29
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: dayOfYear < 31 + 29 + 30 + 29
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: dayOfYear < 31 + 29 + 30 + 29
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: dayOfYear < 31 + 29 + 30 + 29
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: dayOfYear -= 29;
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: return new YearMonthDay(year' 1' dayOfYear - (30 + 29 + 30));
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: return new YearMonthDay(year' 1' dayOfYear - (30 + 29 + 30));
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: return new YearMonthDay(year' 1' dayOfYear - (30 + 29 + 30));
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: dayOfYear < 31 + 29 + 30 + 30
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: dayOfYear < 31 + 29 + 30 + 30
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: dayOfYear < 31 + 29 + 30 + 30
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: dayOfYear < 31 + 29 + 30 + 30
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: return new YearMonthDay(year' 2' dayOfYear - (30 + 29 + 30 + 30));
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: return new YearMonthDay(year' 2' dayOfYear - (30 + 29 + 30 + 30));
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: return new YearMonthDay(year' 2' dayOfYear - (30 + 29 + 30 + 30));
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: return new YearMonthDay(year' 2' dayOfYear - (30 + 29 + 30 + 30));
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: return new YearMonthDay(year' 2' dayOfYear - (30 + 29 + 30 + 30));
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: dayOfYear < 31 + 29 + 30 + 30 + 29
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: dayOfYear < 31 + 29 + 30 + 30 + 29
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: dayOfYear < 31 + 29 + 30 + 30 + 29
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: dayOfYear < 31 + 29 + 30 + 30 + 29
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: dayOfYear < 31 + 29 + 30 + 30 + 29
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: return new YearMonthDay(year' 3' dayOfYear - (30 + 29 + 30 + 30 + 29));
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: return new YearMonthDay(year' 3' dayOfYear - (30 + 29 + 30 + 30 + 29));
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: return new YearMonthDay(year' 3' dayOfYear - (30 + 29 + 30 + 30 + 29));
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: return new YearMonthDay(year' 3' dayOfYear - (30 + 29 + 30 + 30 + 29));
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: return new YearMonthDay(year' 3' dayOfYear - (30 + 29 + 30 + 30 + 29));
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: return new YearMonthDay(year' 3' dayOfYear - (30 + 29 + 30 + 30 + 29));
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: dayOfYear < 31 + 29 + 30 + 30 + 29 + 30
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: dayOfYear < 31 + 29 + 30 + 30 + 29 + 30
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: dayOfYear < 31 + 29 + 30 + 30 + 29 + 30
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: dayOfYear < 31 + 29 + 30 + 30 + 29 + 30
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: dayOfYear < 31 + 29 + 30 + 30 + 29 + 30
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: dayOfYear < 31 + 29 + 30 + 30 + 29 + 30
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: return new YearMonthDay(year' 4' dayOfYear - (30 + 29 + 30 + 30 + 29 + 30));
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: return new YearMonthDay(year' 4' dayOfYear - (30 + 29 + 30 + 30 + 29 + 30));
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: return new YearMonthDay(year' 4' dayOfYear - (30 + 29 + 30 + 30 + 29 + 30));
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: return new YearMonthDay(year' 4' dayOfYear - (30 + 29 + 30 + 30 + 29 + 30));
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: return new YearMonthDay(year' 4' dayOfYear - (30 + 29 + 30 + 30 + 29 + 30));
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: return new YearMonthDay(year' 4' dayOfYear - (30 + 29 + 30 + 30 + 29 + 30));
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: return new YearMonthDay(year' 4' dayOfYear - (30 + 29 + 30 + 30 + 29 + 30));
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: dayOfYear < 31 + 29 + 30 + 30 + 29 + 30 + 29
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: dayOfYear < 31 + 29 + 30 + 30 + 29 + 30 + 29
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: dayOfYear < 31 + 29 + 30 + 30 + 29 + 30 + 29
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: dayOfYear < 31 + 29 + 30 + 30 + 29 + 30 + 29
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: dayOfYear < 31 + 29 + 30 + 30 + 29 + 30 + 29
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: dayOfYear < 31 + 29 + 30 + 30 + 29 + 30 + 29
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: dayOfYear < 31 + 29 + 30 + 30 + 29 + 30 + 29
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: return new YearMonthDay(year' 5' dayOfYear - (30 + 29 + 30 + 30 + 29 + 30 + 29));
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: return new YearMonthDay(year' 5' dayOfYear - (30 + 29 + 30 + 30 + 29 + 30 + 29));
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: return new YearMonthDay(year' 5' dayOfYear - (30 + 29 + 30 + 30 + 29 + 30 + 29));
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: return new YearMonthDay(year' 5' dayOfYear - (30 + 29 + 30 + 30 + 29 + 30 + 29));
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: return new YearMonthDay(year' 5' dayOfYear - (30 + 29 + 30 + 30 + 29 + 30 + 29));
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: return new YearMonthDay(year' 5' dayOfYear - (30 + 29 + 30 + 30 + 29 + 30 + 29));
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: return new YearMonthDay(year' 5' dayOfYear - (30 + 29 + 30 + 30 + 29 + 30 + 29));
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: return new YearMonthDay(year' 5' dayOfYear - (30 + 29 + 30 + 30 + 29 + 30 + 29));
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: dayOfYear < 31 + 29 + 30 + 30 + 29 + 30 + 29 + 30
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: dayOfYear < 31 + 29 + 30 + 30 + 29 + 30 + 29 + 30
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: dayOfYear < 31 + 29 + 30 + 30 + 29 + 30 + 29 + 30
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: dayOfYear < 31 + 29 + 30 + 30 + 29 + 30 + 29 + 30
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: dayOfYear < 31 + 29 + 30 + 30 + 29 + 30 + 29 + 30
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: dayOfYear < 31 + 29 + 30 + 30 + 29 + 30 + 29 + 30
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: dayOfYear < 31 + 29 + 30 + 30 + 29 + 30 + 29 + 30
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: dayOfYear < 31 + 29 + 30 + 30 + 29 + 30 + 29 + 30
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: return new YearMonthDay(year' 6' dayOfYear - (30 + 29 + 30 + 30 + 29 + 30 + 29 + 30));
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: return new YearMonthDay(year' 6' dayOfYear - (30 + 29 + 30 + 30 + 29 + 30 + 29 + 30));
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: return new YearMonthDay(year' 6' dayOfYear - (30 + 29 + 30 + 30 + 29 + 30 + 29 + 30));
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: return new YearMonthDay(year' 6' dayOfYear - (30 + 29 + 30 + 30 + 29 + 30 + 29 + 30));
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: return new YearMonthDay(year' 6' dayOfYear - (30 + 29 + 30 + 30 + 29 + 30 + 29 + 30));
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: return new YearMonthDay(year' 6' dayOfYear - (30 + 29 + 30 + 30 + 29 + 30 + 29 + 30));
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: return new YearMonthDay(year' 6' dayOfYear - (30 + 29 + 30 + 30 + 29 + 30 + 29 + 30));
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: return new YearMonthDay(year' 6' dayOfYear - (30 + 29 + 30 + 30 + 29 + 30 + 29 + 30));
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetYearMonthDay,The following statement contains a magic number: return new YearMonthDay(year' 6' dayOfYear - (30 + 29 + 30 + 30 + 29 + 30 + 29 + 30));
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetDaysFromStartOfYearToStartOfMonth,The following statement contains a magic number: int heshvanLength = (cache & IsHeshvanLongCacheBit) != 0 ? 30 : 29;
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetDaysFromStartOfYearToStartOfMonth,The following statement contains a magic number: int heshvanLength = (cache & IsHeshvanLongCacheBit) != 0 ? 30 : 29;
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetDaysFromStartOfYearToStartOfMonth,The following statement contains a magic number: int kislevLength = (cache & IsKislevShortCacheBit) != 0 ? 29 : 30;
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetDaysFromStartOfYearToStartOfMonth,The following statement contains a magic number: int kislevLength = (cache & IsKislevShortCacheBit) != 0 ? 29 : 30;
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetDaysFromStartOfYearToStartOfMonth,The following statement contains a magic number: int firstAdarLength = isLeap ? 30 : 29;
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetDaysFromStartOfYearToStartOfMonth,The following statement contains a magic number: int firstAdarLength = isLeap ? 30 : 29;
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetDaysFromStartOfYearToStartOfMonth,The following statement contains a magic number: int secondAdarLength = isLeap ? 29 : 0;
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetDaysFromStartOfYearToStartOfMonth,The following statement contains a magic number: return month switch                  {                      // Note: this could be made slightly faster (at least in terms of the apparent IL) by                      // putting all the additions of compile-time constants in one place. Indeed' we could                      // go further by only using isLeap at most once per case. However' this code is clearer                      // and there's no evidence that this is a bottleneck.                      // Nisan                      1 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength'                      // Iyar                      2 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + 30'                      // Sivan                      3 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29)'                      // Tamuz                      4 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30)'                      // Av                      5 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29)'                      // Elul                      6 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29 + 30)'                      // Tishri                      7 => 0'                      // Heshvan                      8 => 30'                      // Kislev                      9 => 30 + heshvanLength'                      // Tevet                      10 => 30 + heshvanLength + kislevLength'                      // Shevat                      11 => 30 + heshvanLength + kislevLength + 29'                      // Adar / Adar I                      12 => 30 + heshvanLength + kislevLength + 29 + 30'                      // Adar II                      13 => 30 + heshvanLength + kislevLength + 29 + 30 + firstAdarLength'                      // TODO: It would be nice for this to be simple via Preconditions                      _ => throw new ArgumentOutOfRangeException(nameof(month)' month' $"Value should be in range [1-13]")                  };
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetDaysFromStartOfYearToStartOfMonth,The following statement contains a magic number: return month switch                  {                      // Note: this could be made slightly faster (at least in terms of the apparent IL) by                      // putting all the additions of compile-time constants in one place. Indeed' we could                      // go further by only using isLeap at most once per case. However' this code is clearer                      // and there's no evidence that this is a bottleneck.                      // Nisan                      1 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength'                      // Iyar                      2 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + 30'                      // Sivan                      3 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29)'                      // Tamuz                      4 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30)'                      // Av                      5 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29)'                      // Elul                      6 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29 + 30)'                      // Tishri                      7 => 0'                      // Heshvan                      8 => 30'                      // Kislev                      9 => 30 + heshvanLength'                      // Tevet                      10 => 30 + heshvanLength + kislevLength'                      // Shevat                      11 => 30 + heshvanLength + kislevLength + 29'                      // Adar / Adar I                      12 => 30 + heshvanLength + kislevLength + 29 + 30'                      // Adar II                      13 => 30 + heshvanLength + kislevLength + 29 + 30 + firstAdarLength'                      // TODO: It would be nice for this to be simple via Preconditions                      _ => throw new ArgumentOutOfRangeException(nameof(month)' month' $"Value should be in range [1-13]")                  };
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetDaysFromStartOfYearToStartOfMonth,The following statement contains a magic number: return month switch                  {                      // Note: this could be made slightly faster (at least in terms of the apparent IL) by                      // putting all the additions of compile-time constants in one place. Indeed' we could                      // go further by only using isLeap at most once per case. However' this code is clearer                      // and there's no evidence that this is a bottleneck.                      // Nisan                      1 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength'                      // Iyar                      2 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + 30'                      // Sivan                      3 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29)'                      // Tamuz                      4 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30)'                      // Av                      5 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29)'                      // Elul                      6 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29 + 30)'                      // Tishri                      7 => 0'                      // Heshvan                      8 => 30'                      // Kislev                      9 => 30 + heshvanLength'                      // Tevet                      10 => 30 + heshvanLength + kislevLength'                      // Shevat                      11 => 30 + heshvanLength + kislevLength + 29'                      // Adar / Adar I                      12 => 30 + heshvanLength + kislevLength + 29 + 30'                      // Adar II                      13 => 30 + heshvanLength + kislevLength + 29 + 30 + firstAdarLength'                      // TODO: It would be nice for this to be simple via Preconditions                      _ => throw new ArgumentOutOfRangeException(nameof(month)' month' $"Value should be in range [1-13]")                  };
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetDaysFromStartOfYearToStartOfMonth,The following statement contains a magic number: return month switch                  {                      // Note: this could be made slightly faster (at least in terms of the apparent IL) by                      // putting all the additions of compile-time constants in one place. Indeed' we could                      // go further by only using isLeap at most once per case. However' this code is clearer                      // and there's no evidence that this is a bottleneck.                      // Nisan                      1 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength'                      // Iyar                      2 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + 30'                      // Sivan                      3 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29)'                      // Tamuz                      4 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30)'                      // Av                      5 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29)'                      // Elul                      6 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29 + 30)'                      // Tishri                      7 => 0'                      // Heshvan                      8 => 30'                      // Kislev                      9 => 30 + heshvanLength'                      // Tevet                      10 => 30 + heshvanLength + kislevLength'                      // Shevat                      11 => 30 + heshvanLength + kislevLength + 29'                      // Adar / Adar I                      12 => 30 + heshvanLength + kislevLength + 29 + 30'                      // Adar II                      13 => 30 + heshvanLength + kislevLength + 29 + 30 + firstAdarLength'                      // TODO: It would be nice for this to be simple via Preconditions                      _ => throw new ArgumentOutOfRangeException(nameof(month)' month' $"Value should be in range [1-13]")                  };
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetDaysFromStartOfYearToStartOfMonth,The following statement contains a magic number: return month switch                  {                      // Note: this could be made slightly faster (at least in terms of the apparent IL) by                      // putting all the additions of compile-time constants in one place. Indeed' we could                      // go further by only using isLeap at most once per case. However' this code is clearer                      // and there's no evidence that this is a bottleneck.                      // Nisan                      1 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength'                      // Iyar                      2 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + 30'                      // Sivan                      3 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29)'                      // Tamuz                      4 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30)'                      // Av                      5 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29)'                      // Elul                      6 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29 + 30)'                      // Tishri                      7 => 0'                      // Heshvan                      8 => 30'                      // Kislev                      9 => 30 + heshvanLength'                      // Tevet                      10 => 30 + heshvanLength + kislevLength'                      // Shevat                      11 => 30 + heshvanLength + kislevLength + 29'                      // Adar / Adar I                      12 => 30 + heshvanLength + kislevLength + 29 + 30'                      // Adar II                      13 => 30 + heshvanLength + kislevLength + 29 + 30 + firstAdarLength'                      // TODO: It would be nice for this to be simple via Preconditions                      _ => throw new ArgumentOutOfRangeException(nameof(month)' month' $"Value should be in range [1-13]")                  };
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetDaysFromStartOfYearToStartOfMonth,The following statement contains a magic number: return month switch                  {                      // Note: this could be made slightly faster (at least in terms of the apparent IL) by                      // putting all the additions of compile-time constants in one place. Indeed' we could                      // go further by only using isLeap at most once per case. However' this code is clearer                      // and there's no evidence that this is a bottleneck.                      // Nisan                      1 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength'                      // Iyar                      2 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + 30'                      // Sivan                      3 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29)'                      // Tamuz                      4 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30)'                      // Av                      5 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29)'                      // Elul                      6 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29 + 30)'                      // Tishri                      7 => 0'                      // Heshvan                      8 => 30'                      // Kislev                      9 => 30 + heshvanLength'                      // Tevet                      10 => 30 + heshvanLength + kislevLength'                      // Shevat                      11 => 30 + heshvanLength + kislevLength + 29'                      // Adar / Adar I                      12 => 30 + heshvanLength + kislevLength + 29 + 30'                      // Adar II                      13 => 30 + heshvanLength + kislevLength + 29 + 30 + firstAdarLength'                      // TODO: It would be nice for this to be simple via Preconditions                      _ => throw new ArgumentOutOfRangeException(nameof(month)' month' $"Value should be in range [1-13]")                  };
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetDaysFromStartOfYearToStartOfMonth,The following statement contains a magic number: return month switch                  {                      // Note: this could be made slightly faster (at least in terms of the apparent IL) by                      // putting all the additions of compile-time constants in one place. Indeed' we could                      // go further by only using isLeap at most once per case. However' this code is clearer                      // and there's no evidence that this is a bottleneck.                      // Nisan                      1 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength'                      // Iyar                      2 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + 30'                      // Sivan                      3 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29)'                      // Tamuz                      4 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30)'                      // Av                      5 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29)'                      // Elul                      6 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29 + 30)'                      // Tishri                      7 => 0'                      // Heshvan                      8 => 30'                      // Kislev                      9 => 30 + heshvanLength'                      // Tevet                      10 => 30 + heshvanLength + kislevLength'                      // Shevat                      11 => 30 + heshvanLength + kislevLength + 29'                      // Adar / Adar I                      12 => 30 + heshvanLength + kislevLength + 29 + 30'                      // Adar II                      13 => 30 + heshvanLength + kislevLength + 29 + 30 + firstAdarLength'                      // TODO: It would be nice for this to be simple via Preconditions                      _ => throw new ArgumentOutOfRangeException(nameof(month)' month' $"Value should be in range [1-13]")                  };
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetDaysFromStartOfYearToStartOfMonth,The following statement contains a magic number: return month switch                  {                      // Note: this could be made slightly faster (at least in terms of the apparent IL) by                      // putting all the additions of compile-time constants in one place. Indeed' we could                      // go further by only using isLeap at most once per case. However' this code is clearer                      // and there's no evidence that this is a bottleneck.                      // Nisan                      1 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength'                      // Iyar                      2 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + 30'                      // Sivan                      3 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29)'                      // Tamuz                      4 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30)'                      // Av                      5 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29)'                      // Elul                      6 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29 + 30)'                      // Tishri                      7 => 0'                      // Heshvan                      8 => 30'                      // Kislev                      9 => 30 + heshvanLength'                      // Tevet                      10 => 30 + heshvanLength + kislevLength'                      // Shevat                      11 => 30 + heshvanLength + kislevLength + 29'                      // Adar / Adar I                      12 => 30 + heshvanLength + kislevLength + 29 + 30'                      // Adar II                      13 => 30 + heshvanLength + kislevLength + 29 + 30 + firstAdarLength'                      // TODO: It would be nice for this to be simple via Preconditions                      _ => throw new ArgumentOutOfRangeException(nameof(month)' month' $"Value should be in range [1-13]")                  };
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetDaysFromStartOfYearToStartOfMonth,The following statement contains a magic number: return month switch                  {                      // Note: this could be made slightly faster (at least in terms of the apparent IL) by                      // putting all the additions of compile-time constants in one place. Indeed' we could                      // go further by only using isLeap at most once per case. However' this code is clearer                      // and there's no evidence that this is a bottleneck.                      // Nisan                      1 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength'                      // Iyar                      2 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + 30'                      // Sivan                      3 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29)'                      // Tamuz                      4 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30)'                      // Av                      5 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29)'                      // Elul                      6 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29 + 30)'                      // Tishri                      7 => 0'                      // Heshvan                      8 => 30'                      // Kislev                      9 => 30 + heshvanLength'                      // Tevet                      10 => 30 + heshvanLength + kislevLength'                      // Shevat                      11 => 30 + heshvanLength + kislevLength + 29'                      // Adar / Adar I                      12 => 30 + heshvanLength + kislevLength + 29 + 30'                      // Adar II                      13 => 30 + heshvanLength + kislevLength + 29 + 30 + firstAdarLength'                      // TODO: It would be nice for this to be simple via Preconditions                      _ => throw new ArgumentOutOfRangeException(nameof(month)' month' $"Value should be in range [1-13]")                  };
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetDaysFromStartOfYearToStartOfMonth,The following statement contains a magic number: return month switch                  {                      // Note: this could be made slightly faster (at least in terms of the apparent IL) by                      // putting all the additions of compile-time constants in one place. Indeed' we could                      // go further by only using isLeap at most once per case. However' this code is clearer                      // and there's no evidence that this is a bottleneck.                      // Nisan                      1 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength'                      // Iyar                      2 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + 30'                      // Sivan                      3 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29)'                      // Tamuz                      4 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30)'                      // Av                      5 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29)'                      // Elul                      6 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29 + 30)'                      // Tishri                      7 => 0'                      // Heshvan                      8 => 30'                      // Kislev                      9 => 30 + heshvanLength'                      // Tevet                      10 => 30 + heshvanLength + kislevLength'                      // Shevat                      11 => 30 + heshvanLength + kislevLength + 29'                      // Adar / Adar I                      12 => 30 + heshvanLength + kislevLength + 29 + 30'                      // Adar II                      13 => 30 + heshvanLength + kislevLength + 29 + 30 + firstAdarLength'                      // TODO: It would be nice for this to be simple via Preconditions                      _ => throw new ArgumentOutOfRangeException(nameof(month)' month' $"Value should be in range [1-13]")                  };
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetDaysFromStartOfYearToStartOfMonth,The following statement contains a magic number: return month switch                  {                      // Note: this could be made slightly faster (at least in terms of the apparent IL) by                      // putting all the additions of compile-time constants in one place. Indeed' we could                      // go further by only using isLeap at most once per case. However' this code is clearer                      // and there's no evidence that this is a bottleneck.                      // Nisan                      1 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength'                      // Iyar                      2 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + 30'                      // Sivan                      3 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29)'                      // Tamuz                      4 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30)'                      // Av                      5 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29)'                      // Elul                      6 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29 + 30)'                      // Tishri                      7 => 0'                      // Heshvan                      8 => 30'                      // Kislev                      9 => 30 + heshvanLength'                      // Tevet                      10 => 30 + heshvanLength + kislevLength'                      // Shevat                      11 => 30 + heshvanLength + kislevLength + 29'                      // Adar / Adar I                      12 => 30 + heshvanLength + kislevLength + 29 + 30'                      // Adar II                      13 => 30 + heshvanLength + kislevLength + 29 + 30 + firstAdarLength'                      // TODO: It would be nice for this to be simple via Preconditions                      _ => throw new ArgumentOutOfRangeException(nameof(month)' month' $"Value should be in range [1-13]")                  };
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetDaysFromStartOfYearToStartOfMonth,The following statement contains a magic number: return month switch                  {                      // Note: this could be made slightly faster (at least in terms of the apparent IL) by                      // putting all the additions of compile-time constants in one place. Indeed' we could                      // go further by only using isLeap at most once per case. However' this code is clearer                      // and there's no evidence that this is a bottleneck.                      // Nisan                      1 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength'                      // Iyar                      2 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + 30'                      // Sivan                      3 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29)'                      // Tamuz                      4 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30)'                      // Av                      5 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29)'                      // Elul                      6 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29 + 30)'                      // Tishri                      7 => 0'                      // Heshvan                      8 => 30'                      // Kislev                      9 => 30 + heshvanLength'                      // Tevet                      10 => 30 + heshvanLength + kislevLength'                      // Shevat                      11 => 30 + heshvanLength + kislevLength + 29'                      // Adar / Adar I                      12 => 30 + heshvanLength + kislevLength + 29 + 30'                      // Adar II                      13 => 30 + heshvanLength + kislevLength + 29 + 30 + firstAdarLength'                      // TODO: It would be nice for this to be simple via Preconditions                      _ => throw new ArgumentOutOfRangeException(nameof(month)' month' $"Value should be in range [1-13]")                  };
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetDaysFromStartOfYearToStartOfMonth,The following statement contains a magic number: return month switch                  {                      // Note: this could be made slightly faster (at least in terms of the apparent IL) by                      // putting all the additions of compile-time constants in one place. Indeed' we could                      // go further by only using isLeap at most once per case. However' this code is clearer                      // and there's no evidence that this is a bottleneck.                      // Nisan                      1 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength'                      // Iyar                      2 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + 30'                      // Sivan                      3 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29)'                      // Tamuz                      4 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30)'                      // Av                      5 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29)'                      // Elul                      6 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29 + 30)'                      // Tishri                      7 => 0'                      // Heshvan                      8 => 30'                      // Kislev                      9 => 30 + heshvanLength'                      // Tevet                      10 => 30 + heshvanLength + kislevLength'                      // Shevat                      11 => 30 + heshvanLength + kislevLength + 29'                      // Adar / Adar I                      12 => 30 + heshvanLength + kislevLength + 29 + 30'                      // Adar II                      13 => 30 + heshvanLength + kislevLength + 29 + 30 + firstAdarLength'                      // TODO: It would be nice for this to be simple via Preconditions                      _ => throw new ArgumentOutOfRangeException(nameof(month)' month' $"Value should be in range [1-13]")                  };
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetDaysFromStartOfYearToStartOfMonth,The following statement contains a magic number: return month switch                  {                      // Note: this could be made slightly faster (at least in terms of the apparent IL) by                      // putting all the additions of compile-time constants in one place. Indeed' we could                      // go further by only using isLeap at most once per case. However' this code is clearer                      // and there's no evidence that this is a bottleneck.                      // Nisan                      1 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength'                      // Iyar                      2 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + 30'                      // Sivan                      3 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29)'                      // Tamuz                      4 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30)'                      // Av                      5 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29)'                      // Elul                      6 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29 + 30)'                      // Tishri                      7 => 0'                      // Heshvan                      8 => 30'                      // Kislev                      9 => 30 + heshvanLength'                      // Tevet                      10 => 30 + heshvanLength + kislevLength'                      // Shevat                      11 => 30 + heshvanLength + kislevLength + 29'                      // Adar / Adar I                      12 => 30 + heshvanLength + kislevLength + 29 + 30'                      // Adar II                      13 => 30 + heshvanLength + kislevLength + 29 + 30 + firstAdarLength'                      // TODO: It would be nice for this to be simple via Preconditions                      _ => throw new ArgumentOutOfRangeException(nameof(month)' month' $"Value should be in range [1-13]")                  };
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetDaysFromStartOfYearToStartOfMonth,The following statement contains a magic number: return month switch                  {                      // Note: this could be made slightly faster (at least in terms of the apparent IL) by                      // putting all the additions of compile-time constants in one place. Indeed' we could                      // go further by only using isLeap at most once per case. However' this code is clearer                      // and there's no evidence that this is a bottleneck.                      // Nisan                      1 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength'                      // Iyar                      2 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + 30'                      // Sivan                      3 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29)'                      // Tamuz                      4 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30)'                      // Av                      5 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29)'                      // Elul                      6 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29 + 30)'                      // Tishri                      7 => 0'                      // Heshvan                      8 => 30'                      // Kislev                      9 => 30 + heshvanLength'                      // Tevet                      10 => 30 + heshvanLength + kislevLength'                      // Shevat                      11 => 30 + heshvanLength + kislevLength + 29'                      // Adar / Adar I                      12 => 30 + heshvanLength + kislevLength + 29 + 30'                      // Adar II                      13 => 30 + heshvanLength + kislevLength + 29 + 30 + firstAdarLength'                      // TODO: It would be nice for this to be simple via Preconditions                      _ => throw new ArgumentOutOfRangeException(nameof(month)' month' $"Value should be in range [1-13]")                  };
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetDaysFromStartOfYearToStartOfMonth,The following statement contains a magic number: return month switch                  {                      // Note: this could be made slightly faster (at least in terms of the apparent IL) by                      // putting all the additions of compile-time constants in one place. Indeed' we could                      // go further by only using isLeap at most once per case. However' this code is clearer                      // and there's no evidence that this is a bottleneck.                      // Nisan                      1 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength'                      // Iyar                      2 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + 30'                      // Sivan                      3 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29)'                      // Tamuz                      4 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30)'                      // Av                      5 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29)'                      // Elul                      6 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29 + 30)'                      // Tishri                      7 => 0'                      // Heshvan                      8 => 30'                      // Kislev                      9 => 30 + heshvanLength'                      // Tevet                      10 => 30 + heshvanLength + kislevLength'                      // Shevat                      11 => 30 + heshvanLength + kislevLength + 29'                      // Adar / Adar I                      12 => 30 + heshvanLength + kislevLength + 29 + 30'                      // Adar II                      13 => 30 + heshvanLength + kislevLength + 29 + 30 + firstAdarLength'                      // TODO: It would be nice for this to be simple via Preconditions                      _ => throw new ArgumentOutOfRangeException(nameof(month)' month' $"Value should be in range [1-13]")                  };
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetDaysFromStartOfYearToStartOfMonth,The following statement contains a magic number: return month switch                  {                      // Note: this could be made slightly faster (at least in terms of the apparent IL) by                      // putting all the additions of compile-time constants in one place. Indeed' we could                      // go further by only using isLeap at most once per case. However' this code is clearer                      // and there's no evidence that this is a bottleneck.                      // Nisan                      1 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength'                      // Iyar                      2 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + 30'                      // Sivan                      3 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29)'                      // Tamuz                      4 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30)'                      // Av                      5 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29)'                      // Elul                      6 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29 + 30)'                      // Tishri                      7 => 0'                      // Heshvan                      8 => 30'                      // Kislev                      9 => 30 + heshvanLength'                      // Tevet                      10 => 30 + heshvanLength + kislevLength'                      // Shevat                      11 => 30 + heshvanLength + kislevLength + 29'                      // Adar / Adar I                      12 => 30 + heshvanLength + kislevLength + 29 + 30'                      // Adar II                      13 => 30 + heshvanLength + kislevLength + 29 + 30 + firstAdarLength'                      // TODO: It would be nice for this to be simple via Preconditions                      _ => throw new ArgumentOutOfRangeException(nameof(month)' month' $"Value should be in range [1-13]")                  };
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetDaysFromStartOfYearToStartOfMonth,The following statement contains a magic number: return month switch                  {                      // Note: this could be made slightly faster (at least in terms of the apparent IL) by                      // putting all the additions of compile-time constants in one place. Indeed' we could                      // go further by only using isLeap at most once per case. However' this code is clearer                      // and there's no evidence that this is a bottleneck.                      // Nisan                      1 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength'                      // Iyar                      2 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + 30'                      // Sivan                      3 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29)'                      // Tamuz                      4 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30)'                      // Av                      5 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29)'                      // Elul                      6 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29 + 30)'                      // Tishri                      7 => 0'                      // Heshvan                      8 => 30'                      // Kislev                      9 => 30 + heshvanLength'                      // Tevet                      10 => 30 + heshvanLength + kislevLength'                      // Shevat                      11 => 30 + heshvanLength + kislevLength + 29'                      // Adar / Adar I                      12 => 30 + heshvanLength + kislevLength + 29 + 30'                      // Adar II                      13 => 30 + heshvanLength + kislevLength + 29 + 30 + firstAdarLength'                      // TODO: It would be nice for this to be simple via Preconditions                      _ => throw new ArgumentOutOfRangeException(nameof(month)' month' $"Value should be in range [1-13]")                  };
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetDaysFromStartOfYearToStartOfMonth,The following statement contains a magic number: return month switch                  {                      // Note: this could be made slightly faster (at least in terms of the apparent IL) by                      // putting all the additions of compile-time constants in one place. Indeed' we could                      // go further by only using isLeap at most once per case. However' this code is clearer                      // and there's no evidence that this is a bottleneck.                      // Nisan                      1 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength'                      // Iyar                      2 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + 30'                      // Sivan                      3 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29)'                      // Tamuz                      4 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30)'                      // Av                      5 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29)'                      // Elul                      6 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29 + 30)'                      // Tishri                      7 => 0'                      // Heshvan                      8 => 30'                      // Kislev                      9 => 30 + heshvanLength'                      // Tevet                      10 => 30 + heshvanLength + kislevLength'                      // Shevat                      11 => 30 + heshvanLength + kislevLength + 29'                      // Adar / Adar I                      12 => 30 + heshvanLength + kislevLength + 29 + 30'                      // Adar II                      13 => 30 + heshvanLength + kislevLength + 29 + 30 + firstAdarLength'                      // TODO: It would be nice for this to be simple via Preconditions                      _ => throw new ArgumentOutOfRangeException(nameof(month)' month' $"Value should be in range [1-13]")                  };
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetDaysFromStartOfYearToStartOfMonth,The following statement contains a magic number: return month switch                  {                      // Note: this could be made slightly faster (at least in terms of the apparent IL) by                      // putting all the additions of compile-time constants in one place. Indeed' we could                      // go further by only using isLeap at most once per case. However' this code is clearer                      // and there's no evidence that this is a bottleneck.                      // Nisan                      1 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength'                      // Iyar                      2 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + 30'                      // Sivan                      3 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29)'                      // Tamuz                      4 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30)'                      // Av                      5 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29)'                      // Elul                      6 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29 + 30)'                      // Tishri                      7 => 0'                      // Heshvan                      8 => 30'                      // Kislev                      9 => 30 + heshvanLength'                      // Tevet                      10 => 30 + heshvanLength + kislevLength'                      // Shevat                      11 => 30 + heshvanLength + kislevLength + 29'                      // Adar / Adar I                      12 => 30 + heshvanLength + kislevLength + 29 + 30'                      // Adar II                      13 => 30 + heshvanLength + kislevLength + 29 + 30 + firstAdarLength'                      // TODO: It would be nice for this to be simple via Preconditions                      _ => throw new ArgumentOutOfRangeException(nameof(month)' month' $"Value should be in range [1-13]")                  };
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetDaysFromStartOfYearToStartOfMonth,The following statement contains a magic number: return month switch                  {                      // Note: this could be made slightly faster (at least in terms of the apparent IL) by                      // putting all the additions of compile-time constants in one place. Indeed' we could                      // go further by only using isLeap at most once per case. However' this code is clearer                      // and there's no evidence that this is a bottleneck.                      // Nisan                      1 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength'                      // Iyar                      2 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + 30'                      // Sivan                      3 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29)'                      // Tamuz                      4 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30)'                      // Av                      5 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29)'                      // Elul                      6 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29 + 30)'                      // Tishri                      7 => 0'                      // Heshvan                      8 => 30'                      // Kislev                      9 => 30 + heshvanLength'                      // Tevet                      10 => 30 + heshvanLength + kislevLength'                      // Shevat                      11 => 30 + heshvanLength + kislevLength + 29'                      // Adar / Adar I                      12 => 30 + heshvanLength + kislevLength + 29 + 30'                      // Adar II                      13 => 30 + heshvanLength + kislevLength + 29 + 30 + firstAdarLength'                      // TODO: It would be nice for this to be simple via Preconditions                      _ => throw new ArgumentOutOfRangeException(nameof(month)' month' $"Value should be in range [1-13]")                  };
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetDaysFromStartOfYearToStartOfMonth,The following statement contains a magic number: return month switch                  {                      // Note: this could be made slightly faster (at least in terms of the apparent IL) by                      // putting all the additions of compile-time constants in one place. Indeed' we could                      // go further by only using isLeap at most once per case. However' this code is clearer                      // and there's no evidence that this is a bottleneck.                      // Nisan                      1 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength'                      // Iyar                      2 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + 30'                      // Sivan                      3 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29)'                      // Tamuz                      4 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30)'                      // Av                      5 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29)'                      // Elul                      6 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29 + 30)'                      // Tishri                      7 => 0'                      // Heshvan                      8 => 30'                      // Kislev                      9 => 30 + heshvanLength'                      // Tevet                      10 => 30 + heshvanLength + kislevLength'                      // Shevat                      11 => 30 + heshvanLength + kislevLength + 29'                      // Adar / Adar I                      12 => 30 + heshvanLength + kislevLength + 29 + 30'                      // Adar II                      13 => 30 + heshvanLength + kislevLength + 29 + 30 + firstAdarLength'                      // TODO: It would be nice for this to be simple via Preconditions                      _ => throw new ArgumentOutOfRangeException(nameof(month)' month' $"Value should be in range [1-13]")                  };
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetDaysFromStartOfYearToStartOfMonth,The following statement contains a magic number: return month switch                  {                      // Note: this could be made slightly faster (at least in terms of the apparent IL) by                      // putting all the additions of compile-time constants in one place. Indeed' we could                      // go further by only using isLeap at most once per case. However' this code is clearer                      // and there's no evidence that this is a bottleneck.                      // Nisan                      1 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength'                      // Iyar                      2 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + 30'                      // Sivan                      3 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29)'                      // Tamuz                      4 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30)'                      // Av                      5 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29)'                      // Elul                      6 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29 + 30)'                      // Tishri                      7 => 0'                      // Heshvan                      8 => 30'                      // Kislev                      9 => 30 + heshvanLength'                      // Tevet                      10 => 30 + heshvanLength + kislevLength'                      // Shevat                      11 => 30 + heshvanLength + kislevLength + 29'                      // Adar / Adar I                      12 => 30 + heshvanLength + kislevLength + 29 + 30'                      // Adar II                      13 => 30 + heshvanLength + kislevLength + 29 + 30 + firstAdarLength'                      // TODO: It would be nice for this to be simple via Preconditions                      _ => throw new ArgumentOutOfRangeException(nameof(month)' month' $"Value should be in range [1-13]")                  };
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetDaysFromStartOfYearToStartOfMonth,The following statement contains a magic number: return month switch                  {                      // Note: this could be made slightly faster (at least in terms of the apparent IL) by                      // putting all the additions of compile-time constants in one place. Indeed' we could                      // go further by only using isLeap at most once per case. However' this code is clearer                      // and there's no evidence that this is a bottleneck.                      // Nisan                      1 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength'                      // Iyar                      2 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + 30'                      // Sivan                      3 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29)'                      // Tamuz                      4 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30)'                      // Av                      5 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29)'                      // Elul                      6 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29 + 30)'                      // Tishri                      7 => 0'                      // Heshvan                      8 => 30'                      // Kislev                      9 => 30 + heshvanLength'                      // Tevet                      10 => 30 + heshvanLength + kislevLength'                      // Shevat                      11 => 30 + heshvanLength + kislevLength + 29'                      // Adar / Adar I                      12 => 30 + heshvanLength + kislevLength + 29 + 30'                      // Adar II                      13 => 30 + heshvanLength + kislevLength + 29 + 30 + firstAdarLength'                      // TODO: It would be nice for this to be simple via Preconditions                      _ => throw new ArgumentOutOfRangeException(nameof(month)' month' $"Value should be in range [1-13]")                  };
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetDaysFromStartOfYearToStartOfMonth,The following statement contains a magic number: return month switch                  {                      // Note: this could be made slightly faster (at least in terms of the apparent IL) by                      // putting all the additions of compile-time constants in one place. Indeed' we could                      // go further by only using isLeap at most once per case. However' this code is clearer                      // and there's no evidence that this is a bottleneck.                      // Nisan                      1 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength'                      // Iyar                      2 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + 30'                      // Sivan                      3 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29)'                      // Tamuz                      4 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30)'                      // Av                      5 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29)'                      // Elul                      6 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29 + 30)'                      // Tishri                      7 => 0'                      // Heshvan                      8 => 30'                      // Kislev                      9 => 30 + heshvanLength'                      // Tevet                      10 => 30 + heshvanLength + kislevLength'                      // Shevat                      11 => 30 + heshvanLength + kislevLength + 29'                      // Adar / Adar I                      12 => 30 + heshvanLength + kislevLength + 29 + 30'                      // Adar II                      13 => 30 + heshvanLength + kislevLength + 29 + 30 + firstAdarLength'                      // TODO: It would be nice for this to be simple via Preconditions                      _ => throw new ArgumentOutOfRangeException(nameof(month)' month' $"Value should be in range [1-13]")                  };
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetDaysFromStartOfYearToStartOfMonth,The following statement contains a magic number: return month switch                  {                      // Note: this could be made slightly faster (at least in terms of the apparent IL) by                      // putting all the additions of compile-time constants in one place. Indeed' we could                      // go further by only using isLeap at most once per case. However' this code is clearer                      // and there's no evidence that this is a bottleneck.                      // Nisan                      1 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength'                      // Iyar                      2 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + 30'                      // Sivan                      3 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29)'                      // Tamuz                      4 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30)'                      // Av                      5 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29)'                      // Elul                      6 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29 + 30)'                      // Tishri                      7 => 0'                      // Heshvan                      8 => 30'                      // Kislev                      9 => 30 + heshvanLength'                      // Tevet                      10 => 30 + heshvanLength + kislevLength'                      // Shevat                      11 => 30 + heshvanLength + kislevLength + 29'                      // Adar / Adar I                      12 => 30 + heshvanLength + kislevLength + 29 + 30'                      // Adar II                      13 => 30 + heshvanLength + kislevLength + 29 + 30 + firstAdarLength'                      // TODO: It would be nice for this to be simple via Preconditions                      _ => throw new ArgumentOutOfRangeException(nameof(month)' month' $"Value should be in range [1-13]")                  };
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetDaysFromStartOfYearToStartOfMonth,The following statement contains a magic number: return month switch                  {                      // Note: this could be made slightly faster (at least in terms of the apparent IL) by                      // putting all the additions of compile-time constants in one place. Indeed' we could                      // go further by only using isLeap at most once per case. However' this code is clearer                      // and there's no evidence that this is a bottleneck.                      // Nisan                      1 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength'                      // Iyar                      2 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + 30'                      // Sivan                      3 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29)'                      // Tamuz                      4 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30)'                      // Av                      5 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29)'                      // Elul                      6 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29 + 30)'                      // Tishri                      7 => 0'                      // Heshvan                      8 => 30'                      // Kislev                      9 => 30 + heshvanLength'                      // Tevet                      10 => 30 + heshvanLength + kislevLength'                      // Shevat                      11 => 30 + heshvanLength + kislevLength + 29'                      // Adar / Adar I                      12 => 30 + heshvanLength + kislevLength + 29 + 30'                      // Adar II                      13 => 30 + heshvanLength + kislevLength + 29 + 30 + firstAdarLength'                      // TODO: It would be nice for this to be simple via Preconditions                      _ => throw new ArgumentOutOfRangeException(nameof(month)' month' $"Value should be in range [1-13]")                  };
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetDaysFromStartOfYearToStartOfMonth,The following statement contains a magic number: return month switch                  {                      // Note: this could be made slightly faster (at least in terms of the apparent IL) by                      // putting all the additions of compile-time constants in one place. Indeed' we could                      // go further by only using isLeap at most once per case. However' this code is clearer                      // and there's no evidence that this is a bottleneck.                      // Nisan                      1 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength'                      // Iyar                      2 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + 30'                      // Sivan                      3 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29)'                      // Tamuz                      4 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30)'                      // Av                      5 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29)'                      // Elul                      6 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29 + 30)'                      // Tishri                      7 => 0'                      // Heshvan                      8 => 30'                      // Kislev                      9 => 30 + heshvanLength'                      // Tevet                      10 => 30 + heshvanLength + kislevLength'                      // Shevat                      11 => 30 + heshvanLength + kislevLength + 29'                      // Adar / Adar I                      12 => 30 + heshvanLength + kislevLength + 29 + 30'                      // Adar II                      13 => 30 + heshvanLength + kislevLength + 29 + 30 + firstAdarLength'                      // TODO: It would be nice for this to be simple via Preconditions                      _ => throw new ArgumentOutOfRangeException(nameof(month)' month' $"Value should be in range [1-13]")                  };
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetDaysFromStartOfYearToStartOfMonth,The following statement contains a magic number: return month switch                  {                      // Note: this could be made slightly faster (at least in terms of the apparent IL) by                      // putting all the additions of compile-time constants in one place. Indeed' we could                      // go further by only using isLeap at most once per case. However' this code is clearer                      // and there's no evidence that this is a bottleneck.                      // Nisan                      1 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength'                      // Iyar                      2 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + 30'                      // Sivan                      3 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29)'                      // Tamuz                      4 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30)'                      // Av                      5 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29)'                      // Elul                      6 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29 + 30)'                      // Tishri                      7 => 0'                      // Heshvan                      8 => 30'                      // Kislev                      9 => 30 + heshvanLength'                      // Tevet                      10 => 30 + heshvanLength + kislevLength'                      // Shevat                      11 => 30 + heshvanLength + kislevLength + 29'                      // Adar / Adar I                      12 => 30 + heshvanLength + kislevLength + 29 + 30'                      // Adar II                      13 => 30 + heshvanLength + kislevLength + 29 + 30 + firstAdarLength'                      // TODO: It would be nice for this to be simple via Preconditions                      _ => throw new ArgumentOutOfRangeException(nameof(month)' month' $"Value should be in range [1-13]")                  };
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetDaysFromStartOfYearToStartOfMonth,The following statement contains a magic number: return month switch                  {                      // Note: this could be made slightly faster (at least in terms of the apparent IL) by                      // putting all the additions of compile-time constants in one place. Indeed' we could                      // go further by only using isLeap at most once per case. However' this code is clearer                      // and there's no evidence that this is a bottleneck.                      // Nisan                      1 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength'                      // Iyar                      2 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + 30'                      // Sivan                      3 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29)'                      // Tamuz                      4 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30)'                      // Av                      5 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29)'                      // Elul                      6 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29 + 30)'                      // Tishri                      7 => 0'                      // Heshvan                      8 => 30'                      // Kislev                      9 => 30 + heshvanLength'                      // Tevet                      10 => 30 + heshvanLength + kislevLength'                      // Shevat                      11 => 30 + heshvanLength + kislevLength + 29'                      // Adar / Adar I                      12 => 30 + heshvanLength + kislevLength + 29 + 30'                      // Adar II                      13 => 30 + heshvanLength + kislevLength + 29 + 30 + firstAdarLength'                      // TODO: It would be nice for this to be simple via Preconditions                      _ => throw new ArgumentOutOfRangeException(nameof(month)' month' $"Value should be in range [1-13]")                  };
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetDaysFromStartOfYearToStartOfMonth,The following statement contains a magic number: return month switch                  {                      // Note: this could be made slightly faster (at least in terms of the apparent IL) by                      // putting all the additions of compile-time constants in one place. Indeed' we could                      // go further by only using isLeap at most once per case. However' this code is clearer                      // and there's no evidence that this is a bottleneck.                      // Nisan                      1 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength'                      // Iyar                      2 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + 30'                      // Sivan                      3 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29)'                      // Tamuz                      4 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30)'                      // Av                      5 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29)'                      // Elul                      6 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29 + 30)'                      // Tishri                      7 => 0'                      // Heshvan                      8 => 30'                      // Kislev                      9 => 30 + heshvanLength'                      // Tevet                      10 => 30 + heshvanLength + kislevLength'                      // Shevat                      11 => 30 + heshvanLength + kislevLength + 29'                      // Adar / Adar I                      12 => 30 + heshvanLength + kislevLength + 29 + 30'                      // Adar II                      13 => 30 + heshvanLength + kislevLength + 29 + 30 + firstAdarLength'                      // TODO: It would be nice for this to be simple via Preconditions                      _ => throw new ArgumentOutOfRangeException(nameof(month)' month' $"Value should be in range [1-13]")                  };
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetDaysFromStartOfYearToStartOfMonth,The following statement contains a magic number: return month switch                  {                      // Note: this could be made slightly faster (at least in terms of the apparent IL) by                      // putting all the additions of compile-time constants in one place. Indeed' we could                      // go further by only using isLeap at most once per case. However' this code is clearer                      // and there's no evidence that this is a bottleneck.                      // Nisan                      1 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength'                      // Iyar                      2 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + 30'                      // Sivan                      3 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29)'                      // Tamuz                      4 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30)'                      // Av                      5 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29)'                      // Elul                      6 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29 + 30)'                      // Tishri                      7 => 0'                      // Heshvan                      8 => 30'                      // Kislev                      9 => 30 + heshvanLength'                      // Tevet                      10 => 30 + heshvanLength + kislevLength'                      // Shevat                      11 => 30 + heshvanLength + kislevLength + 29'                      // Adar / Adar I                      12 => 30 + heshvanLength + kislevLength + 29 + 30'                      // Adar II                      13 => 30 + heshvanLength + kislevLength + 29 + 30 + firstAdarLength'                      // TODO: It would be nice for this to be simple via Preconditions                      _ => throw new ArgumentOutOfRangeException(nameof(month)' month' $"Value should be in range [1-13]")                  };
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetDaysFromStartOfYearToStartOfMonth,The following statement contains a magic number: return month switch                  {                      // Note: this could be made slightly faster (at least in terms of the apparent IL) by                      // putting all the additions of compile-time constants in one place. Indeed' we could                      // go further by only using isLeap at most once per case. However' this code is clearer                      // and there's no evidence that this is a bottleneck.                      // Nisan                      1 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength'                      // Iyar                      2 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + 30'                      // Sivan                      3 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29)'                      // Tamuz                      4 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30)'                      // Av                      5 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29)'                      // Elul                      6 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29 + 30)'                      // Tishri                      7 => 0'                      // Heshvan                      8 => 30'                      // Kislev                      9 => 30 + heshvanLength'                      // Tevet                      10 => 30 + heshvanLength + kislevLength'                      // Shevat                      11 => 30 + heshvanLength + kislevLength + 29'                      // Adar / Adar I                      12 => 30 + heshvanLength + kislevLength + 29 + 30'                      // Adar II                      13 => 30 + heshvanLength + kislevLength + 29 + 30 + firstAdarLength'                      // TODO: It would be nice for this to be simple via Preconditions                      _ => throw new ArgumentOutOfRangeException(nameof(month)' month' $"Value should be in range [1-13]")                  };
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetDaysFromStartOfYearToStartOfMonth,The following statement contains a magic number: return month switch                  {                      // Note: this could be made slightly faster (at least in terms of the apparent IL) by                      // putting all the additions of compile-time constants in one place. Indeed' we could                      // go further by only using isLeap at most once per case. However' this code is clearer                      // and there's no evidence that this is a bottleneck.                      // Nisan                      1 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength'                      // Iyar                      2 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + 30'                      // Sivan                      3 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29)'                      // Tamuz                      4 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30)'                      // Av                      5 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29)'                      // Elul                      6 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29 + 30)'                      // Tishri                      7 => 0'                      // Heshvan                      8 => 30'                      // Kislev                      9 => 30 + heshvanLength'                      // Tevet                      10 => 30 + heshvanLength + kislevLength'                      // Shevat                      11 => 30 + heshvanLength + kislevLength + 29'                      // Adar / Adar I                      12 => 30 + heshvanLength + kislevLength + 29 + 30'                      // Adar II                      13 => 30 + heshvanLength + kislevLength + 29 + 30 + firstAdarLength'                      // TODO: It would be nice for this to be simple via Preconditions                      _ => throw new ArgumentOutOfRangeException(nameof(month)' month' $"Value should be in range [1-13]")                  };
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetDaysFromStartOfYearToStartOfMonth,The following statement contains a magic number: return month switch                  {                      // Note: this could be made slightly faster (at least in terms of the apparent IL) by                      // putting all the additions of compile-time constants in one place. Indeed' we could                      // go further by only using isLeap at most once per case. However' this code is clearer                      // and there's no evidence that this is a bottleneck.                      // Nisan                      1 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength'                      // Iyar                      2 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + 30'                      // Sivan                      3 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29)'                      // Tamuz                      4 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30)'                      // Av                      5 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29)'                      // Elul                      6 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29 + 30)'                      // Tishri                      7 => 0'                      // Heshvan                      8 => 30'                      // Kislev                      9 => 30 + heshvanLength'                      // Tevet                      10 => 30 + heshvanLength + kislevLength'                      // Shevat                      11 => 30 + heshvanLength + kislevLength + 29'                      // Adar / Adar I                      12 => 30 + heshvanLength + kislevLength + 29 + 30'                      // Adar II                      13 => 30 + heshvanLength + kislevLength + 29 + 30 + firstAdarLength'                      // TODO: It would be nice for this to be simple via Preconditions                      _ => throw new ArgumentOutOfRangeException(nameof(month)' month' $"Value should be in range [1-13]")                  };
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetDaysFromStartOfYearToStartOfMonth,The following statement contains a magic number: return month switch                  {                      // Note: this could be made slightly faster (at least in terms of the apparent IL) by                      // putting all the additions of compile-time constants in one place. Indeed' we could                      // go further by only using isLeap at most once per case. However' this code is clearer                      // and there's no evidence that this is a bottleneck.                      // Nisan                      1 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength'                      // Iyar                      2 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + 30'                      // Sivan                      3 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29)'                      // Tamuz                      4 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30)'                      // Av                      5 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29)'                      // Elul                      6 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29 + 30)'                      // Tishri                      7 => 0'                      // Heshvan                      8 => 30'                      // Kislev                      9 => 30 + heshvanLength'                      // Tevet                      10 => 30 + heshvanLength + kislevLength'                      // Shevat                      11 => 30 + heshvanLength + kislevLength + 29'                      // Adar / Adar I                      12 => 30 + heshvanLength + kislevLength + 29 + 30'                      // Adar II                      13 => 30 + heshvanLength + kislevLength + 29 + 30 + firstAdarLength'                      // TODO: It would be nice for this to be simple via Preconditions                      _ => throw new ArgumentOutOfRangeException(nameof(month)' month' $"Value should be in range [1-13]")                  };
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetDaysFromStartOfYearToStartOfMonth,The following statement contains a magic number: return month switch                  {                      // Note: this could be made slightly faster (at least in terms of the apparent IL) by                      // putting all the additions of compile-time constants in one place. Indeed' we could                      // go further by only using isLeap at most once per case. However' this code is clearer                      // and there's no evidence that this is a bottleneck.                      // Nisan                      1 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength'                      // Iyar                      2 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + 30'                      // Sivan                      3 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29)'                      // Tamuz                      4 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30)'                      // Av                      5 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29)'                      // Elul                      6 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29 + 30)'                      // Tishri                      7 => 0'                      // Heshvan                      8 => 30'                      // Kislev                      9 => 30 + heshvanLength'                      // Tevet                      10 => 30 + heshvanLength + kislevLength'                      // Shevat                      11 => 30 + heshvanLength + kislevLength + 29'                      // Adar / Adar I                      12 => 30 + heshvanLength + kislevLength + 29 + 30'                      // Adar II                      13 => 30 + heshvanLength + kislevLength + 29 + 30 + firstAdarLength'                      // TODO: It would be nice for this to be simple via Preconditions                      _ => throw new ArgumentOutOfRangeException(nameof(month)' month' $"Value should be in range [1-13]")                  };
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetDaysFromStartOfYearToStartOfMonth,The following statement contains a magic number: return month switch                  {                      // Note: this could be made slightly faster (at least in terms of the apparent IL) by                      // putting all the additions of compile-time constants in one place. Indeed' we could                      // go further by only using isLeap at most once per case. However' this code is clearer                      // and there's no evidence that this is a bottleneck.                      // Nisan                      1 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength'                      // Iyar                      2 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + 30'                      // Sivan                      3 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29)'                      // Tamuz                      4 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30)'                      // Av                      5 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29)'                      // Elul                      6 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29 + 30)'                      // Tishri                      7 => 0'                      // Heshvan                      8 => 30'                      // Kislev                      9 => 30 + heshvanLength'                      // Tevet                      10 => 30 + heshvanLength + kislevLength'                      // Shevat                      11 => 30 + heshvanLength + kislevLength + 29'                      // Adar / Adar I                      12 => 30 + heshvanLength + kislevLength + 29 + 30'                      // Adar II                      13 => 30 + heshvanLength + kislevLength + 29 + 30 + firstAdarLength'                      // TODO: It would be nice for this to be simple via Preconditions                      _ => throw new ArgumentOutOfRangeException(nameof(month)' month' $"Value should be in range [1-13]")                  };
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetDaysFromStartOfYearToStartOfMonth,The following statement contains a magic number: return month switch                  {                      // Note: this could be made slightly faster (at least in terms of the apparent IL) by                      // putting all the additions of compile-time constants in one place. Indeed' we could                      // go further by only using isLeap at most once per case. However' this code is clearer                      // and there's no evidence that this is a bottleneck.                      // Nisan                      1 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength'                      // Iyar                      2 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + 30'                      // Sivan                      3 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29)'                      // Tamuz                      4 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30)'                      // Av                      5 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29)'                      // Elul                      6 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29 + 30)'                      // Tishri                      7 => 0'                      // Heshvan                      8 => 30'                      // Kislev                      9 => 30 + heshvanLength'                      // Tevet                      10 => 30 + heshvanLength + kislevLength'                      // Shevat                      11 => 30 + heshvanLength + kislevLength + 29'                      // Adar / Adar I                      12 => 30 + heshvanLength + kislevLength + 29 + 30'                      // Adar II                      13 => 30 + heshvanLength + kislevLength + 29 + 30 + firstAdarLength'                      // TODO: It would be nice for this to be simple via Preconditions                      _ => throw new ArgumentOutOfRangeException(nameof(month)' month' $"Value should be in range [1-13]")                  };
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetDaysFromStartOfYearToStartOfMonth,The following statement contains a magic number: return month switch                  {                      // Note: this could be made slightly faster (at least in terms of the apparent IL) by                      // putting all the additions of compile-time constants in one place. Indeed' we could                      // go further by only using isLeap at most once per case. However' this code is clearer                      // and there's no evidence that this is a bottleneck.                      // Nisan                      1 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength'                      // Iyar                      2 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + 30'                      // Sivan                      3 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29)'                      // Tamuz                      4 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30)'                      // Av                      5 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29)'                      // Elul                      6 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29 + 30)'                      // Tishri                      7 => 0'                      // Heshvan                      8 => 30'                      // Kislev                      9 => 30 + heshvanLength'                      // Tevet                      10 => 30 + heshvanLength + kislevLength'                      // Shevat                      11 => 30 + heshvanLength + kislevLength + 29'                      // Adar / Adar I                      12 => 30 + heshvanLength + kislevLength + 29 + 30'                      // Adar II                      13 => 30 + heshvanLength + kislevLength + 29 + 30 + firstAdarLength'                      // TODO: It would be nice for this to be simple via Preconditions                      _ => throw new ArgumentOutOfRangeException(nameof(month)' month' $"Value should be in range [1-13]")                  };
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetDaysFromStartOfYearToStartOfMonth,The following statement contains a magic number: return month switch                  {                      // Note: this could be made slightly faster (at least in terms of the apparent IL) by                      // putting all the additions of compile-time constants in one place. Indeed' we could                      // go further by only using isLeap at most once per case. However' this code is clearer                      // and there's no evidence that this is a bottleneck.                      // Nisan                      1 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength'                      // Iyar                      2 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + 30'                      // Sivan                      3 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29)'                      // Tamuz                      4 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30)'                      // Av                      5 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29)'                      // Elul                      6 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29 + 30)'                      // Tishri                      7 => 0'                      // Heshvan                      8 => 30'                      // Kislev                      9 => 30 + heshvanLength'                      // Tevet                      10 => 30 + heshvanLength + kislevLength'                      // Shevat                      11 => 30 + heshvanLength + kislevLength + 29'                      // Adar / Adar I                      12 => 30 + heshvanLength + kislevLength + 29 + 30'                      // Adar II                      13 => 30 + heshvanLength + kislevLength + 29 + 30 + firstAdarLength'                      // TODO: It would be nice for this to be simple via Preconditions                      _ => throw new ArgumentOutOfRangeException(nameof(month)' month' $"Value should be in range [1-13]")                  };
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetDaysFromStartOfYearToStartOfMonth,The following statement contains a magic number: return month switch                  {                      // Note: this could be made slightly faster (at least in terms of the apparent IL) by                      // putting all the additions of compile-time constants in one place. Indeed' we could                      // go further by only using isLeap at most once per case. However' this code is clearer                      // and there's no evidence that this is a bottleneck.                      // Nisan                      1 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength'                      // Iyar                      2 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + 30'                      // Sivan                      3 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29)'                      // Tamuz                      4 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30)'                      // Av                      5 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29)'                      // Elul                      6 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29 + 30)'                      // Tishri                      7 => 0'                      // Heshvan                      8 => 30'                      // Kislev                      9 => 30 + heshvanLength'                      // Tevet                      10 => 30 + heshvanLength + kislevLength'                      // Shevat                      11 => 30 + heshvanLength + kislevLength + 29'                      // Adar / Adar I                      12 => 30 + heshvanLength + kislevLength + 29 + 30'                      // Adar II                      13 => 30 + heshvanLength + kislevLength + 29 + 30 + firstAdarLength'                      // TODO: It would be nice for this to be simple via Preconditions                      _ => throw new ArgumentOutOfRangeException(nameof(month)' month' $"Value should be in range [1-13]")                  };
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetDaysFromStartOfYearToStartOfMonth,The following statement contains a magic number: return month switch                  {                      // Note: this could be made slightly faster (at least in terms of the apparent IL) by                      // putting all the additions of compile-time constants in one place. Indeed' we could                      // go further by only using isLeap at most once per case. However' this code is clearer                      // and there's no evidence that this is a bottleneck.                      // Nisan                      1 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength'                      // Iyar                      2 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + 30'                      // Sivan                      3 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29)'                      // Tamuz                      4 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30)'                      // Av                      5 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29)'                      // Elul                      6 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29 + 30)'                      // Tishri                      7 => 0'                      // Heshvan                      8 => 30'                      // Kislev                      9 => 30 + heshvanLength'                      // Tevet                      10 => 30 + heshvanLength + kislevLength'                      // Shevat                      11 => 30 + heshvanLength + kislevLength + 29'                      // Adar / Adar I                      12 => 30 + heshvanLength + kislevLength + 29 + 30'                      // Adar II                      13 => 30 + heshvanLength + kislevLength + 29 + 30 + firstAdarLength'                      // TODO: It would be nice for this to be simple via Preconditions                      _ => throw new ArgumentOutOfRangeException(nameof(month)' month' $"Value should be in range [1-13]")                  };
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetDaysFromStartOfYearToStartOfMonth,The following statement contains a magic number: return month switch                  {                      // Note: this could be made slightly faster (at least in terms of the apparent IL) by                      // putting all the additions of compile-time constants in one place. Indeed' we could                      // go further by only using isLeap at most once per case. However' this code is clearer                      // and there's no evidence that this is a bottleneck.                      // Nisan                      1 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength'                      // Iyar                      2 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + 30'                      // Sivan                      3 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29)'                      // Tamuz                      4 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30)'                      // Av                      5 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29)'                      // Elul                      6 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29 + 30)'                      // Tishri                      7 => 0'                      // Heshvan                      8 => 30'                      // Kislev                      9 => 30 + heshvanLength'                      // Tevet                      10 => 30 + heshvanLength + kislevLength'                      // Shevat                      11 => 30 + heshvanLength + kislevLength + 29'                      // Adar / Adar I                      12 => 30 + heshvanLength + kislevLength + 29 + 30'                      // Adar II                      13 => 30 + heshvanLength + kislevLength + 29 + 30 + firstAdarLength'                      // TODO: It would be nice for this to be simple via Preconditions                      _ => throw new ArgumentOutOfRangeException(nameof(month)' month' $"Value should be in range [1-13]")                  };
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetDaysFromStartOfYearToStartOfMonth,The following statement contains a magic number: return month switch                  {                      // Note: this could be made slightly faster (at least in terms of the apparent IL) by                      // putting all the additions of compile-time constants in one place. Indeed' we could                      // go further by only using isLeap at most once per case. However' this code is clearer                      // and there's no evidence that this is a bottleneck.                      // Nisan                      1 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength'                      // Iyar                      2 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + 30'                      // Sivan                      3 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29)'                      // Tamuz                      4 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30)'                      // Av                      5 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29)'                      // Elul                      6 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29 + 30)'                      // Tishri                      7 => 0'                      // Heshvan                      8 => 30'                      // Kislev                      9 => 30 + heshvanLength'                      // Tevet                      10 => 30 + heshvanLength + kislevLength'                      // Shevat                      11 => 30 + heshvanLength + kislevLength + 29'                      // Adar / Adar I                      12 => 30 + heshvanLength + kislevLength + 29 + 30'                      // Adar II                      13 => 30 + heshvanLength + kislevLength + 29 + 30 + firstAdarLength'                      // TODO: It would be nice for this to be simple via Preconditions                      _ => throw new ArgumentOutOfRangeException(nameof(month)' month' $"Value should be in range [1-13]")                  };
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetDaysFromStartOfYearToStartOfMonth,The following statement contains a magic number: return month switch                  {                      // Note: this could be made slightly faster (at least in terms of the apparent IL) by                      // putting all the additions of compile-time constants in one place. Indeed' we could                      // go further by only using isLeap at most once per case. However' this code is clearer                      // and there's no evidence that this is a bottleneck.                      // Nisan                      1 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength'                      // Iyar                      2 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + 30'                      // Sivan                      3 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29)'                      // Tamuz                      4 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30)'                      // Av                      5 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29)'                      // Elul                      6 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29 + 30)'                      // Tishri                      7 => 0'                      // Heshvan                      8 => 30'                      // Kislev                      9 => 30 + heshvanLength'                      // Tevet                      10 => 30 + heshvanLength + kislevLength'                      // Shevat                      11 => 30 + heshvanLength + kislevLength + 29'                      // Adar / Adar I                      12 => 30 + heshvanLength + kislevLength + 29 + 30'                      // Adar II                      13 => 30 + heshvanLength + kislevLength + 29 + 30 + firstAdarLength'                      // TODO: It would be nice for this to be simple via Preconditions                      _ => throw new ArgumentOutOfRangeException(nameof(month)' month' $"Value should be in range [1-13]")                  };
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetDaysFromStartOfYearToStartOfMonth,The following statement contains a magic number: return month switch                  {                      // Note: this could be made slightly faster (at least in terms of the apparent IL) by                      // putting all the additions of compile-time constants in one place. Indeed' we could                      // go further by only using isLeap at most once per case. However' this code is clearer                      // and there's no evidence that this is a bottleneck.                      // Nisan                      1 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength'                      // Iyar                      2 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + 30'                      // Sivan                      3 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29)'                      // Tamuz                      4 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30)'                      // Av                      5 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29)'                      // Elul                      6 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29 + 30)'                      // Tishri                      7 => 0'                      // Heshvan                      8 => 30'                      // Kislev                      9 => 30 + heshvanLength'                      // Tevet                      10 => 30 + heshvanLength + kislevLength'                      // Shevat                      11 => 30 + heshvanLength + kislevLength + 29'                      // Adar / Adar I                      12 => 30 + heshvanLength + kislevLength + 29 + 30'                      // Adar II                      13 => 30 + heshvanLength + kislevLength + 29 + 30 + firstAdarLength'                      // TODO: It would be nice for this to be simple via Preconditions                      _ => throw new ArgumentOutOfRangeException(nameof(month)' month' $"Value should be in range [1-13]")                  };
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetDaysFromStartOfYearToStartOfMonth,The following statement contains a magic number: return month switch                  {                      // Note: this could be made slightly faster (at least in terms of the apparent IL) by                      // putting all the additions of compile-time constants in one place. Indeed' we could                      // go further by only using isLeap at most once per case. However' this code is clearer                      // and there's no evidence that this is a bottleneck.                      // Nisan                      1 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength'                      // Iyar                      2 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + 30'                      // Sivan                      3 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29)'                      // Tamuz                      4 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30)'                      // Av                      5 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29)'                      // Elul                      6 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29 + 30)'                      // Tishri                      7 => 0'                      // Heshvan                      8 => 30'                      // Kislev                      9 => 30 + heshvanLength'                      // Tevet                      10 => 30 + heshvanLength + kislevLength'                      // Shevat                      11 => 30 + heshvanLength + kislevLength + 29'                      // Adar / Adar I                      12 => 30 + heshvanLength + kislevLength + 29 + 30'                      // Adar II                      13 => 30 + heshvanLength + kislevLength + 29 + 30 + firstAdarLength'                      // TODO: It would be nice for this to be simple via Preconditions                      _ => throw new ArgumentOutOfRangeException(nameof(month)' month' $"Value should be in range [1-13]")                  };
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetDaysFromStartOfYearToStartOfMonth,The following statement contains a magic number: return month switch                  {                      // Note: this could be made slightly faster (at least in terms of the apparent IL) by                      // putting all the additions of compile-time constants in one place. Indeed' we could                      // go further by only using isLeap at most once per case. However' this code is clearer                      // and there's no evidence that this is a bottleneck.                      // Nisan                      1 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength'                      // Iyar                      2 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + 30'                      // Sivan                      3 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29)'                      // Tamuz                      4 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30)'                      // Av                      5 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29)'                      // Elul                      6 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29 + 30)'                      // Tishri                      7 => 0'                      // Heshvan                      8 => 30'                      // Kislev                      9 => 30 + heshvanLength'                      // Tevet                      10 => 30 + heshvanLength + kislevLength'                      // Shevat                      11 => 30 + heshvanLength + kislevLength + 29'                      // Adar / Adar I                      12 => 30 + heshvanLength + kislevLength + 29 + 30'                      // Adar II                      13 => 30 + heshvanLength + kislevLength + 29 + 30 + firstAdarLength'                      // TODO: It would be nice for this to be simple via Preconditions                      _ => throw new ArgumentOutOfRangeException(nameof(month)' month' $"Value should be in range [1-13]")                  };
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetDaysFromStartOfYearToStartOfMonth,The following statement contains a magic number: return month switch                  {                      // Note: this could be made slightly faster (at least in terms of the apparent IL) by                      // putting all the additions of compile-time constants in one place. Indeed' we could                      // go further by only using isLeap at most once per case. However' this code is clearer                      // and there's no evidence that this is a bottleneck.                      // Nisan                      1 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength'                      // Iyar                      2 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + 30'                      // Sivan                      3 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29)'                      // Tamuz                      4 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30)'                      // Av                      5 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29)'                      // Elul                      6 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29 + 30)'                      // Tishri                      7 => 0'                      // Heshvan                      8 => 30'                      // Kislev                      9 => 30 + heshvanLength'                      // Tevet                      10 => 30 + heshvanLength + kislevLength'                      // Shevat                      11 => 30 + heshvanLength + kislevLength + 29'                      // Adar / Adar I                      12 => 30 + heshvanLength + kislevLength + 29 + 30'                      // Adar II                      13 => 30 + heshvanLength + kislevLength + 29 + 30 + firstAdarLength'                      // TODO: It would be nice for this to be simple via Preconditions                      _ => throw new ArgumentOutOfRangeException(nameof(month)' month' $"Value should be in range [1-13]")                  };
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetDaysFromStartOfYearToStartOfMonth,The following statement contains a magic number: return month switch                  {                      // Note: this could be made slightly faster (at least in terms of the apparent IL) by                      // putting all the additions of compile-time constants in one place. Indeed' we could                      // go further by only using isLeap at most once per case. However' this code is clearer                      // and there's no evidence that this is a bottleneck.                      // Nisan                      1 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength'                      // Iyar                      2 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + 30'                      // Sivan                      3 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29)'                      // Tamuz                      4 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30)'                      // Av                      5 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29)'                      // Elul                      6 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29 + 30)'                      // Tishri                      7 => 0'                      // Heshvan                      8 => 30'                      // Kislev                      9 => 30 + heshvanLength'                      // Tevet                      10 => 30 + heshvanLength + kislevLength'                      // Shevat                      11 => 30 + heshvanLength + kislevLength + 29'                      // Adar / Adar I                      12 => 30 + heshvanLength + kislevLength + 29 + 30'                      // Adar II                      13 => 30 + heshvanLength + kislevLength + 29 + 30 + firstAdarLength'                      // TODO: It would be nice for this to be simple via Preconditions                      _ => throw new ArgumentOutOfRangeException(nameof(month)' month' $"Value should be in range [1-13]")                  };
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetDaysFromStartOfYearToStartOfMonth,The following statement contains a magic number: return month switch                  {                      // Note: this could be made slightly faster (at least in terms of the apparent IL) by                      // putting all the additions of compile-time constants in one place. Indeed' we could                      // go further by only using isLeap at most once per case. However' this code is clearer                      // and there's no evidence that this is a bottleneck.                      // Nisan                      1 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength'                      // Iyar                      2 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + 30'                      // Sivan                      3 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29)'                      // Tamuz                      4 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30)'                      // Av                      5 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29)'                      // Elul                      6 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29 + 30)'                      // Tishri                      7 => 0'                      // Heshvan                      8 => 30'                      // Kislev                      9 => 30 + heshvanLength'                      // Tevet                      10 => 30 + heshvanLength + kislevLength'                      // Shevat                      11 => 30 + heshvanLength + kislevLength + 29'                      // Adar / Adar I                      12 => 30 + heshvanLength + kislevLength + 29 + 30'                      // Adar II                      13 => 30 + heshvanLength + kislevLength + 29 + 30 + firstAdarLength'                      // TODO: It would be nice for this to be simple via Preconditions                      _ => throw new ArgumentOutOfRangeException(nameof(month)' month' $"Value should be in range [1-13]")                  };
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetDaysFromStartOfYearToStartOfMonth,The following statement contains a magic number: return month switch                  {                      // Note: this could be made slightly faster (at least in terms of the apparent IL) by                      // putting all the additions of compile-time constants in one place. Indeed' we could                      // go further by only using isLeap at most once per case. However' this code is clearer                      // and there's no evidence that this is a bottleneck.                      // Nisan                      1 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength'                      // Iyar                      2 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + 30'                      // Sivan                      3 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29)'                      // Tamuz                      4 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30)'                      // Av                      5 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29)'                      // Elul                      6 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29 + 30)'                      // Tishri                      7 => 0'                      // Heshvan                      8 => 30'                      // Kislev                      9 => 30 + heshvanLength'                      // Tevet                      10 => 30 + heshvanLength + kislevLength'                      // Shevat                      11 => 30 + heshvanLength + kislevLength + 29'                      // Adar / Adar I                      12 => 30 + heshvanLength + kislevLength + 29 + 30'                      // Adar II                      13 => 30 + heshvanLength + kislevLength + 29 + 30 + firstAdarLength'                      // TODO: It would be nice for this to be simple via Preconditions                      _ => throw new ArgumentOutOfRangeException(nameof(month)' month' $"Value should be in range [1-13]")                  };
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetDaysFromStartOfYearToStartOfMonth,The following statement contains a magic number: return month switch                  {                      // Note: this could be made slightly faster (at least in terms of the apparent IL) by                      // putting all the additions of compile-time constants in one place. Indeed' we could                      // go further by only using isLeap at most once per case. However' this code is clearer                      // and there's no evidence that this is a bottleneck.                      // Nisan                      1 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength'                      // Iyar                      2 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + 30'                      // Sivan                      3 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29)'                      // Tamuz                      4 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30)'                      // Av                      5 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29)'                      // Elul                      6 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29 + 30)'                      // Tishri                      7 => 0'                      // Heshvan                      8 => 30'                      // Kislev                      9 => 30 + heshvanLength'                      // Tevet                      10 => 30 + heshvanLength + kislevLength'                      // Shevat                      11 => 30 + heshvanLength + kislevLength + 29'                      // Adar / Adar I                      12 => 30 + heshvanLength + kislevLength + 29 + 30'                      // Adar II                      13 => 30 + heshvanLength + kislevLength + 29 + 30 + firstAdarLength'                      // TODO: It would be nice for this to be simple via Preconditions                      _ => throw new ArgumentOutOfRangeException(nameof(month)' month' $"Value should be in range [1-13]")                  };
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetDaysFromStartOfYearToStartOfMonth,The following statement contains a magic number: return month switch                  {                      // Note: this could be made slightly faster (at least in terms of the apparent IL) by                      // putting all the additions of compile-time constants in one place. Indeed' we could                      // go further by only using isLeap at most once per case. However' this code is clearer                      // and there's no evidence that this is a bottleneck.                      // Nisan                      1 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength'                      // Iyar                      2 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + 30'                      // Sivan                      3 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29)'                      // Tamuz                      4 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30)'                      // Av                      5 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29)'                      // Elul                      6 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29 + 30)'                      // Tishri                      7 => 0'                      // Heshvan                      8 => 30'                      // Kislev                      9 => 30 + heshvanLength'                      // Tevet                      10 => 30 + heshvanLength + kislevLength'                      // Shevat                      11 => 30 + heshvanLength + kislevLength + 29'                      // Adar / Adar I                      12 => 30 + heshvanLength + kislevLength + 29 + 30'                      // Adar II                      13 => 30 + heshvanLength + kislevLength + 29 + 30 + firstAdarLength'                      // TODO: It would be nice for this to be simple via Preconditions                      _ => throw new ArgumentOutOfRangeException(nameof(month)' month' $"Value should be in range [1-13]")                  };
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,GetDaysFromStartOfYearToStartOfMonth,The following statement contains a magic number: return month switch                  {                      // Note: this could be made slightly faster (at least in terms of the apparent IL) by                      // putting all the additions of compile-time constants in one place. Indeed' we could                      // go further by only using isLeap at most once per case. However' this code is clearer                      // and there's no evidence that this is a bottleneck.                      // Nisan                      1 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength'                      // Iyar                      2 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + 30'                      // Sivan                      3 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29)'                      // Tamuz                      4 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30)'                      // Av                      5 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29)'                      // Elul                      6 => 30 + heshvanLength + kislevLength + (29 + 30) + firstAdarLength + secondAdarLength + (30 + 29 + 30 + 29 + 30)'                      // Tishri                      7 => 0'                      // Heshvan                      8 => 30'                      // Kislev                      9 => 30 + heshvanLength'                      // Tevet                      10 => 30 + heshvanLength + kislevLength'                      // Shevat                      11 => 30 + heshvanLength + kislevLength + 29'                      // Adar / Adar I                      12 => 30 + heshvanLength + kislevLength + 29 + 30'                      // Adar II                      13 => 30 + heshvanLength + kislevLength + 29 + 30 + firstAdarLength'                      // TODO: It would be nice for this to be simple via Preconditions                      _ => throw new ArgumentOutOfRangeException(nameof(month)' month' $"Value should be in range [1-13]")                  };
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,ElapsedDaysNoCache,The following statement contains a magic number: int monthsElapsed = (235 * ((year - 1) / 19)) // Months in complete cycles so far                                  + (12 * ((year - 1) % 19)) // Regular months in this cycle                                  + ((((year - 1) % 19) * 7 + 1) / 19);
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,ElapsedDaysNoCache,The following statement contains a magic number: int monthsElapsed = (235 * ((year - 1) / 19)) // Months in complete cycles so far                                  + (12 * ((year - 1) % 19)) // Regular months in this cycle                                  + ((((year - 1) % 19) * 7 + 1) / 19);
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,ElapsedDaysNoCache,The following statement contains a magic number: int monthsElapsed = (235 * ((year - 1) / 19)) // Months in complete cycles so far                                  + (12 * ((year - 1) % 19)) // Regular months in this cycle                                  + ((((year - 1) % 19) * 7 + 1) / 19);
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,ElapsedDaysNoCache,The following statement contains a magic number: int monthsElapsed = (235 * ((year - 1) / 19)) // Months in complete cycles so far                                  + (12 * ((year - 1) % 19)) // Regular months in this cycle                                  + ((((year - 1) % 19) * 7 + 1) / 19);
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,ElapsedDaysNoCache,The following statement contains a magic number: int monthsElapsed = (235 * ((year - 1) / 19)) // Months in complete cycles so far                                  + (12 * ((year - 1) % 19)) // Regular months in this cycle                                  + ((((year - 1) % 19) * 7 + 1) / 19);
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,ElapsedDaysNoCache,The following statement contains a magic number: int monthsElapsed = (235 * ((year - 1) / 19)) // Months in complete cycles so far                                  + (12 * ((year - 1) % 19)) // Regular months in this cycle                                  + ((((year - 1) % 19) * 7 + 1) / 19);
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,ElapsedDaysNoCache,The following statement contains a magic number: int monthsElapsed = (235 * ((year - 1) / 19)) // Months in complete cycles so far                                  + (12 * ((year - 1) % 19)) // Regular months in this cycle                                  + ((((year - 1) % 19) * 7 + 1) / 19);
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,ElapsedDaysNoCache,The following statement contains a magic number: int partsElapsed = 204 + (793 * (monthsElapsed % 1080));
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,ElapsedDaysNoCache,The following statement contains a magic number: int partsElapsed = 204 + (793 * (monthsElapsed % 1080));
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,ElapsedDaysNoCache,The following statement contains a magic number: int partsElapsed = 204 + (793 * (monthsElapsed % 1080));
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,ElapsedDaysNoCache,The following statement contains a magic number: int hoursElapsed = 5 + (12 * monthsElapsed) + (793 * (monthsElapsed / 1080)) + (partsElapsed / 1080);
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,ElapsedDaysNoCache,The following statement contains a magic number: int hoursElapsed = 5 + (12 * monthsElapsed) + (793 * (monthsElapsed / 1080)) + (partsElapsed / 1080);
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,ElapsedDaysNoCache,The following statement contains a magic number: int hoursElapsed = 5 + (12 * monthsElapsed) + (793 * (monthsElapsed / 1080)) + (partsElapsed / 1080);
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,ElapsedDaysNoCache,The following statement contains a magic number: int hoursElapsed = 5 + (12 * monthsElapsed) + (793 * (monthsElapsed / 1080)) + (partsElapsed / 1080);
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,ElapsedDaysNoCache,The following statement contains a magic number: int hoursElapsed = 5 + (12 * monthsElapsed) + (793 * (monthsElapsed / 1080)) + (partsElapsed / 1080);
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,ElapsedDaysNoCache,The following statement contains a magic number: int day = 1 + (29 * monthsElapsed) + (hoursElapsed / 24);
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,ElapsedDaysNoCache,The following statement contains a magic number: int day = 1 + (29 * monthsElapsed) + (hoursElapsed / 24);
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,ElapsedDaysNoCache,The following statement contains a magic number: int parts = ((hoursElapsed % 24) * 1080) + (partsElapsed % 1080);
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,ElapsedDaysNoCache,The following statement contains a magic number: int parts = ((hoursElapsed % 24) * 1080) + (partsElapsed % 1080);
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,ElapsedDaysNoCache,The following statement contains a magic number: int parts = ((hoursElapsed % 24) * 1080) + (partsElapsed % 1080);
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,ElapsedDaysNoCache,The following statement contains a magic number: bool postponeRoshHaShanah = (parts >= 19440) ||                                          (day % 7 == 2 && parts >= 9924 && !IsLeapYear(year)) ||                                          (day % 7 == 1 && parts >= 16789 && IsLeapYear(year - 1));
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,ElapsedDaysNoCache,The following statement contains a magic number: bool postponeRoshHaShanah = (parts >= 19440) ||                                          (day % 7 == 2 && parts >= 9924 && !IsLeapYear(year)) ||                                          (day % 7 == 1 && parts >= 16789 && IsLeapYear(year - 1));
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,ElapsedDaysNoCache,The following statement contains a magic number: bool postponeRoshHaShanah = (parts >= 19440) ||                                          (day % 7 == 2 && parts >= 9924 && !IsLeapYear(year)) ||                                          (day % 7 == 1 && parts >= 16789 && IsLeapYear(year - 1));
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,ElapsedDaysNoCache,The following statement contains a magic number: bool postponeRoshHaShanah = (parts >= 19440) ||                                          (day % 7 == 2 && parts >= 9924 && !IsLeapYear(year)) ||                                          (day % 7 == 1 && parts >= 16789 && IsLeapYear(year - 1));
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,ElapsedDaysNoCache,The following statement contains a magic number: bool postponeRoshHaShanah = (parts >= 19440) ||                                          (day % 7 == 2 && parts >= 9924 && !IsLeapYear(year)) ||                                          (day % 7 == 1 && parts >= 16789 && IsLeapYear(year - 1));
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,ElapsedDaysNoCache,The following statement contains a magic number: bool postponeRoshHaShanah = (parts >= 19440) ||                                          (day % 7 == 2 && parts >= 9924 && !IsLeapYear(year)) ||                                          (day % 7 == 1 && parts >= 16789 && IsLeapYear(year - 1));
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,ElapsedDaysNoCache,The following statement contains a magic number: int alternativeDayMod7 = alternativeDay % 7;
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,ElapsedDaysNoCache,The following statement contains a magic number: return (alternativeDayMod7 == 0 || alternativeDayMod7 == 3 || alternativeDayMod7 == 5)                  ? alternativeDay + 1 : alternativeDay;
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,ElapsedDaysNoCache,The following statement contains a magic number: return (alternativeDayMod7 == 0 || alternativeDayMod7 == 3 || alternativeDayMod7 == 5)                  ? alternativeDay + 1 : alternativeDay;
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,ComputeCacheEntry,The following statement contains a magic number: bool isHeshvanLong = daysInYear % 10 == 5;
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,ComputeCacheEntry,The following statement contains a magic number: bool isHeshvanLong = daysInYear % 10 == 5;
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,ComputeCacheEntry,The following statement contains a magic number: bool isKislevShort = daysInYear % 10 == 3;
Magic Number,NodaTime.Calendars,HebrewScripturalCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewScripturalCalculator.cs,ComputeCacheEntry,The following statement contains a magic number: bool isKislevShort = daysInYear % 10 == 3;
Magic Number,NodaTime.Calendars,HebrewYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewYearMonthDayCalculator.cs,SetYear,The following statement contains a magic number: targetScripturalMonth = 12;
Magic Number,NodaTime.Calendars,HebrewYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewYearMonthDayCalculator.cs,SetYear,The following statement contains a magic number: targetScripturalMonth == 13 && !IsLeapYear(year)
Magic Number,NodaTime.Calendars,HebrewYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewYearMonthDayCalculator.cs,SetYear,The following statement contains a magic number: targetScripturalMonth == 13
Magic Number,NodaTime.Calendars,HebrewYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewYearMonthDayCalculator.cs,SetYear,The following statement contains a magic number: HebrewScripturalCalculator.DaysInMonth(year' targetScripturalMonth) != 30
Magic Number,NodaTime.Calendars,HebrewYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewYearMonthDayCalculator.cs,SetYear,The following statement contains a magic number: targetDay == 30 && (targetScripturalMonth == 8 || targetScripturalMonth == 9 || targetScripturalMonth == 12)
Magic Number,NodaTime.Calendars,HebrewYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewYearMonthDayCalculator.cs,SetYear,The following statement contains a magic number: targetDay == 30 && (targetScripturalMonth == 8 || targetScripturalMonth == 9 || targetScripturalMonth == 12)
Magic Number,NodaTime.Calendars,HebrewYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewYearMonthDayCalculator.cs,SetYear,The following statement contains a magic number: targetDay == 30 && (targetScripturalMonth == 8 || targetScripturalMonth == 9 || targetScripturalMonth == 12)
Magic Number,NodaTime.Calendars,HebrewYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\HebrewYearMonthDayCalculator.cs,SetYear,The following statement contains a magic number: targetDay == 30 && (targetScripturalMonth == 8 || targetScripturalMonth == 9 || targetScripturalMonth == 12)
Magic Number,NodaTime.Calendars,IslamicYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\IslamicYearMonthDayCalculator.cs,IslamicYearMonthDayCalculator,The following statement contains a magic number: TotalDaysByMonth = new int[12];
Magic Number,NodaTime.Calendars,IslamicYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\IslamicYearMonthDayCalculator.cs,IslamicYearMonthDayCalculator,The following statement contains a magic number: i < 12
Magic Number,NodaTime.Calendars,IslamicYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\IslamicYearMonthDayCalculator.cs,GetYearMonthDay,The following statement contains a magic number: month = 12;
Magic Number,NodaTime.Calendars,IslamicYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\IslamicYearMonthDayCalculator.cs,GetYearMonthDay,The following statement contains a magic number: day = 30;
Magic Number,NodaTime.Calendars,IslamicYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\IslamicYearMonthDayCalculator.cs,GetDaysInMonth,The following statement contains a magic number: month == 12 && IsLeapYear(year)
Magic Number,NodaTime.Calendars,JulianYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\JulianYearMonthDayCalculator.cs,CalculateStartOfYearDays,The following statement contains a magic number: int relativeYear = year - 1968;
Magic Number,NodaTime.Calendars,JulianYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\JulianYearMonthDayCalculator.cs,CalculateStartOfYearDays,The following statement contains a magic number: leapYears = (relativeYear + 3) >> 2;
Magic Number,NodaTime.Calendars,JulianYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\JulianYearMonthDayCalculator.cs,CalculateStartOfYearDays,The following statement contains a magic number: leapYears = (relativeYear + 3) >> 2;
Magic Number,NodaTime.Calendars,JulianYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\JulianYearMonthDayCalculator.cs,CalculateStartOfYearDays,The following statement contains a magic number: return (relativeYear * 365 + leapYears - (366 + 352));
Magic Number,NodaTime.Calendars,JulianYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\JulianYearMonthDayCalculator.cs,CalculateStartOfYearDays,The following statement contains a magic number: return (relativeYear * 365 + leapYears - (366 + 352));
Magic Number,NodaTime.Calendars,JulianYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\JulianYearMonthDayCalculator.cs,CalculateStartOfYearDays,The following statement contains a magic number: return (relativeYear * 365 + leapYears - (366 + 352));
Magic Number,NodaTime.Calendars,PersianYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\PersianYearMonthDayCalculator.cs,PersianYearMonthDayCalculator,The following statement contains a magic number: TotalDaysByMonth = new int[13];
Magic Number,NodaTime.Calendars,PersianYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\PersianYearMonthDayCalculator.cs,PersianYearMonthDayCalculator,The following statement contains a magic number: int daysInMonth = i <= 6 ? 31 : 30;
Magic Number,NodaTime.Calendars,PersianYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\PersianYearMonthDayCalculator.cs,PersianYearMonthDayCalculator,The following statement contains a magic number: int daysInMonth = i <= 6 ? 31 : 30;
Magic Number,NodaTime.Calendars,PersianYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\PersianYearMonthDayCalculator.cs,PersianYearMonthDayCalculator,The following statement contains a magic number: int daysInMonth = i <= 6 ? 31 : 30;
Magic Number,NodaTime.Calendars,PersianYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\PersianYearMonthDayCalculator.cs,PersianYearMonthDayCalculator,The following statement contains a magic number: i <= 12
Magic Number,NodaTime.Calendars,PersianYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\PersianYearMonthDayCalculator.cs,PersianYearMonthDayCalculator,The following statement contains a magic number: startOfYearInDaysCache = new int[MaxYear + 2];
Magic Number,NodaTime.Calendars,PersianYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\PersianYearMonthDayCalculator.cs,GetYearMonthDay,The following statement contains a magic number: month = 12;
Magic Number,NodaTime.Calendars,PersianYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\PersianYearMonthDayCalculator.cs,GetYearMonthDay,The following statement contains a magic number: day = 30;
Magic Number,NodaTime.Calendars,Arithmetic,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\PersianYearMonthDayCalculator.cs,IsLeapYear,The following statement contains a magic number: int offsetYear = year > 0 ? year - 474 : year - 473;
Magic Number,NodaTime.Calendars,Arithmetic,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\PersianYearMonthDayCalculator.cs,IsLeapYear,The following statement contains a magic number: int offsetYear = year > 0 ? year - 474 : year - 473;
Magic Number,NodaTime.Calendars,Arithmetic,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\PersianYearMonthDayCalculator.cs,IsLeapYear,The following statement contains a magic number: int cycleYear = (offsetYear % 2820) + 474;
Magic Number,NodaTime.Calendars,Arithmetic,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\PersianYearMonthDayCalculator.cs,IsLeapYear,The following statement contains a magic number: int cycleYear = (offsetYear % 2820) + 474;
Magic Number,NodaTime.Calendars,Arithmetic,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\PersianYearMonthDayCalculator.cs,IsLeapYear,The following statement contains a magic number: return ((cycleYear + 38) * 31) % 128 < 31;
Magic Number,NodaTime.Calendars,Arithmetic,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\PersianYearMonthDayCalculator.cs,IsLeapYear,The following statement contains a magic number: return ((cycleYear + 38) * 31) % 128 < 31;
Magic Number,NodaTime.Calendars,Arithmetic,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\PersianYearMonthDayCalculator.cs,IsLeapYear,The following statement contains a magic number: return ((cycleYear + 38) * 31) % 128 < 31;
Magic Number,NodaTime.Calendars,Arithmetic,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\PersianYearMonthDayCalculator.cs,IsLeapYear,The following statement contains a magic number: return ((cycleYear + 38) * 31) % 128 < 31;
Magic Number,NodaTime.Calendars,SimpleWeekYearRule,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\SimpleWeekYearRule.cs,SimpleWeekYearRule,The following statement contains a magic number: Preconditions.DebugCheckArgumentRange(nameof(minDaysInFirstWeek)' minDaysInFirstWeek' 1' 7);
Magic Number,NodaTime.Calendars,SimpleWeekYearRule,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\SimpleWeekYearRule.cs,SimpleWeekYearRule,The following statement contains a magic number: Preconditions.CheckArgumentRange(nameof(firstDayOfWeek)' (int) firstDayOfWeek' 1' 7);
Magic Number,NodaTime.Calendars,SimpleWeekYearRule,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\SimpleWeekYearRule.cs,GetLocalDate,The following statement contains a magic number: Preconditions.CheckArgumentRange(nameof(dayOfWeek)' (int) dayOfWeek' 1' 7);
Magic Number,NodaTime.Calendars,SimpleWeekYearRule,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\SimpleWeekYearRule.cs,GetLocalDate,The following statement contains a magic number: int daysIntoWeek = ((dayOfWeek - firstDayOfWeek) + 7) % 7;
Magic Number,NodaTime.Calendars,SimpleWeekYearRule,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\SimpleWeekYearRule.cs,GetLocalDate,The following statement contains a magic number: int daysIntoWeek = ((dayOfWeek - firstDayOfWeek) + 7) % 7;
Magic Number,NodaTime.Calendars,SimpleWeekYearRule,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\SimpleWeekYearRule.cs,GetLocalDate,The following statement contains a magic number: int days = startOfWeekYear + (weekOfWeekYear - 1) * 7 + daysIntoWeek;
Magic Number,NodaTime.Calendars,SimpleWeekYearRule,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\SimpleWeekYearRule.cs,GetWeekOfWeekYear,The following statement contains a magic number: int zeroBasedWeek = zeroBasedDayOfWeekYear / 7;
Magic Number,NodaTime.Calendars,SimpleWeekYearRule,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\SimpleWeekYearRule.cs,GetWeeksInWeekYear,The following statement contains a magic number: int extraDaysAtEnd = irregularWeeks ? 6 : minDaysInFirstWeek - 1;
Magic Number,NodaTime.Calendars,SimpleWeekYearRule,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\SimpleWeekYearRule.cs,GetWeeksInWeekYear,The following statement contains a magic number: return (daysInThisYear + extraDaysAtStart + extraDaysAtEnd) / 7;
Magic Number,NodaTime.Calendars,SimpleWeekYearRule,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\SimpleWeekYearRule.cs,GetWeekYear,The following statement contains a magic number: int startOfNextWeekYear = startOfWeekYear + weeksInWeekYear * 7;
Magic Number,NodaTime.Calendars,SimpleWeekYearRule,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\SimpleWeekYearRule.cs,GetWeekYearDaysSinceEpoch,The following statement contains a magic number: int startOfYearDayOfWeek = unchecked(startOfCalendarYear >= -3 ? 1 + ((startOfCalendarYear + 3) % 7)                                             : 7 + ((startOfCalendarYear + 4) % 7));
Magic Number,NodaTime.Calendars,SimpleWeekYearRule,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\SimpleWeekYearRule.cs,GetWeekYearDaysSinceEpoch,The following statement contains a magic number: int startOfYearDayOfWeek = unchecked(startOfCalendarYear >= -3 ? 1 + ((startOfCalendarYear + 3) % 7)                                             : 7 + ((startOfCalendarYear + 4) % 7));
Magic Number,NodaTime.Calendars,SimpleWeekYearRule,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\SimpleWeekYearRule.cs,GetWeekYearDaysSinceEpoch,The following statement contains a magic number: int startOfYearDayOfWeek = unchecked(startOfCalendarYear >= -3 ? 1 + ((startOfCalendarYear + 3) % 7)                                             : 7 + ((startOfCalendarYear + 4) % 7));
Magic Number,NodaTime.Calendars,SimpleWeekYearRule,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\SimpleWeekYearRule.cs,GetWeekYearDaysSinceEpoch,The following statement contains a magic number: int startOfYearDayOfWeek = unchecked(startOfCalendarYear >= -3 ? 1 + ((startOfCalendarYear + 3) % 7)                                             : 7 + ((startOfCalendarYear + 4) % 7));
Magic Number,NodaTime.Calendars,SimpleWeekYearRule,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\SimpleWeekYearRule.cs,GetWeekYearDaysSinceEpoch,The following statement contains a magic number: int startOfYearDayOfWeek = unchecked(startOfCalendarYear >= -3 ? 1 + ((startOfCalendarYear + 3) % 7)                                             : 7 + ((startOfCalendarYear + 4) % 7));
Magic Number,NodaTime.Calendars,SimpleWeekYearRule,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\SimpleWeekYearRule.cs,GetWeekYearDaysSinceEpoch,The following statement contains a magic number: int startOfYearDayOfWeek = unchecked(startOfCalendarYear >= -3 ? 1 + ((startOfCalendarYear + 3) % 7)                                             : 7 + ((startOfCalendarYear + 4) % 7));
Magic Number,NodaTime.Calendars,SimpleWeekYearRule,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\SimpleWeekYearRule.cs,GetWeekYearDaysSinceEpoch,The following statement contains a magic number: int daysIntoWeek = ((startOfYearDayOfWeek - (int) firstDayOfWeek) + 7) % 7;
Magic Number,NodaTime.Calendars,SimpleWeekYearRule,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\SimpleWeekYearRule.cs,GetWeekYearDaysSinceEpoch,The following statement contains a magic number: int daysIntoWeek = ((startOfYearDayOfWeek - (int) firstDayOfWeek) + 7) % 7;
Magic Number,NodaTime.Calendars,SimpleWeekYearRule,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\SimpleWeekYearRule.cs,GetWeekYearDaysSinceEpoch,The following statement contains a magic number: bool startOfYearIsInWeek1 = (7 - daysIntoWeek >= minDaysInFirstWeek);
Magic Number,NodaTime.Calendars,SimpleWeekYearRule,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\SimpleWeekYearRule.cs,GetWeekYearDaysSinceEpoch,The following statement contains a magic number: return startOfYearIsInWeek1                      ? startOfWeekContainingStartOfCalendarYear                      : startOfWeekContainingStartOfCalendarYear + 7;
Magic Number,NodaTime.Calendars,UmAlQuraYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\UmAlQuraYearMonthDayCalculator.cs,UmAlQuraYearMonthDayCalculator,The following statement contains a magic number: MonthLengths = new ushort[data.Length / 2];
Magic Number,NodaTime.Calendars,UmAlQuraYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\UmAlQuraYearMonthDayCalculator.cs,UmAlQuraYearMonthDayCalculator,The following statement contains a magic number: MonthLengths[i] = (ushort) ((data[i * 2] << 8) | (data[i * 2 + 1]));
Magic Number,NodaTime.Calendars,UmAlQuraYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\UmAlQuraYearMonthDayCalculator.cs,UmAlQuraYearMonthDayCalculator,The following statement contains a magic number: MonthLengths[i] = (ushort) ((data[i * 2] << 8) | (data[i * 2 + 1]));
Magic Number,NodaTime.Calendars,UmAlQuraYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\UmAlQuraYearMonthDayCalculator.cs,UmAlQuraYearMonthDayCalculator,The following statement contains a magic number: MonthLengths[i] = (ushort) ((data[i * 2] << 8) | (data[i * 2 + 1]));
Magic Number,NodaTime.Calendars,UmAlQuraYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\UmAlQuraYearMonthDayCalculator.cs,UmAlQuraYearMonthDayCalculator,The following statement contains a magic number: int yearLength = 29 * 12;
Magic Number,NodaTime.Calendars,UmAlQuraYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\UmAlQuraYearMonthDayCalculator.cs,UmAlQuraYearMonthDayCalculator,The following statement contains a magic number: int yearLength = 29 * 12;
Magic Number,NodaTime.Calendars,UmAlQuraYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\UmAlQuraYearMonthDayCalculator.cs,UmAlQuraYearMonthDayCalculator,The following statement contains a magic number: month <= 12
Magic Number,NodaTime.Calendars,UmAlQuraYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\UmAlQuraYearMonthDayCalculator.cs,UmAlQuraYearMonthDayCalculator,The following statement contains a magic number: YearStartDays[0] = ComputedDaysAtStartOfMinYear - 354;
Magic Number,NodaTime.Calendars,UmAlQuraYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\UmAlQuraYearMonthDayCalculator.cs,UmAlQuraYearMonthDayCalculator,The following statement contains a magic number: YearLengths[0] = 354;
Magic Number,NodaTime.Calendars,UmAlQuraYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\UmAlQuraYearMonthDayCalculator.cs,UmAlQuraYearMonthDayCalculator,The following statement contains a magic number: YearLengths[YearStartDays.Length - 1] = 354;
Magic Number,NodaTime.Calendars,UmAlQuraYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\UmAlQuraYearMonthDayCalculator.cs,GetDaysFromStartOfYearToStartOfMonth,The following statement contains a magic number: return (month - 1) * 29 + extraDays;
Magic Number,NodaTime.Calendars,UmAlQuraYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\UmAlQuraYearMonthDayCalculator.cs,GetDaysInMonth,The following statement contains a magic number: return 29 + ((monthBits >> month) & 1);
Magic Number,NodaTime.Calendars,UmAlQuraYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\UmAlQuraYearMonthDayCalculator.cs,GetYearMonthDay,The following statement contains a magic number: int monthLength = 29 + ((monthBits >> month) & 1);
Magic Number,NodaTime.Calendars,UmAlQuraYearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\UmAlQuraYearMonthDayCalculator.cs,GetYearMonthDay,The following statement contains a magic number: month <= 12
Magic Number,NodaTime.Calendars,WeekYearRules,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\WeekYearRules.cs,FromCalendarWeekRule,The following statement contains a magic number: int minDaysInFirstWeek = calendarWeekRule switch              {                  FirstDay => 1'                  FirstFourDayWeek => 4'                  FirstFullWeek => 7'                  _ => throw new ArgumentException($"Unsupported CalendarWeekRule: {calendarWeekRule}"' nameof(calendarWeekRule))              };
Magic Number,NodaTime.Calendars,WeekYearRules,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\WeekYearRules.cs,FromCalendarWeekRule,The following statement contains a magic number: int minDaysInFirstWeek = calendarWeekRule switch              {                  FirstDay => 1'                  FirstFourDayWeek => 4'                  FirstFullWeek => 7'                  _ => throw new ArgumentException($"Unsupported CalendarWeekRule: {calendarWeekRule}"' nameof(calendarWeekRule))              };
Magic Number,NodaTime.Calendars,YearMonthDayCalculator,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Calendars\YearMonthDayCalculator.cs,GetYear,The following statement contains a magic number: int candidate = ((daysSinceYear1 * 10) / averageDaysPer10Years) + 1;
Magic Number,NodaTime.Fields,FixedLengthDatePeriodField,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Fields\FixedLengthDatePeriodField.cs,Add,The following statement contains a magic number: daysToAdd < 300 && daysToAdd > -300
Magic Number,NodaTime.Fields,FixedLengthDatePeriodField,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Fields\FixedLengthDatePeriodField.cs,Add,The following statement contains a magic number: daysToAdd < 300 && daysToAdd > -300
Magic Number,NodaTime.Text,AnnualDatePatternParser,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\AnnualDatePatternParser.cs,HandleDayOfMonth,The following statement contains a magic number: int count = pattern.GetRepeatCount(2);
Magic Number,NodaTime.Text,AnnualDatePatternParser,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\AnnualDatePatternParser.cs,HandleDayOfMonth,The following statement contains a magic number: switch (count)              {                  case 1:                  case 2:                      field = PatternFields.DayOfMonth;                      // Handle real maximum value in the bucket                      builder.AddParseValueAction(count' 2' pattern.Current' 1' 99' (bucket' value) => bucket.DayOfMonth = value);                      builder.AddFormatLeftPad(count' value => value.Day' assumeNonNegative: true' assumeFitsInCount: count == 2);                      break;                  default:                      throw new InvalidOperationException("Invalid count!");              }
Magic Number,NodaTime.Text,AnnualDatePatternParser,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\AnnualDatePatternParser.cs,HandleDayOfMonth,The following statement contains a magic number: switch (count)              {                  case 1:                  case 2:                      field = PatternFields.DayOfMonth;                      // Handle real maximum value in the bucket                      builder.AddParseValueAction(count' 2' pattern.Current' 1' 99' (bucket' value) => bucket.DayOfMonth = value);                      builder.AddFormatLeftPad(count' value => value.Day' assumeNonNegative: true' assumeFitsInCount: count == 2);                      break;                  default:                      throw new InvalidOperationException("Invalid count!");              }
Magic Number,NodaTime.Text,AnnualDatePatternParser,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\AnnualDatePatternParser.cs,HandleDayOfMonth,The following statement contains a magic number: switch (count)              {                  case 1:                  case 2:                      field = PatternFields.DayOfMonth;                      // Handle real maximum value in the bucket                      builder.AddParseValueAction(count' 2' pattern.Current' 1' 99' (bucket' value) => bucket.DayOfMonth = value);                      builder.AddFormatLeftPad(count' value => value.Day' assumeNonNegative: true' assumeFitsInCount: count == 2);                      break;                  default:                      throw new InvalidOperationException("Invalid count!");              }
Magic Number,NodaTime.Text,AnnualDatePatternParser,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\AnnualDatePatternParser.cs,HandleDayOfMonth,The following statement contains a magic number: switch (count)              {                  case 1:                  case 2:                      field = PatternFields.DayOfMonth;                      // Handle real maximum value in the bucket                      builder.AddParseValueAction(count' 2' pattern.Current' 1' 99' (bucket' value) => bucket.DayOfMonth = value);                      builder.AddFormatLeftPad(count' value => value.Day' assumeNonNegative: true' assumeFitsInCount: count == 2);                      break;                  default:                      throw new InvalidOperationException("Invalid count!");              }
Magic Number,NodaTime.Text,AnnualDateParseBucket,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\AnnualDatePatternParser.cs,CalculateValue,The following statement contains a magic number: day > CalendarSystem.Iso.GetDaysInMonth(2000' MonthOfYearNumeric)
Magic Number,NodaTime.Text,AnnualDateParseBucket,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\AnnualDatePatternParser.cs,DetermineMonth,The following statement contains a magic number: MonthOfYearNumeric > CalendarSystem.Iso.GetMonthsInYear(2000)
Magic Number,NodaTime.Text,DurationPatternParser,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\DurationPatternParser.cs,ParsePattern,The following statement contains a magic number: return patternBuilder.Build(Duration.FromHours(1) + Duration.FromMinutes(30) + Duration.FromSeconds(5) + Duration.FromMilliseconds(500));
Magic Number,NodaTime.Text,DurationPatternParser,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\DurationPatternParser.cs,ParsePattern,The following statement contains a magic number: return patternBuilder.Build(Duration.FromHours(1) + Duration.FromMinutes(30) + Duration.FromSeconds(5) + Duration.FromMilliseconds(500));
Magic Number,NodaTime.Text,DurationPatternParser,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\DurationPatternParser.cs,ParsePattern,The following statement contains a magic number: return patternBuilder.Build(Duration.FromHours(1) + Duration.FromMinutes(30) + Duration.FromSeconds(5) + Duration.FromMilliseconds(500));
Magic Number,NodaTime.Text,DurationPatternParser,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\DurationPatternParser.cs,CreateTotalHandler,The following statement contains a magic number: return (pattern' builder) =>              {                  // Needs to be big enough for 1449551462400 seconds                  int count = pattern.GetRepeatCount(13);                  // AddField would throw an inappropriate exception here' so handle it specially.                  if ((builder.UsedFields & PatternFields.TotalDuration) != 0)                  {                      throw new InvalidPatternException(TextErrorMessages.MultipleCapitalDurationFields);                  }                  builder.AddField(field' pattern.Current);                  builder.AddField(PatternFields.TotalDuration' pattern.Current);                  builder.AddParseInt64ValueAction(count' 13' pattern.Current' 0' maxValue' (bucket' value) => bucket.AddUnits(value' nanosecondsPerUnit));                  builder.AddFormatAction((value' sb) => FormatHelper.LeftPadNonNegativeInt64(GetPositiveNanosecondUnits(value' nanosecondsPerUnit' unitsPerDay)' count' sb));              };
Magic Number,NodaTime.Text,DurationPatternParser,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\DurationPatternParser.cs,CreateTotalHandler,The following statement contains a magic number: return (pattern' builder) =>              {                  // Needs to be big enough for 1449551462400 seconds                  int count = pattern.GetRepeatCount(13);                  // AddField would throw an inappropriate exception here' so handle it specially.                  if ((builder.UsedFields & PatternFields.TotalDuration) != 0)                  {                      throw new InvalidPatternException(TextErrorMessages.MultipleCapitalDurationFields);                  }                  builder.AddField(field' pattern.Current);                  builder.AddField(PatternFields.TotalDuration' pattern.Current);                  builder.AddParseInt64ValueAction(count' 13' pattern.Current' 0' maxValue' (bucket' value) => bucket.AddUnits(value' nanosecondsPerUnit));                  builder.AddFormatAction((value' sb) => FormatHelper.LeftPadNonNegativeInt64(GetPositiveNanosecondUnits(value' nanosecondsPerUnit' unitsPerDay)' count' sb));              };
Magic Number,NodaTime.Text,DurationPatternParser,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\DurationPatternParser.cs,CreateDayHandler,The following statement contains a magic number: return (pattern' builder) =>              {                  int count = pattern.GetRepeatCount(8); // Enough for 16777216                  // AddField would throw an inappropriate exception here' so handle it specially.                  if ((builder.UsedFields & PatternFields.TotalDuration) != 0)                  {                      throw new InvalidPatternException(TextErrorMessages.MultipleCapitalDurationFields);                  }                  builder.AddField(PatternFields.DayOfMonth' pattern.Current);                  builder.AddField(PatternFields.TotalDuration' pattern.Current);                  builder.AddParseValueAction(count' 8' pattern.Current' 0' 16777216' (bucket' value) => bucket.AddDays(value));                  builder.AddFormatLeftPad(count' duration =>                  {                      int days = duration.FloorDays;                      if (days >= 0)                      {                          return days;                      }                      // Round towards 0.                      return duration.NanosecondOfFloorDay == 0 ? -days : -(days + 1);                  }'                  assumeNonNegative: true'                  assumeFitsInCount: false);              };
Magic Number,NodaTime.Text,DurationPatternParser,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\DurationPatternParser.cs,CreateDayHandler,The following statement contains a magic number: return (pattern' builder) =>              {                  int count = pattern.GetRepeatCount(8); // Enough for 16777216                  // AddField would throw an inappropriate exception here' so handle it specially.                  if ((builder.UsedFields & PatternFields.TotalDuration) != 0)                  {                      throw new InvalidPatternException(TextErrorMessages.MultipleCapitalDurationFields);                  }                  builder.AddField(PatternFields.DayOfMonth' pattern.Current);                  builder.AddField(PatternFields.TotalDuration' pattern.Current);                  builder.AddParseValueAction(count' 8' pattern.Current' 0' 16777216' (bucket' value) => bucket.AddDays(value));                  builder.AddFormatLeftPad(count' duration =>                  {                      int days = duration.FloorDays;                      if (days >= 0)                      {                          return days;                      }                      // Round towards 0.                      return duration.NanosecondOfFloorDay == 0 ? -days : -(days + 1);                  }'                  assumeNonNegative: true'                  assumeFitsInCount: false);              };
Magic Number,NodaTime.Text,DurationPatternParser,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\DurationPatternParser.cs,CreateDayHandler,The following statement contains a magic number: return (pattern' builder) =>              {                  int count = pattern.GetRepeatCount(8); // Enough for 16777216                  // AddField would throw an inappropriate exception here' so handle it specially.                  if ((builder.UsedFields & PatternFields.TotalDuration) != 0)                  {                      throw new InvalidPatternException(TextErrorMessages.MultipleCapitalDurationFields);                  }                  builder.AddField(PatternFields.DayOfMonth' pattern.Current);                  builder.AddField(PatternFields.TotalDuration' pattern.Current);                  builder.AddParseValueAction(count' 8' pattern.Current' 0' 16777216' (bucket' value) => bucket.AddDays(value));                  builder.AddFormatLeftPad(count' duration =>                  {                      int days = duration.FloorDays;                      if (days >= 0)                      {                          return days;                      }                      // Round towards 0.                      return duration.NanosecondOfFloorDay == 0 ? -days : -(days + 1);                  }'                  assumeNonNegative: true'                  assumeFitsInCount: false);              };
Magic Number,NodaTime.Text,DurationPatternParser,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\DurationPatternParser.cs,CreatePartialHandler,The following statement contains a magic number: return (pattern' builder) =>              {                  int count = pattern.GetRepeatCount(2);                  builder.AddField(field' pattern.Current);                  builder.AddParseValueAction(count' 2' pattern.Current' 0' unitsPerContainer - 1'                      (bucket' value) => bucket.AddUnits(value' nanosecondsPerUnit));                  // This is never used for anything larger than a day' so the day part is irrelevant.                  builder.AddFormatLeftPad(count'                      duration => (int) (((Math.Abs(duration.NanosecondOfDay) / nanosecondsPerUnit)) % unitsPerContainer)'                      assumeNonNegative: true'                      assumeFitsInCount: count == 2);              };
Magic Number,NodaTime.Text,DurationPatternParser,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\DurationPatternParser.cs,CreatePartialHandler,The following statement contains a magic number: return (pattern' builder) =>              {                  int count = pattern.GetRepeatCount(2);                  builder.AddField(field' pattern.Current);                  builder.AddParseValueAction(count' 2' pattern.Current' 0' unitsPerContainer - 1'                      (bucket' value) => bucket.AddUnits(value' nanosecondsPerUnit));                  // This is never used for anything larger than a day' so the day part is irrelevant.                  builder.AddFormatLeftPad(count'                      duration => (int) (((Math.Abs(duration.NanosecondOfDay) / nanosecondsPerUnit)) % unitsPerContainer)'                      assumeNonNegative: true'                      assumeFitsInCount: count == 2);              };
Magic Number,NodaTime.Text,DurationPatternParser,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\DurationPatternParser.cs,CreatePartialHandler,The following statement contains a magic number: return (pattern' builder) =>              {                  int count = pattern.GetRepeatCount(2);                  builder.AddField(field' pattern.Current);                  builder.AddParseValueAction(count' 2' pattern.Current' 0' unitsPerContainer - 1'                      (bucket' value) => bucket.AddUnits(value' nanosecondsPerUnit));                  // This is never used for anything larger than a day' so the day part is irrelevant.                  builder.AddFormatLeftPad(count'                      duration => (int) (((Math.Abs(duration.NanosecondOfDay) / nanosecondsPerUnit)) % unitsPerContainer)'                      assumeNonNegative: true'                      assumeFitsInCount: count == 2);              };
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,Format2DigitsNonNegative,The following statement contains a magic number: Preconditions.DebugCheckArgumentRange(nameof(value)' value' 0' 99);
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,Format2DigitsNonNegative,The following statement contains a magic number: outputBuffer.Append((char) ('0' + value / 10));
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,Format2DigitsNonNegative,The following statement contains a magic number: outputBuffer.Append((char) ('0' + value % 10));
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,Format4DigitsValueFits,The following statement contains a magic number: Preconditions.DebugCheckArgumentRange(nameof(value)' value' -9999' 10000);
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,Format4DigitsValueFits,The following statement contains a magic number: Preconditions.DebugCheckArgumentRange(nameof(value)' value' -9999' 10000);
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,Format4DigitsValueFits,The following statement contains a magic number: outputBuffer.Append((char) ('0' + (value / 1000)));
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,Format4DigitsValueFits,The following statement contains a magic number: outputBuffer.Append((char) ('0' + ((value / 100) % 10)));
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,Format4DigitsValueFits,The following statement contains a magic number: outputBuffer.Append((char) ('0' + ((value / 100) % 10)));
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,Format4DigitsValueFits,The following statement contains a magic number: outputBuffer.Append((char) ('0' + ((value / 10) % 10)));
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,Format4DigitsValueFits,The following statement contains a magic number: outputBuffer.Append((char) ('0' + ((value / 10) % 10)));
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,Format4DigitsValueFits,The following statement contains a magic number: outputBuffer.Append((char) ('0' + (value % 10)));
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,LeftPad,The following statement contains a magic number: outputBuffer.Append("000000".Substring(16 - length));
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,LeftPad,The following statement contains a magic number: length > 10
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,LeftPadNonNegative,The following statement contains a magic number: value < 10
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,LeftPadNonNegative,The following statement contains a magic number: char digit1 = (char) ('0' + (value / 10));
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,LeftPadNonNegative,The following statement contains a magic number: char digit2 = (char) ('0' + (value % 10));
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,LeftPadNonNegative,The following statement contains a magic number: value < 100
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,LeftPadNonNegative,The following statement contains a magic number: char digit1 = (char) ('0' + (value / 10));
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,LeftPadNonNegative,The following statement contains a magic number: char digit2 = (char) ('0' + (value % 10));
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,LeftPadNonNegative,The following statement contains a magic number: length == 2 && value < 100
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,LeftPadNonNegative,The following statement contains a magic number: length == 2 && value < 100
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,LeftPadNonNegative,The following statement contains a magic number: char digit1 = (char) ('0' + ((value / 100) % 10));
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,LeftPadNonNegative,The following statement contains a magic number: char digit1 = (char) ('0' + ((value / 100) % 10));
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,LeftPadNonNegative,The following statement contains a magic number: char digit2 = (char) ('0' + ((value / 10) % 10));
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,LeftPadNonNegative,The following statement contains a magic number: char digit2 = (char) ('0' + ((value / 10) % 10));
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,LeftPadNonNegative,The following statement contains a magic number: char digit3 = (char) ('0' + (value % 10));
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,LeftPadNonNegative,The following statement contains a magic number: length == 3 && value < 1000
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,LeftPadNonNegative,The following statement contains a magic number: length == 3 && value < 1000
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,LeftPadNonNegative,The following statement contains a magic number: char digit1 = (char) ('0' + (value / 1000));
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,LeftPadNonNegative,The following statement contains a magic number: char digit2 = (char) ('0' + ((value / 100) % 10));
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,LeftPadNonNegative,The following statement contains a magic number: char digit2 = (char) ('0' + ((value / 100) % 10));
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,LeftPadNonNegative,The following statement contains a magic number: char digit3 = (char) ('0' + ((value / 10) % 10));
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,LeftPadNonNegative,The following statement contains a magic number: char digit3 = (char) ('0' + ((value / 10) % 10));
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,LeftPadNonNegative,The following statement contains a magic number: char digit4 = (char) ('0' + (value % 10));
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,LeftPadNonNegative,The following statement contains a magic number: length == 4 && value < 10000
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,LeftPadNonNegative,The following statement contains a magic number: length == 4 && value < 10000
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,LeftPadNonNegative,The following statement contains a magic number: char digit1 = (char) ('0' + (value / 10000));
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,LeftPadNonNegative,The following statement contains a magic number: char digit2 = (char) ('0' + ((value / 1000) % 10));
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,LeftPadNonNegative,The following statement contains a magic number: char digit2 = (char) ('0' + ((value / 1000) % 10));
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,LeftPadNonNegative,The following statement contains a magic number: char digit3 = (char) ('0' + ((value / 100) % 10));
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,LeftPadNonNegative,The following statement contains a magic number: char digit3 = (char) ('0' + ((value / 100) % 10));
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,LeftPadNonNegative,The following statement contains a magic number: char digit4 = (char) ('0' + ((value / 10) % 10));
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,LeftPadNonNegative,The following statement contains a magic number: char digit4 = (char) ('0' + ((value / 10) % 10));
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,LeftPadNonNegative,The following statement contains a magic number: char digit5 = (char) ('0' + (value % 10));
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,LeftPadNonNegative,The following statement contains a magic number: length == 5 && value < 100000
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,LeftPadNonNegative,The following statement contains a magic number: length == 5 && value < 100000
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,LeftPadNonNegative,The following statement contains a magic number: digits[--pos] = (char) ('0' + (value % 10));
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,LeftPadNonNegative,The following statement contains a magic number: value /= 10;
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,LeftPadNonNegativeInt64,The following statement contains a magic number: value < 10
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,LeftPadNonNegativeInt64,The following statement contains a magic number: char digit1 = (char) ('0' + (value / 10));
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,LeftPadNonNegativeInt64,The following statement contains a magic number: char digit2 = (char) ('0' + (value % 10));
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,LeftPadNonNegativeInt64,The following statement contains a magic number: value < 100
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,LeftPadNonNegativeInt64,The following statement contains a magic number: char digit1 = (char) ('0' + (value / 10));
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,LeftPadNonNegativeInt64,The following statement contains a magic number: char digit2 = (char) ('0' + (value % 10));
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,LeftPadNonNegativeInt64,The following statement contains a magic number: length == 2 && value < 100
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,LeftPadNonNegativeInt64,The following statement contains a magic number: length == 2 && value < 100
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,LeftPadNonNegativeInt64,The following statement contains a magic number: char digit1 = (char) ('0' + ((value / 100) % 10));
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,LeftPadNonNegativeInt64,The following statement contains a magic number: char digit1 = (char) ('0' + ((value / 100) % 10));
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,LeftPadNonNegativeInt64,The following statement contains a magic number: char digit2 = (char) ('0' + ((value / 10) % 10));
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,LeftPadNonNegativeInt64,The following statement contains a magic number: char digit2 = (char) ('0' + ((value / 10) % 10));
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,LeftPadNonNegativeInt64,The following statement contains a magic number: char digit3 = (char) ('0' + (value % 10));
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,LeftPadNonNegativeInt64,The following statement contains a magic number: length == 3 && value < 1000
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,LeftPadNonNegativeInt64,The following statement contains a magic number: length == 3 && value < 1000
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,LeftPadNonNegativeInt64,The following statement contains a magic number: char digit1 = (char) ('0' + (value / 1000));
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,LeftPadNonNegativeInt64,The following statement contains a magic number: char digit2 = (char) ('0' + ((value / 100) % 10));
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,LeftPadNonNegativeInt64,The following statement contains a magic number: char digit2 = (char) ('0' + ((value / 100) % 10));
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,LeftPadNonNegativeInt64,The following statement contains a magic number: char digit3 = (char) ('0' + ((value / 10) % 10));
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,LeftPadNonNegativeInt64,The following statement contains a magic number: char digit3 = (char) ('0' + ((value / 10) % 10));
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,LeftPadNonNegativeInt64,The following statement contains a magic number: char digit4 = (char) ('0' + (value % 10));
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,LeftPadNonNegativeInt64,The following statement contains a magic number: length == 4 && value < 10000
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,LeftPadNonNegativeInt64,The following statement contains a magic number: length == 4 && value < 10000
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,LeftPadNonNegativeInt64,The following statement contains a magic number: char digit1 = (char) ('0' + (value / 10000));
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,LeftPadNonNegativeInt64,The following statement contains a magic number: char digit2 = (char) ('0' + ((value / 1000) % 10));
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,LeftPadNonNegativeInt64,The following statement contains a magic number: char digit2 = (char) ('0' + ((value / 1000) % 10));
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,LeftPadNonNegativeInt64,The following statement contains a magic number: char digit3 = (char) ('0' + ((value / 100) % 10));
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,LeftPadNonNegativeInt64,The following statement contains a magic number: char digit3 = (char) ('0' + ((value / 100) % 10));
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,LeftPadNonNegativeInt64,The following statement contains a magic number: char digit4 = (char) ('0' + ((value / 10) % 10));
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,LeftPadNonNegativeInt64,The following statement contains a magic number: char digit4 = (char) ('0' + ((value / 10) % 10));
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,LeftPadNonNegativeInt64,The following statement contains a magic number: char digit5 = (char) ('0' + (value % 10));
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,LeftPadNonNegativeInt64,The following statement contains a magic number: length == 5 && value < 100000
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,LeftPadNonNegativeInt64,The following statement contains a magic number: length == 5 && value < 100000
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,LeftPadNonNegativeInt64,The following statement contains a magic number: digits[--pos] = (char) ('0' + (value % 10));
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,LeftPadNonNegativeInt64,The following statement contains a magic number: value /= 10;
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,AppendFraction,The following statement contains a magic number: relevantDigits /= 10;
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,AppendFraction,The following statement contains a magic number: outputBuffer[index--] = (char) ('0' + (relevantDigits % 10));
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,AppendFraction,The following statement contains a magic number: relevantDigits /= 10;
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,AppendFractionTruncate,The following statement contains a magic number: relevantDigits /= 10;
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,AppendFractionTruncate,The following statement contains a magic number: (relevantDigits % 10L) != 0L
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,AppendFractionTruncate,The following statement contains a magic number: relevantDigits /= 10;
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,AppendFractionTruncate,The following statement contains a magic number: outputBuffer[index--] = (char) ('0' + (relevantDigits % 10));
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,AppendFractionTruncate,The following statement contains a magic number: relevantDigits /= 10;
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,FormatInvariant,The following statement contains a magic number: value < 10
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,FormatInvariant,The following statement contains a magic number: char digit1 = (char) ('0' + (value / 10));
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,FormatInvariant,The following statement contains a magic number: char digit2 = (char) ('0' + (value % 10));
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,FormatInvariant,The following statement contains a magic number: value < 100
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,FormatInvariant,The following statement contains a magic number: char digit1 = (char) ('0' + ((value / 100) % 10));
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,FormatInvariant,The following statement contains a magic number: char digit1 = (char) ('0' + ((value / 100) % 10));
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,FormatInvariant,The following statement contains a magic number: char digit2 = (char) ('0' + ((value / 10) % 10));
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,FormatInvariant,The following statement contains a magic number: char digit2 = (char) ('0' + ((value / 10) % 10));
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,FormatInvariant,The following statement contains a magic number: char digit3 = (char) ('0' + (value % 10));
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,FormatInvariant,The following statement contains a magic number: value < 1000
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,FormatInvariant,The following statement contains a magic number: digits[--pos] = (char) ('0' + (value % 10));
Magic Number,NodaTime.Text,FormatHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\FormatHelper.cs,FormatInvariant,The following statement contains a magic number: value /= 10;
Magic Number,NodaTime.Text,LocalDateParseBucket,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\LocalDatePatternParser.cs,CalculateSimpleIsoValue,The following statement contains a magic number: month > 12
Magic Number,NodaTime.Text,LocalDateParseBucket,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\LocalDatePatternParser.cs,CalculateSimpleIsoValue,The following statement contains a magic number: day > 31 || (day > 28 && day > Calendar.GetDaysInMonth(Year' MonthOfYearNumeric))
Magic Number,NodaTime.Text,LocalDateParseBucket,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\LocalDatePatternParser.cs,CalculateSimpleIsoValue,The following statement contains a magic number: day > 31 || (day > 28 && day > Calendar.GetDaysInMonth(Year' MonthOfYearNumeric))
Magic Number,NodaTime.Text,LocalDateParseBucket,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\LocalDatePatternParser.cs,DetermineYear,The following statement contains a magic number: yearOfEraFromYear = yearOfEraFromYear % 100;
Magic Number,NodaTime.Text,LocalDateParseBucket,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\LocalDatePatternParser.cs,DetermineYear,The following statement contains a magic number: int century = TemplateValue.YearOfEra / 100;
Magic Number,NodaTime.Text,LocalDateParseBucket,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\LocalDatePatternParser.cs,DetermineYear,The following statement contains a magic number: YearOfEra += century * 100;
Magic Number,NodaTime.Text,LocalDateTimeParseBucket,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\LocalDateTimePatternParser.cs,CombineBuckets,The following statement contains a magic number: timeBucket.Hours24 == 24
Magic Number,NodaTime.Text,LocalTimeParseBucket,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\LocalTimePatternParser.cs,CalculateValue,The following statement contains a magic number: AmPm = TemplateValue.Hour / 12;
Magic Number,NodaTime.Text,LocalTimeParseBucket,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\LocalTimePatternParser.cs,CalculateValue,The following statement contains a magic number: AmPm == 2
Magic Number,NodaTime.Text,LocalTimeParseBucket,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\LocalTimePatternParser.cs,DetermineHour,The following statement contains a magic number: Hours12 % 12 != Hours24 % 12
Magic Number,NodaTime.Text,LocalTimeParseBucket,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\LocalTimePatternParser.cs,DetermineHour,The following statement contains a magic number: Hours12 % 12 != Hours24 % 12
Magic Number,NodaTime.Text,LocalTimeParseBucket,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\LocalTimePatternParser.cs,DetermineHour,The following statement contains a magic number: Hours24 / 12 != AmPm
Magic Number,NodaTime.Text,LocalTimeParseBucket,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\LocalTimePatternParser.cs,DetermineHour,The following statement contains a magic number: switch (usedFields & (PatternFields.Hours12 | PatternFields.AmPm))                  {                      case PatternFields.Hours12 | PatternFields.AmPm:                          hour = (Hours12 % 12) + AmPm * 12;                          break;                      case PatternFields.Hours12:                          // Preserve AM/PM from template value                          hour = (Hours12 % 12) + (TemplateValue.Hour / 12) * 12;                          break;                      case PatternFields.AmPm:                          // Preserve 12-hour hour of day from template value' use specified AM/PM                          hour = (TemplateValue.Hour % 12) + AmPm * 12;                          break;                      case 0:                          hour = TemplateValue.Hour;                          break;                  }
Magic Number,NodaTime.Text,LocalTimeParseBucket,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\LocalTimePatternParser.cs,DetermineHour,The following statement contains a magic number: switch (usedFields & (PatternFields.Hours12 | PatternFields.AmPm))                  {                      case PatternFields.Hours12 | PatternFields.AmPm:                          hour = (Hours12 % 12) + AmPm * 12;                          break;                      case PatternFields.Hours12:                          // Preserve AM/PM from template value                          hour = (Hours12 % 12) + (TemplateValue.Hour / 12) * 12;                          break;                      case PatternFields.AmPm:                          // Preserve 12-hour hour of day from template value' use specified AM/PM                          hour = (TemplateValue.Hour % 12) + AmPm * 12;                          break;                      case 0:                          hour = TemplateValue.Hour;                          break;                  }
Magic Number,NodaTime.Text,LocalTimeParseBucket,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\LocalTimePatternParser.cs,DetermineHour,The following statement contains a magic number: switch (usedFields & (PatternFields.Hours12 | PatternFields.AmPm))                  {                      case PatternFields.Hours12 | PatternFields.AmPm:                          hour = (Hours12 % 12) + AmPm * 12;                          break;                      case PatternFields.Hours12:                          // Preserve AM/PM from template value                          hour = (Hours12 % 12) + (TemplateValue.Hour / 12) * 12;                          break;                      case PatternFields.AmPm:                          // Preserve 12-hour hour of day from template value' use specified AM/PM                          hour = (TemplateValue.Hour % 12) + AmPm * 12;                          break;                      case 0:                          hour = TemplateValue.Hour;                          break;                  }
Magic Number,NodaTime.Text,LocalTimeParseBucket,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\LocalTimePatternParser.cs,DetermineHour,The following statement contains a magic number: switch (usedFields & (PatternFields.Hours12 | PatternFields.AmPm))                  {                      case PatternFields.Hours12 | PatternFields.AmPm:                          hour = (Hours12 % 12) + AmPm * 12;                          break;                      case PatternFields.Hours12:                          // Preserve AM/PM from template value                          hour = (Hours12 % 12) + (TemplateValue.Hour / 12) * 12;                          break;                      case PatternFields.AmPm:                          // Preserve 12-hour hour of day from template value' use specified AM/PM                          hour = (TemplateValue.Hour % 12) + AmPm * 12;                          break;                      case 0:                          hour = TemplateValue.Hour;                          break;                  }
Magic Number,NodaTime.Text,LocalTimeParseBucket,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\LocalTimePatternParser.cs,DetermineHour,The following statement contains a magic number: switch (usedFields & (PatternFields.Hours12 | PatternFields.AmPm))                  {                      case PatternFields.Hours12 | PatternFields.AmPm:                          hour = (Hours12 % 12) + AmPm * 12;                          break;                      case PatternFields.Hours12:                          // Preserve AM/PM from template value                          hour = (Hours12 % 12) + (TemplateValue.Hour / 12) * 12;                          break;                      case PatternFields.AmPm:                          // Preserve 12-hour hour of day from template value' use specified AM/PM                          hour = (TemplateValue.Hour % 12) + AmPm * 12;                          break;                      case 0:                          hour = TemplateValue.Hour;                          break;                  }
Magic Number,NodaTime.Text,LocalTimeParseBucket,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\LocalTimePatternParser.cs,DetermineHour,The following statement contains a magic number: switch (usedFields & (PatternFields.Hours12 | PatternFields.AmPm))                  {                      case PatternFields.Hours12 | PatternFields.AmPm:                          hour = (Hours12 % 12) + AmPm * 12;                          break;                      case PatternFields.Hours12:                          // Preserve AM/PM from template value                          hour = (Hours12 % 12) + (TemplateValue.Hour / 12) * 12;                          break;                      case PatternFields.AmPm:                          // Preserve 12-hour hour of day from template value' use specified AM/PM                          hour = (TemplateValue.Hour % 12) + AmPm * 12;                          break;                      case 0:                          hour = TemplateValue.Hour;                          break;                  }
Magic Number,NodaTime.Text,LocalTimeParseBucket,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\LocalTimePatternParser.cs,DetermineHour,The following statement contains a magic number: switch (usedFields & (PatternFields.Hours12 | PatternFields.AmPm))                  {                      case PatternFields.Hours12 | PatternFields.AmPm:                          hour = (Hours12 % 12) + AmPm * 12;                          break;                      case PatternFields.Hours12:                          // Preserve AM/PM from template value                          hour = (Hours12 % 12) + (TemplateValue.Hour / 12) * 12;                          break;                      case PatternFields.AmPm:                          // Preserve 12-hour hour of day from template value' use specified AM/PM                          hour = (TemplateValue.Hour % 12) + AmPm * 12;                          break;                      case 0:                          hour = TemplateValue.Hour;                          break;                  }
Magic Number,NodaTime.Text,OffsetPatternParser,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\OffsetPatternParser.cs,ParsePartialPattern,The following statement contains a magic number: IPartialPattern<Offset> pattern = patternBuilder.Build(Offset.FromHoursAndMinutes(5' 30));
Magic Number,NodaTime.Text,OffsetPatternParser,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\OffsetPatternParser.cs,ParsePartialPattern,The following statement contains a magic number: IPartialPattern<Offset> pattern = patternBuilder.Build(Offset.FromHoursAndMinutes(5' 30));
Magic Number,NodaTime.Text,NormalizingIsoPatternImpl,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\PeriodPattern.cs,Parse,The following statement contains a magic number: !valueCursor.ParseFraction(9' 9' out int totalNanoseconds' 1)
Magic Number,NodaTime.Text,NormalizingIsoPatternImpl,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\PeriodPattern.cs,Parse,The following statement contains a magic number: !valueCursor.ParseFraction(9' 9' out int totalNanoseconds' 1)
Magic Number,NodaTime.Text,NormalizingIsoPatternImpl,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\PeriodPattern.cs,AppendFormat,The following statement contains a magic number: FormatHelper.AppendFractionTruncate((int) nanoseconds' 9' 9' builder);
Magic Number,NodaTime.Text,NormalizingIsoPatternImpl,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\PeriodPattern.cs,AppendFormat,The following statement contains a magic number: FormatHelper.AppendFractionTruncate((int) nanoseconds' 9' 9' builder);
Magic Number,NodaTime.Text,ValueCursor,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\ValueCursor.cs,ParseInt64,The following statement contains a magic number: result = result * 10 + digit;
Magic Number,NodaTime.Text,ValueCursor,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\ValueCursor.cs,ParseInt64,The following statement contains a magic number: result < 922337203685477580 && (digit = GetDigit()) != -1
Magic Number,NodaTime.Text,ValueCursor,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\ValueCursor.cs,ParseInt64,The following statement contains a magic number: result > 922337203685477580
Magic Number,NodaTime.Text,ValueCursor,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\ValueCursor.cs,ParseInt64,The following statement contains a magic number: negative && digit == 8
Magic Number,NodaTime.Text,ValueCursor,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\ValueCursor.cs,ParseInt64,The following statement contains a magic number: digit > 7
Magic Number,NodaTime.Text,ValueCursor,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\ValueCursor.cs,ParseInt64,The following statement contains a magic number: result = result * 10 + digit;
Magic Number,NodaTime.Text,ValueCursor,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\ValueCursor.cs,ParseInt64,The following statement contains a magic number: result >= 922337203685477580 && (digit = GetDigit()) != -1
Magic Number,NodaTime.Text,ValueCursor,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\ValueCursor.cs,ParseInt64Digits,The following statement contains a magic number: digit < 0 || digit > 9
Magic Number,NodaTime.Text,ValueCursor,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\ValueCursor.cs,ParseInt64Digits,The following statement contains a magic number: result = result * 10 + digit;
Magic Number,NodaTime.Text,ValueCursor,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\ValueCursor.cs,ParseDigits,The following statement contains a magic number: digit < 0 || digit > 9
Magic Number,NodaTime.Text,ValueCursor,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\ValueCursor.cs,ParseDigits,The following statement contains a magic number: result = result * 10 + digit;
Magic Number,NodaTime.Text,ValueCursor,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\ValueCursor.cs,ParseFraction,The following statement contains a magic number: digit < 0 || digit > 9
Magic Number,NodaTime.Text,ValueCursor,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\ValueCursor.cs,ParseFraction,The following statement contains a magic number: result = result * 10 + digit;
Magic Number,NodaTime.Text,ValueCursor,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\ValueCursor.cs,ParseFraction,The following statement contains a magic number: result = (int) (result * Math.Pow(10.0' scale - count));
Magic Number,NodaTime.Text,ZonedDateTimeParseBucket,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\ZonedDateTimePatternParser.cs,TryParseFixedZone,The following statement contains a magic number: value.Move(value.Index + 3);
Magic Number,NodaTime.Text,ZonedDateTimeParseBucket,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\ZonedDateTimePatternParser.cs,TryParseProviderZone,The following statement contains a magic number: int guess = (lowerBound + upperBound) / 2;
Magic Number,NodaTime.Text,ZonedDateTimeParseBucket,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\ZonedDateTimePatternParser.cs,CalculateValue,The following statement contains a magic number: switch (mapping.Count)                  {                      // If the local time was skipped' the offset has to be invalid.                      case 0:                          return ParseResult<ZonedDateTime>.InvalidOffset(text);                      case 1:                          result = mapping.First(); // We'll validate in a minute                          break;                      case 2:                          result = mapping.First().Offset == Offset ? mapping.First() : mapping.Last();                          break;                      default:                          throw new InvalidOperationException("Mapping has count outside range 0-2; should not happen.");                  }
Magic Number,NodaTime.Text.Patterns,DatePatternHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\Patterns\DatePatternHelper.cs,CreateYearOfEraHandler,The following statement contains a magic number: return (pattern' builder) =>              {                  int count = pattern.GetRepeatCount(4);                  builder.AddField(PatternFields.YearOfEra' pattern.Current);                  switch (count)                  {                      case 2:                          builder.AddParseValueAction(2' 2' 'y'' 0' 99' setter);                          // Force the year into the range 0-99.                          builder.AddFormatLeftPad(2' value => ((yearGetter(value) % 100) + 100) % 100'                              assumeNonNegative: true'                              assumeFitsInCount: true);                          // Just remember that we've set this particular field. We can't set it twice as we've already got the YearOfEra flag set.                          builder.AddField(PatternFields.YearTwoDigits' pattern.Current);                          break;                      case 4:                          // Left-pad to 4 digits when formatting; parse exactly 4 digits.                          builder.AddParseValueAction(4' 4' 'y'' 1' 9999' setter);                          builder.AddFormatLeftPad(4' yearGetter'                              assumeNonNegative: false'                              assumeFitsInCount: true);                          break;                      default:                          throw new InvalidPatternException(TextErrorMessages.InvalidRepeatCount' pattern.Current' count);                  }              };
Magic Number,NodaTime.Text.Patterns,DatePatternHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\Patterns\DatePatternHelper.cs,CreateYearOfEraHandler,The following statement contains a magic number: return (pattern' builder) =>              {                  int count = pattern.GetRepeatCount(4);                  builder.AddField(PatternFields.YearOfEra' pattern.Current);                  switch (count)                  {                      case 2:                          builder.AddParseValueAction(2' 2' 'y'' 0' 99' setter);                          // Force the year into the range 0-99.                          builder.AddFormatLeftPad(2' value => ((yearGetter(value) % 100) + 100) % 100'                              assumeNonNegative: true'                              assumeFitsInCount: true);                          // Just remember that we've set this particular field. We can't set it twice as we've already got the YearOfEra flag set.                          builder.AddField(PatternFields.YearTwoDigits' pattern.Current);                          break;                      case 4:                          // Left-pad to 4 digits when formatting; parse exactly 4 digits.                          builder.AddParseValueAction(4' 4' 'y'' 1' 9999' setter);                          builder.AddFormatLeftPad(4' yearGetter'                              assumeNonNegative: false'                              assumeFitsInCount: true);                          break;                      default:                          throw new InvalidPatternException(TextErrorMessages.InvalidRepeatCount' pattern.Current' count);                  }              };
Magic Number,NodaTime.Text.Patterns,DatePatternHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\Patterns\DatePatternHelper.cs,CreateYearOfEraHandler,The following statement contains a magic number: return (pattern' builder) =>              {                  int count = pattern.GetRepeatCount(4);                  builder.AddField(PatternFields.YearOfEra' pattern.Current);                  switch (count)                  {                      case 2:                          builder.AddParseValueAction(2' 2' 'y'' 0' 99' setter);                          // Force the year into the range 0-99.                          builder.AddFormatLeftPad(2' value => ((yearGetter(value) % 100) + 100) % 100'                              assumeNonNegative: true'                              assumeFitsInCount: true);                          // Just remember that we've set this particular field. We can't set it twice as we've already got the YearOfEra flag set.                          builder.AddField(PatternFields.YearTwoDigits' pattern.Current);                          break;                      case 4:                          // Left-pad to 4 digits when formatting; parse exactly 4 digits.                          builder.AddParseValueAction(4' 4' 'y'' 1' 9999' setter);                          builder.AddFormatLeftPad(4' yearGetter'                              assumeNonNegative: false'                              assumeFitsInCount: true);                          break;                      default:                          throw new InvalidPatternException(TextErrorMessages.InvalidRepeatCount' pattern.Current' count);                  }              };
Magic Number,NodaTime.Text.Patterns,DatePatternHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\Patterns\DatePatternHelper.cs,CreateYearOfEraHandler,The following statement contains a magic number: return (pattern' builder) =>              {                  int count = pattern.GetRepeatCount(4);                  builder.AddField(PatternFields.YearOfEra' pattern.Current);                  switch (count)                  {                      case 2:                          builder.AddParseValueAction(2' 2' 'y'' 0' 99' setter);                          // Force the year into the range 0-99.                          builder.AddFormatLeftPad(2' value => ((yearGetter(value) % 100) + 100) % 100'                              assumeNonNegative: true'                              assumeFitsInCount: true);                          // Just remember that we've set this particular field. We can't set it twice as we've already got the YearOfEra flag set.                          builder.AddField(PatternFields.YearTwoDigits' pattern.Current);                          break;                      case 4:                          // Left-pad to 4 digits when formatting; parse exactly 4 digits.                          builder.AddParseValueAction(4' 4' 'y'' 1' 9999' setter);                          builder.AddFormatLeftPad(4' yearGetter'                              assumeNonNegative: false'                              assumeFitsInCount: true);                          break;                      default:                          throw new InvalidPatternException(TextErrorMessages.InvalidRepeatCount' pattern.Current' count);                  }              };
Magic Number,NodaTime.Text.Patterns,DatePatternHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\Patterns\DatePatternHelper.cs,CreateYearOfEraHandler,The following statement contains a magic number: return (pattern' builder) =>              {                  int count = pattern.GetRepeatCount(4);                  builder.AddField(PatternFields.YearOfEra' pattern.Current);                  switch (count)                  {                      case 2:                          builder.AddParseValueAction(2' 2' 'y'' 0' 99' setter);                          // Force the year into the range 0-99.                          builder.AddFormatLeftPad(2' value => ((yearGetter(value) % 100) + 100) % 100'                              assumeNonNegative: true'                              assumeFitsInCount: true);                          // Just remember that we've set this particular field. We can't set it twice as we've already got the YearOfEra flag set.                          builder.AddField(PatternFields.YearTwoDigits' pattern.Current);                          break;                      case 4:                          // Left-pad to 4 digits when formatting; parse exactly 4 digits.                          builder.AddParseValueAction(4' 4' 'y'' 1' 9999' setter);                          builder.AddFormatLeftPad(4' yearGetter'                              assumeNonNegative: false'                              assumeFitsInCount: true);                          break;                      default:                          throw new InvalidPatternException(TextErrorMessages.InvalidRepeatCount' pattern.Current' count);                  }              };
Magic Number,NodaTime.Text.Patterns,DatePatternHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\Patterns\DatePatternHelper.cs,CreateYearOfEraHandler,The following statement contains a magic number: return (pattern' builder) =>              {                  int count = pattern.GetRepeatCount(4);                  builder.AddField(PatternFields.YearOfEra' pattern.Current);                  switch (count)                  {                      case 2:                          builder.AddParseValueAction(2' 2' 'y'' 0' 99' setter);                          // Force the year into the range 0-99.                          builder.AddFormatLeftPad(2' value => ((yearGetter(value) % 100) + 100) % 100'                              assumeNonNegative: true'                              assumeFitsInCount: true);                          // Just remember that we've set this particular field. We can't set it twice as we've already got the YearOfEra flag set.                          builder.AddField(PatternFields.YearTwoDigits' pattern.Current);                          break;                      case 4:                          // Left-pad to 4 digits when formatting; parse exactly 4 digits.                          builder.AddParseValueAction(4' 4' 'y'' 1' 9999' setter);                          builder.AddFormatLeftPad(4' yearGetter'                              assumeNonNegative: false'                              assumeFitsInCount: true);                          break;                      default:                          throw new InvalidPatternException(TextErrorMessages.InvalidRepeatCount' pattern.Current' count);                  }              };
Magic Number,NodaTime.Text.Patterns,DatePatternHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\Patterns\DatePatternHelper.cs,CreateYearOfEraHandler,The following statement contains a magic number: return (pattern' builder) =>              {                  int count = pattern.GetRepeatCount(4);                  builder.AddField(PatternFields.YearOfEra' pattern.Current);                  switch (count)                  {                      case 2:                          builder.AddParseValueAction(2' 2' 'y'' 0' 99' setter);                          // Force the year into the range 0-99.                          builder.AddFormatLeftPad(2' value => ((yearGetter(value) % 100) + 100) % 100'                              assumeNonNegative: true'                              assumeFitsInCount: true);                          // Just remember that we've set this particular field. We can't set it twice as we've already got the YearOfEra flag set.                          builder.AddField(PatternFields.YearTwoDigits' pattern.Current);                          break;                      case 4:                          // Left-pad to 4 digits when formatting; parse exactly 4 digits.                          builder.AddParseValueAction(4' 4' 'y'' 1' 9999' setter);                          builder.AddFormatLeftPad(4' yearGetter'                              assumeNonNegative: false'                              assumeFitsInCount: true);                          break;                      default:                          throw new InvalidPatternException(TextErrorMessages.InvalidRepeatCount' pattern.Current' count);                  }              };
Magic Number,NodaTime.Text.Patterns,DatePatternHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\Patterns\DatePatternHelper.cs,CreateYearOfEraHandler,The following statement contains a magic number: return (pattern' builder) =>              {                  int count = pattern.GetRepeatCount(4);                  builder.AddField(PatternFields.YearOfEra' pattern.Current);                  switch (count)                  {                      case 2:                          builder.AddParseValueAction(2' 2' 'y'' 0' 99' setter);                          // Force the year into the range 0-99.                          builder.AddFormatLeftPad(2' value => ((yearGetter(value) % 100) + 100) % 100'                              assumeNonNegative: true'                              assumeFitsInCount: true);                          // Just remember that we've set this particular field. We can't set it twice as we've already got the YearOfEra flag set.                          builder.AddField(PatternFields.YearTwoDigits' pattern.Current);                          break;                      case 4:                          // Left-pad to 4 digits when formatting; parse exactly 4 digits.                          builder.AddParseValueAction(4' 4' 'y'' 1' 9999' setter);                          builder.AddFormatLeftPad(4' yearGetter'                              assumeNonNegative: false'                              assumeFitsInCount: true);                          break;                      default:                          throw new InvalidPatternException(TextErrorMessages.InvalidRepeatCount' pattern.Current' count);                  }              };
Magic Number,NodaTime.Text.Patterns,DatePatternHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\Patterns\DatePatternHelper.cs,CreateYearOfEraHandler,The following statement contains a magic number: return (pattern' builder) =>              {                  int count = pattern.GetRepeatCount(4);                  builder.AddField(PatternFields.YearOfEra' pattern.Current);                  switch (count)                  {                      case 2:                          builder.AddParseValueAction(2' 2' 'y'' 0' 99' setter);                          // Force the year into the range 0-99.                          builder.AddFormatLeftPad(2' value => ((yearGetter(value) % 100) + 100) % 100'                              assumeNonNegative: true'                              assumeFitsInCount: true);                          // Just remember that we've set this particular field. We can't set it twice as we've already got the YearOfEra flag set.                          builder.AddField(PatternFields.YearTwoDigits' pattern.Current);                          break;                      case 4:                          // Left-pad to 4 digits when formatting; parse exactly 4 digits.                          builder.AddParseValueAction(4' 4' 'y'' 1' 9999' setter);                          builder.AddFormatLeftPad(4' yearGetter'                              assumeNonNegative: false'                              assumeFitsInCount: true);                          break;                      default:                          throw new InvalidPatternException(TextErrorMessages.InvalidRepeatCount' pattern.Current' count);                  }              };
Magic Number,NodaTime.Text.Patterns,DatePatternHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\Patterns\DatePatternHelper.cs,CreateYearOfEraHandler,The following statement contains a magic number: return (pattern' builder) =>              {                  int count = pattern.GetRepeatCount(4);                  builder.AddField(PatternFields.YearOfEra' pattern.Current);                  switch (count)                  {                      case 2:                          builder.AddParseValueAction(2' 2' 'y'' 0' 99' setter);                          // Force the year into the range 0-99.                          builder.AddFormatLeftPad(2' value => ((yearGetter(value) % 100) + 100) % 100'                              assumeNonNegative: true'                              assumeFitsInCount: true);                          // Just remember that we've set this particular field. We can't set it twice as we've already got the YearOfEra flag set.                          builder.AddField(PatternFields.YearTwoDigits' pattern.Current);                          break;                      case 4:                          // Left-pad to 4 digits when formatting; parse exactly 4 digits.                          builder.AddParseValueAction(4' 4' 'y'' 1' 9999' setter);                          builder.AddFormatLeftPad(4' yearGetter'                              assumeNonNegative: false'                              assumeFitsInCount: true);                          break;                      default:                          throw new InvalidPatternException(TextErrorMessages.InvalidRepeatCount' pattern.Current' count);                  }              };
Magic Number,NodaTime.Text.Patterns,DatePatternHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\Patterns\DatePatternHelper.cs,CreateYearOfEraHandler,The following statement contains a magic number: return (pattern' builder) =>              {                  int count = pattern.GetRepeatCount(4);                  builder.AddField(PatternFields.YearOfEra' pattern.Current);                  switch (count)                  {                      case 2:                          builder.AddParseValueAction(2' 2' 'y'' 0' 99' setter);                          // Force the year into the range 0-99.                          builder.AddFormatLeftPad(2' value => ((yearGetter(value) % 100) + 100) % 100'                              assumeNonNegative: true'                              assumeFitsInCount: true);                          // Just remember that we've set this particular field. We can't set it twice as we've already got the YearOfEra flag set.                          builder.AddField(PatternFields.YearTwoDigits' pattern.Current);                          break;                      case 4:                          // Left-pad to 4 digits when formatting; parse exactly 4 digits.                          builder.AddParseValueAction(4' 4' 'y'' 1' 9999' setter);                          builder.AddFormatLeftPad(4' yearGetter'                              assumeNonNegative: false'                              assumeFitsInCount: true);                          break;                      default:                          throw new InvalidPatternException(TextErrorMessages.InvalidRepeatCount' pattern.Current' count);                  }              };
Magic Number,NodaTime.Text.Patterns,DatePatternHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\Patterns\DatePatternHelper.cs,CreateYearOfEraHandler,The following statement contains a magic number: return (pattern' builder) =>              {                  int count = pattern.GetRepeatCount(4);                  builder.AddField(PatternFields.YearOfEra' pattern.Current);                  switch (count)                  {                      case 2:                          builder.AddParseValueAction(2' 2' 'y'' 0' 99' setter);                          // Force the year into the range 0-99.                          builder.AddFormatLeftPad(2' value => ((yearGetter(value) % 100) + 100) % 100'                              assumeNonNegative: true'                              assumeFitsInCount: true);                          // Just remember that we've set this particular field. We can't set it twice as we've already got the YearOfEra flag set.                          builder.AddField(PatternFields.YearTwoDigits' pattern.Current);                          break;                      case 4:                          // Left-pad to 4 digits when formatting; parse exactly 4 digits.                          builder.AddParseValueAction(4' 4' 'y'' 1' 9999' setter);                          builder.AddFormatLeftPad(4' yearGetter'                              assumeNonNegative: false'                              assumeFitsInCount: true);                          break;                      default:                          throw new InvalidPatternException(TextErrorMessages.InvalidRepeatCount' pattern.Current' count);                  }              };
Magic Number,NodaTime.Text.Patterns,DatePatternHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\Patterns\DatePatternHelper.cs,CreateYearOfEraHandler,The following statement contains a magic number: return (pattern' builder) =>              {                  int count = pattern.GetRepeatCount(4);                  builder.AddField(PatternFields.YearOfEra' pattern.Current);                  switch (count)                  {                      case 2:                          builder.AddParseValueAction(2' 2' 'y'' 0' 99' setter);                          // Force the year into the range 0-99.                          builder.AddFormatLeftPad(2' value => ((yearGetter(value) % 100) + 100) % 100'                              assumeNonNegative: true'                              assumeFitsInCount: true);                          // Just remember that we've set this particular field. We can't set it twice as we've already got the YearOfEra flag set.                          builder.AddField(PatternFields.YearTwoDigits' pattern.Current);                          break;                      case 4:                          // Left-pad to 4 digits when formatting; parse exactly 4 digits.                          builder.AddParseValueAction(4' 4' 'y'' 1' 9999' setter);                          builder.AddFormatLeftPad(4' yearGetter'                              assumeNonNegative: false'                              assumeFitsInCount: true);                          break;                      default:                          throw new InvalidPatternException(TextErrorMessages.InvalidRepeatCount' pattern.Current' count);                  }              };
Magic Number,NodaTime.Text.Patterns,DatePatternHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\Patterns\DatePatternHelper.cs,CreateYearOfEraHandler,The following statement contains a magic number: return (pattern' builder) =>              {                  int count = pattern.GetRepeatCount(4);                  builder.AddField(PatternFields.YearOfEra' pattern.Current);                  switch (count)                  {                      case 2:                          builder.AddParseValueAction(2' 2' 'y'' 0' 99' setter);                          // Force the year into the range 0-99.                          builder.AddFormatLeftPad(2' value => ((yearGetter(value) % 100) + 100) % 100'                              assumeNonNegative: true'                              assumeFitsInCount: true);                          // Just remember that we've set this particular field. We can't set it twice as we've already got the YearOfEra flag set.                          builder.AddField(PatternFields.YearTwoDigits' pattern.Current);                          break;                      case 4:                          // Left-pad to 4 digits when formatting; parse exactly 4 digits.                          builder.AddParseValueAction(4' 4' 'y'' 1' 9999' setter);                          builder.AddFormatLeftPad(4' yearGetter'                              assumeNonNegative: false'                              assumeFitsInCount: true);                          break;                      default:                          throw new InvalidPatternException(TextErrorMessages.InvalidRepeatCount' pattern.Current' count);                  }              };
Magic Number,NodaTime.Text.Patterns,DatePatternHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\Patterns\DatePatternHelper.cs,CreateMonthOfYearHandler,The following statement contains a magic number: return (pattern' builder) =>              {                  int count = pattern.GetRepeatCount(4);                  PatternFields field;                  switch (count)                  {                      case 1:                      case 2:                          field = PatternFields.MonthOfYearNumeric;                          // Handle real maximum value in the bucket                          builder.AddParseValueAction(count' 2' pattern.Current' 1' 99' numberSetter);                          builder.AddFormatLeftPad(count' numberGetter' assumeNonNegative: true' assumeFitsInCount: count == 2);                          break;                      case 3:                      case 4:                          field = PatternFields.MonthOfYearText;                          var format = builder.FormatInfo;                          IReadOnlyList<string> nonGenitiveTextValues = count == 3 ? format.ShortMonthNames : format.LongMonthNames;                          IReadOnlyList<string> genitiveTextValues = count == 3 ? format.ShortMonthGenitiveNames : format.LongMonthGenitiveNames;                          if (nonGenitiveTextValues == genitiveTextValues)                          {                              builder.AddParseLongestTextAction(pattern.Current' textSetter' format.CompareInfo' nonGenitiveTextValues);                          }                          else                          {                              builder.AddParseLongestTextAction(pattern.Current' textSetter' format.CompareInfo'                                                                genitiveTextValues' nonGenitiveTextValues);                          }                            // Hack: see below                          builder.AddFormatAction(new MonthFormatActionHolder<TResult' TBucket>(format' count' numberGetter).DummyMethod);                          break;                      default:                          throw new InvalidOperationException("Invalid count!");                  }                  builder.AddField(field' pattern.Current);              };
Magic Number,NodaTime.Text.Patterns,DatePatternHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\Patterns\DatePatternHelper.cs,CreateMonthOfYearHandler,The following statement contains a magic number: return (pattern' builder) =>              {                  int count = pattern.GetRepeatCount(4);                  PatternFields field;                  switch (count)                  {                      case 1:                      case 2:                          field = PatternFields.MonthOfYearNumeric;                          // Handle real maximum value in the bucket                          builder.AddParseValueAction(count' 2' pattern.Current' 1' 99' numberSetter);                          builder.AddFormatLeftPad(count' numberGetter' assumeNonNegative: true' assumeFitsInCount: count == 2);                          break;                      case 3:                      case 4:                          field = PatternFields.MonthOfYearText;                          var format = builder.FormatInfo;                          IReadOnlyList<string> nonGenitiveTextValues = count == 3 ? format.ShortMonthNames : format.LongMonthNames;                          IReadOnlyList<string> genitiveTextValues = count == 3 ? format.ShortMonthGenitiveNames : format.LongMonthGenitiveNames;                          if (nonGenitiveTextValues == genitiveTextValues)                          {                              builder.AddParseLongestTextAction(pattern.Current' textSetter' format.CompareInfo' nonGenitiveTextValues);                          }                          else                          {                              builder.AddParseLongestTextAction(pattern.Current' textSetter' format.CompareInfo'                                                                genitiveTextValues' nonGenitiveTextValues);                          }                            // Hack: see below                          builder.AddFormatAction(new MonthFormatActionHolder<TResult' TBucket>(format' count' numberGetter).DummyMethod);                          break;                      default:                          throw new InvalidOperationException("Invalid count!");                  }                  builder.AddField(field' pattern.Current);              };
Magic Number,NodaTime.Text.Patterns,DatePatternHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\Patterns\DatePatternHelper.cs,CreateMonthOfYearHandler,The following statement contains a magic number: return (pattern' builder) =>              {                  int count = pattern.GetRepeatCount(4);                  PatternFields field;                  switch (count)                  {                      case 1:                      case 2:                          field = PatternFields.MonthOfYearNumeric;                          // Handle real maximum value in the bucket                          builder.AddParseValueAction(count' 2' pattern.Current' 1' 99' numberSetter);                          builder.AddFormatLeftPad(count' numberGetter' assumeNonNegative: true' assumeFitsInCount: count == 2);                          break;                      case 3:                      case 4:                          field = PatternFields.MonthOfYearText;                          var format = builder.FormatInfo;                          IReadOnlyList<string> nonGenitiveTextValues = count == 3 ? format.ShortMonthNames : format.LongMonthNames;                          IReadOnlyList<string> genitiveTextValues = count == 3 ? format.ShortMonthGenitiveNames : format.LongMonthGenitiveNames;                          if (nonGenitiveTextValues == genitiveTextValues)                          {                              builder.AddParseLongestTextAction(pattern.Current' textSetter' format.CompareInfo' nonGenitiveTextValues);                          }                          else                          {                              builder.AddParseLongestTextAction(pattern.Current' textSetter' format.CompareInfo'                                                                genitiveTextValues' nonGenitiveTextValues);                          }                            // Hack: see below                          builder.AddFormatAction(new MonthFormatActionHolder<TResult' TBucket>(format' count' numberGetter).DummyMethod);                          break;                      default:                          throw new InvalidOperationException("Invalid count!");                  }                  builder.AddField(field' pattern.Current);              };
Magic Number,NodaTime.Text.Patterns,DatePatternHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\Patterns\DatePatternHelper.cs,CreateMonthOfYearHandler,The following statement contains a magic number: return (pattern' builder) =>              {                  int count = pattern.GetRepeatCount(4);                  PatternFields field;                  switch (count)                  {                      case 1:                      case 2:                          field = PatternFields.MonthOfYearNumeric;                          // Handle real maximum value in the bucket                          builder.AddParseValueAction(count' 2' pattern.Current' 1' 99' numberSetter);                          builder.AddFormatLeftPad(count' numberGetter' assumeNonNegative: true' assumeFitsInCount: count == 2);                          break;                      case 3:                      case 4:                          field = PatternFields.MonthOfYearText;                          var format = builder.FormatInfo;                          IReadOnlyList<string> nonGenitiveTextValues = count == 3 ? format.ShortMonthNames : format.LongMonthNames;                          IReadOnlyList<string> genitiveTextValues = count == 3 ? format.ShortMonthGenitiveNames : format.LongMonthGenitiveNames;                          if (nonGenitiveTextValues == genitiveTextValues)                          {                              builder.AddParseLongestTextAction(pattern.Current' textSetter' format.CompareInfo' nonGenitiveTextValues);                          }                          else                          {                              builder.AddParseLongestTextAction(pattern.Current' textSetter' format.CompareInfo'                                                                genitiveTextValues' nonGenitiveTextValues);                          }                            // Hack: see below                          builder.AddFormatAction(new MonthFormatActionHolder<TResult' TBucket>(format' count' numberGetter).DummyMethod);                          break;                      default:                          throw new InvalidOperationException("Invalid count!");                  }                  builder.AddField(field' pattern.Current);              };
Magic Number,NodaTime.Text.Patterns,DatePatternHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\Patterns\DatePatternHelper.cs,CreateMonthOfYearHandler,The following statement contains a magic number: return (pattern' builder) =>              {                  int count = pattern.GetRepeatCount(4);                  PatternFields field;                  switch (count)                  {                      case 1:                      case 2:                          field = PatternFields.MonthOfYearNumeric;                          // Handle real maximum value in the bucket                          builder.AddParseValueAction(count' 2' pattern.Current' 1' 99' numberSetter);                          builder.AddFormatLeftPad(count' numberGetter' assumeNonNegative: true' assumeFitsInCount: count == 2);                          break;                      case 3:                      case 4:                          field = PatternFields.MonthOfYearText;                          var format = builder.FormatInfo;                          IReadOnlyList<string> nonGenitiveTextValues = count == 3 ? format.ShortMonthNames : format.LongMonthNames;                          IReadOnlyList<string> genitiveTextValues = count == 3 ? format.ShortMonthGenitiveNames : format.LongMonthGenitiveNames;                          if (nonGenitiveTextValues == genitiveTextValues)                          {                              builder.AddParseLongestTextAction(pattern.Current' textSetter' format.CompareInfo' nonGenitiveTextValues);                          }                          else                          {                              builder.AddParseLongestTextAction(pattern.Current' textSetter' format.CompareInfo'                                                                genitiveTextValues' nonGenitiveTextValues);                          }                            // Hack: see below                          builder.AddFormatAction(new MonthFormatActionHolder<TResult' TBucket>(format' count' numberGetter).DummyMethod);                          break;                      default:                          throw new InvalidOperationException("Invalid count!");                  }                  builder.AddField(field' pattern.Current);              };
Magic Number,NodaTime.Text.Patterns,DatePatternHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\Patterns\DatePatternHelper.cs,CreateMonthOfYearHandler,The following statement contains a magic number: return (pattern' builder) =>              {                  int count = pattern.GetRepeatCount(4);                  PatternFields field;                  switch (count)                  {                      case 1:                      case 2:                          field = PatternFields.MonthOfYearNumeric;                          // Handle real maximum value in the bucket                          builder.AddParseValueAction(count' 2' pattern.Current' 1' 99' numberSetter);                          builder.AddFormatLeftPad(count' numberGetter' assumeNonNegative: true' assumeFitsInCount: count == 2);                          break;                      case 3:                      case 4:                          field = PatternFields.MonthOfYearText;                          var format = builder.FormatInfo;                          IReadOnlyList<string> nonGenitiveTextValues = count == 3 ? format.ShortMonthNames : format.LongMonthNames;                          IReadOnlyList<string> genitiveTextValues = count == 3 ? format.ShortMonthGenitiveNames : format.LongMonthGenitiveNames;                          if (nonGenitiveTextValues == genitiveTextValues)                          {                              builder.AddParseLongestTextAction(pattern.Current' textSetter' format.CompareInfo' nonGenitiveTextValues);                          }                          else                          {                              builder.AddParseLongestTextAction(pattern.Current' textSetter' format.CompareInfo'                                                                genitiveTextValues' nonGenitiveTextValues);                          }                            // Hack: see below                          builder.AddFormatAction(new MonthFormatActionHolder<TResult' TBucket>(format' count' numberGetter).DummyMethod);                          break;                      default:                          throw new InvalidOperationException("Invalid count!");                  }                  builder.AddField(field' pattern.Current);              };
Magic Number,NodaTime.Text.Patterns,DatePatternHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\Patterns\DatePatternHelper.cs,CreateMonthOfYearHandler,The following statement contains a magic number: return (pattern' builder) =>              {                  int count = pattern.GetRepeatCount(4);                  PatternFields field;                  switch (count)                  {                      case 1:                      case 2:                          field = PatternFields.MonthOfYearNumeric;                          // Handle real maximum value in the bucket                          builder.AddParseValueAction(count' 2' pattern.Current' 1' 99' numberSetter);                          builder.AddFormatLeftPad(count' numberGetter' assumeNonNegative: true' assumeFitsInCount: count == 2);                          break;                      case 3:                      case 4:                          field = PatternFields.MonthOfYearText;                          var format = builder.FormatInfo;                          IReadOnlyList<string> nonGenitiveTextValues = count == 3 ? format.ShortMonthNames : format.LongMonthNames;                          IReadOnlyList<string> genitiveTextValues = count == 3 ? format.ShortMonthGenitiveNames : format.LongMonthGenitiveNames;                          if (nonGenitiveTextValues == genitiveTextValues)                          {                              builder.AddParseLongestTextAction(pattern.Current' textSetter' format.CompareInfo' nonGenitiveTextValues);                          }                          else                          {                              builder.AddParseLongestTextAction(pattern.Current' textSetter' format.CompareInfo'                                                                genitiveTextValues' nonGenitiveTextValues);                          }                            // Hack: see below                          builder.AddFormatAction(new MonthFormatActionHolder<TResult' TBucket>(format' count' numberGetter).DummyMethod);                          break;                      default:                          throw new InvalidOperationException("Invalid count!");                  }                  builder.AddField(field' pattern.Current);              };
Magic Number,NodaTime.Text.Patterns,DatePatternHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\Patterns\DatePatternHelper.cs,CreateMonthOfYearHandler,The following statement contains a magic number: return (pattern' builder) =>              {                  int count = pattern.GetRepeatCount(4);                  PatternFields field;                  switch (count)                  {                      case 1:                      case 2:                          field = PatternFields.MonthOfYearNumeric;                          // Handle real maximum value in the bucket                          builder.AddParseValueAction(count' 2' pattern.Current' 1' 99' numberSetter);                          builder.AddFormatLeftPad(count' numberGetter' assumeNonNegative: true' assumeFitsInCount: count == 2);                          break;                      case 3:                      case 4:                          field = PatternFields.MonthOfYearText;                          var format = builder.FormatInfo;                          IReadOnlyList<string> nonGenitiveTextValues = count == 3 ? format.ShortMonthNames : format.LongMonthNames;                          IReadOnlyList<string> genitiveTextValues = count == 3 ? format.ShortMonthGenitiveNames : format.LongMonthGenitiveNames;                          if (nonGenitiveTextValues == genitiveTextValues)                          {                              builder.AddParseLongestTextAction(pattern.Current' textSetter' format.CompareInfo' nonGenitiveTextValues);                          }                          else                          {                              builder.AddParseLongestTextAction(pattern.Current' textSetter' format.CompareInfo'                                                                genitiveTextValues' nonGenitiveTextValues);                          }                            // Hack: see below                          builder.AddFormatAction(new MonthFormatActionHolder<TResult' TBucket>(format' count' numberGetter).DummyMethod);                          break;                      default:                          throw new InvalidOperationException("Invalid count!");                  }                  builder.AddField(field' pattern.Current);              };
Magic Number,NodaTime.Text.Patterns,DatePatternHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\Patterns\DatePatternHelper.cs,CreateMonthOfYearHandler,The following statement contains a magic number: return (pattern' builder) =>              {                  int count = pattern.GetRepeatCount(4);                  PatternFields field;                  switch (count)                  {                      case 1:                      case 2:                          field = PatternFields.MonthOfYearNumeric;                          // Handle real maximum value in the bucket                          builder.AddParseValueAction(count' 2' pattern.Current' 1' 99' numberSetter);                          builder.AddFormatLeftPad(count' numberGetter' assumeNonNegative: true' assumeFitsInCount: count == 2);                          break;                      case 3:                      case 4:                          field = PatternFields.MonthOfYearText;                          var format = builder.FormatInfo;                          IReadOnlyList<string> nonGenitiveTextValues = count == 3 ? format.ShortMonthNames : format.LongMonthNames;                          IReadOnlyList<string> genitiveTextValues = count == 3 ? format.ShortMonthGenitiveNames : format.LongMonthGenitiveNames;                          if (nonGenitiveTextValues == genitiveTextValues)                          {                              builder.AddParseLongestTextAction(pattern.Current' textSetter' format.CompareInfo' nonGenitiveTextValues);                          }                          else                          {                              builder.AddParseLongestTextAction(pattern.Current' textSetter' format.CompareInfo'                                                                genitiveTextValues' nonGenitiveTextValues);                          }                            // Hack: see below                          builder.AddFormatAction(new MonthFormatActionHolder<TResult' TBucket>(format' count' numberGetter).DummyMethod);                          break;                      default:                          throw new InvalidOperationException("Invalid count!");                  }                  builder.AddField(field' pattern.Current);              };
Magic Number,NodaTime.Text.Patterns,DatePatternHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\Patterns\DatePatternHelper.cs,CreateDayHandler,The following statement contains a magic number: return (pattern' builder) =>              {                  int count = pattern.GetRepeatCount(4);                  PatternFields field;                  switch (count)                  {                      case 1:                      case 2:                          field = PatternFields.DayOfMonth;                          // Handle real maximum value in the bucket                          builder.AddParseValueAction(count' 2' pattern.Current' 1' 99' dayOfMonthSetter);                          builder.AddFormatLeftPad(count' dayOfMonthGetter' assumeNonNegative: true' assumeFitsInCount: count == 2);                          break;                      case 3:                      case 4:                          field = PatternFields.DayOfWeek;                          var format = builder.FormatInfo;                          IReadOnlyList<string> textValues = count == 3 ? format.ShortDayNames : format.LongDayNames;                          builder.AddParseLongestTextAction(pattern.Current' dayOfWeekSetter' format.CompareInfo' textValues);                          builder.AddFormatAction((value' sb) => sb.Append(textValues[dayOfWeekGetter(value)]));                          break;                      default:                          throw new InvalidOperationException("Invalid count!");                  }                  builder.AddField(field' pattern.Current);              };
Magic Number,NodaTime.Text.Patterns,DatePatternHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\Patterns\DatePatternHelper.cs,CreateDayHandler,The following statement contains a magic number: return (pattern' builder) =>              {                  int count = pattern.GetRepeatCount(4);                  PatternFields field;                  switch (count)                  {                      case 1:                      case 2:                          field = PatternFields.DayOfMonth;                          // Handle real maximum value in the bucket                          builder.AddParseValueAction(count' 2' pattern.Current' 1' 99' dayOfMonthSetter);                          builder.AddFormatLeftPad(count' dayOfMonthGetter' assumeNonNegative: true' assumeFitsInCount: count == 2);                          break;                      case 3:                      case 4:                          field = PatternFields.DayOfWeek;                          var format = builder.FormatInfo;                          IReadOnlyList<string> textValues = count == 3 ? format.ShortDayNames : format.LongDayNames;                          builder.AddParseLongestTextAction(pattern.Current' dayOfWeekSetter' format.CompareInfo' textValues);                          builder.AddFormatAction((value' sb) => sb.Append(textValues[dayOfWeekGetter(value)]));                          break;                      default:                          throw new InvalidOperationException("Invalid count!");                  }                  builder.AddField(field' pattern.Current);              };
Magic Number,NodaTime.Text.Patterns,DatePatternHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\Patterns\DatePatternHelper.cs,CreateDayHandler,The following statement contains a magic number: return (pattern' builder) =>              {                  int count = pattern.GetRepeatCount(4);                  PatternFields field;                  switch (count)                  {                      case 1:                      case 2:                          field = PatternFields.DayOfMonth;                          // Handle real maximum value in the bucket                          builder.AddParseValueAction(count' 2' pattern.Current' 1' 99' dayOfMonthSetter);                          builder.AddFormatLeftPad(count' dayOfMonthGetter' assumeNonNegative: true' assumeFitsInCount: count == 2);                          break;                      case 3:                      case 4:                          field = PatternFields.DayOfWeek;                          var format = builder.FormatInfo;                          IReadOnlyList<string> textValues = count == 3 ? format.ShortDayNames : format.LongDayNames;                          builder.AddParseLongestTextAction(pattern.Current' dayOfWeekSetter' format.CompareInfo' textValues);                          builder.AddFormatAction((value' sb) => sb.Append(textValues[dayOfWeekGetter(value)]));                          break;                      default:                          throw new InvalidOperationException("Invalid count!");                  }                  builder.AddField(field' pattern.Current);              };
Magic Number,NodaTime.Text.Patterns,DatePatternHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\Patterns\DatePatternHelper.cs,CreateDayHandler,The following statement contains a magic number: return (pattern' builder) =>              {                  int count = pattern.GetRepeatCount(4);                  PatternFields field;                  switch (count)                  {                      case 1:                      case 2:                          field = PatternFields.DayOfMonth;                          // Handle real maximum value in the bucket                          builder.AddParseValueAction(count' 2' pattern.Current' 1' 99' dayOfMonthSetter);                          builder.AddFormatLeftPad(count' dayOfMonthGetter' assumeNonNegative: true' assumeFitsInCount: count == 2);                          break;                      case 3:                      case 4:                          field = PatternFields.DayOfWeek;                          var format = builder.FormatInfo;                          IReadOnlyList<string> textValues = count == 3 ? format.ShortDayNames : format.LongDayNames;                          builder.AddParseLongestTextAction(pattern.Current' dayOfWeekSetter' format.CompareInfo' textValues);                          builder.AddFormatAction((value' sb) => sb.Append(textValues[dayOfWeekGetter(value)]));                          break;                      default:                          throw new InvalidOperationException("Invalid count!");                  }                  builder.AddField(field' pattern.Current);              };
Magic Number,NodaTime.Text.Patterns,DatePatternHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\Patterns\DatePatternHelper.cs,CreateDayHandler,The following statement contains a magic number: return (pattern' builder) =>              {                  int count = pattern.GetRepeatCount(4);                  PatternFields field;                  switch (count)                  {                      case 1:                      case 2:                          field = PatternFields.DayOfMonth;                          // Handle real maximum value in the bucket                          builder.AddParseValueAction(count' 2' pattern.Current' 1' 99' dayOfMonthSetter);                          builder.AddFormatLeftPad(count' dayOfMonthGetter' assumeNonNegative: true' assumeFitsInCount: count == 2);                          break;                      case 3:                      case 4:                          field = PatternFields.DayOfWeek;                          var format = builder.FormatInfo;                          IReadOnlyList<string> textValues = count == 3 ? format.ShortDayNames : format.LongDayNames;                          builder.AddParseLongestTextAction(pattern.Current' dayOfWeekSetter' format.CompareInfo' textValues);                          builder.AddFormatAction((value' sb) => sb.Append(textValues[dayOfWeekGetter(value)]));                          break;                      default:                          throw new InvalidOperationException("Invalid count!");                  }                  builder.AddField(field' pattern.Current);              };
Magic Number,NodaTime.Text.Patterns,DatePatternHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\Patterns\DatePatternHelper.cs,CreateDayHandler,The following statement contains a magic number: return (pattern' builder) =>              {                  int count = pattern.GetRepeatCount(4);                  PatternFields field;                  switch (count)                  {                      case 1:                      case 2:                          field = PatternFields.DayOfMonth;                          // Handle real maximum value in the bucket                          builder.AddParseValueAction(count' 2' pattern.Current' 1' 99' dayOfMonthSetter);                          builder.AddFormatLeftPad(count' dayOfMonthGetter' assumeNonNegative: true' assumeFitsInCount: count == 2);                          break;                      case 3:                      case 4:                          field = PatternFields.DayOfWeek;                          var format = builder.FormatInfo;                          IReadOnlyList<string> textValues = count == 3 ? format.ShortDayNames : format.LongDayNames;                          builder.AddParseLongestTextAction(pattern.Current' dayOfWeekSetter' format.CompareInfo' textValues);                          builder.AddFormatAction((value' sb) => sb.Append(textValues[dayOfWeekGetter(value)]));                          break;                      default:                          throw new InvalidOperationException("Invalid count!");                  }                  builder.AddField(field' pattern.Current);              };
Magic Number,NodaTime.Text.Patterns,DatePatternHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\Patterns\DatePatternHelper.cs,CreateDayHandler,The following statement contains a magic number: return (pattern' builder) =>              {                  int count = pattern.GetRepeatCount(4);                  PatternFields field;                  switch (count)                  {                      case 1:                      case 2:                          field = PatternFields.DayOfMonth;                          // Handle real maximum value in the bucket                          builder.AddParseValueAction(count' 2' pattern.Current' 1' 99' dayOfMonthSetter);                          builder.AddFormatLeftPad(count' dayOfMonthGetter' assumeNonNegative: true' assumeFitsInCount: count == 2);                          break;                      case 3:                      case 4:                          field = PatternFields.DayOfWeek;                          var format = builder.FormatInfo;                          IReadOnlyList<string> textValues = count == 3 ? format.ShortDayNames : format.LongDayNames;                          builder.AddParseLongestTextAction(pattern.Current' dayOfWeekSetter' format.CompareInfo' textValues);                          builder.AddFormatAction((value' sb) => sb.Append(textValues[dayOfWeekGetter(value)]));                          break;                      default:                          throw new InvalidOperationException("Invalid count!");                  }                  builder.AddField(field' pattern.Current);              };
Magic Number,NodaTime.Text.Patterns,DatePatternHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\Patterns\DatePatternHelper.cs,CreateDayHandler,The following statement contains a magic number: return (pattern' builder) =>              {                  int count = pattern.GetRepeatCount(4);                  PatternFields field;                  switch (count)                  {                      case 1:                      case 2:                          field = PatternFields.DayOfMonth;                          // Handle real maximum value in the bucket                          builder.AddParseValueAction(count' 2' pattern.Current' 1' 99' dayOfMonthSetter);                          builder.AddFormatLeftPad(count' dayOfMonthGetter' assumeNonNegative: true' assumeFitsInCount: count == 2);                          break;                      case 3:                      case 4:                          field = PatternFields.DayOfWeek;                          var format = builder.FormatInfo;                          IReadOnlyList<string> textValues = count == 3 ? format.ShortDayNames : format.LongDayNames;                          builder.AddParseLongestTextAction(pattern.Current' dayOfWeekSetter' format.CompareInfo' textValues);                          builder.AddFormatAction((value' sb) => sb.Append(textValues[dayOfWeekGetter(value)]));                          break;                      default:                          throw new InvalidOperationException("Invalid count!");                  }                  builder.AddField(field' pattern.Current);              };
Magic Number,NodaTime.Text.Patterns,DatePatternHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\Patterns\DatePatternHelper.cs,CreateEraHandler,The following statement contains a magic number: return (pattern' builder) =>              {                  pattern.GetRepeatCount(2);                  builder.AddField(PatternFields.Era' pattern.Current);                  var formatInfo = builder.FormatInfo;                  // Note: currently the count is ignored. More work needed to determine whether abbreviated era names should be used for just "g".                  builder.AddParseAction((cursor' bucket) =>                  {                      var dateBucket = dateBucketFromBucket(bucket);                      return dateBucket.ParseEra<TResult>(formatInfo' cursor);                  });                  builder.AddFormatAction((value' sb) => sb.Append(formatInfo.GetEraPrimaryName(eraFromValue(value))));              };
Magic Number,NodaTime.Text.Patterns,MonthFormatActionHolder<TResult;TBucket>,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\Patterns\DatePatternHelper.cs,BuildFormatAction,The following statement contains a magic number: IReadOnlyList<string> textValues = count == 3                      ? (genitive ? formatInfo.ShortMonthGenitiveNames : formatInfo.ShortMonthNames)                      : (genitive ? formatInfo.LongMonthGenitiveNames : formatInfo.LongMonthNames);
Magic Number,NodaTime.Text.Patterns,SteppedPatternBuilder<TResult;TBucket>,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\Patterns\SteppedPatternBuilder.cs,AddFormatLeftPad,The following statement contains a magic number: count == 2 && assumeNonNegative && assumeFitsInCount
Magic Number,NodaTime.Text.Patterns,TimePatternHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\Patterns\TimePatternHelper.cs,CreateAmPmHandler,The following statement contains a magic number: return (pattern' builder) =>              {                  int count = pattern.GetRepeatCount(2);                  builder.AddField(PatternFields.AmPm' pattern.Current);                    string amDesignator = builder.FormatInfo.AMDesignator;                  string pmDesignator = builder.FormatInfo.PMDesignator;                    // If we don't have an AM or PM designator' we're nearly done. Set the AM/PM designator                  // to the special value of 2' meaning "take it from the template".                  if (amDesignator == "" && pmDesignator == "")                  {                      builder.AddParseAction((str' bucket) =>                      {                          amPmSetter(bucket' 2);                          return null;                      });                      return;                  }                  // Odd scenario (but present in af-ZA for .NET 2) - exactly one of the AM/PM designator is valid.                  // Delegate to a separate method to keep this clearer...                  if (amDesignator == "" || pmDesignator == "")                  {                      int specifiedDesignatorValue = amDesignator == "" ? 1 : 0;                      string specifiedDesignator = specifiedDesignatorValue == 1 ? pmDesignator : amDesignator;                      HandleHalfAmPmDesignator(count' specifiedDesignator' specifiedDesignatorValue' hourOfDayGetter' amPmSetter' builder);                      return;                  }                  CompareInfo compareInfo = builder.FormatInfo.CompareInfo;                  // Single character designator                  if (count == 1)                  {                      // It's not entirely clear whether this is the right thing to do... there's no nice                      // way of providing a single-character case-insensitive match.                      string amFirst = amDesignator.Substring(0' 1);                      string pmFirst = pmDesignator.Substring(0' 1);                      builder.AddParseAction((str' bucket) =>                      {                          if (str.MatchCaseInsensitive(amFirst' compareInfo' true))                          {                              amPmSetter(bucket' 0);                              return null;                          }                          if (str.MatchCaseInsensitive(pmFirst' compareInfo' true))                          {                              amPmSetter(bucket' 1);                              return null;                          }                          return ParseResult<TResult>.MissingAmPmDesignator(str);                      });                      builder.AddFormatAction((value' sb) => sb.Append(hourOfDayGetter(value) > 11 ? pmDesignator[0] : amDesignator[0]));                      return;                  }                  // Full designator                  builder.AddParseAction((str' bucket) =>                  {                      // Could use the "match longest" approach' but with only two it feels a bit silly to build a list...                      bool pmLongerThanAm = pmDesignator.Length > amDesignator.Length;                      string longerDesignator = pmLongerThanAm ? pmDesignator : amDesignator;                      string shorterDesignator = pmLongerThanAm ? amDesignator : pmDesignator;                      int longerValue = pmLongerThanAm ? 1 : 0;                      if (str.MatchCaseInsensitive(longerDesignator' compareInfo' true))                      {                          amPmSetter(bucket' longerValue);                          return null;                      }                      if (str.MatchCaseInsensitive(shorterDesignator' compareInfo' true))                      {                          amPmSetter(bucket' 1 - longerValue);                          return null;                      }                      return ParseResult<TResult>.MissingAmPmDesignator(str);                  });                  builder.AddFormatAction((value' sb) => sb.Append(hourOfDayGetter(value) > 11 ? pmDesignator : amDesignator));              };
Magic Number,NodaTime.Text.Patterns,TimePatternHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\Patterns\TimePatternHelper.cs,CreateAmPmHandler,The following statement contains a magic number: return (pattern' builder) =>              {                  int count = pattern.GetRepeatCount(2);                  builder.AddField(PatternFields.AmPm' pattern.Current);                    string amDesignator = builder.FormatInfo.AMDesignator;                  string pmDesignator = builder.FormatInfo.PMDesignator;                    // If we don't have an AM or PM designator' we're nearly done. Set the AM/PM designator                  // to the special value of 2' meaning "take it from the template".                  if (amDesignator == "" && pmDesignator == "")                  {                      builder.AddParseAction((str' bucket) =>                      {                          amPmSetter(bucket' 2);                          return null;                      });                      return;                  }                  // Odd scenario (but present in af-ZA for .NET 2) - exactly one of the AM/PM designator is valid.                  // Delegate to a separate method to keep this clearer...                  if (amDesignator == "" || pmDesignator == "")                  {                      int specifiedDesignatorValue = amDesignator == "" ? 1 : 0;                      string specifiedDesignator = specifiedDesignatorValue == 1 ? pmDesignator : amDesignator;                      HandleHalfAmPmDesignator(count' specifiedDesignator' specifiedDesignatorValue' hourOfDayGetter' amPmSetter' builder);                      return;                  }                  CompareInfo compareInfo = builder.FormatInfo.CompareInfo;                  // Single character designator                  if (count == 1)                  {                      // It's not entirely clear whether this is the right thing to do... there's no nice                      // way of providing a single-character case-insensitive match.                      string amFirst = amDesignator.Substring(0' 1);                      string pmFirst = pmDesignator.Substring(0' 1);                      builder.AddParseAction((str' bucket) =>                      {                          if (str.MatchCaseInsensitive(amFirst' compareInfo' true))                          {                              amPmSetter(bucket' 0);                              return null;                          }                          if (str.MatchCaseInsensitive(pmFirst' compareInfo' true))                          {                              amPmSetter(bucket' 1);                              return null;                          }                          return ParseResult<TResult>.MissingAmPmDesignator(str);                      });                      builder.AddFormatAction((value' sb) => sb.Append(hourOfDayGetter(value) > 11 ? pmDesignator[0] : amDesignator[0]));                      return;                  }                  // Full designator                  builder.AddParseAction((str' bucket) =>                  {                      // Could use the "match longest" approach' but with only two it feels a bit silly to build a list...                      bool pmLongerThanAm = pmDesignator.Length > amDesignator.Length;                      string longerDesignator = pmLongerThanAm ? pmDesignator : amDesignator;                      string shorterDesignator = pmLongerThanAm ? amDesignator : pmDesignator;                      int longerValue = pmLongerThanAm ? 1 : 0;                      if (str.MatchCaseInsensitive(longerDesignator' compareInfo' true))                      {                          amPmSetter(bucket' longerValue);                          return null;                      }                      if (str.MatchCaseInsensitive(shorterDesignator' compareInfo' true))                      {                          amPmSetter(bucket' 1 - longerValue);                          return null;                      }                      return ParseResult<TResult>.MissingAmPmDesignator(str);                  });                  builder.AddFormatAction((value' sb) => sb.Append(hourOfDayGetter(value) > 11 ? pmDesignator : amDesignator));              };
Magic Number,NodaTime.Text.Patterns,TimePatternHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\Patterns\TimePatternHelper.cs,CreateAmPmHandler,The following statement contains a magic number: return (pattern' builder) =>              {                  int count = pattern.GetRepeatCount(2);                  builder.AddField(PatternFields.AmPm' pattern.Current);                    string amDesignator = builder.FormatInfo.AMDesignator;                  string pmDesignator = builder.FormatInfo.PMDesignator;                    // If we don't have an AM or PM designator' we're nearly done. Set the AM/PM designator                  // to the special value of 2' meaning "take it from the template".                  if (amDesignator == "" && pmDesignator == "")                  {                      builder.AddParseAction((str' bucket) =>                      {                          amPmSetter(bucket' 2);                          return null;                      });                      return;                  }                  // Odd scenario (but present in af-ZA for .NET 2) - exactly one of the AM/PM designator is valid.                  // Delegate to a separate method to keep this clearer...                  if (amDesignator == "" || pmDesignator == "")                  {                      int specifiedDesignatorValue = amDesignator == "" ? 1 : 0;                      string specifiedDesignator = specifiedDesignatorValue == 1 ? pmDesignator : amDesignator;                      HandleHalfAmPmDesignator(count' specifiedDesignator' specifiedDesignatorValue' hourOfDayGetter' amPmSetter' builder);                      return;                  }                  CompareInfo compareInfo = builder.FormatInfo.CompareInfo;                  // Single character designator                  if (count == 1)                  {                      // It's not entirely clear whether this is the right thing to do... there's no nice                      // way of providing a single-character case-insensitive match.                      string amFirst = amDesignator.Substring(0' 1);                      string pmFirst = pmDesignator.Substring(0' 1);                      builder.AddParseAction((str' bucket) =>                      {                          if (str.MatchCaseInsensitive(amFirst' compareInfo' true))                          {                              amPmSetter(bucket' 0);                              return null;                          }                          if (str.MatchCaseInsensitive(pmFirst' compareInfo' true))                          {                              amPmSetter(bucket' 1);                              return null;                          }                          return ParseResult<TResult>.MissingAmPmDesignator(str);                      });                      builder.AddFormatAction((value' sb) => sb.Append(hourOfDayGetter(value) > 11 ? pmDesignator[0] : amDesignator[0]));                      return;                  }                  // Full designator                  builder.AddParseAction((str' bucket) =>                  {                      // Could use the "match longest" approach' but with only two it feels a bit silly to build a list...                      bool pmLongerThanAm = pmDesignator.Length > amDesignator.Length;                      string longerDesignator = pmLongerThanAm ? pmDesignator : amDesignator;                      string shorterDesignator = pmLongerThanAm ? amDesignator : pmDesignator;                      int longerValue = pmLongerThanAm ? 1 : 0;                      if (str.MatchCaseInsensitive(longerDesignator' compareInfo' true))                      {                          amPmSetter(bucket' longerValue);                          return null;                      }                      if (str.MatchCaseInsensitive(shorterDesignator' compareInfo' true))                      {                          amPmSetter(bucket' 1 - longerValue);                          return null;                      }                      return ParseResult<TResult>.MissingAmPmDesignator(str);                  });                  builder.AddFormatAction((value' sb) => sb.Append(hourOfDayGetter(value) > 11 ? pmDesignator : amDesignator));              };
Magic Number,NodaTime.Text.Patterns,TimePatternHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\Patterns\TimePatternHelper.cs,CreateAmPmHandler,The following statement contains a magic number: return (pattern' builder) =>              {                  int count = pattern.GetRepeatCount(2);                  builder.AddField(PatternFields.AmPm' pattern.Current);                    string amDesignator = builder.FormatInfo.AMDesignator;                  string pmDesignator = builder.FormatInfo.PMDesignator;                    // If we don't have an AM or PM designator' we're nearly done. Set the AM/PM designator                  // to the special value of 2' meaning "take it from the template".                  if (amDesignator == "" && pmDesignator == "")                  {                      builder.AddParseAction((str' bucket) =>                      {                          amPmSetter(bucket' 2);                          return null;                      });                      return;                  }                  // Odd scenario (but present in af-ZA for .NET 2) - exactly one of the AM/PM designator is valid.                  // Delegate to a separate method to keep this clearer...                  if (amDesignator == "" || pmDesignator == "")                  {                      int specifiedDesignatorValue = amDesignator == "" ? 1 : 0;                      string specifiedDesignator = specifiedDesignatorValue == 1 ? pmDesignator : amDesignator;                      HandleHalfAmPmDesignator(count' specifiedDesignator' specifiedDesignatorValue' hourOfDayGetter' amPmSetter' builder);                      return;                  }                  CompareInfo compareInfo = builder.FormatInfo.CompareInfo;                  // Single character designator                  if (count == 1)                  {                      // It's not entirely clear whether this is the right thing to do... there's no nice                      // way of providing a single-character case-insensitive match.                      string amFirst = amDesignator.Substring(0' 1);                      string pmFirst = pmDesignator.Substring(0' 1);                      builder.AddParseAction((str' bucket) =>                      {                          if (str.MatchCaseInsensitive(amFirst' compareInfo' true))                          {                              amPmSetter(bucket' 0);                              return null;                          }                          if (str.MatchCaseInsensitive(pmFirst' compareInfo' true))                          {                              amPmSetter(bucket' 1);                              return null;                          }                          return ParseResult<TResult>.MissingAmPmDesignator(str);                      });                      builder.AddFormatAction((value' sb) => sb.Append(hourOfDayGetter(value) > 11 ? pmDesignator[0] : amDesignator[0]));                      return;                  }                  // Full designator                  builder.AddParseAction((str' bucket) =>                  {                      // Could use the "match longest" approach' but with only two it feels a bit silly to build a list...                      bool pmLongerThanAm = pmDesignator.Length > amDesignator.Length;                      string longerDesignator = pmLongerThanAm ? pmDesignator : amDesignator;                      string shorterDesignator = pmLongerThanAm ? amDesignator : pmDesignator;                      int longerValue = pmLongerThanAm ? 1 : 0;                      if (str.MatchCaseInsensitive(longerDesignator' compareInfo' true))                      {                          amPmSetter(bucket' longerValue);                          return null;                      }                      if (str.MatchCaseInsensitive(shorterDesignator' compareInfo' true))                      {                          amPmSetter(bucket' 1 - longerValue);                          return null;                      }                      return ParseResult<TResult>.MissingAmPmDesignator(str);                  });                  builder.AddFormatAction((value' sb) => sb.Append(hourOfDayGetter(value) > 11 ? pmDesignator : amDesignator));              };
Magic Number,NodaTime.Text.Patterns,TimePatternHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\Patterns\TimePatternHelper.cs,HandleHalfAmPmDesignator,The following statement contains a magic number: builder.AddFormatAction((value' sb) =>                  {                      // Only append anything if it's the non-empty designator.                      if (hourOfDayGetter(value) / 12 == specifiedDesignatorValue)                      {                          sb.Append(specifiedDesignator[0]);                      }                  });
Magic Number,NodaTime.Text.Patterns,TimePatternHelper,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\Patterns\TimePatternHelper.cs,HandleHalfAmPmDesignator,The following statement contains a magic number: builder.AddFormatAction((value' sb) =>              {                  // Only append anything if it's the non-empty designator.                  if (hourOfDayGetter(value) / 12 == specifiedDesignatorValue)                  {                      sb.Append(specifiedDesignator);                  }              });
Magic Number,NodaTime.TimeZones,BclDateTimeZone,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\BclDateTimeZone.cs,AreWindowsStyleRules,The following statement contains a magic number: bool IsWindowsRule(TimeZoneInfo.AdjustmentRule rule) =>                  rule.DateStart.Month == 1 && rule.DateStart.Day == 1 && rule.DateStart.TimeOfDay.Ticks == 0 &&                  rule.DateEnd.Month == 12 && rule.DateEnd.Day == 31 && rule.DateEnd.TimeOfDay.Ticks == 0;
Magic Number,NodaTime.TimeZones,BclDateTimeZone,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\BclDateTimeZone.cs,AreWindowsStyleRules,The following statement contains a magic number: bool IsWindowsRule(TimeZoneInfo.AdjustmentRule rule) =>                  rule.DateStart.Month == 1 && rule.DateStart.Day == 1 && rule.DateStart.TimeOfDay.Ticks == 0 &&                  rule.DateEnd.Month == 12 && rule.DateEnd.Day == 31 && rule.DateEnd.TimeOfDay.Ticks == 0;
Magic Number,NodaTime.TimeZones,BclAdjustmentRule,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\BclDateTimeZone.cs,FromUnixAdjustmentRule,The following statement contains a magic number: bclSavings.Hours < -14
Magic Number,NodaTime.TimeZones,BclAdjustmentRule,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\BclDateTimeZone.cs,ConvertTransition,The following statement contains a magic number: transitionTime.Week == 5
Magic Number,NodaTime.TimeZones,PrecalculatedDateTimeZone,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\PrecalculatedDateTimeZone.cs,GetZoneInterval,The following statement contains a magic number: int current = (lower + upper) / 2;
Magic Number,NodaTime.TimeZones,Resolvers,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\Resolvers.cs,CreateMappingResolver,The following statement contains a magic number: return mapping =>                  Preconditions.CheckNotNull(mapping' nameof(mapping)).Count switch                  {                      0 => skippedTimeResolver(mapping.LocalDateTime' mapping.Zone' mapping.EarlyInterval' mapping.LateInterval)'                      1 => mapping.First()'                      2 => ambiguousTimeResolver(mapping.First()' mapping.Last())'                      _ => throw new InvalidOperationException("Mapping has count outside range 0-2; should not happen.")                  };
Magic Number,NodaTime.TimeZones,Transition,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\Transition.cs,GetHashCode,The following statement contains a magic number: int hash = 23;
Magic Number,NodaTime.TimeZones,Transition,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\Transition.cs,GetHashCode,The following statement contains a magic number: hash = hash * 31 + Instant.GetHashCode();
Magic Number,NodaTime.TimeZones,Transition,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\Transition.cs,GetHashCode,The following statement contains a magic number: hash = hash * 31 + NewOffset.GetHashCode();
Magic Number,NodaTime.TimeZones,TzdbDateTimeZoneSource,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\TzdbDateTimeZoneSource.cs,GuessZoneIdByTransitionsUncached,The following statement contains a magic number: Instant startOfNextYear = Instant.FromUtc(thisYear + 5' 1' 1' 0' 0);
Magic Number,NodaTime.TimeZones,TzdbDateTimeZoneSource,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\TzdbDateTimeZoneSource.cs,GuessZoneIdByTransitionsUncached,The following statement contains a magic number: int lowestFailureScore = (instants.Count * 30) / 100;
Magic Number,NodaTime.TimeZones,TzdbDateTimeZoneSource,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\TzdbDateTimeZoneSource.cs,GuessZoneIdByTransitionsUncached,The following statement contains a magic number: int lowestFailureScore = (instants.Count * 30) / 100;
Magic Number,NodaTime.TimeZones,TzdbZone1970Location,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\TzdbZone1970Location.cs,TzdbZone1970Location,The following statement contains a magic number: Preconditions.CheckArgumentRange(nameof(latitudeSeconds)' latitudeSeconds' -90 * 3600' 90 * 3600);
Magic Number,NodaTime.TimeZones,TzdbZone1970Location,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\TzdbZone1970Location.cs,TzdbZone1970Location,The following statement contains a magic number: Preconditions.CheckArgumentRange(nameof(latitudeSeconds)' latitudeSeconds' -90 * 3600' 90 * 3600);
Magic Number,NodaTime.TimeZones,TzdbZone1970Location,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\TzdbZone1970Location.cs,TzdbZone1970Location,The following statement contains a magic number: Preconditions.CheckArgumentRange(nameof(latitudeSeconds)' latitudeSeconds' -90 * 3600' 90 * 3600);
Magic Number,NodaTime.TimeZones,TzdbZone1970Location,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\TzdbZone1970Location.cs,TzdbZone1970Location,The following statement contains a magic number: Preconditions.CheckArgumentRange(nameof(latitudeSeconds)' latitudeSeconds' -90 * 3600' 90 * 3600);
Magic Number,NodaTime.TimeZones,TzdbZone1970Location,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\TzdbZone1970Location.cs,TzdbZone1970Location,The following statement contains a magic number: Preconditions.CheckArgumentRange(nameof(longitudeSeconds)' longitudeSeconds' -180 * 3600' 180 * 3600);
Magic Number,NodaTime.TimeZones,TzdbZone1970Location,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\TzdbZone1970Location.cs,TzdbZone1970Location,The following statement contains a magic number: Preconditions.CheckArgumentRange(nameof(longitudeSeconds)' longitudeSeconds' -180 * 3600' 180 * 3600);
Magic Number,NodaTime.TimeZones,TzdbZone1970Location,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\TzdbZone1970Location.cs,TzdbZone1970Location,The following statement contains a magic number: Preconditions.CheckArgumentRange(nameof(longitudeSeconds)' longitudeSeconds' -180 * 3600' 180 * 3600);
Magic Number,NodaTime.TimeZones,TzdbZone1970Location,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\TzdbZone1970Location.cs,TzdbZone1970Location,The following statement contains a magic number: Preconditions.CheckArgumentRange(nameof(longitudeSeconds)' longitudeSeconds' -180 * 3600' 180 * 3600);
Magic Number,NodaTime.TimeZones,Country,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\TzdbZone1970Location.cs,Country,The following statement contains a magic number: Preconditions.CheckArgument(Code.Length == 2' nameof(code)' "Country code must be two characters");
Magic Number,NodaTime.TimeZones,TzdbZoneLocation,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\TzdbZoneLocation.cs,TzdbZoneLocation,The following statement contains a magic number: Preconditions.CheckArgumentRange(nameof(latitudeSeconds)' latitudeSeconds' -90 * 3600' 90 * 3600);
Magic Number,NodaTime.TimeZones,TzdbZoneLocation,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\TzdbZoneLocation.cs,TzdbZoneLocation,The following statement contains a magic number: Preconditions.CheckArgumentRange(nameof(latitudeSeconds)' latitudeSeconds' -90 * 3600' 90 * 3600);
Magic Number,NodaTime.TimeZones,TzdbZoneLocation,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\TzdbZoneLocation.cs,TzdbZoneLocation,The following statement contains a magic number: Preconditions.CheckArgumentRange(nameof(latitudeSeconds)' latitudeSeconds' -90 * 3600' 90 * 3600);
Magic Number,NodaTime.TimeZones,TzdbZoneLocation,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\TzdbZoneLocation.cs,TzdbZoneLocation,The following statement contains a magic number: Preconditions.CheckArgumentRange(nameof(latitudeSeconds)' latitudeSeconds' -90 * 3600' 90 * 3600);
Magic Number,NodaTime.TimeZones,TzdbZoneLocation,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\TzdbZoneLocation.cs,TzdbZoneLocation,The following statement contains a magic number: Preconditions.CheckArgumentRange(nameof(longitudeSeconds)' longitudeSeconds' -180 * 3600' 180 * 3600);
Magic Number,NodaTime.TimeZones,TzdbZoneLocation,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\TzdbZoneLocation.cs,TzdbZoneLocation,The following statement contains a magic number: Preconditions.CheckArgumentRange(nameof(longitudeSeconds)' longitudeSeconds' -180 * 3600' 180 * 3600);
Magic Number,NodaTime.TimeZones,TzdbZoneLocation,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\TzdbZoneLocation.cs,TzdbZoneLocation,The following statement contains a magic number: Preconditions.CheckArgumentRange(nameof(longitudeSeconds)' longitudeSeconds' -180 * 3600' 180 * 3600);
Magic Number,NodaTime.TimeZones,TzdbZoneLocation,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\TzdbZoneLocation.cs,TzdbZoneLocation,The following statement contains a magic number: Preconditions.CheckArgumentRange(nameof(longitudeSeconds)' longitudeSeconds' -180 * 3600' 180 * 3600);
Magic Number,NodaTime.TimeZones,TzdbZoneLocation,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\TzdbZoneLocation.cs,TzdbZoneLocation,The following statement contains a magic number: Preconditions.CheckArgument(CountryCode.Length == 2' nameof(countryCode)' "Country code must be two characters");
Magic Number,NodaTime.TimeZones,ZoneEqualityComparer,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\ZoneEqualityComparer.cs,GetHashCode,The following statement contains a magic number: int hash = 19;
Magic Number,NodaTime.TimeZones,ZoneEqualityComparer,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\ZoneEqualityComparer.cs,GetHashCode,The following statement contains a magic number: hash = hash * 31 + zoneIntervalComparer.GetHashCode(zoneInterval);
Magic Number,NodaTime.TimeZones,ZoneLocalMapping,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\ZoneLocalMapping.cs,ZoneLocalMapping,The following statement contains a magic number: Preconditions.DebugCheckArgumentRange(nameof(count)' count' 0' 2);
Magic Number,NodaTime.TimeZones,ZoneLocalMapping,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\ZoneLocalMapping.cs,Single,The following statement contains a magic number: switch (Count)              {                  case 0: throw new SkippedTimeException(LocalDateTime' Zone);                  case 1: return BuildZonedDateTime(EarlyInterval);                  case 2:                      throw new AmbiguousTimeException(                          BuildZonedDateTime(EarlyInterval)'                          BuildZonedDateTime(LateInterval));                  default: throw new InvalidOperationException("Can't happen");              }
Magic Number,NodaTime.TimeZones,ZoneLocalMapping,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\ZoneLocalMapping.cs,First,The following statement contains a magic number: switch (Count)              {                  case 0: throw new SkippedTimeException(LocalDateTime' Zone);                  case 1:                  case 2: return BuildZonedDateTime(EarlyInterval);                  default: throw new InvalidOperationException("Can't happen");              }
Magic Number,NodaTime.TimeZones,ZoneLocalMapping,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\ZoneLocalMapping.cs,Last,The following statement contains a magic number: switch (Count)              {                  case 0: throw new SkippedTimeException(LocalDateTime' Zone);                  case 1: return BuildZonedDateTime(EarlyInterval);                  case 2: return BuildZonedDateTime(LateInterval);                  default: throw new InvalidOperationException("Can't happen");              }
Magic Number,NodaTime.TimeZones,ZoneRecurrence,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\ZoneRecurrence.cs,ZoneRecurrence,The following statement contains a magic number: Preconditions.CheckArgument(fromYear == int.MinValue || (fromYear >= -9998 && fromYear <= 9999)' nameof(fromYear)'                  "fromYear must be in the range [-9998' 9999] or Int32.MinValue");
Magic Number,NodaTime.TimeZones,ZoneRecurrence,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\ZoneRecurrence.cs,ZoneRecurrence,The following statement contains a magic number: Preconditions.CheckArgument(fromYear == int.MinValue || (fromYear >= -9998 && fromYear <= 9999)' nameof(fromYear)'                  "fromYear must be in the range [-9998' 9999] or Int32.MinValue");
Magic Number,NodaTime.TimeZones,ZoneRecurrence,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\ZoneRecurrence.cs,ZoneRecurrence,The following statement contains a magic number: Preconditions.CheckArgument(toYear == int.MaxValue || (toYear >= -9998 && toYear <= 9999)' nameof(toYear)'                  "toYear must be in the range [-9998' 9999] or Int32.MaxValue");
Magic Number,NodaTime.TimeZones,ZoneRecurrence,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\ZoneRecurrence.cs,ZoneRecurrence,The following statement contains a magic number: Preconditions.CheckArgument(toYear == int.MaxValue || (toYear >= -9998 && toYear <= 9999)' nameof(toYear)'                  "toYear must be in the range [-9998' 9999] or Int32.MaxValue");
Magic Number,NodaTime.TimeZones,ZoneYearOffset,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\ZoneYearOffset.cs,ZoneYearOffset,The following statement contains a magic number: VerifyFieldValue(1' 12' "monthOfYear"' monthOfYear' false);
Magic Number,NodaTime.TimeZones,ZoneYearOffset,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\ZoneYearOffset.cs,ZoneYearOffset,The following statement contains a magic number: VerifyFieldValue(1' 31' "dayOfMonth"' dayOfMonth' true);
Magic Number,NodaTime.TimeZones,ZoneYearOffset,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\ZoneYearOffset.cs,ZoneYearOffset,The following statement contains a magic number: VerifyFieldValue(1' 7' "dayOfWeek"' dayOfWeek' false);
Magic Number,NodaTime.TimeZones,ZoneYearOffset,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\ZoneYearOffset.cs,GetOccurrenceForYear,The following statement contains a magic number: actualDayOfMonth = 28;
Magic Number,NodaTime.TimeZones,ZoneYearOffset,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\ZoneYearOffset.cs,GetOccurrenceForYear,The following statement contains a magic number: monthOfYear == 2 && dayOfMonth == 29 && !CalendarSystem.Iso.IsLeapYear(year)
Magic Number,NodaTime.TimeZones,ZoneYearOffset,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\ZoneYearOffset.cs,GetOccurrenceForYear,The following statement contains a magic number: monthOfYear == 2 && dayOfMonth == 29 && !CalendarSystem.Iso.IsLeapYear(year)
Magic Number,NodaTime.TimeZones,ZoneYearOffset,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\ZoneYearOffset.cs,GetOccurrenceForYear,The following statement contains a magic number: diff -= 7;
Magic Number,NodaTime.TimeZones,ZoneYearOffset,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\ZoneYearOffset.cs,GetOccurrenceForYear,The following statement contains a magic number: year == 9999 && date.Month == 12 && date.Day == 31
Magic Number,NodaTime.TimeZones,ZoneYearOffset,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\ZoneYearOffset.cs,GetOccurrenceForYear,The following statement contains a magic number: year == 9999 && date.Month == 12 && date.Day == 31
Magic Number,NodaTime.TimeZones,ZoneYearOffset,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\ZoneYearOffset.cs,GetOccurrenceForYear,The following statement contains a magic number: year == 9999 && date.Month == 12 && date.Day == 31
Magic Number,NodaTime.TimeZones,ZoneYearOffset,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\ZoneYearOffset.cs,Write,The following statement contains a magic number: int flags = ((int) Mode << 5) |                          (dayOfWeek << 2) |                          (AdvanceDayOfWeek ? 2 : 0) |                          (addDay ? 1 : 0);
Magic Number,NodaTime.TimeZones,ZoneYearOffset,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\ZoneYearOffset.cs,Write,The following statement contains a magic number: int flags = ((int) Mode << 5) |                          (dayOfWeek << 2) |                          (AdvanceDayOfWeek ? 2 : 0) |                          (addDay ? 1 : 0);
Magic Number,NodaTime.TimeZones,ZoneYearOffset,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\ZoneYearOffset.cs,Write,The following statement contains a magic number: int flags = ((int) Mode << 5) |                          (dayOfWeek << 2) |                          (AdvanceDayOfWeek ? 2 : 0) |                          (addDay ? 1 : 0);
Magic Number,NodaTime.TimeZones,ZoneYearOffset,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\ZoneYearOffset.cs,Read,The following statement contains a magic number: var mode = (TransitionMode) (flags >> 5);
Magic Number,NodaTime.TimeZones,ZoneYearOffset,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\ZoneYearOffset.cs,Read,The following statement contains a magic number: var dayOfWeek = (flags >> 2) & 7;
Magic Number,NodaTime.TimeZones,ZoneYearOffset,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\ZoneYearOffset.cs,Read,The following statement contains a magic number: var dayOfWeek = (flags >> 2) & 7;
Magic Number,NodaTime.TimeZones,ZoneYearOffset,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\ZoneYearOffset.cs,Read,The following statement contains a magic number: var advance = (flags & 2) != 0;
Magic Number,NodaTime.TimeZones.IO,DateTimeZoneReader,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\IO\DateTimeZoneReader.cs,ReadVarint,The following statement contains a magic number: shift += 7;
Magic Number,NodaTime.TimeZones.IO,DateTimeZoneReader,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\IO\DateTimeZoneReader.cs,ReadMilliseconds,The following statement contains a magic number: millis = firstByte * (30 * NodaConstants.MillisecondsPerMinute);
Magic Number,NodaTime.TimeZones.IO,DateTimeZoneReader,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\IO\DateTimeZoneReader.cs,ReadInt16,The following statement contains a magic number: return (high << 8) | low;
Magic Number,NodaTime.TimeZones.IO,DateTimeZoneReader,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\IO\DateTimeZoneReader.cs,ReadInt32,The following statement contains a magic number: return (high << 16) | low;
Magic Number,NodaTime.TimeZones.IO,DateTimeZoneReader,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\IO\DateTimeZoneReader.cs,ReadInt64,The following statement contains a magic number: return (high << 32) | low;
Magic Number,NodaTime.TimeZones.IO,DateTimeZoneWriter,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\IO\DateTimeZoneWriter.cs,WriteSignedCount,The following statement contains a magic number: WriteVarint((uint) ((count >> 31) ^ (count << 1)));
Magic Number,NodaTime.TimeZones.IO,DateTimeZoneWriter,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\IO\DateTimeZoneWriter.cs,WriteVarint,The following statement contains a magic number: value = value >> 7;
Magic Number,NodaTime.TimeZones.IO,DateTimeZoneWriter,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\IO\DateTimeZoneWriter.cs,WriteMilliseconds,The following statement contains a magic number: int units = millis / (30 * MillisecondsPerMinute);
Magic Number,NodaTime.TimeZones.IO,DateTimeZoneWriter,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\IO\DateTimeZoneWriter.cs,WriteMilliseconds,The following statement contains a magic number: millis % (30 * MillisecondsPerMinute) == 0
Magic Number,NodaTime.TimeZones.IO,DateTimeZoneWriter,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\IO\DateTimeZoneWriter.cs,WriteInt16,The following statement contains a magic number: WriteByte((byte) ((value >> 8) & 0xff));
Magic Number,NodaTime.TimeZones.IO,DateTimeZoneWriter,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\IO\DateTimeZoneWriter.cs,WriteInt32,The following statement contains a magic number: WriteInt16((short) (value >> 16));
Magic Number,NodaTime.TimeZones.IO,DateTimeZoneWriter,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\TimeZones\IO\DateTimeZoneWriter.cs,WriteInt64,The following statement contains a magic number: WriteInt32((int) (value >> 32));
Magic Number,NodaTime.Utility,TickArithmetic,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Utility\TickArithmetic.cs,TicksToDaysAndTickOfDay,The following statement contains a magic number: int days = (int) ((ticks >> 14) / 52734375L);
Magic Number,NodaTime.Utility,TickArithmetic,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Utility\TickArithmetic.cs,TicksToDaysAndTickOfDay,The following statement contains a magic number: int days = (int) ((ticks >> 14) / 52734375L);
Magic Number,NodaTime.Utility,TickArithmetic,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Utility\TickArithmetic.cs,NonNegativeTicksToDaysAndTickOfDay,The following statement contains a magic number: int days = (int) ((ticks >> 14) / 52734375L);
Magic Number,NodaTime.Utility,TickArithmetic,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Utility\TickArithmetic.cs,NonNegativeTicksToDaysAndTickOfDay,The following statement contains a magic number: int days = (int) ((ticks >> 14) / 52734375L);
Missing Default,NodaTime,Period,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Period.cs,Between,The following switch statement is missing a default case: switch (units)              {                  case PeriodUnits.Years: return FromYears(DatePeriodFields.YearsField.UnitsBetween(start.Date' endDate));                  case PeriodUnits.Months: return FromMonths(DatePeriodFields.MonthsField.UnitsBetween(start.Date' endDate));                  case PeriodUnits.Weeks: return FromWeeks(DatePeriodFields.WeeksField.UnitsBetween(start.Date' endDate));                  case PeriodUnits.Days: return FromDays(DaysBetween(start.Date' endDate));                  case PeriodUnits.Hours: return FromHours(TimePeriodField.Hours.UnitsBetween(start' end));                  case PeriodUnits.Minutes: return FromMinutes(TimePeriodField.Minutes.UnitsBetween(start' end));                  case PeriodUnits.Seconds: return FromSeconds(TimePeriodField.Seconds.UnitsBetween(start' end));                  case PeriodUnits.Milliseconds: return FromMilliseconds(TimePeriodField.Milliseconds.UnitsBetween(start' end));                  case PeriodUnits.Ticks: return FromTicks(TimePeriodField.Ticks.UnitsBetween(start' end));                  case PeriodUnits.Nanoseconds: return FromNanoseconds(TimePeriodField.Nanoseconds.UnitsBetween(start' end));              }
Missing Default,NodaTime,Period,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Period.cs,Between,The following switch statement is missing a default case: switch (units)              {                  case PeriodUnits.Years: return FromYears(DatePeriodFields.YearsField.UnitsBetween(start' end));                  case PeriodUnits.Months: return FromMonths(DatePeriodFields.MonthsField.UnitsBetween(start' end));                  case PeriodUnits.Weeks: return FromWeeks(DatePeriodFields.WeeksField.UnitsBetween(start' end));                  case PeriodUnits.Days: return FromDays(DaysBetween(start' end));              }
Missing Default,NodaTime,Period,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Period.cs,Between,The following switch statement is missing a default case: switch (units)              {                  case PeriodUnits.Hours: return FromHours(remaining / NanosecondsPerHour);                  case PeriodUnits.Minutes: return FromMinutes(remaining / NanosecondsPerMinute);                  case PeriodUnits.Seconds: return FromSeconds(remaining / NanosecondsPerSecond);                  case PeriodUnits.Milliseconds: return FromMilliseconds(remaining / NanosecondsPerMillisecond);                  case PeriodUnits.Ticks: return FromTicks(remaining / NanosecondsPerTick);                  case PeriodUnits.Nanoseconds: return FromNanoseconds(remaining);              }
Missing Default,NodaTime.Text,AnnualDateParseBucket,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\AnnualDatePatternParser.cs,DetermineMonth,The following switch statement is missing a default case: switch (usedFields & (PatternFields.MonthOfYearNumeric | PatternFields.MonthOfYearText))                  {                      case PatternFields.MonthOfYearNumeric:                          // No-op                          break;                      case PatternFields.MonthOfYearText:                          MonthOfYearNumeric = MonthOfYearText;                          break;                      case PatternFields.MonthOfYearNumeric | PatternFields.MonthOfYearText:                          if (MonthOfYearNumeric != MonthOfYearText)                          {                              return ParseResult<AnnualDate>.InconsistentMonthValues(text);                          }                          // No need to change MonthOfYearNumeric - this was just a check                          break;                      case 0:                          MonthOfYearNumeric = TemplateValue.Month;                          break;                  }
Missing Default,NodaTime.Text,LocalDateParseBucket,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\LocalDatePatternParser.cs,DetermineMonth,The following switch statement is missing a default case: switch (usedFields & (PatternFields.MonthOfYearNumeric | PatternFields.MonthOfYearText))                  {                      case PatternFields.MonthOfYearNumeric:                          // No-op                          break;                      case PatternFields.MonthOfYearText:                          MonthOfYearNumeric = MonthOfYearText;                          break;                      case PatternFields.MonthOfYearNumeric | PatternFields.MonthOfYearText:                          if (MonthOfYearNumeric != MonthOfYearText)                          {                              return ParseResult<LocalDate>.InconsistentMonthValues(text);                          }                          // No need to change MonthOfYearNumeric - this was just a check                          break;                      case 0:                          MonthOfYearNumeric = TemplateValue.Month;                          break;                  }
Missing Default,NodaTime.Text,LocalTimeParseBucket,C:\research\architectureSmells\repos\nodatime_nodatime\src\NodaTime\Text\LocalTimePatternParser.cs,DetermineHour,The following switch statement is missing a default case: switch (usedFields & (PatternFields.Hours12 | PatternFields.AmPm))                  {                      case PatternFields.Hours12 | PatternFields.AmPm:                          hour = (Hours12 % 12) + AmPm * 12;                          break;                      case PatternFields.Hours12:                          // Preserve AM/PM from template value                          hour = (Hours12 % 12) + (TemplateValue.Hour / 12) * 12;                          break;                      case PatternFields.AmPm:                          // Preserve 12-hour hour of day from template value' use specified AM/PM                          hour = (TemplateValue.Hour % 12) + AmPm * 12;                          break;                      case 0:                          hour = TemplateValue.Hour;                          break;                  }
