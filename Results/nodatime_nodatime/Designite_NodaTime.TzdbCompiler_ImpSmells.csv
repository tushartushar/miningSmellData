Implementation smell,Namespace,Class,File,Method,Description
Long Method,NodaTime.TzdbCompiler.Tzdb,DateTimeZoneBuilder,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Tzdb\DateTimeZoneBuilder.cs,AddIntervals,The method has 144 lines of code.
Complex Method,NodaTime.TzdbCompiler.Tzdb,DateTimeZoneBuilder,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Tzdb\DateTimeZoneBuilder.cs,AddIntervals,Cyclomatic complexity of the method is 13
Complex Method,NodaTime.TzdbCompiler.Tzdb,Tokens,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Tzdb\Tokens.cs,Tokenize,Cyclomatic complexity of the method is 8
Complex Method,NodaTime.TzdbCompiler.Tzdb,TzdbStreamWriter,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Tzdb\TzdbStreamWriter.cs,Write,Cyclomatic complexity of the method is 9
Complex Method,CommandLine,LongOptionParser,C:\repos\nodatime_nodatime\lib\commandline\CommandLine.cs,Parse,Cyclomatic complexity of the method is 10
Complex Method,CommandLine,OptionGroupParser,C:\repos\nodatime_nodatime\lib\commandline\CommandLine.cs,Parse,Cyclomatic complexity of the method is 12
Complex Method,CommandLine.Text,HelpText,C:\repos\nodatime_nodatime\lib\commandline\CommandLineText.cs,AutoBuild,Cyclomatic complexity of the method is 8
Complex Method,CommandLine.Text,HelpText,C:\repos\nodatime_nodatime\lib\commandline\CommandLineText.cs,RenderParsingErrorsText,Cyclomatic complexity of the method is 10
Complex Method,CommandLine.Text,HelpText,C:\repos\nodatime_nodatime\lib\commandline\CommandLineText.cs,AddOption,Cyclomatic complexity of the method is 10
Long Parameter List,NodaTime.TzdbCompiler.Tzdb,ZoneLine,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Tzdb\ZoneLine.cs,ZoneLine,The method has 6 parameters. Parameters: name' offset' rules' format' untilYear' untilYearOffset
Long Parameter List,NodaTime.TzdbCompiler.Tzdb,ZoneRuleSet,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Tzdb\ZoneRuleSet.cs,ZoneRuleSet,The method has 5 parameters. Parameters: name' standardOffset' savings' upperYear' upperYearOffset
Long Parameter List,CommandLine.Text,MultiLineTextAttribute,C:\repos\nodatime_nodatime\lib\commandline\CommandLineText.cs,MultiLineTextAttribute,The method has 5 parameters. Parameters: line1' line2' line3' line4' line5
Long Parameter List,CommandLine.Text,AssemblyLicenseAttribute,C:\repos\nodatime_nodatime\lib\commandline\CommandLineText.cs,AssemblyLicenseAttribute,The method has 5 parameters. Parameters: line1' line2' line3' line4' line5
Long Parameter List,CommandLine.Text,AssemblyUsageAttribute,C:\repos\nodatime_nodatime\lib\commandline\CommandLineText.cs,AssemblyUsageAttribute,The method has 5 parameters. Parameters: line1' line2' line3' line4' line5
Long Identifier,NodaTime.TzdbCompiler.Tzdb,TzdbStreamWriter,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Tzdb\TzdbStreamWriter.cs,Write,The length of the parameter additionalWindowsNameToIdMappings is 33.
Long Statement,NodaTime.TzdbCompiler,CompilerOptions,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\CompilerOptions.cs,GetUsage,The length of the statement  "            help.AddPreOptionsLine("Usage: NodaTime.TzdbCompiler -s <tzdb directory> -w <windowsZone.xml file/dir> -o <output file> [-t ResX/Resource/NodaZoneData]"); " is 154.
Long Statement,NodaTime.TzdbCompiler,Program,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Program.cs,Main,The length of the statement  "            ICommandLineParser parser = new CommandLineParser(new CommandLineParserSettings(Console.Error) { MutuallyExclusive = true }); " is 125.
Long Statement,NodaTime.TzdbCompiler,Program,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Program.cs,LoadWindowsZones,The length of the statement  "                throw new Exception($"No zones files suitable for version {targetTzdbVersion}. Found versions targeting: [{versions}]"); " is 120.
Long Statement,NodaTime.TzdbCompiler,Program,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Program.cs,LoadWindowsZones,The length of the statement  "            Console.WriteLine($"Picked Windows Zones with TZDB version {bestFile.TzdbVersion} out of [{versions}] as best match for {targetTzdbVersion}"); " is 142.
Long Statement,NodaTime.TzdbCompiler.Tzdb,CldrWindowsZonesParser,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Tzdb\CldrWindowsZonesParser.cs,Parse,The length of the statement  "            var tzdbVersion = document.Root.Element("windowsZones")?.Element("mapTimezones")?.Attribute("typeVersion")?.Value ?? ""; " is 120.
Long Statement,NodaTime.TzdbCompiler.Tzdb,CldrWindowsZonesParser,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Tzdb\CldrWindowsZonesParser.cs,Parse,The length of the statement  "            var windowsVersion = document.Root.Element("windowsZones")?.Element("mapTimezones")?.Attribute("otherVersion")?.Value ?? ""; " is 124.
Long Statement,NodaTime.TzdbCompiler.Tzdb,DateTimeZoneBuilder,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Tzdb\DateTimeZoneBuilder.cs,Build,The length of the statement  "            Preconditions.CheckArgument(ruleSets.Count > 0' nameof(ruleSets)' "Cannot create a time zone without any Zone entries"); " is 120.
Long Statement,NodaTime.TzdbCompiler.Tzdb,DateTimeZoneBuilder,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Tzdb\DateTimeZoneBuilder.cs,AddIntervals,The length of the statement  "                    .Select(rule => new { rule' prev = rule.PreviousOrSame(start' lastZoneInterval.StandardOffset' lastZoneInterval.Savings) }) " is 123.
Long Statement,NodaTime.TzdbCompiler.Tzdb,ParserHelper,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Tzdb\ParserHelper.cs,ConvertMinuteToTicks,The length of the statement  "            int value = Int32.Parse(text' NumberStyles.AllowLeadingWhite | NumberStyles.AllowTrailingWhite' CultureInfo.InvariantCulture); " is 126.
Long Statement,NodaTime.TzdbCompiler.Tzdb,ParserHelper,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Tzdb\ParserHelper.cs,ConvertSecondsWithFractionalToTicks,The length of the statement  "            double number = Double.Parse(text' NumberStyles.AllowLeadingWhite | NumberStyles.AllowTrailingWhite | NumberStyles.AllowDecimalPoint' " is 133.
Long Statement,NodaTime.TzdbCompiler.Tzdb,TzdbStreamWriter,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Tzdb\TzdbStreamWriter.cs,Write,The length of the statement  "            var stringPool = CreateOptimizedStringPool(zones' database.ZoneLocations' database.Zone1970Locations' cldrWindowsZones); " is 120.
Long Statement,NodaTime.TzdbCompiler.Tzdb,TzdbStreamWriter,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Tzdb\TzdbStreamWriter.cs,Write,The length of the statement  "                (additionalWindowsNameToIdMappings.ToDictionary(pair => pair.Key' pair => cldrWindowsZones.PrimaryMapping[pair.Value])); " is 120.
Long Statement,NodaTime.TzdbCompiler.Tzdb,TzdbZoneInfoCompiler,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Tzdb\TzdbZoneInfoCompiler.cs,LoadLocationFiles,The length of the statement  "                var iso3166Dict = iso3166.ToDictionary(bits => bits[0]' bits => new TzdbZone1970Location.Country(code: bits[0]' name: bits[1])); " is 128.
Long Statement,NodaTime.TzdbCompiler.Tzdb,TzdbZoneLocationParser,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Tzdb\TzdbZoneLocationParser.cs,ParseLocation,The length of the statement  "            Preconditions.CheckArgument(bits.Length == 3 || bits.Length == 4' "line"' "Line must have 3 or 4 tab-separated values"); " is 120.
Long Statement,NodaTime.TzdbCompiler.Tzdb,TzdbZoneLocationParser,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Tzdb\TzdbZoneLocationParser.cs,ParseEnhancedLocation,The length of the statement  "            Preconditions.CheckArgument(bits.Length == 3 || bits.Length == 4' "line"' "Line must have 3 or 4 tab-separated values"); " is 120.
Long Statement,NodaTime.TzdbCompiler.Tzdb,ZoneLine,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Tzdb\ZoneLine.cs,Equals,The length of the statement  "            var result = Name == other.Name && StandardOffset == other.StandardOffset && Rules == other.Rules && Format == other.Format && UntilYear == other.UntilYear; " is 156.
Long Statement,CommandLine.Text,HelpText,C:\repos\nodatime_nodatime\lib\commandline\CommandLineText.cs,AutoBuild,The length of the statement  "            if (title == null) throw new InvalidOperationException("HelpText::AutoBuild() requires that you define AssemblyTitleAttribute."); " is 129.
Long Statement,CommandLine.Text,HelpText,C:\repos\nodatime_nodatime\lib\commandline\CommandLineText.cs,AutoBuild,The length of the statement  "            if (version == null) throw new InvalidOperationException("HelpText::AutoBuild() requires that you define AssemblyInformationalVersionAttribute."); " is 146.
Long Statement,CommandLine.Text,HelpText,C:\repos\nodatime_nodatime\lib\commandline\CommandLineText.cs,AutoBuild,The length of the statement  "            if (copyright == null) throw new InvalidOperationException("HelpText::AutoBuild() requires that you define AssemblyCopyrightAttribute."); " is 137.
Magic Number,NodaTime.TzdbCompiler,CompilerOptions,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\CompilerOptions.cs,GetUsage,The following statement contains a magic number: var help = new HelpText(new HeadingInfo(typeof(CompilerOptions).Namespace))              {                  AdditionalNewLineAfterOption = true'                  Copyright = new CopyrightInfo("The Noda Time Authors"' 2009)              };
Magic Number,NodaTime.TzdbCompiler.Tzdb,DateTimeZoneBuilder,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Tzdb\DateTimeZoneBuilder.cs,AddIntervals,The following statement contains a magic number: while (true)              {                  ZoneTransition bestTransition = null;                  for (int i = 0; i < activeRules.Count; i++)                  {                      var rule = activeRules[i];                      var nextTransition = rule.Next(previousTransition.Instant' standardOffset' previousTransition.Savings);                      // Once a rule is no longer active' remove it from the list. That way we can tell                      // when we can create a tail zone.                      if (nextTransition == null)                      {                          activeRules.RemoveAt(i);                          i--;                          continue;                      }                      var zoneTransition = new ZoneTransition(nextTransition.Value.Instant' rule.Name' standardOffset' rule.Savings);                      if (!zoneTransition.IsTransitionFrom(previousTransition))                      {                          continue;                      }                      if (bestTransition == null || zoneTransition.Instant <= bestTransition.Instant)                      {                          bestTransition = zoneTransition;                      }                  }                  Instant currentUpperBound = ruleSet.GetUpperLimit(previousTransition.Savings);                  if (bestTransition == null || bestTransition.Instant >= currentUpperBound)                  {                      // No more transitions to find. (We may have run out of rules' or they may be beyond where this rule set expires.)                      // Add a final interval leading up to the upper bound of the rule set' unless the previous transition took us up to                      // this current bound anyway.                      // (This is very rare' but can happen if changing rule brings the upper bound down to the time                      // that the transition occurred. Example: 2008d' Europe/Sofia' April 1945.)                      if (currentUpperBound > previousTransition.Instant)                      {                          zoneIntervals.Add(previousTransition.ToZoneInterval(currentUpperBound));                      }                      return;                  }                    // We have a non-final transition. so add an interval from the previous transition to                  // this one.                  zoneIntervals.Add(previousTransition.ToZoneInterval(bestTransition.Instant));                  previousTransition = bestTransition;                    // Tail zone handling.                  // The final rule set must extend to infinity. There are potentially three ways                  // this can happen:                  // - All rules expire' leaving us with the final real transition' and an upper                  //   bound of infinity. This is handled above.                  // - 1 rule is left' but it cannot create more than one transition in a row'                  //   so again we end up with no transitions to record' and we bail out with                  //   a final infinite interval.                  // - 2 rules are left which would alternate infinitely. This is represented                  //   using a DaylightSavingZone as the tail zone.                  //                   // The code here caters for that last option' but needs to do it in stages.                  // When we first realize we will have a tail zone (an infinite rule set'                  // two rules left' both of which are themselves infinite) we can create the                  // tail zone' but we don't yet know that we're into its regular tick/tock.                  // It's possible that one rule only starts years after our current transition'                  // so we need to hit the first transition of that rule before we can create a                  // "seam" from the list of precomputed zone intervals to the calculated-on-demand                   // part of history.                  // For an example of why this is necessary' see Asia/Amman in 2013e: in late 2011                  // we hit "two rules left" but the final rule only starts in 2013 - we don't want                  // to see a bogus transition into that rule in 2012.                  // We could potentially record fewer zone intervals by keeping track of which                  // rules have created at least one transition' but this approach is simpler.                  if (ruleSet.IsInfinite && activeRules.Count == 2)                  {                      if (tailZone != null)                      {                          // Phase two: both rules must now be active' so we're done.                          return;                      }                      ZoneRecurrence startRule = activeRules[0];                      ZoneRecurrence endRule = activeRules[1];                      if (startRule.IsInfinite && endRule.IsInfinite)                      {                          // Phase one: build the zone' so we can go round once again and then return.                          tailZone = new StandardDaylightAlternatingMap(standardOffset' startRule' endRule);                      }                  }              }
Magic Number,NodaTime.TzdbCompiler.Tzdb,ParserHelper,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Tzdb\ParserHelper.cs,ConvertHourToTicks,The following statement contains a magic number: if (value < -23 || value > 23)              {                  throw new FormatException("hours out of valid range of [-23' 23]: " + value);              }
Magic Number,NodaTime.TzdbCompiler.Tzdb,ParserHelper,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Tzdb\ParserHelper.cs,ConvertHourToTicks,The following statement contains a magic number: if (value < -23 || value > 23)              {                  throw new FormatException("hours out of valid range of [-23' 23]: " + value);              }
Magic Number,NodaTime.TzdbCompiler.Tzdb,ParserHelper,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Tzdb\ParserHelper.cs,ConvertMinuteToTicks,The following statement contains a magic number: if (value < 0 || value > 59)              {                  throw new FormatException("minutes out of valid range of [0' 59]: " + value);              }
Magic Number,NodaTime.TzdbCompiler.Tzdb,ParserHelper,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Tzdb\ParserHelper.cs,ConvertSecondsWithFractionalToTicks,The following statement contains a magic number: if (number < 0.0 || number >= 60.0)              {                  throw new FormatException("seconds out of valid range of [0' 60): " + number);              }
Magic Number,NodaTime.TzdbCompiler.Tzdb,ParserHelper,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Tzdb\ParserHelper.cs,ParseOffset,The following statement contains a magic number: if (parts.Length > 3)              {                  throw new FormatException("Offset has too many colon separated parts (max of 3 allowed): " + text);              }
Magic Number,NodaTime.TzdbCompiler.Tzdb,ParserHelper,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Tzdb\ParserHelper.cs,ParseOffset,The following statement contains a magic number: if (parts.Length > 1)              {                  ticks += ConvertMinuteToTicks(parts[1]);                  if (parts.Length > 2)                  {                      ticks += ConvertSecondsWithFractionalToTicks(parts[2]);                  }              }
Magic Number,NodaTime.TzdbCompiler.Tzdb,ParserHelper,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Tzdb\ParserHelper.cs,ParseOffset,The following statement contains a magic number: if (parts.Length > 1)              {                  ticks += ConvertMinuteToTicks(parts[1]);                  if (parts.Length > 2)                  {                      ticks += ConvertSecondsWithFractionalToTicks(parts[2]);                  }              }
Magic Number,NodaTime.TzdbCompiler.Tzdb,RuleLine,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Tzdb\RuleLine.cs,GetRecurrences,The following statement contains a magic number: if (Type == null)              {                  yield return recurrence.WithName(name);              }              else              {                  Predicate<int> yearPredicate = GetYearPredicate();                  // Apply a little sanity...                  if (recurrence.IsInfinite || recurrence.ToYear - recurrence.FromYear > 1000)                  {                      throw new NotSupportedException("Noda Time does not support 'typed' rules over large periods");                  }                  for (int year = recurrence.FromYear; year <= recurrence.ToYear; year++)                  {                      if (yearPredicate(year))                      {                                                  yield return recurrence.ForSingleYear(year).WithName(name);                      }                  }              }
Magic Number,NodaTime.TzdbCompiler.Tzdb,RuleLine,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Tzdb\RuleLine.cs,GetYearPredicate,The following statement contains a magic number: switch (Type)              {                  case "odd":                      return year => year % 2 == 1;                  case "even":                      return year => year % 2 == 0;                  default:                      throw new NotSupportedException($"Noda Time does not support rules of type {Type}");              }
Magic Number,NodaTime.TzdbCompiler.Tzdb,RuleLine,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Tzdb\RuleLine.cs,GetYearPredicate,The following statement contains a magic number: switch (Type)              {                  case "odd":                      return year => year % 2 == 1;                  case "even":                      return year => year % 2 == 0;                  default:                      throw new NotSupportedException($"Noda Time does not support rules of type {Type}");              }
Magic Number,NodaTime.TzdbCompiler.Tzdb,TzdbZoneInfoCompiler,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Tzdb\TzdbZoneInfoCompiler.cs,InferVersion,The following statement contains a magic number: if (source.Contains(Makefile))              {                  foreach (var line in source.ReadLines(Makefile))                  {                      if (Regex.IsMatch(line' @"VERSION=\d{4}.*"))                      {                          var version = line.Substring(8).Trim();                          log?.WriteLine($"Inferred version {version} from {Makefile}");                          return version;                      }                  }              }
Magic Number,NodaTime.TzdbCompiler.Tzdb,TzdbZoneInfoParser,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Tzdb\TzdbZoneInfoParser.cs,ParseDateTimeOfYear,The following statement contains a magic number: if (tokens.HasNextToken || forRule)              {                  var on = NextString(tokens' "On");                  if (on.StartsWith("last"' StringComparison.Ordinal))                  {                      dayOfMonth = -1;                      dayOfWeek = ParseDayOfWeek(on.Substring(4));                  }                  else                  {                      int index = on.IndexOf(">="' StringComparison.Ordinal);                      if (index > 0)                      {                          dayOfMonth = Int32.Parse(on.Substring(index + 2)' CultureInfo.InvariantCulture);                          dayOfWeek = ParseDayOfWeek(on.Substring(0' index));                          advanceDayOfWeek = true;                      }                      else                      {                          index = on.IndexOf("<="' StringComparison.Ordinal);                          if (index > 0)                          {                              dayOfMonth = Int32.Parse(on.Substring(index + 2)' CultureInfo.InvariantCulture);                              dayOfWeek = ParseDayOfWeek(on.Substring(0' index));                          }                          else                          {                              try                              {                                  dayOfMonth = Int32.Parse(on' CultureInfo.InvariantCulture);                                  dayOfWeek = 0;                              }                              catch (FormatException e)                              {                                  throw new ArgumentException($"Unparsable ON token: {on}"' e);                              }                          }                      }                  }                    if (tokens.HasNextToken || forRule)                  {                      var atTime = NextString(tokens' "AT");                      if (!string.IsNullOrEmpty(atTime))                      {                          if (Char.IsLetter(atTime[atTime.Length - 1]))                          {                              char zoneCharacter = atTime[atTime.Length - 1];                              mode = ConvertModeCharacter(zoneCharacter);                              atTime = atTime.Substring(0' atTime.Length - 1);                          }                          if (atTime == "24:00")                          {                              timeOfDay = LocalTime.Midnight;                              addDay = true;                          }                          else                          {                              timeOfDay = ParserHelper.ParseTime(atTime);                          }                      }                  }              }
Magic Number,NodaTime.TzdbCompiler.Tzdb,TzdbZoneInfoParser,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Tzdb\TzdbZoneInfoParser.cs,ParseDateTimeOfYear,The following statement contains a magic number: if (tokens.HasNextToken || forRule)              {                  var on = NextString(tokens' "On");                  if (on.StartsWith("last"' StringComparison.Ordinal))                  {                      dayOfMonth = -1;                      dayOfWeek = ParseDayOfWeek(on.Substring(4));                  }                  else                  {                      int index = on.IndexOf(">="' StringComparison.Ordinal);                      if (index > 0)                      {                          dayOfMonth = Int32.Parse(on.Substring(index + 2)' CultureInfo.InvariantCulture);                          dayOfWeek = ParseDayOfWeek(on.Substring(0' index));                          advanceDayOfWeek = true;                      }                      else                      {                          index = on.IndexOf("<="' StringComparison.Ordinal);                          if (index > 0)                          {                              dayOfMonth = Int32.Parse(on.Substring(index + 2)' CultureInfo.InvariantCulture);                              dayOfWeek = ParseDayOfWeek(on.Substring(0' index));                          }                          else                          {                              try                              {                                  dayOfMonth = Int32.Parse(on' CultureInfo.InvariantCulture);                                  dayOfWeek = 0;                              }                              catch (FormatException e)                              {                                  throw new ArgumentException($"Unparsable ON token: {on}"' e);                              }                          }                      }                  }                    if (tokens.HasNextToken || forRule)                  {                      var atTime = NextString(tokens' "AT");                      if (!string.IsNullOrEmpty(atTime))                      {                          if (Char.IsLetter(atTime[atTime.Length - 1]))                          {                              char zoneCharacter = atTime[atTime.Length - 1];                              mode = ConvertModeCharacter(zoneCharacter);                              atTime = atTime.Substring(0' atTime.Length - 1);                          }                          if (atTime == "24:00")                          {                              timeOfDay = LocalTime.Midnight;                              addDay = true;                          }                          else                          {                              timeOfDay = ParserHelper.ParseTime(atTime);                          }                      }                  }              }
Magic Number,NodaTime.TzdbCompiler.Tzdb,TzdbZoneInfoParser,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Tzdb\TzdbZoneInfoParser.cs,ParseDateTimeOfYear,The following statement contains a magic number: if (tokens.HasNextToken || forRule)              {                  var on = NextString(tokens' "On");                  if (on.StartsWith("last"' StringComparison.Ordinal))                  {                      dayOfMonth = -1;                      dayOfWeek = ParseDayOfWeek(on.Substring(4));                  }                  else                  {                      int index = on.IndexOf(">="' StringComparison.Ordinal);                      if (index > 0)                      {                          dayOfMonth = Int32.Parse(on.Substring(index + 2)' CultureInfo.InvariantCulture);                          dayOfWeek = ParseDayOfWeek(on.Substring(0' index));                          advanceDayOfWeek = true;                      }                      else                      {                          index = on.IndexOf("<="' StringComparison.Ordinal);                          if (index > 0)                          {                              dayOfMonth = Int32.Parse(on.Substring(index + 2)' CultureInfo.InvariantCulture);                              dayOfWeek = ParseDayOfWeek(on.Substring(0' index));                          }                          else                          {                              try                              {                                  dayOfMonth = Int32.Parse(on' CultureInfo.InvariantCulture);                                  dayOfWeek = 0;                              }                              catch (FormatException e)                              {                                  throw new ArgumentException($"Unparsable ON token: {on}"' e);                              }                          }                      }                  }                    if (tokens.HasNextToken || forRule)                  {                      var atTime = NextString(tokens' "AT");                      if (!string.IsNullOrEmpty(atTime))                      {                          if (Char.IsLetter(atTime[atTime.Length - 1]))                          {                              char zoneCharacter = atTime[atTime.Length - 1];                              mode = ConvertModeCharacter(zoneCharacter);                              atTime = atTime.Substring(0' atTime.Length - 1);                          }                          if (atTime == "24:00")                          {                              timeOfDay = LocalTime.Midnight;                              addDay = true;                          }                          else                          {                              timeOfDay = ParserHelper.ParseTime(atTime);                          }                      }                  }              }
Magic Number,NodaTime.TzdbCompiler.Tzdb,TzdbZoneInfoParser,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Tzdb\TzdbZoneInfoParser.cs,ParseRule,The following statement contains a magic number: if (fromYear == int.MinValue)              {                   fromYear = 1900;              }
Magic Number,NodaTime.TzdbCompiler.Tzdb,TzdbZoneLocationParser,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Tzdb\TzdbZoneLocationParser.cs,ParseLocation,The following statement contains a magic number: Preconditions.CheckArgument(bits.Length == 3 || bits.Length == 4' "line"' "Line must have 3 or 4 tab-separated values");
Magic Number,NodaTime.TzdbCompiler.Tzdb,TzdbZoneLocationParser,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Tzdb\TzdbZoneLocationParser.cs,ParseLocation,The following statement contains a magic number: Preconditions.CheckArgument(bits.Length == 3 || bits.Length == 4' "line"' "Line must have 3 or 4 tab-separated values");
Magic Number,NodaTime.TzdbCompiler.Tzdb,TzdbZoneLocationParser,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Tzdb\TzdbZoneLocationParser.cs,ParseLocation,The following statement contains a magic number: string zoneId = bits[2];
Magic Number,NodaTime.TzdbCompiler.Tzdb,TzdbZoneLocationParser,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Tzdb\TzdbZoneLocationParser.cs,ParseLocation,The following statement contains a magic number: string comment = bits.Length == 4 ? bits[3] : "";
Magic Number,NodaTime.TzdbCompiler.Tzdb,TzdbZoneLocationParser,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Tzdb\TzdbZoneLocationParser.cs,ParseLocation,The following statement contains a magic number: string comment = bits.Length == 4 ? bits[3] : "";
Magic Number,NodaTime.TzdbCompiler.Tzdb,TzdbZoneLocationParser,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Tzdb\TzdbZoneLocationParser.cs,ParseEnhancedLocation,The following statement contains a magic number: Preconditions.CheckArgument(bits.Length == 3 || bits.Length == 4' "line"' "Line must have 3 or 4 tab-separated values");
Magic Number,NodaTime.TzdbCompiler.Tzdb,TzdbZoneLocationParser,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Tzdb\TzdbZoneLocationParser.cs,ParseEnhancedLocation,The following statement contains a magic number: Preconditions.CheckArgument(bits.Length == 3 || bits.Length == 4' "line"' "Line must have 3 or 4 tab-separated values");
Magic Number,NodaTime.TzdbCompiler.Tzdb,TzdbZoneLocationParser,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Tzdb\TzdbZoneLocationParser.cs,ParseEnhancedLocation,The following statement contains a magic number: string zoneId = bits[2];
Magic Number,NodaTime.TzdbCompiler.Tzdb,TzdbZoneLocationParser,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Tzdb\TzdbZoneLocationParser.cs,ParseEnhancedLocation,The following statement contains a magic number: string comment = bits.Length == 4 ? bits[3] : "";
Magic Number,NodaTime.TzdbCompiler.Tzdb,TzdbZoneLocationParser,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Tzdb\TzdbZoneLocationParser.cs,ParseEnhancedLocation,The following statement contains a magic number: string comment = bits.Length == 4 ? bits[3] : "";
Magic Number,NodaTime.TzdbCompiler.Tzdb,TzdbZoneLocationParser,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Tzdb\TzdbZoneLocationParser.cs,ParseCoordinates,The following statement contains a magic number: Preconditions.CheckArgument(text.Length == 11 || text.Length == 15' "point"' "Invalid coordinates");
Magic Number,NodaTime.TzdbCompiler.Tzdb,TzdbZoneLocationParser,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Tzdb\TzdbZoneLocationParser.cs,ParseCoordinates,The following statement contains a magic number: Preconditions.CheckArgument(text.Length == 11 || text.Length == 15' "point"' "Invalid coordinates");
Magic Number,NodaTime.TzdbCompiler.Tzdb,TzdbZoneLocationParser,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Tzdb\TzdbZoneLocationParser.cs,ParseCoordinates,The following statement contains a magic number: if (text.Length == 11 /* +-DDMM+-DDDMM */)              {                  latSign = text[0] == '-' ? -1 : 1;                  latDegrees = int.Parse(text.Substring(1' 2));                  latMinutes = int.Parse(text.Substring(3' 2));                  longSign = text[5] == '-' ? -1 : 1;                  longDegrees = int.Parse(text.Substring(6' 3));                  longMinutes = int.Parse(text.Substring(9' 2));              }              else /* +-DDMMSS+-DDDMMSS */              {                  latSign = text[0] == '-' ? -1 : 1;                  latDegrees = int.Parse(text.Substring(1' 2));                  latMinutes = int.Parse(text.Substring(3' 2));                  latSeconds = int.Parse(text.Substring(5' 2));                  longSign = text[7] == '-' ? -1 : 1;                  longDegrees = int.Parse(text.Substring(8' 3));                  longMinutes = int.Parse(text.Substring(11' 2));                  longSeconds = int.Parse(text.Substring(13' 2));              }
Magic Number,NodaTime.TzdbCompiler.Tzdb,TzdbZoneLocationParser,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Tzdb\TzdbZoneLocationParser.cs,ParseCoordinates,The following statement contains a magic number: if (text.Length == 11 /* +-DDMM+-DDDMM */)              {                  latSign = text[0] == '-' ? -1 : 1;                  latDegrees = int.Parse(text.Substring(1' 2));                  latMinutes = int.Parse(text.Substring(3' 2));                  longSign = text[5] == '-' ? -1 : 1;                  longDegrees = int.Parse(text.Substring(6' 3));                  longMinutes = int.Parse(text.Substring(9' 2));              }              else /* +-DDMMSS+-DDDMMSS */              {                  latSign = text[0] == '-' ? -1 : 1;                  latDegrees = int.Parse(text.Substring(1' 2));                  latMinutes = int.Parse(text.Substring(3' 2));                  latSeconds = int.Parse(text.Substring(5' 2));                  longSign = text[7] == '-' ? -1 : 1;                  longDegrees = int.Parse(text.Substring(8' 3));                  longMinutes = int.Parse(text.Substring(11' 2));                  longSeconds = int.Parse(text.Substring(13' 2));              }
Magic Number,NodaTime.TzdbCompiler.Tzdb,TzdbZoneLocationParser,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Tzdb\TzdbZoneLocationParser.cs,ParseCoordinates,The following statement contains a magic number: if (text.Length == 11 /* +-DDMM+-DDDMM */)              {                  latSign = text[0] == '-' ? -1 : 1;                  latDegrees = int.Parse(text.Substring(1' 2));                  latMinutes = int.Parse(text.Substring(3' 2));                  longSign = text[5] == '-' ? -1 : 1;                  longDegrees = int.Parse(text.Substring(6' 3));                  longMinutes = int.Parse(text.Substring(9' 2));              }              else /* +-DDMMSS+-DDDMMSS */              {                  latSign = text[0] == '-' ? -1 : 1;                  latDegrees = int.Parse(text.Substring(1' 2));                  latMinutes = int.Parse(text.Substring(3' 2));                  latSeconds = int.Parse(text.Substring(5' 2));                  longSign = text[7] == '-' ? -1 : 1;                  longDegrees = int.Parse(text.Substring(8' 3));                  longMinutes = int.Parse(text.Substring(11' 2));                  longSeconds = int.Parse(text.Substring(13' 2));              }
Magic Number,NodaTime.TzdbCompiler.Tzdb,TzdbZoneLocationParser,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Tzdb\TzdbZoneLocationParser.cs,ParseCoordinates,The following statement contains a magic number: if (text.Length == 11 /* +-DDMM+-DDDMM */)              {                  latSign = text[0] == '-' ? -1 : 1;                  latDegrees = int.Parse(text.Substring(1' 2));                  latMinutes = int.Parse(text.Substring(3' 2));                  longSign = text[5] == '-' ? -1 : 1;                  longDegrees = int.Parse(text.Substring(6' 3));                  longMinutes = int.Parse(text.Substring(9' 2));              }              else /* +-DDMMSS+-DDDMMSS */              {                  latSign = text[0] == '-' ? -1 : 1;                  latDegrees = int.Parse(text.Substring(1' 2));                  latMinutes = int.Parse(text.Substring(3' 2));                  latSeconds = int.Parse(text.Substring(5' 2));                  longSign = text[7] == '-' ? -1 : 1;                  longDegrees = int.Parse(text.Substring(8' 3));                  longMinutes = int.Parse(text.Substring(11' 2));                  longSeconds = int.Parse(text.Substring(13' 2));              }
Magic Number,NodaTime.TzdbCompiler.Tzdb,TzdbZoneLocationParser,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Tzdb\TzdbZoneLocationParser.cs,ParseCoordinates,The following statement contains a magic number: if (text.Length == 11 /* +-DDMM+-DDDMM */)              {                  latSign = text[0] == '-' ? -1 : 1;                  latDegrees = int.Parse(text.Substring(1' 2));                  latMinutes = int.Parse(text.Substring(3' 2));                  longSign = text[5] == '-' ? -1 : 1;                  longDegrees = int.Parse(text.Substring(6' 3));                  longMinutes = int.Parse(text.Substring(9' 2));              }              else /* +-DDMMSS+-DDDMMSS */              {                  latSign = text[0] == '-' ? -1 : 1;                  latDegrees = int.Parse(text.Substring(1' 2));                  latMinutes = int.Parse(text.Substring(3' 2));                  latSeconds = int.Parse(text.Substring(5' 2));                  longSign = text[7] == '-' ? -1 : 1;                  longDegrees = int.Parse(text.Substring(8' 3));                  longMinutes = int.Parse(text.Substring(11' 2));                  longSeconds = int.Parse(text.Substring(13' 2));              }
Magic Number,NodaTime.TzdbCompiler.Tzdb,TzdbZoneLocationParser,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Tzdb\TzdbZoneLocationParser.cs,ParseCoordinates,The following statement contains a magic number: if (text.Length == 11 /* +-DDMM+-DDDMM */)              {                  latSign = text[0] == '-' ? -1 : 1;                  latDegrees = int.Parse(text.Substring(1' 2));                  latMinutes = int.Parse(text.Substring(3' 2));                  longSign = text[5] == '-' ? -1 : 1;                  longDegrees = int.Parse(text.Substring(6' 3));                  longMinutes = int.Parse(text.Substring(9' 2));              }              else /* +-DDMMSS+-DDDMMSS */              {                  latSign = text[0] == '-' ? -1 : 1;                  latDegrees = int.Parse(text.Substring(1' 2));                  latMinutes = int.Parse(text.Substring(3' 2));                  latSeconds = int.Parse(text.Substring(5' 2));                  longSign = text[7] == '-' ? -1 : 1;                  longDegrees = int.Parse(text.Substring(8' 3));                  longMinutes = int.Parse(text.Substring(11' 2));                  longSeconds = int.Parse(text.Substring(13' 2));              }
Magic Number,NodaTime.TzdbCompiler.Tzdb,TzdbZoneLocationParser,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Tzdb\TzdbZoneLocationParser.cs,ParseCoordinates,The following statement contains a magic number: if (text.Length == 11 /* +-DDMM+-DDDMM */)              {                  latSign = text[0] == '-' ? -1 : 1;                  latDegrees = int.Parse(text.Substring(1' 2));                  latMinutes = int.Parse(text.Substring(3' 2));                  longSign = text[5] == '-' ? -1 : 1;                  longDegrees = int.Parse(text.Substring(6' 3));                  longMinutes = int.Parse(text.Substring(9' 2));              }              else /* +-DDMMSS+-DDDMMSS */              {                  latSign = text[0] == '-' ? -1 : 1;                  latDegrees = int.Parse(text.Substring(1' 2));                  latMinutes = int.Parse(text.Substring(3' 2));                  latSeconds = int.Parse(text.Substring(5' 2));                  longSign = text[7] == '-' ? -1 : 1;                  longDegrees = int.Parse(text.Substring(8' 3));                  longMinutes = int.Parse(text.Substring(11' 2));                  longSeconds = int.Parse(text.Substring(13' 2));              }
Magic Number,NodaTime.TzdbCompiler.Tzdb,TzdbZoneLocationParser,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Tzdb\TzdbZoneLocationParser.cs,ParseCoordinates,The following statement contains a magic number: if (text.Length == 11 /* +-DDMM+-DDDMM */)              {                  latSign = text[0] == '-' ? -1 : 1;                  latDegrees = int.Parse(text.Substring(1' 2));                  latMinutes = int.Parse(text.Substring(3' 2));                  longSign = text[5] == '-' ? -1 : 1;                  longDegrees = int.Parse(text.Substring(6' 3));                  longMinutes = int.Parse(text.Substring(9' 2));              }              else /* +-DDMMSS+-DDDMMSS */              {                  latSign = text[0] == '-' ? -1 : 1;                  latDegrees = int.Parse(text.Substring(1' 2));                  latMinutes = int.Parse(text.Substring(3' 2));                  latSeconds = int.Parse(text.Substring(5' 2));                  longSign = text[7] == '-' ? -1 : 1;                  longDegrees = int.Parse(text.Substring(8' 3));                  longMinutes = int.Parse(text.Substring(11' 2));                  longSeconds = int.Parse(text.Substring(13' 2));              }
Magic Number,NodaTime.TzdbCompiler.Tzdb,TzdbZoneLocationParser,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Tzdb\TzdbZoneLocationParser.cs,ParseCoordinates,The following statement contains a magic number: if (text.Length == 11 /* +-DDMM+-DDDMM */)              {                  latSign = text[0] == '-' ? -1 : 1;                  latDegrees = int.Parse(text.Substring(1' 2));                  latMinutes = int.Parse(text.Substring(3' 2));                  longSign = text[5] == '-' ? -1 : 1;                  longDegrees = int.Parse(text.Substring(6' 3));                  longMinutes = int.Parse(text.Substring(9' 2));              }              else /* +-DDMMSS+-DDDMMSS */              {                  latSign = text[0] == '-' ? -1 : 1;                  latDegrees = int.Parse(text.Substring(1' 2));                  latMinutes = int.Parse(text.Substring(3' 2));                  latSeconds = int.Parse(text.Substring(5' 2));                  longSign = text[7] == '-' ? -1 : 1;                  longDegrees = int.Parse(text.Substring(8' 3));                  longMinutes = int.Parse(text.Substring(11' 2));                  longSeconds = int.Parse(text.Substring(13' 2));              }
Magic Number,NodaTime.TzdbCompiler.Tzdb,TzdbZoneLocationParser,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Tzdb\TzdbZoneLocationParser.cs,ParseCoordinates,The following statement contains a magic number: if (text.Length == 11 /* +-DDMM+-DDDMM */)              {                  latSign = text[0] == '-' ? -1 : 1;                  latDegrees = int.Parse(text.Substring(1' 2));                  latMinutes = int.Parse(text.Substring(3' 2));                  longSign = text[5] == '-' ? -1 : 1;                  longDegrees = int.Parse(text.Substring(6' 3));                  longMinutes = int.Parse(text.Substring(9' 2));              }              else /* +-DDMMSS+-DDDMMSS */              {                  latSign = text[0] == '-' ? -1 : 1;                  latDegrees = int.Parse(text.Substring(1' 2));                  latMinutes = int.Parse(text.Substring(3' 2));                  latSeconds = int.Parse(text.Substring(5' 2));                  longSign = text[7] == '-' ? -1 : 1;                  longDegrees = int.Parse(text.Substring(8' 3));                  longMinutes = int.Parse(text.Substring(11' 2));                  longSeconds = int.Parse(text.Substring(13' 2));              }
Magic Number,NodaTime.TzdbCompiler.Tzdb,TzdbZoneLocationParser,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Tzdb\TzdbZoneLocationParser.cs,ParseCoordinates,The following statement contains a magic number: if (text.Length == 11 /* +-DDMM+-DDDMM */)              {                  latSign = text[0] == '-' ? -1 : 1;                  latDegrees = int.Parse(text.Substring(1' 2));                  latMinutes = int.Parse(text.Substring(3' 2));                  longSign = text[5] == '-' ? -1 : 1;                  longDegrees = int.Parse(text.Substring(6' 3));                  longMinutes = int.Parse(text.Substring(9' 2));              }              else /* +-DDMMSS+-DDDMMSS */              {                  latSign = text[0] == '-' ? -1 : 1;                  latDegrees = int.Parse(text.Substring(1' 2));                  latMinutes = int.Parse(text.Substring(3' 2));                  latSeconds = int.Parse(text.Substring(5' 2));                  longSign = text[7] == '-' ? -1 : 1;                  longDegrees = int.Parse(text.Substring(8' 3));                  longMinutes = int.Parse(text.Substring(11' 2));                  longSeconds = int.Parse(text.Substring(13' 2));              }
Magic Number,NodaTime.TzdbCompiler.Tzdb,TzdbZoneLocationParser,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Tzdb\TzdbZoneLocationParser.cs,ParseCoordinates,The following statement contains a magic number: if (text.Length == 11 /* +-DDMM+-DDDMM */)              {                  latSign = text[0] == '-' ? -1 : 1;                  latDegrees = int.Parse(text.Substring(1' 2));                  latMinutes = int.Parse(text.Substring(3' 2));                  longSign = text[5] == '-' ? -1 : 1;                  longDegrees = int.Parse(text.Substring(6' 3));                  longMinutes = int.Parse(text.Substring(9' 2));              }              else /* +-DDMMSS+-DDDMMSS */              {                  latSign = text[0] == '-' ? -1 : 1;                  latDegrees = int.Parse(text.Substring(1' 2));                  latMinutes = int.Parse(text.Substring(3' 2));                  latSeconds = int.Parse(text.Substring(5' 2));                  longSign = text[7] == '-' ? -1 : 1;                  longDegrees = int.Parse(text.Substring(8' 3));                  longMinutes = int.Parse(text.Substring(11' 2));                  longSeconds = int.Parse(text.Substring(13' 2));              }
Magic Number,NodaTime.TzdbCompiler.Tzdb,TzdbZoneLocationParser,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Tzdb\TzdbZoneLocationParser.cs,ParseCoordinates,The following statement contains a magic number: if (text.Length == 11 /* +-DDMM+-DDDMM */)              {                  latSign = text[0] == '-' ? -1 : 1;                  latDegrees = int.Parse(text.Substring(1' 2));                  latMinutes = int.Parse(text.Substring(3' 2));                  longSign = text[5] == '-' ? -1 : 1;                  longDegrees = int.Parse(text.Substring(6' 3));                  longMinutes = int.Parse(text.Substring(9' 2));              }              else /* +-DDMMSS+-DDDMMSS */              {                  latSign = text[0] == '-' ? -1 : 1;                  latDegrees = int.Parse(text.Substring(1' 2));                  latMinutes = int.Parse(text.Substring(3' 2));                  latSeconds = int.Parse(text.Substring(5' 2));                  longSign = text[7] == '-' ? -1 : 1;                  longDegrees = int.Parse(text.Substring(8' 3));                  longMinutes = int.Parse(text.Substring(11' 2));                  longSeconds = int.Parse(text.Substring(13' 2));              }
Magic Number,NodaTime.TzdbCompiler.Tzdb,TzdbZoneLocationParser,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Tzdb\TzdbZoneLocationParser.cs,ParseCoordinates,The following statement contains a magic number: if (text.Length == 11 /* +-DDMM+-DDDMM */)              {                  latSign = text[0] == '-' ? -1 : 1;                  latDegrees = int.Parse(text.Substring(1' 2));                  latMinutes = int.Parse(text.Substring(3' 2));                  longSign = text[5] == '-' ? -1 : 1;                  longDegrees = int.Parse(text.Substring(6' 3));                  longMinutes = int.Parse(text.Substring(9' 2));              }              else /* +-DDMMSS+-DDDMMSS */              {                  latSign = text[0] == '-' ? -1 : 1;                  latDegrees = int.Parse(text.Substring(1' 2));                  latMinutes = int.Parse(text.Substring(3' 2));                  latSeconds = int.Parse(text.Substring(5' 2));                  longSign = text[7] == '-' ? -1 : 1;                  longDegrees = int.Parse(text.Substring(8' 3));                  longMinutes = int.Parse(text.Substring(11' 2));                  longSeconds = int.Parse(text.Substring(13' 2));              }
Magic Number,NodaTime.TzdbCompiler.Tzdb,TzdbZoneLocationParser,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Tzdb\TzdbZoneLocationParser.cs,ParseCoordinates,The following statement contains a magic number: if (text.Length == 11 /* +-DDMM+-DDDMM */)              {                  latSign = text[0] == '-' ? -1 : 1;                  latDegrees = int.Parse(text.Substring(1' 2));                  latMinutes = int.Parse(text.Substring(3' 2));                  longSign = text[5] == '-' ? -1 : 1;                  longDegrees = int.Parse(text.Substring(6' 3));                  longMinutes = int.Parse(text.Substring(9' 2));              }              else /* +-DDMMSS+-DDDMMSS */              {                  latSign = text[0] == '-' ? -1 : 1;                  latDegrees = int.Parse(text.Substring(1' 2));                  latMinutes = int.Parse(text.Substring(3' 2));                  latSeconds = int.Parse(text.Substring(5' 2));                  longSign = text[7] == '-' ? -1 : 1;                  longDegrees = int.Parse(text.Substring(8' 3));                  longMinutes = int.Parse(text.Substring(11' 2));                  longSeconds = int.Parse(text.Substring(13' 2));              }
Magic Number,NodaTime.TzdbCompiler.Tzdb,TzdbZoneLocationParser,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Tzdb\TzdbZoneLocationParser.cs,ParseCoordinates,The following statement contains a magic number: if (text.Length == 11 /* +-DDMM+-DDDMM */)              {                  latSign = text[0] == '-' ? -1 : 1;                  latDegrees = int.Parse(text.Substring(1' 2));                  latMinutes = int.Parse(text.Substring(3' 2));                  longSign = text[5] == '-' ? -1 : 1;                  longDegrees = int.Parse(text.Substring(6' 3));                  longMinutes = int.Parse(text.Substring(9' 2));              }              else /* +-DDMMSS+-DDDMMSS */              {                  latSign = text[0] == '-' ? -1 : 1;                  latDegrees = int.Parse(text.Substring(1' 2));                  latMinutes = int.Parse(text.Substring(3' 2));                  latSeconds = int.Parse(text.Substring(5' 2));                  longSign = text[7] == '-' ? -1 : 1;                  longDegrees = int.Parse(text.Substring(8' 3));                  longMinutes = int.Parse(text.Substring(11' 2));                  longSeconds = int.Parse(text.Substring(13' 2));              }
Magic Number,NodaTime.TzdbCompiler.Tzdb,TzdbZoneLocationParser,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Tzdb\TzdbZoneLocationParser.cs,ParseCoordinates,The following statement contains a magic number: if (text.Length == 11 /* +-DDMM+-DDDMM */)              {                  latSign = text[0] == '-' ? -1 : 1;                  latDegrees = int.Parse(text.Substring(1' 2));                  latMinutes = int.Parse(text.Substring(3' 2));                  longSign = text[5] == '-' ? -1 : 1;                  longDegrees = int.Parse(text.Substring(6' 3));                  longMinutes = int.Parse(text.Substring(9' 2));              }              else /* +-DDMMSS+-DDDMMSS */              {                  latSign = text[0] == '-' ? -1 : 1;                  latDegrees = int.Parse(text.Substring(1' 2));                  latMinutes = int.Parse(text.Substring(3' 2));                  latSeconds = int.Parse(text.Substring(5' 2));                  longSign = text[7] == '-' ? -1 : 1;                  longDegrees = int.Parse(text.Substring(8' 3));                  longMinutes = int.Parse(text.Substring(11' 2));                  longSeconds = int.Parse(text.Substring(13' 2));              }
Magic Number,NodaTime.TzdbCompiler.Tzdb,TzdbZoneLocationParser,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Tzdb\TzdbZoneLocationParser.cs,ParseCoordinates,The following statement contains a magic number: if (text.Length == 11 /* +-DDMM+-DDDMM */)              {                  latSign = text[0] == '-' ? -1 : 1;                  latDegrees = int.Parse(text.Substring(1' 2));                  latMinutes = int.Parse(text.Substring(3' 2));                  longSign = text[5] == '-' ? -1 : 1;                  longDegrees = int.Parse(text.Substring(6' 3));                  longMinutes = int.Parse(text.Substring(9' 2));              }              else /* +-DDMMSS+-DDDMMSS */              {                  latSign = text[0] == '-' ? -1 : 1;                  latDegrees = int.Parse(text.Substring(1' 2));                  latMinutes = int.Parse(text.Substring(3' 2));                  latSeconds = int.Parse(text.Substring(5' 2));                  longSign = text[7] == '-' ? -1 : 1;                  longDegrees = int.Parse(text.Substring(8' 3));                  longMinutes = int.Parse(text.Substring(11' 2));                  longSeconds = int.Parse(text.Substring(13' 2));              }
Magic Number,NodaTime.TzdbCompiler.Tzdb,TzdbZoneLocationParser,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Tzdb\TzdbZoneLocationParser.cs,ParseCoordinates,The following statement contains a magic number: if (text.Length == 11 /* +-DDMM+-DDDMM */)              {                  latSign = text[0] == '-' ? -1 : 1;                  latDegrees = int.Parse(text.Substring(1' 2));                  latMinutes = int.Parse(text.Substring(3' 2));                  longSign = text[5] == '-' ? -1 : 1;                  longDegrees = int.Parse(text.Substring(6' 3));                  longMinutes = int.Parse(text.Substring(9' 2));              }              else /* +-DDMMSS+-DDDMMSS */              {                  latSign = text[0] == '-' ? -1 : 1;                  latDegrees = int.Parse(text.Substring(1' 2));                  latMinutes = int.Parse(text.Substring(3' 2));                  latSeconds = int.Parse(text.Substring(5' 2));                  longSign = text[7] == '-' ? -1 : 1;                  longDegrees = int.Parse(text.Substring(8' 3));                  longMinutes = int.Parse(text.Substring(11' 2));                  longSeconds = int.Parse(text.Substring(13' 2));              }
Magic Number,NodaTime.TzdbCompiler.Tzdb,TzdbZoneLocationParser,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Tzdb\TzdbZoneLocationParser.cs,ParseCoordinates,The following statement contains a magic number: if (text.Length == 11 /* +-DDMM+-DDDMM */)              {                  latSign = text[0] == '-' ? -1 : 1;                  latDegrees = int.Parse(text.Substring(1' 2));                  latMinutes = int.Parse(text.Substring(3' 2));                  longSign = text[5] == '-' ? -1 : 1;                  longDegrees = int.Parse(text.Substring(6' 3));                  longMinutes = int.Parse(text.Substring(9' 2));              }              else /* +-DDMMSS+-DDDMMSS */              {                  latSign = text[0] == '-' ? -1 : 1;                  latDegrees = int.Parse(text.Substring(1' 2));                  latMinutes = int.Parse(text.Substring(3' 2));                  latSeconds = int.Parse(text.Substring(5' 2));                  longSign = text[7] == '-' ? -1 : 1;                  longDegrees = int.Parse(text.Substring(8' 3));                  longMinutes = int.Parse(text.Substring(11' 2));                  longSeconds = int.Parse(text.Substring(13' 2));              }
Magic Number,NodaTime.TzdbCompiler.Tzdb,TzdbZoneLocationParser,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Tzdb\TzdbZoneLocationParser.cs,ParseCoordinates,The following statement contains a magic number: if (text.Length == 11 /* +-DDMM+-DDDMM */)              {                  latSign = text[0] == '-' ? -1 : 1;                  latDegrees = int.Parse(text.Substring(1' 2));                  latMinutes = int.Parse(text.Substring(3' 2));                  longSign = text[5] == '-' ? -1 : 1;                  longDegrees = int.Parse(text.Substring(6' 3));                  longMinutes = int.Parse(text.Substring(9' 2));              }              else /* +-DDMMSS+-DDDMMSS */              {                  latSign = text[0] == '-' ? -1 : 1;                  latDegrees = int.Parse(text.Substring(1' 2));                  latMinutes = int.Parse(text.Substring(3' 2));                  latSeconds = int.Parse(text.Substring(5' 2));                  longSign = text[7] == '-' ? -1 : 1;                  longDegrees = int.Parse(text.Substring(8' 3));                  longMinutes = int.Parse(text.Substring(11' 2));                  longSeconds = int.Parse(text.Substring(13' 2));              }
Magic Number,NodaTime.TzdbCompiler.Tzdb,TzdbZoneLocationParser,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Tzdb\TzdbZoneLocationParser.cs,ParseCoordinates,The following statement contains a magic number: return new[] {                  latSign * (latDegrees * 3600 + latMinutes * 60 + latSeconds)'                  longSign * (longDegrees * 3600 + longMinutes * 60 + longSeconds)              };
Magic Number,NodaTime.TzdbCompiler.Tzdb,TzdbZoneLocationParser,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Tzdb\TzdbZoneLocationParser.cs,ParseCoordinates,The following statement contains a magic number: return new[] {                  latSign * (latDegrees * 3600 + latMinutes * 60 + latSeconds)'                  longSign * (longDegrees * 3600 + longMinutes * 60 + longSeconds)              };
Magic Number,NodaTime.TzdbCompiler.Tzdb,TzdbZoneLocationParser,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Tzdb\TzdbZoneLocationParser.cs,ParseCoordinates,The following statement contains a magic number: return new[] {                  latSign * (latDegrees * 3600 + latMinutes * 60 + latSeconds)'                  longSign * (longDegrees * 3600 + longMinutes * 60 + longSeconds)              };
Magic Number,NodaTime.TzdbCompiler.Tzdb,TzdbZoneLocationParser,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Tzdb\TzdbZoneLocationParser.cs,ParseCoordinates,The following statement contains a magic number: return new[] {                  latSign * (latDegrees * 3600 + latMinutes * 60 + latSeconds)'                  longSign * (longDegrees * 3600 + longMinutes * 60 + longSeconds)              };
Magic Number,NodaTime.TzdbCompiler.Tzdb,ZoneLine,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Tzdb\ZoneLine.cs,FormatName,The following statement contains a magic number: if (index >= 0)              {                  var left = Format.Substring(0' index);                  var right = Format.Substring(index + 2);                  return left + daylightSavingsIndicator + right;              }
Magic Number,NodaTime.TzdbCompiler.Tzdb,ZoneLine,C:\repos\nodatime_nodatime\src\NodaTime.TzdbCompiler\Tzdb\ZoneLine.cs,FormatName,The following statement contains a magic number: if (index >= 0)              {                  var left = Format.Substring(0' index);                  var right = Format.Substring(index + 2);                  return left + PercentZPattern.Format(StandardOffset + savings) + right;              }
Magic Number,CommandLine,LongOptionParser,C:\repos\nodatime_nodatime\lib\commandline\CommandLine.cs,Parse,The following statement contains a magic number: var parts = argumentEnumerator.Current.Substring(2).Split(new[] { '=' }' 2);
Magic Number,CommandLine,LongOptionParser,C:\repos\nodatime_nodatime\lib\commandline\CommandLine.cs,Parse,The following statement contains a magic number: var parts = argumentEnumerator.Current.Substring(2).Split(new[] { '=' }' 2);
Magic Number,CommandLine,LongOptionParser,C:\repos\nodatime_nodatime\lib\commandline\CommandLine.cs,Parse,The following statement contains a magic number: if (!option.IsBoolean)              {                  if (parts.Length == 1 && (argumentEnumerator.IsLast || !ArgumentParser.IsInputValue(argumentEnumerator.Next)))                      return ParserState.Failure;                    if (parts.Length == 2)                  {                      if (!option.IsArray)                      {                          valueSetting = option.SetValue(parts[1]' options);                          if (!valueSetting)                              this.DefineOptionThatViolatesFormat(option);                            return ArgumentParser.BooleanToParserState(valueSetting);                      }                        ArgumentParser.EnsureOptionAttributeIsArrayCompatible(option);                        var items = ArgumentParser.GetNextInputValues(argumentEnumerator);                      items.Insert(0' parts[1]);                        valueSetting = option.SetValue(items' options);                      if (!valueSetting)                          this.DefineOptionThatViolatesFormat(option);                        return ArgumentParser.BooleanToParserState(valueSetting);                  }                  else                  {                      if (!option.IsArray)                      {                          valueSetting = option.SetValue(argumentEnumerator.Next' options);                          if (!valueSetting)                              this.DefineOptionThatViolatesFormat(option);                            return ArgumentParser.BooleanToParserState(valueSetting' true);                      }                        ArgumentParser.EnsureOptionAttributeIsArrayCompatible(option);                        var items = ArgumentParser.GetNextInputValues(argumentEnumerator);                        valueSetting = option.SetValue(items' options);                      if (!valueSetting)                          this.DefineOptionThatViolatesFormat(option);                        //return ArgumentParser.BooleanToParserState(valueSetting' true);                      return ArgumentParser.BooleanToParserState(valueSetting);                  }              }
Magic Number,CommandLine,LongOptionParser,C:\repos\nodatime_nodatime\lib\commandline\CommandLine.cs,Parse,The following statement contains a magic number: if (parts.Length == 2)                  return ParserState.Failure;
Magic Number,CommandLine,OptionMap,C:\repos\nodatime_nodatime\lib\commandline\CommandLine.cs,OptionMap,The following statement contains a magic number: _map = new Dictionary<string' OptionInfo>(capacity * 2' comparer);
Magic Number,CommandLine.Text,CopyrightInfo,C:\repos\nodatime_nodatime\lib\commandline\CommandLineText.cs,CopyrightInfo,The following statement contains a magic number: const int extraLength = 10;
Magic Number,CommandLine.Text,CopyrightInfo,C:\repos\nodatime_nodatime\lib\commandline\CommandLineText.cs,CopyrightInfo,The following statement contains a magic number: _builder = new StringBuilder                      (CopyrightWord.Length + author.Length + (4 * years.Length) + extraLength);
Magic Number,CommandLine.Text,CopyrightInfo,C:\repos\nodatime_nodatime\lib\commandline\CommandLineText.cs,FormatYears,The following statement contains a magic number: var yearsPart = new StringBuilder (years.Length * 6);
Magic Number,CommandLine.Text,HeadingInfo,C:\repos\nodatime_nodatime\lib\commandline\CommandLineText.cs,WriteMessage,The following statement contains a magic number: var builder = new StringBuilder (_programName.Length + message.Length + 2);
Magic Number,CommandLine.Text,HelpText,C:\repos\nodatime_nodatime\lib\commandline\CommandLineText.cs,DefaultParsingErrorsHandler,The following statement contains a magic number: if (options.InternalLastPostParsingState.Errors.Count > 0)              {                  var errors = current.RenderParsingErrorsText(options' 2); // indent with two spaces                  if (!string.IsNullOrEmpty(errors))                  {                      current.AddPreOptionsLine(string.Concat(Environment.NewLine' current.SentenceBuilder.ErrorsHeadingText));                      //current.AddPreOptionsLine(errors);                      var lines = errors.Split(new string[] { Environment.NewLine }' StringSplitOptions.None);                      foreach (var line in lines) { current.AddPreOptionsLine(line); }                  }              }
Magic Number,CommandLine.Text,HelpText,C:\repos\nodatime_nodatime\lib\commandline\CommandLineText.cs,AddOptions,The following statement contains a magic number: int remainingSpace = maximumLength - (maxLength + 6);
Magic Number,CommandLine.Text,HelpText,C:\repos\nodatime_nodatime\lib\commandline\CommandLineText.cs,AddOption,The following statement contains a magic number: if (!string.IsNullOrEmpty (option.HelpText)) {                  do {                      int wordBuffer = 0;                      var words = option.HelpText.Split (new[] {' '});                      for (int i = 0; i < words.Length; i++) {                          if (words [i].Length < (widthOfHelpText - wordBuffer)) {                              _optionsHelp.Append (words [i]);                              wordBuffer += words [i].Length;                              if ((widthOfHelpText - wordBuffer) > 1 && i != words.Length - 1) {                                  _optionsHelp.Append (" ");                                  wordBuffer++;                              }                          } else if (words [i].Length >= widthOfHelpText && wordBuffer == 0) {                              _optionsHelp.Append (words [i].Substring (                                  0'                                  widthOfHelpText                              ));                              wordBuffer = widthOfHelpText;                              break;                          } else {                              break;                          }                      }                      option.HelpText = option.HelpText.Substring (Math.Min (                          wordBuffer'                          option.HelpText.Length                      ))                          .Trim ();                      if (option.HelpText.Length > 0) {                          _optionsHelp.Append (Environment.NewLine);                          _optionsHelp.Append (new string (' '' maxLength + 6));                      }                  } while (option.HelpText.Length > widthOfHelpText);              }
Magic Number,CommandLine.Text,HelpText,C:\repos\nodatime_nodatime\lib\commandline\CommandLineText.cs,ToString,The following statement contains a magic number: const int extraLength = 10;
Magic Number,CommandLine.Text,HelpText,C:\repos\nodatime_nodatime\lib\commandline\CommandLineText.cs,GetMaxLength,The following statement contains a magic number: foreach (BaseOptionAttribute option in optionList) {                  int optionLength = 0;                  bool hasShort = option.HasShortName;                  bool hasLong = option.HasLongName;                  if (hasShort) {                      optionLength += option.ShortName.Length;                      if (AddDashesToOption)                          ++optionLength;                  }                  if (hasLong) {                      optionLength += option.LongName.Length;                      if (AddDashesToOption)                          optionLength += 2;                  }                  if (hasShort && hasLong) {                      optionLength += 2; // "' "                  }                  length = Math.Max (length' optionLength);              }
Magic Number,CommandLine.Text,HelpText,C:\repos\nodatime_nodatime\lib\commandline\CommandLineText.cs,GetMaxLength,The following statement contains a magic number: foreach (BaseOptionAttribute option in optionList) {                  int optionLength = 0;                  bool hasShort = option.HasShortName;                  bool hasLong = option.HasLongName;                  if (hasShort) {                      optionLength += option.ShortName.Length;                      if (AddDashesToOption)                          ++optionLength;                  }                  if (hasLong) {                      optionLength += option.LongName.Length;                      if (AddDashesToOption)                          optionLength += 2;                  }                  if (hasShort && hasLong) {                      optionLength += 2; // "' "                  }                  length = Math.Max (length' optionLength);              }
