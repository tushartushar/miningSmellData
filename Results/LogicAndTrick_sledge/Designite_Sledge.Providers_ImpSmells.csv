Implementation smell,Namespace,Class,File,Method,Description
Long Method,Sledge.Providers.GameData,FgdProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GameData\FgdProvider.cs,ParseAt,The method has 236 lines of code.
Long Method,Sledge.Providers,GenericStructure,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GenericStructure.cs,SerialiseHelper,The method has 104 lines of code.
Long Method,Sledge.Providers.Map,ObjProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\ObjProvider.cs,Read,The method has 143 lines of code.
Long Method,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadModel,The method has 186 lines of code.
Long Method,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceMeshData,The method has 182 lines of code.
Long Method,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,LoadImage,The method has 125 lines of code.
Complex Method,Sledge.Providers.GameData,FgdProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GameData\FgdProvider.cs,ParseAt,Cyclomatic complexity of the method is 38
Complex Method,Sledge.Providers.GameData,FgdProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GameData\FgdProvider.cs,LexNew,Cyclomatic complexity of the method is 13
Complex Method,Sledge.Providers.GameData,FgdProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GameData\FgdProvider.cs,LexExisting,Cyclomatic complexity of the method is 10
Complex Method,Sledge.Providers,GenericStructure,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GenericStructure.cs,SerialiseHelper,Cyclomatic complexity of the method is 15
Complex Method,Sledge.Providers,GenericStructure,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GenericStructure.cs,DeserialiseHelper,Cyclomatic complexity of the method is 9
Complex Method,Sledge.Providers,GenericStructure,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GenericStructure.cs,ConvertPrimitive,Cyclomatic complexity of the method is 11
Complex Method,Sledge.Providers,GenericStructure,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GenericStructure.cs,ParseStructure,Cyclomatic complexity of the method is 8
Complex Method,Sledge.Providers.Map,ObjProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\ObjProvider.cs,Read,Cyclomatic complexity of the method is 59
Complex Method,Sledge.Providers.Map,VmfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\VmfProvider.cs,ReadWorld,Cyclomatic complexity of the method is 11
Complex Method,Sledge.Providers.Map,VmfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\VmfProvider.cs,GetFromStream,Cyclomatic complexity of the method is 14
Complex Method,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadModel,Cyclomatic complexity of the method is 30
Complex Method,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadSequence,Cyclomatic complexity of the method is 12
Complex Method,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadAnimationSource,Cyclomatic complexity of the method is 9
Complex Method,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadAnimationGoldsource,Cyclomatic complexity of the method is 10
Complex Method,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceMeshData,Cyclomatic complexity of the method is 29
Complex Method,Sledge.Providers.Texture,VmtProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\VmtProvider.cs,CreatePackages,Cyclomatic complexity of the method is 9
Complex Method,Sledge.Providers.Texture,SprProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\SprProvider.cs,Parse,Cyclomatic complexity of the method is 10
Complex Method,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,GetImage,Cyclomatic complexity of the method is 19
Complex Method,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,TransformRgba16161616F,Cyclomatic complexity of the method is 9
Complex Method,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,LoadImage,Cyclomatic complexity of the method is 115
Complex Method,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,Cyclomatic complexity of the method is 9
Complex Method,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,ComputeImageSize,Cyclomatic complexity of the method is 13
Long Parameter List,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadTextureInfo,The method has 6 parameters.
Long Parameter List,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadSequence,The method has 5 parameters.
Long Parameter List,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadStudioModel,The method has 6 parameters.
Long Parameter List,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadVerticesGoldSource,The method has 12 parameters.
Long Parameter List,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadVerticesSource,The method has 8 parameters.
Long Parameter List,Sledge.Providers.Texture,TextureItem,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\TextureItem.cs,TextureItem,The method has 5 parameters.
Long Parameter List,Sledge.Providers.Texture,TextureItem,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\TextureItem.cs,TextureItem,The method has 6 parameters.
Long Parameter List,Sledge.Providers.Texture,TextureSubItem,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\TextureSubItem.cs,TextureSubItem,The method has 5 parameters.
Long Parameter List,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,GetMipToLoad,The method has 5 parameters.
Long Parameter List,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,GetImageDataLocation,The method has 11 parameters.
Long Parameter List,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,TransformBytes,The method has 10 parameters.
Long Parameter List,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,TransformShorts,The method has 9 parameters.
Long Parameter List,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,ComputeMipmapSize,The method has 5 parameters.
Long Parameter List,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,ComputeImageSize,The method has 5 parameters.
Long Statement,Sledge.Providers.GameData,FgdProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GameData\FgdProvider.cs,ParseAt,The length of the statement  "			gd.Classes.AddRange (incgd.Classes.Where (x => !gd.Classes.Any (y => String.Equals (x.Name' y.Name' StringComparison.InvariantCultureIgnoreCase)))); " is 148.
Long Statement,Sledge.Providers.GameData,FgdProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GameData\FgdProvider.cs,ParseAt,The length of the statement  "			gd.AutoVisgroups.AddRange (incgd.AutoVisgroups.Where (x => !gd.AutoVisgroups.Any (y => String.Equals (x.Name' y.Name' StringComparison.InvariantCultureIgnoreCase)))); " is 166.
Long Statement,Sledge.Providers.GameData,FgdProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GameData\FgdProvider.cs,ParseAt,The length of the statement  "			gd.MaterialExclusions.AddRange (incgd.MaterialExclusions.Where (x => !gd.MaterialExclusions.Any (y => String.Equals (x' y' StringComparison.InvariantCultureIgnoreCase)))); " is 171.
Long Statement,Sledge.Providers.GameData,FgdProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GameData\FgdProvider.cs,ParseAt,The length of the statement  "			Assert (iterator.Current' iterator.Current.IsValueOrString ()' "Expected value type' got " + iterator.Current.Type + "."); " is 122.
Long Statement,Sledge.Providers.GameData,FgdProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GameData\FgdProvider.cs,ParseAt,The length of the statement  "		Assert (iterator.Current' iterator.Current.IsValueOrString ()' "Expected value type' got " + iterator.Current.Type + "."); " is 122.
Long Statement,Sledge.Providers.GameData,FgdProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GameData\FgdProvider.cs,ParseAt,The length of the statement  "			Assert (iterator.Current' iterator.Current.IsValueOrString ()' "Expected value type' got " + iterator.Current.Type + "."); " is 122.
Long Statement,Sledge.Providers.GameData,FgdProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GameData\FgdProvider.cs,ParseAt,The length of the statement  "				Assert (iterator.Current' iterator.Current.IsValueOrString ()' "Expected value type' got " + iterator.Current.Type + "."); " is 122.
Long Statement,Sledge.Providers.GameData,FgdProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GameData\FgdProvider.cs,ParseAt,The length of the statement  "					Assert (iterator.Current' iterator.Current.Type == LexType.Value || iterator.Current.Type == LexType.String' "Unexpected " + iterator.Current.Type + "."); " is 154.
Long Statement,Sledge.Providers.GameData,FgdProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GameData\FgdProvider.cs,ParseClassType,The length of the statement  "	throw new ProviderException ("Unable to parse FGD. Invalid class type: " + type + ".\n" + "On line " + obj.LineNumber + "' character " + obj.CharacterNumber); " is 158.
Long Statement,Sledge.Providers.GameData,FgdProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GameData\FgdProvider.cs,ParseVariableType,The length of the statement  "	throw new ProviderException ("Unable to parse FGD. Invalid variable type: " + type + ".\n" + "On line " + obj.LineNumber + "' character " + obj.CharacterNumber); " is 161.
Long Statement,Sledge.Providers.GameData,FgdProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GameData\FgdProvider.cs,Expect,The length of the statement  "		throw new ProviderException ("Unable to parse FGD. Expected " + lexType + "' got " + iterator.Current.Type + ".\n" + "On line " + iterator.Current.LineNumber + "' character " + iterator.Current.CharacterNumber); " is 211.
Long Statement,Sledge.Providers.GameData,FgdProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GameData\FgdProvider.cs,Assert,The length of the statement  "		throw new ProviderException ("Unable to parse FGD. " + error.Trim () + "\n" + "On line " + obj.LineNumber + "' character " + obj.CharacterNumber); " is 146.
Long Statement,Sledge.Providers,GenericStructure,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GenericStructure.cs,GetPropertyValue,The length of the statement  "	var prop = Properties.FirstOrDefault (x => String.Equals (x.Key' name' ignoreCase ? StringComparison.CurrentCultureIgnoreCase : StringComparison.CurrentCulture)); " is 162.
Long Statement,Sledge.Providers,GenericStructure,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GenericStructure.cs,PropertyPlane,The length of the statement  "	if (decimal.TryParse (split [0]' NumberStyles.Float' CultureInfo.InvariantCulture' out x1) && decimal.TryParse (split [1]' NumberStyles.Float' CultureInfo.InvariantCulture' out y1) && decimal.TryParse (split [2]' NumberStyles.Float' CultureInfo.InvariantCulture' out z1) && decimal.TryParse (split [3]' NumberStyles.Float' CultureInfo.InvariantCulture' out x2) && decimal.TryParse (split [4]' NumberStyles.Float' CultureInfo.InvariantCulture' out y2) && decimal.TryParse (split [5]' NumberStyles.Float' CultureInfo.InvariantCulture' out z2) && decimal.TryParse (split [6]' NumberStyles.Float' CultureInfo.InvariantCulture' out x3) && decimal.TryParse (split [7]' NumberStyles.Float' CultureInfo.InvariantCulture' out y3) && decimal.TryParse (split [8]' NumberStyles.Float' CultureInfo.InvariantCulture' out z3)) { " is 813.
Long Statement,Sledge.Providers,GenericStructure,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GenericStructure.cs,PropertyPlane,The length of the statement  "		return new Plane (new Coordinate (x1' y1' z1).Round ()' new Coordinate (x2' y2' z2).Round ()' new Coordinate (x3' y3' z3).Round ()); " is 132.
Long Statement,Sledge.Providers,GenericStructure,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GenericStructure.cs,PropertyCoordinate,The length of the statement  "	if (decimal.TryParse (split [0]' NumberStyles.Float' CultureInfo.InvariantCulture' out x) && decimal.TryParse (split [1]' NumberStyles.Float' CultureInfo.InvariantCulture' out y) && decimal.TryParse (split [2]' NumberStyles.Float' CultureInfo.InvariantCulture' out z)) { " is 270.
Long Statement,Sledge.Providers,GenericStructure,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GenericStructure.cs,PropertyCoordinateArray,The length of the statement  "		if (decimal.TryParse (split [i * 3]' NumberStyles.Float' CultureInfo.InvariantCulture' out x) && decimal.TryParse (split [i * 3 + 1]' NumberStyles.Float' CultureInfo.InvariantCulture' out y) && decimal.TryParse (split [i * 3 + 2]' NumberStyles.Float' CultureInfo.InvariantCulture' out z)) { " is 290.
Long Statement,Sledge.Providers,GenericStructure,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GenericStructure.cs,PropertyTextureAxis,The length of the statement  "	if (decimal.TryParse (split [0]' NumberStyles.Float' CultureInfo.InvariantCulture' out x) && decimal.TryParse (split [1]' NumberStyles.Float' CultureInfo.InvariantCulture' out y) && decimal.TryParse (split [2]' NumberStyles.Float' CultureInfo.InvariantCulture' out z) && decimal.TryParse (split [3]' NumberStyles.Float' CultureInfo.InvariantCulture' out sh) && decimal.TryParse (split [4]' NumberStyles.Float' CultureInfo.InvariantCulture' out sc)) { " is 450.
Long Statement,Sledge.Providers,GenericStructure,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GenericStructure.cs,PropertyColour,The length of the statement  "	if (int.TryParse (split [0]' NumberStyles.Integer' CultureInfo.InvariantCulture' out r) && int.TryParse (split [1]' NumberStyles.Integer' CultureInfo.InvariantCulture' out g) && int.TryParse (split [2]' NumberStyles.Integer' CultureInfo.InvariantCulture' out b)) { " is 264.
Long Statement,Sledge.Providers,GenericStructure,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GenericStructure.cs,GetDescendants,The length of the statement  "	return Children.Where (x => name == null || String.Equals (x.Name' name' StringComparison.CurrentCultureIgnoreCase)).Union (Children.SelectMany (x => x.GetDescendants (name))); " is 176.
Long Statement,Sledge.Providers,GenericStructure,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GenericStructure.cs,SerialiseHelper,The length of the statement  "		rf.AddProperty ("Serialise.Reference.Index"' (encounteredObjects.IndexOf (obj) + 1).ToString (CultureInfo.InvariantCulture)); " is 125.
Long Statement,Sledge.Providers,GenericStructure,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GenericStructure.cs,DeserialiseHelper,The length of the statement  "	var args = ctor.GetParameters ().Select (x => x.ParameterType.IsValueType ? Activator.CreateInstance (x.ParameterType) : null).ToArray (); " is 138.
Long Statement,Sledge.Providers,GenericStructure,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GenericStructure.cs,DeserialiseList,The length of the statement  "		var type = AppDomain.CurrentDomain.GetAssemblies ().Select (a => a.GetType (name)).FirstOrDefault (t => t != null) ?? (listType ?? typeof(object)); " is 147.
Long Statement,Sledge.Providers,GenericStructure,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GenericStructure.cs,ConvertPrimitive,The length of the statement  "		return new Box (Coordinate.Parse (spl [0].TrimStart ('(')' spl [1]' spl [2].TrimEnd (')'))' Coordinate.Parse (spl [3].TrimStart ('(')' spl [4]' spl [5].TrimEnd (')'))); " is 168.
Long Statement,Sledge.Providers.Map,MapFormatProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\MapFormatProvider.cs,IsValidForFileName,The length of the statement  "	return filename.EndsWith (".map"' true' CultureInfo.InvariantCulture) || filename.EndsWith (".max"' true' CultureInfo.InvariantCulture); " is 136.
Long Statement,Sledge.Providers.Map,MapFormatProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\MapFormatProvider.cs,FormatCoordinate,The length of the statement  "	return c.X.ToString ("0.000"' CultureInfo.InvariantCulture) + " " + c.Y.ToString ("0.000"' CultureInfo.InvariantCulture) + " " + c.Z.ToString ("0.000"' CultureInfo.InvariantCulture); " is 182.
Long Statement,Sledge.Providers.Map,MapFormatProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\MapFormatProvider.cs,ReadFace,The length of the statement  "		Plane = new Plane (Coordinate.Parse (parts [1]' parts [2]' parts [3])' Coordinate.Parse (parts [6]' parts [7]' parts [8])' Coordinate.Parse (parts [11]' parts [12]' parts [13]))' " is 178.
Long Statement,Sledge.Providers.Map,MapFormatProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\MapFormatProvider.cs,WriteEntity,The length of the statement  "		var gameDataProp = ent.GameData != null ? ent.GameData.Properties.FirstOrDefault (x => String.Equals (x.Name' prop.Key' StringComparison.InvariantCultureIgnoreCase)) : null; " is 173.
Long Statement,Sledge.Providers.Map,VmfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\VmfProvider.cs,IsValidForFileName,The length of the statement  "	return filename.EndsWith (".vmf"' true' CultureInfo.InvariantCulture) || filename.EndsWith (".vmx"' true' CultureInfo.InvariantCulture); " is 136.
Long Statement,Sledge.Providers.Map,VmfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\VmfProvider.cs,FormatCoordinate,The length of the statement  "	return c.X.ToString ("0.00000000"' CultureInfo.InvariantCulture) + " " + c.Y.ToString ("0.00000000"' CultureInfo.InvariantCulture) + " " + c.Z.ToString ("0.00000000"' CultureInfo.InvariantCulture); " is 197.
Long Statement,Sledge.Providers.Map,VmfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\VmfProvider.cs,FormatColor,The length of the statement  "	return c.R.ToString (CultureInfo.InvariantCulture) + " " + c.G.ToString (CultureInfo.InvariantCulture) + " " + c.B.ToString (CultureInfo.InvariantCulture); " is 155.
Long Statement,Sledge.Providers.Map,VmfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\VmfProvider.cs,ReadDisplacement,The length of the statement  "		var norm = normals != null ? normals.PropertyCoordinateArray (row' size) : Enumerable.Range (0' size).Select (x => Coordinate.Zero).ToArray (); " is 143.
Long Statement,Sledge.Providers.Map,VmfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\VmfProvider.cs,ReadDisplacement,The length of the statement  "		var dist = distances != null ? distances.PropertyDecimalArray (row' size) : Enumerable.Range (0' size).Select (x => 0m).ToArray (); " is 131.
Long Statement,Sledge.Providers.Map,VmfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\VmfProvider.cs,ReadDisplacement,The length of the statement  "		var offn = offsetNormals != null ? offsetNormals.PropertyCoordinateArray (row' size) : Enumerable.Range (0' size).Select (x => Coordinate.Zero).ToArray (); " is 155.
Long Statement,Sledge.Providers.Map,VmfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\VmfProvider.cs,ReadDisplacement,The length of the statement  "		var offs = offsets != null ? offsets.PropertyDecimalArray (row' size) : Enumerable.Range (0' size).Select (x => 0m).ToArray (); " is 127.
Long Statement,Sledge.Providers.Map,VmfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\VmfProvider.cs,ReadDisplacement,The length of the statement  "		var alph = alphas != null ? alphas.PropertyDecimalArray (row' size) : Enumerable.Range (0' size).Select (x => 0m).ToArray (); " is 125.
Long Statement,Sledge.Providers.Map,VmfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\VmfProvider.cs,WriteFace,The length of the statement  "	ret ["plane"] = String.Format ("({0}) ({1}) ({2})"' FormatCoordinate (face.Vertices [0].Location)' FormatCoordinate (face.Vertices [1].Location)' FormatCoordinate (face.Vertices [2].Location)); " is 193.
Long Statement,Sledge.Providers.Map,VmfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\VmfProvider.cs,WriteFace,The length of the statement  "	ret ["uaxis"] = String.Format (CultureInfo.InvariantCulture' "[{0} {1}] {2}"' FormatCoordinate (face.Texture.UAxis)' face.Texture.XShift' face.Texture.XScale); " is 159.
Long Statement,Sledge.Providers.Map,VmfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\VmfProvider.cs,WriteFace,The length of the statement  "	ret ["vaxis"] = String.Format (CultureInfo.InvariantCulture' "[{0} {1}] {2}"' FormatCoordinate (face.Texture.VAxis)' face.Texture.YShift' face.Texture.YScale); " is 159.
Long Statement,Sledge.Providers.Map,VmfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\VmfProvider.cs,ReadEntity,The length of the statement  "	foreach (var child in entity.GetChildren ("solid").Select (solid => ReadSolid (solid' generator)).Where (s => s != null)) { " is 123.
Long Statement,Sledge.Providers.Map,VmfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\VmfProvider.cs,CreateCopyStream,The length of the statement  "	stream.Children.AddRange (objects.OfType<Solid> ().Where (x => !x.IsCodeHidden && !x.IsVisgroupHidden && !entitySolids.Contains (x)).Select (WriteSolid)); " is 154.
Long Statement,Sledge.Providers.Map,VmfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\VmfProvider.cs,ExtractCopyStream,The length of the statement  "		var groupid = entity.Children.Where (x => x.Name == "editor").Select (x => x.PropertyInteger ("groupid")).FirstOrDefault (); " is 124.
Long Statement,Sledge.Providers.Map,VmfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\VmfProvider.cs,GetFromStream,The length of the statement  "			var groupid = entity.Children.Where (x => x.Name == "editor").Select (x => x.PropertyInteger ("groupid")).FirstOrDefault (); " is 124.
Long Statement,Sledge.Providers.Map,VmfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\VmfProvider.cs,GetFromStream,The length of the statement  "			var entParent = groupid > 0 ? map.WorldSpawn.Find (x => x.ID == groupid && x is Group).FirstOrDefault () ?? map.WorldSpawn : map.WorldSpawn; " is 140.
Long Statement,Sledge.Providers.Map,VmfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\VmfProvider.cs,SaveToStream,The length of the statement  "	versioninfo.AddProperty ("editorversion"' fvi.ProductMajorPart.ToString (CultureInfo.InvariantCulture) + "." + fvi.ProductMinorPart.ToString (CultureInfo.InvariantCulture)); " is 173.
Long Statement,Sledge.Providers.Map,RmfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\RmfProvider.cs,IsValidForFileName,The length of the statement  "	return filename.EndsWith (".rmf"' true' CultureInfo.InvariantCulture) || filename.EndsWith (".rmx"' true' CultureInfo.InvariantCulture); " is 136.
Long Statement,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadModel,The length of the statement  "	if (version != MDLVersionGoldsource && version != MDLVersionSource2006 && version != MDLVersionSourceEpisode2 && version != MDLVersionSourcePortal && version != MDLVersionSource2007 && version != MDLVersionSource2012) { " is 219.
Long Statement,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadAnimationSource,The length of the statement  "			var fangq = animBone != null && animBone.FixedQuaternion != null ? animBone.FixedQuaternion : QuaternionF.EulerAngles (fang.ComponentMultiply (bone.DefaultAnglesScale)); " is 169.
Long Statement,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceAnimationData,The length of the statement  "		var sourceAnim = new SourceAnimation (i' numframes' fps' animDescFlags' numMovements' movementIndex' ablock' aindex' numIkRules' ikRuleIndex' animBlockIkRuleIndex); " is 164.
Long Statement,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadAnimationGoldsource,The length of the statement  "			var fpos = new CoordinateF (frame [0]' frame [1]' frame [2]).ComponentMultiply (bone.DefaultPositionScale) + bone.DefaultPosition; " is 130.
Long Statement,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadAnimationGoldsource,The length of the statement  "			var fang = new CoordinateF (frame [3]' frame [4]' frame [5]).ComponentMultiply (bone.DefaultAnglesScale) + bone.DefaultAngles; " is 126.
Long Statement,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadStudioModel,The length of the statement  "		ReadVerticesGoldSource (br' groupName' modelIndex' model' numVerts' vertInfoIndex' vertIndex' numMesh' meshIndex' numNorms' normInfoIndex' normIndex); " is 150.
Long Statement,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadVerticesGoldSource,The length of the statement  "					mesh.Vertices.Add (new MeshVertex (vertices [vi.Vertex]' normals [vi.Normal]' model.Bones [boneIndex]' vi.TextureS' vi.TextureT)); " is 130.
Long Statement,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadVerticesSource,The length of the statement  "		foreach (var mm in modelData.Meshes.Where (mm => mm.BodyPart == bodyPartIndex && mm.Model == modelIndex && mm.LOD == 0 && mm.MeshIndex == meshId)) { " is 148.
Long Statement,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceMeshData,The length of the statement  "								// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown) " is 136.
Long Statement,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceMeshData,The length of the statement  "									// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown) " is 136.
Long Statement,Sledge.Providers.Model,ModelProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\ModelProvider.cs,LoadModel,The length of the statement  "			t.TextureObject = TextureHelper.Create (String.Format ("ModelProvider: {0}/{1}/{2}"' path' t.Name' i)' t.Image' t.Image.Width' t.Image.Height' TextureFlags.None); " is 162.
Long Statement,Sledge.Providers.Texture,VmtProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\VmtProvider.cs,CreatePackages,The length of the statement  "		if ((blist.Any (x => dir.Equals (x' ctype) || dir.StartsWith (x + '/'' ctype))) || (wlist.Any () && !wlist.Any (x => dir.Equals (x' ctype) || dir.StartsWith (x + '/'' ctype)))) { " is 178.
Long Statement,Sledge.Providers.Texture,SprProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\SprProvider.cs,Parse,The length of the statement  "		var data = bitmap.LockBits (new Rectangle (0' 0' bitmap.Width' bitmap.Height)' ImageLockMode.ReadWrite' bitmap.PixelFormat); " is 124.
Long Statement,Sledge.Providers.Texture,SprProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\SprProvider.cs,CreatePackages,The length of the statement  "	var dirs = sourceRoots.Union (additionalPackages).Where (Directory.Exists).Select (Path.GetFullPath).Select (x => x.ToLowerInvariant ()).Distinct ().ToList (); " is 159.
Long Statement,Sledge.Providers.Texture,TextureCollection,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\TextureCollection.cs,GetDefaultSelection,The length of the statement  "	return GetAllBrowsableItems ().OrderBy (x => new string (x.Name.Where (c => !ignored.Contains (c)).ToArray ()) + "Z").FirstOrDefault (); " is 136.
Long Statement,Sledge.Providers.Texture,TextureCollection,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\TextureCollection.cs,GetStreamSource,The length of the statement  "	var streams = packages.Where (x => x != null && x.Provider != null).GroupBy (x => x.Provider).Select (x => x.Key.GetStreamSource (maxWidth' maxHeight' x)).ToList (); " is 165.
Long Statement,Sledge.Providers.Texture,WadProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\WadProvider.cs,LoadFromCache,The length of the statement  "			items.Add (new TextureItem (package' spl [0]' GetFlags (spl [0])' int.Parse (spl [1]' CultureInfo.InvariantCulture)' int.Parse (spl [2]' CultureInfo.InvariantCulture))); " is 169.
Long Statement,Sledge.Providers.Texture,WadProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\WadProvider.cs,SaveToCache,The length of the statement  "		lines.Add (ti.Name + NullCharacter + ti.Width.ToString (CultureInfo.InvariantCulture) + NullCharacter + ti.Height.ToString (CultureInfo.InvariantCulture)); " is 155.
Long Statement,Sledge.Providers.Texture,WadProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\WadProvider.cs,CreatePackage,The length of the statement  "		list.AddRange (pack.Package.GetEntries ().OfType<WadEntry> ().Select (x => new TextureItem (tp' x.Name' GetFlags (x.Name)' (int)x.Width' (int)x.Height))); " is 154.
Long Statement,Sledge.Providers.Texture,WadProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\WadProvider.cs,CreatePackages,The length of the statement  "	var blist = blacklist.Select (x => x.EndsWith (".wad") ? x.Substring (0' x.Length - 4) : x).Where (x => !String.IsNullOrWhiteSpace (x)).ToList (); " is 146.
Long Statement,Sledge.Providers.Texture,WadProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\WadProvider.cs,CreatePackages,The length of the statement  "	var wlist = whitelist.Select (x => x.EndsWith (".wad") ? x.Substring (0' x.Length - 4) : x).Where (x => !String.IsNullOrWhiteSpace (x)).ToList (); " is 146.
Long Statement,Sledge.Providers.Texture,WadProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\WadProvider.cs,CreatePackages,The length of the statement  "	var wads = sourceRoots.Union (additionalPackages).Where (Directory.Exists).SelectMany (x => Directory.GetFiles (x' "*.wad"' SearchOption.TopDirectoryOnly)).Union (additionalPackages.Where (x => x.EndsWith (".wad") && File.Exists (x))).GroupBy (Path.GetFileNameWithoutExtension).Select (x => x.First ()).Where (x => !blist.Any (b => String.Equals (Path.GetFileNameWithoutExtension (x) ?? x' b' StringComparison.InvariantCultureIgnoreCase))); " is 440.
Long Statement,Sledge.Providers.Texture,WadProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\WadProvider.cs,CreatePackages,The length of the statement  "		wads = wads.Where (x => wlist.Contains (Path.GetFileNameWithoutExtension (x) ?? x' StringComparer.InvariantCultureIgnoreCase)); " is 127.
Long Statement,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,GetImage,The length of the statement  "		var thumbnailSize = lowResImageFormat == VtfImageFormat.None ? 0 : ComputeImageSize (lowResWidth' lowResHeight' 1' lowResImageFormat); " is 134.
Long Statement,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,GetImage,The length of the statement  "			mipNum = GetMipToLoad (width' height' maxWidth > 0 ? maxWidth : width' maxHeight > 0 ? maxHeight : height' mipmapCount); " is 120.
Long Statement,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,GetImage,The length of the statement  "						var offset = GetImageDataLocation (frame' face' slice' mip' highResImageFormat' width' height' numFrames' faces' depth' mipmapCount); " is 133.
Long Statement,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,GetImage,The length of the statement  "						//img.Save(String.Format(@"D:\Github\sledge\_Resources\VTF\_test_fr{0}_fa{1}_sl{2}_m{3}.png"' frame' face' slice' mip)); " is 120.
Long Statement,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,TransformRgba16161616F,The length of the statement  "	// I think the half format is slightly different to what it should be' which causes the result to be different to VTFLib. " is 121.
Long Statement,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,LoadImage,The length of the statement  "	var bits = bmp.LockBits (new Rectangle (0' 0' (int)width' (int)height)' ImageLockMode.WriteOnly' PixelFormat.Format32bppArgb); " is 126.
Complex Conditional,Sledge.Providers,GenericStructure,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GenericStructure.cs,PropertyPlane,The conditional expression  "decimal.TryParse (split [0]' NumberStyles.Float' CultureInfo.InvariantCulture' out x1) && decimal.TryParse (split [1]' NumberStyles.Float' CultureInfo.InvariantCulture' out y1) && decimal.TryParse (split [2]' NumberStyles.Float' CultureInfo.InvariantCulture' out z1) && decimal.TryParse (split [3]' NumberStyles.Float' CultureInfo.InvariantCulture' out x2) && decimal.TryParse (split [4]' NumberStyles.Float' CultureInfo.InvariantCulture' out y2) && decimal.TryParse (split [5]' NumberStyles.Float' CultureInfo.InvariantCulture' out z2) && decimal.TryParse (split [6]' NumberStyles.Float' CultureInfo.InvariantCulture' out x3) && decimal.TryParse (split [7]' NumberStyles.Float' CultureInfo.InvariantCulture' out y3) && decimal.TryParse (split [8]' NumberStyles.Float' CultureInfo.InvariantCulture' out z3)"  is complex.
Complex Conditional,Sledge.Providers,GenericStructure,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GenericStructure.cs,PropertyTextureAxis,The conditional expression  "decimal.TryParse (split [0]' NumberStyles.Float' CultureInfo.InvariantCulture' out x) && decimal.TryParse (split [1]' NumberStyles.Float' CultureInfo.InvariantCulture' out y) && decimal.TryParse (split [2]' NumberStyles.Float' CultureInfo.InvariantCulture' out z) && decimal.TryParse (split [3]' NumberStyles.Float' CultureInfo.InvariantCulture' out sh) && decimal.TryParse (split [4]' NumberStyles.Float' CultureInfo.InvariantCulture' out sc)"  is complex.
Complex Conditional,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadModel,The conditional expression  "version != MDLVersionGoldsource && version != MDLVersionSource2006 && version != MDLVersionSourceEpisode2 && version != MDLVersionSourcePortal && version != MDLVersionSource2007 && version != MDLVersionSource2012"  is complex.
Complex Conditional,Sledge.Providers.Texture,VmtProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\VmtProvider.cs,CreatePackages,The conditional expression  "(blist.Any (x => dir.Equals (x' ctype) || dir.StartsWith (x + '/'' ctype))) || (wlist.Any () && !wlist.Any (x => dir.Equals (x' ctype) || dir.StartsWith (x + '/'' ctype)))"  is complex.
Complex Conditional,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,TransformBytes,The conditional expression  "bluescreen && buffer [j + 0] == 255 && buffer [j + 1] == 0 && buffer [j + 2] == 0"  is complex.
Magic Number,Sledge.Providers,GenericStructure,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GenericStructure.cs,PropertyPlane,The following statement contains a magic number: if (prop == null || prop.Count (c => c == ' ') != 8)  	return defaultValue;  
Magic Number,Sledge.Providers,GenericStructure,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GenericStructure.cs,PropertyPlane,The following statement contains a magic number: if (decimal.TryParse (split [0]' NumberStyles.Float' CultureInfo.InvariantCulture' out x1) && decimal.TryParse (split [1]' NumberStyles.Float' CultureInfo.InvariantCulture' out y1) && decimal.TryParse (split [2]' NumberStyles.Float' CultureInfo.InvariantCulture' out z1) && decimal.TryParse (split [3]' NumberStyles.Float' CultureInfo.InvariantCulture' out x2) && decimal.TryParse (split [4]' NumberStyles.Float' CultureInfo.InvariantCulture' out y2) && decimal.TryParse (split [5]' NumberStyles.Float' CultureInfo.InvariantCulture' out z2) && decimal.TryParse (split [6]' NumberStyles.Float' CultureInfo.InvariantCulture' out x3) && decimal.TryParse (split [7]' NumberStyles.Float' CultureInfo.InvariantCulture' out y3) && decimal.TryParse (split [8]' NumberStyles.Float' CultureInfo.InvariantCulture' out z3)) {  	return new Plane (new Coordinate (x1' y1' z1).Round ()' new Coordinate (x2' y2' z2).Round ()' new Coordinate (x3' y3' z3).Round ());  }  
Magic Number,Sledge.Providers,GenericStructure,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GenericStructure.cs,PropertyPlane,The following statement contains a magic number: if (decimal.TryParse (split [0]' NumberStyles.Float' CultureInfo.InvariantCulture' out x1) && decimal.TryParse (split [1]' NumberStyles.Float' CultureInfo.InvariantCulture' out y1) && decimal.TryParse (split [2]' NumberStyles.Float' CultureInfo.InvariantCulture' out z1) && decimal.TryParse (split [3]' NumberStyles.Float' CultureInfo.InvariantCulture' out x2) && decimal.TryParse (split [4]' NumberStyles.Float' CultureInfo.InvariantCulture' out y2) && decimal.TryParse (split [5]' NumberStyles.Float' CultureInfo.InvariantCulture' out z2) && decimal.TryParse (split [6]' NumberStyles.Float' CultureInfo.InvariantCulture' out x3) && decimal.TryParse (split [7]' NumberStyles.Float' CultureInfo.InvariantCulture' out y3) && decimal.TryParse (split [8]' NumberStyles.Float' CultureInfo.InvariantCulture' out z3)) {  	return new Plane (new Coordinate (x1' y1' z1).Round ()' new Coordinate (x2' y2' z2).Round ()' new Coordinate (x3' y3' z3).Round ());  }  
Magic Number,Sledge.Providers,GenericStructure,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GenericStructure.cs,PropertyPlane,The following statement contains a magic number: if (decimal.TryParse (split [0]' NumberStyles.Float' CultureInfo.InvariantCulture' out x1) && decimal.TryParse (split [1]' NumberStyles.Float' CultureInfo.InvariantCulture' out y1) && decimal.TryParse (split [2]' NumberStyles.Float' CultureInfo.InvariantCulture' out z1) && decimal.TryParse (split [3]' NumberStyles.Float' CultureInfo.InvariantCulture' out x2) && decimal.TryParse (split [4]' NumberStyles.Float' CultureInfo.InvariantCulture' out y2) && decimal.TryParse (split [5]' NumberStyles.Float' CultureInfo.InvariantCulture' out z2) && decimal.TryParse (split [6]' NumberStyles.Float' CultureInfo.InvariantCulture' out x3) && decimal.TryParse (split [7]' NumberStyles.Float' CultureInfo.InvariantCulture' out y3) && decimal.TryParse (split [8]' NumberStyles.Float' CultureInfo.InvariantCulture' out z3)) {  	return new Plane (new Coordinate (x1' y1' z1).Round ()' new Coordinate (x2' y2' z2).Round ()' new Coordinate (x3' y3' z3).Round ());  }  
Magic Number,Sledge.Providers,GenericStructure,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GenericStructure.cs,PropertyPlane,The following statement contains a magic number: if (decimal.TryParse (split [0]' NumberStyles.Float' CultureInfo.InvariantCulture' out x1) && decimal.TryParse (split [1]' NumberStyles.Float' CultureInfo.InvariantCulture' out y1) && decimal.TryParse (split [2]' NumberStyles.Float' CultureInfo.InvariantCulture' out z1) && decimal.TryParse (split [3]' NumberStyles.Float' CultureInfo.InvariantCulture' out x2) && decimal.TryParse (split [4]' NumberStyles.Float' CultureInfo.InvariantCulture' out y2) && decimal.TryParse (split [5]' NumberStyles.Float' CultureInfo.InvariantCulture' out z2) && decimal.TryParse (split [6]' NumberStyles.Float' CultureInfo.InvariantCulture' out x3) && decimal.TryParse (split [7]' NumberStyles.Float' CultureInfo.InvariantCulture' out y3) && decimal.TryParse (split [8]' NumberStyles.Float' CultureInfo.InvariantCulture' out z3)) {  	return new Plane (new Coordinate (x1' y1' z1).Round ()' new Coordinate (x2' y2' z2).Round ()' new Coordinate (x3' y3' z3).Round ());  }  
Magic Number,Sledge.Providers,GenericStructure,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GenericStructure.cs,PropertyPlane,The following statement contains a magic number: if (decimal.TryParse (split [0]' NumberStyles.Float' CultureInfo.InvariantCulture' out x1) && decimal.TryParse (split [1]' NumberStyles.Float' CultureInfo.InvariantCulture' out y1) && decimal.TryParse (split [2]' NumberStyles.Float' CultureInfo.InvariantCulture' out z1) && decimal.TryParse (split [3]' NumberStyles.Float' CultureInfo.InvariantCulture' out x2) && decimal.TryParse (split [4]' NumberStyles.Float' CultureInfo.InvariantCulture' out y2) && decimal.TryParse (split [5]' NumberStyles.Float' CultureInfo.InvariantCulture' out z2) && decimal.TryParse (split [6]' NumberStyles.Float' CultureInfo.InvariantCulture' out x3) && decimal.TryParse (split [7]' NumberStyles.Float' CultureInfo.InvariantCulture' out y3) && decimal.TryParse (split [8]' NumberStyles.Float' CultureInfo.InvariantCulture' out z3)) {  	return new Plane (new Coordinate (x1' y1' z1).Round ()' new Coordinate (x2' y2' z2).Round ()' new Coordinate (x3' y3' z3).Round ());  }  
Magic Number,Sledge.Providers,GenericStructure,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GenericStructure.cs,PropertyPlane,The following statement contains a magic number: if (decimal.TryParse (split [0]' NumberStyles.Float' CultureInfo.InvariantCulture' out x1) && decimal.TryParse (split [1]' NumberStyles.Float' CultureInfo.InvariantCulture' out y1) && decimal.TryParse (split [2]' NumberStyles.Float' CultureInfo.InvariantCulture' out z1) && decimal.TryParse (split [3]' NumberStyles.Float' CultureInfo.InvariantCulture' out x2) && decimal.TryParse (split [4]' NumberStyles.Float' CultureInfo.InvariantCulture' out y2) && decimal.TryParse (split [5]' NumberStyles.Float' CultureInfo.InvariantCulture' out z2) && decimal.TryParse (split [6]' NumberStyles.Float' CultureInfo.InvariantCulture' out x3) && decimal.TryParse (split [7]' NumberStyles.Float' CultureInfo.InvariantCulture' out y3) && decimal.TryParse (split [8]' NumberStyles.Float' CultureInfo.InvariantCulture' out z3)) {  	return new Plane (new Coordinate (x1' y1' z1).Round ()' new Coordinate (x2' y2' z2).Round ()' new Coordinate (x3' y3' z3).Round ());  }  
Magic Number,Sledge.Providers,GenericStructure,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GenericStructure.cs,PropertyPlane,The following statement contains a magic number: if (decimal.TryParse (split [0]' NumberStyles.Float' CultureInfo.InvariantCulture' out x1) && decimal.TryParse (split [1]' NumberStyles.Float' CultureInfo.InvariantCulture' out y1) && decimal.TryParse (split [2]' NumberStyles.Float' CultureInfo.InvariantCulture' out z1) && decimal.TryParse (split [3]' NumberStyles.Float' CultureInfo.InvariantCulture' out x2) && decimal.TryParse (split [4]' NumberStyles.Float' CultureInfo.InvariantCulture' out y2) && decimal.TryParse (split [5]' NumberStyles.Float' CultureInfo.InvariantCulture' out z2) && decimal.TryParse (split [6]' NumberStyles.Float' CultureInfo.InvariantCulture' out x3) && decimal.TryParse (split [7]' NumberStyles.Float' CultureInfo.InvariantCulture' out y3) && decimal.TryParse (split [8]' NumberStyles.Float' CultureInfo.InvariantCulture' out z3)) {  	return new Plane (new Coordinate (x1' y1' z1).Round ()' new Coordinate (x2' y2' z2).Round ()' new Coordinate (x3' y3' z3).Round ());  }  
Magic Number,Sledge.Providers,GenericStructure,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GenericStructure.cs,PropertyCoordinate,The following statement contains a magic number: if (prop == null || prop.Count (c => c == ' ') != 2)  	return defaultValue;  
Magic Number,Sledge.Providers,GenericStructure,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GenericStructure.cs,PropertyCoordinate,The following statement contains a magic number: if (decimal.TryParse (split [0]' NumberStyles.Float' CultureInfo.InvariantCulture' out x) && decimal.TryParse (split [1]' NumberStyles.Float' CultureInfo.InvariantCulture' out y) && decimal.TryParse (split [2]' NumberStyles.Float' CultureInfo.InvariantCulture' out z)) {  	return new Coordinate (x' y' z);  }  
Magic Number,Sledge.Providers,GenericStructure,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GenericStructure.cs,PropertyCoordinateArray,The following statement contains a magic number: if (prop == null || prop.Count (c => c == ' ') != (count * 3 - 1))  	return defaultValue;  
Magic Number,Sledge.Providers,GenericStructure,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GenericStructure.cs,PropertyCoordinateArray,The following statement contains a magic number: for (var i = 0; i < count; i++) {  	decimal x' y' z;  	if (decimal.TryParse (split [i * 3]' NumberStyles.Float' CultureInfo.InvariantCulture' out x) && decimal.TryParse (split [i * 3 + 1]' NumberStyles.Float' CultureInfo.InvariantCulture' out y) && decimal.TryParse (split [i * 3 + 2]' NumberStyles.Float' CultureInfo.InvariantCulture' out z)) {  		defaultValue [i] = new Coordinate (x' y' z);  	}  }  
Magic Number,Sledge.Providers,GenericStructure,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GenericStructure.cs,PropertyCoordinateArray,The following statement contains a magic number: for (var i = 0; i < count; i++) {  	decimal x' y' z;  	if (decimal.TryParse (split [i * 3]' NumberStyles.Float' CultureInfo.InvariantCulture' out x) && decimal.TryParse (split [i * 3 + 1]' NumberStyles.Float' CultureInfo.InvariantCulture' out y) && decimal.TryParse (split [i * 3 + 2]' NumberStyles.Float' CultureInfo.InvariantCulture' out z)) {  		defaultValue [i] = new Coordinate (x' y' z);  	}  }  
Magic Number,Sledge.Providers,GenericStructure,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GenericStructure.cs,PropertyCoordinateArray,The following statement contains a magic number: for (var i = 0; i < count; i++) {  	decimal x' y' z;  	if (decimal.TryParse (split [i * 3]' NumberStyles.Float' CultureInfo.InvariantCulture' out x) && decimal.TryParse (split [i * 3 + 1]' NumberStyles.Float' CultureInfo.InvariantCulture' out y) && decimal.TryParse (split [i * 3 + 2]' NumberStyles.Float' CultureInfo.InvariantCulture' out z)) {  		defaultValue [i] = new Coordinate (x' y' z);  	}  }  
Magic Number,Sledge.Providers,GenericStructure,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GenericStructure.cs,PropertyCoordinateArray,The following statement contains a magic number: for (var i = 0; i < count; i++) {  	decimal x' y' z;  	if (decimal.TryParse (split [i * 3]' NumberStyles.Float' CultureInfo.InvariantCulture' out x) && decimal.TryParse (split [i * 3 + 1]' NumberStyles.Float' CultureInfo.InvariantCulture' out y) && decimal.TryParse (split [i * 3 + 2]' NumberStyles.Float' CultureInfo.InvariantCulture' out z)) {  		defaultValue [i] = new Coordinate (x' y' z);  	}  }  
Magic Number,Sledge.Providers,GenericStructure,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GenericStructure.cs,PropertyCoordinateArray,The following statement contains a magic number: if (decimal.TryParse (split [i * 3]' NumberStyles.Float' CultureInfo.InvariantCulture' out x) && decimal.TryParse (split [i * 3 + 1]' NumberStyles.Float' CultureInfo.InvariantCulture' out y) && decimal.TryParse (split [i * 3 + 2]' NumberStyles.Float' CultureInfo.InvariantCulture' out z)) {  	defaultValue [i] = new Coordinate (x' y' z);  }  
Magic Number,Sledge.Providers,GenericStructure,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GenericStructure.cs,PropertyCoordinateArray,The following statement contains a magic number: if (decimal.TryParse (split [i * 3]' NumberStyles.Float' CultureInfo.InvariantCulture' out x) && decimal.TryParse (split [i * 3 + 1]' NumberStyles.Float' CultureInfo.InvariantCulture' out y) && decimal.TryParse (split [i * 3 + 2]' NumberStyles.Float' CultureInfo.InvariantCulture' out z)) {  	defaultValue [i] = new Coordinate (x' y' z);  }  
Magic Number,Sledge.Providers,GenericStructure,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GenericStructure.cs,PropertyCoordinateArray,The following statement contains a magic number: if (decimal.TryParse (split [i * 3]' NumberStyles.Float' CultureInfo.InvariantCulture' out x) && decimal.TryParse (split [i * 3 + 1]' NumberStyles.Float' CultureInfo.InvariantCulture' out y) && decimal.TryParse (split [i * 3 + 2]' NumberStyles.Float' CultureInfo.InvariantCulture' out z)) {  	defaultValue [i] = new Coordinate (x' y' z);  }  
Magic Number,Sledge.Providers,GenericStructure,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GenericStructure.cs,PropertyCoordinateArray,The following statement contains a magic number: if (decimal.TryParse (split [i * 3]' NumberStyles.Float' CultureInfo.InvariantCulture' out x) && decimal.TryParse (split [i * 3 + 1]' NumberStyles.Float' CultureInfo.InvariantCulture' out y) && decimal.TryParse (split [i * 3 + 2]' NumberStyles.Float' CultureInfo.InvariantCulture' out z)) {  	defaultValue [i] = new Coordinate (x' y' z);  }  
Magic Number,Sledge.Providers,GenericStructure,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GenericStructure.cs,PropertyTextureAxis,The following statement contains a magic number: if (prop == null || prop.Count (c => c == ' ') != 4)  	return defaultValue;  
Magic Number,Sledge.Providers,GenericStructure,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GenericStructure.cs,PropertyTextureAxis,The following statement contains a magic number: if (decimal.TryParse (split [0]' NumberStyles.Float' CultureInfo.InvariantCulture' out x) && decimal.TryParse (split [1]' NumberStyles.Float' CultureInfo.InvariantCulture' out y) && decimal.TryParse (split [2]' NumberStyles.Float' CultureInfo.InvariantCulture' out z) && decimal.TryParse (split [3]' NumberStyles.Float' CultureInfo.InvariantCulture' out sh) && decimal.TryParse (split [4]' NumberStyles.Float' CultureInfo.InvariantCulture' out sc)) {  	return Tuple.Create (new Coordinate (x' y' z)' sh' sc);  }  
Magic Number,Sledge.Providers,GenericStructure,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GenericStructure.cs,PropertyTextureAxis,The following statement contains a magic number: if (decimal.TryParse (split [0]' NumberStyles.Float' CultureInfo.InvariantCulture' out x) && decimal.TryParse (split [1]' NumberStyles.Float' CultureInfo.InvariantCulture' out y) && decimal.TryParse (split [2]' NumberStyles.Float' CultureInfo.InvariantCulture' out z) && decimal.TryParse (split [3]' NumberStyles.Float' CultureInfo.InvariantCulture' out sh) && decimal.TryParse (split [4]' NumberStyles.Float' CultureInfo.InvariantCulture' out sc)) {  	return Tuple.Create (new Coordinate (x' y' z)' sh' sc);  }  
Magic Number,Sledge.Providers,GenericStructure,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GenericStructure.cs,PropertyTextureAxis,The following statement contains a magic number: if (decimal.TryParse (split [0]' NumberStyles.Float' CultureInfo.InvariantCulture' out x) && decimal.TryParse (split [1]' NumberStyles.Float' CultureInfo.InvariantCulture' out y) && decimal.TryParse (split [2]' NumberStyles.Float' CultureInfo.InvariantCulture' out z) && decimal.TryParse (split [3]' NumberStyles.Float' CultureInfo.InvariantCulture' out sh) && decimal.TryParse (split [4]' NumberStyles.Float' CultureInfo.InvariantCulture' out sc)) {  	return Tuple.Create (new Coordinate (x' y' z)' sh' sc);  }  
Magic Number,Sledge.Providers,GenericStructure,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GenericStructure.cs,PropertyColour,The following statement contains a magic number: if (prop == null || prop.Count (x => x == ' ') != 2)  	return defaultValue;  
Magic Number,Sledge.Providers,GenericStructure,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GenericStructure.cs,PropertyColour,The following statement contains a magic number: if (int.TryParse (split [0]' NumberStyles.Integer' CultureInfo.InvariantCulture' out r) && int.TryParse (split [1]' NumberStyles.Integer' CultureInfo.InvariantCulture' out g) && int.TryParse (split [2]' NumberStyles.Integer' CultureInfo.InvariantCulture' out b)) {  	return Color.FromArgb (r' g' b);  }  
Magic Number,Sledge.Providers,GenericStructure,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GenericStructure.cs,ConvertPrimitive,The following statement contains a magic number: switch (primitiveType) {  case "Boolean":  	return Boolean.Parse (value);  case "String":  	return value;  case "Numeric":  	return Decimal.Parse (value' NumberStyles.Float' CultureInfo.InvariantCulture);  case "DateTime":  	return DateTime.ParseExact (value' "u"' CultureInfo.InvariantCulture);  case "Colour":  	return Color.FromArgb (int.Parse (spl [3])' int.Parse (spl [0])' int.Parse (spl [1])' int.Parse (spl [2]));  case "Coordinate":  	return Coordinate.Parse (spl [0].TrimStart ('(')' spl [1]' spl [2].TrimEnd (')'));  case "Box":  	return new Box (Coordinate.Parse (spl [0].TrimStart ('(')' spl [1]' spl [2].TrimEnd (')'))' Coordinate.Parse (spl [3].TrimStart ('(')' spl [4]' spl [5].TrimEnd (')')));  case "Plane":  	return new Plane (Coordinate.Parse (spl [0].TrimStart ('(')' spl [1]' spl [2].TrimEnd (')'))' Decimal.Parse (spl [3]));  case "Rectangle":  	return new Rectangle (int.Parse (spl [0])' int.Parse (spl [1])' int.Parse (spl [2])' int.Parse (spl [3]));  default:  	throw new ArgumentException ();  }  
Magic Number,Sledge.Providers,GenericStructure,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GenericStructure.cs,ConvertPrimitive,The following statement contains a magic number: switch (primitiveType) {  case "Boolean":  	return Boolean.Parse (value);  case "String":  	return value;  case "Numeric":  	return Decimal.Parse (value' NumberStyles.Float' CultureInfo.InvariantCulture);  case "DateTime":  	return DateTime.ParseExact (value' "u"' CultureInfo.InvariantCulture);  case "Colour":  	return Color.FromArgb (int.Parse (spl [3])' int.Parse (spl [0])' int.Parse (spl [1])' int.Parse (spl [2]));  case "Coordinate":  	return Coordinate.Parse (spl [0].TrimStart ('(')' spl [1]' spl [2].TrimEnd (')'));  case "Box":  	return new Box (Coordinate.Parse (spl [0].TrimStart ('(')' spl [1]' spl [2].TrimEnd (')'))' Coordinate.Parse (spl [3].TrimStart ('(')' spl [4]' spl [5].TrimEnd (')')));  case "Plane":  	return new Plane (Coordinate.Parse (spl [0].TrimStart ('(')' spl [1]' spl [2].TrimEnd (')'))' Decimal.Parse (spl [3]));  case "Rectangle":  	return new Rectangle (int.Parse (spl [0])' int.Parse (spl [1])' int.Parse (spl [2])' int.Parse (spl [3]));  default:  	throw new ArgumentException ();  }  
Magic Number,Sledge.Providers,GenericStructure,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GenericStructure.cs,ConvertPrimitive,The following statement contains a magic number: switch (primitiveType) {  case "Boolean":  	return Boolean.Parse (value);  case "String":  	return value;  case "Numeric":  	return Decimal.Parse (value' NumberStyles.Float' CultureInfo.InvariantCulture);  case "DateTime":  	return DateTime.ParseExact (value' "u"' CultureInfo.InvariantCulture);  case "Colour":  	return Color.FromArgb (int.Parse (spl [3])' int.Parse (spl [0])' int.Parse (spl [1])' int.Parse (spl [2]));  case "Coordinate":  	return Coordinate.Parse (spl [0].TrimStart ('(')' spl [1]' spl [2].TrimEnd (')'));  case "Box":  	return new Box (Coordinate.Parse (spl [0].TrimStart ('(')' spl [1]' spl [2].TrimEnd (')'))' Coordinate.Parse (spl [3].TrimStart ('(')' spl [4]' spl [5].TrimEnd (')')));  case "Plane":  	return new Plane (Coordinate.Parse (spl [0].TrimStart ('(')' spl [1]' spl [2].TrimEnd (')'))' Decimal.Parse (spl [3]));  case "Rectangle":  	return new Rectangle (int.Parse (spl [0])' int.Parse (spl [1])' int.Parse (spl [2])' int.Parse (spl [3]));  default:  	throw new ArgumentException ();  }  
Magic Number,Sledge.Providers,GenericStructure,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GenericStructure.cs,ConvertPrimitive,The following statement contains a magic number: switch (primitiveType) {  case "Boolean":  	return Boolean.Parse (value);  case "String":  	return value;  case "Numeric":  	return Decimal.Parse (value' NumberStyles.Float' CultureInfo.InvariantCulture);  case "DateTime":  	return DateTime.ParseExact (value' "u"' CultureInfo.InvariantCulture);  case "Colour":  	return Color.FromArgb (int.Parse (spl [3])' int.Parse (spl [0])' int.Parse (spl [1])' int.Parse (spl [2]));  case "Coordinate":  	return Coordinate.Parse (spl [0].TrimStart ('(')' spl [1]' spl [2].TrimEnd (')'));  case "Box":  	return new Box (Coordinate.Parse (spl [0].TrimStart ('(')' spl [1]' spl [2].TrimEnd (')'))' Coordinate.Parse (spl [3].TrimStart ('(')' spl [4]' spl [5].TrimEnd (')')));  case "Plane":  	return new Plane (Coordinate.Parse (spl [0].TrimStart ('(')' spl [1]' spl [2].TrimEnd (')'))' Decimal.Parse (spl [3]));  case "Rectangle":  	return new Rectangle (int.Parse (spl [0])' int.Parse (spl [1])' int.Parse (spl [2])' int.Parse (spl [3]));  default:  	throw new ArgumentException ();  }  
Magic Number,Sledge.Providers,GenericStructure,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GenericStructure.cs,ConvertPrimitive,The following statement contains a magic number: switch (primitiveType) {  case "Boolean":  	return Boolean.Parse (value);  case "String":  	return value;  case "Numeric":  	return Decimal.Parse (value' NumberStyles.Float' CultureInfo.InvariantCulture);  case "DateTime":  	return DateTime.ParseExact (value' "u"' CultureInfo.InvariantCulture);  case "Colour":  	return Color.FromArgb (int.Parse (spl [3])' int.Parse (spl [0])' int.Parse (spl [1])' int.Parse (spl [2]));  case "Coordinate":  	return Coordinate.Parse (spl [0].TrimStart ('(')' spl [1]' spl [2].TrimEnd (')'));  case "Box":  	return new Box (Coordinate.Parse (spl [0].TrimStart ('(')' spl [1]' spl [2].TrimEnd (')'))' Coordinate.Parse (spl [3].TrimStart ('(')' spl [4]' spl [5].TrimEnd (')')));  case "Plane":  	return new Plane (Coordinate.Parse (spl [0].TrimStart ('(')' spl [1]' spl [2].TrimEnd (')'))' Decimal.Parse (spl [3]));  case "Rectangle":  	return new Rectangle (int.Parse (spl [0])' int.Parse (spl [1])' int.Parse (spl [2])' int.Parse (spl [3]));  default:  	throw new ArgumentException ();  }  
Magic Number,Sledge.Providers,GenericStructure,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GenericStructure.cs,ConvertPrimitive,The following statement contains a magic number: switch (primitiveType) {  case "Boolean":  	return Boolean.Parse (value);  case "String":  	return value;  case "Numeric":  	return Decimal.Parse (value' NumberStyles.Float' CultureInfo.InvariantCulture);  case "DateTime":  	return DateTime.ParseExact (value' "u"' CultureInfo.InvariantCulture);  case "Colour":  	return Color.FromArgb (int.Parse (spl [3])' int.Parse (spl [0])' int.Parse (spl [1])' int.Parse (spl [2]));  case "Coordinate":  	return Coordinate.Parse (spl [0].TrimStart ('(')' spl [1]' spl [2].TrimEnd (')'));  case "Box":  	return new Box (Coordinate.Parse (spl [0].TrimStart ('(')' spl [1]' spl [2].TrimEnd (')'))' Coordinate.Parse (spl [3].TrimStart ('(')' spl [4]' spl [5].TrimEnd (')')));  case "Plane":  	return new Plane (Coordinate.Parse (spl [0].TrimStart ('(')' spl [1]' spl [2].TrimEnd (')'))' Decimal.Parse (spl [3]));  case "Rectangle":  	return new Rectangle (int.Parse (spl [0])' int.Parse (spl [1])' int.Parse (spl [2])' int.Parse (spl [3]));  default:  	throw new ArgumentException ();  }  
Magic Number,Sledge.Providers,GenericStructure,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GenericStructure.cs,ConvertPrimitive,The following statement contains a magic number: switch (primitiveType) {  case "Boolean":  	return Boolean.Parse (value);  case "String":  	return value;  case "Numeric":  	return Decimal.Parse (value' NumberStyles.Float' CultureInfo.InvariantCulture);  case "DateTime":  	return DateTime.ParseExact (value' "u"' CultureInfo.InvariantCulture);  case "Colour":  	return Color.FromArgb (int.Parse (spl [3])' int.Parse (spl [0])' int.Parse (spl [1])' int.Parse (spl [2]));  case "Coordinate":  	return Coordinate.Parse (spl [0].TrimStart ('(')' spl [1]' spl [2].TrimEnd (')'));  case "Box":  	return new Box (Coordinate.Parse (spl [0].TrimStart ('(')' spl [1]' spl [2].TrimEnd (')'))' Coordinate.Parse (spl [3].TrimStart ('(')' spl [4]' spl [5].TrimEnd (')')));  case "Plane":  	return new Plane (Coordinate.Parse (spl [0].TrimStart ('(')' spl [1]' spl [2].TrimEnd (')'))' Decimal.Parse (spl [3]));  case "Rectangle":  	return new Rectangle (int.Parse (spl [0])' int.Parse (spl [1])' int.Parse (spl [2])' int.Parse (spl [3]));  default:  	throw new ArgumentException ();  }  
Magic Number,Sledge.Providers,GenericStructure,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GenericStructure.cs,ConvertPrimitive,The following statement contains a magic number: switch (primitiveType) {  case "Boolean":  	return Boolean.Parse (value);  case "String":  	return value;  case "Numeric":  	return Decimal.Parse (value' NumberStyles.Float' CultureInfo.InvariantCulture);  case "DateTime":  	return DateTime.ParseExact (value' "u"' CultureInfo.InvariantCulture);  case "Colour":  	return Color.FromArgb (int.Parse (spl [3])' int.Parse (spl [0])' int.Parse (spl [1])' int.Parse (spl [2]));  case "Coordinate":  	return Coordinate.Parse (spl [0].TrimStart ('(')' spl [1]' spl [2].TrimEnd (')'));  case "Box":  	return new Box (Coordinate.Parse (spl [0].TrimStart ('(')' spl [1]' spl [2].TrimEnd (')'))' Coordinate.Parse (spl [3].TrimStart ('(')' spl [4]' spl [5].TrimEnd (')')));  case "Plane":  	return new Plane (Coordinate.Parse (spl [0].TrimStart ('(')' spl [1]' spl [2].TrimEnd (')'))' Decimal.Parse (spl [3]));  case "Rectangle":  	return new Rectangle (int.Parse (spl [0])' int.Parse (spl [1])' int.Parse (spl [2])' int.Parse (spl [3]));  default:  	throw new ArgumentException ();  }  
Magic Number,Sledge.Providers,GenericStructure,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GenericStructure.cs,ConvertPrimitive,The following statement contains a magic number: switch (primitiveType) {  case "Boolean":  	return Boolean.Parse (value);  case "String":  	return value;  case "Numeric":  	return Decimal.Parse (value' NumberStyles.Float' CultureInfo.InvariantCulture);  case "DateTime":  	return DateTime.ParseExact (value' "u"' CultureInfo.InvariantCulture);  case "Colour":  	return Color.FromArgb (int.Parse (spl [3])' int.Parse (spl [0])' int.Parse (spl [1])' int.Parse (spl [2]));  case "Coordinate":  	return Coordinate.Parse (spl [0].TrimStart ('(')' spl [1]' spl [2].TrimEnd (')'));  case "Box":  	return new Box (Coordinate.Parse (spl [0].TrimStart ('(')' spl [1]' spl [2].TrimEnd (')'))' Coordinate.Parse (spl [3].TrimStart ('(')' spl [4]' spl [5].TrimEnd (')')));  case "Plane":  	return new Plane (Coordinate.Parse (spl [0].TrimStart ('(')' spl [1]' spl [2].TrimEnd (')'))' Decimal.Parse (spl [3]));  case "Rectangle":  	return new Rectangle (int.Parse (spl [0])' int.Parse (spl [1])' int.Parse (spl [2])' int.Parse (spl [3]));  default:  	throw new ArgumentException ();  }  
Magic Number,Sledge.Providers,GenericStructure,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GenericStructure.cs,ConvertPrimitive,The following statement contains a magic number: switch (primitiveType) {  case "Boolean":  	return Boolean.Parse (value);  case "String":  	return value;  case "Numeric":  	return Decimal.Parse (value' NumberStyles.Float' CultureInfo.InvariantCulture);  case "DateTime":  	return DateTime.ParseExact (value' "u"' CultureInfo.InvariantCulture);  case "Colour":  	return Color.FromArgb (int.Parse (spl [3])' int.Parse (spl [0])' int.Parse (spl [1])' int.Parse (spl [2]));  case "Coordinate":  	return Coordinate.Parse (spl [0].TrimStart ('(')' spl [1]' spl [2].TrimEnd (')'));  case "Box":  	return new Box (Coordinate.Parse (spl [0].TrimStart ('(')' spl [1]' spl [2].TrimEnd (')'))' Coordinate.Parse (spl [3].TrimStart ('(')' spl [4]' spl [5].TrimEnd (')')));  case "Plane":  	return new Plane (Coordinate.Parse (spl [0].TrimStart ('(')' spl [1]' spl [2].TrimEnd (')'))' Decimal.Parse (spl [3]));  case "Rectangle":  	return new Rectangle (int.Parse (spl [0])' int.Parse (spl [1])' int.Parse (spl [2])' int.Parse (spl [3]));  default:  	throw new ArgumentException ();  }  
Magic Number,Sledge.Providers,GenericStructure,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GenericStructure.cs,ConvertPrimitive,The following statement contains a magic number: switch (primitiveType) {  case "Boolean":  	return Boolean.Parse (value);  case "String":  	return value;  case "Numeric":  	return Decimal.Parse (value' NumberStyles.Float' CultureInfo.InvariantCulture);  case "DateTime":  	return DateTime.ParseExact (value' "u"' CultureInfo.InvariantCulture);  case "Colour":  	return Color.FromArgb (int.Parse (spl [3])' int.Parse (spl [0])' int.Parse (spl [1])' int.Parse (spl [2]));  case "Coordinate":  	return Coordinate.Parse (spl [0].TrimStart ('(')' spl [1]' spl [2].TrimEnd (')'));  case "Box":  	return new Box (Coordinate.Parse (spl [0].TrimStart ('(')' spl [1]' spl [2].TrimEnd (')'))' Coordinate.Parse (spl [3].TrimStart ('(')' spl [4]' spl [5].TrimEnd (')')));  case "Plane":  	return new Plane (Coordinate.Parse (spl [0].TrimStart ('(')' spl [1]' spl [2].TrimEnd (')'))' Decimal.Parse (spl [3]));  case "Rectangle":  	return new Rectangle (int.Parse (spl [0])' int.Parse (spl [1])' int.Parse (spl [2])' int.Parse (spl [3]));  default:  	throw new ArgumentException ();  }  
Magic Number,Sledge.Providers,GenericStructure,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GenericStructure.cs,ConvertPrimitive,The following statement contains a magic number: return Color.FromArgb (int.Parse (spl [3])' int.Parse (spl [0])' int.Parse (spl [1])' int.Parse (spl [2]));  
Magic Number,Sledge.Providers,GenericStructure,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GenericStructure.cs,ConvertPrimitive,The following statement contains a magic number: return Color.FromArgb (int.Parse (spl [3])' int.Parse (spl [0])' int.Parse (spl [1])' int.Parse (spl [2]));  
Magic Number,Sledge.Providers,GenericStructure,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GenericStructure.cs,ConvertPrimitive,The following statement contains a magic number: return Coordinate.Parse (spl [0].TrimStart ('(')' spl [1]' spl [2].TrimEnd (')'));  
Magic Number,Sledge.Providers,GenericStructure,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GenericStructure.cs,ConvertPrimitive,The following statement contains a magic number: return new Box (Coordinate.Parse (spl [0].TrimStart ('(')' spl [1]' spl [2].TrimEnd (')'))' Coordinate.Parse (spl [3].TrimStart ('(')' spl [4]' spl [5].TrimEnd (')')));  
Magic Number,Sledge.Providers,GenericStructure,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GenericStructure.cs,ConvertPrimitive,The following statement contains a magic number: return new Box (Coordinate.Parse (spl [0].TrimStart ('(')' spl [1]' spl [2].TrimEnd (')'))' Coordinate.Parse (spl [3].TrimStart ('(')' spl [4]' spl [5].TrimEnd (')')));  
Magic Number,Sledge.Providers,GenericStructure,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GenericStructure.cs,ConvertPrimitive,The following statement contains a magic number: return new Box (Coordinate.Parse (spl [0].TrimStart ('(')' spl [1]' spl [2].TrimEnd (')'))' Coordinate.Parse (spl [3].TrimStart ('(')' spl [4]' spl [5].TrimEnd (')')));  
Magic Number,Sledge.Providers,GenericStructure,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GenericStructure.cs,ConvertPrimitive,The following statement contains a magic number: return new Box (Coordinate.Parse (spl [0].TrimStart ('(')' spl [1]' spl [2].TrimEnd (')'))' Coordinate.Parse (spl [3].TrimStart ('(')' spl [4]' spl [5].TrimEnd (')')));  
Magic Number,Sledge.Providers,GenericStructure,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GenericStructure.cs,ConvertPrimitive,The following statement contains a magic number: return new Plane (Coordinate.Parse (spl [0].TrimStart ('(')' spl [1]' spl [2].TrimEnd (')'))' Decimal.Parse (spl [3]));  
Magic Number,Sledge.Providers,GenericStructure,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GenericStructure.cs,ConvertPrimitive,The following statement contains a magic number: return new Plane (Coordinate.Parse (spl [0].TrimStart ('(')' spl [1]' spl [2].TrimEnd (')'))' Decimal.Parse (spl [3]));  
Magic Number,Sledge.Providers,GenericStructure,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GenericStructure.cs,ConvertPrimitive,The following statement contains a magic number: return new Rectangle (int.Parse (spl [0])' int.Parse (spl [1])' int.Parse (spl [2])' int.Parse (spl [3]));  
Magic Number,Sledge.Providers,GenericStructure,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GenericStructure.cs,ConvertPrimitive,The following statement contains a magic number: return new Rectangle (int.Parse (spl [0])' int.Parse (spl [1])' int.Parse (spl [2])' int.Parse (spl [3]));  
Magic Number,Sledge.Providers,GenericStructure,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GenericStructure.cs,Print,The following statement contains a magic number: foreach (var kv in Properties) {  	tw.Write (postTabStr);  	tw.Write ('"');  	tw.Write (LengthLimit (kv.Key' 1024));  	tw.Write ('"');  	tw.Write (' ');  	tw.Write ('"');  	tw.Write (LengthLimit ((kv.Value ?? "").Replace ('"'' '`')' 1024));  	tw.Write ('"');  	tw.WriteLine ();  }  
Magic Number,Sledge.Providers,GenericStructure,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GenericStructure.cs,Print,The following statement contains a magic number: foreach (var kv in Properties) {  	tw.Write (postTabStr);  	tw.Write ('"');  	tw.Write (LengthLimit (kv.Key' 1024));  	tw.Write ('"');  	tw.Write (' ');  	tw.Write ('"');  	tw.Write (LengthLimit ((kv.Value ?? "").Replace ('"'' '`')' 1024));  	tw.Write ('"');  	tw.WriteLine ();  }  
Magic Number,Sledge.Providers,GenericStructure,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GenericStructure.cs,Print,The following statement contains a magic number: tw.Write (LengthLimit (kv.Key' 1024));  
Magic Number,Sledge.Providers,GenericStructure,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GenericStructure.cs,Print,The following statement contains a magic number: tw.Write (LengthLimit ((kv.Value ?? "").Replace ('"'' '`')' 1024));  
Magic Number,Sledge.Providers,GenericStructure,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GenericStructure.cs,ParseStructure,The following statement contains a magic number: if (spl.Length != 2 || spl [1] != "{") {  	do {  		line = CleanLine (reader.ReadLine ());  	} while (String.IsNullOrWhiteSpace (line));  	if (line != "{") {  		return gs;  	}  }  
Magic Number,Sledge.Providers,GenericStructure,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GenericStructure.cs,ValidStructStartString,The following statement contains a magic number: return split.Length == 1 || (split.Length == 2 && split [1] == "{");  
Magic Number,Sledge.Providers,GenericStructure,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GenericStructure.cs,ValidStructPropertyString,The following statement contains a magic number: return split.Length == 2;  
Magic Number,Sledge.Providers,BinaryExtensions,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\BinaryExtensions.cs,WritePlane,The following statement contains a magic number: WriteCoordinate (bw' coords [2]);  
Magic Number,Sledge.Providers,BinaryExtensions,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\BinaryExtensions.cs,ReadRGBColour,The following statement contains a magic number: return Color.FromArgb (255' br.ReadByte ()' br.ReadByte ()' br.ReadByte ());  
Magic Number,Sledge.Providers.Map,MapFormatProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\MapFormatProvider.cs,ReadFace,The following statement contains a magic number: Assert (parts [4] == ")");  
Magic Number,Sledge.Providers.Map,MapFormatProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\MapFormatProvider.cs,ReadFace,The following statement contains a magic number: Assert (parts [5] == "(");  
Magic Number,Sledge.Providers.Map,MapFormatProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\MapFormatProvider.cs,ReadFace,The following statement contains a magic number: Assert (parts [9] == ")");  
Magic Number,Sledge.Providers.Map,MapFormatProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\MapFormatProvider.cs,ReadFace,The following statement contains a magic number: Assert (parts [10] == "(");  
Magic Number,Sledge.Providers.Map,MapFormatProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\MapFormatProvider.cs,ReadFace,The following statement contains a magic number: Assert (parts [14] == ")");  
Magic Number,Sledge.Providers.Map,MapFormatProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\MapFormatProvider.cs,ReadFace,The following statement contains a magic number: if (parts.Count == 21) {  	face.AlignTextureToFace ();  	face.Texture.XShift = decimal.Parse (parts [16]' ns' CultureInfo.InvariantCulture);  	face.Texture.YShift = decimal.Parse (parts [17]' ns' CultureInfo.InvariantCulture);  	face.Texture.Rotation = decimal.Parse (parts [18]' ns' CultureInfo.InvariantCulture);  	face.Texture.XScale = decimal.Parse (parts [19]' ns' CultureInfo.InvariantCulture);  	face.Texture.YScale = decimal.Parse (parts [20]' ns' CultureInfo.InvariantCulture);  } else {  	Assert (parts [16] == "[");  	Assert (parts [21] == "]");  	Assert (parts [22] == "[");  	Assert (parts [27] == "]");  	face.Texture.UAxis = Coordinate.Parse (parts [17]' parts [18]' parts [19]);  	face.Texture.XShift = decimal.Parse (parts [20]' ns' CultureInfo.InvariantCulture);  	face.Texture.VAxis = Coordinate.Parse (parts [23]' parts [24]' parts [25]);  	face.Texture.YShift = decimal.Parse (parts [26]' ns' CultureInfo.InvariantCulture);  	face.Texture.Rotation = decimal.Parse (parts [28]' ns' CultureInfo.InvariantCulture);  	face.Texture.XScale = decimal.Parse (parts [29]' ns' CultureInfo.InvariantCulture);  	face.Texture.YScale = decimal.Parse (parts [30]' ns' CultureInfo.InvariantCulture);  }  
Magic Number,Sledge.Providers.Map,MapFormatProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\MapFormatProvider.cs,ReadFace,The following statement contains a magic number: if (parts.Count == 21) {  	face.AlignTextureToFace ();  	face.Texture.XShift = decimal.Parse (parts [16]' ns' CultureInfo.InvariantCulture);  	face.Texture.YShift = decimal.Parse (parts [17]' ns' CultureInfo.InvariantCulture);  	face.Texture.Rotation = decimal.Parse (parts [18]' ns' CultureInfo.InvariantCulture);  	face.Texture.XScale = decimal.Parse (parts [19]' ns' CultureInfo.InvariantCulture);  	face.Texture.YScale = decimal.Parse (parts [20]' ns' CultureInfo.InvariantCulture);  } else {  	Assert (parts [16] == "[");  	Assert (parts [21] == "]");  	Assert (parts [22] == "[");  	Assert (parts [27] == "]");  	face.Texture.UAxis = Coordinate.Parse (parts [17]' parts [18]' parts [19]);  	face.Texture.XShift = decimal.Parse (parts [20]' ns' CultureInfo.InvariantCulture);  	face.Texture.VAxis = Coordinate.Parse (parts [23]' parts [24]' parts [25]);  	face.Texture.YShift = decimal.Parse (parts [26]' ns' CultureInfo.InvariantCulture);  	face.Texture.Rotation = decimal.Parse (parts [28]' ns' CultureInfo.InvariantCulture);  	face.Texture.XScale = decimal.Parse (parts [29]' ns' CultureInfo.InvariantCulture);  	face.Texture.YScale = decimal.Parse (parts [30]' ns' CultureInfo.InvariantCulture);  }  
Magic Number,Sledge.Providers.Map,MapFormatProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\MapFormatProvider.cs,ReadFace,The following statement contains a magic number: if (parts.Count == 21) {  	face.AlignTextureToFace ();  	face.Texture.XShift = decimal.Parse (parts [16]' ns' CultureInfo.InvariantCulture);  	face.Texture.YShift = decimal.Parse (parts [17]' ns' CultureInfo.InvariantCulture);  	face.Texture.Rotation = decimal.Parse (parts [18]' ns' CultureInfo.InvariantCulture);  	face.Texture.XScale = decimal.Parse (parts [19]' ns' CultureInfo.InvariantCulture);  	face.Texture.YScale = decimal.Parse (parts [20]' ns' CultureInfo.InvariantCulture);  } else {  	Assert (parts [16] == "[");  	Assert (parts [21] == "]");  	Assert (parts [22] == "[");  	Assert (parts [27] == "]");  	face.Texture.UAxis = Coordinate.Parse (parts [17]' parts [18]' parts [19]);  	face.Texture.XShift = decimal.Parse (parts [20]' ns' CultureInfo.InvariantCulture);  	face.Texture.VAxis = Coordinate.Parse (parts [23]' parts [24]' parts [25]);  	face.Texture.YShift = decimal.Parse (parts [26]' ns' CultureInfo.InvariantCulture);  	face.Texture.Rotation = decimal.Parse (parts [28]' ns' CultureInfo.InvariantCulture);  	face.Texture.XScale = decimal.Parse (parts [29]' ns' CultureInfo.InvariantCulture);  	face.Texture.YScale = decimal.Parse (parts [30]' ns' CultureInfo.InvariantCulture);  }  
Magic Number,Sledge.Providers.Map,MapFormatProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\MapFormatProvider.cs,ReadFace,The following statement contains a magic number: if (parts.Count == 21) {  	face.AlignTextureToFace ();  	face.Texture.XShift = decimal.Parse (parts [16]' ns' CultureInfo.InvariantCulture);  	face.Texture.YShift = decimal.Parse (parts [17]' ns' CultureInfo.InvariantCulture);  	face.Texture.Rotation = decimal.Parse (parts [18]' ns' CultureInfo.InvariantCulture);  	face.Texture.XScale = decimal.Parse (parts [19]' ns' CultureInfo.InvariantCulture);  	face.Texture.YScale = decimal.Parse (parts [20]' ns' CultureInfo.InvariantCulture);  } else {  	Assert (parts [16] == "[");  	Assert (parts [21] == "]");  	Assert (parts [22] == "[");  	Assert (parts [27] == "]");  	face.Texture.UAxis = Coordinate.Parse (parts [17]' parts [18]' parts [19]);  	face.Texture.XShift = decimal.Parse (parts [20]' ns' CultureInfo.InvariantCulture);  	face.Texture.VAxis = Coordinate.Parse (parts [23]' parts [24]' parts [25]);  	face.Texture.YShift = decimal.Parse (parts [26]' ns' CultureInfo.InvariantCulture);  	face.Texture.Rotation = decimal.Parse (parts [28]' ns' CultureInfo.InvariantCulture);  	face.Texture.XScale = decimal.Parse (parts [29]' ns' CultureInfo.InvariantCulture);  	face.Texture.YScale = decimal.Parse (parts [30]' ns' CultureInfo.InvariantCulture);  }  
Magic Number,Sledge.Providers.Map,MapFormatProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\MapFormatProvider.cs,ReadFace,The following statement contains a magic number: if (parts.Count == 21) {  	face.AlignTextureToFace ();  	face.Texture.XShift = decimal.Parse (parts [16]' ns' CultureInfo.InvariantCulture);  	face.Texture.YShift = decimal.Parse (parts [17]' ns' CultureInfo.InvariantCulture);  	face.Texture.Rotation = decimal.Parse (parts [18]' ns' CultureInfo.InvariantCulture);  	face.Texture.XScale = decimal.Parse (parts [19]' ns' CultureInfo.InvariantCulture);  	face.Texture.YScale = decimal.Parse (parts [20]' ns' CultureInfo.InvariantCulture);  } else {  	Assert (parts [16] == "[");  	Assert (parts [21] == "]");  	Assert (parts [22] == "[");  	Assert (parts [27] == "]");  	face.Texture.UAxis = Coordinate.Parse (parts [17]' parts [18]' parts [19]);  	face.Texture.XShift = decimal.Parse (parts [20]' ns' CultureInfo.InvariantCulture);  	face.Texture.VAxis = Coordinate.Parse (parts [23]' parts [24]' parts [25]);  	face.Texture.YShift = decimal.Parse (parts [26]' ns' CultureInfo.InvariantCulture);  	face.Texture.Rotation = decimal.Parse (parts [28]' ns' CultureInfo.InvariantCulture);  	face.Texture.XScale = decimal.Parse (parts [29]' ns' CultureInfo.InvariantCulture);  	face.Texture.YScale = decimal.Parse (parts [30]' ns' CultureInfo.InvariantCulture);  }  
Magic Number,Sledge.Providers.Map,MapFormatProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\MapFormatProvider.cs,ReadFace,The following statement contains a magic number: if (parts.Count == 21) {  	face.AlignTextureToFace ();  	face.Texture.XShift = decimal.Parse (parts [16]' ns' CultureInfo.InvariantCulture);  	face.Texture.YShift = decimal.Parse (parts [17]' ns' CultureInfo.InvariantCulture);  	face.Texture.Rotation = decimal.Parse (parts [18]' ns' CultureInfo.InvariantCulture);  	face.Texture.XScale = decimal.Parse (parts [19]' ns' CultureInfo.InvariantCulture);  	face.Texture.YScale = decimal.Parse (parts [20]' ns' CultureInfo.InvariantCulture);  } else {  	Assert (parts [16] == "[");  	Assert (parts [21] == "]");  	Assert (parts [22] == "[");  	Assert (parts [27] == "]");  	face.Texture.UAxis = Coordinate.Parse (parts [17]' parts [18]' parts [19]);  	face.Texture.XShift = decimal.Parse (parts [20]' ns' CultureInfo.InvariantCulture);  	face.Texture.VAxis = Coordinate.Parse (parts [23]' parts [24]' parts [25]);  	face.Texture.YShift = decimal.Parse (parts [26]' ns' CultureInfo.InvariantCulture);  	face.Texture.Rotation = decimal.Parse (parts [28]' ns' CultureInfo.InvariantCulture);  	face.Texture.XScale = decimal.Parse (parts [29]' ns' CultureInfo.InvariantCulture);  	face.Texture.YScale = decimal.Parse (parts [30]' ns' CultureInfo.InvariantCulture);  }  
Magic Number,Sledge.Providers.Map,MapFormatProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\MapFormatProvider.cs,ReadFace,The following statement contains a magic number: if (parts.Count == 21) {  	face.AlignTextureToFace ();  	face.Texture.XShift = decimal.Parse (parts [16]' ns' CultureInfo.InvariantCulture);  	face.Texture.YShift = decimal.Parse (parts [17]' ns' CultureInfo.InvariantCulture);  	face.Texture.Rotation = decimal.Parse (parts [18]' ns' CultureInfo.InvariantCulture);  	face.Texture.XScale = decimal.Parse (parts [19]' ns' CultureInfo.InvariantCulture);  	face.Texture.YScale = decimal.Parse (parts [20]' ns' CultureInfo.InvariantCulture);  } else {  	Assert (parts [16] == "[");  	Assert (parts [21] == "]");  	Assert (parts [22] == "[");  	Assert (parts [27] == "]");  	face.Texture.UAxis = Coordinate.Parse (parts [17]' parts [18]' parts [19]);  	face.Texture.XShift = decimal.Parse (parts [20]' ns' CultureInfo.InvariantCulture);  	face.Texture.VAxis = Coordinate.Parse (parts [23]' parts [24]' parts [25]);  	face.Texture.YShift = decimal.Parse (parts [26]' ns' CultureInfo.InvariantCulture);  	face.Texture.Rotation = decimal.Parse (parts [28]' ns' CultureInfo.InvariantCulture);  	face.Texture.XScale = decimal.Parse (parts [29]' ns' CultureInfo.InvariantCulture);  	face.Texture.YScale = decimal.Parse (parts [30]' ns' CultureInfo.InvariantCulture);  }  
Magic Number,Sledge.Providers.Map,MapFormatProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\MapFormatProvider.cs,ReadFace,The following statement contains a magic number: if (parts.Count == 21) {  	face.AlignTextureToFace ();  	face.Texture.XShift = decimal.Parse (parts [16]' ns' CultureInfo.InvariantCulture);  	face.Texture.YShift = decimal.Parse (parts [17]' ns' CultureInfo.InvariantCulture);  	face.Texture.Rotation = decimal.Parse (parts [18]' ns' CultureInfo.InvariantCulture);  	face.Texture.XScale = decimal.Parse (parts [19]' ns' CultureInfo.InvariantCulture);  	face.Texture.YScale = decimal.Parse (parts [20]' ns' CultureInfo.InvariantCulture);  } else {  	Assert (parts [16] == "[");  	Assert (parts [21] == "]");  	Assert (parts [22] == "[");  	Assert (parts [27] == "]");  	face.Texture.UAxis = Coordinate.Parse (parts [17]' parts [18]' parts [19]);  	face.Texture.XShift = decimal.Parse (parts [20]' ns' CultureInfo.InvariantCulture);  	face.Texture.VAxis = Coordinate.Parse (parts [23]' parts [24]' parts [25]);  	face.Texture.YShift = decimal.Parse (parts [26]' ns' CultureInfo.InvariantCulture);  	face.Texture.Rotation = decimal.Parse (parts [28]' ns' CultureInfo.InvariantCulture);  	face.Texture.XScale = decimal.Parse (parts [29]' ns' CultureInfo.InvariantCulture);  	face.Texture.YScale = decimal.Parse (parts [30]' ns' CultureInfo.InvariantCulture);  }  
Magic Number,Sledge.Providers.Map,MapFormatProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\MapFormatProvider.cs,ReadFace,The following statement contains a magic number: if (parts.Count == 21) {  	face.AlignTextureToFace ();  	face.Texture.XShift = decimal.Parse (parts [16]' ns' CultureInfo.InvariantCulture);  	face.Texture.YShift = decimal.Parse (parts [17]' ns' CultureInfo.InvariantCulture);  	face.Texture.Rotation = decimal.Parse (parts [18]' ns' CultureInfo.InvariantCulture);  	face.Texture.XScale = decimal.Parse (parts [19]' ns' CultureInfo.InvariantCulture);  	face.Texture.YScale = decimal.Parse (parts [20]' ns' CultureInfo.InvariantCulture);  } else {  	Assert (parts [16] == "[");  	Assert (parts [21] == "]");  	Assert (parts [22] == "[");  	Assert (parts [27] == "]");  	face.Texture.UAxis = Coordinate.Parse (parts [17]' parts [18]' parts [19]);  	face.Texture.XShift = decimal.Parse (parts [20]' ns' CultureInfo.InvariantCulture);  	face.Texture.VAxis = Coordinate.Parse (parts [23]' parts [24]' parts [25]);  	face.Texture.YShift = decimal.Parse (parts [26]' ns' CultureInfo.InvariantCulture);  	face.Texture.Rotation = decimal.Parse (parts [28]' ns' CultureInfo.InvariantCulture);  	face.Texture.XScale = decimal.Parse (parts [29]' ns' CultureInfo.InvariantCulture);  	face.Texture.YScale = decimal.Parse (parts [30]' ns' CultureInfo.InvariantCulture);  }  
Magic Number,Sledge.Providers.Map,MapFormatProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\MapFormatProvider.cs,ReadFace,The following statement contains a magic number: if (parts.Count == 21) {  	face.AlignTextureToFace ();  	face.Texture.XShift = decimal.Parse (parts [16]' ns' CultureInfo.InvariantCulture);  	face.Texture.YShift = decimal.Parse (parts [17]' ns' CultureInfo.InvariantCulture);  	face.Texture.Rotation = decimal.Parse (parts [18]' ns' CultureInfo.InvariantCulture);  	face.Texture.XScale = decimal.Parse (parts [19]' ns' CultureInfo.InvariantCulture);  	face.Texture.YScale = decimal.Parse (parts [20]' ns' CultureInfo.InvariantCulture);  } else {  	Assert (parts [16] == "[");  	Assert (parts [21] == "]");  	Assert (parts [22] == "[");  	Assert (parts [27] == "]");  	face.Texture.UAxis = Coordinate.Parse (parts [17]' parts [18]' parts [19]);  	face.Texture.XShift = decimal.Parse (parts [20]' ns' CultureInfo.InvariantCulture);  	face.Texture.VAxis = Coordinate.Parse (parts [23]' parts [24]' parts [25]);  	face.Texture.YShift = decimal.Parse (parts [26]' ns' CultureInfo.InvariantCulture);  	face.Texture.Rotation = decimal.Parse (parts [28]' ns' CultureInfo.InvariantCulture);  	face.Texture.XScale = decimal.Parse (parts [29]' ns' CultureInfo.InvariantCulture);  	face.Texture.YScale = decimal.Parse (parts [30]' ns' CultureInfo.InvariantCulture);  }  
Magic Number,Sledge.Providers.Map,MapFormatProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\MapFormatProvider.cs,ReadFace,The following statement contains a magic number: if (parts.Count == 21) {  	face.AlignTextureToFace ();  	face.Texture.XShift = decimal.Parse (parts [16]' ns' CultureInfo.InvariantCulture);  	face.Texture.YShift = decimal.Parse (parts [17]' ns' CultureInfo.InvariantCulture);  	face.Texture.Rotation = decimal.Parse (parts [18]' ns' CultureInfo.InvariantCulture);  	face.Texture.XScale = decimal.Parse (parts [19]' ns' CultureInfo.InvariantCulture);  	face.Texture.YScale = decimal.Parse (parts [20]' ns' CultureInfo.InvariantCulture);  } else {  	Assert (parts [16] == "[");  	Assert (parts [21] == "]");  	Assert (parts [22] == "[");  	Assert (parts [27] == "]");  	face.Texture.UAxis = Coordinate.Parse (parts [17]' parts [18]' parts [19]);  	face.Texture.XShift = decimal.Parse (parts [20]' ns' CultureInfo.InvariantCulture);  	face.Texture.VAxis = Coordinate.Parse (parts [23]' parts [24]' parts [25]);  	face.Texture.YShift = decimal.Parse (parts [26]' ns' CultureInfo.InvariantCulture);  	face.Texture.Rotation = decimal.Parse (parts [28]' ns' CultureInfo.InvariantCulture);  	face.Texture.XScale = decimal.Parse (parts [29]' ns' CultureInfo.InvariantCulture);  	face.Texture.YScale = decimal.Parse (parts [30]' ns' CultureInfo.InvariantCulture);  }  
Magic Number,Sledge.Providers.Map,MapFormatProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\MapFormatProvider.cs,ReadFace,The following statement contains a magic number: if (parts.Count == 21) {  	face.AlignTextureToFace ();  	face.Texture.XShift = decimal.Parse (parts [16]' ns' CultureInfo.InvariantCulture);  	face.Texture.YShift = decimal.Parse (parts [17]' ns' CultureInfo.InvariantCulture);  	face.Texture.Rotation = decimal.Parse (parts [18]' ns' CultureInfo.InvariantCulture);  	face.Texture.XScale = decimal.Parse (parts [19]' ns' CultureInfo.InvariantCulture);  	face.Texture.YScale = decimal.Parse (parts [20]' ns' CultureInfo.InvariantCulture);  } else {  	Assert (parts [16] == "[");  	Assert (parts [21] == "]");  	Assert (parts [22] == "[");  	Assert (parts [27] == "]");  	face.Texture.UAxis = Coordinate.Parse (parts [17]' parts [18]' parts [19]);  	face.Texture.XShift = decimal.Parse (parts [20]' ns' CultureInfo.InvariantCulture);  	face.Texture.VAxis = Coordinate.Parse (parts [23]' parts [24]' parts [25]);  	face.Texture.YShift = decimal.Parse (parts [26]' ns' CultureInfo.InvariantCulture);  	face.Texture.Rotation = decimal.Parse (parts [28]' ns' CultureInfo.InvariantCulture);  	face.Texture.XScale = decimal.Parse (parts [29]' ns' CultureInfo.InvariantCulture);  	face.Texture.YScale = decimal.Parse (parts [30]' ns' CultureInfo.InvariantCulture);  }  
Magic Number,Sledge.Providers.Map,MapFormatProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\MapFormatProvider.cs,ReadFace,The following statement contains a magic number: if (parts.Count == 21) {  	face.AlignTextureToFace ();  	face.Texture.XShift = decimal.Parse (parts [16]' ns' CultureInfo.InvariantCulture);  	face.Texture.YShift = decimal.Parse (parts [17]' ns' CultureInfo.InvariantCulture);  	face.Texture.Rotation = decimal.Parse (parts [18]' ns' CultureInfo.InvariantCulture);  	face.Texture.XScale = decimal.Parse (parts [19]' ns' CultureInfo.InvariantCulture);  	face.Texture.YScale = decimal.Parse (parts [20]' ns' CultureInfo.InvariantCulture);  } else {  	Assert (parts [16] == "[");  	Assert (parts [21] == "]");  	Assert (parts [22] == "[");  	Assert (parts [27] == "]");  	face.Texture.UAxis = Coordinate.Parse (parts [17]' parts [18]' parts [19]);  	face.Texture.XShift = decimal.Parse (parts [20]' ns' CultureInfo.InvariantCulture);  	face.Texture.VAxis = Coordinate.Parse (parts [23]' parts [24]' parts [25]);  	face.Texture.YShift = decimal.Parse (parts [26]' ns' CultureInfo.InvariantCulture);  	face.Texture.Rotation = decimal.Parse (parts [28]' ns' CultureInfo.InvariantCulture);  	face.Texture.XScale = decimal.Parse (parts [29]' ns' CultureInfo.InvariantCulture);  	face.Texture.YScale = decimal.Parse (parts [30]' ns' CultureInfo.InvariantCulture);  }  
Magic Number,Sledge.Providers.Map,MapFormatProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\MapFormatProvider.cs,ReadFace,The following statement contains a magic number: if (parts.Count == 21) {  	face.AlignTextureToFace ();  	face.Texture.XShift = decimal.Parse (parts [16]' ns' CultureInfo.InvariantCulture);  	face.Texture.YShift = decimal.Parse (parts [17]' ns' CultureInfo.InvariantCulture);  	face.Texture.Rotation = decimal.Parse (parts [18]' ns' CultureInfo.InvariantCulture);  	face.Texture.XScale = decimal.Parse (parts [19]' ns' CultureInfo.InvariantCulture);  	face.Texture.YScale = decimal.Parse (parts [20]' ns' CultureInfo.InvariantCulture);  } else {  	Assert (parts [16] == "[");  	Assert (parts [21] == "]");  	Assert (parts [22] == "[");  	Assert (parts [27] == "]");  	face.Texture.UAxis = Coordinate.Parse (parts [17]' parts [18]' parts [19]);  	face.Texture.XShift = decimal.Parse (parts [20]' ns' CultureInfo.InvariantCulture);  	face.Texture.VAxis = Coordinate.Parse (parts [23]' parts [24]' parts [25]);  	face.Texture.YShift = decimal.Parse (parts [26]' ns' CultureInfo.InvariantCulture);  	face.Texture.Rotation = decimal.Parse (parts [28]' ns' CultureInfo.InvariantCulture);  	face.Texture.XScale = decimal.Parse (parts [29]' ns' CultureInfo.InvariantCulture);  	face.Texture.YScale = decimal.Parse (parts [30]' ns' CultureInfo.InvariantCulture);  }  
Magic Number,Sledge.Providers.Map,MapFormatProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\MapFormatProvider.cs,ReadFace,The following statement contains a magic number: if (parts.Count == 21) {  	face.AlignTextureToFace ();  	face.Texture.XShift = decimal.Parse (parts [16]' ns' CultureInfo.InvariantCulture);  	face.Texture.YShift = decimal.Parse (parts [17]' ns' CultureInfo.InvariantCulture);  	face.Texture.Rotation = decimal.Parse (parts [18]' ns' CultureInfo.InvariantCulture);  	face.Texture.XScale = decimal.Parse (parts [19]' ns' CultureInfo.InvariantCulture);  	face.Texture.YScale = decimal.Parse (parts [20]' ns' CultureInfo.InvariantCulture);  } else {  	Assert (parts [16] == "[");  	Assert (parts [21] == "]");  	Assert (parts [22] == "[");  	Assert (parts [27] == "]");  	face.Texture.UAxis = Coordinate.Parse (parts [17]' parts [18]' parts [19]);  	face.Texture.XShift = decimal.Parse (parts [20]' ns' CultureInfo.InvariantCulture);  	face.Texture.VAxis = Coordinate.Parse (parts [23]' parts [24]' parts [25]);  	face.Texture.YShift = decimal.Parse (parts [26]' ns' CultureInfo.InvariantCulture);  	face.Texture.Rotation = decimal.Parse (parts [28]' ns' CultureInfo.InvariantCulture);  	face.Texture.XScale = decimal.Parse (parts [29]' ns' CultureInfo.InvariantCulture);  	face.Texture.YScale = decimal.Parse (parts [30]' ns' CultureInfo.InvariantCulture);  }  
Magic Number,Sledge.Providers.Map,MapFormatProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\MapFormatProvider.cs,ReadFace,The following statement contains a magic number: if (parts.Count == 21) {  	face.AlignTextureToFace ();  	face.Texture.XShift = decimal.Parse (parts [16]' ns' CultureInfo.InvariantCulture);  	face.Texture.YShift = decimal.Parse (parts [17]' ns' CultureInfo.InvariantCulture);  	face.Texture.Rotation = decimal.Parse (parts [18]' ns' CultureInfo.InvariantCulture);  	face.Texture.XScale = decimal.Parse (parts [19]' ns' CultureInfo.InvariantCulture);  	face.Texture.YScale = decimal.Parse (parts [20]' ns' CultureInfo.InvariantCulture);  } else {  	Assert (parts [16] == "[");  	Assert (parts [21] == "]");  	Assert (parts [22] == "[");  	Assert (parts [27] == "]");  	face.Texture.UAxis = Coordinate.Parse (parts [17]' parts [18]' parts [19]);  	face.Texture.XShift = decimal.Parse (parts [20]' ns' CultureInfo.InvariantCulture);  	face.Texture.VAxis = Coordinate.Parse (parts [23]' parts [24]' parts [25]);  	face.Texture.YShift = decimal.Parse (parts [26]' ns' CultureInfo.InvariantCulture);  	face.Texture.Rotation = decimal.Parse (parts [28]' ns' CultureInfo.InvariantCulture);  	face.Texture.XScale = decimal.Parse (parts [29]' ns' CultureInfo.InvariantCulture);  	face.Texture.YScale = decimal.Parse (parts [30]' ns' CultureInfo.InvariantCulture);  }  
Magic Number,Sledge.Providers.Map,MapFormatProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\MapFormatProvider.cs,ReadFace,The following statement contains a magic number: if (parts.Count == 21) {  	face.AlignTextureToFace ();  	face.Texture.XShift = decimal.Parse (parts [16]' ns' CultureInfo.InvariantCulture);  	face.Texture.YShift = decimal.Parse (parts [17]' ns' CultureInfo.InvariantCulture);  	face.Texture.Rotation = decimal.Parse (parts [18]' ns' CultureInfo.InvariantCulture);  	face.Texture.XScale = decimal.Parse (parts [19]' ns' CultureInfo.InvariantCulture);  	face.Texture.YScale = decimal.Parse (parts [20]' ns' CultureInfo.InvariantCulture);  } else {  	Assert (parts [16] == "[");  	Assert (parts [21] == "]");  	Assert (parts [22] == "[");  	Assert (parts [27] == "]");  	face.Texture.UAxis = Coordinate.Parse (parts [17]' parts [18]' parts [19]);  	face.Texture.XShift = decimal.Parse (parts [20]' ns' CultureInfo.InvariantCulture);  	face.Texture.VAxis = Coordinate.Parse (parts [23]' parts [24]' parts [25]);  	face.Texture.YShift = decimal.Parse (parts [26]' ns' CultureInfo.InvariantCulture);  	face.Texture.Rotation = decimal.Parse (parts [28]' ns' CultureInfo.InvariantCulture);  	face.Texture.XScale = decimal.Parse (parts [29]' ns' CultureInfo.InvariantCulture);  	face.Texture.YScale = decimal.Parse (parts [30]' ns' CultureInfo.InvariantCulture);  }  
Magic Number,Sledge.Providers.Map,MapFormatProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\MapFormatProvider.cs,ReadFace,The following statement contains a magic number: if (parts.Count == 21) {  	face.AlignTextureToFace ();  	face.Texture.XShift = decimal.Parse (parts [16]' ns' CultureInfo.InvariantCulture);  	face.Texture.YShift = decimal.Parse (parts [17]' ns' CultureInfo.InvariantCulture);  	face.Texture.Rotation = decimal.Parse (parts [18]' ns' CultureInfo.InvariantCulture);  	face.Texture.XScale = decimal.Parse (parts [19]' ns' CultureInfo.InvariantCulture);  	face.Texture.YScale = decimal.Parse (parts [20]' ns' CultureInfo.InvariantCulture);  } else {  	Assert (parts [16] == "[");  	Assert (parts [21] == "]");  	Assert (parts [22] == "[");  	Assert (parts [27] == "]");  	face.Texture.UAxis = Coordinate.Parse (parts [17]' parts [18]' parts [19]);  	face.Texture.XShift = decimal.Parse (parts [20]' ns' CultureInfo.InvariantCulture);  	face.Texture.VAxis = Coordinate.Parse (parts [23]' parts [24]' parts [25]);  	face.Texture.YShift = decimal.Parse (parts [26]' ns' CultureInfo.InvariantCulture);  	face.Texture.Rotation = decimal.Parse (parts [28]' ns' CultureInfo.InvariantCulture);  	face.Texture.XScale = decimal.Parse (parts [29]' ns' CultureInfo.InvariantCulture);  	face.Texture.YScale = decimal.Parse (parts [30]' ns' CultureInfo.InvariantCulture);  }  
Magic Number,Sledge.Providers.Map,MapFormatProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\MapFormatProvider.cs,ReadFace,The following statement contains a magic number: if (parts.Count == 21) {  	face.AlignTextureToFace ();  	face.Texture.XShift = decimal.Parse (parts [16]' ns' CultureInfo.InvariantCulture);  	face.Texture.YShift = decimal.Parse (parts [17]' ns' CultureInfo.InvariantCulture);  	face.Texture.Rotation = decimal.Parse (parts [18]' ns' CultureInfo.InvariantCulture);  	face.Texture.XScale = decimal.Parse (parts [19]' ns' CultureInfo.InvariantCulture);  	face.Texture.YScale = decimal.Parse (parts [20]' ns' CultureInfo.InvariantCulture);  } else {  	Assert (parts [16] == "[");  	Assert (parts [21] == "]");  	Assert (parts [22] == "[");  	Assert (parts [27] == "]");  	face.Texture.UAxis = Coordinate.Parse (parts [17]' parts [18]' parts [19]);  	face.Texture.XShift = decimal.Parse (parts [20]' ns' CultureInfo.InvariantCulture);  	face.Texture.VAxis = Coordinate.Parse (parts [23]' parts [24]' parts [25]);  	face.Texture.YShift = decimal.Parse (parts [26]' ns' CultureInfo.InvariantCulture);  	face.Texture.Rotation = decimal.Parse (parts [28]' ns' CultureInfo.InvariantCulture);  	face.Texture.XScale = decimal.Parse (parts [29]' ns' CultureInfo.InvariantCulture);  	face.Texture.YScale = decimal.Parse (parts [30]' ns' CultureInfo.InvariantCulture);  }  
Magic Number,Sledge.Providers.Map,MapFormatProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\MapFormatProvider.cs,ReadFace,The following statement contains a magic number: if (parts.Count == 21) {  	face.AlignTextureToFace ();  	face.Texture.XShift = decimal.Parse (parts [16]' ns' CultureInfo.InvariantCulture);  	face.Texture.YShift = decimal.Parse (parts [17]' ns' CultureInfo.InvariantCulture);  	face.Texture.Rotation = decimal.Parse (parts [18]' ns' CultureInfo.InvariantCulture);  	face.Texture.XScale = decimal.Parse (parts [19]' ns' CultureInfo.InvariantCulture);  	face.Texture.YScale = decimal.Parse (parts [20]' ns' CultureInfo.InvariantCulture);  } else {  	Assert (parts [16] == "[");  	Assert (parts [21] == "]");  	Assert (parts [22] == "[");  	Assert (parts [27] == "]");  	face.Texture.UAxis = Coordinate.Parse (parts [17]' parts [18]' parts [19]);  	face.Texture.XShift = decimal.Parse (parts [20]' ns' CultureInfo.InvariantCulture);  	face.Texture.VAxis = Coordinate.Parse (parts [23]' parts [24]' parts [25]);  	face.Texture.YShift = decimal.Parse (parts [26]' ns' CultureInfo.InvariantCulture);  	face.Texture.Rotation = decimal.Parse (parts [28]' ns' CultureInfo.InvariantCulture);  	face.Texture.XScale = decimal.Parse (parts [29]' ns' CultureInfo.InvariantCulture);  	face.Texture.YScale = decimal.Parse (parts [30]' ns' CultureInfo.InvariantCulture);  }  
Magic Number,Sledge.Providers.Map,MapFormatProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\MapFormatProvider.cs,ReadFace,The following statement contains a magic number: if (parts.Count == 21) {  	face.AlignTextureToFace ();  	face.Texture.XShift = decimal.Parse (parts [16]' ns' CultureInfo.InvariantCulture);  	face.Texture.YShift = decimal.Parse (parts [17]' ns' CultureInfo.InvariantCulture);  	face.Texture.Rotation = decimal.Parse (parts [18]' ns' CultureInfo.InvariantCulture);  	face.Texture.XScale = decimal.Parse (parts [19]' ns' CultureInfo.InvariantCulture);  	face.Texture.YScale = decimal.Parse (parts [20]' ns' CultureInfo.InvariantCulture);  } else {  	Assert (parts [16] == "[");  	Assert (parts [21] == "]");  	Assert (parts [22] == "[");  	Assert (parts [27] == "]");  	face.Texture.UAxis = Coordinate.Parse (parts [17]' parts [18]' parts [19]);  	face.Texture.XShift = decimal.Parse (parts [20]' ns' CultureInfo.InvariantCulture);  	face.Texture.VAxis = Coordinate.Parse (parts [23]' parts [24]' parts [25]);  	face.Texture.YShift = decimal.Parse (parts [26]' ns' CultureInfo.InvariantCulture);  	face.Texture.Rotation = decimal.Parse (parts [28]' ns' CultureInfo.InvariantCulture);  	face.Texture.XScale = decimal.Parse (parts [29]' ns' CultureInfo.InvariantCulture);  	face.Texture.YScale = decimal.Parse (parts [30]' ns' CultureInfo.InvariantCulture);  }  
Magic Number,Sledge.Providers.Map,MapFormatProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\MapFormatProvider.cs,ReadFace,The following statement contains a magic number: face.Texture.XShift = decimal.Parse (parts [16]' ns' CultureInfo.InvariantCulture);  
Magic Number,Sledge.Providers.Map,MapFormatProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\MapFormatProvider.cs,ReadFace,The following statement contains a magic number: face.Texture.YShift = decimal.Parse (parts [17]' ns' CultureInfo.InvariantCulture);  
Magic Number,Sledge.Providers.Map,MapFormatProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\MapFormatProvider.cs,ReadFace,The following statement contains a magic number: face.Texture.Rotation = decimal.Parse (parts [18]' ns' CultureInfo.InvariantCulture);  
Magic Number,Sledge.Providers.Map,MapFormatProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\MapFormatProvider.cs,ReadFace,The following statement contains a magic number: face.Texture.XScale = decimal.Parse (parts [19]' ns' CultureInfo.InvariantCulture);  
Magic Number,Sledge.Providers.Map,MapFormatProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\MapFormatProvider.cs,ReadFace,The following statement contains a magic number: face.Texture.YScale = decimal.Parse (parts [20]' ns' CultureInfo.InvariantCulture);  
Magic Number,Sledge.Providers.Map,MapFormatProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\MapFormatProvider.cs,ReadFace,The following statement contains a magic number: Assert (parts [16] == "[");  
Magic Number,Sledge.Providers.Map,MapFormatProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\MapFormatProvider.cs,ReadFace,The following statement contains a magic number: Assert (parts [21] == "]");  
Magic Number,Sledge.Providers.Map,MapFormatProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\MapFormatProvider.cs,ReadFace,The following statement contains a magic number: Assert (parts [22] == "[");  
Magic Number,Sledge.Providers.Map,MapFormatProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\MapFormatProvider.cs,ReadFace,The following statement contains a magic number: Assert (parts [27] == "]");  
Magic Number,Sledge.Providers.Map,MapFormatProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\MapFormatProvider.cs,ReadFace,The following statement contains a magic number: face.Texture.UAxis = Coordinate.Parse (parts [17]' parts [18]' parts [19]);  
Magic Number,Sledge.Providers.Map,MapFormatProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\MapFormatProvider.cs,ReadFace,The following statement contains a magic number: face.Texture.UAxis = Coordinate.Parse (parts [17]' parts [18]' parts [19]);  
Magic Number,Sledge.Providers.Map,MapFormatProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\MapFormatProvider.cs,ReadFace,The following statement contains a magic number: face.Texture.UAxis = Coordinate.Parse (parts [17]' parts [18]' parts [19]);  
Magic Number,Sledge.Providers.Map,MapFormatProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\MapFormatProvider.cs,ReadFace,The following statement contains a magic number: face.Texture.XShift = decimal.Parse (parts [20]' ns' CultureInfo.InvariantCulture);  
Magic Number,Sledge.Providers.Map,MapFormatProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\MapFormatProvider.cs,ReadFace,The following statement contains a magic number: face.Texture.VAxis = Coordinate.Parse (parts [23]' parts [24]' parts [25]);  
Magic Number,Sledge.Providers.Map,MapFormatProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\MapFormatProvider.cs,ReadFace,The following statement contains a magic number: face.Texture.VAxis = Coordinate.Parse (parts [23]' parts [24]' parts [25]);  
Magic Number,Sledge.Providers.Map,MapFormatProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\MapFormatProvider.cs,ReadFace,The following statement contains a magic number: face.Texture.VAxis = Coordinate.Parse (parts [23]' parts [24]' parts [25]);  
Magic Number,Sledge.Providers.Map,MapFormatProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\MapFormatProvider.cs,ReadFace,The following statement contains a magic number: face.Texture.YShift = decimal.Parse (parts [26]' ns' CultureInfo.InvariantCulture);  
Magic Number,Sledge.Providers.Map,MapFormatProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\MapFormatProvider.cs,ReadFace,The following statement contains a magic number: face.Texture.Rotation = decimal.Parse (parts [28]' ns' CultureInfo.InvariantCulture);  
Magic Number,Sledge.Providers.Map,MapFormatProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\MapFormatProvider.cs,ReadFace,The following statement contains a magic number: face.Texture.XScale = decimal.Parse (parts [29]' ns' CultureInfo.InvariantCulture);  
Magic Number,Sledge.Providers.Map,MapFormatProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\MapFormatProvider.cs,ReadFace,The following statement contains a magic number: face.Texture.YScale = decimal.Parse (parts [30]' ns' CultureInfo.InvariantCulture);  
Magic Number,Sledge.Providers.Map,MapFormatProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\MapFormatProvider.cs,ReadProperty,The following statement contains a magic number: if (key == "classname") {  	ent.EntityData.Name = val;  } else if (key == "spawnflags") {  	ent.EntityData.Flags = int.Parse (val);  } else if (key == "origin") {  	var osp = val.Split (' ');  	ent.Origin = Coordinate.Parse (osp [0]' osp [1]' osp [2]);  } else if (!ExcludedKeys.Contains (key.ToLower ())) {  	ent.EntityData.SetPropertyValue (key' val);  }  
Magic Number,Sledge.Providers.Map,MapFormatProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\MapFormatProvider.cs,ReadProperty,The following statement contains a magic number: if (key == "spawnflags") {  	ent.EntityData.Flags = int.Parse (val);  } else if (key == "origin") {  	var osp = val.Split (' ');  	ent.Origin = Coordinate.Parse (osp [0]' osp [1]' osp [2]);  } else if (!ExcludedKeys.Contains (key.ToLower ())) {  	ent.EntityData.SetPropertyValue (key' val);  }  
Magic Number,Sledge.Providers.Map,MapFormatProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\MapFormatProvider.cs,ReadProperty,The following statement contains a magic number: if (key == "origin") {  	var osp = val.Split (' ');  	ent.Origin = Coordinate.Parse (osp [0]' osp [1]' osp [2]);  } else if (!ExcludedKeys.Contains (key.ToLower ())) {  	ent.EntityData.SetPropertyValue (key' val);  }  
Magic Number,Sledge.Providers.Map,MapFormatProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\MapFormatProvider.cs,ReadProperty,The following statement contains a magic number: ent.Origin = Coordinate.Parse (osp [0]' osp [1]' osp [2]);  
Magic Number,Sledge.Providers.Map,ObjProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\ObjProvider.cs,Read,The following statement contains a magic number: while ((line = reader.ReadLine ()) != null) {  	if (line.StartsWith ("# Scale: ")) {  		var num = line.Substring (9);  		decimal s;  		if (decimal.TryParse (num' NumberStyles.Float' CultureInfo.InvariantCulture' out s)) {  			scale = s;  		}  	}  	line = CleanLine (line);  	string keyword' values;  	SplitLine (line' out keyword' out values);  	if (String.IsNullOrWhiteSpace (keyword))  		continue;  	var vals = (values ?? "").Split (' ').Where (x => !String.IsNullOrWhiteSpace (x)).ToArray ();  	switch (keyword.ToLower ()) {  	// Things I care about  	case "v":  		// geometric vertices  		points.Add (Coordinate.Parse (vals [0]' vals [1]' vals [2]) * scale);  		break;  	case "f":  		// face  		faces.Add (new ObjFace (currentGroup' vals.Select (x => ParseFaceIndex (points' x))));  		break;  	case "g":  		// group name  		currentGroup = (values ?? "").Trim ();  		break;  	// Things I don't care about  	#region Not Implemented  	// Vertex data  	// "v"  	case "vt":  		// texture vertices  		break;  	case "vn":  		// vertex normals  		break;  	case "vp":  	// parameter space vertices  	case "cstype":  	// rational or non-rational forms of curve or surface type: basis matrix' Bezier' B-spline' Cardinal' Taylor  	case "degree":  	// degree  	case "bmat":  	// basis matrix  	case "step":  		// step size  		// not supported  		break;  	// Elements  	// "f"  	case "p":  	// point  	case "l":  	// line  	case "curv":  	// curve  	case "curv2":  	// 2D curve  	case "surf":  		// surface  		// not supported  		break;  	// Free-form curve/surface body statements  	case "parm":  	// parameter name  	case "trim":  	// outer trimming loop (trim)  	case "hole":  	// inner trimming loop (hole)  	case "scrv":  	// special curve (scrv)  	case "sp":  	// special point (sp)  	case "end":  		// end statement (end)  		// not supported  		break;  	// Connectivity between free-form surfaces  	case "con":  		// connect  		// not supported  		break;  	// Grouping  	// "g"  	case "s":  		// smoothing group  		break;  	case "mg":  		// merging group  		break;  	case "o":  		// object name  		// not supported  		break;  	// Display/render attributes  	case "mtllib":  	// material library  	case "usemtl":  	// material name  	case "usemap":  	// texture map name  	case "bevel":  	// bevel interpolation  	case "c_interp":  	// color interpolation  	case "d_interp":  	// dissolve interpolation  	case "lod":  	// level of detail  	case "shadow_obj":  	// shadow casting  	case "trace_obj":  	// ray tracing  	case "ctech":  	// curve approximation technique  	case "stech":  		// surface approximation technique  		// not relevant  		break;  	#endregion  	}  }  
Magic Number,Sledge.Providers.Map,ObjProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\ObjProvider.cs,Read,The following statement contains a magic number: while ((line = reader.ReadLine ()) != null) {  	if (line.StartsWith ("# Scale: ")) {  		var num = line.Substring (9);  		decimal s;  		if (decimal.TryParse (num' NumberStyles.Float' CultureInfo.InvariantCulture' out s)) {  			scale = s;  		}  	}  	line = CleanLine (line);  	string keyword' values;  	SplitLine (line' out keyword' out values);  	if (String.IsNullOrWhiteSpace (keyword))  		continue;  	var vals = (values ?? "").Split (' ').Where (x => !String.IsNullOrWhiteSpace (x)).ToArray ();  	switch (keyword.ToLower ()) {  	// Things I care about  	case "v":  		// geometric vertices  		points.Add (Coordinate.Parse (vals [0]' vals [1]' vals [2]) * scale);  		break;  	case "f":  		// face  		faces.Add (new ObjFace (currentGroup' vals.Select (x => ParseFaceIndex (points' x))));  		break;  	case "g":  		// group name  		currentGroup = (values ?? "").Trim ();  		break;  	// Things I don't care about  	#region Not Implemented  	// Vertex data  	// "v"  	case "vt":  		// texture vertices  		break;  	case "vn":  		// vertex normals  		break;  	case "vp":  	// parameter space vertices  	case "cstype":  	// rational or non-rational forms of curve or surface type: basis matrix' Bezier' B-spline' Cardinal' Taylor  	case "degree":  	// degree  	case "bmat":  	// basis matrix  	case "step":  		// step size  		// not supported  		break;  	// Elements  	// "f"  	case "p":  	// point  	case "l":  	// line  	case "curv":  	// curve  	case "curv2":  	// 2D curve  	case "surf":  		// surface  		// not supported  		break;  	// Free-form curve/surface body statements  	case "parm":  	// parameter name  	case "trim":  	// outer trimming loop (trim)  	case "hole":  	// inner trimming loop (hole)  	case "scrv":  	// special curve (scrv)  	case "sp":  	// special point (sp)  	case "end":  		// end statement (end)  		// not supported  		break;  	// Connectivity between free-form surfaces  	case "con":  		// connect  		// not supported  		break;  	// Grouping  	// "g"  	case "s":  		// smoothing group  		break;  	case "mg":  		// merging group  		break;  	case "o":  		// object name  		// not supported  		break;  	// Display/render attributes  	case "mtllib":  	// material library  	case "usemtl":  	// material name  	case "usemap":  	// texture map name  	case "bevel":  	// bevel interpolation  	case "c_interp":  	// color interpolation  	case "d_interp":  	// dissolve interpolation  	case "lod":  	// level of detail  	case "shadow_obj":  	// shadow casting  	case "trace_obj":  	// ray tracing  	case "ctech":  	// curve approximation technique  	case "stech":  		// surface approximation technique  		// not relevant  		break;  	#endregion  	}  }  
Magic Number,Sledge.Providers.Map,ObjProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\ObjProvider.cs,Read,The following statement contains a magic number: if (line.StartsWith ("# Scale: ")) {  	var num = line.Substring (9);  	decimal s;  	if (decimal.TryParse (num' NumberStyles.Float' CultureInfo.InvariantCulture' out s)) {  		scale = s;  	}  }  
Magic Number,Sledge.Providers.Map,ObjProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\ObjProvider.cs,Read,The following statement contains a magic number: switch (keyword.ToLower ()) {  // Things I care about  case "v":  	// geometric vertices  	points.Add (Coordinate.Parse (vals [0]' vals [1]' vals [2]) * scale);  	break;  case "f":  	// face  	faces.Add (new ObjFace (currentGroup' vals.Select (x => ParseFaceIndex (points' x))));  	break;  case "g":  	// group name  	currentGroup = (values ?? "").Trim ();  	break;  // Things I don't care about  #region Not Implemented  // Vertex data  // "v"  case "vt":  	// texture vertices  	break;  case "vn":  	// vertex normals  	break;  case "vp":  // parameter space vertices  case "cstype":  // rational or non-rational forms of curve or surface type: basis matrix' Bezier' B-spline' Cardinal' Taylor  case "degree":  // degree  case "bmat":  // basis matrix  case "step":  	// step size  	// not supported  	break;  // Elements  // "f"  case "p":  // point  case "l":  // line  case "curv":  // curve  case "curv2":  // 2D curve  case "surf":  	// surface  	// not supported  	break;  // Free-form curve/surface body statements  case "parm":  // parameter name  case "trim":  // outer trimming loop (trim)  case "hole":  // inner trimming loop (hole)  case "scrv":  // special curve (scrv)  case "sp":  // special point (sp)  case "end":  	// end statement (end)  	// not supported  	break;  // Connectivity between free-form surfaces  case "con":  	// connect  	// not supported  	break;  // Grouping  // "g"  case "s":  	// smoothing group  	break;  case "mg":  	// merging group  	break;  case "o":  	// object name  	// not supported  	break;  // Display/render attributes  case "mtllib":  // material library  case "usemtl":  // material name  case "usemap":  // texture map name  case "bevel":  // bevel interpolation  case "c_interp":  // color interpolation  case "d_interp":  // dissolve interpolation  case "lod":  // level of detail  case "shadow_obj":  // shadow casting  case "trace_obj":  // ray tracing  case "ctech":  // curve approximation technique  case "stech":  	// surface approximation technique  	// not relevant  	break;  #endregion  }  
Magic Number,Sledge.Providers.Map,ObjProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\ObjProvider.cs,Read,The following statement contains a magic number: points.Add (Coordinate.Parse (vals [0]' vals [1]' vals [2]) * scale);  
Magic Number,Sledge.Providers.Map,ObjProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\ObjProvider.cs,CreateSolids,The following statement contains a magic number: if (solid.IsValid ()) {  	// Do an additional check to ensure that all edges are shared  	var edges = solid.Faces.SelectMany (x => x.GetEdges ()).ToList ();  	if (edges.All (x => edges.Count (y => x.EquivalentTo (y)) == 2)) {  		// Valid! let's get out of here!  		yield return solid;  		yield break;  	}  }  
Magic Number,Sledge.Providers.Map,ObjProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\ObjProvider.cs,CreateSolids,The following statement contains a magic number: if (edges.All (x => edges.Count (y => x.EquivalentTo (y)) == 2)) {  	// Valid! let's get out of here!  	yield return solid;  	yield break;  }  
Magic Number,Sledge.Providers.Map,ObjProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\ObjProvider.cs,CreateSolids,The following statement contains a magic number: foreach (var face in faces) {  	var polygon = new Polygon (face.Vertices.Select (x => x.Location));  	if (!polygon.IsValid () || !polygon.IsConvex ()) {  		// tetrahedrons  		foreach (var triangle in face.GetTriangles ()) {  			var tf = new Face (map.IDGenerator.GetNextFaceID ());  			tf.Plane = new Plane (triangle [0].Location' triangle [1].Location' triangle [2].Location);  			tf.Vertices.AddRange (triangle.Select (x => new Vertex (x.Location' tf)));  			tf.UpdateBoundingBox ();  			yield return SolidifyFace (map' tf);  		}  	} else {  		// cone/pyramid/whatever  		yield return SolidifyFace (map' face);  	}  }  
Magic Number,Sledge.Providers.Map,ObjProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\ObjProvider.cs,CreateSolids,The following statement contains a magic number: if (!polygon.IsValid () || !polygon.IsConvex ()) {  	// tetrahedrons  	foreach (var triangle in face.GetTriangles ()) {  		var tf = new Face (map.IDGenerator.GetNextFaceID ());  		tf.Plane = new Plane (triangle [0].Location' triangle [1].Location' triangle [2].Location);  		tf.Vertices.AddRange (triangle.Select (x => new Vertex (x.Location' tf)));  		tf.UpdateBoundingBox ();  		yield return SolidifyFace (map' tf);  	}  } else {  	// cone/pyramid/whatever  	yield return SolidifyFace (map' face);  }  
Magic Number,Sledge.Providers.Map,ObjProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\ObjProvider.cs,CreateSolids,The following statement contains a magic number: foreach (var triangle in face.GetTriangles ()) {  	var tf = new Face (map.IDGenerator.GetNextFaceID ());  	tf.Plane = new Plane (triangle [0].Location' triangle [1].Location' triangle [2].Location);  	tf.Vertices.AddRange (triangle.Select (x => new Vertex (x.Location' tf)));  	tf.UpdateBoundingBox ();  	yield return SolidifyFace (map' tf);  }  
Magic Number,Sledge.Providers.Map,ObjProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\ObjProvider.cs,CreateSolids,The following statement contains a magic number: tf.Plane = new Plane (triangle [0].Location' triangle [1].Location' triangle [2].Location);  
Magic Number,Sledge.Providers.Map,ObjProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\ObjProvider.cs,CreateFace,The following statement contains a magic number: f.Plane = new Plane (verts [2]' verts [1]' verts [0]);  
Magic Number,Sledge.Providers.Map,VmfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\VmfProvider.cs,ReadDisplacement,The following statement contains a magic number: disp.SetPower (dispinfo.PropertyInteger ("power"' 3));  
Magic Number,Sledge.Providers.Map,VmfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\VmfProvider.cs,WriteFace,The following statement contains a magic number: ret ["plane"] = String.Format ("({0}) ({1}) ({2})"' FormatCoordinate (face.Vertices [0].Location)' FormatCoordinate (face.Vertices [1].Location)' FormatCoordinate (face.Vertices [2].Location));  
Magic Number,Sledge.Providers.Map,VmfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\VmfProvider.cs,ReadSolid,The following statement contains a magic number: if (faces.All (x => x.Vertices.Count >= 3)) {  	// Vertices were stored in the VMF  	ret = new Solid (GetObjectID (solid' generator));  	ret.Faces.AddRange (faces);  } else {  	// Need to grab the vertices using plane intersections  	var idg = new IDGenerator ();  	// No need to increment the id generator if it doesn't have to be  	ret = Solid.CreateFromIntersectingPlanes (faces.Select (x => x.Plane)' idg);  	ret.ID = GetObjectID (solid' generator);  	for (var i = 0; i < ret.Faces.Count; i++) {  		var face = ret.Faces [i];  		var f = faces.FirstOrDefault (x => x.Plane.Normal.EquivalentTo (ret.Faces [i].Plane.Normal));  		if (f == null) {  			// TODO: Report invalid solids  			Debug.WriteLine ("Invalid solid! ID: " + solid ["id"]);  			return null;  		}  		face.Texture = f.Texture;  		var disp = f as Displacement;  		if (disp == null)  			continue;  		disp.Plane = face.Plane;  		disp.Vertices = face.Vertices;  		disp.Texture = f.Texture;  		disp.AlignTextureToWorld ();  		disp.CalculatePoints ();  		ret.Faces [i] = disp;  	}  }  
Magic Number,Sledge.Providers.Map,RmfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\RmfProvider.cs,GetFromStream,The following statement contains a magic number: if (Math.Abs (version - 2.2) > 0.01) {  	throw new ProviderException ("Incorrect RMF version number. Expected 2.2' got " + version + ".");  }  
Magic Number,Sledge.Providers.Map,RmfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\RmfProvider.cs,GetFromStream,The following statement contains a magic number: if (Math.Abs (version - 2.2) > 0.01) {  	throw new ProviderException ("Incorrect RMF version number. Expected 2.2' got " + version + ".");  }  
Magic Number,Sledge.Providers.Map,RmfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\RmfProvider.cs,SaveToStream,The following statement contains a magic number: bw.WriteFixedLengthString (Encoding.UTF8' 3' "RMF");  
Magic Number,Sledge.Providers.Map,RmfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\RmfProvider.cs,SaveToStream,The following statement contains a magic number: bw.WriteFixedLengthString (Encoding.UTF8' 8' "DOCINFO");  
Magic Number,Sledge.Providers.Map,RmfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\RmfProvider.cs,ReadEntityData,The following statement contains a magic number: br.ReadBytes (4);  
Magic Number,Sledge.Providers.Map,RmfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\RmfProvider.cs,ReadEntityData,The following statement contains a magic number: br.ReadBytes (12);  
Magic Number,Sledge.Providers.Map,RmfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\RmfProvider.cs,WriteEntityData,The following statement contains a magic number: bw.Write (new byte[4]);  
Magic Number,Sledge.Providers.Map,RmfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\RmfProvider.cs,WriteEntityData,The following statement contains a magic number: bw.Write (new byte[12]);  
Magic Number,Sledge.Providers.Map,RmfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\RmfProvider.cs,ReadMapEntity,The following statement contains a magic number: br.ReadBytes (2);  
Magic Number,Sledge.Providers.Map,RmfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\RmfProvider.cs,ReadMapEntity,The following statement contains a magic number: br.ReadBytes (4);  
Magic Number,Sledge.Providers.Map,RmfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\RmfProvider.cs,WriteMapEntity,The following statement contains a magic number: bw.Write (new byte[2]);  
Magic Number,Sledge.Providers.Map,RmfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\RmfProvider.cs,WriteMapEntity,The following statement contains a magic number: bw.Write (new byte[4]);  
Magic Number,Sledge.Providers.Map,RmfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\RmfProvider.cs,ReadFace,The following statement contains a magic number: br.ReadBytes (4);  
Magic Number,Sledge.Providers.Map,RmfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\RmfProvider.cs,ReadFace,The following statement contains a magic number: br.ReadBytes (16);  
Magic Number,Sledge.Providers.Map,RmfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\RmfProvider.cs,WriteFace,The following statement contains a magic number: bw.WriteFixedLengthString (Encoding.UTF8' 256' face.Texture.Name);  
Magic Number,Sledge.Providers.Map,RmfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\RmfProvider.cs,WriteFace,The following statement contains a magic number: bw.Write (new byte[4]);  
Magic Number,Sledge.Providers.Map,RmfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\RmfProvider.cs,WriteFace,The following statement contains a magic number: bw.Write (new byte[16]);  
Magic Number,Sledge.Providers.Map,RmfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\RmfProvider.cs,WritePathNode,The following statement contains a magic number: bw.WriteFixedLengthString (Encoding.UTF8' 128' node.Name);  
Magic Number,Sledge.Providers.Map,RmfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\RmfProvider.cs,WritePath,The following statement contains a magic number: bw.WriteFixedLengthString (Encoding.UTF8' 128' path.Name);  
Magic Number,Sledge.Providers.Map,RmfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\RmfProvider.cs,WritePath,The following statement contains a magic number: bw.WriteFixedLengthString (Encoding.UTF8' 128' path.Type);  
Magic Number,Sledge.Providers.Map,RmfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\RmfProvider.cs,ReadVisgroups,The following statement contains a magic number: for (var i = 0; i < numVisgroups; i++) {  	var vis = new Visgroup {  		Name = br.ReadFixedLengthString (Encoding.UTF8' 128)'  		Colour = br.ReadRGBAColour ()'  		ID = br.ReadInt32 ()'  		Visible = br.ReadBoolean ()  	};  	vis.Colour = Color.FromArgb (255' vis.Colour);  	br.ReadBytes (3);  	list.Add (vis);  }  
Magic Number,Sledge.Providers.Map,RmfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\RmfProvider.cs,ReadVisgroups,The following statement contains a magic number: for (var i = 0; i < numVisgroups; i++) {  	var vis = new Visgroup {  		Name = br.ReadFixedLengthString (Encoding.UTF8' 128)'  		Colour = br.ReadRGBAColour ()'  		ID = br.ReadInt32 ()'  		Visible = br.ReadBoolean ()  	};  	vis.Colour = Color.FromArgb (255' vis.Colour);  	br.ReadBytes (3);  	list.Add (vis);  }  
Magic Number,Sledge.Providers.Map,RmfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\RmfProvider.cs,ReadVisgroups,The following statement contains a magic number: for (var i = 0; i < numVisgroups; i++) {  	var vis = new Visgroup {  		Name = br.ReadFixedLengthString (Encoding.UTF8' 128)'  		Colour = br.ReadRGBAColour ()'  		ID = br.ReadInt32 ()'  		Visible = br.ReadBoolean ()  	};  	vis.Colour = Color.FromArgb (255' vis.Colour);  	br.ReadBytes (3);  	list.Add (vis);  }  
Magic Number,Sledge.Providers.Map,RmfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\RmfProvider.cs,ReadVisgroups,The following statement contains a magic number: vis.Colour = Color.FromArgb (255' vis.Colour);  
Magic Number,Sledge.Providers.Map,RmfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\RmfProvider.cs,ReadVisgroups,The following statement contains a magic number: br.ReadBytes (3);  
Magic Number,Sledge.Providers.Map,RmfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\RmfProvider.cs,WriteVisgroups,The following statement contains a magic number: foreach (var visgroup in vis) {  	bw.WriteFixedLengthString (Encoding.UTF8' 128' visgroup.Name);  	bw.WriteRGBAColour (visgroup.Colour);  	bw.Write (visgroup.ID);  	bw.Write (visgroup.Visible);  	bw.Write (new byte[3]);  	// Unused  }  
Magic Number,Sledge.Providers.Map,RmfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\RmfProvider.cs,WriteVisgroups,The following statement contains a magic number: foreach (var visgroup in vis) {  	bw.WriteFixedLengthString (Encoding.UTF8' 128' visgroup.Name);  	bw.WriteRGBAColour (visgroup.Colour);  	bw.Write (visgroup.ID);  	bw.Write (visgroup.Visible);  	bw.Write (new byte[3]);  	// Unused  }  
Magic Number,Sledge.Providers.Map,RmfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\RmfProvider.cs,WriteVisgroups,The following statement contains a magic number: bw.WriteFixedLengthString (Encoding.UTF8' 128' visgroup.Name);  
Magic Number,Sledge.Providers.Map,RmfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\RmfProvider.cs,WriteVisgroups,The following statement contains a magic number: bw.Write (new byte[3]);  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadModel,The following statement contains a magic number: if (version >= MDLVersionSource2006) {  	var numlocalnodes = br.ReadInt32 ();  	var localnodeindex = br.ReadInt32 ();  	var localnodenameindex = br.ReadInt32 ();  	var numflexdesc = br.ReadInt32 ();  	var flexdescindex = br.ReadInt32 ();  	var numflexcontrollers = br.ReadInt32 ();  	var flexcontrollerindex = br.ReadInt32 ();  	var numflexrules = br.ReadInt32 ();  	var flexruleindex = br.ReadInt32 ();  	var numikchains = br.ReadInt32 ();  	var ikchainindex = br.ReadInt32 ();  	var nummouths = br.ReadInt32 ();  	var mouthindex = br.ReadInt32 ();  	var numlocalposeparameters = br.ReadInt32 ();  	var localposeparamindex = br.ReadInt32 ();  	var surfacepropindex = br.ReadInt32 ();  	var keyvalueindex = br.ReadInt32 ();  	var keyvaluesize = br.ReadInt32 ();  	var numlocalikautoplaylocks = br.ReadInt32 ();  	var localikautoplaylockindex = br.ReadInt32 ();  	var mass = br.ReadSingle ();  	var contents = br.ReadInt32 ();  	var numincludemodels = br.ReadInt32 ();  	var includemodelindex = br.ReadInt32 ();  	var virtualModelPointer = br.ReadInt32 ();  	var szanimblocknameindex = br.ReadInt32 ();  	var numanimblocks = br.ReadInt32 ();  	var animblockindex = br.ReadInt32 ();  	var animblockModelPointer = br.ReadInt32 ();  	var bonetablebynameindex = br.ReadInt32 ();  	var pVertexBasePointer = br.ReadInt32 ();  	var pIndexBasePointer = br.ReadInt32 ();  	var constdirectionallightdot = br.ReadByte ();  	var rootLod = br.ReadByte ();  	var numAllowedRootLods = br.ReadByte ();  	// Unused in Source2006  	br.ReadByte ();  	// Unused  	var zeroframecacheindex = br.ReadInt32 ();  	// Unused in Source2007  	if (version == MDLVersionSource2006) {  		br.ReadBytes (6);  		// Unused  	} else if (version == MDLVersionSource2007) {  		var numflexcontrollerui = br.ReadInt32 ();  		var flexcontrolleruiindex = br.ReadInt32 ();  		br.ReadIntArray (2);  		// Unused  		var studiohdr2Index = br.ReadInt32 ();  		br.ReadInt32 ();  		// Unused  	}  } else if (version == MDLVersionGoldsource) {  	var soundTable = br.ReadInt32 ();  	var soundIndex = br.ReadInt32 ();  	var soundGroups = br.ReadInt32 ();  	var soundGroupIndex = br.ReadInt32 ();  	var numTransitions = br.ReadInt32 ();  	var transitionIndex = br.ReadInt32 ();  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadModel,The following statement contains a magic number: if (version >= MDLVersionSource2006) {  	var numlocalnodes = br.ReadInt32 ();  	var localnodeindex = br.ReadInt32 ();  	var localnodenameindex = br.ReadInt32 ();  	var numflexdesc = br.ReadInt32 ();  	var flexdescindex = br.ReadInt32 ();  	var numflexcontrollers = br.ReadInt32 ();  	var flexcontrollerindex = br.ReadInt32 ();  	var numflexrules = br.ReadInt32 ();  	var flexruleindex = br.ReadInt32 ();  	var numikchains = br.ReadInt32 ();  	var ikchainindex = br.ReadInt32 ();  	var nummouths = br.ReadInt32 ();  	var mouthindex = br.ReadInt32 ();  	var numlocalposeparameters = br.ReadInt32 ();  	var localposeparamindex = br.ReadInt32 ();  	var surfacepropindex = br.ReadInt32 ();  	var keyvalueindex = br.ReadInt32 ();  	var keyvaluesize = br.ReadInt32 ();  	var numlocalikautoplaylocks = br.ReadInt32 ();  	var localikautoplaylockindex = br.ReadInt32 ();  	var mass = br.ReadSingle ();  	var contents = br.ReadInt32 ();  	var numincludemodels = br.ReadInt32 ();  	var includemodelindex = br.ReadInt32 ();  	var virtualModelPointer = br.ReadInt32 ();  	var szanimblocknameindex = br.ReadInt32 ();  	var numanimblocks = br.ReadInt32 ();  	var animblockindex = br.ReadInt32 ();  	var animblockModelPointer = br.ReadInt32 ();  	var bonetablebynameindex = br.ReadInt32 ();  	var pVertexBasePointer = br.ReadInt32 ();  	var pIndexBasePointer = br.ReadInt32 ();  	var constdirectionallightdot = br.ReadByte ();  	var rootLod = br.ReadByte ();  	var numAllowedRootLods = br.ReadByte ();  	// Unused in Source2006  	br.ReadByte ();  	// Unused  	var zeroframecacheindex = br.ReadInt32 ();  	// Unused in Source2007  	if (version == MDLVersionSource2006) {  		br.ReadBytes (6);  		// Unused  	} else if (version == MDLVersionSource2007) {  		var numflexcontrollerui = br.ReadInt32 ();  		var flexcontrolleruiindex = br.ReadInt32 ();  		br.ReadIntArray (2);  		// Unused  		var studiohdr2Index = br.ReadInt32 ();  		br.ReadInt32 ();  		// Unused  	}  } else if (version == MDLVersionGoldsource) {  	var soundTable = br.ReadInt32 ();  	var soundIndex = br.ReadInt32 ();  	var soundGroups = br.ReadInt32 ();  	var soundGroupIndex = br.ReadInt32 ();  	var numTransitions = br.ReadInt32 ();  	var transitionIndex = br.ReadInt32 ();  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadModel,The following statement contains a magic number: if (version == MDLVersionSource2006) {  	br.ReadBytes (6);  	// Unused  } else if (version == MDLVersionSource2007) {  	var numflexcontrollerui = br.ReadInt32 ();  	var flexcontrolleruiindex = br.ReadInt32 ();  	br.ReadIntArray (2);  	// Unused  	var studiohdr2Index = br.ReadInt32 ();  	br.ReadInt32 ();  	// Unused  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadModel,The following statement contains a magic number: if (version == MDLVersionSource2006) {  	br.ReadBytes (6);  	// Unused  } else if (version == MDLVersionSource2007) {  	var numflexcontrollerui = br.ReadInt32 ();  	var flexcontrolleruiindex = br.ReadInt32 ();  	br.ReadIntArray (2);  	// Unused  	var studiohdr2Index = br.ReadInt32 ();  	br.ReadInt32 ();  	// Unused  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadModel,The following statement contains a magic number: br.ReadBytes (6);  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadModel,The following statement contains a magic number: if (version == MDLVersionSource2007) {  	var numflexcontrollerui = br.ReadInt32 ();  	var flexcontrolleruiindex = br.ReadInt32 ();  	br.ReadIntArray (2);  	// Unused  	var studiohdr2Index = br.ReadInt32 ();  	br.ReadInt32 ();  	// Unused  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadModel,The following statement contains a magic number: br.ReadIntArray (2);  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadTextureInfo,The following statement contains a magic number: if (data.Version == MDLVersionGoldsource) {  	var tempBr = br;  	var disp = false;  	if (numTextures == 0) {  		disp = true;  		var texFile = file.Parent.GetFile (file.NameWithoutExtension + "T." + file.Extension);  		br = new BinaryReader (texFile.Open ());  		br.BaseStream.Position = 180;  		// skip all the unused nonsense in the T file  		numTextures = br.ReadInt32 ();  		textureIndex = br.ReadInt32 ();  		var textureDataIndex = br.ReadInt32 ();  		var numSkinRef = br.ReadInt32 ();  		var numSkinFamilies = br.ReadInt32 ();  		var skinIndex = br.ReadInt32 ();  	}  	br.BaseStream.Position = textureIndex;  	for (var i = 0; i < numTextures; i++) {  		var name = br.ReadFixedLengthString (Encoding.ASCII' 64);  		var flags = br.ReadInt32 ();  		var width = br.ReadInt32 ();  		var height = br.ReadInt32 ();  		var index = br.ReadInt32 ();  		var savedPosition = br.BaseStream.Position;  		br.BaseStream.Position = index;  		var indices = br.ReadBytes (width * height);  		var palette = br.ReadBytes ((byte.MaxValue + 1) * 3);  		var bmp = new Bitmap (width' height' PixelFormat.Format8bppIndexed);  		var pal = bmp.Palette;  		for (var j = 0; j <= byte.MaxValue; j++) {  			var k = j * 3;  			pal.Entries [j] = Color.FromArgb (255' palette [k]' palette [k + 1]' palette [k + 2]);  		}  		bmp.Palette = pal;  		var bmpData = bmp.LockBits (new Rectangle (0' 0' width' height)' ImageLockMode.WriteOnly' bmp.PixelFormat);  		Marshal.Copy (indices' 0' bmpData.Scan0' indices.Length);  		bmp.UnlockBits (bmpData);  		var tex = new DataStructures.Models.Texture {  			Name = name'  			Index = i'  			Width = width'  			Height = height'  			Flags = flags'  			Image = bmp  		};  		model.Textures.Add (tex);  		br.BaseStream.Position = savedPosition;  	}  	//  	if (disp) {  		br.BaseStream.Dispose ();  		br.Dispose ();  		br = tempBr;  	}  } else if (data.Version >= MDLVersionSource2006) {  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadTextureInfo,The following statement contains a magic number: if (data.Version == MDLVersionGoldsource) {  	var tempBr = br;  	var disp = false;  	if (numTextures == 0) {  		disp = true;  		var texFile = file.Parent.GetFile (file.NameWithoutExtension + "T." + file.Extension);  		br = new BinaryReader (texFile.Open ());  		br.BaseStream.Position = 180;  		// skip all the unused nonsense in the T file  		numTextures = br.ReadInt32 ();  		textureIndex = br.ReadInt32 ();  		var textureDataIndex = br.ReadInt32 ();  		var numSkinRef = br.ReadInt32 ();  		var numSkinFamilies = br.ReadInt32 ();  		var skinIndex = br.ReadInt32 ();  	}  	br.BaseStream.Position = textureIndex;  	for (var i = 0; i < numTextures; i++) {  		var name = br.ReadFixedLengthString (Encoding.ASCII' 64);  		var flags = br.ReadInt32 ();  		var width = br.ReadInt32 ();  		var height = br.ReadInt32 ();  		var index = br.ReadInt32 ();  		var savedPosition = br.BaseStream.Position;  		br.BaseStream.Position = index;  		var indices = br.ReadBytes (width * height);  		var palette = br.ReadBytes ((byte.MaxValue + 1) * 3);  		var bmp = new Bitmap (width' height' PixelFormat.Format8bppIndexed);  		var pal = bmp.Palette;  		for (var j = 0; j <= byte.MaxValue; j++) {  			var k = j * 3;  			pal.Entries [j] = Color.FromArgb (255' palette [k]' palette [k + 1]' palette [k + 2]);  		}  		bmp.Palette = pal;  		var bmpData = bmp.LockBits (new Rectangle (0' 0' width' height)' ImageLockMode.WriteOnly' bmp.PixelFormat);  		Marshal.Copy (indices' 0' bmpData.Scan0' indices.Length);  		bmp.UnlockBits (bmpData);  		var tex = new DataStructures.Models.Texture {  			Name = name'  			Index = i'  			Width = width'  			Height = height'  			Flags = flags'  			Image = bmp  		};  		model.Textures.Add (tex);  		br.BaseStream.Position = savedPosition;  	}  	//  	if (disp) {  		br.BaseStream.Dispose ();  		br.Dispose ();  		br = tempBr;  	}  } else if (data.Version >= MDLVersionSource2006) {  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadTextureInfo,The following statement contains a magic number: if (data.Version == MDLVersionGoldsource) {  	var tempBr = br;  	var disp = false;  	if (numTextures == 0) {  		disp = true;  		var texFile = file.Parent.GetFile (file.NameWithoutExtension + "T." + file.Extension);  		br = new BinaryReader (texFile.Open ());  		br.BaseStream.Position = 180;  		// skip all the unused nonsense in the T file  		numTextures = br.ReadInt32 ();  		textureIndex = br.ReadInt32 ();  		var textureDataIndex = br.ReadInt32 ();  		var numSkinRef = br.ReadInt32 ();  		var numSkinFamilies = br.ReadInt32 ();  		var skinIndex = br.ReadInt32 ();  	}  	br.BaseStream.Position = textureIndex;  	for (var i = 0; i < numTextures; i++) {  		var name = br.ReadFixedLengthString (Encoding.ASCII' 64);  		var flags = br.ReadInt32 ();  		var width = br.ReadInt32 ();  		var height = br.ReadInt32 ();  		var index = br.ReadInt32 ();  		var savedPosition = br.BaseStream.Position;  		br.BaseStream.Position = index;  		var indices = br.ReadBytes (width * height);  		var palette = br.ReadBytes ((byte.MaxValue + 1) * 3);  		var bmp = new Bitmap (width' height' PixelFormat.Format8bppIndexed);  		var pal = bmp.Palette;  		for (var j = 0; j <= byte.MaxValue; j++) {  			var k = j * 3;  			pal.Entries [j] = Color.FromArgb (255' palette [k]' palette [k + 1]' palette [k + 2]);  		}  		bmp.Palette = pal;  		var bmpData = bmp.LockBits (new Rectangle (0' 0' width' height)' ImageLockMode.WriteOnly' bmp.PixelFormat);  		Marshal.Copy (indices' 0' bmpData.Scan0' indices.Length);  		bmp.UnlockBits (bmpData);  		var tex = new DataStructures.Models.Texture {  			Name = name'  			Index = i'  			Width = width'  			Height = height'  			Flags = flags'  			Image = bmp  		};  		model.Textures.Add (tex);  		br.BaseStream.Position = savedPosition;  	}  	//  	if (disp) {  		br.BaseStream.Dispose ();  		br.Dispose ();  		br = tempBr;  	}  } else if (data.Version >= MDLVersionSource2006) {  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadTextureInfo,The following statement contains a magic number: if (data.Version == MDLVersionGoldsource) {  	var tempBr = br;  	var disp = false;  	if (numTextures == 0) {  		disp = true;  		var texFile = file.Parent.GetFile (file.NameWithoutExtension + "T." + file.Extension);  		br = new BinaryReader (texFile.Open ());  		br.BaseStream.Position = 180;  		// skip all the unused nonsense in the T file  		numTextures = br.ReadInt32 ();  		textureIndex = br.ReadInt32 ();  		var textureDataIndex = br.ReadInt32 ();  		var numSkinRef = br.ReadInt32 ();  		var numSkinFamilies = br.ReadInt32 ();  		var skinIndex = br.ReadInt32 ();  	}  	br.BaseStream.Position = textureIndex;  	for (var i = 0; i < numTextures; i++) {  		var name = br.ReadFixedLengthString (Encoding.ASCII' 64);  		var flags = br.ReadInt32 ();  		var width = br.ReadInt32 ();  		var height = br.ReadInt32 ();  		var index = br.ReadInt32 ();  		var savedPosition = br.BaseStream.Position;  		br.BaseStream.Position = index;  		var indices = br.ReadBytes (width * height);  		var palette = br.ReadBytes ((byte.MaxValue + 1) * 3);  		var bmp = new Bitmap (width' height' PixelFormat.Format8bppIndexed);  		var pal = bmp.Palette;  		for (var j = 0; j <= byte.MaxValue; j++) {  			var k = j * 3;  			pal.Entries [j] = Color.FromArgb (255' palette [k]' palette [k + 1]' palette [k + 2]);  		}  		bmp.Palette = pal;  		var bmpData = bmp.LockBits (new Rectangle (0' 0' width' height)' ImageLockMode.WriteOnly' bmp.PixelFormat);  		Marshal.Copy (indices' 0' bmpData.Scan0' indices.Length);  		bmp.UnlockBits (bmpData);  		var tex = new DataStructures.Models.Texture {  			Name = name'  			Index = i'  			Width = width'  			Height = height'  			Flags = flags'  			Image = bmp  		};  		model.Textures.Add (tex);  		br.BaseStream.Position = savedPosition;  	}  	//  	if (disp) {  		br.BaseStream.Dispose ();  		br.Dispose ();  		br = tempBr;  	}  } else if (data.Version >= MDLVersionSource2006) {  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadTextureInfo,The following statement contains a magic number: if (data.Version == MDLVersionGoldsource) {  	var tempBr = br;  	var disp = false;  	if (numTextures == 0) {  		disp = true;  		var texFile = file.Parent.GetFile (file.NameWithoutExtension + "T." + file.Extension);  		br = new BinaryReader (texFile.Open ());  		br.BaseStream.Position = 180;  		// skip all the unused nonsense in the T file  		numTextures = br.ReadInt32 ();  		textureIndex = br.ReadInt32 ();  		var textureDataIndex = br.ReadInt32 ();  		var numSkinRef = br.ReadInt32 ();  		var numSkinFamilies = br.ReadInt32 ();  		var skinIndex = br.ReadInt32 ();  	}  	br.BaseStream.Position = textureIndex;  	for (var i = 0; i < numTextures; i++) {  		var name = br.ReadFixedLengthString (Encoding.ASCII' 64);  		var flags = br.ReadInt32 ();  		var width = br.ReadInt32 ();  		var height = br.ReadInt32 ();  		var index = br.ReadInt32 ();  		var savedPosition = br.BaseStream.Position;  		br.BaseStream.Position = index;  		var indices = br.ReadBytes (width * height);  		var palette = br.ReadBytes ((byte.MaxValue + 1) * 3);  		var bmp = new Bitmap (width' height' PixelFormat.Format8bppIndexed);  		var pal = bmp.Palette;  		for (var j = 0; j <= byte.MaxValue; j++) {  			var k = j * 3;  			pal.Entries [j] = Color.FromArgb (255' palette [k]' palette [k + 1]' palette [k + 2]);  		}  		bmp.Palette = pal;  		var bmpData = bmp.LockBits (new Rectangle (0' 0' width' height)' ImageLockMode.WriteOnly' bmp.PixelFormat);  		Marshal.Copy (indices' 0' bmpData.Scan0' indices.Length);  		bmp.UnlockBits (bmpData);  		var tex = new DataStructures.Models.Texture {  			Name = name'  			Index = i'  			Width = width'  			Height = height'  			Flags = flags'  			Image = bmp  		};  		model.Textures.Add (tex);  		br.BaseStream.Position = savedPosition;  	}  	//  	if (disp) {  		br.BaseStream.Dispose ();  		br.Dispose ();  		br = tempBr;  	}  } else if (data.Version >= MDLVersionSource2006) {  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadTextureInfo,The following statement contains a magic number: if (data.Version == MDLVersionGoldsource) {  	var tempBr = br;  	var disp = false;  	if (numTextures == 0) {  		disp = true;  		var texFile = file.Parent.GetFile (file.NameWithoutExtension + "T." + file.Extension);  		br = new BinaryReader (texFile.Open ());  		br.BaseStream.Position = 180;  		// skip all the unused nonsense in the T file  		numTextures = br.ReadInt32 ();  		textureIndex = br.ReadInt32 ();  		var textureDataIndex = br.ReadInt32 ();  		var numSkinRef = br.ReadInt32 ();  		var numSkinFamilies = br.ReadInt32 ();  		var skinIndex = br.ReadInt32 ();  	}  	br.BaseStream.Position = textureIndex;  	for (var i = 0; i < numTextures; i++) {  		var name = br.ReadFixedLengthString (Encoding.ASCII' 64);  		var flags = br.ReadInt32 ();  		var width = br.ReadInt32 ();  		var height = br.ReadInt32 ();  		var index = br.ReadInt32 ();  		var savedPosition = br.BaseStream.Position;  		br.BaseStream.Position = index;  		var indices = br.ReadBytes (width * height);  		var palette = br.ReadBytes ((byte.MaxValue + 1) * 3);  		var bmp = new Bitmap (width' height' PixelFormat.Format8bppIndexed);  		var pal = bmp.Palette;  		for (var j = 0; j <= byte.MaxValue; j++) {  			var k = j * 3;  			pal.Entries [j] = Color.FromArgb (255' palette [k]' palette [k + 1]' palette [k + 2]);  		}  		bmp.Palette = pal;  		var bmpData = bmp.LockBits (new Rectangle (0' 0' width' height)' ImageLockMode.WriteOnly' bmp.PixelFormat);  		Marshal.Copy (indices' 0' bmpData.Scan0' indices.Length);  		bmp.UnlockBits (bmpData);  		var tex = new DataStructures.Models.Texture {  			Name = name'  			Index = i'  			Width = width'  			Height = height'  			Flags = flags'  			Image = bmp  		};  		model.Textures.Add (tex);  		br.BaseStream.Position = savedPosition;  	}  	//  	if (disp) {  		br.BaseStream.Dispose ();  		br.Dispose ();  		br = tempBr;  	}  } else if (data.Version >= MDLVersionSource2006) {  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadTextureInfo,The following statement contains a magic number: if (numTextures == 0) {  	disp = true;  	var texFile = file.Parent.GetFile (file.NameWithoutExtension + "T." + file.Extension);  	br = new BinaryReader (texFile.Open ());  	br.BaseStream.Position = 180;  	// skip all the unused nonsense in the T file  	numTextures = br.ReadInt32 ();  	textureIndex = br.ReadInt32 ();  	var textureDataIndex = br.ReadInt32 ();  	var numSkinRef = br.ReadInt32 ();  	var numSkinFamilies = br.ReadInt32 ();  	var skinIndex = br.ReadInt32 ();  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadTextureInfo,The following statement contains a magic number: br.BaseStream.Position = 180;  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadTextureInfo,The following statement contains a magic number: for (var i = 0; i < numTextures; i++) {  	var name = br.ReadFixedLengthString (Encoding.ASCII' 64);  	var flags = br.ReadInt32 ();  	var width = br.ReadInt32 ();  	var height = br.ReadInt32 ();  	var index = br.ReadInt32 ();  	var savedPosition = br.BaseStream.Position;  	br.BaseStream.Position = index;  	var indices = br.ReadBytes (width * height);  	var palette = br.ReadBytes ((byte.MaxValue + 1) * 3);  	var bmp = new Bitmap (width' height' PixelFormat.Format8bppIndexed);  	var pal = bmp.Palette;  	for (var j = 0; j <= byte.MaxValue; j++) {  		var k = j * 3;  		pal.Entries [j] = Color.FromArgb (255' palette [k]' palette [k + 1]' palette [k + 2]);  	}  	bmp.Palette = pal;  	var bmpData = bmp.LockBits (new Rectangle (0' 0' width' height)' ImageLockMode.WriteOnly' bmp.PixelFormat);  	Marshal.Copy (indices' 0' bmpData.Scan0' indices.Length);  	bmp.UnlockBits (bmpData);  	var tex = new DataStructures.Models.Texture {  		Name = name'  		Index = i'  		Width = width'  		Height = height'  		Flags = flags'  		Image = bmp  	};  	model.Textures.Add (tex);  	br.BaseStream.Position = savedPosition;  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadTextureInfo,The following statement contains a magic number: for (var i = 0; i < numTextures; i++) {  	var name = br.ReadFixedLengthString (Encoding.ASCII' 64);  	var flags = br.ReadInt32 ();  	var width = br.ReadInt32 ();  	var height = br.ReadInt32 ();  	var index = br.ReadInt32 ();  	var savedPosition = br.BaseStream.Position;  	br.BaseStream.Position = index;  	var indices = br.ReadBytes (width * height);  	var palette = br.ReadBytes ((byte.MaxValue + 1) * 3);  	var bmp = new Bitmap (width' height' PixelFormat.Format8bppIndexed);  	var pal = bmp.Palette;  	for (var j = 0; j <= byte.MaxValue; j++) {  		var k = j * 3;  		pal.Entries [j] = Color.FromArgb (255' palette [k]' palette [k + 1]' palette [k + 2]);  	}  	bmp.Palette = pal;  	var bmpData = bmp.LockBits (new Rectangle (0' 0' width' height)' ImageLockMode.WriteOnly' bmp.PixelFormat);  	Marshal.Copy (indices' 0' bmpData.Scan0' indices.Length);  	bmp.UnlockBits (bmpData);  	var tex = new DataStructures.Models.Texture {  		Name = name'  		Index = i'  		Width = width'  		Height = height'  		Flags = flags'  		Image = bmp  	};  	model.Textures.Add (tex);  	br.BaseStream.Position = savedPosition;  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadTextureInfo,The following statement contains a magic number: for (var i = 0; i < numTextures; i++) {  	var name = br.ReadFixedLengthString (Encoding.ASCII' 64);  	var flags = br.ReadInt32 ();  	var width = br.ReadInt32 ();  	var height = br.ReadInt32 ();  	var index = br.ReadInt32 ();  	var savedPosition = br.BaseStream.Position;  	br.BaseStream.Position = index;  	var indices = br.ReadBytes (width * height);  	var palette = br.ReadBytes ((byte.MaxValue + 1) * 3);  	var bmp = new Bitmap (width' height' PixelFormat.Format8bppIndexed);  	var pal = bmp.Palette;  	for (var j = 0; j <= byte.MaxValue; j++) {  		var k = j * 3;  		pal.Entries [j] = Color.FromArgb (255' palette [k]' palette [k + 1]' palette [k + 2]);  	}  	bmp.Palette = pal;  	var bmpData = bmp.LockBits (new Rectangle (0' 0' width' height)' ImageLockMode.WriteOnly' bmp.PixelFormat);  	Marshal.Copy (indices' 0' bmpData.Scan0' indices.Length);  	bmp.UnlockBits (bmpData);  	var tex = new DataStructures.Models.Texture {  		Name = name'  		Index = i'  		Width = width'  		Height = height'  		Flags = flags'  		Image = bmp  	};  	model.Textures.Add (tex);  	br.BaseStream.Position = savedPosition;  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadTextureInfo,The following statement contains a magic number: for (var i = 0; i < numTextures; i++) {  	var name = br.ReadFixedLengthString (Encoding.ASCII' 64);  	var flags = br.ReadInt32 ();  	var width = br.ReadInt32 ();  	var height = br.ReadInt32 ();  	var index = br.ReadInt32 ();  	var savedPosition = br.BaseStream.Position;  	br.BaseStream.Position = index;  	var indices = br.ReadBytes (width * height);  	var palette = br.ReadBytes ((byte.MaxValue + 1) * 3);  	var bmp = new Bitmap (width' height' PixelFormat.Format8bppIndexed);  	var pal = bmp.Palette;  	for (var j = 0; j <= byte.MaxValue; j++) {  		var k = j * 3;  		pal.Entries [j] = Color.FromArgb (255' palette [k]' palette [k + 1]' palette [k + 2]);  	}  	bmp.Palette = pal;  	var bmpData = bmp.LockBits (new Rectangle (0' 0' width' height)' ImageLockMode.WriteOnly' bmp.PixelFormat);  	Marshal.Copy (indices' 0' bmpData.Scan0' indices.Length);  	bmp.UnlockBits (bmpData);  	var tex = new DataStructures.Models.Texture {  		Name = name'  		Index = i'  		Width = width'  		Height = height'  		Flags = flags'  		Image = bmp  	};  	model.Textures.Add (tex);  	br.BaseStream.Position = savedPosition;  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadTextureInfo,The following statement contains a magic number: for (var i = 0; i < numTextures; i++) {  	var name = br.ReadFixedLengthString (Encoding.ASCII' 64);  	var flags = br.ReadInt32 ();  	var width = br.ReadInt32 ();  	var height = br.ReadInt32 ();  	var index = br.ReadInt32 ();  	var savedPosition = br.BaseStream.Position;  	br.BaseStream.Position = index;  	var indices = br.ReadBytes (width * height);  	var palette = br.ReadBytes ((byte.MaxValue + 1) * 3);  	var bmp = new Bitmap (width' height' PixelFormat.Format8bppIndexed);  	var pal = bmp.Palette;  	for (var j = 0; j <= byte.MaxValue; j++) {  		var k = j * 3;  		pal.Entries [j] = Color.FromArgb (255' palette [k]' palette [k + 1]' palette [k + 2]);  	}  	bmp.Palette = pal;  	var bmpData = bmp.LockBits (new Rectangle (0' 0' width' height)' ImageLockMode.WriteOnly' bmp.PixelFormat);  	Marshal.Copy (indices' 0' bmpData.Scan0' indices.Length);  	bmp.UnlockBits (bmpData);  	var tex = new DataStructures.Models.Texture {  		Name = name'  		Index = i'  		Width = width'  		Height = height'  		Flags = flags'  		Image = bmp  	};  	model.Textures.Add (tex);  	br.BaseStream.Position = savedPosition;  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadTextureInfo,The following statement contains a magic number: for (var j = 0; j <= byte.MaxValue; j++) {  	var k = j * 3;  	pal.Entries [j] = Color.FromArgb (255' palette [k]' palette [k + 1]' palette [k + 2]);  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadTextureInfo,The following statement contains a magic number: for (var j = 0; j <= byte.MaxValue; j++) {  	var k = j * 3;  	pal.Entries [j] = Color.FromArgb (255' palette [k]' palette [k + 1]' palette [k + 2]);  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadTextureInfo,The following statement contains a magic number: for (var j = 0; j <= byte.MaxValue; j++) {  	var k = j * 3;  	pal.Entries [j] = Color.FromArgb (255' palette [k]' palette [k + 1]' palette [k + 2]);  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadTextureInfo,The following statement contains a magic number: pal.Entries [j] = Color.FromArgb (255' palette [k]' palette [k + 1]' palette [k + 2]);  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadTextureInfo,The following statement contains a magic number: pal.Entries [j] = Color.FromArgb (255' palette [k]' palette [k + 1]' palette [k + 2]);  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadSequence,The following statement contains a magic number: if (data.Version == MDLVersionGoldsource) {  	name = br.ReadFixedLengthString (Encoding.ASCII' 32);  	fps = br.ReadSingle ();  } else if (data.Version >= MDLVersionSource2006) {  	var baseIndex = br.ReadInt32 ();  	var labelIndex = br.ReadInt32 ();  	var activityNameIndex = br.ReadInt32 ();  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadSequence,The following statement contains a magic number: name = br.ReadFixedLengthString (Encoding.ASCII' 32);  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadSequence,The following statement contains a magic number: if (data.Version >= MDLVersionSource2006) {  	var movementindex = br.ReadInt32 ();  	groupsize = br.ReadIntArray (2);  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadSequence,The following statement contains a magic number: groupsize = br.ReadIntArray (2);  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadSequence,The following statement contains a magic number: if (data.Version >= MDLVersionSource2006) {  	var pose = br.ReadInt32 ();  	var numikrules = br.ReadInt32 ();  	var numautolayers = br.ReadInt32 ();  	var autolayerindex = br.ReadInt32 ();  	var weightlistindex = br.ReadInt32 ();  	var wlpos = br.BaseStream.Position;  	br.BaseStream.Position = startReadIndex + weightlistindex;  	var weightList = br.ReadSingleArray (model.Bones.Count);  	br.BaseStream.Position = wlpos;  	var posekeyindex = br.ReadInt32 ();  	var numiklocks = br.ReadInt32 ();  	var iklockindex = br.ReadInt32 ();  	var keyvalueindex = br.ReadInt32 ();  	var keyvaluesize = br.ReadInt32 ();  	var cycleposeindex = br.ReadInt32 ();  	br.ReadIntArray (7);  	// Unused  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadSequence,The following statement contains a magic number: br.ReadIntArray (7);  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceAnimationData,The following statement contains a magic number: for (var i = 0; i < numAnim; i++) {  	var animStartPos = br.BaseStream.Position;  	var basePointer = br.ReadInt32 ();  	var szNameIndex = br.ReadInt32 ();  	var fps = br.ReadSingle ();  	var animDescFlags = br.ReadInt32 ();  	var numframes = br.ReadInt32 ();  	var numMovements = br.ReadInt32 ();  	var movementIndex = br.ReadInt32 ();  	br.ReadCoordinateFArray (2);  	// bounding box; unused  	var ablock = br.ReadInt32 ();  	var aindex = br.ReadInt32 ();  	var numIkRules = br.ReadInt32 ();  	var ikRuleIndex = br.ReadInt32 ();  	var animBlockIkRuleIndex = br.ReadInt32 ();  	br.ReadIntArray (7);  	// Unused  	var animEndPos = br.BaseStream.Position;  	var sourceAnim = new SourceAnimation (i' numframes' fps' animDescFlags' numMovements' movementIndex' ablock' aindex' numIkRules' ikRuleIndex' animBlockIkRuleIndex);  	var currentOffset = aindex;  	short nextOffset;  	do {  		br.BaseStream.Position = animStartPos + currentOffset;  		var animBone = br.ReadByte ();  		var animFlags = br.ReadByte ();  		nextOffset = br.ReadInt16 ();  		currentOffset += nextOffset;  		var aniBone = new SourceAnimationBone (animBone' animFlags' numframes);  		aniBone.ReadData (br);  		sourceAnim.AnimationBones.Add (aniBone);  	} while (nextOffset != 0);  	modelData.SourceAnimations.Add (sourceAnim);  	br.BaseStream.Position = animEndPos;  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceAnimationData,The following statement contains a magic number: for (var i = 0; i < numAnim; i++) {  	var animStartPos = br.BaseStream.Position;  	var basePointer = br.ReadInt32 ();  	var szNameIndex = br.ReadInt32 ();  	var fps = br.ReadSingle ();  	var animDescFlags = br.ReadInt32 ();  	var numframes = br.ReadInt32 ();  	var numMovements = br.ReadInt32 ();  	var movementIndex = br.ReadInt32 ();  	br.ReadCoordinateFArray (2);  	// bounding box; unused  	var ablock = br.ReadInt32 ();  	var aindex = br.ReadInt32 ();  	var numIkRules = br.ReadInt32 ();  	var ikRuleIndex = br.ReadInt32 ();  	var animBlockIkRuleIndex = br.ReadInt32 ();  	br.ReadIntArray (7);  	// Unused  	var animEndPos = br.BaseStream.Position;  	var sourceAnim = new SourceAnimation (i' numframes' fps' animDescFlags' numMovements' movementIndex' ablock' aindex' numIkRules' ikRuleIndex' animBlockIkRuleIndex);  	var currentOffset = aindex;  	short nextOffset;  	do {  		br.BaseStream.Position = animStartPos + currentOffset;  		var animBone = br.ReadByte ();  		var animFlags = br.ReadByte ();  		nextOffset = br.ReadInt16 ();  		currentOffset += nextOffset;  		var aniBone = new SourceAnimationBone (animBone' animFlags' numframes);  		aniBone.ReadData (br);  		sourceAnim.AnimationBones.Add (aniBone);  	} while (nextOffset != 0);  	modelData.SourceAnimations.Add (sourceAnim);  	br.BaseStream.Position = animEndPos;  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceAnimationData,The following statement contains a magic number: br.ReadCoordinateFArray (2);  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceAnimationData,The following statement contains a magic number: br.ReadIntArray (7);  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadAnimationGoldsource,The following statement contains a magic number: foreach (var bone in model.Bones) {  	var offsetPos = br.BaseStream.Position;  	var offsets = br.ReadShortArray (6);  	var restorePoint = br.BaseStream.Position;  	var position = bone.DefaultPosition;  	var angles = bone.DefaultAngles;  	var boneFrames = new List<float[]> ();  	for (var i = 0; i < numframes; i++)  		boneFrames.Add (new float[] {  			0'  			0'  			0'  			0'  			0'  			0  		});  	for (var i = 0; i < 6; i++)// For each offset [X' Y' Z' XR' YR' ZR]  	 {  		if (offsets [i] <= 0)  			continue;  		br.BaseStream.Position = offsetPos + offsets [i];  		var values = ReadRLEEncodedAnimationFrameValues (br' numframes);  		for (var f = 0; f < numframes; f++) {  			boneFrames [f] [i] += values [f];  		}  	}  	for (var f = 0; f < numframes; f++) {  		var frame = boneFrames [f];  		var fpos = new CoordinateF (frame [0]' frame [1]' frame [2]).ComponentMultiply (bone.DefaultPositionScale) + bone.DefaultPosition;  		var fang = new CoordinateF (frame [3]' frame [4]' frame [5]).ComponentMultiply (bone.DefaultAnglesScale) + bone.DefaultAngles;  		anim.Frames [f].Bones.Add (new BoneAnimationFrame (bone' fpos' QuaternionF.EulerAngles (fang)));  	}  	br.BaseStream.Position = restorePoint;  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadAnimationGoldsource,The following statement contains a magic number: foreach (var bone in model.Bones) {  	var offsetPos = br.BaseStream.Position;  	var offsets = br.ReadShortArray (6);  	var restorePoint = br.BaseStream.Position;  	var position = bone.DefaultPosition;  	var angles = bone.DefaultAngles;  	var boneFrames = new List<float[]> ();  	for (var i = 0; i < numframes; i++)  		boneFrames.Add (new float[] {  			0'  			0'  			0'  			0'  			0'  			0  		});  	for (var i = 0; i < 6; i++)// For each offset [X' Y' Z' XR' YR' ZR]  	 {  		if (offsets [i] <= 0)  			continue;  		br.BaseStream.Position = offsetPos + offsets [i];  		var values = ReadRLEEncodedAnimationFrameValues (br' numframes);  		for (var f = 0; f < numframes; f++) {  			boneFrames [f] [i] += values [f];  		}  	}  	for (var f = 0; f < numframes; f++) {  		var frame = boneFrames [f];  		var fpos = new CoordinateF (frame [0]' frame [1]' frame [2]).ComponentMultiply (bone.DefaultPositionScale) + bone.DefaultPosition;  		var fang = new CoordinateF (frame [3]' frame [4]' frame [5]).ComponentMultiply (bone.DefaultAnglesScale) + bone.DefaultAngles;  		anim.Frames [f].Bones.Add (new BoneAnimationFrame (bone' fpos' QuaternionF.EulerAngles (fang)));  	}  	br.BaseStream.Position = restorePoint;  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadAnimationGoldsource,The following statement contains a magic number: foreach (var bone in model.Bones) {  	var offsetPos = br.BaseStream.Position;  	var offsets = br.ReadShortArray (6);  	var restorePoint = br.BaseStream.Position;  	var position = bone.DefaultPosition;  	var angles = bone.DefaultAngles;  	var boneFrames = new List<float[]> ();  	for (var i = 0; i < numframes; i++)  		boneFrames.Add (new float[] {  			0'  			0'  			0'  			0'  			0'  			0  		});  	for (var i = 0; i < 6; i++)// For each offset [X' Y' Z' XR' YR' ZR]  	 {  		if (offsets [i] <= 0)  			continue;  		br.BaseStream.Position = offsetPos + offsets [i];  		var values = ReadRLEEncodedAnimationFrameValues (br' numframes);  		for (var f = 0; f < numframes; f++) {  			boneFrames [f] [i] += values [f];  		}  	}  	for (var f = 0; f < numframes; f++) {  		var frame = boneFrames [f];  		var fpos = new CoordinateF (frame [0]' frame [1]' frame [2]).ComponentMultiply (bone.DefaultPositionScale) + bone.DefaultPosition;  		var fang = new CoordinateF (frame [3]' frame [4]' frame [5]).ComponentMultiply (bone.DefaultAnglesScale) + bone.DefaultAngles;  		anim.Frames [f].Bones.Add (new BoneAnimationFrame (bone' fpos' QuaternionF.EulerAngles (fang)));  	}  	br.BaseStream.Position = restorePoint;  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadAnimationGoldsource,The following statement contains a magic number: foreach (var bone in model.Bones) {  	var offsetPos = br.BaseStream.Position;  	var offsets = br.ReadShortArray (6);  	var restorePoint = br.BaseStream.Position;  	var position = bone.DefaultPosition;  	var angles = bone.DefaultAngles;  	var boneFrames = new List<float[]> ();  	for (var i = 0; i < numframes; i++)  		boneFrames.Add (new float[] {  			0'  			0'  			0'  			0'  			0'  			0  		});  	for (var i = 0; i < 6; i++)// For each offset [X' Y' Z' XR' YR' ZR]  	 {  		if (offsets [i] <= 0)  			continue;  		br.BaseStream.Position = offsetPos + offsets [i];  		var values = ReadRLEEncodedAnimationFrameValues (br' numframes);  		for (var f = 0; f < numframes; f++) {  			boneFrames [f] [i] += values [f];  		}  	}  	for (var f = 0; f < numframes; f++) {  		var frame = boneFrames [f];  		var fpos = new CoordinateF (frame [0]' frame [1]' frame [2]).ComponentMultiply (bone.DefaultPositionScale) + bone.DefaultPosition;  		var fang = new CoordinateF (frame [3]' frame [4]' frame [5]).ComponentMultiply (bone.DefaultAnglesScale) + bone.DefaultAngles;  		anim.Frames [f].Bones.Add (new BoneAnimationFrame (bone' fpos' QuaternionF.EulerAngles (fang)));  	}  	br.BaseStream.Position = restorePoint;  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadAnimationGoldsource,The following statement contains a magic number: foreach (var bone in model.Bones) {  	var offsetPos = br.BaseStream.Position;  	var offsets = br.ReadShortArray (6);  	var restorePoint = br.BaseStream.Position;  	var position = bone.DefaultPosition;  	var angles = bone.DefaultAngles;  	var boneFrames = new List<float[]> ();  	for (var i = 0; i < numframes; i++)  		boneFrames.Add (new float[] {  			0'  			0'  			0'  			0'  			0'  			0  		});  	for (var i = 0; i < 6; i++)// For each offset [X' Y' Z' XR' YR' ZR]  	 {  		if (offsets [i] <= 0)  			continue;  		br.BaseStream.Position = offsetPos + offsets [i];  		var values = ReadRLEEncodedAnimationFrameValues (br' numframes);  		for (var f = 0; f < numframes; f++) {  			boneFrames [f] [i] += values [f];  		}  	}  	for (var f = 0; f < numframes; f++) {  		var frame = boneFrames [f];  		var fpos = new CoordinateF (frame [0]' frame [1]' frame [2]).ComponentMultiply (bone.DefaultPositionScale) + bone.DefaultPosition;  		var fang = new CoordinateF (frame [3]' frame [4]' frame [5]).ComponentMultiply (bone.DefaultAnglesScale) + bone.DefaultAngles;  		anim.Frames [f].Bones.Add (new BoneAnimationFrame (bone' fpos' QuaternionF.EulerAngles (fang)));  	}  	br.BaseStream.Position = restorePoint;  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadAnimationGoldsource,The following statement contains a magic number: foreach (var bone in model.Bones) {  	var offsetPos = br.BaseStream.Position;  	var offsets = br.ReadShortArray (6);  	var restorePoint = br.BaseStream.Position;  	var position = bone.DefaultPosition;  	var angles = bone.DefaultAngles;  	var boneFrames = new List<float[]> ();  	for (var i = 0; i < numframes; i++)  		boneFrames.Add (new float[] {  			0'  			0'  			0'  			0'  			0'  			0  		});  	for (var i = 0; i < 6; i++)// For each offset [X' Y' Z' XR' YR' ZR]  	 {  		if (offsets [i] <= 0)  			continue;  		br.BaseStream.Position = offsetPos + offsets [i];  		var values = ReadRLEEncodedAnimationFrameValues (br' numframes);  		for (var f = 0; f < numframes; f++) {  			boneFrames [f] [i] += values [f];  		}  	}  	for (var f = 0; f < numframes; f++) {  		var frame = boneFrames [f];  		var fpos = new CoordinateF (frame [0]' frame [1]' frame [2]).ComponentMultiply (bone.DefaultPositionScale) + bone.DefaultPosition;  		var fang = new CoordinateF (frame [3]' frame [4]' frame [5]).ComponentMultiply (bone.DefaultAnglesScale) + bone.DefaultAngles;  		anim.Frames [f].Bones.Add (new BoneAnimationFrame (bone' fpos' QuaternionF.EulerAngles (fang)));  	}  	br.BaseStream.Position = restorePoint;  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadAnimationGoldsource,The following statement contains a magic number: for (var i = 0; i < 6; i++)// For each offset [X' Y' Z' XR' YR' ZR]   {  	if (offsets [i] <= 0)  		continue;  	br.BaseStream.Position = offsetPos + offsets [i];  	var values = ReadRLEEncodedAnimationFrameValues (br' numframes);  	for (var f = 0; f < numframes; f++) {  		boneFrames [f] [i] += values [f];  	}  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadAnimationGoldsource,The following statement contains a magic number: for (var f = 0; f < numframes; f++) {  	var frame = boneFrames [f];  	var fpos = new CoordinateF (frame [0]' frame [1]' frame [2]).ComponentMultiply (bone.DefaultPositionScale) + bone.DefaultPosition;  	var fang = new CoordinateF (frame [3]' frame [4]' frame [5]).ComponentMultiply (bone.DefaultAnglesScale) + bone.DefaultAngles;  	anim.Frames [f].Bones.Add (new BoneAnimationFrame (bone' fpos' QuaternionF.EulerAngles (fang)));  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadAnimationGoldsource,The following statement contains a magic number: for (var f = 0; f < numframes; f++) {  	var frame = boneFrames [f];  	var fpos = new CoordinateF (frame [0]' frame [1]' frame [2]).ComponentMultiply (bone.DefaultPositionScale) + bone.DefaultPosition;  	var fang = new CoordinateF (frame [3]' frame [4]' frame [5]).ComponentMultiply (bone.DefaultAnglesScale) + bone.DefaultAngles;  	anim.Frames [f].Bones.Add (new BoneAnimationFrame (bone' fpos' QuaternionF.EulerAngles (fang)));  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadAnimationGoldsource,The following statement contains a magic number: for (var f = 0; f < numframes; f++) {  	var frame = boneFrames [f];  	var fpos = new CoordinateF (frame [0]' frame [1]' frame [2]).ComponentMultiply (bone.DefaultPositionScale) + bone.DefaultPosition;  	var fang = new CoordinateF (frame [3]' frame [4]' frame [5]).ComponentMultiply (bone.DefaultAnglesScale) + bone.DefaultAngles;  	anim.Frames [f].Bones.Add (new BoneAnimationFrame (bone' fpos' QuaternionF.EulerAngles (fang)));  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadAnimationGoldsource,The following statement contains a magic number: for (var f = 0; f < numframes; f++) {  	var frame = boneFrames [f];  	var fpos = new CoordinateF (frame [0]' frame [1]' frame [2]).ComponentMultiply (bone.DefaultPositionScale) + bone.DefaultPosition;  	var fang = new CoordinateF (frame [3]' frame [4]' frame [5]).ComponentMultiply (bone.DefaultAnglesScale) + bone.DefaultAngles;  	anim.Frames [f].Bones.Add (new BoneAnimationFrame (bone' fpos' QuaternionF.EulerAngles (fang)));  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadBone,The following statement contains a magic number: if (data.Version >= MDLVersionSource2006) {  	nameIndex = br.ReadInt32 ();  } else if (data.Version == MDLVersionGoldsource) {  	name = br.ReadFixedLengthString (Encoding.UTF8' 32);  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadBone,The following statement contains a magic number: if (data.Version == MDLVersionGoldsource) {  	name = br.ReadFixedLengthString (Encoding.UTF8' 32);  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadBone,The following statement contains a magic number: name = br.ReadFixedLengthString (Encoding.UTF8' 32);  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadBone,The following statement contains a magic number: if (data.Version >= MDLVersionSource2006) {  	var poseToBone = br.ReadIntArray (12);  	// 3x4 matrix  	var qAlignment = new QuaternionF (br.ReadCoordinateF ()' br.ReadSingle ());  	flags = br.ReadInt32 ();  	var proctype = br.ReadInt32 ();  	var procindex = br.ReadInt32 ();  	var physicsbone = br.ReadInt32 ();  	var surfacepropidx = br.ReadInt32 ();  	var contents = br.ReadInt32 ();  	br.ReadIntArray (8);  	// Unused  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadBone,The following statement contains a magic number: if (data.Version >= MDLVersionSource2006) {  	var poseToBone = br.ReadIntArray (12);  	// 3x4 matrix  	var qAlignment = new QuaternionF (br.ReadCoordinateF ()' br.ReadSingle ());  	flags = br.ReadInt32 ();  	var proctype = br.ReadInt32 ();  	var procindex = br.ReadInt32 ();  	var physicsbone = br.ReadInt32 ();  	var surfacepropidx = br.ReadInt32 ();  	var contents = br.ReadInt32 ();  	br.ReadIntArray (8);  	// Unused  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadBone,The following statement contains a magic number: br.ReadIntArray (8);  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadBodyPart,The following statement contains a magic number: if (data.Version >= MDLVersionSource2006) {  	nameIndex = br.ReadInt32 ();  	var idx = br.BaseStream.Position;  	br.BaseStream.Position = startIndex + nameIndex;  	name = br.ReadNullTerminatedString ();  	br.BaseStream.Position = idx;  } else if (data.Version == MDLVersionGoldsource) {  	name = br.ReadFixedLengthString (Encoding.UTF8' 64);  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadBodyPart,The following statement contains a magic number: if (data.Version == MDLVersionGoldsource) {  	name = br.ReadFixedLengthString (Encoding.UTF8' 64);  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadBodyPart,The following statement contains a magic number: name = br.ReadFixedLengthString (Encoding.UTF8' 64);  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadStudioModel,The following statement contains a magic number: if (data.Version >= MDLVersionSource2006) {  	var numEyeballs = br.ReadInt32 ();  	var eyeballIndex = br.ReadInt32 ();  	var vertexDataPointer = br.ReadInt32 ();  	var tangentDataPointer = br.ReadInt32 ();  	br.ReadIntArray (8);  	// Unused  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadStudioModel,The following statement contains a magic number: br.ReadIntArray (8);  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadVerticesGoldSource,The following statement contains a magic number: for (var i = 0; i < numMesh; i++) {  	var mesh = new Mesh (0);  	// GoldSource meshes don't have LODs  	var meshNumTris = br.ReadInt32 ();  	var meshTriIndex = br.ReadInt32 ();  	var meshSkinRef = br.ReadInt32 ();  	var meshNumNorms = br.ReadInt32 ();  	var meshNormIndex = br.ReadInt32 ();  	mesh.SkinRef = meshSkinRef;  	var pos = br.BaseStream.Position;  	br.BaseStream.Position = meshTriIndex;  	int sh;  	// Read all the triangle strips and fans from the mesh and convert into easy-to-render 3-point triangles  	while ((sh = br.ReadInt16 ()) != 0) {  		var list = new List<MdlProviderSequenceDataPoint> ();  		var fan = sh < 0;  		if (fan)  			sh = -sh;  		// Negative value flags a fan' otherwise it is a strip  		for (var j = 0; j < sh; j++)// Read the points in the sequence  		 {  			list.Add (new MdlProviderSequenceDataPoint {  				Vertex = br.ReadInt16 ()'  				// Vertex index in the vertices array  				Normal = br.ReadInt16 ()'  				// Normal index in the normals array  				TextureS = br.ReadInt16 ()'  				TextureT = br.ReadInt16 ()  			});  		}  		for (var j = 0; j < list.Count - 2; j++) {  			// Get the vert indices to use for the various types of strip/fan  			//                    |TRIANGLE FAN   |                       |TRIANGLE STRIP (ODD)|         |TRIANGLE STRIP (EVEN)|  			var add = fan ? new[] {  				0'  				j + 1'  				j + 2  			} : (j % 2 == 1 ? new[] {  				j + 1'  				j'  				j + 2  			} : new[] {  				j'  				j + 1'  				j + 2  			});  			foreach (var idx in add) {  				var vi = list [idx];  				var boneIndex = vertInfoData [vi.Vertex];  				// Vertinfo tells what bone the vert belongs to  				mesh.Vertices.Add (new MeshVertex (vertices [vi.Vertex]' normals [vi.Normal]' model.Bones [boneIndex]' vi.TextureS' vi.TextureT));  			}  		}  	}  	model.AddMesh (bodyPartName' modelIndex' mesh);  	br.BaseStream.Position = pos;  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadVerticesGoldSource,The following statement contains a magic number: for (var i = 0; i < numMesh; i++) {  	var mesh = new Mesh (0);  	// GoldSource meshes don't have LODs  	var meshNumTris = br.ReadInt32 ();  	var meshTriIndex = br.ReadInt32 ();  	var meshSkinRef = br.ReadInt32 ();  	var meshNumNorms = br.ReadInt32 ();  	var meshNormIndex = br.ReadInt32 ();  	mesh.SkinRef = meshSkinRef;  	var pos = br.BaseStream.Position;  	br.BaseStream.Position = meshTriIndex;  	int sh;  	// Read all the triangle strips and fans from the mesh and convert into easy-to-render 3-point triangles  	while ((sh = br.ReadInt16 ()) != 0) {  		var list = new List<MdlProviderSequenceDataPoint> ();  		var fan = sh < 0;  		if (fan)  			sh = -sh;  		// Negative value flags a fan' otherwise it is a strip  		for (var j = 0; j < sh; j++)// Read the points in the sequence  		 {  			list.Add (new MdlProviderSequenceDataPoint {  				Vertex = br.ReadInt16 ()'  				// Vertex index in the vertices array  				Normal = br.ReadInt16 ()'  				// Normal index in the normals array  				TextureS = br.ReadInt16 ()'  				TextureT = br.ReadInt16 ()  			});  		}  		for (var j = 0; j < list.Count - 2; j++) {  			// Get the vert indices to use for the various types of strip/fan  			//                    |TRIANGLE FAN   |                       |TRIANGLE STRIP (ODD)|         |TRIANGLE STRIP (EVEN)|  			var add = fan ? new[] {  				0'  				j + 1'  				j + 2  			} : (j % 2 == 1 ? new[] {  				j + 1'  				j'  				j + 2  			} : new[] {  				j'  				j + 1'  				j + 2  			});  			foreach (var idx in add) {  				var vi = list [idx];  				var boneIndex = vertInfoData [vi.Vertex];  				// Vertinfo tells what bone the vert belongs to  				mesh.Vertices.Add (new MeshVertex (vertices [vi.Vertex]' normals [vi.Normal]' model.Bones [boneIndex]' vi.TextureS' vi.TextureT));  			}  		}  	}  	model.AddMesh (bodyPartName' modelIndex' mesh);  	br.BaseStream.Position = pos;  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadVerticesGoldSource,The following statement contains a magic number: for (var i = 0; i < numMesh; i++) {  	var mesh = new Mesh (0);  	// GoldSource meshes don't have LODs  	var meshNumTris = br.ReadInt32 ();  	var meshTriIndex = br.ReadInt32 ();  	var meshSkinRef = br.ReadInt32 ();  	var meshNumNorms = br.ReadInt32 ();  	var meshNormIndex = br.ReadInt32 ();  	mesh.SkinRef = meshSkinRef;  	var pos = br.BaseStream.Position;  	br.BaseStream.Position = meshTriIndex;  	int sh;  	// Read all the triangle strips and fans from the mesh and convert into easy-to-render 3-point triangles  	while ((sh = br.ReadInt16 ()) != 0) {  		var list = new List<MdlProviderSequenceDataPoint> ();  		var fan = sh < 0;  		if (fan)  			sh = -sh;  		// Negative value flags a fan' otherwise it is a strip  		for (var j = 0; j < sh; j++)// Read the points in the sequence  		 {  			list.Add (new MdlProviderSequenceDataPoint {  				Vertex = br.ReadInt16 ()'  				// Vertex index in the vertices array  				Normal = br.ReadInt16 ()'  				// Normal index in the normals array  				TextureS = br.ReadInt16 ()'  				TextureT = br.ReadInt16 ()  			});  		}  		for (var j = 0; j < list.Count - 2; j++) {  			// Get the vert indices to use for the various types of strip/fan  			//                    |TRIANGLE FAN   |                       |TRIANGLE STRIP (ODD)|         |TRIANGLE STRIP (EVEN)|  			var add = fan ? new[] {  				0'  				j + 1'  				j + 2  			} : (j % 2 == 1 ? new[] {  				j + 1'  				j'  				j + 2  			} : new[] {  				j'  				j + 1'  				j + 2  			});  			foreach (var idx in add) {  				var vi = list [idx];  				var boneIndex = vertInfoData [vi.Vertex];  				// Vertinfo tells what bone the vert belongs to  				mesh.Vertices.Add (new MeshVertex (vertices [vi.Vertex]' normals [vi.Normal]' model.Bones [boneIndex]' vi.TextureS' vi.TextureT));  			}  		}  	}  	model.AddMesh (bodyPartName' modelIndex' mesh);  	br.BaseStream.Position = pos;  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadVerticesGoldSource,The following statement contains a magic number: for (var i = 0; i < numMesh; i++) {  	var mesh = new Mesh (0);  	// GoldSource meshes don't have LODs  	var meshNumTris = br.ReadInt32 ();  	var meshTriIndex = br.ReadInt32 ();  	var meshSkinRef = br.ReadInt32 ();  	var meshNumNorms = br.ReadInt32 ();  	var meshNormIndex = br.ReadInt32 ();  	mesh.SkinRef = meshSkinRef;  	var pos = br.BaseStream.Position;  	br.BaseStream.Position = meshTriIndex;  	int sh;  	// Read all the triangle strips and fans from the mesh and convert into easy-to-render 3-point triangles  	while ((sh = br.ReadInt16 ()) != 0) {  		var list = new List<MdlProviderSequenceDataPoint> ();  		var fan = sh < 0;  		if (fan)  			sh = -sh;  		// Negative value flags a fan' otherwise it is a strip  		for (var j = 0; j < sh; j++)// Read the points in the sequence  		 {  			list.Add (new MdlProviderSequenceDataPoint {  				Vertex = br.ReadInt16 ()'  				// Vertex index in the vertices array  				Normal = br.ReadInt16 ()'  				// Normal index in the normals array  				TextureS = br.ReadInt16 ()'  				TextureT = br.ReadInt16 ()  			});  		}  		for (var j = 0; j < list.Count - 2; j++) {  			// Get the vert indices to use for the various types of strip/fan  			//                    |TRIANGLE FAN   |                       |TRIANGLE STRIP (ODD)|         |TRIANGLE STRIP (EVEN)|  			var add = fan ? new[] {  				0'  				j + 1'  				j + 2  			} : (j % 2 == 1 ? new[] {  				j + 1'  				j'  				j + 2  			} : new[] {  				j'  				j + 1'  				j + 2  			});  			foreach (var idx in add) {  				var vi = list [idx];  				var boneIndex = vertInfoData [vi.Vertex];  				// Vertinfo tells what bone the vert belongs to  				mesh.Vertices.Add (new MeshVertex (vertices [vi.Vertex]' normals [vi.Normal]' model.Bones [boneIndex]' vi.TextureS' vi.TextureT));  			}  		}  	}  	model.AddMesh (bodyPartName' modelIndex' mesh);  	br.BaseStream.Position = pos;  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadVerticesGoldSource,The following statement contains a magic number: for (var i = 0; i < numMesh; i++) {  	var mesh = new Mesh (0);  	// GoldSource meshes don't have LODs  	var meshNumTris = br.ReadInt32 ();  	var meshTriIndex = br.ReadInt32 ();  	var meshSkinRef = br.ReadInt32 ();  	var meshNumNorms = br.ReadInt32 ();  	var meshNormIndex = br.ReadInt32 ();  	mesh.SkinRef = meshSkinRef;  	var pos = br.BaseStream.Position;  	br.BaseStream.Position = meshTriIndex;  	int sh;  	// Read all the triangle strips and fans from the mesh and convert into easy-to-render 3-point triangles  	while ((sh = br.ReadInt16 ()) != 0) {  		var list = new List<MdlProviderSequenceDataPoint> ();  		var fan = sh < 0;  		if (fan)  			sh = -sh;  		// Negative value flags a fan' otherwise it is a strip  		for (var j = 0; j < sh; j++)// Read the points in the sequence  		 {  			list.Add (new MdlProviderSequenceDataPoint {  				Vertex = br.ReadInt16 ()'  				// Vertex index in the vertices array  				Normal = br.ReadInt16 ()'  				// Normal index in the normals array  				TextureS = br.ReadInt16 ()'  				TextureT = br.ReadInt16 ()  			});  		}  		for (var j = 0; j < list.Count - 2; j++) {  			// Get the vert indices to use for the various types of strip/fan  			//                    |TRIANGLE FAN   |                       |TRIANGLE STRIP (ODD)|         |TRIANGLE STRIP (EVEN)|  			var add = fan ? new[] {  				0'  				j + 1'  				j + 2  			} : (j % 2 == 1 ? new[] {  				j + 1'  				j'  				j + 2  			} : new[] {  				j'  				j + 1'  				j + 2  			});  			foreach (var idx in add) {  				var vi = list [idx];  				var boneIndex = vertInfoData [vi.Vertex];  				// Vertinfo tells what bone the vert belongs to  				mesh.Vertices.Add (new MeshVertex (vertices [vi.Vertex]' normals [vi.Normal]' model.Bones [boneIndex]' vi.TextureS' vi.TextureT));  			}  		}  	}  	model.AddMesh (bodyPartName' modelIndex' mesh);  	br.BaseStream.Position = pos;  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadVerticesGoldSource,The following statement contains a magic number: while ((sh = br.ReadInt16 ()) != 0) {  	var list = new List<MdlProviderSequenceDataPoint> ();  	var fan = sh < 0;  	if (fan)  		sh = -sh;  	// Negative value flags a fan' otherwise it is a strip  	for (var j = 0; j < sh; j++)// Read the points in the sequence  	 {  		list.Add (new MdlProviderSequenceDataPoint {  			Vertex = br.ReadInt16 ()'  			// Vertex index in the vertices array  			Normal = br.ReadInt16 ()'  			// Normal index in the normals array  			TextureS = br.ReadInt16 ()'  			TextureT = br.ReadInt16 ()  		});  	}  	for (var j = 0; j < list.Count - 2; j++) {  		// Get the vert indices to use for the various types of strip/fan  		//                    |TRIANGLE FAN   |                       |TRIANGLE STRIP (ODD)|         |TRIANGLE STRIP (EVEN)|  		var add = fan ? new[] {  			0'  			j + 1'  			j + 2  		} : (j % 2 == 1 ? new[] {  			j + 1'  			j'  			j + 2  		} : new[] {  			j'  			j + 1'  			j + 2  		});  		foreach (var idx in add) {  			var vi = list [idx];  			var boneIndex = vertInfoData [vi.Vertex];  			// Vertinfo tells what bone the vert belongs to  			mesh.Vertices.Add (new MeshVertex (vertices [vi.Vertex]' normals [vi.Normal]' model.Bones [boneIndex]' vi.TextureS' vi.TextureT));  		}  	}  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadVerticesGoldSource,The following statement contains a magic number: while ((sh = br.ReadInt16 ()) != 0) {  	var list = new List<MdlProviderSequenceDataPoint> ();  	var fan = sh < 0;  	if (fan)  		sh = -sh;  	// Negative value flags a fan' otherwise it is a strip  	for (var j = 0; j < sh; j++)// Read the points in the sequence  	 {  		list.Add (new MdlProviderSequenceDataPoint {  			Vertex = br.ReadInt16 ()'  			// Vertex index in the vertices array  			Normal = br.ReadInt16 ()'  			// Normal index in the normals array  			TextureS = br.ReadInt16 ()'  			TextureT = br.ReadInt16 ()  		});  	}  	for (var j = 0; j < list.Count - 2; j++) {  		// Get the vert indices to use for the various types of strip/fan  		//                    |TRIANGLE FAN   |                       |TRIANGLE STRIP (ODD)|         |TRIANGLE STRIP (EVEN)|  		var add = fan ? new[] {  			0'  			j + 1'  			j + 2  		} : (j % 2 == 1 ? new[] {  			j + 1'  			j'  			j + 2  		} : new[] {  			j'  			j + 1'  			j + 2  		});  		foreach (var idx in add) {  			var vi = list [idx];  			var boneIndex = vertInfoData [vi.Vertex];  			// Vertinfo tells what bone the vert belongs to  			mesh.Vertices.Add (new MeshVertex (vertices [vi.Vertex]' normals [vi.Normal]' model.Bones [boneIndex]' vi.TextureS' vi.TextureT));  		}  	}  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadVerticesGoldSource,The following statement contains a magic number: while ((sh = br.ReadInt16 ()) != 0) {  	var list = new List<MdlProviderSequenceDataPoint> ();  	var fan = sh < 0;  	if (fan)  		sh = -sh;  	// Negative value flags a fan' otherwise it is a strip  	for (var j = 0; j < sh; j++)// Read the points in the sequence  	 {  		list.Add (new MdlProviderSequenceDataPoint {  			Vertex = br.ReadInt16 ()'  			// Vertex index in the vertices array  			Normal = br.ReadInt16 ()'  			// Normal index in the normals array  			TextureS = br.ReadInt16 ()'  			TextureT = br.ReadInt16 ()  		});  	}  	for (var j = 0; j < list.Count - 2; j++) {  		// Get the vert indices to use for the various types of strip/fan  		//                    |TRIANGLE FAN   |                       |TRIANGLE STRIP (ODD)|         |TRIANGLE STRIP (EVEN)|  		var add = fan ? new[] {  			0'  			j + 1'  			j + 2  		} : (j % 2 == 1 ? new[] {  			j + 1'  			j'  			j + 2  		} : new[] {  			j'  			j + 1'  			j + 2  		});  		foreach (var idx in add) {  			var vi = list [idx];  			var boneIndex = vertInfoData [vi.Vertex];  			// Vertinfo tells what bone the vert belongs to  			mesh.Vertices.Add (new MeshVertex (vertices [vi.Vertex]' normals [vi.Normal]' model.Bones [boneIndex]' vi.TextureS' vi.TextureT));  		}  	}  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadVerticesGoldSource,The following statement contains a magic number: while ((sh = br.ReadInt16 ()) != 0) {  	var list = new List<MdlProviderSequenceDataPoint> ();  	var fan = sh < 0;  	if (fan)  		sh = -sh;  	// Negative value flags a fan' otherwise it is a strip  	for (var j = 0; j < sh; j++)// Read the points in the sequence  	 {  		list.Add (new MdlProviderSequenceDataPoint {  			Vertex = br.ReadInt16 ()'  			// Vertex index in the vertices array  			Normal = br.ReadInt16 ()'  			// Normal index in the normals array  			TextureS = br.ReadInt16 ()'  			TextureT = br.ReadInt16 ()  		});  	}  	for (var j = 0; j < list.Count - 2; j++) {  		// Get the vert indices to use for the various types of strip/fan  		//                    |TRIANGLE FAN   |                       |TRIANGLE STRIP (ODD)|         |TRIANGLE STRIP (EVEN)|  		var add = fan ? new[] {  			0'  			j + 1'  			j + 2  		} : (j % 2 == 1 ? new[] {  			j + 1'  			j'  			j + 2  		} : new[] {  			j'  			j + 1'  			j + 2  		});  		foreach (var idx in add) {  			var vi = list [idx];  			var boneIndex = vertInfoData [vi.Vertex];  			// Vertinfo tells what bone the vert belongs to  			mesh.Vertices.Add (new MeshVertex (vertices [vi.Vertex]' normals [vi.Normal]' model.Bones [boneIndex]' vi.TextureS' vi.TextureT));  		}  	}  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadVerticesGoldSource,The following statement contains a magic number: while ((sh = br.ReadInt16 ()) != 0) {  	var list = new List<MdlProviderSequenceDataPoint> ();  	var fan = sh < 0;  	if (fan)  		sh = -sh;  	// Negative value flags a fan' otherwise it is a strip  	for (var j = 0; j < sh; j++)// Read the points in the sequence  	 {  		list.Add (new MdlProviderSequenceDataPoint {  			Vertex = br.ReadInt16 ()'  			// Vertex index in the vertices array  			Normal = br.ReadInt16 ()'  			// Normal index in the normals array  			TextureS = br.ReadInt16 ()'  			TextureT = br.ReadInt16 ()  		});  	}  	for (var j = 0; j < list.Count - 2; j++) {  		// Get the vert indices to use for the various types of strip/fan  		//                    |TRIANGLE FAN   |                       |TRIANGLE STRIP (ODD)|         |TRIANGLE STRIP (EVEN)|  		var add = fan ? new[] {  			0'  			j + 1'  			j + 2  		} : (j % 2 == 1 ? new[] {  			j + 1'  			j'  			j + 2  		} : new[] {  			j'  			j + 1'  			j + 2  		});  		foreach (var idx in add) {  			var vi = list [idx];  			var boneIndex = vertInfoData [vi.Vertex];  			// Vertinfo tells what bone the vert belongs to  			mesh.Vertices.Add (new MeshVertex (vertices [vi.Vertex]' normals [vi.Normal]' model.Bones [boneIndex]' vi.TextureS' vi.TextureT));  		}  	}  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadVerticesGoldSource,The following statement contains a magic number: for (var j = 0; j < list.Count - 2; j++) {  	// Get the vert indices to use for the various types of strip/fan  	//                    |TRIANGLE FAN   |                       |TRIANGLE STRIP (ODD)|         |TRIANGLE STRIP (EVEN)|  	var add = fan ? new[] {  		0'  		j + 1'  		j + 2  	} : (j % 2 == 1 ? new[] {  		j + 1'  		j'  		j + 2  	} : new[] {  		j'  		j + 1'  		j + 2  	});  	foreach (var idx in add) {  		var vi = list [idx];  		var boneIndex = vertInfoData [vi.Vertex];  		// Vertinfo tells what bone the vert belongs to  		mesh.Vertices.Add (new MeshVertex (vertices [vi.Vertex]' normals [vi.Normal]' model.Bones [boneIndex]' vi.TextureS' vi.TextureT));  	}  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadVerticesGoldSource,The following statement contains a magic number: for (var j = 0; j < list.Count - 2; j++) {  	// Get the vert indices to use for the various types of strip/fan  	//                    |TRIANGLE FAN   |                       |TRIANGLE STRIP (ODD)|         |TRIANGLE STRIP (EVEN)|  	var add = fan ? new[] {  		0'  		j + 1'  		j + 2  	} : (j % 2 == 1 ? new[] {  		j + 1'  		j'  		j + 2  	} : new[] {  		j'  		j + 1'  		j + 2  	});  	foreach (var idx in add) {  		var vi = list [idx];  		var boneIndex = vertInfoData [vi.Vertex];  		// Vertinfo tells what bone the vert belongs to  		mesh.Vertices.Add (new MeshVertex (vertices [vi.Vertex]' normals [vi.Normal]' model.Bones [boneIndex]' vi.TextureS' vi.TextureT));  	}  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadVerticesGoldSource,The following statement contains a magic number: for (var j = 0; j < list.Count - 2; j++) {  	// Get the vert indices to use for the various types of strip/fan  	//                    |TRIANGLE FAN   |                       |TRIANGLE STRIP (ODD)|         |TRIANGLE STRIP (EVEN)|  	var add = fan ? new[] {  		0'  		j + 1'  		j + 2  	} : (j % 2 == 1 ? new[] {  		j + 1'  		j'  		j + 2  	} : new[] {  		j'  		j + 1'  		j + 2  	});  	foreach (var idx in add) {  		var vi = list [idx];  		var boneIndex = vertInfoData [vi.Vertex];  		// Vertinfo tells what bone the vert belongs to  		mesh.Vertices.Add (new MeshVertex (vertices [vi.Vertex]' normals [vi.Normal]' model.Bones [boneIndex]' vi.TextureS' vi.TextureT));  	}  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadVerticesGoldSource,The following statement contains a magic number: for (var j = 0; j < list.Count - 2; j++) {  	// Get the vert indices to use for the various types of strip/fan  	//                    |TRIANGLE FAN   |                       |TRIANGLE STRIP (ODD)|         |TRIANGLE STRIP (EVEN)|  	var add = fan ? new[] {  		0'  		j + 1'  		j + 2  	} : (j % 2 == 1 ? new[] {  		j + 1'  		j'  		j + 2  	} : new[] {  		j'  		j + 1'  		j + 2  	});  	foreach (var idx in add) {  		var vi = list [idx];  		var boneIndex = vertInfoData [vi.Vertex];  		// Vertinfo tells what bone the vert belongs to  		mesh.Vertices.Add (new MeshVertex (vertices [vi.Vertex]' normals [vi.Normal]' model.Bones [boneIndex]' vi.TextureS' vi.TextureT));  	}  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadVerticesGoldSource,The following statement contains a magic number: for (var j = 0; j < list.Count - 2; j++) {  	// Get the vert indices to use for the various types of strip/fan  	//                    |TRIANGLE FAN   |                       |TRIANGLE STRIP (ODD)|         |TRIANGLE STRIP (EVEN)|  	var add = fan ? new[] {  		0'  		j + 1'  		j + 2  	} : (j % 2 == 1 ? new[] {  		j + 1'  		j'  		j + 2  	} : new[] {  		j'  		j + 1'  		j + 2  	});  	foreach (var idx in add) {  		var vi = list [idx];  		var boneIndex = vertInfoData [vi.Vertex];  		// Vertinfo tells what bone the vert belongs to  		mesh.Vertices.Add (new MeshVertex (vertices [vi.Vertex]' normals [vi.Normal]' model.Bones [boneIndex]' vi.TextureS' vi.TextureT));  	}  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadVerticesSource,The following statement contains a magic number: for (var i = 0; i < numMesh; i++) {  	var material = br.ReadInt32 ();  	var modelOffset = br.ReadInt32 ();  	var numVerts = br.ReadInt32 ();  	var vertexOffset = br.ReadInt32 ();  	var numFlexes = br.ReadInt32 ();  	var flexIndex = br.ReadInt32 ();  	var materialType = br.ReadInt32 ();  	var materialParam = br.ReadInt32 ();  	var meshId = br.ReadInt32 ();  	var center = br.ReadCoordinateF ();  	var modelVertexDataPointer = br.ReadInt32 ();  	var numLODVertices = br.ReadIntArray (8);  	br.ReadIntArray (8);  	// Unused  	foreach (var mm in modelData.Meshes.Where (mm => mm.BodyPart == bodyPartIndex && mm.Model == modelIndex && mm.LOD == 0 && mm.MeshIndex == meshId)) {  		var mesh = new Mesh (mm.LOD);  		foreach (var point in mm.Mesh.Points) {  			var vert = modelData.Vertices [point.VertexIndex + vertexOffset];  			var boneWeights = new List<BoneWeighting> ();  			for (var j = 0; j < vert.NumBones; j++) {  				boneWeights.Add (new BoneWeighting (model.Bones [vert.Bones [j]]' vert.BoneWeights [j]));  			}  			var mv = new MeshVertex (vert.Position' vert.Normal' boneWeights' vert.TextureS' vert.TextureT);  			mesh.Vertices.Add (mv);  		}  		model.AddMesh (groupName' modelIndex' mesh);  	}  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadVerticesSource,The following statement contains a magic number: for (var i = 0; i < numMesh; i++) {  	var material = br.ReadInt32 ();  	var modelOffset = br.ReadInt32 ();  	var numVerts = br.ReadInt32 ();  	var vertexOffset = br.ReadInt32 ();  	var numFlexes = br.ReadInt32 ();  	var flexIndex = br.ReadInt32 ();  	var materialType = br.ReadInt32 ();  	var materialParam = br.ReadInt32 ();  	var meshId = br.ReadInt32 ();  	var center = br.ReadCoordinateF ();  	var modelVertexDataPointer = br.ReadInt32 ();  	var numLODVertices = br.ReadIntArray (8);  	br.ReadIntArray (8);  	// Unused  	foreach (var mm in modelData.Meshes.Where (mm => mm.BodyPart == bodyPartIndex && mm.Model == modelIndex && mm.LOD == 0 && mm.MeshIndex == meshId)) {  		var mesh = new Mesh (mm.LOD);  		foreach (var point in mm.Mesh.Points) {  			var vert = modelData.Vertices [point.VertexIndex + vertexOffset];  			var boneWeights = new List<BoneWeighting> ();  			for (var j = 0; j < vert.NumBones; j++) {  				boneWeights.Add (new BoneWeighting (model.Bones [vert.Bones [j]]' vert.BoneWeights [j]));  			}  			var mv = new MeshVertex (vert.Position' vert.Normal' boneWeights' vert.TextureS' vert.TextureT);  			mesh.Vertices.Add (mv);  		}  		model.AddMesh (groupName' modelIndex' mesh);  	}  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,ReadVerticesSource,The following statement contains a magic number: br.ReadIntArray (8);  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceMeshData,The following statement contains a magic number: using (var fs = vvd.Open ()) {  	using (var vbr = new BinaryReader (fs)) {  		var magicString = vbr.ReadFixedLengthString (Encoding.UTF8' 4);  		if (magicString != MagicStringIDSV) {  			throw new ProviderException ("Bad magic number for vertex file. Expected IDSV' got: " + magicString);  		}  		var version = vbr.ReadInt32 ();  		if (version != VVDVersionSource) {  			throw new ProviderException ("Bad version number for vertex file. Expected 4' got: " + version);  		}  		long checksum = vbr.ReadInt32 ();  		var numLods = vbr.ReadInt32 ();  		var numLodVertices = vbr.ReadIntArray (8);  		var numFixups = vbr.ReadInt32 ();  		var fixupTableStart = vbr.ReadInt32 ();  		var vertexDataStart = vbr.ReadInt32 ();  		var tangentDataStart = vbr.ReadInt32 ();  		vbr.BaseStream.Position = vertexDataStart;  		// Read all the vertices from LOD 0 (this should contain the vertices for all LODs)  		for (var i = 0; i < numLodVertices [0]; i++) {  			var boneWeights = vbr.ReadSingleArray (3);  			var bones = vbr.ReadBytes (3);  			var numBones = vbr.ReadByte ();  			var position = vbr.ReadCoordinateF ();  			var normal = vbr.ReadCoordinateF ();  			var textureS = vbr.ReadSingle ();  			var textureT = vbr.ReadSingle ();  			vertices.Add (new VVDPoint (boneWeights' bones' numBones' position' normal' textureS' textureT));  		}  		// Apply the fixup table' this re-orders the indices in reverse LOD order for performance reasons  		if (numFixups > 0) {  			vbr.BaseStream.Position = fixupTableStart;  			var newVerts = new List<VVDPoint> ();  			for (var i = 0; i < numFixups; i++) {  				var fuLod = vbr.ReadInt32 ();  				var fuvertid = vbr.ReadInt32 ();  				var funumverts = vbr.ReadInt32 ();  				newVerts.AddRange (vertices.GetRange (fuvertid' funumverts));  			}  			vertices.Clear ();  			vertices.AddRange (newVerts);  		}  		modelData.Vertices = vertices;  	}  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceMeshData,The following statement contains a magic number: using (var fs = vvd.Open ()) {  	using (var vbr = new BinaryReader (fs)) {  		var magicString = vbr.ReadFixedLengthString (Encoding.UTF8' 4);  		if (magicString != MagicStringIDSV) {  			throw new ProviderException ("Bad magic number for vertex file. Expected IDSV' got: " + magicString);  		}  		var version = vbr.ReadInt32 ();  		if (version != VVDVersionSource) {  			throw new ProviderException ("Bad version number for vertex file. Expected 4' got: " + version);  		}  		long checksum = vbr.ReadInt32 ();  		var numLods = vbr.ReadInt32 ();  		var numLodVertices = vbr.ReadIntArray (8);  		var numFixups = vbr.ReadInt32 ();  		var fixupTableStart = vbr.ReadInt32 ();  		var vertexDataStart = vbr.ReadInt32 ();  		var tangentDataStart = vbr.ReadInt32 ();  		vbr.BaseStream.Position = vertexDataStart;  		// Read all the vertices from LOD 0 (this should contain the vertices for all LODs)  		for (var i = 0; i < numLodVertices [0]; i++) {  			var boneWeights = vbr.ReadSingleArray (3);  			var bones = vbr.ReadBytes (3);  			var numBones = vbr.ReadByte ();  			var position = vbr.ReadCoordinateF ();  			var normal = vbr.ReadCoordinateF ();  			var textureS = vbr.ReadSingle ();  			var textureT = vbr.ReadSingle ();  			vertices.Add (new VVDPoint (boneWeights' bones' numBones' position' normal' textureS' textureT));  		}  		// Apply the fixup table' this re-orders the indices in reverse LOD order for performance reasons  		if (numFixups > 0) {  			vbr.BaseStream.Position = fixupTableStart;  			var newVerts = new List<VVDPoint> ();  			for (var i = 0; i < numFixups; i++) {  				var fuLod = vbr.ReadInt32 ();  				var fuvertid = vbr.ReadInt32 ();  				var funumverts = vbr.ReadInt32 ();  				newVerts.AddRange (vertices.GetRange (fuvertid' funumverts));  			}  			vertices.Clear ();  			vertices.AddRange (newVerts);  		}  		modelData.Vertices = vertices;  	}  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceMeshData,The following statement contains a magic number: using (var fs = vvd.Open ()) {  	using (var vbr = new BinaryReader (fs)) {  		var magicString = vbr.ReadFixedLengthString (Encoding.UTF8' 4);  		if (magicString != MagicStringIDSV) {  			throw new ProviderException ("Bad magic number for vertex file. Expected IDSV' got: " + magicString);  		}  		var version = vbr.ReadInt32 ();  		if (version != VVDVersionSource) {  			throw new ProviderException ("Bad version number for vertex file. Expected 4' got: " + version);  		}  		long checksum = vbr.ReadInt32 ();  		var numLods = vbr.ReadInt32 ();  		var numLodVertices = vbr.ReadIntArray (8);  		var numFixups = vbr.ReadInt32 ();  		var fixupTableStart = vbr.ReadInt32 ();  		var vertexDataStart = vbr.ReadInt32 ();  		var tangentDataStart = vbr.ReadInt32 ();  		vbr.BaseStream.Position = vertexDataStart;  		// Read all the vertices from LOD 0 (this should contain the vertices for all LODs)  		for (var i = 0; i < numLodVertices [0]; i++) {  			var boneWeights = vbr.ReadSingleArray (3);  			var bones = vbr.ReadBytes (3);  			var numBones = vbr.ReadByte ();  			var position = vbr.ReadCoordinateF ();  			var normal = vbr.ReadCoordinateF ();  			var textureS = vbr.ReadSingle ();  			var textureT = vbr.ReadSingle ();  			vertices.Add (new VVDPoint (boneWeights' bones' numBones' position' normal' textureS' textureT));  		}  		// Apply the fixup table' this re-orders the indices in reverse LOD order for performance reasons  		if (numFixups > 0) {  			vbr.BaseStream.Position = fixupTableStart;  			var newVerts = new List<VVDPoint> ();  			for (var i = 0; i < numFixups; i++) {  				var fuLod = vbr.ReadInt32 ();  				var fuvertid = vbr.ReadInt32 ();  				var funumverts = vbr.ReadInt32 ();  				newVerts.AddRange (vertices.GetRange (fuvertid' funumverts));  			}  			vertices.Clear ();  			vertices.AddRange (newVerts);  		}  		modelData.Vertices = vertices;  	}  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceMeshData,The following statement contains a magic number: using (var fs = vvd.Open ()) {  	using (var vbr = new BinaryReader (fs)) {  		var magicString = vbr.ReadFixedLengthString (Encoding.UTF8' 4);  		if (magicString != MagicStringIDSV) {  			throw new ProviderException ("Bad magic number for vertex file. Expected IDSV' got: " + magicString);  		}  		var version = vbr.ReadInt32 ();  		if (version != VVDVersionSource) {  			throw new ProviderException ("Bad version number for vertex file. Expected 4' got: " + version);  		}  		long checksum = vbr.ReadInt32 ();  		var numLods = vbr.ReadInt32 ();  		var numLodVertices = vbr.ReadIntArray (8);  		var numFixups = vbr.ReadInt32 ();  		var fixupTableStart = vbr.ReadInt32 ();  		var vertexDataStart = vbr.ReadInt32 ();  		var tangentDataStart = vbr.ReadInt32 ();  		vbr.BaseStream.Position = vertexDataStart;  		// Read all the vertices from LOD 0 (this should contain the vertices for all LODs)  		for (var i = 0; i < numLodVertices [0]; i++) {  			var boneWeights = vbr.ReadSingleArray (3);  			var bones = vbr.ReadBytes (3);  			var numBones = vbr.ReadByte ();  			var position = vbr.ReadCoordinateF ();  			var normal = vbr.ReadCoordinateF ();  			var textureS = vbr.ReadSingle ();  			var textureT = vbr.ReadSingle ();  			vertices.Add (new VVDPoint (boneWeights' bones' numBones' position' normal' textureS' textureT));  		}  		// Apply the fixup table' this re-orders the indices in reverse LOD order for performance reasons  		if (numFixups > 0) {  			vbr.BaseStream.Position = fixupTableStart;  			var newVerts = new List<VVDPoint> ();  			for (var i = 0; i < numFixups; i++) {  				var fuLod = vbr.ReadInt32 ();  				var fuvertid = vbr.ReadInt32 ();  				var funumverts = vbr.ReadInt32 ();  				newVerts.AddRange (vertices.GetRange (fuvertid' funumverts));  			}  			vertices.Clear ();  			vertices.AddRange (newVerts);  		}  		modelData.Vertices = vertices;  	}  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceMeshData,The following statement contains a magic number: using (var vbr = new BinaryReader (fs)) {  	var magicString = vbr.ReadFixedLengthString (Encoding.UTF8' 4);  	if (magicString != MagicStringIDSV) {  		throw new ProviderException ("Bad magic number for vertex file. Expected IDSV' got: " + magicString);  	}  	var version = vbr.ReadInt32 ();  	if (version != VVDVersionSource) {  		throw new ProviderException ("Bad version number for vertex file. Expected 4' got: " + version);  	}  	long checksum = vbr.ReadInt32 ();  	var numLods = vbr.ReadInt32 ();  	var numLodVertices = vbr.ReadIntArray (8);  	var numFixups = vbr.ReadInt32 ();  	var fixupTableStart = vbr.ReadInt32 ();  	var vertexDataStart = vbr.ReadInt32 ();  	var tangentDataStart = vbr.ReadInt32 ();  	vbr.BaseStream.Position = vertexDataStart;  	// Read all the vertices from LOD 0 (this should contain the vertices for all LODs)  	for (var i = 0; i < numLodVertices [0]; i++) {  		var boneWeights = vbr.ReadSingleArray (3);  		var bones = vbr.ReadBytes (3);  		var numBones = vbr.ReadByte ();  		var position = vbr.ReadCoordinateF ();  		var normal = vbr.ReadCoordinateF ();  		var textureS = vbr.ReadSingle ();  		var textureT = vbr.ReadSingle ();  		vertices.Add (new VVDPoint (boneWeights' bones' numBones' position' normal' textureS' textureT));  	}  	// Apply the fixup table' this re-orders the indices in reverse LOD order for performance reasons  	if (numFixups > 0) {  		vbr.BaseStream.Position = fixupTableStart;  		var newVerts = new List<VVDPoint> ();  		for (var i = 0; i < numFixups; i++) {  			var fuLod = vbr.ReadInt32 ();  			var fuvertid = vbr.ReadInt32 ();  			var funumverts = vbr.ReadInt32 ();  			newVerts.AddRange (vertices.GetRange (fuvertid' funumverts));  		}  		vertices.Clear ();  		vertices.AddRange (newVerts);  	}  	modelData.Vertices = vertices;  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceMeshData,The following statement contains a magic number: using (var vbr = new BinaryReader (fs)) {  	var magicString = vbr.ReadFixedLengthString (Encoding.UTF8' 4);  	if (magicString != MagicStringIDSV) {  		throw new ProviderException ("Bad magic number for vertex file. Expected IDSV' got: " + magicString);  	}  	var version = vbr.ReadInt32 ();  	if (version != VVDVersionSource) {  		throw new ProviderException ("Bad version number for vertex file. Expected 4' got: " + version);  	}  	long checksum = vbr.ReadInt32 ();  	var numLods = vbr.ReadInt32 ();  	var numLodVertices = vbr.ReadIntArray (8);  	var numFixups = vbr.ReadInt32 ();  	var fixupTableStart = vbr.ReadInt32 ();  	var vertexDataStart = vbr.ReadInt32 ();  	var tangentDataStart = vbr.ReadInt32 ();  	vbr.BaseStream.Position = vertexDataStart;  	// Read all the vertices from LOD 0 (this should contain the vertices for all LODs)  	for (var i = 0; i < numLodVertices [0]; i++) {  		var boneWeights = vbr.ReadSingleArray (3);  		var bones = vbr.ReadBytes (3);  		var numBones = vbr.ReadByte ();  		var position = vbr.ReadCoordinateF ();  		var normal = vbr.ReadCoordinateF ();  		var textureS = vbr.ReadSingle ();  		var textureT = vbr.ReadSingle ();  		vertices.Add (new VVDPoint (boneWeights' bones' numBones' position' normal' textureS' textureT));  	}  	// Apply the fixup table' this re-orders the indices in reverse LOD order for performance reasons  	if (numFixups > 0) {  		vbr.BaseStream.Position = fixupTableStart;  		var newVerts = new List<VVDPoint> ();  		for (var i = 0; i < numFixups; i++) {  			var fuLod = vbr.ReadInt32 ();  			var fuvertid = vbr.ReadInt32 ();  			var funumverts = vbr.ReadInt32 ();  			newVerts.AddRange (vertices.GetRange (fuvertid' funumverts));  		}  		vertices.Clear ();  		vertices.AddRange (newVerts);  	}  	modelData.Vertices = vertices;  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceMeshData,The following statement contains a magic number: using (var vbr = new BinaryReader (fs)) {  	var magicString = vbr.ReadFixedLengthString (Encoding.UTF8' 4);  	if (magicString != MagicStringIDSV) {  		throw new ProviderException ("Bad magic number for vertex file. Expected IDSV' got: " + magicString);  	}  	var version = vbr.ReadInt32 ();  	if (version != VVDVersionSource) {  		throw new ProviderException ("Bad version number for vertex file. Expected 4' got: " + version);  	}  	long checksum = vbr.ReadInt32 ();  	var numLods = vbr.ReadInt32 ();  	var numLodVertices = vbr.ReadIntArray (8);  	var numFixups = vbr.ReadInt32 ();  	var fixupTableStart = vbr.ReadInt32 ();  	var vertexDataStart = vbr.ReadInt32 ();  	var tangentDataStart = vbr.ReadInt32 ();  	vbr.BaseStream.Position = vertexDataStart;  	// Read all the vertices from LOD 0 (this should contain the vertices for all LODs)  	for (var i = 0; i < numLodVertices [0]; i++) {  		var boneWeights = vbr.ReadSingleArray (3);  		var bones = vbr.ReadBytes (3);  		var numBones = vbr.ReadByte ();  		var position = vbr.ReadCoordinateF ();  		var normal = vbr.ReadCoordinateF ();  		var textureS = vbr.ReadSingle ();  		var textureT = vbr.ReadSingle ();  		vertices.Add (new VVDPoint (boneWeights' bones' numBones' position' normal' textureS' textureT));  	}  	// Apply the fixup table' this re-orders the indices in reverse LOD order for performance reasons  	if (numFixups > 0) {  		vbr.BaseStream.Position = fixupTableStart;  		var newVerts = new List<VVDPoint> ();  		for (var i = 0; i < numFixups; i++) {  			var fuLod = vbr.ReadInt32 ();  			var fuvertid = vbr.ReadInt32 ();  			var funumverts = vbr.ReadInt32 ();  			newVerts.AddRange (vertices.GetRange (fuvertid' funumverts));  		}  		vertices.Clear ();  		vertices.AddRange (newVerts);  	}  	modelData.Vertices = vertices;  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceMeshData,The following statement contains a magic number: using (var vbr = new BinaryReader (fs)) {  	var magicString = vbr.ReadFixedLengthString (Encoding.UTF8' 4);  	if (magicString != MagicStringIDSV) {  		throw new ProviderException ("Bad magic number for vertex file. Expected IDSV' got: " + magicString);  	}  	var version = vbr.ReadInt32 ();  	if (version != VVDVersionSource) {  		throw new ProviderException ("Bad version number for vertex file. Expected 4' got: " + version);  	}  	long checksum = vbr.ReadInt32 ();  	var numLods = vbr.ReadInt32 ();  	var numLodVertices = vbr.ReadIntArray (8);  	var numFixups = vbr.ReadInt32 ();  	var fixupTableStart = vbr.ReadInt32 ();  	var vertexDataStart = vbr.ReadInt32 ();  	var tangentDataStart = vbr.ReadInt32 ();  	vbr.BaseStream.Position = vertexDataStart;  	// Read all the vertices from LOD 0 (this should contain the vertices for all LODs)  	for (var i = 0; i < numLodVertices [0]; i++) {  		var boneWeights = vbr.ReadSingleArray (3);  		var bones = vbr.ReadBytes (3);  		var numBones = vbr.ReadByte ();  		var position = vbr.ReadCoordinateF ();  		var normal = vbr.ReadCoordinateF ();  		var textureS = vbr.ReadSingle ();  		var textureT = vbr.ReadSingle ();  		vertices.Add (new VVDPoint (boneWeights' bones' numBones' position' normal' textureS' textureT));  	}  	// Apply the fixup table' this re-orders the indices in reverse LOD order for performance reasons  	if (numFixups > 0) {  		vbr.BaseStream.Position = fixupTableStart;  		var newVerts = new List<VVDPoint> ();  		for (var i = 0; i < numFixups; i++) {  			var fuLod = vbr.ReadInt32 ();  			var fuvertid = vbr.ReadInt32 ();  			var funumverts = vbr.ReadInt32 ();  			newVerts.AddRange (vertices.GetRange (fuvertid' funumverts));  		}  		vertices.Clear ();  		vertices.AddRange (newVerts);  	}  	modelData.Vertices = vertices;  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceMeshData,The following statement contains a magic number: for (var i = 0; i < numLodVertices [0]; i++) {  	var boneWeights = vbr.ReadSingleArray (3);  	var bones = vbr.ReadBytes (3);  	var numBones = vbr.ReadByte ();  	var position = vbr.ReadCoordinateF ();  	var normal = vbr.ReadCoordinateF ();  	var textureS = vbr.ReadSingle ();  	var textureT = vbr.ReadSingle ();  	vertices.Add (new VVDPoint (boneWeights' bones' numBones' position' normal' textureS' textureT));  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceMeshData,The following statement contains a magic number: for (var i = 0; i < numLodVertices [0]; i++) {  	var boneWeights = vbr.ReadSingleArray (3);  	var bones = vbr.ReadBytes (3);  	var numBones = vbr.ReadByte ();  	var position = vbr.ReadCoordinateF ();  	var normal = vbr.ReadCoordinateF ();  	var textureS = vbr.ReadSingle ();  	var textureT = vbr.ReadSingle ();  	vertices.Add (new VVDPoint (boneWeights' bones' numBones' position' normal' textureS' textureT));  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceMeshData,The following statement contains a magic number: using (var fs = vtx.Open ()) {  	using (var vbr = new BinaryReader (fs)) {  		var version = vbr.ReadInt32 ();  		// 7  		if (version != VTXVersionSource) {  			throw new ProviderException ("Bad version number for vertex file. Expected 7' got: " + version);  		}  		var vertCacheSize = vbr.ReadInt32 ();  		var maxBonesPerStrip = vbr.ReadUInt16 ();  		var maxBonesPerTri = vbr.ReadUInt16 ();  		var maxBonesPerVert = vbr.ReadInt32 ();  		long checksum = vbr.ReadInt32 ();  		var numLods = vbr.ReadInt32 ();  		var materialReplacementListOffset = vbr.ReadInt32 ();  		var numBodyParts = vbr.ReadInt32 ();  		var bodyPartOffset = vbr.ReadInt32 ();  		// BODY PARTS  		long posbp = bodyPartOffset;  		for (var bp = 0; bp < numBodyParts; bp++) {  			vbr.BaseStream.Position = posbp;  			var numModels = vbr.ReadInt32 ();  			var modelOffset = vbr.ReadInt32 ();  			var posmdl = posbp + modelOffset;  			posbp = vbr.BaseStream.Position;  			// MODELS  			for (var mdl = 0; mdl < numModels; mdl++) {  				vbr.BaseStream.Position = posmdl;  				var numLod = vbr.ReadInt32 ();  				var lodOffset = vbr.ReadInt32 ();  				var poslod = posmdl + lodOffset;  				posmdl = vbr.BaseStream.Position;  				// LODS  				for (var lod = 0; lod < numLod; lod++) {  					vbr.BaseStream.Position = poslod;  					var meshNum = vbr.ReadInt32 ();  					var meshOffset = vbr.ReadInt32 ();  					var switchPoint = vbr.ReadSingle ();  					var posmesh = poslod + meshOffset;  					poslod = vbr.BaseStream.Position;  					// MESHES  					for (var msh = 0; msh < meshNum; msh++) {  						vbr.BaseStream.Position = posmesh;  						var sgNum = vbr.ReadInt32 ();  						var sgOffset = vbr.ReadInt32 ();  						var meshFlags = vbr.ReadByte ();  						var possg = posmesh + sgOffset;  						posmesh = vbr.BaseStream.Position;  						var mesh = new VTXModel (bp' mdl' lod' msh);  						// STRIP GROUPS  						for (var sg = 0; sg < sgNum; sg++) {  							vbr.BaseStream.Position = possg;  							var vertNum = vbr.ReadInt32 ();  							var vertOffset = vbr.ReadInt32 ();  							var indexNum = vbr.ReadInt32 ();  							var indexOffset = vbr.ReadInt32 ();  							var stripNum = vbr.ReadInt32 ();  							var stripOffset = vbr.ReadInt32 ();  							var sgFlags = vbr.ReadByte ();  							// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  							var posvert = possg + vertOffset;  							var posidx = possg + indexOffset;  							var posstrip = possg + stripOffset;  							possg = vbr.BaseStream.Position;  							var vertinfo = new List<VTXPoint> ();  							vbr.BaseStream.Position = posvert;  							for (var vert = 0; vert < vertNum; vert++) {  								var boneWeightIndices = vbr.ReadBytes (3);  								var numBones = vbr.ReadByte ();  								var meshVertex = vbr.ReadInt16 ();  								var boneIDs = vbr.ReadBytes (3);  								vertinfo.Add (new VTXPoint (boneWeightIndices' numBones' meshVertex' boneIDs));  							}  							vbr.BaseStream.Position = posidx;  							var indices = vbr.ReadShortArray (indexNum);  							// The strips hold info about whether this is a triangle strip or just a list  							vbr.BaseStream.Position = posstrip;  							for (var st = 0; st < stripNum; st++) {  								var numStIndices = vbr.ReadInt32 ();  								var stIndexOffset = vbr.ReadInt32 ();  								var numStVerts = vbr.ReadInt32 ();  								var stVertOffset = vbr.ReadInt32 ();  								var numStBones = vbr.ReadInt16 ();  								var stFlags = vbr.ReadByte ();  								var numStBoneStateChanges = vbr.ReadInt32 ();  								var stBoneStateChangeOffset = vbr.ReadInt32 ();  								// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  								if ((stFlags & VTXStripGroupTriListFlag) > 0) {  									for (var j = stIndexOffset; j < stIndexOffset + numStIndices; j++) {  										mesh.Mesh.Points.Add (vertinfo [indices [j]]);  										//mesh.Vertices.Add(vertices[vertinfo[indices[j]]]);  									}  								} else if ((stFlags & VTXStripGroupTriStripFlag) > 0) {  									for (var j = stIndexOffset; j < stIndexOffset + numStIndices - 2; j++) {  										var add = j % 2 == 1 ? new[] {  											j + 1'  											j'  											j + 2  										} : new[] {  											j'  											j + 1'  											j + 2  										};  										foreach (var idx in add) {  											mesh.Mesh.Points.Add (vertinfo [indices [idx]]);  											//mesh.Vertices.Add(vertices[vertinfo[indices[idx]]]);  										}  									}  								}  							}  							// Strips  						}  						// Strip Groups  						modelData.Meshes.Add (mesh);  					}  					// Meshes  				}  				// LODs  			}  			// Models  		}  		// Body Parts  	}  	// using (var br)  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceMeshData,The following statement contains a magic number: using (var fs = vtx.Open ()) {  	using (var vbr = new BinaryReader (fs)) {  		var version = vbr.ReadInt32 ();  		// 7  		if (version != VTXVersionSource) {  			throw new ProviderException ("Bad version number for vertex file. Expected 7' got: " + version);  		}  		var vertCacheSize = vbr.ReadInt32 ();  		var maxBonesPerStrip = vbr.ReadUInt16 ();  		var maxBonesPerTri = vbr.ReadUInt16 ();  		var maxBonesPerVert = vbr.ReadInt32 ();  		long checksum = vbr.ReadInt32 ();  		var numLods = vbr.ReadInt32 ();  		var materialReplacementListOffset = vbr.ReadInt32 ();  		var numBodyParts = vbr.ReadInt32 ();  		var bodyPartOffset = vbr.ReadInt32 ();  		// BODY PARTS  		long posbp = bodyPartOffset;  		for (var bp = 0; bp < numBodyParts; bp++) {  			vbr.BaseStream.Position = posbp;  			var numModels = vbr.ReadInt32 ();  			var modelOffset = vbr.ReadInt32 ();  			var posmdl = posbp + modelOffset;  			posbp = vbr.BaseStream.Position;  			// MODELS  			for (var mdl = 0; mdl < numModels; mdl++) {  				vbr.BaseStream.Position = posmdl;  				var numLod = vbr.ReadInt32 ();  				var lodOffset = vbr.ReadInt32 ();  				var poslod = posmdl + lodOffset;  				posmdl = vbr.BaseStream.Position;  				// LODS  				for (var lod = 0; lod < numLod; lod++) {  					vbr.BaseStream.Position = poslod;  					var meshNum = vbr.ReadInt32 ();  					var meshOffset = vbr.ReadInt32 ();  					var switchPoint = vbr.ReadSingle ();  					var posmesh = poslod + meshOffset;  					poslod = vbr.BaseStream.Position;  					// MESHES  					for (var msh = 0; msh < meshNum; msh++) {  						vbr.BaseStream.Position = posmesh;  						var sgNum = vbr.ReadInt32 ();  						var sgOffset = vbr.ReadInt32 ();  						var meshFlags = vbr.ReadByte ();  						var possg = posmesh + sgOffset;  						posmesh = vbr.BaseStream.Position;  						var mesh = new VTXModel (bp' mdl' lod' msh);  						// STRIP GROUPS  						for (var sg = 0; sg < sgNum; sg++) {  							vbr.BaseStream.Position = possg;  							var vertNum = vbr.ReadInt32 ();  							var vertOffset = vbr.ReadInt32 ();  							var indexNum = vbr.ReadInt32 ();  							var indexOffset = vbr.ReadInt32 ();  							var stripNum = vbr.ReadInt32 ();  							var stripOffset = vbr.ReadInt32 ();  							var sgFlags = vbr.ReadByte ();  							// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  							var posvert = possg + vertOffset;  							var posidx = possg + indexOffset;  							var posstrip = possg + stripOffset;  							possg = vbr.BaseStream.Position;  							var vertinfo = new List<VTXPoint> ();  							vbr.BaseStream.Position = posvert;  							for (var vert = 0; vert < vertNum; vert++) {  								var boneWeightIndices = vbr.ReadBytes (3);  								var numBones = vbr.ReadByte ();  								var meshVertex = vbr.ReadInt16 ();  								var boneIDs = vbr.ReadBytes (3);  								vertinfo.Add (new VTXPoint (boneWeightIndices' numBones' meshVertex' boneIDs));  							}  							vbr.BaseStream.Position = posidx;  							var indices = vbr.ReadShortArray (indexNum);  							// The strips hold info about whether this is a triangle strip or just a list  							vbr.BaseStream.Position = posstrip;  							for (var st = 0; st < stripNum; st++) {  								var numStIndices = vbr.ReadInt32 ();  								var stIndexOffset = vbr.ReadInt32 ();  								var numStVerts = vbr.ReadInt32 ();  								var stVertOffset = vbr.ReadInt32 ();  								var numStBones = vbr.ReadInt16 ();  								var stFlags = vbr.ReadByte ();  								var numStBoneStateChanges = vbr.ReadInt32 ();  								var stBoneStateChangeOffset = vbr.ReadInt32 ();  								// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  								if ((stFlags & VTXStripGroupTriListFlag) > 0) {  									for (var j = stIndexOffset; j < stIndexOffset + numStIndices; j++) {  										mesh.Mesh.Points.Add (vertinfo [indices [j]]);  										//mesh.Vertices.Add(vertices[vertinfo[indices[j]]]);  									}  								} else if ((stFlags & VTXStripGroupTriStripFlag) > 0) {  									for (var j = stIndexOffset; j < stIndexOffset + numStIndices - 2; j++) {  										var add = j % 2 == 1 ? new[] {  											j + 1'  											j'  											j + 2  										} : new[] {  											j'  											j + 1'  											j + 2  										};  										foreach (var idx in add) {  											mesh.Mesh.Points.Add (vertinfo [indices [idx]]);  											//mesh.Vertices.Add(vertices[vertinfo[indices[idx]]]);  										}  									}  								}  							}  							// Strips  						}  						// Strip Groups  						modelData.Meshes.Add (mesh);  					}  					// Meshes  				}  				// LODs  			}  			// Models  		}  		// Body Parts  	}  	// using (var br)  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceMeshData,The following statement contains a magic number: using (var fs = vtx.Open ()) {  	using (var vbr = new BinaryReader (fs)) {  		var version = vbr.ReadInt32 ();  		// 7  		if (version != VTXVersionSource) {  			throw new ProviderException ("Bad version number for vertex file. Expected 7' got: " + version);  		}  		var vertCacheSize = vbr.ReadInt32 ();  		var maxBonesPerStrip = vbr.ReadUInt16 ();  		var maxBonesPerTri = vbr.ReadUInt16 ();  		var maxBonesPerVert = vbr.ReadInt32 ();  		long checksum = vbr.ReadInt32 ();  		var numLods = vbr.ReadInt32 ();  		var materialReplacementListOffset = vbr.ReadInt32 ();  		var numBodyParts = vbr.ReadInt32 ();  		var bodyPartOffset = vbr.ReadInt32 ();  		// BODY PARTS  		long posbp = bodyPartOffset;  		for (var bp = 0; bp < numBodyParts; bp++) {  			vbr.BaseStream.Position = posbp;  			var numModels = vbr.ReadInt32 ();  			var modelOffset = vbr.ReadInt32 ();  			var posmdl = posbp + modelOffset;  			posbp = vbr.BaseStream.Position;  			// MODELS  			for (var mdl = 0; mdl < numModels; mdl++) {  				vbr.BaseStream.Position = posmdl;  				var numLod = vbr.ReadInt32 ();  				var lodOffset = vbr.ReadInt32 ();  				var poslod = posmdl + lodOffset;  				posmdl = vbr.BaseStream.Position;  				// LODS  				for (var lod = 0; lod < numLod; lod++) {  					vbr.BaseStream.Position = poslod;  					var meshNum = vbr.ReadInt32 ();  					var meshOffset = vbr.ReadInt32 ();  					var switchPoint = vbr.ReadSingle ();  					var posmesh = poslod + meshOffset;  					poslod = vbr.BaseStream.Position;  					// MESHES  					for (var msh = 0; msh < meshNum; msh++) {  						vbr.BaseStream.Position = posmesh;  						var sgNum = vbr.ReadInt32 ();  						var sgOffset = vbr.ReadInt32 ();  						var meshFlags = vbr.ReadByte ();  						var possg = posmesh + sgOffset;  						posmesh = vbr.BaseStream.Position;  						var mesh = new VTXModel (bp' mdl' lod' msh);  						// STRIP GROUPS  						for (var sg = 0; sg < sgNum; sg++) {  							vbr.BaseStream.Position = possg;  							var vertNum = vbr.ReadInt32 ();  							var vertOffset = vbr.ReadInt32 ();  							var indexNum = vbr.ReadInt32 ();  							var indexOffset = vbr.ReadInt32 ();  							var stripNum = vbr.ReadInt32 ();  							var stripOffset = vbr.ReadInt32 ();  							var sgFlags = vbr.ReadByte ();  							// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  							var posvert = possg + vertOffset;  							var posidx = possg + indexOffset;  							var posstrip = possg + stripOffset;  							possg = vbr.BaseStream.Position;  							var vertinfo = new List<VTXPoint> ();  							vbr.BaseStream.Position = posvert;  							for (var vert = 0; vert < vertNum; vert++) {  								var boneWeightIndices = vbr.ReadBytes (3);  								var numBones = vbr.ReadByte ();  								var meshVertex = vbr.ReadInt16 ();  								var boneIDs = vbr.ReadBytes (3);  								vertinfo.Add (new VTXPoint (boneWeightIndices' numBones' meshVertex' boneIDs));  							}  							vbr.BaseStream.Position = posidx;  							var indices = vbr.ReadShortArray (indexNum);  							// The strips hold info about whether this is a triangle strip or just a list  							vbr.BaseStream.Position = posstrip;  							for (var st = 0; st < stripNum; st++) {  								var numStIndices = vbr.ReadInt32 ();  								var stIndexOffset = vbr.ReadInt32 ();  								var numStVerts = vbr.ReadInt32 ();  								var stVertOffset = vbr.ReadInt32 ();  								var numStBones = vbr.ReadInt16 ();  								var stFlags = vbr.ReadByte ();  								var numStBoneStateChanges = vbr.ReadInt32 ();  								var stBoneStateChangeOffset = vbr.ReadInt32 ();  								// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  								if ((stFlags & VTXStripGroupTriListFlag) > 0) {  									for (var j = stIndexOffset; j < stIndexOffset + numStIndices; j++) {  										mesh.Mesh.Points.Add (vertinfo [indices [j]]);  										//mesh.Vertices.Add(vertices[vertinfo[indices[j]]]);  									}  								} else if ((stFlags & VTXStripGroupTriStripFlag) > 0) {  									for (var j = stIndexOffset; j < stIndexOffset + numStIndices - 2; j++) {  										var add = j % 2 == 1 ? new[] {  											j + 1'  											j'  											j + 2  										} : new[] {  											j'  											j + 1'  											j + 2  										};  										foreach (var idx in add) {  											mesh.Mesh.Points.Add (vertinfo [indices [idx]]);  											//mesh.Vertices.Add(vertices[vertinfo[indices[idx]]]);  										}  									}  								}  							}  							// Strips  						}  						// Strip Groups  						modelData.Meshes.Add (mesh);  					}  					// Meshes  				}  				// LODs  			}  			// Models  		}  		// Body Parts  	}  	// using (var br)  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceMeshData,The following statement contains a magic number: using (var fs = vtx.Open ()) {  	using (var vbr = new BinaryReader (fs)) {  		var version = vbr.ReadInt32 ();  		// 7  		if (version != VTXVersionSource) {  			throw new ProviderException ("Bad version number for vertex file. Expected 7' got: " + version);  		}  		var vertCacheSize = vbr.ReadInt32 ();  		var maxBonesPerStrip = vbr.ReadUInt16 ();  		var maxBonesPerTri = vbr.ReadUInt16 ();  		var maxBonesPerVert = vbr.ReadInt32 ();  		long checksum = vbr.ReadInt32 ();  		var numLods = vbr.ReadInt32 ();  		var materialReplacementListOffset = vbr.ReadInt32 ();  		var numBodyParts = vbr.ReadInt32 ();  		var bodyPartOffset = vbr.ReadInt32 ();  		// BODY PARTS  		long posbp = bodyPartOffset;  		for (var bp = 0; bp < numBodyParts; bp++) {  			vbr.BaseStream.Position = posbp;  			var numModels = vbr.ReadInt32 ();  			var modelOffset = vbr.ReadInt32 ();  			var posmdl = posbp + modelOffset;  			posbp = vbr.BaseStream.Position;  			// MODELS  			for (var mdl = 0; mdl < numModels; mdl++) {  				vbr.BaseStream.Position = posmdl;  				var numLod = vbr.ReadInt32 ();  				var lodOffset = vbr.ReadInt32 ();  				var poslod = posmdl + lodOffset;  				posmdl = vbr.BaseStream.Position;  				// LODS  				for (var lod = 0; lod < numLod; lod++) {  					vbr.BaseStream.Position = poslod;  					var meshNum = vbr.ReadInt32 ();  					var meshOffset = vbr.ReadInt32 ();  					var switchPoint = vbr.ReadSingle ();  					var posmesh = poslod + meshOffset;  					poslod = vbr.BaseStream.Position;  					// MESHES  					for (var msh = 0; msh < meshNum; msh++) {  						vbr.BaseStream.Position = posmesh;  						var sgNum = vbr.ReadInt32 ();  						var sgOffset = vbr.ReadInt32 ();  						var meshFlags = vbr.ReadByte ();  						var possg = posmesh + sgOffset;  						posmesh = vbr.BaseStream.Position;  						var mesh = new VTXModel (bp' mdl' lod' msh);  						// STRIP GROUPS  						for (var sg = 0; sg < sgNum; sg++) {  							vbr.BaseStream.Position = possg;  							var vertNum = vbr.ReadInt32 ();  							var vertOffset = vbr.ReadInt32 ();  							var indexNum = vbr.ReadInt32 ();  							var indexOffset = vbr.ReadInt32 ();  							var stripNum = vbr.ReadInt32 ();  							var stripOffset = vbr.ReadInt32 ();  							var sgFlags = vbr.ReadByte ();  							// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  							var posvert = possg + vertOffset;  							var posidx = possg + indexOffset;  							var posstrip = possg + stripOffset;  							possg = vbr.BaseStream.Position;  							var vertinfo = new List<VTXPoint> ();  							vbr.BaseStream.Position = posvert;  							for (var vert = 0; vert < vertNum; vert++) {  								var boneWeightIndices = vbr.ReadBytes (3);  								var numBones = vbr.ReadByte ();  								var meshVertex = vbr.ReadInt16 ();  								var boneIDs = vbr.ReadBytes (3);  								vertinfo.Add (new VTXPoint (boneWeightIndices' numBones' meshVertex' boneIDs));  							}  							vbr.BaseStream.Position = posidx;  							var indices = vbr.ReadShortArray (indexNum);  							// The strips hold info about whether this is a triangle strip or just a list  							vbr.BaseStream.Position = posstrip;  							for (var st = 0; st < stripNum; st++) {  								var numStIndices = vbr.ReadInt32 ();  								var stIndexOffset = vbr.ReadInt32 ();  								var numStVerts = vbr.ReadInt32 ();  								var stVertOffset = vbr.ReadInt32 ();  								var numStBones = vbr.ReadInt16 ();  								var stFlags = vbr.ReadByte ();  								var numStBoneStateChanges = vbr.ReadInt32 ();  								var stBoneStateChangeOffset = vbr.ReadInt32 ();  								// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  								if ((stFlags & VTXStripGroupTriListFlag) > 0) {  									for (var j = stIndexOffset; j < stIndexOffset + numStIndices; j++) {  										mesh.Mesh.Points.Add (vertinfo [indices [j]]);  										//mesh.Vertices.Add(vertices[vertinfo[indices[j]]]);  									}  								} else if ((stFlags & VTXStripGroupTriStripFlag) > 0) {  									for (var j = stIndexOffset; j < stIndexOffset + numStIndices - 2; j++) {  										var add = j % 2 == 1 ? new[] {  											j + 1'  											j'  											j + 2  										} : new[] {  											j'  											j + 1'  											j + 2  										};  										foreach (var idx in add) {  											mesh.Mesh.Points.Add (vertinfo [indices [idx]]);  											//mesh.Vertices.Add(vertices[vertinfo[indices[idx]]]);  										}  									}  								}  							}  							// Strips  						}  						// Strip Groups  						modelData.Meshes.Add (mesh);  					}  					// Meshes  				}  				// LODs  			}  			// Models  		}  		// Body Parts  	}  	// using (var br)  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceMeshData,The following statement contains a magic number: using (var fs = vtx.Open ()) {  	using (var vbr = new BinaryReader (fs)) {  		var version = vbr.ReadInt32 ();  		// 7  		if (version != VTXVersionSource) {  			throw new ProviderException ("Bad version number for vertex file. Expected 7' got: " + version);  		}  		var vertCacheSize = vbr.ReadInt32 ();  		var maxBonesPerStrip = vbr.ReadUInt16 ();  		var maxBonesPerTri = vbr.ReadUInt16 ();  		var maxBonesPerVert = vbr.ReadInt32 ();  		long checksum = vbr.ReadInt32 ();  		var numLods = vbr.ReadInt32 ();  		var materialReplacementListOffset = vbr.ReadInt32 ();  		var numBodyParts = vbr.ReadInt32 ();  		var bodyPartOffset = vbr.ReadInt32 ();  		// BODY PARTS  		long posbp = bodyPartOffset;  		for (var bp = 0; bp < numBodyParts; bp++) {  			vbr.BaseStream.Position = posbp;  			var numModels = vbr.ReadInt32 ();  			var modelOffset = vbr.ReadInt32 ();  			var posmdl = posbp + modelOffset;  			posbp = vbr.BaseStream.Position;  			// MODELS  			for (var mdl = 0; mdl < numModels; mdl++) {  				vbr.BaseStream.Position = posmdl;  				var numLod = vbr.ReadInt32 ();  				var lodOffset = vbr.ReadInt32 ();  				var poslod = posmdl + lodOffset;  				posmdl = vbr.BaseStream.Position;  				// LODS  				for (var lod = 0; lod < numLod; lod++) {  					vbr.BaseStream.Position = poslod;  					var meshNum = vbr.ReadInt32 ();  					var meshOffset = vbr.ReadInt32 ();  					var switchPoint = vbr.ReadSingle ();  					var posmesh = poslod + meshOffset;  					poslod = vbr.BaseStream.Position;  					// MESHES  					for (var msh = 0; msh < meshNum; msh++) {  						vbr.BaseStream.Position = posmesh;  						var sgNum = vbr.ReadInt32 ();  						var sgOffset = vbr.ReadInt32 ();  						var meshFlags = vbr.ReadByte ();  						var possg = posmesh + sgOffset;  						posmesh = vbr.BaseStream.Position;  						var mesh = new VTXModel (bp' mdl' lod' msh);  						// STRIP GROUPS  						for (var sg = 0; sg < sgNum; sg++) {  							vbr.BaseStream.Position = possg;  							var vertNum = vbr.ReadInt32 ();  							var vertOffset = vbr.ReadInt32 ();  							var indexNum = vbr.ReadInt32 ();  							var indexOffset = vbr.ReadInt32 ();  							var stripNum = vbr.ReadInt32 ();  							var stripOffset = vbr.ReadInt32 ();  							var sgFlags = vbr.ReadByte ();  							// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  							var posvert = possg + vertOffset;  							var posidx = possg + indexOffset;  							var posstrip = possg + stripOffset;  							possg = vbr.BaseStream.Position;  							var vertinfo = new List<VTXPoint> ();  							vbr.BaseStream.Position = posvert;  							for (var vert = 0; vert < vertNum; vert++) {  								var boneWeightIndices = vbr.ReadBytes (3);  								var numBones = vbr.ReadByte ();  								var meshVertex = vbr.ReadInt16 ();  								var boneIDs = vbr.ReadBytes (3);  								vertinfo.Add (new VTXPoint (boneWeightIndices' numBones' meshVertex' boneIDs));  							}  							vbr.BaseStream.Position = posidx;  							var indices = vbr.ReadShortArray (indexNum);  							// The strips hold info about whether this is a triangle strip or just a list  							vbr.BaseStream.Position = posstrip;  							for (var st = 0; st < stripNum; st++) {  								var numStIndices = vbr.ReadInt32 ();  								var stIndexOffset = vbr.ReadInt32 ();  								var numStVerts = vbr.ReadInt32 ();  								var stVertOffset = vbr.ReadInt32 ();  								var numStBones = vbr.ReadInt16 ();  								var stFlags = vbr.ReadByte ();  								var numStBoneStateChanges = vbr.ReadInt32 ();  								var stBoneStateChangeOffset = vbr.ReadInt32 ();  								// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  								if ((stFlags & VTXStripGroupTriListFlag) > 0) {  									for (var j = stIndexOffset; j < stIndexOffset + numStIndices; j++) {  										mesh.Mesh.Points.Add (vertinfo [indices [j]]);  										//mesh.Vertices.Add(vertices[vertinfo[indices[j]]]);  									}  								} else if ((stFlags & VTXStripGroupTriStripFlag) > 0) {  									for (var j = stIndexOffset; j < stIndexOffset + numStIndices - 2; j++) {  										var add = j % 2 == 1 ? new[] {  											j + 1'  											j'  											j + 2  										} : new[] {  											j'  											j + 1'  											j + 2  										};  										foreach (var idx in add) {  											mesh.Mesh.Points.Add (vertinfo [indices [idx]]);  											//mesh.Vertices.Add(vertices[vertinfo[indices[idx]]]);  										}  									}  								}  							}  							// Strips  						}  						// Strip Groups  						modelData.Meshes.Add (mesh);  					}  					// Meshes  				}  				// LODs  			}  			// Models  		}  		// Body Parts  	}  	// using (var br)  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceMeshData,The following statement contains a magic number: using (var fs = vtx.Open ()) {  	using (var vbr = new BinaryReader (fs)) {  		var version = vbr.ReadInt32 ();  		// 7  		if (version != VTXVersionSource) {  			throw new ProviderException ("Bad version number for vertex file. Expected 7' got: " + version);  		}  		var vertCacheSize = vbr.ReadInt32 ();  		var maxBonesPerStrip = vbr.ReadUInt16 ();  		var maxBonesPerTri = vbr.ReadUInt16 ();  		var maxBonesPerVert = vbr.ReadInt32 ();  		long checksum = vbr.ReadInt32 ();  		var numLods = vbr.ReadInt32 ();  		var materialReplacementListOffset = vbr.ReadInt32 ();  		var numBodyParts = vbr.ReadInt32 ();  		var bodyPartOffset = vbr.ReadInt32 ();  		// BODY PARTS  		long posbp = bodyPartOffset;  		for (var bp = 0; bp < numBodyParts; bp++) {  			vbr.BaseStream.Position = posbp;  			var numModels = vbr.ReadInt32 ();  			var modelOffset = vbr.ReadInt32 ();  			var posmdl = posbp + modelOffset;  			posbp = vbr.BaseStream.Position;  			// MODELS  			for (var mdl = 0; mdl < numModels; mdl++) {  				vbr.BaseStream.Position = posmdl;  				var numLod = vbr.ReadInt32 ();  				var lodOffset = vbr.ReadInt32 ();  				var poslod = posmdl + lodOffset;  				posmdl = vbr.BaseStream.Position;  				// LODS  				for (var lod = 0; lod < numLod; lod++) {  					vbr.BaseStream.Position = poslod;  					var meshNum = vbr.ReadInt32 ();  					var meshOffset = vbr.ReadInt32 ();  					var switchPoint = vbr.ReadSingle ();  					var posmesh = poslod + meshOffset;  					poslod = vbr.BaseStream.Position;  					// MESHES  					for (var msh = 0; msh < meshNum; msh++) {  						vbr.BaseStream.Position = posmesh;  						var sgNum = vbr.ReadInt32 ();  						var sgOffset = vbr.ReadInt32 ();  						var meshFlags = vbr.ReadByte ();  						var possg = posmesh + sgOffset;  						posmesh = vbr.BaseStream.Position;  						var mesh = new VTXModel (bp' mdl' lod' msh);  						// STRIP GROUPS  						for (var sg = 0; sg < sgNum; sg++) {  							vbr.BaseStream.Position = possg;  							var vertNum = vbr.ReadInt32 ();  							var vertOffset = vbr.ReadInt32 ();  							var indexNum = vbr.ReadInt32 ();  							var indexOffset = vbr.ReadInt32 ();  							var stripNum = vbr.ReadInt32 ();  							var stripOffset = vbr.ReadInt32 ();  							var sgFlags = vbr.ReadByte ();  							// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  							var posvert = possg + vertOffset;  							var posidx = possg + indexOffset;  							var posstrip = possg + stripOffset;  							possg = vbr.BaseStream.Position;  							var vertinfo = new List<VTXPoint> ();  							vbr.BaseStream.Position = posvert;  							for (var vert = 0; vert < vertNum; vert++) {  								var boneWeightIndices = vbr.ReadBytes (3);  								var numBones = vbr.ReadByte ();  								var meshVertex = vbr.ReadInt16 ();  								var boneIDs = vbr.ReadBytes (3);  								vertinfo.Add (new VTXPoint (boneWeightIndices' numBones' meshVertex' boneIDs));  							}  							vbr.BaseStream.Position = posidx;  							var indices = vbr.ReadShortArray (indexNum);  							// The strips hold info about whether this is a triangle strip or just a list  							vbr.BaseStream.Position = posstrip;  							for (var st = 0; st < stripNum; st++) {  								var numStIndices = vbr.ReadInt32 ();  								var stIndexOffset = vbr.ReadInt32 ();  								var numStVerts = vbr.ReadInt32 ();  								var stVertOffset = vbr.ReadInt32 ();  								var numStBones = vbr.ReadInt16 ();  								var stFlags = vbr.ReadByte ();  								var numStBoneStateChanges = vbr.ReadInt32 ();  								var stBoneStateChangeOffset = vbr.ReadInt32 ();  								// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  								if ((stFlags & VTXStripGroupTriListFlag) > 0) {  									for (var j = stIndexOffset; j < stIndexOffset + numStIndices; j++) {  										mesh.Mesh.Points.Add (vertinfo [indices [j]]);  										//mesh.Vertices.Add(vertices[vertinfo[indices[j]]]);  									}  								} else if ((stFlags & VTXStripGroupTriStripFlag) > 0) {  									for (var j = stIndexOffset; j < stIndexOffset + numStIndices - 2; j++) {  										var add = j % 2 == 1 ? new[] {  											j + 1'  											j'  											j + 2  										} : new[] {  											j'  											j + 1'  											j + 2  										};  										foreach (var idx in add) {  											mesh.Mesh.Points.Add (vertinfo [indices [idx]]);  											//mesh.Vertices.Add(vertices[vertinfo[indices[idx]]]);  										}  									}  								}  							}  							// Strips  						}  						// Strip Groups  						modelData.Meshes.Add (mesh);  					}  					// Meshes  				}  				// LODs  			}  			// Models  		}  		// Body Parts  	}  	// using (var br)  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceMeshData,The following statement contains a magic number: using (var vbr = new BinaryReader (fs)) {  	var version = vbr.ReadInt32 ();  	// 7  	if (version != VTXVersionSource) {  		throw new ProviderException ("Bad version number for vertex file. Expected 7' got: " + version);  	}  	var vertCacheSize = vbr.ReadInt32 ();  	var maxBonesPerStrip = vbr.ReadUInt16 ();  	var maxBonesPerTri = vbr.ReadUInt16 ();  	var maxBonesPerVert = vbr.ReadInt32 ();  	long checksum = vbr.ReadInt32 ();  	var numLods = vbr.ReadInt32 ();  	var materialReplacementListOffset = vbr.ReadInt32 ();  	var numBodyParts = vbr.ReadInt32 ();  	var bodyPartOffset = vbr.ReadInt32 ();  	// BODY PARTS  	long posbp = bodyPartOffset;  	for (var bp = 0; bp < numBodyParts; bp++) {  		vbr.BaseStream.Position = posbp;  		var numModels = vbr.ReadInt32 ();  		var modelOffset = vbr.ReadInt32 ();  		var posmdl = posbp + modelOffset;  		posbp = vbr.BaseStream.Position;  		// MODELS  		for (var mdl = 0; mdl < numModels; mdl++) {  			vbr.BaseStream.Position = posmdl;  			var numLod = vbr.ReadInt32 ();  			var lodOffset = vbr.ReadInt32 ();  			var poslod = posmdl + lodOffset;  			posmdl = vbr.BaseStream.Position;  			// LODS  			for (var lod = 0; lod < numLod; lod++) {  				vbr.BaseStream.Position = poslod;  				var meshNum = vbr.ReadInt32 ();  				var meshOffset = vbr.ReadInt32 ();  				var switchPoint = vbr.ReadSingle ();  				var posmesh = poslod + meshOffset;  				poslod = vbr.BaseStream.Position;  				// MESHES  				for (var msh = 0; msh < meshNum; msh++) {  					vbr.BaseStream.Position = posmesh;  					var sgNum = vbr.ReadInt32 ();  					var sgOffset = vbr.ReadInt32 ();  					var meshFlags = vbr.ReadByte ();  					var possg = posmesh + sgOffset;  					posmesh = vbr.BaseStream.Position;  					var mesh = new VTXModel (bp' mdl' lod' msh);  					// STRIP GROUPS  					for (var sg = 0; sg < sgNum; sg++) {  						vbr.BaseStream.Position = possg;  						var vertNum = vbr.ReadInt32 ();  						var vertOffset = vbr.ReadInt32 ();  						var indexNum = vbr.ReadInt32 ();  						var indexOffset = vbr.ReadInt32 ();  						var stripNum = vbr.ReadInt32 ();  						var stripOffset = vbr.ReadInt32 ();  						var sgFlags = vbr.ReadByte ();  						// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  						var posvert = possg + vertOffset;  						var posidx = possg + indexOffset;  						var posstrip = possg + stripOffset;  						possg = vbr.BaseStream.Position;  						var vertinfo = new List<VTXPoint> ();  						vbr.BaseStream.Position = posvert;  						for (var vert = 0; vert < vertNum; vert++) {  							var boneWeightIndices = vbr.ReadBytes (3);  							var numBones = vbr.ReadByte ();  							var meshVertex = vbr.ReadInt16 ();  							var boneIDs = vbr.ReadBytes (3);  							vertinfo.Add (new VTXPoint (boneWeightIndices' numBones' meshVertex' boneIDs));  						}  						vbr.BaseStream.Position = posidx;  						var indices = vbr.ReadShortArray (indexNum);  						// The strips hold info about whether this is a triangle strip or just a list  						vbr.BaseStream.Position = posstrip;  						for (var st = 0; st < stripNum; st++) {  							var numStIndices = vbr.ReadInt32 ();  							var stIndexOffset = vbr.ReadInt32 ();  							var numStVerts = vbr.ReadInt32 ();  							var stVertOffset = vbr.ReadInt32 ();  							var numStBones = vbr.ReadInt16 ();  							var stFlags = vbr.ReadByte ();  							var numStBoneStateChanges = vbr.ReadInt32 ();  							var stBoneStateChangeOffset = vbr.ReadInt32 ();  							// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  							if ((stFlags & VTXStripGroupTriListFlag) > 0) {  								for (var j = stIndexOffset; j < stIndexOffset + numStIndices; j++) {  									mesh.Mesh.Points.Add (vertinfo [indices [j]]);  									//mesh.Vertices.Add(vertices[vertinfo[indices[j]]]);  								}  							} else if ((stFlags & VTXStripGroupTriStripFlag) > 0) {  								for (var j = stIndexOffset; j < stIndexOffset + numStIndices - 2; j++) {  									var add = j % 2 == 1 ? new[] {  										j + 1'  										j'  										j + 2  									} : new[] {  										j'  										j + 1'  										j + 2  									};  									foreach (var idx in add) {  										mesh.Mesh.Points.Add (vertinfo [indices [idx]]);  										//mesh.Vertices.Add(vertices[vertinfo[indices[idx]]]);  									}  								}  							}  						}  						// Strips  					}  					// Strip Groups  					modelData.Meshes.Add (mesh);  				}  				// Meshes  			}  			// LODs  		}  		// Models  	}  	// Body Parts  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceMeshData,The following statement contains a magic number: using (var vbr = new BinaryReader (fs)) {  	var version = vbr.ReadInt32 ();  	// 7  	if (version != VTXVersionSource) {  		throw new ProviderException ("Bad version number for vertex file. Expected 7' got: " + version);  	}  	var vertCacheSize = vbr.ReadInt32 ();  	var maxBonesPerStrip = vbr.ReadUInt16 ();  	var maxBonesPerTri = vbr.ReadUInt16 ();  	var maxBonesPerVert = vbr.ReadInt32 ();  	long checksum = vbr.ReadInt32 ();  	var numLods = vbr.ReadInt32 ();  	var materialReplacementListOffset = vbr.ReadInt32 ();  	var numBodyParts = vbr.ReadInt32 ();  	var bodyPartOffset = vbr.ReadInt32 ();  	// BODY PARTS  	long posbp = bodyPartOffset;  	for (var bp = 0; bp < numBodyParts; bp++) {  		vbr.BaseStream.Position = posbp;  		var numModels = vbr.ReadInt32 ();  		var modelOffset = vbr.ReadInt32 ();  		var posmdl = posbp + modelOffset;  		posbp = vbr.BaseStream.Position;  		// MODELS  		for (var mdl = 0; mdl < numModels; mdl++) {  			vbr.BaseStream.Position = posmdl;  			var numLod = vbr.ReadInt32 ();  			var lodOffset = vbr.ReadInt32 ();  			var poslod = posmdl + lodOffset;  			posmdl = vbr.BaseStream.Position;  			// LODS  			for (var lod = 0; lod < numLod; lod++) {  				vbr.BaseStream.Position = poslod;  				var meshNum = vbr.ReadInt32 ();  				var meshOffset = vbr.ReadInt32 ();  				var switchPoint = vbr.ReadSingle ();  				var posmesh = poslod + meshOffset;  				poslod = vbr.BaseStream.Position;  				// MESHES  				for (var msh = 0; msh < meshNum; msh++) {  					vbr.BaseStream.Position = posmesh;  					var sgNum = vbr.ReadInt32 ();  					var sgOffset = vbr.ReadInt32 ();  					var meshFlags = vbr.ReadByte ();  					var possg = posmesh + sgOffset;  					posmesh = vbr.BaseStream.Position;  					var mesh = new VTXModel (bp' mdl' lod' msh);  					// STRIP GROUPS  					for (var sg = 0; sg < sgNum; sg++) {  						vbr.BaseStream.Position = possg;  						var vertNum = vbr.ReadInt32 ();  						var vertOffset = vbr.ReadInt32 ();  						var indexNum = vbr.ReadInt32 ();  						var indexOffset = vbr.ReadInt32 ();  						var stripNum = vbr.ReadInt32 ();  						var stripOffset = vbr.ReadInt32 ();  						var sgFlags = vbr.ReadByte ();  						// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  						var posvert = possg + vertOffset;  						var posidx = possg + indexOffset;  						var posstrip = possg + stripOffset;  						possg = vbr.BaseStream.Position;  						var vertinfo = new List<VTXPoint> ();  						vbr.BaseStream.Position = posvert;  						for (var vert = 0; vert < vertNum; vert++) {  							var boneWeightIndices = vbr.ReadBytes (3);  							var numBones = vbr.ReadByte ();  							var meshVertex = vbr.ReadInt16 ();  							var boneIDs = vbr.ReadBytes (3);  							vertinfo.Add (new VTXPoint (boneWeightIndices' numBones' meshVertex' boneIDs));  						}  						vbr.BaseStream.Position = posidx;  						var indices = vbr.ReadShortArray (indexNum);  						// The strips hold info about whether this is a triangle strip or just a list  						vbr.BaseStream.Position = posstrip;  						for (var st = 0; st < stripNum; st++) {  							var numStIndices = vbr.ReadInt32 ();  							var stIndexOffset = vbr.ReadInt32 ();  							var numStVerts = vbr.ReadInt32 ();  							var stVertOffset = vbr.ReadInt32 ();  							var numStBones = vbr.ReadInt16 ();  							var stFlags = vbr.ReadByte ();  							var numStBoneStateChanges = vbr.ReadInt32 ();  							var stBoneStateChangeOffset = vbr.ReadInt32 ();  							// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  							if ((stFlags & VTXStripGroupTriListFlag) > 0) {  								for (var j = stIndexOffset; j < stIndexOffset + numStIndices; j++) {  									mesh.Mesh.Points.Add (vertinfo [indices [j]]);  									//mesh.Vertices.Add(vertices[vertinfo[indices[j]]]);  								}  							} else if ((stFlags & VTXStripGroupTriStripFlag) > 0) {  								for (var j = stIndexOffset; j < stIndexOffset + numStIndices - 2; j++) {  									var add = j % 2 == 1 ? new[] {  										j + 1'  										j'  										j + 2  									} : new[] {  										j'  										j + 1'  										j + 2  									};  									foreach (var idx in add) {  										mesh.Mesh.Points.Add (vertinfo [indices [idx]]);  										//mesh.Vertices.Add(vertices[vertinfo[indices[idx]]]);  									}  								}  							}  						}  						// Strips  					}  					// Strip Groups  					modelData.Meshes.Add (mesh);  				}  				// Meshes  			}  			// LODs  		}  		// Models  	}  	// Body Parts  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceMeshData,The following statement contains a magic number: using (var vbr = new BinaryReader (fs)) {  	var version = vbr.ReadInt32 ();  	// 7  	if (version != VTXVersionSource) {  		throw new ProviderException ("Bad version number for vertex file. Expected 7' got: " + version);  	}  	var vertCacheSize = vbr.ReadInt32 ();  	var maxBonesPerStrip = vbr.ReadUInt16 ();  	var maxBonesPerTri = vbr.ReadUInt16 ();  	var maxBonesPerVert = vbr.ReadInt32 ();  	long checksum = vbr.ReadInt32 ();  	var numLods = vbr.ReadInt32 ();  	var materialReplacementListOffset = vbr.ReadInt32 ();  	var numBodyParts = vbr.ReadInt32 ();  	var bodyPartOffset = vbr.ReadInt32 ();  	// BODY PARTS  	long posbp = bodyPartOffset;  	for (var bp = 0; bp < numBodyParts; bp++) {  		vbr.BaseStream.Position = posbp;  		var numModels = vbr.ReadInt32 ();  		var modelOffset = vbr.ReadInt32 ();  		var posmdl = posbp + modelOffset;  		posbp = vbr.BaseStream.Position;  		// MODELS  		for (var mdl = 0; mdl < numModels; mdl++) {  			vbr.BaseStream.Position = posmdl;  			var numLod = vbr.ReadInt32 ();  			var lodOffset = vbr.ReadInt32 ();  			var poslod = posmdl + lodOffset;  			posmdl = vbr.BaseStream.Position;  			// LODS  			for (var lod = 0; lod < numLod; lod++) {  				vbr.BaseStream.Position = poslod;  				var meshNum = vbr.ReadInt32 ();  				var meshOffset = vbr.ReadInt32 ();  				var switchPoint = vbr.ReadSingle ();  				var posmesh = poslod + meshOffset;  				poslod = vbr.BaseStream.Position;  				// MESHES  				for (var msh = 0; msh < meshNum; msh++) {  					vbr.BaseStream.Position = posmesh;  					var sgNum = vbr.ReadInt32 ();  					var sgOffset = vbr.ReadInt32 ();  					var meshFlags = vbr.ReadByte ();  					var possg = posmesh + sgOffset;  					posmesh = vbr.BaseStream.Position;  					var mesh = new VTXModel (bp' mdl' lod' msh);  					// STRIP GROUPS  					for (var sg = 0; sg < sgNum; sg++) {  						vbr.BaseStream.Position = possg;  						var vertNum = vbr.ReadInt32 ();  						var vertOffset = vbr.ReadInt32 ();  						var indexNum = vbr.ReadInt32 ();  						var indexOffset = vbr.ReadInt32 ();  						var stripNum = vbr.ReadInt32 ();  						var stripOffset = vbr.ReadInt32 ();  						var sgFlags = vbr.ReadByte ();  						// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  						var posvert = possg + vertOffset;  						var posidx = possg + indexOffset;  						var posstrip = possg + stripOffset;  						possg = vbr.BaseStream.Position;  						var vertinfo = new List<VTXPoint> ();  						vbr.BaseStream.Position = posvert;  						for (var vert = 0; vert < vertNum; vert++) {  							var boneWeightIndices = vbr.ReadBytes (3);  							var numBones = vbr.ReadByte ();  							var meshVertex = vbr.ReadInt16 ();  							var boneIDs = vbr.ReadBytes (3);  							vertinfo.Add (new VTXPoint (boneWeightIndices' numBones' meshVertex' boneIDs));  						}  						vbr.BaseStream.Position = posidx;  						var indices = vbr.ReadShortArray (indexNum);  						// The strips hold info about whether this is a triangle strip or just a list  						vbr.BaseStream.Position = posstrip;  						for (var st = 0; st < stripNum; st++) {  							var numStIndices = vbr.ReadInt32 ();  							var stIndexOffset = vbr.ReadInt32 ();  							var numStVerts = vbr.ReadInt32 ();  							var stVertOffset = vbr.ReadInt32 ();  							var numStBones = vbr.ReadInt16 ();  							var stFlags = vbr.ReadByte ();  							var numStBoneStateChanges = vbr.ReadInt32 ();  							var stBoneStateChangeOffset = vbr.ReadInt32 ();  							// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  							if ((stFlags & VTXStripGroupTriListFlag) > 0) {  								for (var j = stIndexOffset; j < stIndexOffset + numStIndices; j++) {  									mesh.Mesh.Points.Add (vertinfo [indices [j]]);  									//mesh.Vertices.Add(vertices[vertinfo[indices[j]]]);  								}  							} else if ((stFlags & VTXStripGroupTriStripFlag) > 0) {  								for (var j = stIndexOffset; j < stIndexOffset + numStIndices - 2; j++) {  									var add = j % 2 == 1 ? new[] {  										j + 1'  										j'  										j + 2  									} : new[] {  										j'  										j + 1'  										j + 2  									};  									foreach (var idx in add) {  										mesh.Mesh.Points.Add (vertinfo [indices [idx]]);  										//mesh.Vertices.Add(vertices[vertinfo[indices[idx]]]);  									}  								}  							}  						}  						// Strips  					}  					// Strip Groups  					modelData.Meshes.Add (mesh);  				}  				// Meshes  			}  			// LODs  		}  		// Models  	}  	// Body Parts  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceMeshData,The following statement contains a magic number: using (var vbr = new BinaryReader (fs)) {  	var version = vbr.ReadInt32 ();  	// 7  	if (version != VTXVersionSource) {  		throw new ProviderException ("Bad version number for vertex file. Expected 7' got: " + version);  	}  	var vertCacheSize = vbr.ReadInt32 ();  	var maxBonesPerStrip = vbr.ReadUInt16 ();  	var maxBonesPerTri = vbr.ReadUInt16 ();  	var maxBonesPerVert = vbr.ReadInt32 ();  	long checksum = vbr.ReadInt32 ();  	var numLods = vbr.ReadInt32 ();  	var materialReplacementListOffset = vbr.ReadInt32 ();  	var numBodyParts = vbr.ReadInt32 ();  	var bodyPartOffset = vbr.ReadInt32 ();  	// BODY PARTS  	long posbp = bodyPartOffset;  	for (var bp = 0; bp < numBodyParts; bp++) {  		vbr.BaseStream.Position = posbp;  		var numModels = vbr.ReadInt32 ();  		var modelOffset = vbr.ReadInt32 ();  		var posmdl = posbp + modelOffset;  		posbp = vbr.BaseStream.Position;  		// MODELS  		for (var mdl = 0; mdl < numModels; mdl++) {  			vbr.BaseStream.Position = posmdl;  			var numLod = vbr.ReadInt32 ();  			var lodOffset = vbr.ReadInt32 ();  			var poslod = posmdl + lodOffset;  			posmdl = vbr.BaseStream.Position;  			// LODS  			for (var lod = 0; lod < numLod; lod++) {  				vbr.BaseStream.Position = poslod;  				var meshNum = vbr.ReadInt32 ();  				var meshOffset = vbr.ReadInt32 ();  				var switchPoint = vbr.ReadSingle ();  				var posmesh = poslod + meshOffset;  				poslod = vbr.BaseStream.Position;  				// MESHES  				for (var msh = 0; msh < meshNum; msh++) {  					vbr.BaseStream.Position = posmesh;  					var sgNum = vbr.ReadInt32 ();  					var sgOffset = vbr.ReadInt32 ();  					var meshFlags = vbr.ReadByte ();  					var possg = posmesh + sgOffset;  					posmesh = vbr.BaseStream.Position;  					var mesh = new VTXModel (bp' mdl' lod' msh);  					// STRIP GROUPS  					for (var sg = 0; sg < sgNum; sg++) {  						vbr.BaseStream.Position = possg;  						var vertNum = vbr.ReadInt32 ();  						var vertOffset = vbr.ReadInt32 ();  						var indexNum = vbr.ReadInt32 ();  						var indexOffset = vbr.ReadInt32 ();  						var stripNum = vbr.ReadInt32 ();  						var stripOffset = vbr.ReadInt32 ();  						var sgFlags = vbr.ReadByte ();  						// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  						var posvert = possg + vertOffset;  						var posidx = possg + indexOffset;  						var posstrip = possg + stripOffset;  						possg = vbr.BaseStream.Position;  						var vertinfo = new List<VTXPoint> ();  						vbr.BaseStream.Position = posvert;  						for (var vert = 0; vert < vertNum; vert++) {  							var boneWeightIndices = vbr.ReadBytes (3);  							var numBones = vbr.ReadByte ();  							var meshVertex = vbr.ReadInt16 ();  							var boneIDs = vbr.ReadBytes (3);  							vertinfo.Add (new VTXPoint (boneWeightIndices' numBones' meshVertex' boneIDs));  						}  						vbr.BaseStream.Position = posidx;  						var indices = vbr.ReadShortArray (indexNum);  						// The strips hold info about whether this is a triangle strip or just a list  						vbr.BaseStream.Position = posstrip;  						for (var st = 0; st < stripNum; st++) {  							var numStIndices = vbr.ReadInt32 ();  							var stIndexOffset = vbr.ReadInt32 ();  							var numStVerts = vbr.ReadInt32 ();  							var stVertOffset = vbr.ReadInt32 ();  							var numStBones = vbr.ReadInt16 ();  							var stFlags = vbr.ReadByte ();  							var numStBoneStateChanges = vbr.ReadInt32 ();  							var stBoneStateChangeOffset = vbr.ReadInt32 ();  							// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  							if ((stFlags & VTXStripGroupTriListFlag) > 0) {  								for (var j = stIndexOffset; j < stIndexOffset + numStIndices; j++) {  									mesh.Mesh.Points.Add (vertinfo [indices [j]]);  									//mesh.Vertices.Add(vertices[vertinfo[indices[j]]]);  								}  							} else if ((stFlags & VTXStripGroupTriStripFlag) > 0) {  								for (var j = stIndexOffset; j < stIndexOffset + numStIndices - 2; j++) {  									var add = j % 2 == 1 ? new[] {  										j + 1'  										j'  										j + 2  									} : new[] {  										j'  										j + 1'  										j + 2  									};  									foreach (var idx in add) {  										mesh.Mesh.Points.Add (vertinfo [indices [idx]]);  										//mesh.Vertices.Add(vertices[vertinfo[indices[idx]]]);  									}  								}  							}  						}  						// Strips  					}  					// Strip Groups  					modelData.Meshes.Add (mesh);  				}  				// Meshes  			}  			// LODs  		}  		// Models  	}  	// Body Parts  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceMeshData,The following statement contains a magic number: using (var vbr = new BinaryReader (fs)) {  	var version = vbr.ReadInt32 ();  	// 7  	if (version != VTXVersionSource) {  		throw new ProviderException ("Bad version number for vertex file. Expected 7' got: " + version);  	}  	var vertCacheSize = vbr.ReadInt32 ();  	var maxBonesPerStrip = vbr.ReadUInt16 ();  	var maxBonesPerTri = vbr.ReadUInt16 ();  	var maxBonesPerVert = vbr.ReadInt32 ();  	long checksum = vbr.ReadInt32 ();  	var numLods = vbr.ReadInt32 ();  	var materialReplacementListOffset = vbr.ReadInt32 ();  	var numBodyParts = vbr.ReadInt32 ();  	var bodyPartOffset = vbr.ReadInt32 ();  	// BODY PARTS  	long posbp = bodyPartOffset;  	for (var bp = 0; bp < numBodyParts; bp++) {  		vbr.BaseStream.Position = posbp;  		var numModels = vbr.ReadInt32 ();  		var modelOffset = vbr.ReadInt32 ();  		var posmdl = posbp + modelOffset;  		posbp = vbr.BaseStream.Position;  		// MODELS  		for (var mdl = 0; mdl < numModels; mdl++) {  			vbr.BaseStream.Position = posmdl;  			var numLod = vbr.ReadInt32 ();  			var lodOffset = vbr.ReadInt32 ();  			var poslod = posmdl + lodOffset;  			posmdl = vbr.BaseStream.Position;  			// LODS  			for (var lod = 0; lod < numLod; lod++) {  				vbr.BaseStream.Position = poslod;  				var meshNum = vbr.ReadInt32 ();  				var meshOffset = vbr.ReadInt32 ();  				var switchPoint = vbr.ReadSingle ();  				var posmesh = poslod + meshOffset;  				poslod = vbr.BaseStream.Position;  				// MESHES  				for (var msh = 0; msh < meshNum; msh++) {  					vbr.BaseStream.Position = posmesh;  					var sgNum = vbr.ReadInt32 ();  					var sgOffset = vbr.ReadInt32 ();  					var meshFlags = vbr.ReadByte ();  					var possg = posmesh + sgOffset;  					posmesh = vbr.BaseStream.Position;  					var mesh = new VTXModel (bp' mdl' lod' msh);  					// STRIP GROUPS  					for (var sg = 0; sg < sgNum; sg++) {  						vbr.BaseStream.Position = possg;  						var vertNum = vbr.ReadInt32 ();  						var vertOffset = vbr.ReadInt32 ();  						var indexNum = vbr.ReadInt32 ();  						var indexOffset = vbr.ReadInt32 ();  						var stripNum = vbr.ReadInt32 ();  						var stripOffset = vbr.ReadInt32 ();  						var sgFlags = vbr.ReadByte ();  						// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  						var posvert = possg + vertOffset;  						var posidx = possg + indexOffset;  						var posstrip = possg + stripOffset;  						possg = vbr.BaseStream.Position;  						var vertinfo = new List<VTXPoint> ();  						vbr.BaseStream.Position = posvert;  						for (var vert = 0; vert < vertNum; vert++) {  							var boneWeightIndices = vbr.ReadBytes (3);  							var numBones = vbr.ReadByte ();  							var meshVertex = vbr.ReadInt16 ();  							var boneIDs = vbr.ReadBytes (3);  							vertinfo.Add (new VTXPoint (boneWeightIndices' numBones' meshVertex' boneIDs));  						}  						vbr.BaseStream.Position = posidx;  						var indices = vbr.ReadShortArray (indexNum);  						// The strips hold info about whether this is a triangle strip or just a list  						vbr.BaseStream.Position = posstrip;  						for (var st = 0; st < stripNum; st++) {  							var numStIndices = vbr.ReadInt32 ();  							var stIndexOffset = vbr.ReadInt32 ();  							var numStVerts = vbr.ReadInt32 ();  							var stVertOffset = vbr.ReadInt32 ();  							var numStBones = vbr.ReadInt16 ();  							var stFlags = vbr.ReadByte ();  							var numStBoneStateChanges = vbr.ReadInt32 ();  							var stBoneStateChangeOffset = vbr.ReadInt32 ();  							// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  							if ((stFlags & VTXStripGroupTriListFlag) > 0) {  								for (var j = stIndexOffset; j < stIndexOffset + numStIndices; j++) {  									mesh.Mesh.Points.Add (vertinfo [indices [j]]);  									//mesh.Vertices.Add(vertices[vertinfo[indices[j]]]);  								}  							} else if ((stFlags & VTXStripGroupTriStripFlag) > 0) {  								for (var j = stIndexOffset; j < stIndexOffset + numStIndices - 2; j++) {  									var add = j % 2 == 1 ? new[] {  										j + 1'  										j'  										j + 2  									} : new[] {  										j'  										j + 1'  										j + 2  									};  									foreach (var idx in add) {  										mesh.Mesh.Points.Add (vertinfo [indices [idx]]);  										//mesh.Vertices.Add(vertices[vertinfo[indices[idx]]]);  									}  								}  							}  						}  						// Strips  					}  					// Strip Groups  					modelData.Meshes.Add (mesh);  				}  				// Meshes  			}  			// LODs  		}  		// Models  	}  	// Body Parts  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceMeshData,The following statement contains a magic number: using (var vbr = new BinaryReader (fs)) {  	var version = vbr.ReadInt32 ();  	// 7  	if (version != VTXVersionSource) {  		throw new ProviderException ("Bad version number for vertex file. Expected 7' got: " + version);  	}  	var vertCacheSize = vbr.ReadInt32 ();  	var maxBonesPerStrip = vbr.ReadUInt16 ();  	var maxBonesPerTri = vbr.ReadUInt16 ();  	var maxBonesPerVert = vbr.ReadInt32 ();  	long checksum = vbr.ReadInt32 ();  	var numLods = vbr.ReadInt32 ();  	var materialReplacementListOffset = vbr.ReadInt32 ();  	var numBodyParts = vbr.ReadInt32 ();  	var bodyPartOffset = vbr.ReadInt32 ();  	// BODY PARTS  	long posbp = bodyPartOffset;  	for (var bp = 0; bp < numBodyParts; bp++) {  		vbr.BaseStream.Position = posbp;  		var numModels = vbr.ReadInt32 ();  		var modelOffset = vbr.ReadInt32 ();  		var posmdl = posbp + modelOffset;  		posbp = vbr.BaseStream.Position;  		// MODELS  		for (var mdl = 0; mdl < numModels; mdl++) {  			vbr.BaseStream.Position = posmdl;  			var numLod = vbr.ReadInt32 ();  			var lodOffset = vbr.ReadInt32 ();  			var poslod = posmdl + lodOffset;  			posmdl = vbr.BaseStream.Position;  			// LODS  			for (var lod = 0; lod < numLod; lod++) {  				vbr.BaseStream.Position = poslod;  				var meshNum = vbr.ReadInt32 ();  				var meshOffset = vbr.ReadInt32 ();  				var switchPoint = vbr.ReadSingle ();  				var posmesh = poslod + meshOffset;  				poslod = vbr.BaseStream.Position;  				// MESHES  				for (var msh = 0; msh < meshNum; msh++) {  					vbr.BaseStream.Position = posmesh;  					var sgNum = vbr.ReadInt32 ();  					var sgOffset = vbr.ReadInt32 ();  					var meshFlags = vbr.ReadByte ();  					var possg = posmesh + sgOffset;  					posmesh = vbr.BaseStream.Position;  					var mesh = new VTXModel (bp' mdl' lod' msh);  					// STRIP GROUPS  					for (var sg = 0; sg < sgNum; sg++) {  						vbr.BaseStream.Position = possg;  						var vertNum = vbr.ReadInt32 ();  						var vertOffset = vbr.ReadInt32 ();  						var indexNum = vbr.ReadInt32 ();  						var indexOffset = vbr.ReadInt32 ();  						var stripNum = vbr.ReadInt32 ();  						var stripOffset = vbr.ReadInt32 ();  						var sgFlags = vbr.ReadByte ();  						// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  						var posvert = possg + vertOffset;  						var posidx = possg + indexOffset;  						var posstrip = possg + stripOffset;  						possg = vbr.BaseStream.Position;  						var vertinfo = new List<VTXPoint> ();  						vbr.BaseStream.Position = posvert;  						for (var vert = 0; vert < vertNum; vert++) {  							var boneWeightIndices = vbr.ReadBytes (3);  							var numBones = vbr.ReadByte ();  							var meshVertex = vbr.ReadInt16 ();  							var boneIDs = vbr.ReadBytes (3);  							vertinfo.Add (new VTXPoint (boneWeightIndices' numBones' meshVertex' boneIDs));  						}  						vbr.BaseStream.Position = posidx;  						var indices = vbr.ReadShortArray (indexNum);  						// The strips hold info about whether this is a triangle strip or just a list  						vbr.BaseStream.Position = posstrip;  						for (var st = 0; st < stripNum; st++) {  							var numStIndices = vbr.ReadInt32 ();  							var stIndexOffset = vbr.ReadInt32 ();  							var numStVerts = vbr.ReadInt32 ();  							var stVertOffset = vbr.ReadInt32 ();  							var numStBones = vbr.ReadInt16 ();  							var stFlags = vbr.ReadByte ();  							var numStBoneStateChanges = vbr.ReadInt32 ();  							var stBoneStateChangeOffset = vbr.ReadInt32 ();  							// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  							if ((stFlags & VTXStripGroupTriListFlag) > 0) {  								for (var j = stIndexOffset; j < stIndexOffset + numStIndices; j++) {  									mesh.Mesh.Points.Add (vertinfo [indices [j]]);  									//mesh.Vertices.Add(vertices[vertinfo[indices[j]]]);  								}  							} else if ((stFlags & VTXStripGroupTriStripFlag) > 0) {  								for (var j = stIndexOffset; j < stIndexOffset + numStIndices - 2; j++) {  									var add = j % 2 == 1 ? new[] {  										j + 1'  										j'  										j + 2  									} : new[] {  										j'  										j + 1'  										j + 2  									};  									foreach (var idx in add) {  										mesh.Mesh.Points.Add (vertinfo [indices [idx]]);  										//mesh.Vertices.Add(vertices[vertinfo[indices[idx]]]);  									}  								}  							}  						}  						// Strips  					}  					// Strip Groups  					modelData.Meshes.Add (mesh);  				}  				// Meshes  			}  			// LODs  		}  		// Models  	}  	// Body Parts  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceMeshData,The following statement contains a magic number: for (var bp = 0; bp < numBodyParts; bp++) {  	vbr.BaseStream.Position = posbp;  	var numModels = vbr.ReadInt32 ();  	var modelOffset = vbr.ReadInt32 ();  	var posmdl = posbp + modelOffset;  	posbp = vbr.BaseStream.Position;  	// MODELS  	for (var mdl = 0; mdl < numModels; mdl++) {  		vbr.BaseStream.Position = posmdl;  		var numLod = vbr.ReadInt32 ();  		var lodOffset = vbr.ReadInt32 ();  		var poslod = posmdl + lodOffset;  		posmdl = vbr.BaseStream.Position;  		// LODS  		for (var lod = 0; lod < numLod; lod++) {  			vbr.BaseStream.Position = poslod;  			var meshNum = vbr.ReadInt32 ();  			var meshOffset = vbr.ReadInt32 ();  			var switchPoint = vbr.ReadSingle ();  			var posmesh = poslod + meshOffset;  			poslod = vbr.BaseStream.Position;  			// MESHES  			for (var msh = 0; msh < meshNum; msh++) {  				vbr.BaseStream.Position = posmesh;  				var sgNum = vbr.ReadInt32 ();  				var sgOffset = vbr.ReadInt32 ();  				var meshFlags = vbr.ReadByte ();  				var possg = posmesh + sgOffset;  				posmesh = vbr.BaseStream.Position;  				var mesh = new VTXModel (bp' mdl' lod' msh);  				// STRIP GROUPS  				for (var sg = 0; sg < sgNum; sg++) {  					vbr.BaseStream.Position = possg;  					var vertNum = vbr.ReadInt32 ();  					var vertOffset = vbr.ReadInt32 ();  					var indexNum = vbr.ReadInt32 ();  					var indexOffset = vbr.ReadInt32 ();  					var stripNum = vbr.ReadInt32 ();  					var stripOffset = vbr.ReadInt32 ();  					var sgFlags = vbr.ReadByte ();  					// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  					var posvert = possg + vertOffset;  					var posidx = possg + indexOffset;  					var posstrip = possg + stripOffset;  					possg = vbr.BaseStream.Position;  					var vertinfo = new List<VTXPoint> ();  					vbr.BaseStream.Position = posvert;  					for (var vert = 0; vert < vertNum; vert++) {  						var boneWeightIndices = vbr.ReadBytes (3);  						var numBones = vbr.ReadByte ();  						var meshVertex = vbr.ReadInt16 ();  						var boneIDs = vbr.ReadBytes (3);  						vertinfo.Add (new VTXPoint (boneWeightIndices' numBones' meshVertex' boneIDs));  					}  					vbr.BaseStream.Position = posidx;  					var indices = vbr.ReadShortArray (indexNum);  					// The strips hold info about whether this is a triangle strip or just a list  					vbr.BaseStream.Position = posstrip;  					for (var st = 0; st < stripNum; st++) {  						var numStIndices = vbr.ReadInt32 ();  						var stIndexOffset = vbr.ReadInt32 ();  						var numStVerts = vbr.ReadInt32 ();  						var stVertOffset = vbr.ReadInt32 ();  						var numStBones = vbr.ReadInt16 ();  						var stFlags = vbr.ReadByte ();  						var numStBoneStateChanges = vbr.ReadInt32 ();  						var stBoneStateChangeOffset = vbr.ReadInt32 ();  						// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  						if ((stFlags & VTXStripGroupTriListFlag) > 0) {  							for (var j = stIndexOffset; j < stIndexOffset + numStIndices; j++) {  								mesh.Mesh.Points.Add (vertinfo [indices [j]]);  								//mesh.Vertices.Add(vertices[vertinfo[indices[j]]]);  							}  						} else if ((stFlags & VTXStripGroupTriStripFlag) > 0) {  							for (var j = stIndexOffset; j < stIndexOffset + numStIndices - 2; j++) {  								var add = j % 2 == 1 ? new[] {  									j + 1'  									j'  									j + 2  								} : new[] {  									j'  									j + 1'  									j + 2  								};  								foreach (var idx in add) {  									mesh.Mesh.Points.Add (vertinfo [indices [idx]]);  									//mesh.Vertices.Add(vertices[vertinfo[indices[idx]]]);  								}  							}  						}  					}  					// Strips  				}  				// Strip Groups  				modelData.Meshes.Add (mesh);  			}  			// Meshes  		}  		// LODs  	}  	// Models  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceMeshData,The following statement contains a magic number: for (var bp = 0; bp < numBodyParts; bp++) {  	vbr.BaseStream.Position = posbp;  	var numModels = vbr.ReadInt32 ();  	var modelOffset = vbr.ReadInt32 ();  	var posmdl = posbp + modelOffset;  	posbp = vbr.BaseStream.Position;  	// MODELS  	for (var mdl = 0; mdl < numModels; mdl++) {  		vbr.BaseStream.Position = posmdl;  		var numLod = vbr.ReadInt32 ();  		var lodOffset = vbr.ReadInt32 ();  		var poslod = posmdl + lodOffset;  		posmdl = vbr.BaseStream.Position;  		// LODS  		for (var lod = 0; lod < numLod; lod++) {  			vbr.BaseStream.Position = poslod;  			var meshNum = vbr.ReadInt32 ();  			var meshOffset = vbr.ReadInt32 ();  			var switchPoint = vbr.ReadSingle ();  			var posmesh = poslod + meshOffset;  			poslod = vbr.BaseStream.Position;  			// MESHES  			for (var msh = 0; msh < meshNum; msh++) {  				vbr.BaseStream.Position = posmesh;  				var sgNum = vbr.ReadInt32 ();  				var sgOffset = vbr.ReadInt32 ();  				var meshFlags = vbr.ReadByte ();  				var possg = posmesh + sgOffset;  				posmesh = vbr.BaseStream.Position;  				var mesh = new VTXModel (bp' mdl' lod' msh);  				// STRIP GROUPS  				for (var sg = 0; sg < sgNum; sg++) {  					vbr.BaseStream.Position = possg;  					var vertNum = vbr.ReadInt32 ();  					var vertOffset = vbr.ReadInt32 ();  					var indexNum = vbr.ReadInt32 ();  					var indexOffset = vbr.ReadInt32 ();  					var stripNum = vbr.ReadInt32 ();  					var stripOffset = vbr.ReadInt32 ();  					var sgFlags = vbr.ReadByte ();  					// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  					var posvert = possg + vertOffset;  					var posidx = possg + indexOffset;  					var posstrip = possg + stripOffset;  					possg = vbr.BaseStream.Position;  					var vertinfo = new List<VTXPoint> ();  					vbr.BaseStream.Position = posvert;  					for (var vert = 0; vert < vertNum; vert++) {  						var boneWeightIndices = vbr.ReadBytes (3);  						var numBones = vbr.ReadByte ();  						var meshVertex = vbr.ReadInt16 ();  						var boneIDs = vbr.ReadBytes (3);  						vertinfo.Add (new VTXPoint (boneWeightIndices' numBones' meshVertex' boneIDs));  					}  					vbr.BaseStream.Position = posidx;  					var indices = vbr.ReadShortArray (indexNum);  					// The strips hold info about whether this is a triangle strip or just a list  					vbr.BaseStream.Position = posstrip;  					for (var st = 0; st < stripNum; st++) {  						var numStIndices = vbr.ReadInt32 ();  						var stIndexOffset = vbr.ReadInt32 ();  						var numStVerts = vbr.ReadInt32 ();  						var stVertOffset = vbr.ReadInt32 ();  						var numStBones = vbr.ReadInt16 ();  						var stFlags = vbr.ReadByte ();  						var numStBoneStateChanges = vbr.ReadInt32 ();  						var stBoneStateChangeOffset = vbr.ReadInt32 ();  						// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  						if ((stFlags & VTXStripGroupTriListFlag) > 0) {  							for (var j = stIndexOffset; j < stIndexOffset + numStIndices; j++) {  								mesh.Mesh.Points.Add (vertinfo [indices [j]]);  								//mesh.Vertices.Add(vertices[vertinfo[indices[j]]]);  							}  						} else if ((stFlags & VTXStripGroupTriStripFlag) > 0) {  							for (var j = stIndexOffset; j < stIndexOffset + numStIndices - 2; j++) {  								var add = j % 2 == 1 ? new[] {  									j + 1'  									j'  									j + 2  								} : new[] {  									j'  									j + 1'  									j + 2  								};  								foreach (var idx in add) {  									mesh.Mesh.Points.Add (vertinfo [indices [idx]]);  									//mesh.Vertices.Add(vertices[vertinfo[indices[idx]]]);  								}  							}  						}  					}  					// Strips  				}  				// Strip Groups  				modelData.Meshes.Add (mesh);  			}  			// Meshes  		}  		// LODs  	}  	// Models  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceMeshData,The following statement contains a magic number: for (var bp = 0; bp < numBodyParts; bp++) {  	vbr.BaseStream.Position = posbp;  	var numModels = vbr.ReadInt32 ();  	var modelOffset = vbr.ReadInt32 ();  	var posmdl = posbp + modelOffset;  	posbp = vbr.BaseStream.Position;  	// MODELS  	for (var mdl = 0; mdl < numModels; mdl++) {  		vbr.BaseStream.Position = posmdl;  		var numLod = vbr.ReadInt32 ();  		var lodOffset = vbr.ReadInt32 ();  		var poslod = posmdl + lodOffset;  		posmdl = vbr.BaseStream.Position;  		// LODS  		for (var lod = 0; lod < numLod; lod++) {  			vbr.BaseStream.Position = poslod;  			var meshNum = vbr.ReadInt32 ();  			var meshOffset = vbr.ReadInt32 ();  			var switchPoint = vbr.ReadSingle ();  			var posmesh = poslod + meshOffset;  			poslod = vbr.BaseStream.Position;  			// MESHES  			for (var msh = 0; msh < meshNum; msh++) {  				vbr.BaseStream.Position = posmesh;  				var sgNum = vbr.ReadInt32 ();  				var sgOffset = vbr.ReadInt32 ();  				var meshFlags = vbr.ReadByte ();  				var possg = posmesh + sgOffset;  				posmesh = vbr.BaseStream.Position;  				var mesh = new VTXModel (bp' mdl' lod' msh);  				// STRIP GROUPS  				for (var sg = 0; sg < sgNum; sg++) {  					vbr.BaseStream.Position = possg;  					var vertNum = vbr.ReadInt32 ();  					var vertOffset = vbr.ReadInt32 ();  					var indexNum = vbr.ReadInt32 ();  					var indexOffset = vbr.ReadInt32 ();  					var stripNum = vbr.ReadInt32 ();  					var stripOffset = vbr.ReadInt32 ();  					var sgFlags = vbr.ReadByte ();  					// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  					var posvert = possg + vertOffset;  					var posidx = possg + indexOffset;  					var posstrip = possg + stripOffset;  					possg = vbr.BaseStream.Position;  					var vertinfo = new List<VTXPoint> ();  					vbr.BaseStream.Position = posvert;  					for (var vert = 0; vert < vertNum; vert++) {  						var boneWeightIndices = vbr.ReadBytes (3);  						var numBones = vbr.ReadByte ();  						var meshVertex = vbr.ReadInt16 ();  						var boneIDs = vbr.ReadBytes (3);  						vertinfo.Add (new VTXPoint (boneWeightIndices' numBones' meshVertex' boneIDs));  					}  					vbr.BaseStream.Position = posidx;  					var indices = vbr.ReadShortArray (indexNum);  					// The strips hold info about whether this is a triangle strip or just a list  					vbr.BaseStream.Position = posstrip;  					for (var st = 0; st < stripNum; st++) {  						var numStIndices = vbr.ReadInt32 ();  						var stIndexOffset = vbr.ReadInt32 ();  						var numStVerts = vbr.ReadInt32 ();  						var stVertOffset = vbr.ReadInt32 ();  						var numStBones = vbr.ReadInt16 ();  						var stFlags = vbr.ReadByte ();  						var numStBoneStateChanges = vbr.ReadInt32 ();  						var stBoneStateChangeOffset = vbr.ReadInt32 ();  						// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  						if ((stFlags & VTXStripGroupTriListFlag) > 0) {  							for (var j = stIndexOffset; j < stIndexOffset + numStIndices; j++) {  								mesh.Mesh.Points.Add (vertinfo [indices [j]]);  								//mesh.Vertices.Add(vertices[vertinfo[indices[j]]]);  							}  						} else if ((stFlags & VTXStripGroupTriStripFlag) > 0) {  							for (var j = stIndexOffset; j < stIndexOffset + numStIndices - 2; j++) {  								var add = j % 2 == 1 ? new[] {  									j + 1'  									j'  									j + 2  								} : new[] {  									j'  									j + 1'  									j + 2  								};  								foreach (var idx in add) {  									mesh.Mesh.Points.Add (vertinfo [indices [idx]]);  									//mesh.Vertices.Add(vertices[vertinfo[indices[idx]]]);  								}  							}  						}  					}  					// Strips  				}  				// Strip Groups  				modelData.Meshes.Add (mesh);  			}  			// Meshes  		}  		// LODs  	}  	// Models  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceMeshData,The following statement contains a magic number: for (var bp = 0; bp < numBodyParts; bp++) {  	vbr.BaseStream.Position = posbp;  	var numModels = vbr.ReadInt32 ();  	var modelOffset = vbr.ReadInt32 ();  	var posmdl = posbp + modelOffset;  	posbp = vbr.BaseStream.Position;  	// MODELS  	for (var mdl = 0; mdl < numModels; mdl++) {  		vbr.BaseStream.Position = posmdl;  		var numLod = vbr.ReadInt32 ();  		var lodOffset = vbr.ReadInt32 ();  		var poslod = posmdl + lodOffset;  		posmdl = vbr.BaseStream.Position;  		// LODS  		for (var lod = 0; lod < numLod; lod++) {  			vbr.BaseStream.Position = poslod;  			var meshNum = vbr.ReadInt32 ();  			var meshOffset = vbr.ReadInt32 ();  			var switchPoint = vbr.ReadSingle ();  			var posmesh = poslod + meshOffset;  			poslod = vbr.BaseStream.Position;  			// MESHES  			for (var msh = 0; msh < meshNum; msh++) {  				vbr.BaseStream.Position = posmesh;  				var sgNum = vbr.ReadInt32 ();  				var sgOffset = vbr.ReadInt32 ();  				var meshFlags = vbr.ReadByte ();  				var possg = posmesh + sgOffset;  				posmesh = vbr.BaseStream.Position;  				var mesh = new VTXModel (bp' mdl' lod' msh);  				// STRIP GROUPS  				for (var sg = 0; sg < sgNum; sg++) {  					vbr.BaseStream.Position = possg;  					var vertNum = vbr.ReadInt32 ();  					var vertOffset = vbr.ReadInt32 ();  					var indexNum = vbr.ReadInt32 ();  					var indexOffset = vbr.ReadInt32 ();  					var stripNum = vbr.ReadInt32 ();  					var stripOffset = vbr.ReadInt32 ();  					var sgFlags = vbr.ReadByte ();  					// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  					var posvert = possg + vertOffset;  					var posidx = possg + indexOffset;  					var posstrip = possg + stripOffset;  					possg = vbr.BaseStream.Position;  					var vertinfo = new List<VTXPoint> ();  					vbr.BaseStream.Position = posvert;  					for (var vert = 0; vert < vertNum; vert++) {  						var boneWeightIndices = vbr.ReadBytes (3);  						var numBones = vbr.ReadByte ();  						var meshVertex = vbr.ReadInt16 ();  						var boneIDs = vbr.ReadBytes (3);  						vertinfo.Add (new VTXPoint (boneWeightIndices' numBones' meshVertex' boneIDs));  					}  					vbr.BaseStream.Position = posidx;  					var indices = vbr.ReadShortArray (indexNum);  					// The strips hold info about whether this is a triangle strip or just a list  					vbr.BaseStream.Position = posstrip;  					for (var st = 0; st < stripNum; st++) {  						var numStIndices = vbr.ReadInt32 ();  						var stIndexOffset = vbr.ReadInt32 ();  						var numStVerts = vbr.ReadInt32 ();  						var stVertOffset = vbr.ReadInt32 ();  						var numStBones = vbr.ReadInt16 ();  						var stFlags = vbr.ReadByte ();  						var numStBoneStateChanges = vbr.ReadInt32 ();  						var stBoneStateChangeOffset = vbr.ReadInt32 ();  						// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  						if ((stFlags & VTXStripGroupTriListFlag) > 0) {  							for (var j = stIndexOffset; j < stIndexOffset + numStIndices; j++) {  								mesh.Mesh.Points.Add (vertinfo [indices [j]]);  								//mesh.Vertices.Add(vertices[vertinfo[indices[j]]]);  							}  						} else if ((stFlags & VTXStripGroupTriStripFlag) > 0) {  							for (var j = stIndexOffset; j < stIndexOffset + numStIndices - 2; j++) {  								var add = j % 2 == 1 ? new[] {  									j + 1'  									j'  									j + 2  								} : new[] {  									j'  									j + 1'  									j + 2  								};  								foreach (var idx in add) {  									mesh.Mesh.Points.Add (vertinfo [indices [idx]]);  									//mesh.Vertices.Add(vertices[vertinfo[indices[idx]]]);  								}  							}  						}  					}  					// Strips  				}  				// Strip Groups  				modelData.Meshes.Add (mesh);  			}  			// Meshes  		}  		// LODs  	}  	// Models  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceMeshData,The following statement contains a magic number: for (var bp = 0; bp < numBodyParts; bp++) {  	vbr.BaseStream.Position = posbp;  	var numModels = vbr.ReadInt32 ();  	var modelOffset = vbr.ReadInt32 ();  	var posmdl = posbp + modelOffset;  	posbp = vbr.BaseStream.Position;  	// MODELS  	for (var mdl = 0; mdl < numModels; mdl++) {  		vbr.BaseStream.Position = posmdl;  		var numLod = vbr.ReadInt32 ();  		var lodOffset = vbr.ReadInt32 ();  		var poslod = posmdl + lodOffset;  		posmdl = vbr.BaseStream.Position;  		// LODS  		for (var lod = 0; lod < numLod; lod++) {  			vbr.BaseStream.Position = poslod;  			var meshNum = vbr.ReadInt32 ();  			var meshOffset = vbr.ReadInt32 ();  			var switchPoint = vbr.ReadSingle ();  			var posmesh = poslod + meshOffset;  			poslod = vbr.BaseStream.Position;  			// MESHES  			for (var msh = 0; msh < meshNum; msh++) {  				vbr.BaseStream.Position = posmesh;  				var sgNum = vbr.ReadInt32 ();  				var sgOffset = vbr.ReadInt32 ();  				var meshFlags = vbr.ReadByte ();  				var possg = posmesh + sgOffset;  				posmesh = vbr.BaseStream.Position;  				var mesh = new VTXModel (bp' mdl' lod' msh);  				// STRIP GROUPS  				for (var sg = 0; sg < sgNum; sg++) {  					vbr.BaseStream.Position = possg;  					var vertNum = vbr.ReadInt32 ();  					var vertOffset = vbr.ReadInt32 ();  					var indexNum = vbr.ReadInt32 ();  					var indexOffset = vbr.ReadInt32 ();  					var stripNum = vbr.ReadInt32 ();  					var stripOffset = vbr.ReadInt32 ();  					var sgFlags = vbr.ReadByte ();  					// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  					var posvert = possg + vertOffset;  					var posidx = possg + indexOffset;  					var posstrip = possg + stripOffset;  					possg = vbr.BaseStream.Position;  					var vertinfo = new List<VTXPoint> ();  					vbr.BaseStream.Position = posvert;  					for (var vert = 0; vert < vertNum; vert++) {  						var boneWeightIndices = vbr.ReadBytes (3);  						var numBones = vbr.ReadByte ();  						var meshVertex = vbr.ReadInt16 ();  						var boneIDs = vbr.ReadBytes (3);  						vertinfo.Add (new VTXPoint (boneWeightIndices' numBones' meshVertex' boneIDs));  					}  					vbr.BaseStream.Position = posidx;  					var indices = vbr.ReadShortArray (indexNum);  					// The strips hold info about whether this is a triangle strip or just a list  					vbr.BaseStream.Position = posstrip;  					for (var st = 0; st < stripNum; st++) {  						var numStIndices = vbr.ReadInt32 ();  						var stIndexOffset = vbr.ReadInt32 ();  						var numStVerts = vbr.ReadInt32 ();  						var stVertOffset = vbr.ReadInt32 ();  						var numStBones = vbr.ReadInt16 ();  						var stFlags = vbr.ReadByte ();  						var numStBoneStateChanges = vbr.ReadInt32 ();  						var stBoneStateChangeOffset = vbr.ReadInt32 ();  						// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  						if ((stFlags & VTXStripGroupTriListFlag) > 0) {  							for (var j = stIndexOffset; j < stIndexOffset + numStIndices; j++) {  								mesh.Mesh.Points.Add (vertinfo [indices [j]]);  								//mesh.Vertices.Add(vertices[vertinfo[indices[j]]]);  							}  						} else if ((stFlags & VTXStripGroupTriStripFlag) > 0) {  							for (var j = stIndexOffset; j < stIndexOffset + numStIndices - 2; j++) {  								var add = j % 2 == 1 ? new[] {  									j + 1'  									j'  									j + 2  								} : new[] {  									j'  									j + 1'  									j + 2  								};  								foreach (var idx in add) {  									mesh.Mesh.Points.Add (vertinfo [indices [idx]]);  									//mesh.Vertices.Add(vertices[vertinfo[indices[idx]]]);  								}  							}  						}  					}  					// Strips  				}  				// Strip Groups  				modelData.Meshes.Add (mesh);  			}  			// Meshes  		}  		// LODs  	}  	// Models  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceMeshData,The following statement contains a magic number: for (var bp = 0; bp < numBodyParts; bp++) {  	vbr.BaseStream.Position = posbp;  	var numModels = vbr.ReadInt32 ();  	var modelOffset = vbr.ReadInt32 ();  	var posmdl = posbp + modelOffset;  	posbp = vbr.BaseStream.Position;  	// MODELS  	for (var mdl = 0; mdl < numModels; mdl++) {  		vbr.BaseStream.Position = posmdl;  		var numLod = vbr.ReadInt32 ();  		var lodOffset = vbr.ReadInt32 ();  		var poslod = posmdl + lodOffset;  		posmdl = vbr.BaseStream.Position;  		// LODS  		for (var lod = 0; lod < numLod; lod++) {  			vbr.BaseStream.Position = poslod;  			var meshNum = vbr.ReadInt32 ();  			var meshOffset = vbr.ReadInt32 ();  			var switchPoint = vbr.ReadSingle ();  			var posmesh = poslod + meshOffset;  			poslod = vbr.BaseStream.Position;  			// MESHES  			for (var msh = 0; msh < meshNum; msh++) {  				vbr.BaseStream.Position = posmesh;  				var sgNum = vbr.ReadInt32 ();  				var sgOffset = vbr.ReadInt32 ();  				var meshFlags = vbr.ReadByte ();  				var possg = posmesh + sgOffset;  				posmesh = vbr.BaseStream.Position;  				var mesh = new VTXModel (bp' mdl' lod' msh);  				// STRIP GROUPS  				for (var sg = 0; sg < sgNum; sg++) {  					vbr.BaseStream.Position = possg;  					var vertNum = vbr.ReadInt32 ();  					var vertOffset = vbr.ReadInt32 ();  					var indexNum = vbr.ReadInt32 ();  					var indexOffset = vbr.ReadInt32 ();  					var stripNum = vbr.ReadInt32 ();  					var stripOffset = vbr.ReadInt32 ();  					var sgFlags = vbr.ReadByte ();  					// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  					var posvert = possg + vertOffset;  					var posidx = possg + indexOffset;  					var posstrip = possg + stripOffset;  					possg = vbr.BaseStream.Position;  					var vertinfo = new List<VTXPoint> ();  					vbr.BaseStream.Position = posvert;  					for (var vert = 0; vert < vertNum; vert++) {  						var boneWeightIndices = vbr.ReadBytes (3);  						var numBones = vbr.ReadByte ();  						var meshVertex = vbr.ReadInt16 ();  						var boneIDs = vbr.ReadBytes (3);  						vertinfo.Add (new VTXPoint (boneWeightIndices' numBones' meshVertex' boneIDs));  					}  					vbr.BaseStream.Position = posidx;  					var indices = vbr.ReadShortArray (indexNum);  					// The strips hold info about whether this is a triangle strip or just a list  					vbr.BaseStream.Position = posstrip;  					for (var st = 0; st < stripNum; st++) {  						var numStIndices = vbr.ReadInt32 ();  						var stIndexOffset = vbr.ReadInt32 ();  						var numStVerts = vbr.ReadInt32 ();  						var stVertOffset = vbr.ReadInt32 ();  						var numStBones = vbr.ReadInt16 ();  						var stFlags = vbr.ReadByte ();  						var numStBoneStateChanges = vbr.ReadInt32 ();  						var stBoneStateChangeOffset = vbr.ReadInt32 ();  						// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  						if ((stFlags & VTXStripGroupTriListFlag) > 0) {  							for (var j = stIndexOffset; j < stIndexOffset + numStIndices; j++) {  								mesh.Mesh.Points.Add (vertinfo [indices [j]]);  								//mesh.Vertices.Add(vertices[vertinfo[indices[j]]]);  							}  						} else if ((stFlags & VTXStripGroupTriStripFlag) > 0) {  							for (var j = stIndexOffset; j < stIndexOffset + numStIndices - 2; j++) {  								var add = j % 2 == 1 ? new[] {  									j + 1'  									j'  									j + 2  								} : new[] {  									j'  									j + 1'  									j + 2  								};  								foreach (var idx in add) {  									mesh.Mesh.Points.Add (vertinfo [indices [idx]]);  									//mesh.Vertices.Add(vertices[vertinfo[indices[idx]]]);  								}  							}  						}  					}  					// Strips  				}  				// Strip Groups  				modelData.Meshes.Add (mesh);  			}  			// Meshes  		}  		// LODs  	}  	// Models  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceMeshData,The following statement contains a magic number: for (var mdl = 0; mdl < numModels; mdl++) {  	vbr.BaseStream.Position = posmdl;  	var numLod = vbr.ReadInt32 ();  	var lodOffset = vbr.ReadInt32 ();  	var poslod = posmdl + lodOffset;  	posmdl = vbr.BaseStream.Position;  	// LODS  	for (var lod = 0; lod < numLod; lod++) {  		vbr.BaseStream.Position = poslod;  		var meshNum = vbr.ReadInt32 ();  		var meshOffset = vbr.ReadInt32 ();  		var switchPoint = vbr.ReadSingle ();  		var posmesh = poslod + meshOffset;  		poslod = vbr.BaseStream.Position;  		// MESHES  		for (var msh = 0; msh < meshNum; msh++) {  			vbr.BaseStream.Position = posmesh;  			var sgNum = vbr.ReadInt32 ();  			var sgOffset = vbr.ReadInt32 ();  			var meshFlags = vbr.ReadByte ();  			var possg = posmesh + sgOffset;  			posmesh = vbr.BaseStream.Position;  			var mesh = new VTXModel (bp' mdl' lod' msh);  			// STRIP GROUPS  			for (var sg = 0; sg < sgNum; sg++) {  				vbr.BaseStream.Position = possg;  				var vertNum = vbr.ReadInt32 ();  				var vertOffset = vbr.ReadInt32 ();  				var indexNum = vbr.ReadInt32 ();  				var indexOffset = vbr.ReadInt32 ();  				var stripNum = vbr.ReadInt32 ();  				var stripOffset = vbr.ReadInt32 ();  				var sgFlags = vbr.ReadByte ();  				// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  				var posvert = possg + vertOffset;  				var posidx = possg + indexOffset;  				var posstrip = possg + stripOffset;  				possg = vbr.BaseStream.Position;  				var vertinfo = new List<VTXPoint> ();  				vbr.BaseStream.Position = posvert;  				for (var vert = 0; vert < vertNum; vert++) {  					var boneWeightIndices = vbr.ReadBytes (3);  					var numBones = vbr.ReadByte ();  					var meshVertex = vbr.ReadInt16 ();  					var boneIDs = vbr.ReadBytes (3);  					vertinfo.Add (new VTXPoint (boneWeightIndices' numBones' meshVertex' boneIDs));  				}  				vbr.BaseStream.Position = posidx;  				var indices = vbr.ReadShortArray (indexNum);  				// The strips hold info about whether this is a triangle strip or just a list  				vbr.BaseStream.Position = posstrip;  				for (var st = 0; st < stripNum; st++) {  					var numStIndices = vbr.ReadInt32 ();  					var stIndexOffset = vbr.ReadInt32 ();  					var numStVerts = vbr.ReadInt32 ();  					var stVertOffset = vbr.ReadInt32 ();  					var numStBones = vbr.ReadInt16 ();  					var stFlags = vbr.ReadByte ();  					var numStBoneStateChanges = vbr.ReadInt32 ();  					var stBoneStateChangeOffset = vbr.ReadInt32 ();  					// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  					if ((stFlags & VTXStripGroupTriListFlag) > 0) {  						for (var j = stIndexOffset; j < stIndexOffset + numStIndices; j++) {  							mesh.Mesh.Points.Add (vertinfo [indices [j]]);  							//mesh.Vertices.Add(vertices[vertinfo[indices[j]]]);  						}  					} else if ((stFlags & VTXStripGroupTriStripFlag) > 0) {  						for (var j = stIndexOffset; j < stIndexOffset + numStIndices - 2; j++) {  							var add = j % 2 == 1 ? new[] {  								j + 1'  								j'  								j + 2  							} : new[] {  								j'  								j + 1'  								j + 2  							};  							foreach (var idx in add) {  								mesh.Mesh.Points.Add (vertinfo [indices [idx]]);  								//mesh.Vertices.Add(vertices[vertinfo[indices[idx]]]);  							}  						}  					}  				}  				// Strips  			}  			// Strip Groups  			modelData.Meshes.Add (mesh);  		}  		// Meshes  	}  	// LODs  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceMeshData,The following statement contains a magic number: for (var mdl = 0; mdl < numModels; mdl++) {  	vbr.BaseStream.Position = posmdl;  	var numLod = vbr.ReadInt32 ();  	var lodOffset = vbr.ReadInt32 ();  	var poslod = posmdl + lodOffset;  	posmdl = vbr.BaseStream.Position;  	// LODS  	for (var lod = 0; lod < numLod; lod++) {  		vbr.BaseStream.Position = poslod;  		var meshNum = vbr.ReadInt32 ();  		var meshOffset = vbr.ReadInt32 ();  		var switchPoint = vbr.ReadSingle ();  		var posmesh = poslod + meshOffset;  		poslod = vbr.BaseStream.Position;  		// MESHES  		for (var msh = 0; msh < meshNum; msh++) {  			vbr.BaseStream.Position = posmesh;  			var sgNum = vbr.ReadInt32 ();  			var sgOffset = vbr.ReadInt32 ();  			var meshFlags = vbr.ReadByte ();  			var possg = posmesh + sgOffset;  			posmesh = vbr.BaseStream.Position;  			var mesh = new VTXModel (bp' mdl' lod' msh);  			// STRIP GROUPS  			for (var sg = 0; sg < sgNum; sg++) {  				vbr.BaseStream.Position = possg;  				var vertNum = vbr.ReadInt32 ();  				var vertOffset = vbr.ReadInt32 ();  				var indexNum = vbr.ReadInt32 ();  				var indexOffset = vbr.ReadInt32 ();  				var stripNum = vbr.ReadInt32 ();  				var stripOffset = vbr.ReadInt32 ();  				var sgFlags = vbr.ReadByte ();  				// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  				var posvert = possg + vertOffset;  				var posidx = possg + indexOffset;  				var posstrip = possg + stripOffset;  				possg = vbr.BaseStream.Position;  				var vertinfo = new List<VTXPoint> ();  				vbr.BaseStream.Position = posvert;  				for (var vert = 0; vert < vertNum; vert++) {  					var boneWeightIndices = vbr.ReadBytes (3);  					var numBones = vbr.ReadByte ();  					var meshVertex = vbr.ReadInt16 ();  					var boneIDs = vbr.ReadBytes (3);  					vertinfo.Add (new VTXPoint (boneWeightIndices' numBones' meshVertex' boneIDs));  				}  				vbr.BaseStream.Position = posidx;  				var indices = vbr.ReadShortArray (indexNum);  				// The strips hold info about whether this is a triangle strip or just a list  				vbr.BaseStream.Position = posstrip;  				for (var st = 0; st < stripNum; st++) {  					var numStIndices = vbr.ReadInt32 ();  					var stIndexOffset = vbr.ReadInt32 ();  					var numStVerts = vbr.ReadInt32 ();  					var stVertOffset = vbr.ReadInt32 ();  					var numStBones = vbr.ReadInt16 ();  					var stFlags = vbr.ReadByte ();  					var numStBoneStateChanges = vbr.ReadInt32 ();  					var stBoneStateChangeOffset = vbr.ReadInt32 ();  					// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  					if ((stFlags & VTXStripGroupTriListFlag) > 0) {  						for (var j = stIndexOffset; j < stIndexOffset + numStIndices; j++) {  							mesh.Mesh.Points.Add (vertinfo [indices [j]]);  							//mesh.Vertices.Add(vertices[vertinfo[indices[j]]]);  						}  					} else if ((stFlags & VTXStripGroupTriStripFlag) > 0) {  						for (var j = stIndexOffset; j < stIndexOffset + numStIndices - 2; j++) {  							var add = j % 2 == 1 ? new[] {  								j + 1'  								j'  								j + 2  							} : new[] {  								j'  								j + 1'  								j + 2  							};  							foreach (var idx in add) {  								mesh.Mesh.Points.Add (vertinfo [indices [idx]]);  								//mesh.Vertices.Add(vertices[vertinfo[indices[idx]]]);  							}  						}  					}  				}  				// Strips  			}  			// Strip Groups  			modelData.Meshes.Add (mesh);  		}  		// Meshes  	}  	// LODs  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceMeshData,The following statement contains a magic number: for (var mdl = 0; mdl < numModels; mdl++) {  	vbr.BaseStream.Position = posmdl;  	var numLod = vbr.ReadInt32 ();  	var lodOffset = vbr.ReadInt32 ();  	var poslod = posmdl + lodOffset;  	posmdl = vbr.BaseStream.Position;  	// LODS  	for (var lod = 0; lod < numLod; lod++) {  		vbr.BaseStream.Position = poslod;  		var meshNum = vbr.ReadInt32 ();  		var meshOffset = vbr.ReadInt32 ();  		var switchPoint = vbr.ReadSingle ();  		var posmesh = poslod + meshOffset;  		poslod = vbr.BaseStream.Position;  		// MESHES  		for (var msh = 0; msh < meshNum; msh++) {  			vbr.BaseStream.Position = posmesh;  			var sgNum = vbr.ReadInt32 ();  			var sgOffset = vbr.ReadInt32 ();  			var meshFlags = vbr.ReadByte ();  			var possg = posmesh + sgOffset;  			posmesh = vbr.BaseStream.Position;  			var mesh = new VTXModel (bp' mdl' lod' msh);  			// STRIP GROUPS  			for (var sg = 0; sg < sgNum; sg++) {  				vbr.BaseStream.Position = possg;  				var vertNum = vbr.ReadInt32 ();  				var vertOffset = vbr.ReadInt32 ();  				var indexNum = vbr.ReadInt32 ();  				var indexOffset = vbr.ReadInt32 ();  				var stripNum = vbr.ReadInt32 ();  				var stripOffset = vbr.ReadInt32 ();  				var sgFlags = vbr.ReadByte ();  				// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  				var posvert = possg + vertOffset;  				var posidx = possg + indexOffset;  				var posstrip = possg + stripOffset;  				possg = vbr.BaseStream.Position;  				var vertinfo = new List<VTXPoint> ();  				vbr.BaseStream.Position = posvert;  				for (var vert = 0; vert < vertNum; vert++) {  					var boneWeightIndices = vbr.ReadBytes (3);  					var numBones = vbr.ReadByte ();  					var meshVertex = vbr.ReadInt16 ();  					var boneIDs = vbr.ReadBytes (3);  					vertinfo.Add (new VTXPoint (boneWeightIndices' numBones' meshVertex' boneIDs));  				}  				vbr.BaseStream.Position = posidx;  				var indices = vbr.ReadShortArray (indexNum);  				// The strips hold info about whether this is a triangle strip or just a list  				vbr.BaseStream.Position = posstrip;  				for (var st = 0; st < stripNum; st++) {  					var numStIndices = vbr.ReadInt32 ();  					var stIndexOffset = vbr.ReadInt32 ();  					var numStVerts = vbr.ReadInt32 ();  					var stVertOffset = vbr.ReadInt32 ();  					var numStBones = vbr.ReadInt16 ();  					var stFlags = vbr.ReadByte ();  					var numStBoneStateChanges = vbr.ReadInt32 ();  					var stBoneStateChangeOffset = vbr.ReadInt32 ();  					// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  					if ((stFlags & VTXStripGroupTriListFlag) > 0) {  						for (var j = stIndexOffset; j < stIndexOffset + numStIndices; j++) {  							mesh.Mesh.Points.Add (vertinfo [indices [j]]);  							//mesh.Vertices.Add(vertices[vertinfo[indices[j]]]);  						}  					} else if ((stFlags & VTXStripGroupTriStripFlag) > 0) {  						for (var j = stIndexOffset; j < stIndexOffset + numStIndices - 2; j++) {  							var add = j % 2 == 1 ? new[] {  								j + 1'  								j'  								j + 2  							} : new[] {  								j'  								j + 1'  								j + 2  							};  							foreach (var idx in add) {  								mesh.Mesh.Points.Add (vertinfo [indices [idx]]);  								//mesh.Vertices.Add(vertices[vertinfo[indices[idx]]]);  							}  						}  					}  				}  				// Strips  			}  			// Strip Groups  			modelData.Meshes.Add (mesh);  		}  		// Meshes  	}  	// LODs  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceMeshData,The following statement contains a magic number: for (var mdl = 0; mdl < numModels; mdl++) {  	vbr.BaseStream.Position = posmdl;  	var numLod = vbr.ReadInt32 ();  	var lodOffset = vbr.ReadInt32 ();  	var poslod = posmdl + lodOffset;  	posmdl = vbr.BaseStream.Position;  	// LODS  	for (var lod = 0; lod < numLod; lod++) {  		vbr.BaseStream.Position = poslod;  		var meshNum = vbr.ReadInt32 ();  		var meshOffset = vbr.ReadInt32 ();  		var switchPoint = vbr.ReadSingle ();  		var posmesh = poslod + meshOffset;  		poslod = vbr.BaseStream.Position;  		// MESHES  		for (var msh = 0; msh < meshNum; msh++) {  			vbr.BaseStream.Position = posmesh;  			var sgNum = vbr.ReadInt32 ();  			var sgOffset = vbr.ReadInt32 ();  			var meshFlags = vbr.ReadByte ();  			var possg = posmesh + sgOffset;  			posmesh = vbr.BaseStream.Position;  			var mesh = new VTXModel (bp' mdl' lod' msh);  			// STRIP GROUPS  			for (var sg = 0; sg < sgNum; sg++) {  				vbr.BaseStream.Position = possg;  				var vertNum = vbr.ReadInt32 ();  				var vertOffset = vbr.ReadInt32 ();  				var indexNum = vbr.ReadInt32 ();  				var indexOffset = vbr.ReadInt32 ();  				var stripNum = vbr.ReadInt32 ();  				var stripOffset = vbr.ReadInt32 ();  				var sgFlags = vbr.ReadByte ();  				// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  				var posvert = possg + vertOffset;  				var posidx = possg + indexOffset;  				var posstrip = possg + stripOffset;  				possg = vbr.BaseStream.Position;  				var vertinfo = new List<VTXPoint> ();  				vbr.BaseStream.Position = posvert;  				for (var vert = 0; vert < vertNum; vert++) {  					var boneWeightIndices = vbr.ReadBytes (3);  					var numBones = vbr.ReadByte ();  					var meshVertex = vbr.ReadInt16 ();  					var boneIDs = vbr.ReadBytes (3);  					vertinfo.Add (new VTXPoint (boneWeightIndices' numBones' meshVertex' boneIDs));  				}  				vbr.BaseStream.Position = posidx;  				var indices = vbr.ReadShortArray (indexNum);  				// The strips hold info about whether this is a triangle strip or just a list  				vbr.BaseStream.Position = posstrip;  				for (var st = 0; st < stripNum; st++) {  					var numStIndices = vbr.ReadInt32 ();  					var stIndexOffset = vbr.ReadInt32 ();  					var numStVerts = vbr.ReadInt32 ();  					var stVertOffset = vbr.ReadInt32 ();  					var numStBones = vbr.ReadInt16 ();  					var stFlags = vbr.ReadByte ();  					var numStBoneStateChanges = vbr.ReadInt32 ();  					var stBoneStateChangeOffset = vbr.ReadInt32 ();  					// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  					if ((stFlags & VTXStripGroupTriListFlag) > 0) {  						for (var j = stIndexOffset; j < stIndexOffset + numStIndices; j++) {  							mesh.Mesh.Points.Add (vertinfo [indices [j]]);  							//mesh.Vertices.Add(vertices[vertinfo[indices[j]]]);  						}  					} else if ((stFlags & VTXStripGroupTriStripFlag) > 0) {  						for (var j = stIndexOffset; j < stIndexOffset + numStIndices - 2; j++) {  							var add = j % 2 == 1 ? new[] {  								j + 1'  								j'  								j + 2  							} : new[] {  								j'  								j + 1'  								j + 2  							};  							foreach (var idx in add) {  								mesh.Mesh.Points.Add (vertinfo [indices [idx]]);  								//mesh.Vertices.Add(vertices[vertinfo[indices[idx]]]);  							}  						}  					}  				}  				// Strips  			}  			// Strip Groups  			modelData.Meshes.Add (mesh);  		}  		// Meshes  	}  	// LODs  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceMeshData,The following statement contains a magic number: for (var mdl = 0; mdl < numModels; mdl++) {  	vbr.BaseStream.Position = posmdl;  	var numLod = vbr.ReadInt32 ();  	var lodOffset = vbr.ReadInt32 ();  	var poslod = posmdl + lodOffset;  	posmdl = vbr.BaseStream.Position;  	// LODS  	for (var lod = 0; lod < numLod; lod++) {  		vbr.BaseStream.Position = poslod;  		var meshNum = vbr.ReadInt32 ();  		var meshOffset = vbr.ReadInt32 ();  		var switchPoint = vbr.ReadSingle ();  		var posmesh = poslod + meshOffset;  		poslod = vbr.BaseStream.Position;  		// MESHES  		for (var msh = 0; msh < meshNum; msh++) {  			vbr.BaseStream.Position = posmesh;  			var sgNum = vbr.ReadInt32 ();  			var sgOffset = vbr.ReadInt32 ();  			var meshFlags = vbr.ReadByte ();  			var possg = posmesh + sgOffset;  			posmesh = vbr.BaseStream.Position;  			var mesh = new VTXModel (bp' mdl' lod' msh);  			// STRIP GROUPS  			for (var sg = 0; sg < sgNum; sg++) {  				vbr.BaseStream.Position = possg;  				var vertNum = vbr.ReadInt32 ();  				var vertOffset = vbr.ReadInt32 ();  				var indexNum = vbr.ReadInt32 ();  				var indexOffset = vbr.ReadInt32 ();  				var stripNum = vbr.ReadInt32 ();  				var stripOffset = vbr.ReadInt32 ();  				var sgFlags = vbr.ReadByte ();  				// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  				var posvert = possg + vertOffset;  				var posidx = possg + indexOffset;  				var posstrip = possg + stripOffset;  				possg = vbr.BaseStream.Position;  				var vertinfo = new List<VTXPoint> ();  				vbr.BaseStream.Position = posvert;  				for (var vert = 0; vert < vertNum; vert++) {  					var boneWeightIndices = vbr.ReadBytes (3);  					var numBones = vbr.ReadByte ();  					var meshVertex = vbr.ReadInt16 ();  					var boneIDs = vbr.ReadBytes (3);  					vertinfo.Add (new VTXPoint (boneWeightIndices' numBones' meshVertex' boneIDs));  				}  				vbr.BaseStream.Position = posidx;  				var indices = vbr.ReadShortArray (indexNum);  				// The strips hold info about whether this is a triangle strip or just a list  				vbr.BaseStream.Position = posstrip;  				for (var st = 0; st < stripNum; st++) {  					var numStIndices = vbr.ReadInt32 ();  					var stIndexOffset = vbr.ReadInt32 ();  					var numStVerts = vbr.ReadInt32 ();  					var stVertOffset = vbr.ReadInt32 ();  					var numStBones = vbr.ReadInt16 ();  					var stFlags = vbr.ReadByte ();  					var numStBoneStateChanges = vbr.ReadInt32 ();  					var stBoneStateChangeOffset = vbr.ReadInt32 ();  					// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  					if ((stFlags & VTXStripGroupTriListFlag) > 0) {  						for (var j = stIndexOffset; j < stIndexOffset + numStIndices; j++) {  							mesh.Mesh.Points.Add (vertinfo [indices [j]]);  							//mesh.Vertices.Add(vertices[vertinfo[indices[j]]]);  						}  					} else if ((stFlags & VTXStripGroupTriStripFlag) > 0) {  						for (var j = stIndexOffset; j < stIndexOffset + numStIndices - 2; j++) {  							var add = j % 2 == 1 ? new[] {  								j + 1'  								j'  								j + 2  							} : new[] {  								j'  								j + 1'  								j + 2  							};  							foreach (var idx in add) {  								mesh.Mesh.Points.Add (vertinfo [indices [idx]]);  								//mesh.Vertices.Add(vertices[vertinfo[indices[idx]]]);  							}  						}  					}  				}  				// Strips  			}  			// Strip Groups  			modelData.Meshes.Add (mesh);  		}  		// Meshes  	}  	// LODs  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceMeshData,The following statement contains a magic number: for (var mdl = 0; mdl < numModels; mdl++) {  	vbr.BaseStream.Position = posmdl;  	var numLod = vbr.ReadInt32 ();  	var lodOffset = vbr.ReadInt32 ();  	var poslod = posmdl + lodOffset;  	posmdl = vbr.BaseStream.Position;  	// LODS  	for (var lod = 0; lod < numLod; lod++) {  		vbr.BaseStream.Position = poslod;  		var meshNum = vbr.ReadInt32 ();  		var meshOffset = vbr.ReadInt32 ();  		var switchPoint = vbr.ReadSingle ();  		var posmesh = poslod + meshOffset;  		poslod = vbr.BaseStream.Position;  		// MESHES  		for (var msh = 0; msh < meshNum; msh++) {  			vbr.BaseStream.Position = posmesh;  			var sgNum = vbr.ReadInt32 ();  			var sgOffset = vbr.ReadInt32 ();  			var meshFlags = vbr.ReadByte ();  			var possg = posmesh + sgOffset;  			posmesh = vbr.BaseStream.Position;  			var mesh = new VTXModel (bp' mdl' lod' msh);  			// STRIP GROUPS  			for (var sg = 0; sg < sgNum; sg++) {  				vbr.BaseStream.Position = possg;  				var vertNum = vbr.ReadInt32 ();  				var vertOffset = vbr.ReadInt32 ();  				var indexNum = vbr.ReadInt32 ();  				var indexOffset = vbr.ReadInt32 ();  				var stripNum = vbr.ReadInt32 ();  				var stripOffset = vbr.ReadInt32 ();  				var sgFlags = vbr.ReadByte ();  				// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  				var posvert = possg + vertOffset;  				var posidx = possg + indexOffset;  				var posstrip = possg + stripOffset;  				possg = vbr.BaseStream.Position;  				var vertinfo = new List<VTXPoint> ();  				vbr.BaseStream.Position = posvert;  				for (var vert = 0; vert < vertNum; vert++) {  					var boneWeightIndices = vbr.ReadBytes (3);  					var numBones = vbr.ReadByte ();  					var meshVertex = vbr.ReadInt16 ();  					var boneIDs = vbr.ReadBytes (3);  					vertinfo.Add (new VTXPoint (boneWeightIndices' numBones' meshVertex' boneIDs));  				}  				vbr.BaseStream.Position = posidx;  				var indices = vbr.ReadShortArray (indexNum);  				// The strips hold info about whether this is a triangle strip or just a list  				vbr.BaseStream.Position = posstrip;  				for (var st = 0; st < stripNum; st++) {  					var numStIndices = vbr.ReadInt32 ();  					var stIndexOffset = vbr.ReadInt32 ();  					var numStVerts = vbr.ReadInt32 ();  					var stVertOffset = vbr.ReadInt32 ();  					var numStBones = vbr.ReadInt16 ();  					var stFlags = vbr.ReadByte ();  					var numStBoneStateChanges = vbr.ReadInt32 ();  					var stBoneStateChangeOffset = vbr.ReadInt32 ();  					// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  					if ((stFlags & VTXStripGroupTriListFlag) > 0) {  						for (var j = stIndexOffset; j < stIndexOffset + numStIndices; j++) {  							mesh.Mesh.Points.Add (vertinfo [indices [j]]);  							//mesh.Vertices.Add(vertices[vertinfo[indices[j]]]);  						}  					} else if ((stFlags & VTXStripGroupTriStripFlag) > 0) {  						for (var j = stIndexOffset; j < stIndexOffset + numStIndices - 2; j++) {  							var add = j % 2 == 1 ? new[] {  								j + 1'  								j'  								j + 2  							} : new[] {  								j'  								j + 1'  								j + 2  							};  							foreach (var idx in add) {  								mesh.Mesh.Points.Add (vertinfo [indices [idx]]);  								//mesh.Vertices.Add(vertices[vertinfo[indices[idx]]]);  							}  						}  					}  				}  				// Strips  			}  			// Strip Groups  			modelData.Meshes.Add (mesh);  		}  		// Meshes  	}  	// LODs  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceMeshData,The following statement contains a magic number: for (var lod = 0; lod < numLod; lod++) {  	vbr.BaseStream.Position = poslod;  	var meshNum = vbr.ReadInt32 ();  	var meshOffset = vbr.ReadInt32 ();  	var switchPoint = vbr.ReadSingle ();  	var posmesh = poslod + meshOffset;  	poslod = vbr.BaseStream.Position;  	// MESHES  	for (var msh = 0; msh < meshNum; msh++) {  		vbr.BaseStream.Position = posmesh;  		var sgNum = vbr.ReadInt32 ();  		var sgOffset = vbr.ReadInt32 ();  		var meshFlags = vbr.ReadByte ();  		var possg = posmesh + sgOffset;  		posmesh = vbr.BaseStream.Position;  		var mesh = new VTXModel (bp' mdl' lod' msh);  		// STRIP GROUPS  		for (var sg = 0; sg < sgNum; sg++) {  			vbr.BaseStream.Position = possg;  			var vertNum = vbr.ReadInt32 ();  			var vertOffset = vbr.ReadInt32 ();  			var indexNum = vbr.ReadInt32 ();  			var indexOffset = vbr.ReadInt32 ();  			var stripNum = vbr.ReadInt32 ();  			var stripOffset = vbr.ReadInt32 ();  			var sgFlags = vbr.ReadByte ();  			// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  			var posvert = possg + vertOffset;  			var posidx = possg + indexOffset;  			var posstrip = possg + stripOffset;  			possg = vbr.BaseStream.Position;  			var vertinfo = new List<VTXPoint> ();  			vbr.BaseStream.Position = posvert;  			for (var vert = 0; vert < vertNum; vert++) {  				var boneWeightIndices = vbr.ReadBytes (3);  				var numBones = vbr.ReadByte ();  				var meshVertex = vbr.ReadInt16 ();  				var boneIDs = vbr.ReadBytes (3);  				vertinfo.Add (new VTXPoint (boneWeightIndices' numBones' meshVertex' boneIDs));  			}  			vbr.BaseStream.Position = posidx;  			var indices = vbr.ReadShortArray (indexNum);  			// The strips hold info about whether this is a triangle strip or just a list  			vbr.BaseStream.Position = posstrip;  			for (var st = 0; st < stripNum; st++) {  				var numStIndices = vbr.ReadInt32 ();  				var stIndexOffset = vbr.ReadInt32 ();  				var numStVerts = vbr.ReadInt32 ();  				var stVertOffset = vbr.ReadInt32 ();  				var numStBones = vbr.ReadInt16 ();  				var stFlags = vbr.ReadByte ();  				var numStBoneStateChanges = vbr.ReadInt32 ();  				var stBoneStateChangeOffset = vbr.ReadInt32 ();  				// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  				if ((stFlags & VTXStripGroupTriListFlag) > 0) {  					for (var j = stIndexOffset; j < stIndexOffset + numStIndices; j++) {  						mesh.Mesh.Points.Add (vertinfo [indices [j]]);  						//mesh.Vertices.Add(vertices[vertinfo[indices[j]]]);  					}  				} else if ((stFlags & VTXStripGroupTriStripFlag) > 0) {  					for (var j = stIndexOffset; j < stIndexOffset + numStIndices - 2; j++) {  						var add = j % 2 == 1 ? new[] {  							j + 1'  							j'  							j + 2  						} : new[] {  							j'  							j + 1'  							j + 2  						};  						foreach (var idx in add) {  							mesh.Mesh.Points.Add (vertinfo [indices [idx]]);  							//mesh.Vertices.Add(vertices[vertinfo[indices[idx]]]);  						}  					}  				}  			}  			// Strips  		}  		// Strip Groups  		modelData.Meshes.Add (mesh);  	}  	// Meshes  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceMeshData,The following statement contains a magic number: for (var lod = 0; lod < numLod; lod++) {  	vbr.BaseStream.Position = poslod;  	var meshNum = vbr.ReadInt32 ();  	var meshOffset = vbr.ReadInt32 ();  	var switchPoint = vbr.ReadSingle ();  	var posmesh = poslod + meshOffset;  	poslod = vbr.BaseStream.Position;  	// MESHES  	for (var msh = 0; msh < meshNum; msh++) {  		vbr.BaseStream.Position = posmesh;  		var sgNum = vbr.ReadInt32 ();  		var sgOffset = vbr.ReadInt32 ();  		var meshFlags = vbr.ReadByte ();  		var possg = posmesh + sgOffset;  		posmesh = vbr.BaseStream.Position;  		var mesh = new VTXModel (bp' mdl' lod' msh);  		// STRIP GROUPS  		for (var sg = 0; sg < sgNum; sg++) {  			vbr.BaseStream.Position = possg;  			var vertNum = vbr.ReadInt32 ();  			var vertOffset = vbr.ReadInt32 ();  			var indexNum = vbr.ReadInt32 ();  			var indexOffset = vbr.ReadInt32 ();  			var stripNum = vbr.ReadInt32 ();  			var stripOffset = vbr.ReadInt32 ();  			var sgFlags = vbr.ReadByte ();  			// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  			var posvert = possg + vertOffset;  			var posidx = possg + indexOffset;  			var posstrip = possg + stripOffset;  			possg = vbr.BaseStream.Position;  			var vertinfo = new List<VTXPoint> ();  			vbr.BaseStream.Position = posvert;  			for (var vert = 0; vert < vertNum; vert++) {  				var boneWeightIndices = vbr.ReadBytes (3);  				var numBones = vbr.ReadByte ();  				var meshVertex = vbr.ReadInt16 ();  				var boneIDs = vbr.ReadBytes (3);  				vertinfo.Add (new VTXPoint (boneWeightIndices' numBones' meshVertex' boneIDs));  			}  			vbr.BaseStream.Position = posidx;  			var indices = vbr.ReadShortArray (indexNum);  			// The strips hold info about whether this is a triangle strip or just a list  			vbr.BaseStream.Position = posstrip;  			for (var st = 0; st < stripNum; st++) {  				var numStIndices = vbr.ReadInt32 ();  				var stIndexOffset = vbr.ReadInt32 ();  				var numStVerts = vbr.ReadInt32 ();  				var stVertOffset = vbr.ReadInt32 ();  				var numStBones = vbr.ReadInt16 ();  				var stFlags = vbr.ReadByte ();  				var numStBoneStateChanges = vbr.ReadInt32 ();  				var stBoneStateChangeOffset = vbr.ReadInt32 ();  				// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  				if ((stFlags & VTXStripGroupTriListFlag) > 0) {  					for (var j = stIndexOffset; j < stIndexOffset + numStIndices; j++) {  						mesh.Mesh.Points.Add (vertinfo [indices [j]]);  						//mesh.Vertices.Add(vertices[vertinfo[indices[j]]]);  					}  				} else if ((stFlags & VTXStripGroupTriStripFlag) > 0) {  					for (var j = stIndexOffset; j < stIndexOffset + numStIndices - 2; j++) {  						var add = j % 2 == 1 ? new[] {  							j + 1'  							j'  							j + 2  						} : new[] {  							j'  							j + 1'  							j + 2  						};  						foreach (var idx in add) {  							mesh.Mesh.Points.Add (vertinfo [indices [idx]]);  							//mesh.Vertices.Add(vertices[vertinfo[indices[idx]]]);  						}  					}  				}  			}  			// Strips  		}  		// Strip Groups  		modelData.Meshes.Add (mesh);  	}  	// Meshes  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceMeshData,The following statement contains a magic number: for (var lod = 0; lod < numLod; lod++) {  	vbr.BaseStream.Position = poslod;  	var meshNum = vbr.ReadInt32 ();  	var meshOffset = vbr.ReadInt32 ();  	var switchPoint = vbr.ReadSingle ();  	var posmesh = poslod + meshOffset;  	poslod = vbr.BaseStream.Position;  	// MESHES  	for (var msh = 0; msh < meshNum; msh++) {  		vbr.BaseStream.Position = posmesh;  		var sgNum = vbr.ReadInt32 ();  		var sgOffset = vbr.ReadInt32 ();  		var meshFlags = vbr.ReadByte ();  		var possg = posmesh + sgOffset;  		posmesh = vbr.BaseStream.Position;  		var mesh = new VTXModel (bp' mdl' lod' msh);  		// STRIP GROUPS  		for (var sg = 0; sg < sgNum; sg++) {  			vbr.BaseStream.Position = possg;  			var vertNum = vbr.ReadInt32 ();  			var vertOffset = vbr.ReadInt32 ();  			var indexNum = vbr.ReadInt32 ();  			var indexOffset = vbr.ReadInt32 ();  			var stripNum = vbr.ReadInt32 ();  			var stripOffset = vbr.ReadInt32 ();  			var sgFlags = vbr.ReadByte ();  			// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  			var posvert = possg + vertOffset;  			var posidx = possg + indexOffset;  			var posstrip = possg + stripOffset;  			possg = vbr.BaseStream.Position;  			var vertinfo = new List<VTXPoint> ();  			vbr.BaseStream.Position = posvert;  			for (var vert = 0; vert < vertNum; vert++) {  				var boneWeightIndices = vbr.ReadBytes (3);  				var numBones = vbr.ReadByte ();  				var meshVertex = vbr.ReadInt16 ();  				var boneIDs = vbr.ReadBytes (3);  				vertinfo.Add (new VTXPoint (boneWeightIndices' numBones' meshVertex' boneIDs));  			}  			vbr.BaseStream.Position = posidx;  			var indices = vbr.ReadShortArray (indexNum);  			// The strips hold info about whether this is a triangle strip or just a list  			vbr.BaseStream.Position = posstrip;  			for (var st = 0; st < stripNum; st++) {  				var numStIndices = vbr.ReadInt32 ();  				var stIndexOffset = vbr.ReadInt32 ();  				var numStVerts = vbr.ReadInt32 ();  				var stVertOffset = vbr.ReadInt32 ();  				var numStBones = vbr.ReadInt16 ();  				var stFlags = vbr.ReadByte ();  				var numStBoneStateChanges = vbr.ReadInt32 ();  				var stBoneStateChangeOffset = vbr.ReadInt32 ();  				// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  				if ((stFlags & VTXStripGroupTriListFlag) > 0) {  					for (var j = stIndexOffset; j < stIndexOffset + numStIndices; j++) {  						mesh.Mesh.Points.Add (vertinfo [indices [j]]);  						//mesh.Vertices.Add(vertices[vertinfo[indices[j]]]);  					}  				} else if ((stFlags & VTXStripGroupTriStripFlag) > 0) {  					for (var j = stIndexOffset; j < stIndexOffset + numStIndices - 2; j++) {  						var add = j % 2 == 1 ? new[] {  							j + 1'  							j'  							j + 2  						} : new[] {  							j'  							j + 1'  							j + 2  						};  						foreach (var idx in add) {  							mesh.Mesh.Points.Add (vertinfo [indices [idx]]);  							//mesh.Vertices.Add(vertices[vertinfo[indices[idx]]]);  						}  					}  				}  			}  			// Strips  		}  		// Strip Groups  		modelData.Meshes.Add (mesh);  	}  	// Meshes  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceMeshData,The following statement contains a magic number: for (var lod = 0; lod < numLod; lod++) {  	vbr.BaseStream.Position = poslod;  	var meshNum = vbr.ReadInt32 ();  	var meshOffset = vbr.ReadInt32 ();  	var switchPoint = vbr.ReadSingle ();  	var posmesh = poslod + meshOffset;  	poslod = vbr.BaseStream.Position;  	// MESHES  	for (var msh = 0; msh < meshNum; msh++) {  		vbr.BaseStream.Position = posmesh;  		var sgNum = vbr.ReadInt32 ();  		var sgOffset = vbr.ReadInt32 ();  		var meshFlags = vbr.ReadByte ();  		var possg = posmesh + sgOffset;  		posmesh = vbr.BaseStream.Position;  		var mesh = new VTXModel (bp' mdl' lod' msh);  		// STRIP GROUPS  		for (var sg = 0; sg < sgNum; sg++) {  			vbr.BaseStream.Position = possg;  			var vertNum = vbr.ReadInt32 ();  			var vertOffset = vbr.ReadInt32 ();  			var indexNum = vbr.ReadInt32 ();  			var indexOffset = vbr.ReadInt32 ();  			var stripNum = vbr.ReadInt32 ();  			var stripOffset = vbr.ReadInt32 ();  			var sgFlags = vbr.ReadByte ();  			// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  			var posvert = possg + vertOffset;  			var posidx = possg + indexOffset;  			var posstrip = possg + stripOffset;  			possg = vbr.BaseStream.Position;  			var vertinfo = new List<VTXPoint> ();  			vbr.BaseStream.Position = posvert;  			for (var vert = 0; vert < vertNum; vert++) {  				var boneWeightIndices = vbr.ReadBytes (3);  				var numBones = vbr.ReadByte ();  				var meshVertex = vbr.ReadInt16 ();  				var boneIDs = vbr.ReadBytes (3);  				vertinfo.Add (new VTXPoint (boneWeightIndices' numBones' meshVertex' boneIDs));  			}  			vbr.BaseStream.Position = posidx;  			var indices = vbr.ReadShortArray (indexNum);  			// The strips hold info about whether this is a triangle strip or just a list  			vbr.BaseStream.Position = posstrip;  			for (var st = 0; st < stripNum; st++) {  				var numStIndices = vbr.ReadInt32 ();  				var stIndexOffset = vbr.ReadInt32 ();  				var numStVerts = vbr.ReadInt32 ();  				var stVertOffset = vbr.ReadInt32 ();  				var numStBones = vbr.ReadInt16 ();  				var stFlags = vbr.ReadByte ();  				var numStBoneStateChanges = vbr.ReadInt32 ();  				var stBoneStateChangeOffset = vbr.ReadInt32 ();  				// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  				if ((stFlags & VTXStripGroupTriListFlag) > 0) {  					for (var j = stIndexOffset; j < stIndexOffset + numStIndices; j++) {  						mesh.Mesh.Points.Add (vertinfo [indices [j]]);  						//mesh.Vertices.Add(vertices[vertinfo[indices[j]]]);  					}  				} else if ((stFlags & VTXStripGroupTriStripFlag) > 0) {  					for (var j = stIndexOffset; j < stIndexOffset + numStIndices - 2; j++) {  						var add = j % 2 == 1 ? new[] {  							j + 1'  							j'  							j + 2  						} : new[] {  							j'  							j + 1'  							j + 2  						};  						foreach (var idx in add) {  							mesh.Mesh.Points.Add (vertinfo [indices [idx]]);  							//mesh.Vertices.Add(vertices[vertinfo[indices[idx]]]);  						}  					}  				}  			}  			// Strips  		}  		// Strip Groups  		modelData.Meshes.Add (mesh);  	}  	// Meshes  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceMeshData,The following statement contains a magic number: for (var lod = 0; lod < numLod; lod++) {  	vbr.BaseStream.Position = poslod;  	var meshNum = vbr.ReadInt32 ();  	var meshOffset = vbr.ReadInt32 ();  	var switchPoint = vbr.ReadSingle ();  	var posmesh = poslod + meshOffset;  	poslod = vbr.BaseStream.Position;  	// MESHES  	for (var msh = 0; msh < meshNum; msh++) {  		vbr.BaseStream.Position = posmesh;  		var sgNum = vbr.ReadInt32 ();  		var sgOffset = vbr.ReadInt32 ();  		var meshFlags = vbr.ReadByte ();  		var possg = posmesh + sgOffset;  		posmesh = vbr.BaseStream.Position;  		var mesh = new VTXModel (bp' mdl' lod' msh);  		// STRIP GROUPS  		for (var sg = 0; sg < sgNum; sg++) {  			vbr.BaseStream.Position = possg;  			var vertNum = vbr.ReadInt32 ();  			var vertOffset = vbr.ReadInt32 ();  			var indexNum = vbr.ReadInt32 ();  			var indexOffset = vbr.ReadInt32 ();  			var stripNum = vbr.ReadInt32 ();  			var stripOffset = vbr.ReadInt32 ();  			var sgFlags = vbr.ReadByte ();  			// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  			var posvert = possg + vertOffset;  			var posidx = possg + indexOffset;  			var posstrip = possg + stripOffset;  			possg = vbr.BaseStream.Position;  			var vertinfo = new List<VTXPoint> ();  			vbr.BaseStream.Position = posvert;  			for (var vert = 0; vert < vertNum; vert++) {  				var boneWeightIndices = vbr.ReadBytes (3);  				var numBones = vbr.ReadByte ();  				var meshVertex = vbr.ReadInt16 ();  				var boneIDs = vbr.ReadBytes (3);  				vertinfo.Add (new VTXPoint (boneWeightIndices' numBones' meshVertex' boneIDs));  			}  			vbr.BaseStream.Position = posidx;  			var indices = vbr.ReadShortArray (indexNum);  			// The strips hold info about whether this is a triangle strip or just a list  			vbr.BaseStream.Position = posstrip;  			for (var st = 0; st < stripNum; st++) {  				var numStIndices = vbr.ReadInt32 ();  				var stIndexOffset = vbr.ReadInt32 ();  				var numStVerts = vbr.ReadInt32 ();  				var stVertOffset = vbr.ReadInt32 ();  				var numStBones = vbr.ReadInt16 ();  				var stFlags = vbr.ReadByte ();  				var numStBoneStateChanges = vbr.ReadInt32 ();  				var stBoneStateChangeOffset = vbr.ReadInt32 ();  				// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  				if ((stFlags & VTXStripGroupTriListFlag) > 0) {  					for (var j = stIndexOffset; j < stIndexOffset + numStIndices; j++) {  						mesh.Mesh.Points.Add (vertinfo [indices [j]]);  						//mesh.Vertices.Add(vertices[vertinfo[indices[j]]]);  					}  				} else if ((stFlags & VTXStripGroupTriStripFlag) > 0) {  					for (var j = stIndexOffset; j < stIndexOffset + numStIndices - 2; j++) {  						var add = j % 2 == 1 ? new[] {  							j + 1'  							j'  							j + 2  						} : new[] {  							j'  							j + 1'  							j + 2  						};  						foreach (var idx in add) {  							mesh.Mesh.Points.Add (vertinfo [indices [idx]]);  							//mesh.Vertices.Add(vertices[vertinfo[indices[idx]]]);  						}  					}  				}  			}  			// Strips  		}  		// Strip Groups  		modelData.Meshes.Add (mesh);  	}  	// Meshes  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceMeshData,The following statement contains a magic number: for (var lod = 0; lod < numLod; lod++) {  	vbr.BaseStream.Position = poslod;  	var meshNum = vbr.ReadInt32 ();  	var meshOffset = vbr.ReadInt32 ();  	var switchPoint = vbr.ReadSingle ();  	var posmesh = poslod + meshOffset;  	poslod = vbr.BaseStream.Position;  	// MESHES  	for (var msh = 0; msh < meshNum; msh++) {  		vbr.BaseStream.Position = posmesh;  		var sgNum = vbr.ReadInt32 ();  		var sgOffset = vbr.ReadInt32 ();  		var meshFlags = vbr.ReadByte ();  		var possg = posmesh + sgOffset;  		posmesh = vbr.BaseStream.Position;  		var mesh = new VTXModel (bp' mdl' lod' msh);  		// STRIP GROUPS  		for (var sg = 0; sg < sgNum; sg++) {  			vbr.BaseStream.Position = possg;  			var vertNum = vbr.ReadInt32 ();  			var vertOffset = vbr.ReadInt32 ();  			var indexNum = vbr.ReadInt32 ();  			var indexOffset = vbr.ReadInt32 ();  			var stripNum = vbr.ReadInt32 ();  			var stripOffset = vbr.ReadInt32 ();  			var sgFlags = vbr.ReadByte ();  			// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  			var posvert = possg + vertOffset;  			var posidx = possg + indexOffset;  			var posstrip = possg + stripOffset;  			possg = vbr.BaseStream.Position;  			var vertinfo = new List<VTXPoint> ();  			vbr.BaseStream.Position = posvert;  			for (var vert = 0; vert < vertNum; vert++) {  				var boneWeightIndices = vbr.ReadBytes (3);  				var numBones = vbr.ReadByte ();  				var meshVertex = vbr.ReadInt16 ();  				var boneIDs = vbr.ReadBytes (3);  				vertinfo.Add (new VTXPoint (boneWeightIndices' numBones' meshVertex' boneIDs));  			}  			vbr.BaseStream.Position = posidx;  			var indices = vbr.ReadShortArray (indexNum);  			// The strips hold info about whether this is a triangle strip or just a list  			vbr.BaseStream.Position = posstrip;  			for (var st = 0; st < stripNum; st++) {  				var numStIndices = vbr.ReadInt32 ();  				var stIndexOffset = vbr.ReadInt32 ();  				var numStVerts = vbr.ReadInt32 ();  				var stVertOffset = vbr.ReadInt32 ();  				var numStBones = vbr.ReadInt16 ();  				var stFlags = vbr.ReadByte ();  				var numStBoneStateChanges = vbr.ReadInt32 ();  				var stBoneStateChangeOffset = vbr.ReadInt32 ();  				// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  				if ((stFlags & VTXStripGroupTriListFlag) > 0) {  					for (var j = stIndexOffset; j < stIndexOffset + numStIndices; j++) {  						mesh.Mesh.Points.Add (vertinfo [indices [j]]);  						//mesh.Vertices.Add(vertices[vertinfo[indices[j]]]);  					}  				} else if ((stFlags & VTXStripGroupTriStripFlag) > 0) {  					for (var j = stIndexOffset; j < stIndexOffset + numStIndices - 2; j++) {  						var add = j % 2 == 1 ? new[] {  							j + 1'  							j'  							j + 2  						} : new[] {  							j'  							j + 1'  							j + 2  						};  						foreach (var idx in add) {  							mesh.Mesh.Points.Add (vertinfo [indices [idx]]);  							//mesh.Vertices.Add(vertices[vertinfo[indices[idx]]]);  						}  					}  				}  			}  			// Strips  		}  		// Strip Groups  		modelData.Meshes.Add (mesh);  	}  	// Meshes  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceMeshData,The following statement contains a magic number: for (var msh = 0; msh < meshNum; msh++) {  	vbr.BaseStream.Position = posmesh;  	var sgNum = vbr.ReadInt32 ();  	var sgOffset = vbr.ReadInt32 ();  	var meshFlags = vbr.ReadByte ();  	var possg = posmesh + sgOffset;  	posmesh = vbr.BaseStream.Position;  	var mesh = new VTXModel (bp' mdl' lod' msh);  	// STRIP GROUPS  	for (var sg = 0; sg < sgNum; sg++) {  		vbr.BaseStream.Position = possg;  		var vertNum = vbr.ReadInt32 ();  		var vertOffset = vbr.ReadInt32 ();  		var indexNum = vbr.ReadInt32 ();  		var indexOffset = vbr.ReadInt32 ();  		var stripNum = vbr.ReadInt32 ();  		var stripOffset = vbr.ReadInt32 ();  		var sgFlags = vbr.ReadByte ();  		// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  		var posvert = possg + vertOffset;  		var posidx = possg + indexOffset;  		var posstrip = possg + stripOffset;  		possg = vbr.BaseStream.Position;  		var vertinfo = new List<VTXPoint> ();  		vbr.BaseStream.Position = posvert;  		for (var vert = 0; vert < vertNum; vert++) {  			var boneWeightIndices = vbr.ReadBytes (3);  			var numBones = vbr.ReadByte ();  			var meshVertex = vbr.ReadInt16 ();  			var boneIDs = vbr.ReadBytes (3);  			vertinfo.Add (new VTXPoint (boneWeightIndices' numBones' meshVertex' boneIDs));  		}  		vbr.BaseStream.Position = posidx;  		var indices = vbr.ReadShortArray (indexNum);  		// The strips hold info about whether this is a triangle strip or just a list  		vbr.BaseStream.Position = posstrip;  		for (var st = 0; st < stripNum; st++) {  			var numStIndices = vbr.ReadInt32 ();  			var stIndexOffset = vbr.ReadInt32 ();  			var numStVerts = vbr.ReadInt32 ();  			var stVertOffset = vbr.ReadInt32 ();  			var numStBones = vbr.ReadInt16 ();  			var stFlags = vbr.ReadByte ();  			var numStBoneStateChanges = vbr.ReadInt32 ();  			var stBoneStateChangeOffset = vbr.ReadInt32 ();  			// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  			if ((stFlags & VTXStripGroupTriListFlag) > 0) {  				for (var j = stIndexOffset; j < stIndexOffset + numStIndices; j++) {  					mesh.Mesh.Points.Add (vertinfo [indices [j]]);  					//mesh.Vertices.Add(vertices[vertinfo[indices[j]]]);  				}  			} else if ((stFlags & VTXStripGroupTriStripFlag) > 0) {  				for (var j = stIndexOffset; j < stIndexOffset + numStIndices - 2; j++) {  					var add = j % 2 == 1 ? new[] {  						j + 1'  						j'  						j + 2  					} : new[] {  						j'  						j + 1'  						j + 2  					};  					foreach (var idx in add) {  						mesh.Mesh.Points.Add (vertinfo [indices [idx]]);  						//mesh.Vertices.Add(vertices[vertinfo[indices[idx]]]);  					}  				}  			}  		}  		// Strips  	}  	// Strip Groups  	modelData.Meshes.Add (mesh);  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceMeshData,The following statement contains a magic number: for (var msh = 0; msh < meshNum; msh++) {  	vbr.BaseStream.Position = posmesh;  	var sgNum = vbr.ReadInt32 ();  	var sgOffset = vbr.ReadInt32 ();  	var meshFlags = vbr.ReadByte ();  	var possg = posmesh + sgOffset;  	posmesh = vbr.BaseStream.Position;  	var mesh = new VTXModel (bp' mdl' lod' msh);  	// STRIP GROUPS  	for (var sg = 0; sg < sgNum; sg++) {  		vbr.BaseStream.Position = possg;  		var vertNum = vbr.ReadInt32 ();  		var vertOffset = vbr.ReadInt32 ();  		var indexNum = vbr.ReadInt32 ();  		var indexOffset = vbr.ReadInt32 ();  		var stripNum = vbr.ReadInt32 ();  		var stripOffset = vbr.ReadInt32 ();  		var sgFlags = vbr.ReadByte ();  		// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  		var posvert = possg + vertOffset;  		var posidx = possg + indexOffset;  		var posstrip = possg + stripOffset;  		possg = vbr.BaseStream.Position;  		var vertinfo = new List<VTXPoint> ();  		vbr.BaseStream.Position = posvert;  		for (var vert = 0; vert < vertNum; vert++) {  			var boneWeightIndices = vbr.ReadBytes (3);  			var numBones = vbr.ReadByte ();  			var meshVertex = vbr.ReadInt16 ();  			var boneIDs = vbr.ReadBytes (3);  			vertinfo.Add (new VTXPoint (boneWeightIndices' numBones' meshVertex' boneIDs));  		}  		vbr.BaseStream.Position = posidx;  		var indices = vbr.ReadShortArray (indexNum);  		// The strips hold info about whether this is a triangle strip or just a list  		vbr.BaseStream.Position = posstrip;  		for (var st = 0; st < stripNum; st++) {  			var numStIndices = vbr.ReadInt32 ();  			var stIndexOffset = vbr.ReadInt32 ();  			var numStVerts = vbr.ReadInt32 ();  			var stVertOffset = vbr.ReadInt32 ();  			var numStBones = vbr.ReadInt16 ();  			var stFlags = vbr.ReadByte ();  			var numStBoneStateChanges = vbr.ReadInt32 ();  			var stBoneStateChangeOffset = vbr.ReadInt32 ();  			// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  			if ((stFlags & VTXStripGroupTriListFlag) > 0) {  				for (var j = stIndexOffset; j < stIndexOffset + numStIndices; j++) {  					mesh.Mesh.Points.Add (vertinfo [indices [j]]);  					//mesh.Vertices.Add(vertices[vertinfo[indices[j]]]);  				}  			} else if ((stFlags & VTXStripGroupTriStripFlag) > 0) {  				for (var j = stIndexOffset; j < stIndexOffset + numStIndices - 2; j++) {  					var add = j % 2 == 1 ? new[] {  						j + 1'  						j'  						j + 2  					} : new[] {  						j'  						j + 1'  						j + 2  					};  					foreach (var idx in add) {  						mesh.Mesh.Points.Add (vertinfo [indices [idx]]);  						//mesh.Vertices.Add(vertices[vertinfo[indices[idx]]]);  					}  				}  			}  		}  		// Strips  	}  	// Strip Groups  	modelData.Meshes.Add (mesh);  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceMeshData,The following statement contains a magic number: for (var msh = 0; msh < meshNum; msh++) {  	vbr.BaseStream.Position = posmesh;  	var sgNum = vbr.ReadInt32 ();  	var sgOffset = vbr.ReadInt32 ();  	var meshFlags = vbr.ReadByte ();  	var possg = posmesh + sgOffset;  	posmesh = vbr.BaseStream.Position;  	var mesh = new VTXModel (bp' mdl' lod' msh);  	// STRIP GROUPS  	for (var sg = 0; sg < sgNum; sg++) {  		vbr.BaseStream.Position = possg;  		var vertNum = vbr.ReadInt32 ();  		var vertOffset = vbr.ReadInt32 ();  		var indexNum = vbr.ReadInt32 ();  		var indexOffset = vbr.ReadInt32 ();  		var stripNum = vbr.ReadInt32 ();  		var stripOffset = vbr.ReadInt32 ();  		var sgFlags = vbr.ReadByte ();  		// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  		var posvert = possg + vertOffset;  		var posidx = possg + indexOffset;  		var posstrip = possg + stripOffset;  		possg = vbr.BaseStream.Position;  		var vertinfo = new List<VTXPoint> ();  		vbr.BaseStream.Position = posvert;  		for (var vert = 0; vert < vertNum; vert++) {  			var boneWeightIndices = vbr.ReadBytes (3);  			var numBones = vbr.ReadByte ();  			var meshVertex = vbr.ReadInt16 ();  			var boneIDs = vbr.ReadBytes (3);  			vertinfo.Add (new VTXPoint (boneWeightIndices' numBones' meshVertex' boneIDs));  		}  		vbr.BaseStream.Position = posidx;  		var indices = vbr.ReadShortArray (indexNum);  		// The strips hold info about whether this is a triangle strip or just a list  		vbr.BaseStream.Position = posstrip;  		for (var st = 0; st < stripNum; st++) {  			var numStIndices = vbr.ReadInt32 ();  			var stIndexOffset = vbr.ReadInt32 ();  			var numStVerts = vbr.ReadInt32 ();  			var stVertOffset = vbr.ReadInt32 ();  			var numStBones = vbr.ReadInt16 ();  			var stFlags = vbr.ReadByte ();  			var numStBoneStateChanges = vbr.ReadInt32 ();  			var stBoneStateChangeOffset = vbr.ReadInt32 ();  			// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  			if ((stFlags & VTXStripGroupTriListFlag) > 0) {  				for (var j = stIndexOffset; j < stIndexOffset + numStIndices; j++) {  					mesh.Mesh.Points.Add (vertinfo [indices [j]]);  					//mesh.Vertices.Add(vertices[vertinfo[indices[j]]]);  				}  			} else if ((stFlags & VTXStripGroupTriStripFlag) > 0) {  				for (var j = stIndexOffset; j < stIndexOffset + numStIndices - 2; j++) {  					var add = j % 2 == 1 ? new[] {  						j + 1'  						j'  						j + 2  					} : new[] {  						j'  						j + 1'  						j + 2  					};  					foreach (var idx in add) {  						mesh.Mesh.Points.Add (vertinfo [indices [idx]]);  						//mesh.Vertices.Add(vertices[vertinfo[indices[idx]]]);  					}  				}  			}  		}  		// Strips  	}  	// Strip Groups  	modelData.Meshes.Add (mesh);  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceMeshData,The following statement contains a magic number: for (var msh = 0; msh < meshNum; msh++) {  	vbr.BaseStream.Position = posmesh;  	var sgNum = vbr.ReadInt32 ();  	var sgOffset = vbr.ReadInt32 ();  	var meshFlags = vbr.ReadByte ();  	var possg = posmesh + sgOffset;  	posmesh = vbr.BaseStream.Position;  	var mesh = new VTXModel (bp' mdl' lod' msh);  	// STRIP GROUPS  	for (var sg = 0; sg < sgNum; sg++) {  		vbr.BaseStream.Position = possg;  		var vertNum = vbr.ReadInt32 ();  		var vertOffset = vbr.ReadInt32 ();  		var indexNum = vbr.ReadInt32 ();  		var indexOffset = vbr.ReadInt32 ();  		var stripNum = vbr.ReadInt32 ();  		var stripOffset = vbr.ReadInt32 ();  		var sgFlags = vbr.ReadByte ();  		// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  		var posvert = possg + vertOffset;  		var posidx = possg + indexOffset;  		var posstrip = possg + stripOffset;  		possg = vbr.BaseStream.Position;  		var vertinfo = new List<VTXPoint> ();  		vbr.BaseStream.Position = posvert;  		for (var vert = 0; vert < vertNum; vert++) {  			var boneWeightIndices = vbr.ReadBytes (3);  			var numBones = vbr.ReadByte ();  			var meshVertex = vbr.ReadInt16 ();  			var boneIDs = vbr.ReadBytes (3);  			vertinfo.Add (new VTXPoint (boneWeightIndices' numBones' meshVertex' boneIDs));  		}  		vbr.BaseStream.Position = posidx;  		var indices = vbr.ReadShortArray (indexNum);  		// The strips hold info about whether this is a triangle strip or just a list  		vbr.BaseStream.Position = posstrip;  		for (var st = 0; st < stripNum; st++) {  			var numStIndices = vbr.ReadInt32 ();  			var stIndexOffset = vbr.ReadInt32 ();  			var numStVerts = vbr.ReadInt32 ();  			var stVertOffset = vbr.ReadInt32 ();  			var numStBones = vbr.ReadInt16 ();  			var stFlags = vbr.ReadByte ();  			var numStBoneStateChanges = vbr.ReadInt32 ();  			var stBoneStateChangeOffset = vbr.ReadInt32 ();  			// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  			if ((stFlags & VTXStripGroupTriListFlag) > 0) {  				for (var j = stIndexOffset; j < stIndexOffset + numStIndices; j++) {  					mesh.Mesh.Points.Add (vertinfo [indices [j]]);  					//mesh.Vertices.Add(vertices[vertinfo[indices[j]]]);  				}  			} else if ((stFlags & VTXStripGroupTriStripFlag) > 0) {  				for (var j = stIndexOffset; j < stIndexOffset + numStIndices - 2; j++) {  					var add = j % 2 == 1 ? new[] {  						j + 1'  						j'  						j + 2  					} : new[] {  						j'  						j + 1'  						j + 2  					};  					foreach (var idx in add) {  						mesh.Mesh.Points.Add (vertinfo [indices [idx]]);  						//mesh.Vertices.Add(vertices[vertinfo[indices[idx]]]);  					}  				}  			}  		}  		// Strips  	}  	// Strip Groups  	modelData.Meshes.Add (mesh);  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceMeshData,The following statement contains a magic number: for (var msh = 0; msh < meshNum; msh++) {  	vbr.BaseStream.Position = posmesh;  	var sgNum = vbr.ReadInt32 ();  	var sgOffset = vbr.ReadInt32 ();  	var meshFlags = vbr.ReadByte ();  	var possg = posmesh + sgOffset;  	posmesh = vbr.BaseStream.Position;  	var mesh = new VTXModel (bp' mdl' lod' msh);  	// STRIP GROUPS  	for (var sg = 0; sg < sgNum; sg++) {  		vbr.BaseStream.Position = possg;  		var vertNum = vbr.ReadInt32 ();  		var vertOffset = vbr.ReadInt32 ();  		var indexNum = vbr.ReadInt32 ();  		var indexOffset = vbr.ReadInt32 ();  		var stripNum = vbr.ReadInt32 ();  		var stripOffset = vbr.ReadInt32 ();  		var sgFlags = vbr.ReadByte ();  		// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  		var posvert = possg + vertOffset;  		var posidx = possg + indexOffset;  		var posstrip = possg + stripOffset;  		possg = vbr.BaseStream.Position;  		var vertinfo = new List<VTXPoint> ();  		vbr.BaseStream.Position = posvert;  		for (var vert = 0; vert < vertNum; vert++) {  			var boneWeightIndices = vbr.ReadBytes (3);  			var numBones = vbr.ReadByte ();  			var meshVertex = vbr.ReadInt16 ();  			var boneIDs = vbr.ReadBytes (3);  			vertinfo.Add (new VTXPoint (boneWeightIndices' numBones' meshVertex' boneIDs));  		}  		vbr.BaseStream.Position = posidx;  		var indices = vbr.ReadShortArray (indexNum);  		// The strips hold info about whether this is a triangle strip or just a list  		vbr.BaseStream.Position = posstrip;  		for (var st = 0; st < stripNum; st++) {  			var numStIndices = vbr.ReadInt32 ();  			var stIndexOffset = vbr.ReadInt32 ();  			var numStVerts = vbr.ReadInt32 ();  			var stVertOffset = vbr.ReadInt32 ();  			var numStBones = vbr.ReadInt16 ();  			var stFlags = vbr.ReadByte ();  			var numStBoneStateChanges = vbr.ReadInt32 ();  			var stBoneStateChangeOffset = vbr.ReadInt32 ();  			// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  			if ((stFlags & VTXStripGroupTriListFlag) > 0) {  				for (var j = stIndexOffset; j < stIndexOffset + numStIndices; j++) {  					mesh.Mesh.Points.Add (vertinfo [indices [j]]);  					//mesh.Vertices.Add(vertices[vertinfo[indices[j]]]);  				}  			} else if ((stFlags & VTXStripGroupTriStripFlag) > 0) {  				for (var j = stIndexOffset; j < stIndexOffset + numStIndices - 2; j++) {  					var add = j % 2 == 1 ? new[] {  						j + 1'  						j'  						j + 2  					} : new[] {  						j'  						j + 1'  						j + 2  					};  					foreach (var idx in add) {  						mesh.Mesh.Points.Add (vertinfo [indices [idx]]);  						//mesh.Vertices.Add(vertices[vertinfo[indices[idx]]]);  					}  				}  			}  		}  		// Strips  	}  	// Strip Groups  	modelData.Meshes.Add (mesh);  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceMeshData,The following statement contains a magic number: for (var msh = 0; msh < meshNum; msh++) {  	vbr.BaseStream.Position = posmesh;  	var sgNum = vbr.ReadInt32 ();  	var sgOffset = vbr.ReadInt32 ();  	var meshFlags = vbr.ReadByte ();  	var possg = posmesh + sgOffset;  	posmesh = vbr.BaseStream.Position;  	var mesh = new VTXModel (bp' mdl' lod' msh);  	// STRIP GROUPS  	for (var sg = 0; sg < sgNum; sg++) {  		vbr.BaseStream.Position = possg;  		var vertNum = vbr.ReadInt32 ();  		var vertOffset = vbr.ReadInt32 ();  		var indexNum = vbr.ReadInt32 ();  		var indexOffset = vbr.ReadInt32 ();  		var stripNum = vbr.ReadInt32 ();  		var stripOffset = vbr.ReadInt32 ();  		var sgFlags = vbr.ReadByte ();  		// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  		var posvert = possg + vertOffset;  		var posidx = possg + indexOffset;  		var posstrip = possg + stripOffset;  		possg = vbr.BaseStream.Position;  		var vertinfo = new List<VTXPoint> ();  		vbr.BaseStream.Position = posvert;  		for (var vert = 0; vert < vertNum; vert++) {  			var boneWeightIndices = vbr.ReadBytes (3);  			var numBones = vbr.ReadByte ();  			var meshVertex = vbr.ReadInt16 ();  			var boneIDs = vbr.ReadBytes (3);  			vertinfo.Add (new VTXPoint (boneWeightIndices' numBones' meshVertex' boneIDs));  		}  		vbr.BaseStream.Position = posidx;  		var indices = vbr.ReadShortArray (indexNum);  		// The strips hold info about whether this is a triangle strip or just a list  		vbr.BaseStream.Position = posstrip;  		for (var st = 0; st < stripNum; st++) {  			var numStIndices = vbr.ReadInt32 ();  			var stIndexOffset = vbr.ReadInt32 ();  			var numStVerts = vbr.ReadInt32 ();  			var stVertOffset = vbr.ReadInt32 ();  			var numStBones = vbr.ReadInt16 ();  			var stFlags = vbr.ReadByte ();  			var numStBoneStateChanges = vbr.ReadInt32 ();  			var stBoneStateChangeOffset = vbr.ReadInt32 ();  			// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  			if ((stFlags & VTXStripGroupTriListFlag) > 0) {  				for (var j = stIndexOffset; j < stIndexOffset + numStIndices; j++) {  					mesh.Mesh.Points.Add (vertinfo [indices [j]]);  					//mesh.Vertices.Add(vertices[vertinfo[indices[j]]]);  				}  			} else if ((stFlags & VTXStripGroupTriStripFlag) > 0) {  				for (var j = stIndexOffset; j < stIndexOffset + numStIndices - 2; j++) {  					var add = j % 2 == 1 ? new[] {  						j + 1'  						j'  						j + 2  					} : new[] {  						j'  						j + 1'  						j + 2  					};  					foreach (var idx in add) {  						mesh.Mesh.Points.Add (vertinfo [indices [idx]]);  						//mesh.Vertices.Add(vertices[vertinfo[indices[idx]]]);  					}  				}  			}  		}  		// Strips  	}  	// Strip Groups  	modelData.Meshes.Add (mesh);  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceMeshData,The following statement contains a magic number: for (var sg = 0; sg < sgNum; sg++) {  	vbr.BaseStream.Position = possg;  	var vertNum = vbr.ReadInt32 ();  	var vertOffset = vbr.ReadInt32 ();  	var indexNum = vbr.ReadInt32 ();  	var indexOffset = vbr.ReadInt32 ();  	var stripNum = vbr.ReadInt32 ();  	var stripOffset = vbr.ReadInt32 ();  	var sgFlags = vbr.ReadByte ();  	// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  	var posvert = possg + vertOffset;  	var posidx = possg + indexOffset;  	var posstrip = possg + stripOffset;  	possg = vbr.BaseStream.Position;  	var vertinfo = new List<VTXPoint> ();  	vbr.BaseStream.Position = posvert;  	for (var vert = 0; vert < vertNum; vert++) {  		var boneWeightIndices = vbr.ReadBytes (3);  		var numBones = vbr.ReadByte ();  		var meshVertex = vbr.ReadInt16 ();  		var boneIDs = vbr.ReadBytes (3);  		vertinfo.Add (new VTXPoint (boneWeightIndices' numBones' meshVertex' boneIDs));  	}  	vbr.BaseStream.Position = posidx;  	var indices = vbr.ReadShortArray (indexNum);  	// The strips hold info about whether this is a triangle strip or just a list  	vbr.BaseStream.Position = posstrip;  	for (var st = 0; st < stripNum; st++) {  		var numStIndices = vbr.ReadInt32 ();  		var stIndexOffset = vbr.ReadInt32 ();  		var numStVerts = vbr.ReadInt32 ();  		var stVertOffset = vbr.ReadInt32 ();  		var numStBones = vbr.ReadInt16 ();  		var stFlags = vbr.ReadByte ();  		var numStBoneStateChanges = vbr.ReadInt32 ();  		var stBoneStateChangeOffset = vbr.ReadInt32 ();  		// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  		if ((stFlags & VTXStripGroupTriListFlag) > 0) {  			for (var j = stIndexOffset; j < stIndexOffset + numStIndices; j++) {  				mesh.Mesh.Points.Add (vertinfo [indices [j]]);  				//mesh.Vertices.Add(vertices[vertinfo[indices[j]]]);  			}  		} else if ((stFlags & VTXStripGroupTriStripFlag) > 0) {  			for (var j = stIndexOffset; j < stIndexOffset + numStIndices - 2; j++) {  				var add = j % 2 == 1 ? new[] {  					j + 1'  					j'  					j + 2  				} : new[] {  					j'  					j + 1'  					j + 2  				};  				foreach (var idx in add) {  					mesh.Mesh.Points.Add (vertinfo [indices [idx]]);  					//mesh.Vertices.Add(vertices[vertinfo[indices[idx]]]);  				}  			}  		}  	}  	// Strips  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceMeshData,The following statement contains a magic number: for (var sg = 0; sg < sgNum; sg++) {  	vbr.BaseStream.Position = possg;  	var vertNum = vbr.ReadInt32 ();  	var vertOffset = vbr.ReadInt32 ();  	var indexNum = vbr.ReadInt32 ();  	var indexOffset = vbr.ReadInt32 ();  	var stripNum = vbr.ReadInt32 ();  	var stripOffset = vbr.ReadInt32 ();  	var sgFlags = vbr.ReadByte ();  	// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  	var posvert = possg + vertOffset;  	var posidx = possg + indexOffset;  	var posstrip = possg + stripOffset;  	possg = vbr.BaseStream.Position;  	var vertinfo = new List<VTXPoint> ();  	vbr.BaseStream.Position = posvert;  	for (var vert = 0; vert < vertNum; vert++) {  		var boneWeightIndices = vbr.ReadBytes (3);  		var numBones = vbr.ReadByte ();  		var meshVertex = vbr.ReadInt16 ();  		var boneIDs = vbr.ReadBytes (3);  		vertinfo.Add (new VTXPoint (boneWeightIndices' numBones' meshVertex' boneIDs));  	}  	vbr.BaseStream.Position = posidx;  	var indices = vbr.ReadShortArray (indexNum);  	// The strips hold info about whether this is a triangle strip or just a list  	vbr.BaseStream.Position = posstrip;  	for (var st = 0; st < stripNum; st++) {  		var numStIndices = vbr.ReadInt32 ();  		var stIndexOffset = vbr.ReadInt32 ();  		var numStVerts = vbr.ReadInt32 ();  		var stVertOffset = vbr.ReadInt32 ();  		var numStBones = vbr.ReadInt16 ();  		var stFlags = vbr.ReadByte ();  		var numStBoneStateChanges = vbr.ReadInt32 ();  		var stBoneStateChangeOffset = vbr.ReadInt32 ();  		// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  		if ((stFlags & VTXStripGroupTriListFlag) > 0) {  			for (var j = stIndexOffset; j < stIndexOffset + numStIndices; j++) {  				mesh.Mesh.Points.Add (vertinfo [indices [j]]);  				//mesh.Vertices.Add(vertices[vertinfo[indices[j]]]);  			}  		} else if ((stFlags & VTXStripGroupTriStripFlag) > 0) {  			for (var j = stIndexOffset; j < stIndexOffset + numStIndices - 2; j++) {  				var add = j % 2 == 1 ? new[] {  					j + 1'  					j'  					j + 2  				} : new[] {  					j'  					j + 1'  					j + 2  				};  				foreach (var idx in add) {  					mesh.Mesh.Points.Add (vertinfo [indices [idx]]);  					//mesh.Vertices.Add(vertices[vertinfo[indices[idx]]]);  				}  			}  		}  	}  	// Strips  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceMeshData,The following statement contains a magic number: for (var sg = 0; sg < sgNum; sg++) {  	vbr.BaseStream.Position = possg;  	var vertNum = vbr.ReadInt32 ();  	var vertOffset = vbr.ReadInt32 ();  	var indexNum = vbr.ReadInt32 ();  	var indexOffset = vbr.ReadInt32 ();  	var stripNum = vbr.ReadInt32 ();  	var stripOffset = vbr.ReadInt32 ();  	var sgFlags = vbr.ReadByte ();  	// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  	var posvert = possg + vertOffset;  	var posidx = possg + indexOffset;  	var posstrip = possg + stripOffset;  	possg = vbr.BaseStream.Position;  	var vertinfo = new List<VTXPoint> ();  	vbr.BaseStream.Position = posvert;  	for (var vert = 0; vert < vertNum; vert++) {  		var boneWeightIndices = vbr.ReadBytes (3);  		var numBones = vbr.ReadByte ();  		var meshVertex = vbr.ReadInt16 ();  		var boneIDs = vbr.ReadBytes (3);  		vertinfo.Add (new VTXPoint (boneWeightIndices' numBones' meshVertex' boneIDs));  	}  	vbr.BaseStream.Position = posidx;  	var indices = vbr.ReadShortArray (indexNum);  	// The strips hold info about whether this is a triangle strip or just a list  	vbr.BaseStream.Position = posstrip;  	for (var st = 0; st < stripNum; st++) {  		var numStIndices = vbr.ReadInt32 ();  		var stIndexOffset = vbr.ReadInt32 ();  		var numStVerts = vbr.ReadInt32 ();  		var stVertOffset = vbr.ReadInt32 ();  		var numStBones = vbr.ReadInt16 ();  		var stFlags = vbr.ReadByte ();  		var numStBoneStateChanges = vbr.ReadInt32 ();  		var stBoneStateChangeOffset = vbr.ReadInt32 ();  		// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  		if ((stFlags & VTXStripGroupTriListFlag) > 0) {  			for (var j = stIndexOffset; j < stIndexOffset + numStIndices; j++) {  				mesh.Mesh.Points.Add (vertinfo [indices [j]]);  				//mesh.Vertices.Add(vertices[vertinfo[indices[j]]]);  			}  		} else if ((stFlags & VTXStripGroupTriStripFlag) > 0) {  			for (var j = stIndexOffset; j < stIndexOffset + numStIndices - 2; j++) {  				var add = j % 2 == 1 ? new[] {  					j + 1'  					j'  					j + 2  				} : new[] {  					j'  					j + 1'  					j + 2  				};  				foreach (var idx in add) {  					mesh.Mesh.Points.Add (vertinfo [indices [idx]]);  					//mesh.Vertices.Add(vertices[vertinfo[indices[idx]]]);  				}  			}  		}  	}  	// Strips  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceMeshData,The following statement contains a magic number: for (var sg = 0; sg < sgNum; sg++) {  	vbr.BaseStream.Position = possg;  	var vertNum = vbr.ReadInt32 ();  	var vertOffset = vbr.ReadInt32 ();  	var indexNum = vbr.ReadInt32 ();  	var indexOffset = vbr.ReadInt32 ();  	var stripNum = vbr.ReadInt32 ();  	var stripOffset = vbr.ReadInt32 ();  	var sgFlags = vbr.ReadByte ();  	// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  	var posvert = possg + vertOffset;  	var posidx = possg + indexOffset;  	var posstrip = possg + stripOffset;  	possg = vbr.BaseStream.Position;  	var vertinfo = new List<VTXPoint> ();  	vbr.BaseStream.Position = posvert;  	for (var vert = 0; vert < vertNum; vert++) {  		var boneWeightIndices = vbr.ReadBytes (3);  		var numBones = vbr.ReadByte ();  		var meshVertex = vbr.ReadInt16 ();  		var boneIDs = vbr.ReadBytes (3);  		vertinfo.Add (new VTXPoint (boneWeightIndices' numBones' meshVertex' boneIDs));  	}  	vbr.BaseStream.Position = posidx;  	var indices = vbr.ReadShortArray (indexNum);  	// The strips hold info about whether this is a triangle strip or just a list  	vbr.BaseStream.Position = posstrip;  	for (var st = 0; st < stripNum; st++) {  		var numStIndices = vbr.ReadInt32 ();  		var stIndexOffset = vbr.ReadInt32 ();  		var numStVerts = vbr.ReadInt32 ();  		var stVertOffset = vbr.ReadInt32 ();  		var numStBones = vbr.ReadInt16 ();  		var stFlags = vbr.ReadByte ();  		var numStBoneStateChanges = vbr.ReadInt32 ();  		var stBoneStateChangeOffset = vbr.ReadInt32 ();  		// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  		if ((stFlags & VTXStripGroupTriListFlag) > 0) {  			for (var j = stIndexOffset; j < stIndexOffset + numStIndices; j++) {  				mesh.Mesh.Points.Add (vertinfo [indices [j]]);  				//mesh.Vertices.Add(vertices[vertinfo[indices[j]]]);  			}  		} else if ((stFlags & VTXStripGroupTriStripFlag) > 0) {  			for (var j = stIndexOffset; j < stIndexOffset + numStIndices - 2; j++) {  				var add = j % 2 == 1 ? new[] {  					j + 1'  					j'  					j + 2  				} : new[] {  					j'  					j + 1'  					j + 2  				};  				foreach (var idx in add) {  					mesh.Mesh.Points.Add (vertinfo [indices [idx]]);  					//mesh.Vertices.Add(vertices[vertinfo[indices[idx]]]);  				}  			}  		}  	}  	// Strips  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceMeshData,The following statement contains a magic number: for (var sg = 0; sg < sgNum; sg++) {  	vbr.BaseStream.Position = possg;  	var vertNum = vbr.ReadInt32 ();  	var vertOffset = vbr.ReadInt32 ();  	var indexNum = vbr.ReadInt32 ();  	var indexOffset = vbr.ReadInt32 ();  	var stripNum = vbr.ReadInt32 ();  	var stripOffset = vbr.ReadInt32 ();  	var sgFlags = vbr.ReadByte ();  	// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  	var posvert = possg + vertOffset;  	var posidx = possg + indexOffset;  	var posstrip = possg + stripOffset;  	possg = vbr.BaseStream.Position;  	var vertinfo = new List<VTXPoint> ();  	vbr.BaseStream.Position = posvert;  	for (var vert = 0; vert < vertNum; vert++) {  		var boneWeightIndices = vbr.ReadBytes (3);  		var numBones = vbr.ReadByte ();  		var meshVertex = vbr.ReadInt16 ();  		var boneIDs = vbr.ReadBytes (3);  		vertinfo.Add (new VTXPoint (boneWeightIndices' numBones' meshVertex' boneIDs));  	}  	vbr.BaseStream.Position = posidx;  	var indices = vbr.ReadShortArray (indexNum);  	// The strips hold info about whether this is a triangle strip or just a list  	vbr.BaseStream.Position = posstrip;  	for (var st = 0; st < stripNum; st++) {  		var numStIndices = vbr.ReadInt32 ();  		var stIndexOffset = vbr.ReadInt32 ();  		var numStVerts = vbr.ReadInt32 ();  		var stVertOffset = vbr.ReadInt32 ();  		var numStBones = vbr.ReadInt16 ();  		var stFlags = vbr.ReadByte ();  		var numStBoneStateChanges = vbr.ReadInt32 ();  		var stBoneStateChangeOffset = vbr.ReadInt32 ();  		// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  		if ((stFlags & VTXStripGroupTriListFlag) > 0) {  			for (var j = stIndexOffset; j < stIndexOffset + numStIndices; j++) {  				mesh.Mesh.Points.Add (vertinfo [indices [j]]);  				//mesh.Vertices.Add(vertices[vertinfo[indices[j]]]);  			}  		} else if ((stFlags & VTXStripGroupTriStripFlag) > 0) {  			for (var j = stIndexOffset; j < stIndexOffset + numStIndices - 2; j++) {  				var add = j % 2 == 1 ? new[] {  					j + 1'  					j'  					j + 2  				} : new[] {  					j'  					j + 1'  					j + 2  				};  				foreach (var idx in add) {  					mesh.Mesh.Points.Add (vertinfo [indices [idx]]);  					//mesh.Vertices.Add(vertices[vertinfo[indices[idx]]]);  				}  			}  		}  	}  	// Strips  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceMeshData,The following statement contains a magic number: for (var sg = 0; sg < sgNum; sg++) {  	vbr.BaseStream.Position = possg;  	var vertNum = vbr.ReadInt32 ();  	var vertOffset = vbr.ReadInt32 ();  	var indexNum = vbr.ReadInt32 ();  	var indexOffset = vbr.ReadInt32 ();  	var stripNum = vbr.ReadInt32 ();  	var stripOffset = vbr.ReadInt32 ();  	var sgFlags = vbr.ReadByte ();  	// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  	var posvert = possg + vertOffset;  	var posidx = possg + indexOffset;  	var posstrip = possg + stripOffset;  	possg = vbr.BaseStream.Position;  	var vertinfo = new List<VTXPoint> ();  	vbr.BaseStream.Position = posvert;  	for (var vert = 0; vert < vertNum; vert++) {  		var boneWeightIndices = vbr.ReadBytes (3);  		var numBones = vbr.ReadByte ();  		var meshVertex = vbr.ReadInt16 ();  		var boneIDs = vbr.ReadBytes (3);  		vertinfo.Add (new VTXPoint (boneWeightIndices' numBones' meshVertex' boneIDs));  	}  	vbr.BaseStream.Position = posidx;  	var indices = vbr.ReadShortArray (indexNum);  	// The strips hold info about whether this is a triangle strip or just a list  	vbr.BaseStream.Position = posstrip;  	for (var st = 0; st < stripNum; st++) {  		var numStIndices = vbr.ReadInt32 ();  		var stIndexOffset = vbr.ReadInt32 ();  		var numStVerts = vbr.ReadInt32 ();  		var stVertOffset = vbr.ReadInt32 ();  		var numStBones = vbr.ReadInt16 ();  		var stFlags = vbr.ReadByte ();  		var numStBoneStateChanges = vbr.ReadInt32 ();  		var stBoneStateChangeOffset = vbr.ReadInt32 ();  		// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  		if ((stFlags & VTXStripGroupTriListFlag) > 0) {  			for (var j = stIndexOffset; j < stIndexOffset + numStIndices; j++) {  				mesh.Mesh.Points.Add (vertinfo [indices [j]]);  				//mesh.Vertices.Add(vertices[vertinfo[indices[j]]]);  			}  		} else if ((stFlags & VTXStripGroupTriStripFlag) > 0) {  			for (var j = stIndexOffset; j < stIndexOffset + numStIndices - 2; j++) {  				var add = j % 2 == 1 ? new[] {  					j + 1'  					j'  					j + 2  				} : new[] {  					j'  					j + 1'  					j + 2  				};  				foreach (var idx in add) {  					mesh.Mesh.Points.Add (vertinfo [indices [idx]]);  					//mesh.Vertices.Add(vertices[vertinfo[indices[idx]]]);  				}  			}  		}  	}  	// Strips  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceMeshData,The following statement contains a magic number: for (var vert = 0; vert < vertNum; vert++) {  	var boneWeightIndices = vbr.ReadBytes (3);  	var numBones = vbr.ReadByte ();  	var meshVertex = vbr.ReadInt16 ();  	var boneIDs = vbr.ReadBytes (3);  	vertinfo.Add (new VTXPoint (boneWeightIndices' numBones' meshVertex' boneIDs));  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceMeshData,The following statement contains a magic number: for (var vert = 0; vert < vertNum; vert++) {  	var boneWeightIndices = vbr.ReadBytes (3);  	var numBones = vbr.ReadByte ();  	var meshVertex = vbr.ReadInt16 ();  	var boneIDs = vbr.ReadBytes (3);  	vertinfo.Add (new VTXPoint (boneWeightIndices' numBones' meshVertex' boneIDs));  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceMeshData,The following statement contains a magic number: for (var st = 0; st < stripNum; st++) {  	var numStIndices = vbr.ReadInt32 ();  	var stIndexOffset = vbr.ReadInt32 ();  	var numStVerts = vbr.ReadInt32 ();  	var stVertOffset = vbr.ReadInt32 ();  	var numStBones = vbr.ReadInt16 ();  	var stFlags = vbr.ReadByte ();  	var numStBoneStateChanges = vbr.ReadInt32 ();  	var stBoneStateChangeOffset = vbr.ReadInt32 ();  	// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  	if ((stFlags & VTXStripGroupTriListFlag) > 0) {  		for (var j = stIndexOffset; j < stIndexOffset + numStIndices; j++) {  			mesh.Mesh.Points.Add (vertinfo [indices [j]]);  			//mesh.Vertices.Add(vertices[vertinfo[indices[j]]]);  		}  	} else if ((stFlags & VTXStripGroupTriStripFlag) > 0) {  		for (var j = stIndexOffset; j < stIndexOffset + numStIndices - 2; j++) {  			var add = j % 2 == 1 ? new[] {  				j + 1'  				j'  				j + 2  			} : new[] {  				j'  				j + 1'  				j + 2  			};  			foreach (var idx in add) {  				mesh.Mesh.Points.Add (vertinfo [indices [idx]]);  				//mesh.Vertices.Add(vertices[vertinfo[indices[idx]]]);  			}  		}  	}  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceMeshData,The following statement contains a magic number: for (var st = 0; st < stripNum; st++) {  	var numStIndices = vbr.ReadInt32 ();  	var stIndexOffset = vbr.ReadInt32 ();  	var numStVerts = vbr.ReadInt32 ();  	var stVertOffset = vbr.ReadInt32 ();  	var numStBones = vbr.ReadInt16 ();  	var stFlags = vbr.ReadByte ();  	var numStBoneStateChanges = vbr.ReadInt32 ();  	var stBoneStateChangeOffset = vbr.ReadInt32 ();  	// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  	if ((stFlags & VTXStripGroupTriListFlag) > 0) {  		for (var j = stIndexOffset; j < stIndexOffset + numStIndices; j++) {  			mesh.Mesh.Points.Add (vertinfo [indices [j]]);  			//mesh.Vertices.Add(vertices[vertinfo[indices[j]]]);  		}  	} else if ((stFlags & VTXStripGroupTriStripFlag) > 0) {  		for (var j = stIndexOffset; j < stIndexOffset + numStIndices - 2; j++) {  			var add = j % 2 == 1 ? new[] {  				j + 1'  				j'  				j + 2  			} : new[] {  				j'  				j + 1'  				j + 2  			};  			foreach (var idx in add) {  				mesh.Mesh.Points.Add (vertinfo [indices [idx]]);  				//mesh.Vertices.Add(vertices[vertinfo[indices[idx]]]);  			}  		}  	}  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceMeshData,The following statement contains a magic number: for (var st = 0; st < stripNum; st++) {  	var numStIndices = vbr.ReadInt32 ();  	var stIndexOffset = vbr.ReadInt32 ();  	var numStVerts = vbr.ReadInt32 ();  	var stVertOffset = vbr.ReadInt32 ();  	var numStBones = vbr.ReadInt16 ();  	var stFlags = vbr.ReadByte ();  	var numStBoneStateChanges = vbr.ReadInt32 ();  	var stBoneStateChangeOffset = vbr.ReadInt32 ();  	// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  	if ((stFlags & VTXStripGroupTriListFlag) > 0) {  		for (var j = stIndexOffset; j < stIndexOffset + numStIndices; j++) {  			mesh.Mesh.Points.Add (vertinfo [indices [j]]);  			//mesh.Vertices.Add(vertices[vertinfo[indices[j]]]);  		}  	} else if ((stFlags & VTXStripGroupTriStripFlag) > 0) {  		for (var j = stIndexOffset; j < stIndexOffset + numStIndices - 2; j++) {  			var add = j % 2 == 1 ? new[] {  				j + 1'  				j'  				j + 2  			} : new[] {  				j'  				j + 1'  				j + 2  			};  			foreach (var idx in add) {  				mesh.Mesh.Points.Add (vertinfo [indices [idx]]);  				//mesh.Vertices.Add(vertices[vertinfo[indices[idx]]]);  			}  		}  	}  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceMeshData,The following statement contains a magic number: for (var st = 0; st < stripNum; st++) {  	var numStIndices = vbr.ReadInt32 ();  	var stIndexOffset = vbr.ReadInt32 ();  	var numStVerts = vbr.ReadInt32 ();  	var stVertOffset = vbr.ReadInt32 ();  	var numStBones = vbr.ReadInt16 ();  	var stFlags = vbr.ReadByte ();  	var numStBoneStateChanges = vbr.ReadInt32 ();  	var stBoneStateChangeOffset = vbr.ReadInt32 ();  	// vbr.ReadIntArray(2); //TODO FIXME Newer model format 49's (DOTA2' CSGO) have two extra integers here' (num + offset' purpose unknown)  	if ((stFlags & VTXStripGroupTriListFlag) > 0) {  		for (var j = stIndexOffset; j < stIndexOffset + numStIndices; j++) {  			mesh.Mesh.Points.Add (vertinfo [indices [j]]);  			//mesh.Vertices.Add(vertices[vertinfo[indices[j]]]);  		}  	} else if ((stFlags & VTXStripGroupTriStripFlag) > 0) {  		for (var j = stIndexOffset; j < stIndexOffset + numStIndices - 2; j++) {  			var add = j % 2 == 1 ? new[] {  				j + 1'  				j'  				j + 2  			} : new[] {  				j'  				j + 1'  				j + 2  			};  			foreach (var idx in add) {  				mesh.Mesh.Points.Add (vertinfo [indices [idx]]);  				//mesh.Vertices.Add(vertices[vertinfo[indices[idx]]]);  			}  		}  	}  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceMeshData,The following statement contains a magic number: if ((stFlags & VTXStripGroupTriListFlag) > 0) {  	for (var j = stIndexOffset; j < stIndexOffset + numStIndices; j++) {  		mesh.Mesh.Points.Add (vertinfo [indices [j]]);  		//mesh.Vertices.Add(vertices[vertinfo[indices[j]]]);  	}  } else if ((stFlags & VTXStripGroupTriStripFlag) > 0) {  	for (var j = stIndexOffset; j < stIndexOffset + numStIndices - 2; j++) {  		var add = j % 2 == 1 ? new[] {  			j + 1'  			j'  			j + 2  		} : new[] {  			j'  			j + 1'  			j + 2  		};  		foreach (var idx in add) {  			mesh.Mesh.Points.Add (vertinfo [indices [idx]]);  			//mesh.Vertices.Add(vertices[vertinfo[indices[idx]]]);  		}  	}  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceMeshData,The following statement contains a magic number: if ((stFlags & VTXStripGroupTriListFlag) > 0) {  	for (var j = stIndexOffset; j < stIndexOffset + numStIndices; j++) {  		mesh.Mesh.Points.Add (vertinfo [indices [j]]);  		//mesh.Vertices.Add(vertices[vertinfo[indices[j]]]);  	}  } else if ((stFlags & VTXStripGroupTriStripFlag) > 0) {  	for (var j = stIndexOffset; j < stIndexOffset + numStIndices - 2; j++) {  		var add = j % 2 == 1 ? new[] {  			j + 1'  			j'  			j + 2  		} : new[] {  			j'  			j + 1'  			j + 2  		};  		foreach (var idx in add) {  			mesh.Mesh.Points.Add (vertinfo [indices [idx]]);  			//mesh.Vertices.Add(vertices[vertinfo[indices[idx]]]);  		}  	}  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceMeshData,The following statement contains a magic number: if ((stFlags & VTXStripGroupTriListFlag) > 0) {  	for (var j = stIndexOffset; j < stIndexOffset + numStIndices; j++) {  		mesh.Mesh.Points.Add (vertinfo [indices [j]]);  		//mesh.Vertices.Add(vertices[vertinfo[indices[j]]]);  	}  } else if ((stFlags & VTXStripGroupTriStripFlag) > 0) {  	for (var j = stIndexOffset; j < stIndexOffset + numStIndices - 2; j++) {  		var add = j % 2 == 1 ? new[] {  			j + 1'  			j'  			j + 2  		} : new[] {  			j'  			j + 1'  			j + 2  		};  		foreach (var idx in add) {  			mesh.Mesh.Points.Add (vertinfo [indices [idx]]);  			//mesh.Vertices.Add(vertices[vertinfo[indices[idx]]]);  		}  	}  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceMeshData,The following statement contains a magic number: if ((stFlags & VTXStripGroupTriListFlag) > 0) {  	for (var j = stIndexOffset; j < stIndexOffset + numStIndices; j++) {  		mesh.Mesh.Points.Add (vertinfo [indices [j]]);  		//mesh.Vertices.Add(vertices[vertinfo[indices[j]]]);  	}  } else if ((stFlags & VTXStripGroupTriStripFlag) > 0) {  	for (var j = stIndexOffset; j < stIndexOffset + numStIndices - 2; j++) {  		var add = j % 2 == 1 ? new[] {  			j + 1'  			j'  			j + 2  		} : new[] {  			j'  			j + 1'  			j + 2  		};  		foreach (var idx in add) {  			mesh.Mesh.Points.Add (vertinfo [indices [idx]]);  			//mesh.Vertices.Add(vertices[vertinfo[indices[idx]]]);  		}  	}  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceMeshData,The following statement contains a magic number: if ((stFlags & VTXStripGroupTriStripFlag) > 0) {  	for (var j = stIndexOffset; j < stIndexOffset + numStIndices - 2; j++) {  		var add = j % 2 == 1 ? new[] {  			j + 1'  			j'  			j + 2  		} : new[] {  			j'  			j + 1'  			j + 2  		};  		foreach (var idx in add) {  			mesh.Mesh.Points.Add (vertinfo [indices [idx]]);  			//mesh.Vertices.Add(vertices[vertinfo[indices[idx]]]);  		}  	}  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceMeshData,The following statement contains a magic number: if ((stFlags & VTXStripGroupTriStripFlag) > 0) {  	for (var j = stIndexOffset; j < stIndexOffset + numStIndices - 2; j++) {  		var add = j % 2 == 1 ? new[] {  			j + 1'  			j'  			j + 2  		} : new[] {  			j'  			j + 1'  			j + 2  		};  		foreach (var idx in add) {  			mesh.Mesh.Points.Add (vertinfo [indices [idx]]);  			//mesh.Vertices.Add(vertices[vertinfo[indices[idx]]]);  		}  	}  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceMeshData,The following statement contains a magic number: if ((stFlags & VTXStripGroupTriStripFlag) > 0) {  	for (var j = stIndexOffset; j < stIndexOffset + numStIndices - 2; j++) {  		var add = j % 2 == 1 ? new[] {  			j + 1'  			j'  			j + 2  		} : new[] {  			j'  			j + 1'  			j + 2  		};  		foreach (var idx in add) {  			mesh.Mesh.Points.Add (vertinfo [indices [idx]]);  			//mesh.Vertices.Add(vertices[vertinfo[indices[idx]]]);  		}  	}  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceMeshData,The following statement contains a magic number: if ((stFlags & VTXStripGroupTriStripFlag) > 0) {  	for (var j = stIndexOffset; j < stIndexOffset + numStIndices - 2; j++) {  		var add = j % 2 == 1 ? new[] {  			j + 1'  			j'  			j + 2  		} : new[] {  			j'  			j + 1'  			j + 2  		};  		foreach (var idx in add) {  			mesh.Mesh.Points.Add (vertinfo [indices [idx]]);  			//mesh.Vertices.Add(vertices[vertinfo[indices[idx]]]);  		}  	}  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceMeshData,The following statement contains a magic number: for (var j = stIndexOffset; j < stIndexOffset + numStIndices - 2; j++) {  	var add = j % 2 == 1 ? new[] {  		j + 1'  		j'  		j + 2  	} : new[] {  		j'  		j + 1'  		j + 2  	};  	foreach (var idx in add) {  		mesh.Mesh.Points.Add (vertinfo [indices [idx]]);  		//mesh.Vertices.Add(vertices[vertinfo[indices[idx]]]);  	}  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceMeshData,The following statement contains a magic number: for (var j = stIndexOffset; j < stIndexOffset + numStIndices - 2; j++) {  	var add = j % 2 == 1 ? new[] {  		j + 1'  		j'  		j + 2  	} : new[] {  		j'  		j + 1'  		j + 2  	};  	foreach (var idx in add) {  		mesh.Mesh.Points.Add (vertinfo [indices [idx]]);  		//mesh.Vertices.Add(vertices[vertinfo[indices[idx]]]);  	}  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceMeshData,The following statement contains a magic number: for (var j = stIndexOffset; j < stIndexOffset + numStIndices - 2; j++) {  	var add = j % 2 == 1 ? new[] {  		j + 1'  		j'  		j + 2  	} : new[] {  		j'  		j + 1'  		j + 2  	};  	foreach (var idx in add) {  		mesh.Mesh.Points.Add (vertinfo [indices [idx]]);  		//mesh.Vertices.Add(vertices[vertinfo[indices[idx]]]);  	}  }  
Magic Number,Sledge.Providers.Model,MdlProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Model\MdlProvider.cs,LoadSourceMeshData,The following statement contains a magic number: for (var j = stIndexOffset; j < stIndexOffset + numStIndices - 2; j++) {  	var add = j % 2 == 1 ? new[] {  		j + 1'  		j'  		j + 2  	} : new[] {  		j'  		j + 1'  		j + 2  	};  	foreach (var idx in add) {  		mesh.Mesh.Points.Add (vertinfo [indices [idx]]);  		//mesh.Vertices.Add(vertices[vertinfo[indices[idx]]]);  	}  }  
Magic Number,Sledge.Providers.Texture,NullTextureStreamSource,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\NullTextureStreamSource.cs,NullTextureStreamSource,The following statement contains a magic number: PlaceholderImage = new Bitmap (64' 64' PixelFormat.Format32bppArgb);  
Magic Number,Sledge.Providers.Texture,NullTextureStreamSource,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\NullTextureStreamSource.cs,NullTextureStreamSource,The following statement contains a magic number: PlaceholderImage = new Bitmap (64' 64' PixelFormat.Format32bppArgb);  
Magic Number,Sledge.Providers.Texture,NullTextureStreamSource,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\NullTextureStreamSource.cs,NullTextureStreamSource,The following statement contains a magic number: using (var g = System.Drawing.Graphics.FromImage (PlaceholderImage)) {  	g.FillRectangle (Brushes.Black' 0' 0' 64' 64);  	for (var i = 0; i < 64; i++) {  		var x = i % 8;  		var y = i / 8;  		if (y % 2 == x % 2)  			continue;  		g.FillRectangle (Brushes.Magenta' x * 8' y * 8' 8' 8);  	}  }  
Magic Number,Sledge.Providers.Texture,NullTextureStreamSource,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\NullTextureStreamSource.cs,NullTextureStreamSource,The following statement contains a magic number: using (var g = System.Drawing.Graphics.FromImage (PlaceholderImage)) {  	g.FillRectangle (Brushes.Black' 0' 0' 64' 64);  	for (var i = 0; i < 64; i++) {  		var x = i % 8;  		var y = i / 8;  		if (y % 2 == x % 2)  			continue;  		g.FillRectangle (Brushes.Magenta' x * 8' y * 8' 8' 8);  	}  }  
Magic Number,Sledge.Providers.Texture,NullTextureStreamSource,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\NullTextureStreamSource.cs,NullTextureStreamSource,The following statement contains a magic number: using (var g = System.Drawing.Graphics.FromImage (PlaceholderImage)) {  	g.FillRectangle (Brushes.Black' 0' 0' 64' 64);  	for (var i = 0; i < 64; i++) {  		var x = i % 8;  		var y = i / 8;  		if (y % 2 == x % 2)  			continue;  		g.FillRectangle (Brushes.Magenta' x * 8' y * 8' 8' 8);  	}  }  
Magic Number,Sledge.Providers.Texture,NullTextureStreamSource,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\NullTextureStreamSource.cs,NullTextureStreamSource,The following statement contains a magic number: using (var g = System.Drawing.Graphics.FromImage (PlaceholderImage)) {  	g.FillRectangle (Brushes.Black' 0' 0' 64' 64);  	for (var i = 0; i < 64; i++) {  		var x = i % 8;  		var y = i / 8;  		if (y % 2 == x % 2)  			continue;  		g.FillRectangle (Brushes.Magenta' x * 8' y * 8' 8' 8);  	}  }  
Magic Number,Sledge.Providers.Texture,NullTextureStreamSource,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\NullTextureStreamSource.cs,NullTextureStreamSource,The following statement contains a magic number: using (var g = System.Drawing.Graphics.FromImage (PlaceholderImage)) {  	g.FillRectangle (Brushes.Black' 0' 0' 64' 64);  	for (var i = 0; i < 64; i++) {  		var x = i % 8;  		var y = i / 8;  		if (y % 2 == x % 2)  			continue;  		g.FillRectangle (Brushes.Magenta' x * 8' y * 8' 8' 8);  	}  }  
Magic Number,Sledge.Providers.Texture,NullTextureStreamSource,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\NullTextureStreamSource.cs,NullTextureStreamSource,The following statement contains a magic number: using (var g = System.Drawing.Graphics.FromImage (PlaceholderImage)) {  	g.FillRectangle (Brushes.Black' 0' 0' 64' 64);  	for (var i = 0; i < 64; i++) {  		var x = i % 8;  		var y = i / 8;  		if (y % 2 == x % 2)  			continue;  		g.FillRectangle (Brushes.Magenta' x * 8' y * 8' 8' 8);  	}  }  
Magic Number,Sledge.Providers.Texture,NullTextureStreamSource,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\NullTextureStreamSource.cs,NullTextureStreamSource,The following statement contains a magic number: using (var g = System.Drawing.Graphics.FromImage (PlaceholderImage)) {  	g.FillRectangle (Brushes.Black' 0' 0' 64' 64);  	for (var i = 0; i < 64; i++) {  		var x = i % 8;  		var y = i / 8;  		if (y % 2 == x % 2)  			continue;  		g.FillRectangle (Brushes.Magenta' x * 8' y * 8' 8' 8);  	}  }  
Magic Number,Sledge.Providers.Texture,NullTextureStreamSource,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\NullTextureStreamSource.cs,NullTextureStreamSource,The following statement contains a magic number: using (var g = System.Drawing.Graphics.FromImage (PlaceholderImage)) {  	g.FillRectangle (Brushes.Black' 0' 0' 64' 64);  	for (var i = 0; i < 64; i++) {  		var x = i % 8;  		var y = i / 8;  		if (y % 2 == x % 2)  			continue;  		g.FillRectangle (Brushes.Magenta' x * 8' y * 8' 8' 8);  	}  }  
Magic Number,Sledge.Providers.Texture,NullTextureStreamSource,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\NullTextureStreamSource.cs,NullTextureStreamSource,The following statement contains a magic number: using (var g = System.Drawing.Graphics.FromImage (PlaceholderImage)) {  	g.FillRectangle (Brushes.Black' 0' 0' 64' 64);  	for (var i = 0; i < 64; i++) {  		var x = i % 8;  		var y = i / 8;  		if (y % 2 == x % 2)  			continue;  		g.FillRectangle (Brushes.Magenta' x * 8' y * 8' 8' 8);  	}  }  
Magic Number,Sledge.Providers.Texture,NullTextureStreamSource,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\NullTextureStreamSource.cs,NullTextureStreamSource,The following statement contains a magic number: using (var g = System.Drawing.Graphics.FromImage (PlaceholderImage)) {  	g.FillRectangle (Brushes.Black' 0' 0' 64' 64);  	for (var i = 0; i < 64; i++) {  		var x = i % 8;  		var y = i / 8;  		if (y % 2 == x % 2)  			continue;  		g.FillRectangle (Brushes.Magenta' x * 8' y * 8' 8' 8);  	}  }  
Magic Number,Sledge.Providers.Texture,NullTextureStreamSource,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\NullTextureStreamSource.cs,NullTextureStreamSource,The following statement contains a magic number: using (var g = System.Drawing.Graphics.FromImage (PlaceholderImage)) {  	g.FillRectangle (Brushes.Black' 0' 0' 64' 64);  	for (var i = 0; i < 64; i++) {  		var x = i % 8;  		var y = i / 8;  		if (y % 2 == x % 2)  			continue;  		g.FillRectangle (Brushes.Magenta' x * 8' y * 8' 8' 8);  	}  }  
Magic Number,Sledge.Providers.Texture,NullTextureStreamSource,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\NullTextureStreamSource.cs,NullTextureStreamSource,The following statement contains a magic number: g.FillRectangle (Brushes.Black' 0' 0' 64' 64);  
Magic Number,Sledge.Providers.Texture,NullTextureStreamSource,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\NullTextureStreamSource.cs,NullTextureStreamSource,The following statement contains a magic number: g.FillRectangle (Brushes.Black' 0' 0' 64' 64);  
Magic Number,Sledge.Providers.Texture,NullTextureStreamSource,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\NullTextureStreamSource.cs,NullTextureStreamSource,The following statement contains a magic number: for (var i = 0; i < 64; i++) {  	var x = i % 8;  	var y = i / 8;  	if (y % 2 == x % 2)  		continue;  	g.FillRectangle (Brushes.Magenta' x * 8' y * 8' 8' 8);  }  
Magic Number,Sledge.Providers.Texture,NullTextureStreamSource,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\NullTextureStreamSource.cs,NullTextureStreamSource,The following statement contains a magic number: for (var i = 0; i < 64; i++) {  	var x = i % 8;  	var y = i / 8;  	if (y % 2 == x % 2)  		continue;  	g.FillRectangle (Brushes.Magenta' x * 8' y * 8' 8' 8);  }  
Magic Number,Sledge.Providers.Texture,NullTextureStreamSource,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\NullTextureStreamSource.cs,NullTextureStreamSource,The following statement contains a magic number: for (var i = 0; i < 64; i++) {  	var x = i % 8;  	var y = i / 8;  	if (y % 2 == x % 2)  		continue;  	g.FillRectangle (Brushes.Magenta' x * 8' y * 8' 8' 8);  }  
Magic Number,Sledge.Providers.Texture,NullTextureStreamSource,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\NullTextureStreamSource.cs,NullTextureStreamSource,The following statement contains a magic number: for (var i = 0; i < 64; i++) {  	var x = i % 8;  	var y = i / 8;  	if (y % 2 == x % 2)  		continue;  	g.FillRectangle (Brushes.Magenta' x * 8' y * 8' 8' 8);  }  
Magic Number,Sledge.Providers.Texture,NullTextureStreamSource,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\NullTextureStreamSource.cs,NullTextureStreamSource,The following statement contains a magic number: for (var i = 0; i < 64; i++) {  	var x = i % 8;  	var y = i / 8;  	if (y % 2 == x % 2)  		continue;  	g.FillRectangle (Brushes.Magenta' x * 8' y * 8' 8' 8);  }  
Magic Number,Sledge.Providers.Texture,NullTextureStreamSource,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\NullTextureStreamSource.cs,NullTextureStreamSource,The following statement contains a magic number: for (var i = 0; i < 64; i++) {  	var x = i % 8;  	var y = i / 8;  	if (y % 2 == x % 2)  		continue;  	g.FillRectangle (Brushes.Magenta' x * 8' y * 8' 8' 8);  }  
Magic Number,Sledge.Providers.Texture,NullTextureStreamSource,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\NullTextureStreamSource.cs,NullTextureStreamSource,The following statement contains a magic number: for (var i = 0; i < 64; i++) {  	var x = i % 8;  	var y = i / 8;  	if (y % 2 == x % 2)  		continue;  	g.FillRectangle (Brushes.Magenta' x * 8' y * 8' 8' 8);  }  
Magic Number,Sledge.Providers.Texture,NullTextureStreamSource,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\NullTextureStreamSource.cs,NullTextureStreamSource,The following statement contains a magic number: for (var i = 0; i < 64; i++) {  	var x = i % 8;  	var y = i / 8;  	if (y % 2 == x % 2)  		continue;  	g.FillRectangle (Brushes.Magenta' x * 8' y * 8' 8' 8);  }  
Magic Number,Sledge.Providers.Texture,NullTextureStreamSource,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\NullTextureStreamSource.cs,NullTextureStreamSource,The following statement contains a magic number: for (var i = 0; i < 64; i++) {  	var x = i % 8;  	var y = i / 8;  	if (y % 2 == x % 2)  		continue;  	g.FillRectangle (Brushes.Magenta' x * 8' y * 8' 8' 8);  }  
Magic Number,Sledge.Providers.Texture,NullTextureStreamSource,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\NullTextureStreamSource.cs,NullTextureStreamSource,The following statement contains a magic number: if (y % 2 == x % 2)  	continue;  
Magic Number,Sledge.Providers.Texture,NullTextureStreamSource,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\NullTextureStreamSource.cs,NullTextureStreamSource,The following statement contains a magic number: if (y % 2 == x % 2)  	continue;  
Magic Number,Sledge.Providers.Texture,NullTextureStreamSource,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\NullTextureStreamSource.cs,NullTextureStreamSource,The following statement contains a magic number: g.FillRectangle (Brushes.Magenta' x * 8' y * 8' 8' 8);  
Magic Number,Sledge.Providers.Texture,NullTextureStreamSource,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\NullTextureStreamSource.cs,NullTextureStreamSource,The following statement contains a magic number: g.FillRectangle (Brushes.Magenta' x * 8' y * 8' 8' 8);  
Magic Number,Sledge.Providers.Texture,NullTextureStreamSource,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\NullTextureStreamSource.cs,NullTextureStreamSource,The following statement contains a magic number: g.FillRectangle (Brushes.Magenta' x * 8' y * 8' 8' 8);  
Magic Number,Sledge.Providers.Texture,NullTextureStreamSource,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\NullTextureStreamSource.cs,NullTextureStreamSource,The following statement contains a magic number: g.FillRectangle (Brushes.Magenta' x * 8' y * 8' 8' 8);  
Magic Number,Sledge.Providers.Texture,SprProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\SprProvider.cs,GetSize,The following statement contains a magic number: using (var br = new BinaryReader (File.Open (file' FileMode.Open' FileAccess.Read' FileShare.ReadWrite))) {  	var idst = br.ReadFixedLengthString (Encoding.ASCII' 4);  	if (idst != "IDSP")  		return Size.Empty;  	var version = br.ReadInt32 ();  	if (version != 2)  		return Size.Empty;  	var type = (SpriteOrientation)br.ReadInt32 ();  	var texFormat = (SpriteRenderMode)br.ReadInt32 ();  	var boundingRadius = br.ReadSingle ();  	var width = br.ReadInt32 ();  	var height = br.ReadInt32 ();  	return new Size (width' height);  }  
Magic Number,Sledge.Providers.Texture,SprProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\SprProvider.cs,GetSize,The following statement contains a magic number: using (var br = new BinaryReader (File.Open (file' FileMode.Open' FileAccess.Read' FileShare.ReadWrite))) {  	var idst = br.ReadFixedLengthString (Encoding.ASCII' 4);  	if (idst != "IDSP")  		return Size.Empty;  	var version = br.ReadInt32 ();  	if (version != 2)  		return Size.Empty;  	var type = (SpriteOrientation)br.ReadInt32 ();  	var texFormat = (SpriteRenderMode)br.ReadInt32 ();  	var boundingRadius = br.ReadSingle ();  	var width = br.ReadInt32 ();  	var height = br.ReadInt32 ();  	return new Size (width' height);  }  
Magic Number,Sledge.Providers.Texture,SprProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\SprProvider.cs,GetSize,The following statement contains a magic number: if (version != 2)  	return Size.Empty;  
Magic Number,Sledge.Providers.Texture,SprProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\SprProvider.cs,Parse,The following statement contains a magic number: using (var br = new BinaryReader (File.Open (file' FileMode.Open' FileAccess.Read' FileShare.ReadWrite))) {  	var idst = br.ReadFixedLengthString (Encoding.ASCII' 4);  	if (idst != "IDSP")  		return null;  	var version = br.ReadInt32 ();  	if (version != 2)  		return null;  	var type = (SpriteOrientation)br.ReadInt32 ();  	var texFormat = (SpriteRenderMode)br.ReadInt32 ();  	var boundingRadius = br.ReadSingle ();  	var width = br.ReadInt32 ();  	var height = br.ReadInt32 ();  	var numframes = br.ReadInt32 ();  	var beamlength = br.ReadSingle ();  	var synctype = br.ReadInt32 ();  	var paletteSize = br.ReadInt16 ();  	var palette = br.ReadBytes (paletteSize * 3);  	if (paletteSize > 256)  		paletteSize = 256;  	// Don't accept anything higher  	var colours = new Color[256];  	for (var i = 0; i < paletteSize; i++) {  		var r = palette [i * 3 + 0];  		var g = palette [i * 3 + 1];  		var b = palette [i * 3 + 2];  		colours [i] = Color.FromArgb (255' r' g' b);  	}  	// Only read the first frame.  	var frametype = br.ReadInt32 ();  	if (frametype != 0) {  		var num = br.ReadInt32 ();  		var intervals = br.ReadSingleArray (num);  	}  	var originX = br.ReadInt32 ();  	var originY = br.ReadInt32 ();  	var framewidth = br.ReadInt32 ();  	var frameheight = br.ReadInt32 ();  	var pixels = br.ReadBytes (framewidth * frameheight);  	var bitmap = new Bitmap (framewidth' frameheight' PixelFormat.Format8bppIndexed);  	// Pre-process the palette  	var pal = bitmap.Palette;  	var last = colours [255];  	for (var i = 0; i < paletteSize; i++) {  		var c = colours [i];  		if (texFormat == SpriteRenderMode.Additive) {  			var a = (int)((c.R + c.G + c.B) / 3f);  			c = Color.FromArgb (a' c);  		} else if (texFormat == SpriteRenderMode.IndexAlpha && i < 255) {  			var a = (int)((c.R + c.G + c.B) / 3f);  			c = Color.FromArgb (a' last);  		}  		pal.Entries [i] = c;  	}  	if (texFormat == SpriteRenderMode.AlphaTest) {  		pal.Entries [255] = Color.FromArgb (0' 0' 0' 0);  	}  	bitmap.Palette = pal;  	// Set the pixel data  	var data = bitmap.LockBits (new Rectangle (0' 0' bitmap.Width' bitmap.Height)' ImageLockMode.ReadWrite' bitmap.PixelFormat);  	Marshal.Copy (pixels' 0' data.Scan0' data.Width * data.Height);  	bitmap.UnlockBits (data);  	return bitmap;  }  
Magic Number,Sledge.Providers.Texture,SprProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\SprProvider.cs,Parse,The following statement contains a magic number: using (var br = new BinaryReader (File.Open (file' FileMode.Open' FileAccess.Read' FileShare.ReadWrite))) {  	var idst = br.ReadFixedLengthString (Encoding.ASCII' 4);  	if (idst != "IDSP")  		return null;  	var version = br.ReadInt32 ();  	if (version != 2)  		return null;  	var type = (SpriteOrientation)br.ReadInt32 ();  	var texFormat = (SpriteRenderMode)br.ReadInt32 ();  	var boundingRadius = br.ReadSingle ();  	var width = br.ReadInt32 ();  	var height = br.ReadInt32 ();  	var numframes = br.ReadInt32 ();  	var beamlength = br.ReadSingle ();  	var synctype = br.ReadInt32 ();  	var paletteSize = br.ReadInt16 ();  	var palette = br.ReadBytes (paletteSize * 3);  	if (paletteSize > 256)  		paletteSize = 256;  	// Don't accept anything higher  	var colours = new Color[256];  	for (var i = 0; i < paletteSize; i++) {  		var r = palette [i * 3 + 0];  		var g = palette [i * 3 + 1];  		var b = palette [i * 3 + 2];  		colours [i] = Color.FromArgb (255' r' g' b);  	}  	// Only read the first frame.  	var frametype = br.ReadInt32 ();  	if (frametype != 0) {  		var num = br.ReadInt32 ();  		var intervals = br.ReadSingleArray (num);  	}  	var originX = br.ReadInt32 ();  	var originY = br.ReadInt32 ();  	var framewidth = br.ReadInt32 ();  	var frameheight = br.ReadInt32 ();  	var pixels = br.ReadBytes (framewidth * frameheight);  	var bitmap = new Bitmap (framewidth' frameheight' PixelFormat.Format8bppIndexed);  	// Pre-process the palette  	var pal = bitmap.Palette;  	var last = colours [255];  	for (var i = 0; i < paletteSize; i++) {  		var c = colours [i];  		if (texFormat == SpriteRenderMode.Additive) {  			var a = (int)((c.R + c.G + c.B) / 3f);  			c = Color.FromArgb (a' c);  		} else if (texFormat == SpriteRenderMode.IndexAlpha && i < 255) {  			var a = (int)((c.R + c.G + c.B) / 3f);  			c = Color.FromArgb (a' last);  		}  		pal.Entries [i] = c;  	}  	if (texFormat == SpriteRenderMode.AlphaTest) {  		pal.Entries [255] = Color.FromArgb (0' 0' 0' 0);  	}  	bitmap.Palette = pal;  	// Set the pixel data  	var data = bitmap.LockBits (new Rectangle (0' 0' bitmap.Width' bitmap.Height)' ImageLockMode.ReadWrite' bitmap.PixelFormat);  	Marshal.Copy (pixels' 0' data.Scan0' data.Width * data.Height);  	bitmap.UnlockBits (data);  	return bitmap;  }  
Magic Number,Sledge.Providers.Texture,SprProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\SprProvider.cs,Parse,The following statement contains a magic number: using (var br = new BinaryReader (File.Open (file' FileMode.Open' FileAccess.Read' FileShare.ReadWrite))) {  	var idst = br.ReadFixedLengthString (Encoding.ASCII' 4);  	if (idst != "IDSP")  		return null;  	var version = br.ReadInt32 ();  	if (version != 2)  		return null;  	var type = (SpriteOrientation)br.ReadInt32 ();  	var texFormat = (SpriteRenderMode)br.ReadInt32 ();  	var boundingRadius = br.ReadSingle ();  	var width = br.ReadInt32 ();  	var height = br.ReadInt32 ();  	var numframes = br.ReadInt32 ();  	var beamlength = br.ReadSingle ();  	var synctype = br.ReadInt32 ();  	var paletteSize = br.ReadInt16 ();  	var palette = br.ReadBytes (paletteSize * 3);  	if (paletteSize > 256)  		paletteSize = 256;  	// Don't accept anything higher  	var colours = new Color[256];  	for (var i = 0; i < paletteSize; i++) {  		var r = palette [i * 3 + 0];  		var g = palette [i * 3 + 1];  		var b = palette [i * 3 + 2];  		colours [i] = Color.FromArgb (255' r' g' b);  	}  	// Only read the first frame.  	var frametype = br.ReadInt32 ();  	if (frametype != 0) {  		var num = br.ReadInt32 ();  		var intervals = br.ReadSingleArray (num);  	}  	var originX = br.ReadInt32 ();  	var originY = br.ReadInt32 ();  	var framewidth = br.ReadInt32 ();  	var frameheight = br.ReadInt32 ();  	var pixels = br.ReadBytes (framewidth * frameheight);  	var bitmap = new Bitmap (framewidth' frameheight' PixelFormat.Format8bppIndexed);  	// Pre-process the palette  	var pal = bitmap.Palette;  	var last = colours [255];  	for (var i = 0; i < paletteSize; i++) {  		var c = colours [i];  		if (texFormat == SpriteRenderMode.Additive) {  			var a = (int)((c.R + c.G + c.B) / 3f);  			c = Color.FromArgb (a' c);  		} else if (texFormat == SpriteRenderMode.IndexAlpha && i < 255) {  			var a = (int)((c.R + c.G + c.B) / 3f);  			c = Color.FromArgb (a' last);  		}  		pal.Entries [i] = c;  	}  	if (texFormat == SpriteRenderMode.AlphaTest) {  		pal.Entries [255] = Color.FromArgb (0' 0' 0' 0);  	}  	bitmap.Palette = pal;  	// Set the pixel data  	var data = bitmap.LockBits (new Rectangle (0' 0' bitmap.Width' bitmap.Height)' ImageLockMode.ReadWrite' bitmap.PixelFormat);  	Marshal.Copy (pixels' 0' data.Scan0' data.Width * data.Height);  	bitmap.UnlockBits (data);  	return bitmap;  }  
Magic Number,Sledge.Providers.Texture,SprProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\SprProvider.cs,Parse,The following statement contains a magic number: using (var br = new BinaryReader (File.Open (file' FileMode.Open' FileAccess.Read' FileShare.ReadWrite))) {  	var idst = br.ReadFixedLengthString (Encoding.ASCII' 4);  	if (idst != "IDSP")  		return null;  	var version = br.ReadInt32 ();  	if (version != 2)  		return null;  	var type = (SpriteOrientation)br.ReadInt32 ();  	var texFormat = (SpriteRenderMode)br.ReadInt32 ();  	var boundingRadius = br.ReadSingle ();  	var width = br.ReadInt32 ();  	var height = br.ReadInt32 ();  	var numframes = br.ReadInt32 ();  	var beamlength = br.ReadSingle ();  	var synctype = br.ReadInt32 ();  	var paletteSize = br.ReadInt16 ();  	var palette = br.ReadBytes (paletteSize * 3);  	if (paletteSize > 256)  		paletteSize = 256;  	// Don't accept anything higher  	var colours = new Color[256];  	for (var i = 0; i < paletteSize; i++) {  		var r = palette [i * 3 + 0];  		var g = palette [i * 3 + 1];  		var b = palette [i * 3 + 2];  		colours [i] = Color.FromArgb (255' r' g' b);  	}  	// Only read the first frame.  	var frametype = br.ReadInt32 ();  	if (frametype != 0) {  		var num = br.ReadInt32 ();  		var intervals = br.ReadSingleArray (num);  	}  	var originX = br.ReadInt32 ();  	var originY = br.ReadInt32 ();  	var framewidth = br.ReadInt32 ();  	var frameheight = br.ReadInt32 ();  	var pixels = br.ReadBytes (framewidth * frameheight);  	var bitmap = new Bitmap (framewidth' frameheight' PixelFormat.Format8bppIndexed);  	// Pre-process the palette  	var pal = bitmap.Palette;  	var last = colours [255];  	for (var i = 0; i < paletteSize; i++) {  		var c = colours [i];  		if (texFormat == SpriteRenderMode.Additive) {  			var a = (int)((c.R + c.G + c.B) / 3f);  			c = Color.FromArgb (a' c);  		} else if (texFormat == SpriteRenderMode.IndexAlpha && i < 255) {  			var a = (int)((c.R + c.G + c.B) / 3f);  			c = Color.FromArgb (a' last);  		}  		pal.Entries [i] = c;  	}  	if (texFormat == SpriteRenderMode.AlphaTest) {  		pal.Entries [255] = Color.FromArgb (0' 0' 0' 0);  	}  	bitmap.Palette = pal;  	// Set the pixel data  	var data = bitmap.LockBits (new Rectangle (0' 0' bitmap.Width' bitmap.Height)' ImageLockMode.ReadWrite' bitmap.PixelFormat);  	Marshal.Copy (pixels' 0' data.Scan0' data.Width * data.Height);  	bitmap.UnlockBits (data);  	return bitmap;  }  
Magic Number,Sledge.Providers.Texture,SprProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\SprProvider.cs,Parse,The following statement contains a magic number: using (var br = new BinaryReader (File.Open (file' FileMode.Open' FileAccess.Read' FileShare.ReadWrite))) {  	var idst = br.ReadFixedLengthString (Encoding.ASCII' 4);  	if (idst != "IDSP")  		return null;  	var version = br.ReadInt32 ();  	if (version != 2)  		return null;  	var type = (SpriteOrientation)br.ReadInt32 ();  	var texFormat = (SpriteRenderMode)br.ReadInt32 ();  	var boundingRadius = br.ReadSingle ();  	var width = br.ReadInt32 ();  	var height = br.ReadInt32 ();  	var numframes = br.ReadInt32 ();  	var beamlength = br.ReadSingle ();  	var synctype = br.ReadInt32 ();  	var paletteSize = br.ReadInt16 ();  	var palette = br.ReadBytes (paletteSize * 3);  	if (paletteSize > 256)  		paletteSize = 256;  	// Don't accept anything higher  	var colours = new Color[256];  	for (var i = 0; i < paletteSize; i++) {  		var r = palette [i * 3 + 0];  		var g = palette [i * 3 + 1];  		var b = palette [i * 3 + 2];  		colours [i] = Color.FromArgb (255' r' g' b);  	}  	// Only read the first frame.  	var frametype = br.ReadInt32 ();  	if (frametype != 0) {  		var num = br.ReadInt32 ();  		var intervals = br.ReadSingleArray (num);  	}  	var originX = br.ReadInt32 ();  	var originY = br.ReadInt32 ();  	var framewidth = br.ReadInt32 ();  	var frameheight = br.ReadInt32 ();  	var pixels = br.ReadBytes (framewidth * frameheight);  	var bitmap = new Bitmap (framewidth' frameheight' PixelFormat.Format8bppIndexed);  	// Pre-process the palette  	var pal = bitmap.Palette;  	var last = colours [255];  	for (var i = 0; i < paletteSize; i++) {  		var c = colours [i];  		if (texFormat == SpriteRenderMode.Additive) {  			var a = (int)((c.R + c.G + c.B) / 3f);  			c = Color.FromArgb (a' c);  		} else if (texFormat == SpriteRenderMode.IndexAlpha && i < 255) {  			var a = (int)((c.R + c.G + c.B) / 3f);  			c = Color.FromArgb (a' last);  		}  		pal.Entries [i] = c;  	}  	if (texFormat == SpriteRenderMode.AlphaTest) {  		pal.Entries [255] = Color.FromArgb (0' 0' 0' 0);  	}  	bitmap.Palette = pal;  	// Set the pixel data  	var data = bitmap.LockBits (new Rectangle (0' 0' bitmap.Width' bitmap.Height)' ImageLockMode.ReadWrite' bitmap.PixelFormat);  	Marshal.Copy (pixels' 0' data.Scan0' data.Width * data.Height);  	bitmap.UnlockBits (data);  	return bitmap;  }  
Magic Number,Sledge.Providers.Texture,SprProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\SprProvider.cs,Parse,The following statement contains a magic number: using (var br = new BinaryReader (File.Open (file' FileMode.Open' FileAccess.Read' FileShare.ReadWrite))) {  	var idst = br.ReadFixedLengthString (Encoding.ASCII' 4);  	if (idst != "IDSP")  		return null;  	var version = br.ReadInt32 ();  	if (version != 2)  		return null;  	var type = (SpriteOrientation)br.ReadInt32 ();  	var texFormat = (SpriteRenderMode)br.ReadInt32 ();  	var boundingRadius = br.ReadSingle ();  	var width = br.ReadInt32 ();  	var height = br.ReadInt32 ();  	var numframes = br.ReadInt32 ();  	var beamlength = br.ReadSingle ();  	var synctype = br.ReadInt32 ();  	var paletteSize = br.ReadInt16 ();  	var palette = br.ReadBytes (paletteSize * 3);  	if (paletteSize > 256)  		paletteSize = 256;  	// Don't accept anything higher  	var colours = new Color[256];  	for (var i = 0; i < paletteSize; i++) {  		var r = palette [i * 3 + 0];  		var g = palette [i * 3 + 1];  		var b = palette [i * 3 + 2];  		colours [i] = Color.FromArgb (255' r' g' b);  	}  	// Only read the first frame.  	var frametype = br.ReadInt32 ();  	if (frametype != 0) {  		var num = br.ReadInt32 ();  		var intervals = br.ReadSingleArray (num);  	}  	var originX = br.ReadInt32 ();  	var originY = br.ReadInt32 ();  	var framewidth = br.ReadInt32 ();  	var frameheight = br.ReadInt32 ();  	var pixels = br.ReadBytes (framewidth * frameheight);  	var bitmap = new Bitmap (framewidth' frameheight' PixelFormat.Format8bppIndexed);  	// Pre-process the palette  	var pal = bitmap.Palette;  	var last = colours [255];  	for (var i = 0; i < paletteSize; i++) {  		var c = colours [i];  		if (texFormat == SpriteRenderMode.Additive) {  			var a = (int)((c.R + c.G + c.B) / 3f);  			c = Color.FromArgb (a' c);  		} else if (texFormat == SpriteRenderMode.IndexAlpha && i < 255) {  			var a = (int)((c.R + c.G + c.B) / 3f);  			c = Color.FromArgb (a' last);  		}  		pal.Entries [i] = c;  	}  	if (texFormat == SpriteRenderMode.AlphaTest) {  		pal.Entries [255] = Color.FromArgb (0' 0' 0' 0);  	}  	bitmap.Palette = pal;  	// Set the pixel data  	var data = bitmap.LockBits (new Rectangle (0' 0' bitmap.Width' bitmap.Height)' ImageLockMode.ReadWrite' bitmap.PixelFormat);  	Marshal.Copy (pixels' 0' data.Scan0' data.Width * data.Height);  	bitmap.UnlockBits (data);  	return bitmap;  }  
Magic Number,Sledge.Providers.Texture,SprProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\SprProvider.cs,Parse,The following statement contains a magic number: using (var br = new BinaryReader (File.Open (file' FileMode.Open' FileAccess.Read' FileShare.ReadWrite))) {  	var idst = br.ReadFixedLengthString (Encoding.ASCII' 4);  	if (idst != "IDSP")  		return null;  	var version = br.ReadInt32 ();  	if (version != 2)  		return null;  	var type = (SpriteOrientation)br.ReadInt32 ();  	var texFormat = (SpriteRenderMode)br.ReadInt32 ();  	var boundingRadius = br.ReadSingle ();  	var width = br.ReadInt32 ();  	var height = br.ReadInt32 ();  	var numframes = br.ReadInt32 ();  	var beamlength = br.ReadSingle ();  	var synctype = br.ReadInt32 ();  	var paletteSize = br.ReadInt16 ();  	var palette = br.ReadBytes (paletteSize * 3);  	if (paletteSize > 256)  		paletteSize = 256;  	// Don't accept anything higher  	var colours = new Color[256];  	for (var i = 0; i < paletteSize; i++) {  		var r = palette [i * 3 + 0];  		var g = palette [i * 3 + 1];  		var b = palette [i * 3 + 2];  		colours [i] = Color.FromArgb (255' r' g' b);  	}  	// Only read the first frame.  	var frametype = br.ReadInt32 ();  	if (frametype != 0) {  		var num = br.ReadInt32 ();  		var intervals = br.ReadSingleArray (num);  	}  	var originX = br.ReadInt32 ();  	var originY = br.ReadInt32 ();  	var framewidth = br.ReadInt32 ();  	var frameheight = br.ReadInt32 ();  	var pixels = br.ReadBytes (framewidth * frameheight);  	var bitmap = new Bitmap (framewidth' frameheight' PixelFormat.Format8bppIndexed);  	// Pre-process the palette  	var pal = bitmap.Palette;  	var last = colours [255];  	for (var i = 0; i < paletteSize; i++) {  		var c = colours [i];  		if (texFormat == SpriteRenderMode.Additive) {  			var a = (int)((c.R + c.G + c.B) / 3f);  			c = Color.FromArgb (a' c);  		} else if (texFormat == SpriteRenderMode.IndexAlpha && i < 255) {  			var a = (int)((c.R + c.G + c.B) / 3f);  			c = Color.FromArgb (a' last);  		}  		pal.Entries [i] = c;  	}  	if (texFormat == SpriteRenderMode.AlphaTest) {  		pal.Entries [255] = Color.FromArgb (0' 0' 0' 0);  	}  	bitmap.Palette = pal;  	// Set the pixel data  	var data = bitmap.LockBits (new Rectangle (0' 0' bitmap.Width' bitmap.Height)' ImageLockMode.ReadWrite' bitmap.PixelFormat);  	Marshal.Copy (pixels' 0' data.Scan0' data.Width * data.Height);  	bitmap.UnlockBits (data);  	return bitmap;  }  
Magic Number,Sledge.Providers.Texture,SprProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\SprProvider.cs,Parse,The following statement contains a magic number: using (var br = new BinaryReader (File.Open (file' FileMode.Open' FileAccess.Read' FileShare.ReadWrite))) {  	var idst = br.ReadFixedLengthString (Encoding.ASCII' 4);  	if (idst != "IDSP")  		return null;  	var version = br.ReadInt32 ();  	if (version != 2)  		return null;  	var type = (SpriteOrientation)br.ReadInt32 ();  	var texFormat = (SpriteRenderMode)br.ReadInt32 ();  	var boundingRadius = br.ReadSingle ();  	var width = br.ReadInt32 ();  	var height = br.ReadInt32 ();  	var numframes = br.ReadInt32 ();  	var beamlength = br.ReadSingle ();  	var synctype = br.ReadInt32 ();  	var paletteSize = br.ReadInt16 ();  	var palette = br.ReadBytes (paletteSize * 3);  	if (paletteSize > 256)  		paletteSize = 256;  	// Don't accept anything higher  	var colours = new Color[256];  	for (var i = 0; i < paletteSize; i++) {  		var r = palette [i * 3 + 0];  		var g = palette [i * 3 + 1];  		var b = palette [i * 3 + 2];  		colours [i] = Color.FromArgb (255' r' g' b);  	}  	// Only read the first frame.  	var frametype = br.ReadInt32 ();  	if (frametype != 0) {  		var num = br.ReadInt32 ();  		var intervals = br.ReadSingleArray (num);  	}  	var originX = br.ReadInt32 ();  	var originY = br.ReadInt32 ();  	var framewidth = br.ReadInt32 ();  	var frameheight = br.ReadInt32 ();  	var pixels = br.ReadBytes (framewidth * frameheight);  	var bitmap = new Bitmap (framewidth' frameheight' PixelFormat.Format8bppIndexed);  	// Pre-process the palette  	var pal = bitmap.Palette;  	var last = colours [255];  	for (var i = 0; i < paletteSize; i++) {  		var c = colours [i];  		if (texFormat == SpriteRenderMode.Additive) {  			var a = (int)((c.R + c.G + c.B) / 3f);  			c = Color.FromArgb (a' c);  		} else if (texFormat == SpriteRenderMode.IndexAlpha && i < 255) {  			var a = (int)((c.R + c.G + c.B) / 3f);  			c = Color.FromArgb (a' last);  		}  		pal.Entries [i] = c;  	}  	if (texFormat == SpriteRenderMode.AlphaTest) {  		pal.Entries [255] = Color.FromArgb (0' 0' 0' 0);  	}  	bitmap.Palette = pal;  	// Set the pixel data  	var data = bitmap.LockBits (new Rectangle (0' 0' bitmap.Width' bitmap.Height)' ImageLockMode.ReadWrite' bitmap.PixelFormat);  	Marshal.Copy (pixels' 0' data.Scan0' data.Width * data.Height);  	bitmap.UnlockBits (data);  	return bitmap;  }  
Magic Number,Sledge.Providers.Texture,SprProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\SprProvider.cs,Parse,The following statement contains a magic number: using (var br = new BinaryReader (File.Open (file' FileMode.Open' FileAccess.Read' FileShare.ReadWrite))) {  	var idst = br.ReadFixedLengthString (Encoding.ASCII' 4);  	if (idst != "IDSP")  		return null;  	var version = br.ReadInt32 ();  	if (version != 2)  		return null;  	var type = (SpriteOrientation)br.ReadInt32 ();  	var texFormat = (SpriteRenderMode)br.ReadInt32 ();  	var boundingRadius = br.ReadSingle ();  	var width = br.ReadInt32 ();  	var height = br.ReadInt32 ();  	var numframes = br.ReadInt32 ();  	var beamlength = br.ReadSingle ();  	var synctype = br.ReadInt32 ();  	var paletteSize = br.ReadInt16 ();  	var palette = br.ReadBytes (paletteSize * 3);  	if (paletteSize > 256)  		paletteSize = 256;  	// Don't accept anything higher  	var colours = new Color[256];  	for (var i = 0; i < paletteSize; i++) {  		var r = palette [i * 3 + 0];  		var g = palette [i * 3 + 1];  		var b = palette [i * 3 + 2];  		colours [i] = Color.FromArgb (255' r' g' b);  	}  	// Only read the first frame.  	var frametype = br.ReadInt32 ();  	if (frametype != 0) {  		var num = br.ReadInt32 ();  		var intervals = br.ReadSingleArray (num);  	}  	var originX = br.ReadInt32 ();  	var originY = br.ReadInt32 ();  	var framewidth = br.ReadInt32 ();  	var frameheight = br.ReadInt32 ();  	var pixels = br.ReadBytes (framewidth * frameheight);  	var bitmap = new Bitmap (framewidth' frameheight' PixelFormat.Format8bppIndexed);  	// Pre-process the palette  	var pal = bitmap.Palette;  	var last = colours [255];  	for (var i = 0; i < paletteSize; i++) {  		var c = colours [i];  		if (texFormat == SpriteRenderMode.Additive) {  			var a = (int)((c.R + c.G + c.B) / 3f);  			c = Color.FromArgb (a' c);  		} else if (texFormat == SpriteRenderMode.IndexAlpha && i < 255) {  			var a = (int)((c.R + c.G + c.B) / 3f);  			c = Color.FromArgb (a' last);  		}  		pal.Entries [i] = c;  	}  	if (texFormat == SpriteRenderMode.AlphaTest) {  		pal.Entries [255] = Color.FromArgb (0' 0' 0' 0);  	}  	bitmap.Palette = pal;  	// Set the pixel data  	var data = bitmap.LockBits (new Rectangle (0' 0' bitmap.Width' bitmap.Height)' ImageLockMode.ReadWrite' bitmap.PixelFormat);  	Marshal.Copy (pixels' 0' data.Scan0' data.Width * data.Height);  	bitmap.UnlockBits (data);  	return bitmap;  }  
Magic Number,Sledge.Providers.Texture,SprProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\SprProvider.cs,Parse,The following statement contains a magic number: using (var br = new BinaryReader (File.Open (file' FileMode.Open' FileAccess.Read' FileShare.ReadWrite))) {  	var idst = br.ReadFixedLengthString (Encoding.ASCII' 4);  	if (idst != "IDSP")  		return null;  	var version = br.ReadInt32 ();  	if (version != 2)  		return null;  	var type = (SpriteOrientation)br.ReadInt32 ();  	var texFormat = (SpriteRenderMode)br.ReadInt32 ();  	var boundingRadius = br.ReadSingle ();  	var width = br.ReadInt32 ();  	var height = br.ReadInt32 ();  	var numframes = br.ReadInt32 ();  	var beamlength = br.ReadSingle ();  	var synctype = br.ReadInt32 ();  	var paletteSize = br.ReadInt16 ();  	var palette = br.ReadBytes (paletteSize * 3);  	if (paletteSize > 256)  		paletteSize = 256;  	// Don't accept anything higher  	var colours = new Color[256];  	for (var i = 0; i < paletteSize; i++) {  		var r = palette [i * 3 + 0];  		var g = palette [i * 3 + 1];  		var b = palette [i * 3 + 2];  		colours [i] = Color.FromArgb (255' r' g' b);  	}  	// Only read the first frame.  	var frametype = br.ReadInt32 ();  	if (frametype != 0) {  		var num = br.ReadInt32 ();  		var intervals = br.ReadSingleArray (num);  	}  	var originX = br.ReadInt32 ();  	var originY = br.ReadInt32 ();  	var framewidth = br.ReadInt32 ();  	var frameheight = br.ReadInt32 ();  	var pixels = br.ReadBytes (framewidth * frameheight);  	var bitmap = new Bitmap (framewidth' frameheight' PixelFormat.Format8bppIndexed);  	// Pre-process the palette  	var pal = bitmap.Palette;  	var last = colours [255];  	for (var i = 0; i < paletteSize; i++) {  		var c = colours [i];  		if (texFormat == SpriteRenderMode.Additive) {  			var a = (int)((c.R + c.G + c.B) / 3f);  			c = Color.FromArgb (a' c);  		} else if (texFormat == SpriteRenderMode.IndexAlpha && i < 255) {  			var a = (int)((c.R + c.G + c.B) / 3f);  			c = Color.FromArgb (a' last);  		}  		pal.Entries [i] = c;  	}  	if (texFormat == SpriteRenderMode.AlphaTest) {  		pal.Entries [255] = Color.FromArgb (0' 0' 0' 0);  	}  	bitmap.Palette = pal;  	// Set the pixel data  	var data = bitmap.LockBits (new Rectangle (0' 0' bitmap.Width' bitmap.Height)' ImageLockMode.ReadWrite' bitmap.PixelFormat);  	Marshal.Copy (pixels' 0' data.Scan0' data.Width * data.Height);  	bitmap.UnlockBits (data);  	return bitmap;  }  
Magic Number,Sledge.Providers.Texture,SprProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\SprProvider.cs,Parse,The following statement contains a magic number: using (var br = new BinaryReader (File.Open (file' FileMode.Open' FileAccess.Read' FileShare.ReadWrite))) {  	var idst = br.ReadFixedLengthString (Encoding.ASCII' 4);  	if (idst != "IDSP")  		return null;  	var version = br.ReadInt32 ();  	if (version != 2)  		return null;  	var type = (SpriteOrientation)br.ReadInt32 ();  	var texFormat = (SpriteRenderMode)br.ReadInt32 ();  	var boundingRadius = br.ReadSingle ();  	var width = br.ReadInt32 ();  	var height = br.ReadInt32 ();  	var numframes = br.ReadInt32 ();  	var beamlength = br.ReadSingle ();  	var synctype = br.ReadInt32 ();  	var paletteSize = br.ReadInt16 ();  	var palette = br.ReadBytes (paletteSize * 3);  	if (paletteSize > 256)  		paletteSize = 256;  	// Don't accept anything higher  	var colours = new Color[256];  	for (var i = 0; i < paletteSize; i++) {  		var r = palette [i * 3 + 0];  		var g = palette [i * 3 + 1];  		var b = palette [i * 3 + 2];  		colours [i] = Color.FromArgb (255' r' g' b);  	}  	// Only read the first frame.  	var frametype = br.ReadInt32 ();  	if (frametype != 0) {  		var num = br.ReadInt32 ();  		var intervals = br.ReadSingleArray (num);  	}  	var originX = br.ReadInt32 ();  	var originY = br.ReadInt32 ();  	var framewidth = br.ReadInt32 ();  	var frameheight = br.ReadInt32 ();  	var pixels = br.ReadBytes (framewidth * frameheight);  	var bitmap = new Bitmap (framewidth' frameheight' PixelFormat.Format8bppIndexed);  	// Pre-process the palette  	var pal = bitmap.Palette;  	var last = colours [255];  	for (var i = 0; i < paletteSize; i++) {  		var c = colours [i];  		if (texFormat == SpriteRenderMode.Additive) {  			var a = (int)((c.R + c.G + c.B) / 3f);  			c = Color.FromArgb (a' c);  		} else if (texFormat == SpriteRenderMode.IndexAlpha && i < 255) {  			var a = (int)((c.R + c.G + c.B) / 3f);  			c = Color.FromArgb (a' last);  		}  		pal.Entries [i] = c;  	}  	if (texFormat == SpriteRenderMode.AlphaTest) {  		pal.Entries [255] = Color.FromArgb (0' 0' 0' 0);  	}  	bitmap.Palette = pal;  	// Set the pixel data  	var data = bitmap.LockBits (new Rectangle (0' 0' bitmap.Width' bitmap.Height)' ImageLockMode.ReadWrite' bitmap.PixelFormat);  	Marshal.Copy (pixels' 0' data.Scan0' data.Width * data.Height);  	bitmap.UnlockBits (data);  	return bitmap;  }  
Magic Number,Sledge.Providers.Texture,SprProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\SprProvider.cs,Parse,The following statement contains a magic number: using (var br = new BinaryReader (File.Open (file' FileMode.Open' FileAccess.Read' FileShare.ReadWrite))) {  	var idst = br.ReadFixedLengthString (Encoding.ASCII' 4);  	if (idst != "IDSP")  		return null;  	var version = br.ReadInt32 ();  	if (version != 2)  		return null;  	var type = (SpriteOrientation)br.ReadInt32 ();  	var texFormat = (SpriteRenderMode)br.ReadInt32 ();  	var boundingRadius = br.ReadSingle ();  	var width = br.ReadInt32 ();  	var height = br.ReadInt32 ();  	var numframes = br.ReadInt32 ();  	var beamlength = br.ReadSingle ();  	var synctype = br.ReadInt32 ();  	var paletteSize = br.ReadInt16 ();  	var palette = br.ReadBytes (paletteSize * 3);  	if (paletteSize > 256)  		paletteSize = 256;  	// Don't accept anything higher  	var colours = new Color[256];  	for (var i = 0; i < paletteSize; i++) {  		var r = palette [i * 3 + 0];  		var g = palette [i * 3 + 1];  		var b = palette [i * 3 + 2];  		colours [i] = Color.FromArgb (255' r' g' b);  	}  	// Only read the first frame.  	var frametype = br.ReadInt32 ();  	if (frametype != 0) {  		var num = br.ReadInt32 ();  		var intervals = br.ReadSingleArray (num);  	}  	var originX = br.ReadInt32 ();  	var originY = br.ReadInt32 ();  	var framewidth = br.ReadInt32 ();  	var frameheight = br.ReadInt32 ();  	var pixels = br.ReadBytes (framewidth * frameheight);  	var bitmap = new Bitmap (framewidth' frameheight' PixelFormat.Format8bppIndexed);  	// Pre-process the palette  	var pal = bitmap.Palette;  	var last = colours [255];  	for (var i = 0; i < paletteSize; i++) {  		var c = colours [i];  		if (texFormat == SpriteRenderMode.Additive) {  			var a = (int)((c.R + c.G + c.B) / 3f);  			c = Color.FromArgb (a' c);  		} else if (texFormat == SpriteRenderMode.IndexAlpha && i < 255) {  			var a = (int)((c.R + c.G + c.B) / 3f);  			c = Color.FromArgb (a' last);  		}  		pal.Entries [i] = c;  	}  	if (texFormat == SpriteRenderMode.AlphaTest) {  		pal.Entries [255] = Color.FromArgb (0' 0' 0' 0);  	}  	bitmap.Palette = pal;  	// Set the pixel data  	var data = bitmap.LockBits (new Rectangle (0' 0' bitmap.Width' bitmap.Height)' ImageLockMode.ReadWrite' bitmap.PixelFormat);  	Marshal.Copy (pixels' 0' data.Scan0' data.Width * data.Height);  	bitmap.UnlockBits (data);  	return bitmap;  }  
Magic Number,Sledge.Providers.Texture,SprProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\SprProvider.cs,Parse,The following statement contains a magic number: using (var br = new BinaryReader (File.Open (file' FileMode.Open' FileAccess.Read' FileShare.ReadWrite))) {  	var idst = br.ReadFixedLengthString (Encoding.ASCII' 4);  	if (idst != "IDSP")  		return null;  	var version = br.ReadInt32 ();  	if (version != 2)  		return null;  	var type = (SpriteOrientation)br.ReadInt32 ();  	var texFormat = (SpriteRenderMode)br.ReadInt32 ();  	var boundingRadius = br.ReadSingle ();  	var width = br.ReadInt32 ();  	var height = br.ReadInt32 ();  	var numframes = br.ReadInt32 ();  	var beamlength = br.ReadSingle ();  	var synctype = br.ReadInt32 ();  	var paletteSize = br.ReadInt16 ();  	var palette = br.ReadBytes (paletteSize * 3);  	if (paletteSize > 256)  		paletteSize = 256;  	// Don't accept anything higher  	var colours = new Color[256];  	for (var i = 0; i < paletteSize; i++) {  		var r = palette [i * 3 + 0];  		var g = palette [i * 3 + 1];  		var b = palette [i * 3 + 2];  		colours [i] = Color.FromArgb (255' r' g' b);  	}  	// Only read the first frame.  	var frametype = br.ReadInt32 ();  	if (frametype != 0) {  		var num = br.ReadInt32 ();  		var intervals = br.ReadSingleArray (num);  	}  	var originX = br.ReadInt32 ();  	var originY = br.ReadInt32 ();  	var framewidth = br.ReadInt32 ();  	var frameheight = br.ReadInt32 ();  	var pixels = br.ReadBytes (framewidth * frameheight);  	var bitmap = new Bitmap (framewidth' frameheight' PixelFormat.Format8bppIndexed);  	// Pre-process the palette  	var pal = bitmap.Palette;  	var last = colours [255];  	for (var i = 0; i < paletteSize; i++) {  		var c = colours [i];  		if (texFormat == SpriteRenderMode.Additive) {  			var a = (int)((c.R + c.G + c.B) / 3f);  			c = Color.FromArgb (a' c);  		} else if (texFormat == SpriteRenderMode.IndexAlpha && i < 255) {  			var a = (int)((c.R + c.G + c.B) / 3f);  			c = Color.FromArgb (a' last);  		}  		pal.Entries [i] = c;  	}  	if (texFormat == SpriteRenderMode.AlphaTest) {  		pal.Entries [255] = Color.FromArgb (0' 0' 0' 0);  	}  	bitmap.Palette = pal;  	// Set the pixel data  	var data = bitmap.LockBits (new Rectangle (0' 0' bitmap.Width' bitmap.Height)' ImageLockMode.ReadWrite' bitmap.PixelFormat);  	Marshal.Copy (pixels' 0' data.Scan0' data.Width * data.Height);  	bitmap.UnlockBits (data);  	return bitmap;  }  
Magic Number,Sledge.Providers.Texture,SprProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\SprProvider.cs,Parse,The following statement contains a magic number: using (var br = new BinaryReader (File.Open (file' FileMode.Open' FileAccess.Read' FileShare.ReadWrite))) {  	var idst = br.ReadFixedLengthString (Encoding.ASCII' 4);  	if (idst != "IDSP")  		return null;  	var version = br.ReadInt32 ();  	if (version != 2)  		return null;  	var type = (SpriteOrientation)br.ReadInt32 ();  	var texFormat = (SpriteRenderMode)br.ReadInt32 ();  	var boundingRadius = br.ReadSingle ();  	var width = br.ReadInt32 ();  	var height = br.ReadInt32 ();  	var numframes = br.ReadInt32 ();  	var beamlength = br.ReadSingle ();  	var synctype = br.ReadInt32 ();  	var paletteSize = br.ReadInt16 ();  	var palette = br.ReadBytes (paletteSize * 3);  	if (paletteSize > 256)  		paletteSize = 256;  	// Don't accept anything higher  	var colours = new Color[256];  	for (var i = 0; i < paletteSize; i++) {  		var r = palette [i * 3 + 0];  		var g = palette [i * 3 + 1];  		var b = palette [i * 3 + 2];  		colours [i] = Color.FromArgb (255' r' g' b);  	}  	// Only read the first frame.  	var frametype = br.ReadInt32 ();  	if (frametype != 0) {  		var num = br.ReadInt32 ();  		var intervals = br.ReadSingleArray (num);  	}  	var originX = br.ReadInt32 ();  	var originY = br.ReadInt32 ();  	var framewidth = br.ReadInt32 ();  	var frameheight = br.ReadInt32 ();  	var pixels = br.ReadBytes (framewidth * frameheight);  	var bitmap = new Bitmap (framewidth' frameheight' PixelFormat.Format8bppIndexed);  	// Pre-process the palette  	var pal = bitmap.Palette;  	var last = colours [255];  	for (var i = 0; i < paletteSize; i++) {  		var c = colours [i];  		if (texFormat == SpriteRenderMode.Additive) {  			var a = (int)((c.R + c.G + c.B) / 3f);  			c = Color.FromArgb (a' c);  		} else if (texFormat == SpriteRenderMode.IndexAlpha && i < 255) {  			var a = (int)((c.R + c.G + c.B) / 3f);  			c = Color.FromArgb (a' last);  		}  		pal.Entries [i] = c;  	}  	if (texFormat == SpriteRenderMode.AlphaTest) {  		pal.Entries [255] = Color.FromArgb (0' 0' 0' 0);  	}  	bitmap.Palette = pal;  	// Set the pixel data  	var data = bitmap.LockBits (new Rectangle (0' 0' bitmap.Width' bitmap.Height)' ImageLockMode.ReadWrite' bitmap.PixelFormat);  	Marshal.Copy (pixels' 0' data.Scan0' data.Width * data.Height);  	bitmap.UnlockBits (data);  	return bitmap;  }  
Magic Number,Sledge.Providers.Texture,SprProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\SprProvider.cs,Parse,The following statement contains a magic number: if (version != 2)  	return null;  
Magic Number,Sledge.Providers.Texture,SprProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\SprProvider.cs,Parse,The following statement contains a magic number: if (paletteSize > 256)  	paletteSize = 256;  
Magic Number,Sledge.Providers.Texture,SprProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\SprProvider.cs,Parse,The following statement contains a magic number: if (paletteSize > 256)  	paletteSize = 256;  
Magic Number,Sledge.Providers.Texture,SprProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\SprProvider.cs,Parse,The following statement contains a magic number: paletteSize = 256;  
Magic Number,Sledge.Providers.Texture,SprProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\SprProvider.cs,Parse,The following statement contains a magic number: for (var i = 0; i < paletteSize; i++) {  	var r = palette [i * 3 + 0];  	var g = palette [i * 3 + 1];  	var b = palette [i * 3 + 2];  	colours [i] = Color.FromArgb (255' r' g' b);  }  
Magic Number,Sledge.Providers.Texture,SprProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\SprProvider.cs,Parse,The following statement contains a magic number: for (var i = 0; i < paletteSize; i++) {  	var r = palette [i * 3 + 0];  	var g = palette [i * 3 + 1];  	var b = palette [i * 3 + 2];  	colours [i] = Color.FromArgb (255' r' g' b);  }  
Magic Number,Sledge.Providers.Texture,SprProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\SprProvider.cs,Parse,The following statement contains a magic number: for (var i = 0; i < paletteSize; i++) {  	var r = palette [i * 3 + 0];  	var g = palette [i * 3 + 1];  	var b = palette [i * 3 + 2];  	colours [i] = Color.FromArgb (255' r' g' b);  }  
Magic Number,Sledge.Providers.Texture,SprProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\SprProvider.cs,Parse,The following statement contains a magic number: for (var i = 0; i < paletteSize; i++) {  	var r = palette [i * 3 + 0];  	var g = palette [i * 3 + 1];  	var b = palette [i * 3 + 2];  	colours [i] = Color.FromArgb (255' r' g' b);  }  
Magic Number,Sledge.Providers.Texture,SprProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\SprProvider.cs,Parse,The following statement contains a magic number: for (var i = 0; i < paletteSize; i++) {  	var r = palette [i * 3 + 0];  	var g = palette [i * 3 + 1];  	var b = palette [i * 3 + 2];  	colours [i] = Color.FromArgb (255' r' g' b);  }  
Magic Number,Sledge.Providers.Texture,SprProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\SprProvider.cs,Parse,The following statement contains a magic number: colours [i] = Color.FromArgb (255' r' g' b);  
Magic Number,Sledge.Providers.Texture,SprProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\SprProvider.cs,Parse,The following statement contains a magic number: for (var i = 0; i < paletteSize; i++) {  	var c = colours [i];  	if (texFormat == SpriteRenderMode.Additive) {  		var a = (int)((c.R + c.G + c.B) / 3f);  		c = Color.FromArgb (a' c);  	} else if (texFormat == SpriteRenderMode.IndexAlpha && i < 255) {  		var a = (int)((c.R + c.G + c.B) / 3f);  		c = Color.FromArgb (a' last);  	}  	pal.Entries [i] = c;  }  
Magic Number,Sledge.Providers.Texture,SprProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\SprProvider.cs,Parse,The following statement contains a magic number: if (texFormat == SpriteRenderMode.Additive) {  	var a = (int)((c.R + c.G + c.B) / 3f);  	c = Color.FromArgb (a' c);  } else if (texFormat == SpriteRenderMode.IndexAlpha && i < 255) {  	var a = (int)((c.R + c.G + c.B) / 3f);  	c = Color.FromArgb (a' last);  }  
Magic Number,Sledge.Providers.Texture,SprProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\SprProvider.cs,Parse,The following statement contains a magic number: if (texFormat == SpriteRenderMode.IndexAlpha && i < 255) {  	var a = (int)((c.R + c.G + c.B) / 3f);  	c = Color.FromArgb (a' last);  }  
Magic Number,Sledge.Providers.Texture,SprProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\SprProvider.cs,Parse,The following statement contains a magic number: if (texFormat == SpriteRenderMode.AlphaTest) {  	pal.Entries [255] = Color.FromArgb (0' 0' 0' 0);  }  
Magic Number,Sledge.Providers.Texture,SprProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\SprProvider.cs,Parse,The following statement contains a magic number: pal.Entries [255] = Color.FromArgb (0' 0' 0' 0);  
Magic Number,Sledge.Providers.Texture,WadProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\WadProvider.cs,PostProcessBitmap,The following statement contains a magic number: if (ReplaceTransparentPixels && name.StartsWith ("{")) {  	hasTransparency = true;  	var palette = bmp.Palette;  	// Two transparency types: "blue" transparency and "decal" transparency  	// Decal transparency is all greyscale and doesn't contain any of palette #255 colour  	/*                 var blueTransparency = false;                 for (var i = 0; i < palette.Entries.Length - 1; i++)                 {                     var color = palette.Entries[i];                     if (color.R != color.B || color.R != color.G || color.B != color.G)                     {                         blueTransparency = true;                         break;                     }                 }*/// Can't be clever and detect the transparency type automatically - Goldsource is too unpredictable  	var blueTransparency = packageName.IndexOf ("decal"' StringComparison.CurrentCultureIgnoreCase) < 0;  	if (blueTransparency) {  		// We found the last index' therefore it should be transparent  		palette.Entries [palette.Entries.Length - 1] = Color.Transparent;  	} else {  		// If we didn't find the last index' we have a decal  		var last = palette.Entries [palette.Entries.Length - 1];  		// If the first item is black' we need to flip the transparency calculation (I think...)  		var isBlack = palette.Entries [0].R == 0 && palette.Entries [0].G == 0 && palette.Entries [0].B == 0;  		for (var i = 0; i < palette.Entries.Length - 1; i++) {  			palette.Entries [i] = Color.FromArgb (isBlack ? palette.Entries [i].R : 255 - palette.Entries [i].R' last);  		}  	}  	bmp.Palette = palette;  	// Copy the bitmap to a new one with a proper alpha channel  	var clone = new Bitmap (bmp.Width' bmp.Height' PixelFormat.Format32bppArgb);  	using (var g = System.Drawing.Graphics.FromImage (clone)) {  		g.DrawImage (bmp' new Rectangle (0' 0' clone.Width' clone.Height));  	}  	bmp.Dispose ();  	return clone;  }  
Magic Number,Sledge.Providers.Texture,WadProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\WadProvider.cs,PostProcessBitmap,The following statement contains a magic number: if (blueTransparency) {  	// We found the last index' therefore it should be transparent  	palette.Entries [palette.Entries.Length - 1] = Color.Transparent;  } else {  	// If we didn't find the last index' we have a decal  	var last = palette.Entries [palette.Entries.Length - 1];  	// If the first item is black' we need to flip the transparency calculation (I think...)  	var isBlack = palette.Entries [0].R == 0 && palette.Entries [0].G == 0 && palette.Entries [0].B == 0;  	for (var i = 0; i < palette.Entries.Length - 1; i++) {  		palette.Entries [i] = Color.FromArgb (isBlack ? palette.Entries [i].R : 255 - palette.Entries [i].R' last);  	}  }  
Magic Number,Sledge.Providers.Texture,WadProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\WadProvider.cs,PostProcessBitmap,The following statement contains a magic number: for (var i = 0; i < palette.Entries.Length - 1; i++) {  	palette.Entries [i] = Color.FromArgb (isBlack ? palette.Entries [i].R : 255 - palette.Entries [i].R' last);  }  
Magic Number,Sledge.Providers.Texture,WadProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\WadProvider.cs,PostProcessBitmap,The following statement contains a magic number: palette.Entries [i] = Color.FromArgb (isBlack ? palette.Entries [i].R : 255 - palette.Entries [i].R' last);  
Magic Number,Sledge.Providers.Texture,WadProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\WadProvider.cs,LoadFromCache,The following statement contains a magic number: if (lines.Length < 3)  	return false;  
Magic Number,Sledge.Providers.Texture,WadProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\WadProvider.cs,LoadFromCache,The following statement contains a magic number: if (lines [2] != fi.Length.ToString (CultureInfo.InvariantCulture))  	return false;  
Magic Number,Sledge.Providers.Texture,WadProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\WadProvider.cs,LoadFromCache,The following statement contains a magic number: try {  	var items = new List<TextureItem> ();  	foreach (var line in lines.Skip (3)) {  		var spl = line.Split (NullCharacter);  		items.Add (new TextureItem (package' spl [0]' GetFlags (spl [0])' int.Parse (spl [1]' CultureInfo.InvariantCulture)' int.Parse (spl [2]' CultureInfo.InvariantCulture)));  	}  	items.ForEach (package.AddTexture);  } catch {  	// Cache file is no good...  	return false;  }  
Magic Number,Sledge.Providers.Texture,WadProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\WadProvider.cs,LoadFromCache,The following statement contains a magic number: try {  	var items = new List<TextureItem> ();  	foreach (var line in lines.Skip (3)) {  		var spl = line.Split (NullCharacter);  		items.Add (new TextureItem (package' spl [0]' GetFlags (spl [0])' int.Parse (spl [1]' CultureInfo.InvariantCulture)' int.Parse (spl [2]' CultureInfo.InvariantCulture)));  	}  	items.ForEach (package.AddTexture);  } catch {  	// Cache file is no good...  	return false;  }  
Magic Number,Sledge.Providers.Texture,WadProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\WadProvider.cs,LoadFromCache,The following statement contains a magic number: foreach (var line in lines.Skip (3)) {  	var spl = line.Split (NullCharacter);  	items.Add (new TextureItem (package' spl [0]' GetFlags (spl [0])' int.Parse (spl [1]' CultureInfo.InvariantCulture)' int.Parse (spl [2]' CultureInfo.InvariantCulture)));  }  
Magic Number,Sledge.Providers.Texture,WadProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\WadProvider.cs,LoadFromCache,The following statement contains a magic number: foreach (var line in lines.Skip (3)) {  	var spl = line.Split (NullCharacter);  	items.Add (new TextureItem (package' spl [0]' GetFlags (spl [0])' int.Parse (spl [1]' CultureInfo.InvariantCulture)' int.Parse (spl [2]' CultureInfo.InvariantCulture)));  }  
Magic Number,Sledge.Providers.Texture,WadProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\WadProvider.cs,LoadFromCache,The following statement contains a magic number: items.Add (new TextureItem (package' spl [0]' GetFlags (spl [0])' int.Parse (spl [1]' CultureInfo.InvariantCulture)' int.Parse (spl [2]' CultureInfo.InvariantCulture)));  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,GetSize,The following statement contains a magic number: using (var br = new BinaryReader (stream)) {  	var header = br.ReadFixedLengthString (Encoding.ASCII' 4);  	if (header != VtfHeader)  		throw new ProviderException ("Invalid VTF header. Expected '" + VtfHeader + "'' got '" + header + "'.");  	var v1 = br.ReadUInt32 ();  	var v2 = br.ReadUInt32 ();  	var version = v1 + (v2 / 10);  	// e.g. 7.3  	var headerSize = br.ReadUInt32 ();  	var width = br.ReadUInt16 ();  	var height = br.ReadUInt16 ();  	return new Size (width' height);  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,GetSize,The following statement contains a magic number: using (var br = new BinaryReader (stream)) {  	var header = br.ReadFixedLengthString (Encoding.ASCII' 4);  	if (header != VtfHeader)  		throw new ProviderException ("Invalid VTF header. Expected '" + VtfHeader + "'' got '" + header + "'.");  	var v1 = br.ReadUInt32 ();  	var v2 = br.ReadUInt32 ();  	var version = v1 + (v2 / 10);  	// e.g. 7.3  	var headerSize = br.ReadUInt32 ();  	var width = br.ReadUInt16 ();  	var height = br.ReadUInt16 ();  	return new Size (width' height);  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,GetImage,The following statement contains a magic number: using (var br = new BinaryReader (stream)) {  	var header = br.ReadFixedLengthString (Encoding.ASCII' 4);  	if (header != VtfHeader)  		throw new ProviderException ("Invalid VTF header. Expected '" + VtfHeader + "'' got '" + header + "'.");  	var v1 = br.ReadUInt32 ();  	var v2 = br.ReadUInt32 ();  	var version = v1 + (v2 / 10m);  	// e.g. 7.3  	var headerSize = br.ReadUInt32 ();  	var width = br.ReadUInt16 ();  	var height = br.ReadUInt16 ();  	var flags = (VtfImageFlag)br.ReadUInt32 ();  	var numFrames = br.ReadUInt16 ();  	var firstFrame = br.ReadUInt16 ();  	br.ReadBytes (4);  	// padding  	var reflectivity = br.ReadCoordinate ();  	br.ReadBytes (4);  	// padding  	var bumpmapScale = br.ReadSingle ();  	var highResImageFormat = (VtfImageFormat)br.ReadUInt32 ();  	var mipmapCount = br.ReadByte ();  	var lowResImageFormat = (VtfImageFormat)br.ReadUInt32 ();  	var lowResWidth = br.ReadByte ();  	var lowResHeight = br.ReadByte ();  	ushort depth = 1;  	uint numResources = 0;  	if (version >= 7.2m) {  		depth = br.ReadUInt16 ();  	}  	if (version >= 7.3m) {  		br.ReadBytes (3);  		numResources = br.ReadUInt32 ();  	}  	var faces = 1;  	if (flags.HasFlag (VtfImageFlag.Envmap)) {  		faces = version < 7.5m && firstFrame != 0xFFFF ? 7 : 6;  	}  	var imageSize = ComputeImageSize (width' height' depth' mipmapCount' highResImageFormat) * faces * numFrames;  	var thumbnailSize = lowResImageFormat == VtfImageFormat.None ? 0 : ComputeImageSize (lowResWidth' lowResHeight' 1' lowResImageFormat);  	var thumbnailPos = headerSize;  	var dataPos = headerSize + thumbnailSize;  	for (var i = 0; i < numResources; i++) {  		var type = br.ReadUInt32 ();  		var data = br.ReadUInt32 ();  		switch (type) {  		case 0x01:  			// Low res image  			thumbnailPos = data;  			break;  		case 0x30:  			// Regular image  			dataPos = data;  			break;  		}  	}  	if (lowResImageFormat != VtfImageFormat.None) {  		br.BaseStream.Position = thumbnailPos;  		var thumbnail = br.ReadBytes ((int)thumbnailSize);  		//var thumbImage = LoadImage(br' lowResWidth' lowResHeight' lowResImageFormat);  		//return thumbImage;  	}  	var mipNum = 0;  	if (maxWidth > 0 || maxHeight > 0)  		mipNum = GetMipToLoad (width' height' maxWidth > 0 ? maxWidth : width' maxHeight > 0 ? maxHeight : height' mipmapCount);  	for (var frame = 0; frame < numFrames; frame++) {  		for (var face = 0; face < faces; face++) {  			for (var slice = 0; slice < depth; slice++) {  				for (var mip = mipNum; mip < mipmapCount; mip++) {  					var wid = MipmapResize (width' mip);  					var hei = MipmapResize (height' mip);  					var offset = GetImageDataLocation (frame' face' slice' mip' highResImageFormat' width' height' numFrames' faces' depth' mipmapCount);  					br.BaseStream.Position = offset + dataPos;  					var img = LoadImage (br' (uint)wid' (uint)hei' highResImageFormat);  					//img.Save(String.Format(@"D:\Github\sledge\_Resources\VTF\_test_fr{0}_fa{1}_sl{2}_m{3}.png"' frame' face' slice' mip));  					return img;  				}  			}  		}  	}  	return null;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,GetImage,The following statement contains a magic number: using (var br = new BinaryReader (stream)) {  	var header = br.ReadFixedLengthString (Encoding.ASCII' 4);  	if (header != VtfHeader)  		throw new ProviderException ("Invalid VTF header. Expected '" + VtfHeader + "'' got '" + header + "'.");  	var v1 = br.ReadUInt32 ();  	var v2 = br.ReadUInt32 ();  	var version = v1 + (v2 / 10m);  	// e.g. 7.3  	var headerSize = br.ReadUInt32 ();  	var width = br.ReadUInt16 ();  	var height = br.ReadUInt16 ();  	var flags = (VtfImageFlag)br.ReadUInt32 ();  	var numFrames = br.ReadUInt16 ();  	var firstFrame = br.ReadUInt16 ();  	br.ReadBytes (4);  	// padding  	var reflectivity = br.ReadCoordinate ();  	br.ReadBytes (4);  	// padding  	var bumpmapScale = br.ReadSingle ();  	var highResImageFormat = (VtfImageFormat)br.ReadUInt32 ();  	var mipmapCount = br.ReadByte ();  	var lowResImageFormat = (VtfImageFormat)br.ReadUInt32 ();  	var lowResWidth = br.ReadByte ();  	var lowResHeight = br.ReadByte ();  	ushort depth = 1;  	uint numResources = 0;  	if (version >= 7.2m) {  		depth = br.ReadUInt16 ();  	}  	if (version >= 7.3m) {  		br.ReadBytes (3);  		numResources = br.ReadUInt32 ();  	}  	var faces = 1;  	if (flags.HasFlag (VtfImageFlag.Envmap)) {  		faces = version < 7.5m && firstFrame != 0xFFFF ? 7 : 6;  	}  	var imageSize = ComputeImageSize (width' height' depth' mipmapCount' highResImageFormat) * faces * numFrames;  	var thumbnailSize = lowResImageFormat == VtfImageFormat.None ? 0 : ComputeImageSize (lowResWidth' lowResHeight' 1' lowResImageFormat);  	var thumbnailPos = headerSize;  	var dataPos = headerSize + thumbnailSize;  	for (var i = 0; i < numResources; i++) {  		var type = br.ReadUInt32 ();  		var data = br.ReadUInt32 ();  		switch (type) {  		case 0x01:  			// Low res image  			thumbnailPos = data;  			break;  		case 0x30:  			// Regular image  			dataPos = data;  			break;  		}  	}  	if (lowResImageFormat != VtfImageFormat.None) {  		br.BaseStream.Position = thumbnailPos;  		var thumbnail = br.ReadBytes ((int)thumbnailSize);  		//var thumbImage = LoadImage(br' lowResWidth' lowResHeight' lowResImageFormat);  		//return thumbImage;  	}  	var mipNum = 0;  	if (maxWidth > 0 || maxHeight > 0)  		mipNum = GetMipToLoad (width' height' maxWidth > 0 ? maxWidth : width' maxHeight > 0 ? maxHeight : height' mipmapCount);  	for (var frame = 0; frame < numFrames; frame++) {  		for (var face = 0; face < faces; face++) {  			for (var slice = 0; slice < depth; slice++) {  				for (var mip = mipNum; mip < mipmapCount; mip++) {  					var wid = MipmapResize (width' mip);  					var hei = MipmapResize (height' mip);  					var offset = GetImageDataLocation (frame' face' slice' mip' highResImageFormat' width' height' numFrames' faces' depth' mipmapCount);  					br.BaseStream.Position = offset + dataPos;  					var img = LoadImage (br' (uint)wid' (uint)hei' highResImageFormat);  					//img.Save(String.Format(@"D:\Github\sledge\_Resources\VTF\_test_fr{0}_fa{1}_sl{2}_m{3}.png"' frame' face' slice' mip));  					return img;  				}  			}  		}  	}  	return null;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,GetImage,The following statement contains a magic number: using (var br = new BinaryReader (stream)) {  	var header = br.ReadFixedLengthString (Encoding.ASCII' 4);  	if (header != VtfHeader)  		throw new ProviderException ("Invalid VTF header. Expected '" + VtfHeader + "'' got '" + header + "'.");  	var v1 = br.ReadUInt32 ();  	var v2 = br.ReadUInt32 ();  	var version = v1 + (v2 / 10m);  	// e.g. 7.3  	var headerSize = br.ReadUInt32 ();  	var width = br.ReadUInt16 ();  	var height = br.ReadUInt16 ();  	var flags = (VtfImageFlag)br.ReadUInt32 ();  	var numFrames = br.ReadUInt16 ();  	var firstFrame = br.ReadUInt16 ();  	br.ReadBytes (4);  	// padding  	var reflectivity = br.ReadCoordinate ();  	br.ReadBytes (4);  	// padding  	var bumpmapScale = br.ReadSingle ();  	var highResImageFormat = (VtfImageFormat)br.ReadUInt32 ();  	var mipmapCount = br.ReadByte ();  	var lowResImageFormat = (VtfImageFormat)br.ReadUInt32 ();  	var lowResWidth = br.ReadByte ();  	var lowResHeight = br.ReadByte ();  	ushort depth = 1;  	uint numResources = 0;  	if (version >= 7.2m) {  		depth = br.ReadUInt16 ();  	}  	if (version >= 7.3m) {  		br.ReadBytes (3);  		numResources = br.ReadUInt32 ();  	}  	var faces = 1;  	if (flags.HasFlag (VtfImageFlag.Envmap)) {  		faces = version < 7.5m && firstFrame != 0xFFFF ? 7 : 6;  	}  	var imageSize = ComputeImageSize (width' height' depth' mipmapCount' highResImageFormat) * faces * numFrames;  	var thumbnailSize = lowResImageFormat == VtfImageFormat.None ? 0 : ComputeImageSize (lowResWidth' lowResHeight' 1' lowResImageFormat);  	var thumbnailPos = headerSize;  	var dataPos = headerSize + thumbnailSize;  	for (var i = 0; i < numResources; i++) {  		var type = br.ReadUInt32 ();  		var data = br.ReadUInt32 ();  		switch (type) {  		case 0x01:  			// Low res image  			thumbnailPos = data;  			break;  		case 0x30:  			// Regular image  			dataPos = data;  			break;  		}  	}  	if (lowResImageFormat != VtfImageFormat.None) {  		br.BaseStream.Position = thumbnailPos;  		var thumbnail = br.ReadBytes ((int)thumbnailSize);  		//var thumbImage = LoadImage(br' lowResWidth' lowResHeight' lowResImageFormat);  		//return thumbImage;  	}  	var mipNum = 0;  	if (maxWidth > 0 || maxHeight > 0)  		mipNum = GetMipToLoad (width' height' maxWidth > 0 ? maxWidth : width' maxHeight > 0 ? maxHeight : height' mipmapCount);  	for (var frame = 0; frame < numFrames; frame++) {  		for (var face = 0; face < faces; face++) {  			for (var slice = 0; slice < depth; slice++) {  				for (var mip = mipNum; mip < mipmapCount; mip++) {  					var wid = MipmapResize (width' mip);  					var hei = MipmapResize (height' mip);  					var offset = GetImageDataLocation (frame' face' slice' mip' highResImageFormat' width' height' numFrames' faces' depth' mipmapCount);  					br.BaseStream.Position = offset + dataPos;  					var img = LoadImage (br' (uint)wid' (uint)hei' highResImageFormat);  					//img.Save(String.Format(@"D:\Github\sledge\_Resources\VTF\_test_fr{0}_fa{1}_sl{2}_m{3}.png"' frame' face' slice' mip));  					return img;  				}  			}  		}  	}  	return null;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,GetImage,The following statement contains a magic number: using (var br = new BinaryReader (stream)) {  	var header = br.ReadFixedLengthString (Encoding.ASCII' 4);  	if (header != VtfHeader)  		throw new ProviderException ("Invalid VTF header. Expected '" + VtfHeader + "'' got '" + header + "'.");  	var v1 = br.ReadUInt32 ();  	var v2 = br.ReadUInt32 ();  	var version = v1 + (v2 / 10m);  	// e.g. 7.3  	var headerSize = br.ReadUInt32 ();  	var width = br.ReadUInt16 ();  	var height = br.ReadUInt16 ();  	var flags = (VtfImageFlag)br.ReadUInt32 ();  	var numFrames = br.ReadUInt16 ();  	var firstFrame = br.ReadUInt16 ();  	br.ReadBytes (4);  	// padding  	var reflectivity = br.ReadCoordinate ();  	br.ReadBytes (4);  	// padding  	var bumpmapScale = br.ReadSingle ();  	var highResImageFormat = (VtfImageFormat)br.ReadUInt32 ();  	var mipmapCount = br.ReadByte ();  	var lowResImageFormat = (VtfImageFormat)br.ReadUInt32 ();  	var lowResWidth = br.ReadByte ();  	var lowResHeight = br.ReadByte ();  	ushort depth = 1;  	uint numResources = 0;  	if (version >= 7.2m) {  		depth = br.ReadUInt16 ();  	}  	if (version >= 7.3m) {  		br.ReadBytes (3);  		numResources = br.ReadUInt32 ();  	}  	var faces = 1;  	if (flags.HasFlag (VtfImageFlag.Envmap)) {  		faces = version < 7.5m && firstFrame != 0xFFFF ? 7 : 6;  	}  	var imageSize = ComputeImageSize (width' height' depth' mipmapCount' highResImageFormat) * faces * numFrames;  	var thumbnailSize = lowResImageFormat == VtfImageFormat.None ? 0 : ComputeImageSize (lowResWidth' lowResHeight' 1' lowResImageFormat);  	var thumbnailPos = headerSize;  	var dataPos = headerSize + thumbnailSize;  	for (var i = 0; i < numResources; i++) {  		var type = br.ReadUInt32 ();  		var data = br.ReadUInt32 ();  		switch (type) {  		case 0x01:  			// Low res image  			thumbnailPos = data;  			break;  		case 0x30:  			// Regular image  			dataPos = data;  			break;  		}  	}  	if (lowResImageFormat != VtfImageFormat.None) {  		br.BaseStream.Position = thumbnailPos;  		var thumbnail = br.ReadBytes ((int)thumbnailSize);  		//var thumbImage = LoadImage(br' lowResWidth' lowResHeight' lowResImageFormat);  		//return thumbImage;  	}  	var mipNum = 0;  	if (maxWidth > 0 || maxHeight > 0)  		mipNum = GetMipToLoad (width' height' maxWidth > 0 ? maxWidth : width' maxHeight > 0 ? maxHeight : height' mipmapCount);  	for (var frame = 0; frame < numFrames; frame++) {  		for (var face = 0; face < faces; face++) {  			for (var slice = 0; slice < depth; slice++) {  				for (var mip = mipNum; mip < mipmapCount; mip++) {  					var wid = MipmapResize (width' mip);  					var hei = MipmapResize (height' mip);  					var offset = GetImageDataLocation (frame' face' slice' mip' highResImageFormat' width' height' numFrames' faces' depth' mipmapCount);  					br.BaseStream.Position = offset + dataPos;  					var img = LoadImage (br' (uint)wid' (uint)hei' highResImageFormat);  					//img.Save(String.Format(@"D:\Github\sledge\_Resources\VTF\_test_fr{0}_fa{1}_sl{2}_m{3}.png"' frame' face' slice' mip));  					return img;  				}  			}  		}  	}  	return null;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,GetImage,The following statement contains a magic number: using (var br = new BinaryReader (stream)) {  	var header = br.ReadFixedLengthString (Encoding.ASCII' 4);  	if (header != VtfHeader)  		throw new ProviderException ("Invalid VTF header. Expected '" + VtfHeader + "'' got '" + header + "'.");  	var v1 = br.ReadUInt32 ();  	var v2 = br.ReadUInt32 ();  	var version = v1 + (v2 / 10m);  	// e.g. 7.3  	var headerSize = br.ReadUInt32 ();  	var width = br.ReadUInt16 ();  	var height = br.ReadUInt16 ();  	var flags = (VtfImageFlag)br.ReadUInt32 ();  	var numFrames = br.ReadUInt16 ();  	var firstFrame = br.ReadUInt16 ();  	br.ReadBytes (4);  	// padding  	var reflectivity = br.ReadCoordinate ();  	br.ReadBytes (4);  	// padding  	var bumpmapScale = br.ReadSingle ();  	var highResImageFormat = (VtfImageFormat)br.ReadUInt32 ();  	var mipmapCount = br.ReadByte ();  	var lowResImageFormat = (VtfImageFormat)br.ReadUInt32 ();  	var lowResWidth = br.ReadByte ();  	var lowResHeight = br.ReadByte ();  	ushort depth = 1;  	uint numResources = 0;  	if (version >= 7.2m) {  		depth = br.ReadUInt16 ();  	}  	if (version >= 7.3m) {  		br.ReadBytes (3);  		numResources = br.ReadUInt32 ();  	}  	var faces = 1;  	if (flags.HasFlag (VtfImageFlag.Envmap)) {  		faces = version < 7.5m && firstFrame != 0xFFFF ? 7 : 6;  	}  	var imageSize = ComputeImageSize (width' height' depth' mipmapCount' highResImageFormat) * faces * numFrames;  	var thumbnailSize = lowResImageFormat == VtfImageFormat.None ? 0 : ComputeImageSize (lowResWidth' lowResHeight' 1' lowResImageFormat);  	var thumbnailPos = headerSize;  	var dataPos = headerSize + thumbnailSize;  	for (var i = 0; i < numResources; i++) {  		var type = br.ReadUInt32 ();  		var data = br.ReadUInt32 ();  		switch (type) {  		case 0x01:  			// Low res image  			thumbnailPos = data;  			break;  		case 0x30:  			// Regular image  			dataPos = data;  			break;  		}  	}  	if (lowResImageFormat != VtfImageFormat.None) {  		br.BaseStream.Position = thumbnailPos;  		var thumbnail = br.ReadBytes ((int)thumbnailSize);  		//var thumbImage = LoadImage(br' lowResWidth' lowResHeight' lowResImageFormat);  		//return thumbImage;  	}  	var mipNum = 0;  	if (maxWidth > 0 || maxHeight > 0)  		mipNum = GetMipToLoad (width' height' maxWidth > 0 ? maxWidth : width' maxHeight > 0 ? maxHeight : height' mipmapCount);  	for (var frame = 0; frame < numFrames; frame++) {  		for (var face = 0; face < faces; face++) {  			for (var slice = 0; slice < depth; slice++) {  				for (var mip = mipNum; mip < mipmapCount; mip++) {  					var wid = MipmapResize (width' mip);  					var hei = MipmapResize (height' mip);  					var offset = GetImageDataLocation (frame' face' slice' mip' highResImageFormat' width' height' numFrames' faces' depth' mipmapCount);  					br.BaseStream.Position = offset + dataPos;  					var img = LoadImage (br' (uint)wid' (uint)hei' highResImageFormat);  					//img.Save(String.Format(@"D:\Github\sledge\_Resources\VTF\_test_fr{0}_fa{1}_sl{2}_m{3}.png"' frame' face' slice' mip));  					return img;  				}  			}  		}  	}  	return null;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,GetImage,The following statement contains a magic number: using (var br = new BinaryReader (stream)) {  	var header = br.ReadFixedLengthString (Encoding.ASCII' 4);  	if (header != VtfHeader)  		throw new ProviderException ("Invalid VTF header. Expected '" + VtfHeader + "'' got '" + header + "'.");  	var v1 = br.ReadUInt32 ();  	var v2 = br.ReadUInt32 ();  	var version = v1 + (v2 / 10m);  	// e.g. 7.3  	var headerSize = br.ReadUInt32 ();  	var width = br.ReadUInt16 ();  	var height = br.ReadUInt16 ();  	var flags = (VtfImageFlag)br.ReadUInt32 ();  	var numFrames = br.ReadUInt16 ();  	var firstFrame = br.ReadUInt16 ();  	br.ReadBytes (4);  	// padding  	var reflectivity = br.ReadCoordinate ();  	br.ReadBytes (4);  	// padding  	var bumpmapScale = br.ReadSingle ();  	var highResImageFormat = (VtfImageFormat)br.ReadUInt32 ();  	var mipmapCount = br.ReadByte ();  	var lowResImageFormat = (VtfImageFormat)br.ReadUInt32 ();  	var lowResWidth = br.ReadByte ();  	var lowResHeight = br.ReadByte ();  	ushort depth = 1;  	uint numResources = 0;  	if (version >= 7.2m) {  		depth = br.ReadUInt16 ();  	}  	if (version >= 7.3m) {  		br.ReadBytes (3);  		numResources = br.ReadUInt32 ();  	}  	var faces = 1;  	if (flags.HasFlag (VtfImageFlag.Envmap)) {  		faces = version < 7.5m && firstFrame != 0xFFFF ? 7 : 6;  	}  	var imageSize = ComputeImageSize (width' height' depth' mipmapCount' highResImageFormat) * faces * numFrames;  	var thumbnailSize = lowResImageFormat == VtfImageFormat.None ? 0 : ComputeImageSize (lowResWidth' lowResHeight' 1' lowResImageFormat);  	var thumbnailPos = headerSize;  	var dataPos = headerSize + thumbnailSize;  	for (var i = 0; i < numResources; i++) {  		var type = br.ReadUInt32 ();  		var data = br.ReadUInt32 ();  		switch (type) {  		case 0x01:  			// Low res image  			thumbnailPos = data;  			break;  		case 0x30:  			// Regular image  			dataPos = data;  			break;  		}  	}  	if (lowResImageFormat != VtfImageFormat.None) {  		br.BaseStream.Position = thumbnailPos;  		var thumbnail = br.ReadBytes ((int)thumbnailSize);  		//var thumbImage = LoadImage(br' lowResWidth' lowResHeight' lowResImageFormat);  		//return thumbImage;  	}  	var mipNum = 0;  	if (maxWidth > 0 || maxHeight > 0)  		mipNum = GetMipToLoad (width' height' maxWidth > 0 ? maxWidth : width' maxHeight > 0 ? maxHeight : height' mipmapCount);  	for (var frame = 0; frame < numFrames; frame++) {  		for (var face = 0; face < faces; face++) {  			for (var slice = 0; slice < depth; slice++) {  				for (var mip = mipNum; mip < mipmapCount; mip++) {  					var wid = MipmapResize (width' mip);  					var hei = MipmapResize (height' mip);  					var offset = GetImageDataLocation (frame' face' slice' mip' highResImageFormat' width' height' numFrames' faces' depth' mipmapCount);  					br.BaseStream.Position = offset + dataPos;  					var img = LoadImage (br' (uint)wid' (uint)hei' highResImageFormat);  					//img.Save(String.Format(@"D:\Github\sledge\_Resources\VTF\_test_fr{0}_fa{1}_sl{2}_m{3}.png"' frame' face' slice' mip));  					return img;  				}  			}  		}  	}  	return null;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,GetImage,The following statement contains a magic number: br.ReadBytes (4);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,GetImage,The following statement contains a magic number: br.ReadBytes (4);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,GetImage,The following statement contains a magic number: if (version >= 7.3m) {  	br.ReadBytes (3);  	numResources = br.ReadUInt32 ();  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,GetImage,The following statement contains a magic number: br.ReadBytes (3);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,GetImage,The following statement contains a magic number: if (flags.HasFlag (VtfImageFlag.Envmap)) {  	faces = version < 7.5m && firstFrame != 0xFFFF ? 7 : 6;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,GetImage,The following statement contains a magic number: if (flags.HasFlag (VtfImageFlag.Envmap)) {  	faces = version < 7.5m && firstFrame != 0xFFFF ? 7 : 6;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,GetImage,The following statement contains a magic number: faces = version < 7.5m && firstFrame != 0xFFFF ? 7 : 6;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,GetImage,The following statement contains a magic number: faces = version < 7.5m && firstFrame != 0xFFFF ? 7 : 6;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,TransformBytes,The following statement contains a magic number: for (int i = 0' j = 0; i < bytes.Length; i += bpp' j += 4) {  	buffer [j + 0] = (b >= 0) ? bytes [i + b] : (byte)0;  	// b  	buffer [j + 1] = (g >= 0) ? bytes [i + g] : (byte)0;  	// g  	buffer [j + 2] = (r >= 0) ? bytes [i + r] : (byte)0;  	// r  	buffer [j + 3] = (a >= 0) ? bytes [i + a] : (byte)255;  	// a  	if (bluescreen && buffer [j + 0] == 255 && buffer [j + 1] == 0 && buffer [j + 2] == 0)  		buffer [j + 3] = 0;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,TransformBytes,The following statement contains a magic number: for (int i = 0' j = 0; i < bytes.Length; i += bpp' j += 4) {  	buffer [j + 0] = (b >= 0) ? bytes [i + b] : (byte)0;  	// b  	buffer [j + 1] = (g >= 0) ? bytes [i + g] : (byte)0;  	// g  	buffer [j + 2] = (r >= 0) ? bytes [i + r] : (byte)0;  	// r  	buffer [j + 3] = (a >= 0) ? bytes [i + a] : (byte)255;  	// a  	if (bluescreen && buffer [j + 0] == 255 && buffer [j + 1] == 0 && buffer [j + 2] == 0)  		buffer [j + 3] = 0;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,TransformBytes,The following statement contains a magic number: for (int i = 0' j = 0; i < bytes.Length; i += bpp' j += 4) {  	buffer [j + 0] = (b >= 0) ? bytes [i + b] : (byte)0;  	// b  	buffer [j + 1] = (g >= 0) ? bytes [i + g] : (byte)0;  	// g  	buffer [j + 2] = (r >= 0) ? bytes [i + r] : (byte)0;  	// r  	buffer [j + 3] = (a >= 0) ? bytes [i + a] : (byte)255;  	// a  	if (bluescreen && buffer [j + 0] == 255 && buffer [j + 1] == 0 && buffer [j + 2] == 0)  		buffer [j + 3] = 0;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,TransformBytes,The following statement contains a magic number: for (int i = 0' j = 0; i < bytes.Length; i += bpp' j += 4) {  	buffer [j + 0] = (b >= 0) ? bytes [i + b] : (byte)0;  	// b  	buffer [j + 1] = (g >= 0) ? bytes [i + g] : (byte)0;  	// g  	buffer [j + 2] = (r >= 0) ? bytes [i + r] : (byte)0;  	// r  	buffer [j + 3] = (a >= 0) ? bytes [i + a] : (byte)255;  	// a  	if (bluescreen && buffer [j + 0] == 255 && buffer [j + 1] == 0 && buffer [j + 2] == 0)  		buffer [j + 3] = 0;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,TransformBytes,The following statement contains a magic number: for (int i = 0' j = 0; i < bytes.Length; i += bpp' j += 4) {  	buffer [j + 0] = (b >= 0) ? bytes [i + b] : (byte)0;  	// b  	buffer [j + 1] = (g >= 0) ? bytes [i + g] : (byte)0;  	// g  	buffer [j + 2] = (r >= 0) ? bytes [i + r] : (byte)0;  	// r  	buffer [j + 3] = (a >= 0) ? bytes [i + a] : (byte)255;  	// a  	if (bluescreen && buffer [j + 0] == 255 && buffer [j + 1] == 0 && buffer [j + 2] == 0)  		buffer [j + 3] = 0;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,TransformBytes,The following statement contains a magic number: for (int i = 0' j = 0; i < bytes.Length; i += bpp' j += 4) {  	buffer [j + 0] = (b >= 0) ? bytes [i + b] : (byte)0;  	// b  	buffer [j + 1] = (g >= 0) ? bytes [i + g] : (byte)0;  	// g  	buffer [j + 2] = (r >= 0) ? bytes [i + r] : (byte)0;  	// r  	buffer [j + 3] = (a >= 0) ? bytes [i + a] : (byte)255;  	// a  	if (bluescreen && buffer [j + 0] == 255 && buffer [j + 1] == 0 && buffer [j + 2] == 0)  		buffer [j + 3] = 0;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,TransformBytes,The following statement contains a magic number: for (int i = 0' j = 0; i < bytes.Length; i += bpp' j += 4) {  	buffer [j + 0] = (b >= 0) ? bytes [i + b] : (byte)0;  	// b  	buffer [j + 1] = (g >= 0) ? bytes [i + g] : (byte)0;  	// g  	buffer [j + 2] = (r >= 0) ? bytes [i + r] : (byte)0;  	// r  	buffer [j + 3] = (a >= 0) ? bytes [i + a] : (byte)255;  	// a  	if (bluescreen && buffer [j + 0] == 255 && buffer [j + 1] == 0 && buffer [j + 2] == 0)  		buffer [j + 3] = 0;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,TransformBytes,The following statement contains a magic number: j += 4
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,TransformBytes,The following statement contains a magic number: buffer [j + 2] = (r >= 0) ? bytes [i + r] : (byte)0;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,TransformBytes,The following statement contains a magic number: buffer [j + 3] = (a >= 0) ? bytes [i + a] : (byte)255;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,TransformBytes,The following statement contains a magic number: buffer [j + 3] = (a >= 0) ? bytes [i + a] : (byte)255;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,TransformBytes,The following statement contains a magic number: if (bluescreen && buffer [j + 0] == 255 && buffer [j + 1] == 0 && buffer [j + 2] == 0)  	buffer [j + 3] = 0;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,TransformBytes,The following statement contains a magic number: if (bluescreen && buffer [j + 0] == 255 && buffer [j + 1] == 0 && buffer [j + 2] == 0)  	buffer [j + 3] = 0;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,TransformBytes,The following statement contains a magic number: if (bluescreen && buffer [j + 0] == 255 && buffer [j + 1] == 0 && buffer [j + 2] == 0)  	buffer [j + 3] = 0;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,TransformBytes,The following statement contains a magic number: buffer [j + 3] = 0;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,TransformShorts,The following statement contains a magic number: a *= 2;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,TransformShorts,The following statement contains a magic number: r *= 2;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,TransformShorts,The following statement contains a magic number: g *= 2;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,TransformShorts,The following statement contains a magic number: b *= 2;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,TransformShorts,The following statement contains a magic number: for (int i = 0' j = 0; i < bytes.Length; i += bpp' j += 4) {  	buffer [j + 0] = (b >= 0) ? (byte)((bytes [i + b] | bytes [i + b + 1] << 8) / 256) : (byte)0;  	// b  	buffer [j + 1] = (g >= 0) ? (byte)((bytes [i + g] | bytes [i + g + 1] << 8) / 256) : (byte)0;  	// g  	buffer [j + 2] = (r >= 0) ? (byte)((bytes [i + r] | bytes [i + r + 1] << 8) / 256) : (byte)0;  	// r  	buffer [j + 3] = (a >= 0) ? (byte)((bytes [i + a] | bytes [i + a + 1] << 8) / 256) : (byte)255;  	// a  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,TransformShorts,The following statement contains a magic number: for (int i = 0' j = 0; i < bytes.Length; i += bpp' j += 4) {  	buffer [j + 0] = (b >= 0) ? (byte)((bytes [i + b] | bytes [i + b + 1] << 8) / 256) : (byte)0;  	// b  	buffer [j + 1] = (g >= 0) ? (byte)((bytes [i + g] | bytes [i + g + 1] << 8) / 256) : (byte)0;  	// g  	buffer [j + 2] = (r >= 0) ? (byte)((bytes [i + r] | bytes [i + r + 1] << 8) / 256) : (byte)0;  	// r  	buffer [j + 3] = (a >= 0) ? (byte)((bytes [i + a] | bytes [i + a + 1] << 8) / 256) : (byte)255;  	// a  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,TransformShorts,The following statement contains a magic number: for (int i = 0' j = 0; i < bytes.Length; i += bpp' j += 4) {  	buffer [j + 0] = (b >= 0) ? (byte)((bytes [i + b] | bytes [i + b + 1] << 8) / 256) : (byte)0;  	// b  	buffer [j + 1] = (g >= 0) ? (byte)((bytes [i + g] | bytes [i + g + 1] << 8) / 256) : (byte)0;  	// g  	buffer [j + 2] = (r >= 0) ? (byte)((bytes [i + r] | bytes [i + r + 1] << 8) / 256) : (byte)0;  	// r  	buffer [j + 3] = (a >= 0) ? (byte)((bytes [i + a] | bytes [i + a + 1] << 8) / 256) : (byte)255;  	// a  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,TransformShorts,The following statement contains a magic number: for (int i = 0' j = 0; i < bytes.Length; i += bpp' j += 4) {  	buffer [j + 0] = (b >= 0) ? (byte)((bytes [i + b] | bytes [i + b + 1] << 8) / 256) : (byte)0;  	// b  	buffer [j + 1] = (g >= 0) ? (byte)((bytes [i + g] | bytes [i + g + 1] << 8) / 256) : (byte)0;  	// g  	buffer [j + 2] = (r >= 0) ? (byte)((bytes [i + r] | bytes [i + r + 1] << 8) / 256) : (byte)0;  	// r  	buffer [j + 3] = (a >= 0) ? (byte)((bytes [i + a] | bytes [i + a + 1] << 8) / 256) : (byte)255;  	// a  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,TransformShorts,The following statement contains a magic number: for (int i = 0' j = 0; i < bytes.Length; i += bpp' j += 4) {  	buffer [j + 0] = (b >= 0) ? (byte)((bytes [i + b] | bytes [i + b + 1] << 8) / 256) : (byte)0;  	// b  	buffer [j + 1] = (g >= 0) ? (byte)((bytes [i + g] | bytes [i + g + 1] << 8) / 256) : (byte)0;  	// g  	buffer [j + 2] = (r >= 0) ? (byte)((bytes [i + r] | bytes [i + r + 1] << 8) / 256) : (byte)0;  	// r  	buffer [j + 3] = (a >= 0) ? (byte)((bytes [i + a] | bytes [i + a + 1] << 8) / 256) : (byte)255;  	// a  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,TransformShorts,The following statement contains a magic number: for (int i = 0' j = 0; i < bytes.Length; i += bpp' j += 4) {  	buffer [j + 0] = (b >= 0) ? (byte)((bytes [i + b] | bytes [i + b + 1] << 8) / 256) : (byte)0;  	// b  	buffer [j + 1] = (g >= 0) ? (byte)((bytes [i + g] | bytes [i + g + 1] << 8) / 256) : (byte)0;  	// g  	buffer [j + 2] = (r >= 0) ? (byte)((bytes [i + r] | bytes [i + r + 1] << 8) / 256) : (byte)0;  	// r  	buffer [j + 3] = (a >= 0) ? (byte)((bytes [i + a] | bytes [i + a + 1] << 8) / 256) : (byte)255;  	// a  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,TransformShorts,The following statement contains a magic number: for (int i = 0' j = 0; i < bytes.Length; i += bpp' j += 4) {  	buffer [j + 0] = (b >= 0) ? (byte)((bytes [i + b] | bytes [i + b + 1] << 8) / 256) : (byte)0;  	// b  	buffer [j + 1] = (g >= 0) ? (byte)((bytes [i + g] | bytes [i + g + 1] << 8) / 256) : (byte)0;  	// g  	buffer [j + 2] = (r >= 0) ? (byte)((bytes [i + r] | bytes [i + r + 1] << 8) / 256) : (byte)0;  	// r  	buffer [j + 3] = (a >= 0) ? (byte)((bytes [i + a] | bytes [i + a + 1] << 8) / 256) : (byte)255;  	// a  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,TransformShorts,The following statement contains a magic number: for (int i = 0' j = 0; i < bytes.Length; i += bpp' j += 4) {  	buffer [j + 0] = (b >= 0) ? (byte)((bytes [i + b] | bytes [i + b + 1] << 8) / 256) : (byte)0;  	// b  	buffer [j + 1] = (g >= 0) ? (byte)((bytes [i + g] | bytes [i + g + 1] << 8) / 256) : (byte)0;  	// g  	buffer [j + 2] = (r >= 0) ? (byte)((bytes [i + r] | bytes [i + r + 1] << 8) / 256) : (byte)0;  	// r  	buffer [j + 3] = (a >= 0) ? (byte)((bytes [i + a] | bytes [i + a + 1] << 8) / 256) : (byte)255;  	// a  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,TransformShorts,The following statement contains a magic number: for (int i = 0' j = 0; i < bytes.Length; i += bpp' j += 4) {  	buffer [j + 0] = (b >= 0) ? (byte)((bytes [i + b] | bytes [i + b + 1] << 8) / 256) : (byte)0;  	// b  	buffer [j + 1] = (g >= 0) ? (byte)((bytes [i + g] | bytes [i + g + 1] << 8) / 256) : (byte)0;  	// g  	buffer [j + 2] = (r >= 0) ? (byte)((bytes [i + r] | bytes [i + r + 1] << 8) / 256) : (byte)0;  	// r  	buffer [j + 3] = (a >= 0) ? (byte)((bytes [i + a] | bytes [i + a + 1] << 8) / 256) : (byte)255;  	// a  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,TransformShorts,The following statement contains a magic number: for (int i = 0' j = 0; i < bytes.Length; i += bpp' j += 4) {  	buffer [j + 0] = (b >= 0) ? (byte)((bytes [i + b] | bytes [i + b + 1] << 8) / 256) : (byte)0;  	// b  	buffer [j + 1] = (g >= 0) ? (byte)((bytes [i + g] | bytes [i + g + 1] << 8) / 256) : (byte)0;  	// g  	buffer [j + 2] = (r >= 0) ? (byte)((bytes [i + r] | bytes [i + r + 1] << 8) / 256) : (byte)0;  	// r  	buffer [j + 3] = (a >= 0) ? (byte)((bytes [i + a] | bytes [i + a + 1] << 8) / 256) : (byte)255;  	// a  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,TransformShorts,The following statement contains a magic number: for (int i = 0' j = 0; i < bytes.Length; i += bpp' j += 4) {  	buffer [j + 0] = (b >= 0) ? (byte)((bytes [i + b] | bytes [i + b + 1] << 8) / 256) : (byte)0;  	// b  	buffer [j + 1] = (g >= 0) ? (byte)((bytes [i + g] | bytes [i + g + 1] << 8) / 256) : (byte)0;  	// g  	buffer [j + 2] = (r >= 0) ? (byte)((bytes [i + r] | bytes [i + r + 1] << 8) / 256) : (byte)0;  	// r  	buffer [j + 3] = (a >= 0) ? (byte)((bytes [i + a] | bytes [i + a + 1] << 8) / 256) : (byte)255;  	// a  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,TransformShorts,The following statement contains a magic number: for (int i = 0' j = 0; i < bytes.Length; i += bpp' j += 4) {  	buffer [j + 0] = (b >= 0) ? (byte)((bytes [i + b] | bytes [i + b + 1] << 8) / 256) : (byte)0;  	// b  	buffer [j + 1] = (g >= 0) ? (byte)((bytes [i + g] | bytes [i + g + 1] << 8) / 256) : (byte)0;  	// g  	buffer [j + 2] = (r >= 0) ? (byte)((bytes [i + r] | bytes [i + r + 1] << 8) / 256) : (byte)0;  	// r  	buffer [j + 3] = (a >= 0) ? (byte)((bytes [i + a] | bytes [i + a + 1] << 8) / 256) : (byte)255;  	// a  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,TransformShorts,The following statement contains a magic number: j += 4
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,TransformShorts,The following statement contains a magic number: buffer [j + 0] = (b >= 0) ? (byte)((bytes [i + b] | bytes [i + b + 1] << 8) / 256) : (byte)0;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,TransformShorts,The following statement contains a magic number: buffer [j + 0] = (b >= 0) ? (byte)((bytes [i + b] | bytes [i + b + 1] << 8) / 256) : (byte)0;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,TransformShorts,The following statement contains a magic number: buffer [j + 1] = (g >= 0) ? (byte)((bytes [i + g] | bytes [i + g + 1] << 8) / 256) : (byte)0;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,TransformShorts,The following statement contains a magic number: buffer [j + 1] = (g >= 0) ? (byte)((bytes [i + g] | bytes [i + g + 1] << 8) / 256) : (byte)0;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,TransformShorts,The following statement contains a magic number: buffer [j + 2] = (r >= 0) ? (byte)((bytes [i + r] | bytes [i + r + 1] << 8) / 256) : (byte)0;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,TransformShorts,The following statement contains a magic number: buffer [j + 2] = (r >= 0) ? (byte)((bytes [i + r] | bytes [i + r + 1] << 8) / 256) : (byte)0;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,TransformShorts,The following statement contains a magic number: buffer [j + 2] = (r >= 0) ? (byte)((bytes [i + r] | bytes [i + r + 1] << 8) / 256) : (byte)0;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,TransformShorts,The following statement contains a magic number: buffer [j + 3] = (a >= 0) ? (byte)((bytes [i + a] | bytes [i + a + 1] << 8) / 256) : (byte)255;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,TransformShorts,The following statement contains a magic number: buffer [j + 3] = (a >= 0) ? (byte)((bytes [i + a] | bytes [i + a + 1] << 8) / 256) : (byte)255;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,TransformShorts,The following statement contains a magic number: buffer [j + 3] = (a >= 0) ? (byte)((bytes [i + a] | bytes [i + a + 1] << 8) / 256) : (byte)255;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,TransformShorts,The following statement contains a magic number: buffer [j + 3] = (a >= 0) ? (byte)((bytes [i + a] | bytes [i + a + 1] << 8) / 256) : (byte)255;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,TransformRgba16161616F,The following statement contains a magic number: for (int i = 0' j = 0; i < bytes.Length; i += 8' j += 4) {  	var hb = Half.FromBytes (bytes' i + b).ToSingle ();  	var hg = Half.FromBytes (bytes' i + g).ToSingle ();  	var hr = Half.FromBytes (bytes' i + r).ToSingle ();  	var lum = hr * 0.299f + hg * 0.587f + hb * 0.114f;  	log += Math.Log (0.0000000001d + lum);  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,TransformRgba16161616F,The following statement contains a magic number: for (int i = 0' j = 0; i < bytes.Length; i += 8' j += 4) {  	var hb = Half.FromBytes (bytes' i + b).ToSingle ();  	var hg = Half.FromBytes (bytes' i + g).ToSingle ();  	var hr = Half.FromBytes (bytes' i + r).ToSingle ();  	var lum = hr * 0.299f + hg * 0.587f + hb * 0.114f;  	log += Math.Log (0.0000000001d + lum);  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,TransformRgba16161616F,The following statement contains a magic number: i += 8
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,TransformRgba16161616F,The following statement contains a magic number: j += 4
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,TransformRgba16161616F,The following statement contains a magic number: for (int i = 0' j = 0; i < bytes.Length; i += 8' j += 4) {  	var hb = Half.FromBytes (bytes' i + b).ToSingle ();  	var hg = Half.FromBytes (bytes' i + g).ToSingle ();  	var hr = Half.FromBytes (bytes' i + r).ToSingle ();  	var ha = Half.FromBytes (bytes' i + a).ToSingle ();  	var y = hr * 0.299f + hg * 0.587f + hb * 0.114f;  	var u = (hb - y) * 0.565f;  	var v = (hr - y) * 0.713f;  	var mul = 4 * y / log;  	mul = mul / (1 + mul);  	mul /= y;  	hr = (float)Math.Pow ((y + 1.403f * v) * mul' 2.25f);  	hg = (float)Math.Pow ((y - 0.344f * u - 0.714f * v) * mul' 2.25f);  	hb = (float)Math.Pow ((y + 1.770f * u) * mul' 2.25f);  	if (hr < 0)  		hr = 0;  	if (hr > 1)  		hr = 1;  	if (hg < 0)  		hg = 0;  	if (hg > 1)  		hg = 1;  	if (hb < 0)  		hb = 0;  	if (hb > 1)  		hb = 1;  	buffer [j + 0] = (byte)(hb * 255);  	// b  	buffer [j + 1] = (byte)(hg * 255);  	// g  	buffer [j + 2] = (byte)(hr * 255);  	// r  	buffer [j + 3] = (byte)(ha * 255);  	// a  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,TransformRgba16161616F,The following statement contains a magic number: for (int i = 0' j = 0; i < bytes.Length; i += 8' j += 4) {  	var hb = Half.FromBytes (bytes' i + b).ToSingle ();  	var hg = Half.FromBytes (bytes' i + g).ToSingle ();  	var hr = Half.FromBytes (bytes' i + r).ToSingle ();  	var ha = Half.FromBytes (bytes' i + a).ToSingle ();  	var y = hr * 0.299f + hg * 0.587f + hb * 0.114f;  	var u = (hb - y) * 0.565f;  	var v = (hr - y) * 0.713f;  	var mul = 4 * y / log;  	mul = mul / (1 + mul);  	mul /= y;  	hr = (float)Math.Pow ((y + 1.403f * v) * mul' 2.25f);  	hg = (float)Math.Pow ((y - 0.344f * u - 0.714f * v) * mul' 2.25f);  	hb = (float)Math.Pow ((y + 1.770f * u) * mul' 2.25f);  	if (hr < 0)  		hr = 0;  	if (hr > 1)  		hr = 1;  	if (hg < 0)  		hg = 0;  	if (hg > 1)  		hg = 1;  	if (hb < 0)  		hb = 0;  	if (hb > 1)  		hb = 1;  	buffer [j + 0] = (byte)(hb * 255);  	// b  	buffer [j + 1] = (byte)(hg * 255);  	// g  	buffer [j + 2] = (byte)(hr * 255);  	// r  	buffer [j + 3] = (byte)(ha * 255);  	// a  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,TransformRgba16161616F,The following statement contains a magic number: for (int i = 0' j = 0; i < bytes.Length; i += 8' j += 4) {  	var hb = Half.FromBytes (bytes' i + b).ToSingle ();  	var hg = Half.FromBytes (bytes' i + g).ToSingle ();  	var hr = Half.FromBytes (bytes' i + r).ToSingle ();  	var ha = Half.FromBytes (bytes' i + a).ToSingle ();  	var y = hr * 0.299f + hg * 0.587f + hb * 0.114f;  	var u = (hb - y) * 0.565f;  	var v = (hr - y) * 0.713f;  	var mul = 4 * y / log;  	mul = mul / (1 + mul);  	mul /= y;  	hr = (float)Math.Pow ((y + 1.403f * v) * mul' 2.25f);  	hg = (float)Math.Pow ((y - 0.344f * u - 0.714f * v) * mul' 2.25f);  	hb = (float)Math.Pow ((y + 1.770f * u) * mul' 2.25f);  	if (hr < 0)  		hr = 0;  	if (hr > 1)  		hr = 1;  	if (hg < 0)  		hg = 0;  	if (hg > 1)  		hg = 1;  	if (hb < 0)  		hb = 0;  	if (hb > 1)  		hb = 1;  	buffer [j + 0] = (byte)(hb * 255);  	// b  	buffer [j + 1] = (byte)(hg * 255);  	// g  	buffer [j + 2] = (byte)(hr * 255);  	// r  	buffer [j + 3] = (byte)(ha * 255);  	// a  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,TransformRgba16161616F,The following statement contains a magic number: for (int i = 0' j = 0; i < bytes.Length; i += 8' j += 4) {  	var hb = Half.FromBytes (bytes' i + b).ToSingle ();  	var hg = Half.FromBytes (bytes' i + g).ToSingle ();  	var hr = Half.FromBytes (bytes' i + r).ToSingle ();  	var ha = Half.FromBytes (bytes' i + a).ToSingle ();  	var y = hr * 0.299f + hg * 0.587f + hb * 0.114f;  	var u = (hb - y) * 0.565f;  	var v = (hr - y) * 0.713f;  	var mul = 4 * y / log;  	mul = mul / (1 + mul);  	mul /= y;  	hr = (float)Math.Pow ((y + 1.403f * v) * mul' 2.25f);  	hg = (float)Math.Pow ((y - 0.344f * u - 0.714f * v) * mul' 2.25f);  	hb = (float)Math.Pow ((y + 1.770f * u) * mul' 2.25f);  	if (hr < 0)  		hr = 0;  	if (hr > 1)  		hr = 1;  	if (hg < 0)  		hg = 0;  	if (hg > 1)  		hg = 1;  	if (hb < 0)  		hb = 0;  	if (hb > 1)  		hb = 1;  	buffer [j + 0] = (byte)(hb * 255);  	// b  	buffer [j + 1] = (byte)(hg * 255);  	// g  	buffer [j + 2] = (byte)(hr * 255);  	// r  	buffer [j + 3] = (byte)(ha * 255);  	// a  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,TransformRgba16161616F,The following statement contains a magic number: for (int i = 0' j = 0; i < bytes.Length; i += 8' j += 4) {  	var hb = Half.FromBytes (bytes' i + b).ToSingle ();  	var hg = Half.FromBytes (bytes' i + g).ToSingle ();  	var hr = Half.FromBytes (bytes' i + r).ToSingle ();  	var ha = Half.FromBytes (bytes' i + a).ToSingle ();  	var y = hr * 0.299f + hg * 0.587f + hb * 0.114f;  	var u = (hb - y) * 0.565f;  	var v = (hr - y) * 0.713f;  	var mul = 4 * y / log;  	mul = mul / (1 + mul);  	mul /= y;  	hr = (float)Math.Pow ((y + 1.403f * v) * mul' 2.25f);  	hg = (float)Math.Pow ((y - 0.344f * u - 0.714f * v) * mul' 2.25f);  	hb = (float)Math.Pow ((y + 1.770f * u) * mul' 2.25f);  	if (hr < 0)  		hr = 0;  	if (hr > 1)  		hr = 1;  	if (hg < 0)  		hg = 0;  	if (hg > 1)  		hg = 1;  	if (hb < 0)  		hb = 0;  	if (hb > 1)  		hb = 1;  	buffer [j + 0] = (byte)(hb * 255);  	// b  	buffer [j + 1] = (byte)(hg * 255);  	// g  	buffer [j + 2] = (byte)(hr * 255);  	// r  	buffer [j + 3] = (byte)(ha * 255);  	// a  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,TransformRgba16161616F,The following statement contains a magic number: for (int i = 0' j = 0; i < bytes.Length; i += 8' j += 4) {  	var hb = Half.FromBytes (bytes' i + b).ToSingle ();  	var hg = Half.FromBytes (bytes' i + g).ToSingle ();  	var hr = Half.FromBytes (bytes' i + r).ToSingle ();  	var ha = Half.FromBytes (bytes' i + a).ToSingle ();  	var y = hr * 0.299f + hg * 0.587f + hb * 0.114f;  	var u = (hb - y) * 0.565f;  	var v = (hr - y) * 0.713f;  	var mul = 4 * y / log;  	mul = mul / (1 + mul);  	mul /= y;  	hr = (float)Math.Pow ((y + 1.403f * v) * mul' 2.25f);  	hg = (float)Math.Pow ((y - 0.344f * u - 0.714f * v) * mul' 2.25f);  	hb = (float)Math.Pow ((y + 1.770f * u) * mul' 2.25f);  	if (hr < 0)  		hr = 0;  	if (hr > 1)  		hr = 1;  	if (hg < 0)  		hg = 0;  	if (hg > 1)  		hg = 1;  	if (hb < 0)  		hb = 0;  	if (hb > 1)  		hb = 1;  	buffer [j + 0] = (byte)(hb * 255);  	// b  	buffer [j + 1] = (byte)(hg * 255);  	// g  	buffer [j + 2] = (byte)(hr * 255);  	// r  	buffer [j + 3] = (byte)(ha * 255);  	// a  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,TransformRgba16161616F,The following statement contains a magic number: for (int i = 0' j = 0; i < bytes.Length; i += 8' j += 4) {  	var hb = Half.FromBytes (bytes' i + b).ToSingle ();  	var hg = Half.FromBytes (bytes' i + g).ToSingle ();  	var hr = Half.FromBytes (bytes' i + r).ToSingle ();  	var ha = Half.FromBytes (bytes' i + a).ToSingle ();  	var y = hr * 0.299f + hg * 0.587f + hb * 0.114f;  	var u = (hb - y) * 0.565f;  	var v = (hr - y) * 0.713f;  	var mul = 4 * y / log;  	mul = mul / (1 + mul);  	mul /= y;  	hr = (float)Math.Pow ((y + 1.403f * v) * mul' 2.25f);  	hg = (float)Math.Pow ((y - 0.344f * u - 0.714f * v) * mul' 2.25f);  	hb = (float)Math.Pow ((y + 1.770f * u) * mul' 2.25f);  	if (hr < 0)  		hr = 0;  	if (hr > 1)  		hr = 1;  	if (hg < 0)  		hg = 0;  	if (hg > 1)  		hg = 1;  	if (hb < 0)  		hb = 0;  	if (hb > 1)  		hb = 1;  	buffer [j + 0] = (byte)(hb * 255);  	// b  	buffer [j + 1] = (byte)(hg * 255);  	// g  	buffer [j + 2] = (byte)(hr * 255);  	// r  	buffer [j + 3] = (byte)(ha * 255);  	// a  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,TransformRgba16161616F,The following statement contains a magic number: for (int i = 0' j = 0; i < bytes.Length; i += 8' j += 4) {  	var hb = Half.FromBytes (bytes' i + b).ToSingle ();  	var hg = Half.FromBytes (bytes' i + g).ToSingle ();  	var hr = Half.FromBytes (bytes' i + r).ToSingle ();  	var ha = Half.FromBytes (bytes' i + a).ToSingle ();  	var y = hr * 0.299f + hg * 0.587f + hb * 0.114f;  	var u = (hb - y) * 0.565f;  	var v = (hr - y) * 0.713f;  	var mul = 4 * y / log;  	mul = mul / (1 + mul);  	mul /= y;  	hr = (float)Math.Pow ((y + 1.403f * v) * mul' 2.25f);  	hg = (float)Math.Pow ((y - 0.344f * u - 0.714f * v) * mul' 2.25f);  	hb = (float)Math.Pow ((y + 1.770f * u) * mul' 2.25f);  	if (hr < 0)  		hr = 0;  	if (hr > 1)  		hr = 1;  	if (hg < 0)  		hg = 0;  	if (hg > 1)  		hg = 1;  	if (hb < 0)  		hb = 0;  	if (hb > 1)  		hb = 1;  	buffer [j + 0] = (byte)(hb * 255);  	// b  	buffer [j + 1] = (byte)(hg * 255);  	// g  	buffer [j + 2] = (byte)(hr * 255);  	// r  	buffer [j + 3] = (byte)(ha * 255);  	// a  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,TransformRgba16161616F,The following statement contains a magic number: for (int i = 0' j = 0; i < bytes.Length; i += 8' j += 4) {  	var hb = Half.FromBytes (bytes' i + b).ToSingle ();  	var hg = Half.FromBytes (bytes' i + g).ToSingle ();  	var hr = Half.FromBytes (bytes' i + r).ToSingle ();  	var ha = Half.FromBytes (bytes' i + a).ToSingle ();  	var y = hr * 0.299f + hg * 0.587f + hb * 0.114f;  	var u = (hb - y) * 0.565f;  	var v = (hr - y) * 0.713f;  	var mul = 4 * y / log;  	mul = mul / (1 + mul);  	mul /= y;  	hr = (float)Math.Pow ((y + 1.403f * v) * mul' 2.25f);  	hg = (float)Math.Pow ((y - 0.344f * u - 0.714f * v) * mul' 2.25f);  	hb = (float)Math.Pow ((y + 1.770f * u) * mul' 2.25f);  	if (hr < 0)  		hr = 0;  	if (hr > 1)  		hr = 1;  	if (hg < 0)  		hg = 0;  	if (hg > 1)  		hg = 1;  	if (hb < 0)  		hb = 0;  	if (hb > 1)  		hb = 1;  	buffer [j + 0] = (byte)(hb * 255);  	// b  	buffer [j + 1] = (byte)(hg * 255);  	// g  	buffer [j + 2] = (byte)(hr * 255);  	// r  	buffer [j + 3] = (byte)(ha * 255);  	// a  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,TransformRgba16161616F,The following statement contains a magic number: i += 8
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,TransformRgba16161616F,The following statement contains a magic number: j += 4
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,TransformRgba16161616F,The following statement contains a magic number: buffer [j + 0] = (byte)(hb * 255);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,TransformRgba16161616F,The following statement contains a magic number: buffer [j + 1] = (byte)(hg * 255);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,TransformRgba16161616F,The following statement contains a magic number: buffer [j + 2] = (byte)(hr * 255);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,TransformRgba16161616F,The following statement contains a magic number: buffer [j + 2] = (byte)(hr * 255);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,TransformRgba16161616F,The following statement contains a magic number: buffer [j + 3] = (byte)(ha * 255);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,TransformRgba16161616F,The following statement contains a magic number: buffer [j + 3] = (byte)(ha * 255);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,LoadImage,The following statement contains a magic number: switch (format) {  case VtfImageFormat.Rgba8888:  	TransformBytes (buffer' br' width' height' 4' 3' 0' 1' 2' false);  	break;  case VtfImageFormat.Abgr8888:  	TransformBytes (buffer' br' width' height' 4' 0' 3' 2' 1' false);  	break;  case VtfImageFormat.Rgb888:  	TransformBytes (buffer' br' width' height' 3' -1' 0' 1' 2' false);  	break;  case VtfImageFormat.Bgr888:  	TransformBytes (buffer' br' width' height' 3' -1' 2' 1' 0' false);  	break;  case VtfImageFormat.Rgb565:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.I8:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Ia88:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.P8:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.A8:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgb888Bluescreen:  	TransformBytes (buffer' br' width' height' 3' -1' 0' 1' 2' true);  	break;  case VtfImageFormat.Bgr888Bluescreen:  	TransformBytes (buffer' br' width' height' 3' -1' 2' 1' 0' true);  	break;  case VtfImageFormat.Argb8888:  	TransformBytes (buffer' br' width' height' 4' 0' 1' 2' 3' false);  	break;  case VtfImageFormat.Bgra8888:  	br.Read (buffer' 0' buffer.Length);  	break;  case VtfImageFormat.Dxt1:  case VtfImageFormat.Dxt1Onebitalpha:  	DecompressDxt1 (buffer' br' width' height);  	break;  case VtfImageFormat.Dxt3:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Dxt5:  	DecompressDxt5 (buffer' br' width' height);  	break;  case VtfImageFormat.Bgrx8888:  	TransformBytes (buffer' br' width' height' 4' -1' 2' 1' 0' false);  	break;  case VtfImageFormat.Bgr565:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Bgrx5551:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Bgra4444:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Bgra5551:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Uv88:  	TransformBytes (buffer' br' width' height' 2' -1' 0' 1' -1' false);  	break;  case VtfImageFormat.Uvwq8888:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgba16161616F:  	TransformRgba16161616F (buffer' br' width' height);  	break;  case VtfImageFormat.Rgba16161616:  	TransformShorts (buffer' br' width' height' 8' 3' 0' 1' 2);  	break;  case VtfImageFormat.Uvlx8888:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.R32F:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgb323232F:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgba32323232F:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvDst16:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvDst24:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvIntz:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvRawz:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.AtiDst16:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.AtiDst24:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvNull:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Ati2N:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Ati1N:  	throw new NotImplementedException ();  	break;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,LoadImage,The following statement contains a magic number: switch (format) {  case VtfImageFormat.Rgba8888:  	TransformBytes (buffer' br' width' height' 4' 3' 0' 1' 2' false);  	break;  case VtfImageFormat.Abgr8888:  	TransformBytes (buffer' br' width' height' 4' 0' 3' 2' 1' false);  	break;  case VtfImageFormat.Rgb888:  	TransformBytes (buffer' br' width' height' 3' -1' 0' 1' 2' false);  	break;  case VtfImageFormat.Bgr888:  	TransformBytes (buffer' br' width' height' 3' -1' 2' 1' 0' false);  	break;  case VtfImageFormat.Rgb565:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.I8:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Ia88:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.P8:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.A8:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgb888Bluescreen:  	TransformBytes (buffer' br' width' height' 3' -1' 0' 1' 2' true);  	break;  case VtfImageFormat.Bgr888Bluescreen:  	TransformBytes (buffer' br' width' height' 3' -1' 2' 1' 0' true);  	break;  case VtfImageFormat.Argb8888:  	TransformBytes (buffer' br' width' height' 4' 0' 1' 2' 3' false);  	break;  case VtfImageFormat.Bgra8888:  	br.Read (buffer' 0' buffer.Length);  	break;  case VtfImageFormat.Dxt1:  case VtfImageFormat.Dxt1Onebitalpha:  	DecompressDxt1 (buffer' br' width' height);  	break;  case VtfImageFormat.Dxt3:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Dxt5:  	DecompressDxt5 (buffer' br' width' height);  	break;  case VtfImageFormat.Bgrx8888:  	TransformBytes (buffer' br' width' height' 4' -1' 2' 1' 0' false);  	break;  case VtfImageFormat.Bgr565:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Bgrx5551:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Bgra4444:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Bgra5551:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Uv88:  	TransformBytes (buffer' br' width' height' 2' -1' 0' 1' -1' false);  	break;  case VtfImageFormat.Uvwq8888:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgba16161616F:  	TransformRgba16161616F (buffer' br' width' height);  	break;  case VtfImageFormat.Rgba16161616:  	TransformShorts (buffer' br' width' height' 8' 3' 0' 1' 2);  	break;  case VtfImageFormat.Uvlx8888:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.R32F:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgb323232F:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgba32323232F:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvDst16:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvDst24:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvIntz:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvRawz:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.AtiDst16:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.AtiDst24:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvNull:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Ati2N:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Ati1N:  	throw new NotImplementedException ();  	break;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,LoadImage,The following statement contains a magic number: switch (format) {  case VtfImageFormat.Rgba8888:  	TransformBytes (buffer' br' width' height' 4' 3' 0' 1' 2' false);  	break;  case VtfImageFormat.Abgr8888:  	TransformBytes (buffer' br' width' height' 4' 0' 3' 2' 1' false);  	break;  case VtfImageFormat.Rgb888:  	TransformBytes (buffer' br' width' height' 3' -1' 0' 1' 2' false);  	break;  case VtfImageFormat.Bgr888:  	TransformBytes (buffer' br' width' height' 3' -1' 2' 1' 0' false);  	break;  case VtfImageFormat.Rgb565:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.I8:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Ia88:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.P8:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.A8:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgb888Bluescreen:  	TransformBytes (buffer' br' width' height' 3' -1' 0' 1' 2' true);  	break;  case VtfImageFormat.Bgr888Bluescreen:  	TransformBytes (buffer' br' width' height' 3' -1' 2' 1' 0' true);  	break;  case VtfImageFormat.Argb8888:  	TransformBytes (buffer' br' width' height' 4' 0' 1' 2' 3' false);  	break;  case VtfImageFormat.Bgra8888:  	br.Read (buffer' 0' buffer.Length);  	break;  case VtfImageFormat.Dxt1:  case VtfImageFormat.Dxt1Onebitalpha:  	DecompressDxt1 (buffer' br' width' height);  	break;  case VtfImageFormat.Dxt3:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Dxt5:  	DecompressDxt5 (buffer' br' width' height);  	break;  case VtfImageFormat.Bgrx8888:  	TransformBytes (buffer' br' width' height' 4' -1' 2' 1' 0' false);  	break;  case VtfImageFormat.Bgr565:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Bgrx5551:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Bgra4444:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Bgra5551:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Uv88:  	TransformBytes (buffer' br' width' height' 2' -1' 0' 1' -1' false);  	break;  case VtfImageFormat.Uvwq8888:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgba16161616F:  	TransformRgba16161616F (buffer' br' width' height);  	break;  case VtfImageFormat.Rgba16161616:  	TransformShorts (buffer' br' width' height' 8' 3' 0' 1' 2);  	break;  case VtfImageFormat.Uvlx8888:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.R32F:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgb323232F:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgba32323232F:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvDst16:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvDst24:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvIntz:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvRawz:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.AtiDst16:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.AtiDst24:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvNull:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Ati2N:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Ati1N:  	throw new NotImplementedException ();  	break;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,LoadImage,The following statement contains a magic number: switch (format) {  case VtfImageFormat.Rgba8888:  	TransformBytes (buffer' br' width' height' 4' 3' 0' 1' 2' false);  	break;  case VtfImageFormat.Abgr8888:  	TransformBytes (buffer' br' width' height' 4' 0' 3' 2' 1' false);  	break;  case VtfImageFormat.Rgb888:  	TransformBytes (buffer' br' width' height' 3' -1' 0' 1' 2' false);  	break;  case VtfImageFormat.Bgr888:  	TransformBytes (buffer' br' width' height' 3' -1' 2' 1' 0' false);  	break;  case VtfImageFormat.Rgb565:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.I8:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Ia88:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.P8:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.A8:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgb888Bluescreen:  	TransformBytes (buffer' br' width' height' 3' -1' 0' 1' 2' true);  	break;  case VtfImageFormat.Bgr888Bluescreen:  	TransformBytes (buffer' br' width' height' 3' -1' 2' 1' 0' true);  	break;  case VtfImageFormat.Argb8888:  	TransformBytes (buffer' br' width' height' 4' 0' 1' 2' 3' false);  	break;  case VtfImageFormat.Bgra8888:  	br.Read (buffer' 0' buffer.Length);  	break;  case VtfImageFormat.Dxt1:  case VtfImageFormat.Dxt1Onebitalpha:  	DecompressDxt1 (buffer' br' width' height);  	break;  case VtfImageFormat.Dxt3:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Dxt5:  	DecompressDxt5 (buffer' br' width' height);  	break;  case VtfImageFormat.Bgrx8888:  	TransformBytes (buffer' br' width' height' 4' -1' 2' 1' 0' false);  	break;  case VtfImageFormat.Bgr565:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Bgrx5551:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Bgra4444:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Bgra5551:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Uv88:  	TransformBytes (buffer' br' width' height' 2' -1' 0' 1' -1' false);  	break;  case VtfImageFormat.Uvwq8888:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgba16161616F:  	TransformRgba16161616F (buffer' br' width' height);  	break;  case VtfImageFormat.Rgba16161616:  	TransformShorts (buffer' br' width' height' 8' 3' 0' 1' 2);  	break;  case VtfImageFormat.Uvlx8888:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.R32F:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgb323232F:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgba32323232F:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvDst16:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvDst24:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvIntz:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvRawz:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.AtiDst16:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.AtiDst24:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvNull:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Ati2N:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Ati1N:  	throw new NotImplementedException ();  	break;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,LoadImage,The following statement contains a magic number: switch (format) {  case VtfImageFormat.Rgba8888:  	TransformBytes (buffer' br' width' height' 4' 3' 0' 1' 2' false);  	break;  case VtfImageFormat.Abgr8888:  	TransformBytes (buffer' br' width' height' 4' 0' 3' 2' 1' false);  	break;  case VtfImageFormat.Rgb888:  	TransformBytes (buffer' br' width' height' 3' -1' 0' 1' 2' false);  	break;  case VtfImageFormat.Bgr888:  	TransformBytes (buffer' br' width' height' 3' -1' 2' 1' 0' false);  	break;  case VtfImageFormat.Rgb565:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.I8:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Ia88:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.P8:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.A8:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgb888Bluescreen:  	TransformBytes (buffer' br' width' height' 3' -1' 0' 1' 2' true);  	break;  case VtfImageFormat.Bgr888Bluescreen:  	TransformBytes (buffer' br' width' height' 3' -1' 2' 1' 0' true);  	break;  case VtfImageFormat.Argb8888:  	TransformBytes (buffer' br' width' height' 4' 0' 1' 2' 3' false);  	break;  case VtfImageFormat.Bgra8888:  	br.Read (buffer' 0' buffer.Length);  	break;  case VtfImageFormat.Dxt1:  case VtfImageFormat.Dxt1Onebitalpha:  	DecompressDxt1 (buffer' br' width' height);  	break;  case VtfImageFormat.Dxt3:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Dxt5:  	DecompressDxt5 (buffer' br' width' height);  	break;  case VtfImageFormat.Bgrx8888:  	TransformBytes (buffer' br' width' height' 4' -1' 2' 1' 0' false);  	break;  case VtfImageFormat.Bgr565:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Bgrx5551:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Bgra4444:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Bgra5551:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Uv88:  	TransformBytes (buffer' br' width' height' 2' -1' 0' 1' -1' false);  	break;  case VtfImageFormat.Uvwq8888:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgba16161616F:  	TransformRgba16161616F (buffer' br' width' height);  	break;  case VtfImageFormat.Rgba16161616:  	TransformShorts (buffer' br' width' height' 8' 3' 0' 1' 2);  	break;  case VtfImageFormat.Uvlx8888:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.R32F:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgb323232F:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgba32323232F:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvDst16:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvDst24:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvIntz:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvRawz:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.AtiDst16:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.AtiDst24:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvNull:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Ati2N:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Ati1N:  	throw new NotImplementedException ();  	break;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,LoadImage,The following statement contains a magic number: switch (format) {  case VtfImageFormat.Rgba8888:  	TransformBytes (buffer' br' width' height' 4' 3' 0' 1' 2' false);  	break;  case VtfImageFormat.Abgr8888:  	TransformBytes (buffer' br' width' height' 4' 0' 3' 2' 1' false);  	break;  case VtfImageFormat.Rgb888:  	TransformBytes (buffer' br' width' height' 3' -1' 0' 1' 2' false);  	break;  case VtfImageFormat.Bgr888:  	TransformBytes (buffer' br' width' height' 3' -1' 2' 1' 0' false);  	break;  case VtfImageFormat.Rgb565:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.I8:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Ia88:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.P8:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.A8:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgb888Bluescreen:  	TransformBytes (buffer' br' width' height' 3' -1' 0' 1' 2' true);  	break;  case VtfImageFormat.Bgr888Bluescreen:  	TransformBytes (buffer' br' width' height' 3' -1' 2' 1' 0' true);  	break;  case VtfImageFormat.Argb8888:  	TransformBytes (buffer' br' width' height' 4' 0' 1' 2' 3' false);  	break;  case VtfImageFormat.Bgra8888:  	br.Read (buffer' 0' buffer.Length);  	break;  case VtfImageFormat.Dxt1:  case VtfImageFormat.Dxt1Onebitalpha:  	DecompressDxt1 (buffer' br' width' height);  	break;  case VtfImageFormat.Dxt3:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Dxt5:  	DecompressDxt5 (buffer' br' width' height);  	break;  case VtfImageFormat.Bgrx8888:  	TransformBytes (buffer' br' width' height' 4' -1' 2' 1' 0' false);  	break;  case VtfImageFormat.Bgr565:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Bgrx5551:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Bgra4444:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Bgra5551:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Uv88:  	TransformBytes (buffer' br' width' height' 2' -1' 0' 1' -1' false);  	break;  case VtfImageFormat.Uvwq8888:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgba16161616F:  	TransformRgba16161616F (buffer' br' width' height);  	break;  case VtfImageFormat.Rgba16161616:  	TransformShorts (buffer' br' width' height' 8' 3' 0' 1' 2);  	break;  case VtfImageFormat.Uvlx8888:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.R32F:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgb323232F:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgba32323232F:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvDst16:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvDst24:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvIntz:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvRawz:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.AtiDst16:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.AtiDst24:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvNull:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Ati2N:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Ati1N:  	throw new NotImplementedException ();  	break;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,LoadImage,The following statement contains a magic number: switch (format) {  case VtfImageFormat.Rgba8888:  	TransformBytes (buffer' br' width' height' 4' 3' 0' 1' 2' false);  	break;  case VtfImageFormat.Abgr8888:  	TransformBytes (buffer' br' width' height' 4' 0' 3' 2' 1' false);  	break;  case VtfImageFormat.Rgb888:  	TransformBytes (buffer' br' width' height' 3' -1' 0' 1' 2' false);  	break;  case VtfImageFormat.Bgr888:  	TransformBytes (buffer' br' width' height' 3' -1' 2' 1' 0' false);  	break;  case VtfImageFormat.Rgb565:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.I8:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Ia88:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.P8:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.A8:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgb888Bluescreen:  	TransformBytes (buffer' br' width' height' 3' -1' 0' 1' 2' true);  	break;  case VtfImageFormat.Bgr888Bluescreen:  	TransformBytes (buffer' br' width' height' 3' -1' 2' 1' 0' true);  	break;  case VtfImageFormat.Argb8888:  	TransformBytes (buffer' br' width' height' 4' 0' 1' 2' 3' false);  	break;  case VtfImageFormat.Bgra8888:  	br.Read (buffer' 0' buffer.Length);  	break;  case VtfImageFormat.Dxt1:  case VtfImageFormat.Dxt1Onebitalpha:  	DecompressDxt1 (buffer' br' width' height);  	break;  case VtfImageFormat.Dxt3:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Dxt5:  	DecompressDxt5 (buffer' br' width' height);  	break;  case VtfImageFormat.Bgrx8888:  	TransformBytes (buffer' br' width' height' 4' -1' 2' 1' 0' false);  	break;  case VtfImageFormat.Bgr565:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Bgrx5551:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Bgra4444:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Bgra5551:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Uv88:  	TransformBytes (buffer' br' width' height' 2' -1' 0' 1' -1' false);  	break;  case VtfImageFormat.Uvwq8888:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgba16161616F:  	TransformRgba16161616F (buffer' br' width' height);  	break;  case VtfImageFormat.Rgba16161616:  	TransformShorts (buffer' br' width' height' 8' 3' 0' 1' 2);  	break;  case VtfImageFormat.Uvlx8888:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.R32F:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgb323232F:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgba32323232F:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvDst16:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvDst24:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvIntz:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvRawz:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.AtiDst16:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.AtiDst24:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvNull:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Ati2N:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Ati1N:  	throw new NotImplementedException ();  	break;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,LoadImage,The following statement contains a magic number: switch (format) {  case VtfImageFormat.Rgba8888:  	TransformBytes (buffer' br' width' height' 4' 3' 0' 1' 2' false);  	break;  case VtfImageFormat.Abgr8888:  	TransformBytes (buffer' br' width' height' 4' 0' 3' 2' 1' false);  	break;  case VtfImageFormat.Rgb888:  	TransformBytes (buffer' br' width' height' 3' -1' 0' 1' 2' false);  	break;  case VtfImageFormat.Bgr888:  	TransformBytes (buffer' br' width' height' 3' -1' 2' 1' 0' false);  	break;  case VtfImageFormat.Rgb565:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.I8:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Ia88:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.P8:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.A8:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgb888Bluescreen:  	TransformBytes (buffer' br' width' height' 3' -1' 0' 1' 2' true);  	break;  case VtfImageFormat.Bgr888Bluescreen:  	TransformBytes (buffer' br' width' height' 3' -1' 2' 1' 0' true);  	break;  case VtfImageFormat.Argb8888:  	TransformBytes (buffer' br' width' height' 4' 0' 1' 2' 3' false);  	break;  case VtfImageFormat.Bgra8888:  	br.Read (buffer' 0' buffer.Length);  	break;  case VtfImageFormat.Dxt1:  case VtfImageFormat.Dxt1Onebitalpha:  	DecompressDxt1 (buffer' br' width' height);  	break;  case VtfImageFormat.Dxt3:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Dxt5:  	DecompressDxt5 (buffer' br' width' height);  	break;  case VtfImageFormat.Bgrx8888:  	TransformBytes (buffer' br' width' height' 4' -1' 2' 1' 0' false);  	break;  case VtfImageFormat.Bgr565:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Bgrx5551:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Bgra4444:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Bgra5551:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Uv88:  	TransformBytes (buffer' br' width' height' 2' -1' 0' 1' -1' false);  	break;  case VtfImageFormat.Uvwq8888:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgba16161616F:  	TransformRgba16161616F (buffer' br' width' height);  	break;  case VtfImageFormat.Rgba16161616:  	TransformShorts (buffer' br' width' height' 8' 3' 0' 1' 2);  	break;  case VtfImageFormat.Uvlx8888:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.R32F:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgb323232F:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgba32323232F:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvDst16:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvDst24:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvIntz:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvRawz:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.AtiDst16:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.AtiDst24:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvNull:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Ati2N:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Ati1N:  	throw new NotImplementedException ();  	break;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,LoadImage,The following statement contains a magic number: switch (format) {  case VtfImageFormat.Rgba8888:  	TransformBytes (buffer' br' width' height' 4' 3' 0' 1' 2' false);  	break;  case VtfImageFormat.Abgr8888:  	TransformBytes (buffer' br' width' height' 4' 0' 3' 2' 1' false);  	break;  case VtfImageFormat.Rgb888:  	TransformBytes (buffer' br' width' height' 3' -1' 0' 1' 2' false);  	break;  case VtfImageFormat.Bgr888:  	TransformBytes (buffer' br' width' height' 3' -1' 2' 1' 0' false);  	break;  case VtfImageFormat.Rgb565:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.I8:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Ia88:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.P8:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.A8:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgb888Bluescreen:  	TransformBytes (buffer' br' width' height' 3' -1' 0' 1' 2' true);  	break;  case VtfImageFormat.Bgr888Bluescreen:  	TransformBytes (buffer' br' width' height' 3' -1' 2' 1' 0' true);  	break;  case VtfImageFormat.Argb8888:  	TransformBytes (buffer' br' width' height' 4' 0' 1' 2' 3' false);  	break;  case VtfImageFormat.Bgra8888:  	br.Read (buffer' 0' buffer.Length);  	break;  case VtfImageFormat.Dxt1:  case VtfImageFormat.Dxt1Onebitalpha:  	DecompressDxt1 (buffer' br' width' height);  	break;  case VtfImageFormat.Dxt3:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Dxt5:  	DecompressDxt5 (buffer' br' width' height);  	break;  case VtfImageFormat.Bgrx8888:  	TransformBytes (buffer' br' width' height' 4' -1' 2' 1' 0' false);  	break;  case VtfImageFormat.Bgr565:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Bgrx5551:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Bgra4444:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Bgra5551:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Uv88:  	TransformBytes (buffer' br' width' height' 2' -1' 0' 1' -1' false);  	break;  case VtfImageFormat.Uvwq8888:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgba16161616F:  	TransformRgba16161616F (buffer' br' width' height);  	break;  case VtfImageFormat.Rgba16161616:  	TransformShorts (buffer' br' width' height' 8' 3' 0' 1' 2);  	break;  case VtfImageFormat.Uvlx8888:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.R32F:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgb323232F:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgba32323232F:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvDst16:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvDst24:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvIntz:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvRawz:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.AtiDst16:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.AtiDst24:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvNull:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Ati2N:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Ati1N:  	throw new NotImplementedException ();  	break;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,LoadImage,The following statement contains a magic number: switch (format) {  case VtfImageFormat.Rgba8888:  	TransformBytes (buffer' br' width' height' 4' 3' 0' 1' 2' false);  	break;  case VtfImageFormat.Abgr8888:  	TransformBytes (buffer' br' width' height' 4' 0' 3' 2' 1' false);  	break;  case VtfImageFormat.Rgb888:  	TransformBytes (buffer' br' width' height' 3' -1' 0' 1' 2' false);  	break;  case VtfImageFormat.Bgr888:  	TransformBytes (buffer' br' width' height' 3' -1' 2' 1' 0' false);  	break;  case VtfImageFormat.Rgb565:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.I8:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Ia88:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.P8:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.A8:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgb888Bluescreen:  	TransformBytes (buffer' br' width' height' 3' -1' 0' 1' 2' true);  	break;  case VtfImageFormat.Bgr888Bluescreen:  	TransformBytes (buffer' br' width' height' 3' -1' 2' 1' 0' true);  	break;  case VtfImageFormat.Argb8888:  	TransformBytes (buffer' br' width' height' 4' 0' 1' 2' 3' false);  	break;  case VtfImageFormat.Bgra8888:  	br.Read (buffer' 0' buffer.Length);  	break;  case VtfImageFormat.Dxt1:  case VtfImageFormat.Dxt1Onebitalpha:  	DecompressDxt1 (buffer' br' width' height);  	break;  case VtfImageFormat.Dxt3:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Dxt5:  	DecompressDxt5 (buffer' br' width' height);  	break;  case VtfImageFormat.Bgrx8888:  	TransformBytes (buffer' br' width' height' 4' -1' 2' 1' 0' false);  	break;  case VtfImageFormat.Bgr565:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Bgrx5551:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Bgra4444:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Bgra5551:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Uv88:  	TransformBytes (buffer' br' width' height' 2' -1' 0' 1' -1' false);  	break;  case VtfImageFormat.Uvwq8888:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgba16161616F:  	TransformRgba16161616F (buffer' br' width' height);  	break;  case VtfImageFormat.Rgba16161616:  	TransformShorts (buffer' br' width' height' 8' 3' 0' 1' 2);  	break;  case VtfImageFormat.Uvlx8888:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.R32F:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgb323232F:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgba32323232F:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvDst16:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvDst24:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvIntz:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvRawz:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.AtiDst16:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.AtiDst24:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvNull:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Ati2N:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Ati1N:  	throw new NotImplementedException ();  	break;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,LoadImage,The following statement contains a magic number: switch (format) {  case VtfImageFormat.Rgba8888:  	TransformBytes (buffer' br' width' height' 4' 3' 0' 1' 2' false);  	break;  case VtfImageFormat.Abgr8888:  	TransformBytes (buffer' br' width' height' 4' 0' 3' 2' 1' false);  	break;  case VtfImageFormat.Rgb888:  	TransformBytes (buffer' br' width' height' 3' -1' 0' 1' 2' false);  	break;  case VtfImageFormat.Bgr888:  	TransformBytes (buffer' br' width' height' 3' -1' 2' 1' 0' false);  	break;  case VtfImageFormat.Rgb565:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.I8:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Ia88:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.P8:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.A8:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgb888Bluescreen:  	TransformBytes (buffer' br' width' height' 3' -1' 0' 1' 2' true);  	break;  case VtfImageFormat.Bgr888Bluescreen:  	TransformBytes (buffer' br' width' height' 3' -1' 2' 1' 0' true);  	break;  case VtfImageFormat.Argb8888:  	TransformBytes (buffer' br' width' height' 4' 0' 1' 2' 3' false);  	break;  case VtfImageFormat.Bgra8888:  	br.Read (buffer' 0' buffer.Length);  	break;  case VtfImageFormat.Dxt1:  case VtfImageFormat.Dxt1Onebitalpha:  	DecompressDxt1 (buffer' br' width' height);  	break;  case VtfImageFormat.Dxt3:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Dxt5:  	DecompressDxt5 (buffer' br' width' height);  	break;  case VtfImageFormat.Bgrx8888:  	TransformBytes (buffer' br' width' height' 4' -1' 2' 1' 0' false);  	break;  case VtfImageFormat.Bgr565:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Bgrx5551:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Bgra4444:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Bgra5551:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Uv88:  	TransformBytes (buffer' br' width' height' 2' -1' 0' 1' -1' false);  	break;  case VtfImageFormat.Uvwq8888:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgba16161616F:  	TransformRgba16161616F (buffer' br' width' height);  	break;  case VtfImageFormat.Rgba16161616:  	TransformShorts (buffer' br' width' height' 8' 3' 0' 1' 2);  	break;  case VtfImageFormat.Uvlx8888:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.R32F:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgb323232F:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgba32323232F:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvDst16:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvDst24:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvIntz:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvRawz:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.AtiDst16:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.AtiDst24:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvNull:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Ati2N:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Ati1N:  	throw new NotImplementedException ();  	break;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,LoadImage,The following statement contains a magic number: switch (format) {  case VtfImageFormat.Rgba8888:  	TransformBytes (buffer' br' width' height' 4' 3' 0' 1' 2' false);  	break;  case VtfImageFormat.Abgr8888:  	TransformBytes (buffer' br' width' height' 4' 0' 3' 2' 1' false);  	break;  case VtfImageFormat.Rgb888:  	TransformBytes (buffer' br' width' height' 3' -1' 0' 1' 2' false);  	break;  case VtfImageFormat.Bgr888:  	TransformBytes (buffer' br' width' height' 3' -1' 2' 1' 0' false);  	break;  case VtfImageFormat.Rgb565:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.I8:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Ia88:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.P8:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.A8:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgb888Bluescreen:  	TransformBytes (buffer' br' width' height' 3' -1' 0' 1' 2' true);  	break;  case VtfImageFormat.Bgr888Bluescreen:  	TransformBytes (buffer' br' width' height' 3' -1' 2' 1' 0' true);  	break;  case VtfImageFormat.Argb8888:  	TransformBytes (buffer' br' width' height' 4' 0' 1' 2' 3' false);  	break;  case VtfImageFormat.Bgra8888:  	br.Read (buffer' 0' buffer.Length);  	break;  case VtfImageFormat.Dxt1:  case VtfImageFormat.Dxt1Onebitalpha:  	DecompressDxt1 (buffer' br' width' height);  	break;  case VtfImageFormat.Dxt3:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Dxt5:  	DecompressDxt5 (buffer' br' width' height);  	break;  case VtfImageFormat.Bgrx8888:  	TransformBytes (buffer' br' width' height' 4' -1' 2' 1' 0' false);  	break;  case VtfImageFormat.Bgr565:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Bgrx5551:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Bgra4444:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Bgra5551:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Uv88:  	TransformBytes (buffer' br' width' height' 2' -1' 0' 1' -1' false);  	break;  case VtfImageFormat.Uvwq8888:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgba16161616F:  	TransformRgba16161616F (buffer' br' width' height);  	break;  case VtfImageFormat.Rgba16161616:  	TransformShorts (buffer' br' width' height' 8' 3' 0' 1' 2);  	break;  case VtfImageFormat.Uvlx8888:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.R32F:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgb323232F:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgba32323232F:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvDst16:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvDst24:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvIntz:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvRawz:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.AtiDst16:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.AtiDst24:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvNull:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Ati2N:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Ati1N:  	throw new NotImplementedException ();  	break;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,LoadImage,The following statement contains a magic number: switch (format) {  case VtfImageFormat.Rgba8888:  	TransformBytes (buffer' br' width' height' 4' 3' 0' 1' 2' false);  	break;  case VtfImageFormat.Abgr8888:  	TransformBytes (buffer' br' width' height' 4' 0' 3' 2' 1' false);  	break;  case VtfImageFormat.Rgb888:  	TransformBytes (buffer' br' width' height' 3' -1' 0' 1' 2' false);  	break;  case VtfImageFormat.Bgr888:  	TransformBytes (buffer' br' width' height' 3' -1' 2' 1' 0' false);  	break;  case VtfImageFormat.Rgb565:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.I8:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Ia88:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.P8:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.A8:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgb888Bluescreen:  	TransformBytes (buffer' br' width' height' 3' -1' 0' 1' 2' true);  	break;  case VtfImageFormat.Bgr888Bluescreen:  	TransformBytes (buffer' br' width' height' 3' -1' 2' 1' 0' true);  	break;  case VtfImageFormat.Argb8888:  	TransformBytes (buffer' br' width' height' 4' 0' 1' 2' 3' false);  	break;  case VtfImageFormat.Bgra8888:  	br.Read (buffer' 0' buffer.Length);  	break;  case VtfImageFormat.Dxt1:  case VtfImageFormat.Dxt1Onebitalpha:  	DecompressDxt1 (buffer' br' width' height);  	break;  case VtfImageFormat.Dxt3:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Dxt5:  	DecompressDxt5 (buffer' br' width' height);  	break;  case VtfImageFormat.Bgrx8888:  	TransformBytes (buffer' br' width' height' 4' -1' 2' 1' 0' false);  	break;  case VtfImageFormat.Bgr565:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Bgrx5551:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Bgra4444:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Bgra5551:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Uv88:  	TransformBytes (buffer' br' width' height' 2' -1' 0' 1' -1' false);  	break;  case VtfImageFormat.Uvwq8888:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgba16161616F:  	TransformRgba16161616F (buffer' br' width' height);  	break;  case VtfImageFormat.Rgba16161616:  	TransformShorts (buffer' br' width' height' 8' 3' 0' 1' 2);  	break;  case VtfImageFormat.Uvlx8888:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.R32F:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgb323232F:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgba32323232F:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvDst16:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvDst24:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvIntz:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvRawz:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.AtiDst16:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.AtiDst24:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvNull:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Ati2N:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Ati1N:  	throw new NotImplementedException ();  	break;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,LoadImage,The following statement contains a magic number: switch (format) {  case VtfImageFormat.Rgba8888:  	TransformBytes (buffer' br' width' height' 4' 3' 0' 1' 2' false);  	break;  case VtfImageFormat.Abgr8888:  	TransformBytes (buffer' br' width' height' 4' 0' 3' 2' 1' false);  	break;  case VtfImageFormat.Rgb888:  	TransformBytes (buffer' br' width' height' 3' -1' 0' 1' 2' false);  	break;  case VtfImageFormat.Bgr888:  	TransformBytes (buffer' br' width' height' 3' -1' 2' 1' 0' false);  	break;  case VtfImageFormat.Rgb565:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.I8:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Ia88:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.P8:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.A8:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgb888Bluescreen:  	TransformBytes (buffer' br' width' height' 3' -1' 0' 1' 2' true);  	break;  case VtfImageFormat.Bgr888Bluescreen:  	TransformBytes (buffer' br' width' height' 3' -1' 2' 1' 0' true);  	break;  case VtfImageFormat.Argb8888:  	TransformBytes (buffer' br' width' height' 4' 0' 1' 2' 3' false);  	break;  case VtfImageFormat.Bgra8888:  	br.Read (buffer' 0' buffer.Length);  	break;  case VtfImageFormat.Dxt1:  case VtfImageFormat.Dxt1Onebitalpha:  	DecompressDxt1 (buffer' br' width' height);  	break;  case VtfImageFormat.Dxt3:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Dxt5:  	DecompressDxt5 (buffer' br' width' height);  	break;  case VtfImageFormat.Bgrx8888:  	TransformBytes (buffer' br' width' height' 4' -1' 2' 1' 0' false);  	break;  case VtfImageFormat.Bgr565:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Bgrx5551:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Bgra4444:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Bgra5551:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Uv88:  	TransformBytes (buffer' br' width' height' 2' -1' 0' 1' -1' false);  	break;  case VtfImageFormat.Uvwq8888:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgba16161616F:  	TransformRgba16161616F (buffer' br' width' height);  	break;  case VtfImageFormat.Rgba16161616:  	TransformShorts (buffer' br' width' height' 8' 3' 0' 1' 2);  	break;  case VtfImageFormat.Uvlx8888:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.R32F:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgb323232F:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgba32323232F:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvDst16:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvDst24:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvIntz:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvRawz:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.AtiDst16:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.AtiDst24:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvNull:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Ati2N:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Ati1N:  	throw new NotImplementedException ();  	break;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,LoadImage,The following statement contains a magic number: switch (format) {  case VtfImageFormat.Rgba8888:  	TransformBytes (buffer' br' width' height' 4' 3' 0' 1' 2' false);  	break;  case VtfImageFormat.Abgr8888:  	TransformBytes (buffer' br' width' height' 4' 0' 3' 2' 1' false);  	break;  case VtfImageFormat.Rgb888:  	TransformBytes (buffer' br' width' height' 3' -1' 0' 1' 2' false);  	break;  case VtfImageFormat.Bgr888:  	TransformBytes (buffer' br' width' height' 3' -1' 2' 1' 0' false);  	break;  case VtfImageFormat.Rgb565:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.I8:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Ia88:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.P8:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.A8:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgb888Bluescreen:  	TransformBytes (buffer' br' width' height' 3' -1' 0' 1' 2' true);  	break;  case VtfImageFormat.Bgr888Bluescreen:  	TransformBytes (buffer' br' width' height' 3' -1' 2' 1' 0' true);  	break;  case VtfImageFormat.Argb8888:  	TransformBytes (buffer' br' width' height' 4' 0' 1' 2' 3' false);  	break;  case VtfImageFormat.Bgra8888:  	br.Read (buffer' 0' buffer.Length);  	break;  case VtfImageFormat.Dxt1:  case VtfImageFormat.Dxt1Onebitalpha:  	DecompressDxt1 (buffer' br' width' height);  	break;  case VtfImageFormat.Dxt3:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Dxt5:  	DecompressDxt5 (buffer' br' width' height);  	break;  case VtfImageFormat.Bgrx8888:  	TransformBytes (buffer' br' width' height' 4' -1' 2' 1' 0' false);  	break;  case VtfImageFormat.Bgr565:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Bgrx5551:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Bgra4444:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Bgra5551:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Uv88:  	TransformBytes (buffer' br' width' height' 2' -1' 0' 1' -1' false);  	break;  case VtfImageFormat.Uvwq8888:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgba16161616F:  	TransformRgba16161616F (buffer' br' width' height);  	break;  case VtfImageFormat.Rgba16161616:  	TransformShorts (buffer' br' width' height' 8' 3' 0' 1' 2);  	break;  case VtfImageFormat.Uvlx8888:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.R32F:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgb323232F:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgba32323232F:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvDst16:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvDst24:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvIntz:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvRawz:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.AtiDst16:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.AtiDst24:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvNull:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Ati2N:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Ati1N:  	throw new NotImplementedException ();  	break;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,LoadImage,The following statement contains a magic number: switch (format) {  case VtfImageFormat.Rgba8888:  	TransformBytes (buffer' br' width' height' 4' 3' 0' 1' 2' false);  	break;  case VtfImageFormat.Abgr8888:  	TransformBytes (buffer' br' width' height' 4' 0' 3' 2' 1' false);  	break;  case VtfImageFormat.Rgb888:  	TransformBytes (buffer' br' width' height' 3' -1' 0' 1' 2' false);  	break;  case VtfImageFormat.Bgr888:  	TransformBytes (buffer' br' width' height' 3' -1' 2' 1' 0' false);  	break;  case VtfImageFormat.Rgb565:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.I8:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Ia88:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.P8:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.A8:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgb888Bluescreen:  	TransformBytes (buffer' br' width' height' 3' -1' 0' 1' 2' true);  	break;  case VtfImageFormat.Bgr888Bluescreen:  	TransformBytes (buffer' br' width' height' 3' -1' 2' 1' 0' true);  	break;  case VtfImageFormat.Argb8888:  	TransformBytes (buffer' br' width' height' 4' 0' 1' 2' 3' false);  	break;  case VtfImageFormat.Bgra8888:  	br.Read (buffer' 0' buffer.Length);  	break;  case VtfImageFormat.Dxt1:  case VtfImageFormat.Dxt1Onebitalpha:  	DecompressDxt1 (buffer' br' width' height);  	break;  case VtfImageFormat.Dxt3:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Dxt5:  	DecompressDxt5 (buffer' br' width' height);  	break;  case VtfImageFormat.Bgrx8888:  	TransformBytes (buffer' br' width' height' 4' -1' 2' 1' 0' false);  	break;  case VtfImageFormat.Bgr565:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Bgrx5551:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Bgra4444:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Bgra5551:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Uv88:  	TransformBytes (buffer' br' width' height' 2' -1' 0' 1' -1' false);  	break;  case VtfImageFormat.Uvwq8888:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgba16161616F:  	TransformRgba16161616F (buffer' br' width' height);  	break;  case VtfImageFormat.Rgba16161616:  	TransformShorts (buffer' br' width' height' 8' 3' 0' 1' 2);  	break;  case VtfImageFormat.Uvlx8888:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.R32F:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgb323232F:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgba32323232F:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvDst16:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvDst24:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvIntz:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvRawz:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.AtiDst16:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.AtiDst24:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvNull:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Ati2N:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Ati1N:  	throw new NotImplementedException ();  	break;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,LoadImage,The following statement contains a magic number: switch (format) {  case VtfImageFormat.Rgba8888:  	TransformBytes (buffer' br' width' height' 4' 3' 0' 1' 2' false);  	break;  case VtfImageFormat.Abgr8888:  	TransformBytes (buffer' br' width' height' 4' 0' 3' 2' 1' false);  	break;  case VtfImageFormat.Rgb888:  	TransformBytes (buffer' br' width' height' 3' -1' 0' 1' 2' false);  	break;  case VtfImageFormat.Bgr888:  	TransformBytes (buffer' br' width' height' 3' -1' 2' 1' 0' false);  	break;  case VtfImageFormat.Rgb565:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.I8:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Ia88:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.P8:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.A8:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgb888Bluescreen:  	TransformBytes (buffer' br' width' height' 3' -1' 0' 1' 2' true);  	break;  case VtfImageFormat.Bgr888Bluescreen:  	TransformBytes (buffer' br' width' height' 3' -1' 2' 1' 0' true);  	break;  case VtfImageFormat.Argb8888:  	TransformBytes (buffer' br' width' height' 4' 0' 1' 2' 3' false);  	break;  case VtfImageFormat.Bgra8888:  	br.Read (buffer' 0' buffer.Length);  	break;  case VtfImageFormat.Dxt1:  case VtfImageFormat.Dxt1Onebitalpha:  	DecompressDxt1 (buffer' br' width' height);  	break;  case VtfImageFormat.Dxt3:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Dxt5:  	DecompressDxt5 (buffer' br' width' height);  	break;  case VtfImageFormat.Bgrx8888:  	TransformBytes (buffer' br' width' height' 4' -1' 2' 1' 0' false);  	break;  case VtfImageFormat.Bgr565:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Bgrx5551:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Bgra4444:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Bgra5551:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Uv88:  	TransformBytes (buffer' br' width' height' 2' -1' 0' 1' -1' false);  	break;  case VtfImageFormat.Uvwq8888:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgba16161616F:  	TransformRgba16161616F (buffer' br' width' height);  	break;  case VtfImageFormat.Rgba16161616:  	TransformShorts (buffer' br' width' height' 8' 3' 0' 1' 2);  	break;  case VtfImageFormat.Uvlx8888:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.R32F:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgb323232F:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgba32323232F:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvDst16:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvDst24:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvIntz:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvRawz:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.AtiDst16:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.AtiDst24:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvNull:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Ati2N:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Ati1N:  	throw new NotImplementedException ();  	break;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,LoadImage,The following statement contains a magic number: switch (format) {  case VtfImageFormat.Rgba8888:  	TransformBytes (buffer' br' width' height' 4' 3' 0' 1' 2' false);  	break;  case VtfImageFormat.Abgr8888:  	TransformBytes (buffer' br' width' height' 4' 0' 3' 2' 1' false);  	break;  case VtfImageFormat.Rgb888:  	TransformBytes (buffer' br' width' height' 3' -1' 0' 1' 2' false);  	break;  case VtfImageFormat.Bgr888:  	TransformBytes (buffer' br' width' height' 3' -1' 2' 1' 0' false);  	break;  case VtfImageFormat.Rgb565:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.I8:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Ia88:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.P8:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.A8:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgb888Bluescreen:  	TransformBytes (buffer' br' width' height' 3' -1' 0' 1' 2' true);  	break;  case VtfImageFormat.Bgr888Bluescreen:  	TransformBytes (buffer' br' width' height' 3' -1' 2' 1' 0' true);  	break;  case VtfImageFormat.Argb8888:  	TransformBytes (buffer' br' width' height' 4' 0' 1' 2' 3' false);  	break;  case VtfImageFormat.Bgra8888:  	br.Read (buffer' 0' buffer.Length);  	break;  case VtfImageFormat.Dxt1:  case VtfImageFormat.Dxt1Onebitalpha:  	DecompressDxt1 (buffer' br' width' height);  	break;  case VtfImageFormat.Dxt3:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Dxt5:  	DecompressDxt5 (buffer' br' width' height);  	break;  case VtfImageFormat.Bgrx8888:  	TransformBytes (buffer' br' width' height' 4' -1' 2' 1' 0' false);  	break;  case VtfImageFormat.Bgr565:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Bgrx5551:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Bgra4444:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Bgra5551:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Uv88:  	TransformBytes (buffer' br' width' height' 2' -1' 0' 1' -1' false);  	break;  case VtfImageFormat.Uvwq8888:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgba16161616F:  	TransformRgba16161616F (buffer' br' width' height);  	break;  case VtfImageFormat.Rgba16161616:  	TransformShorts (buffer' br' width' height' 8' 3' 0' 1' 2);  	break;  case VtfImageFormat.Uvlx8888:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.R32F:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgb323232F:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgba32323232F:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvDst16:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvDst24:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvIntz:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvRawz:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.AtiDst16:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.AtiDst24:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvNull:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Ati2N:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Ati1N:  	throw new NotImplementedException ();  	break;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,LoadImage,The following statement contains a magic number: switch (format) {  case VtfImageFormat.Rgba8888:  	TransformBytes (buffer' br' width' height' 4' 3' 0' 1' 2' false);  	break;  case VtfImageFormat.Abgr8888:  	TransformBytes (buffer' br' width' height' 4' 0' 3' 2' 1' false);  	break;  case VtfImageFormat.Rgb888:  	TransformBytes (buffer' br' width' height' 3' -1' 0' 1' 2' false);  	break;  case VtfImageFormat.Bgr888:  	TransformBytes (buffer' br' width' height' 3' -1' 2' 1' 0' false);  	break;  case VtfImageFormat.Rgb565:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.I8:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Ia88:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.P8:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.A8:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgb888Bluescreen:  	TransformBytes (buffer' br' width' height' 3' -1' 0' 1' 2' true);  	break;  case VtfImageFormat.Bgr888Bluescreen:  	TransformBytes (buffer' br' width' height' 3' -1' 2' 1' 0' true);  	break;  case VtfImageFormat.Argb8888:  	TransformBytes (buffer' br' width' height' 4' 0' 1' 2' 3' false);  	break;  case VtfImageFormat.Bgra8888:  	br.Read (buffer' 0' buffer.Length);  	break;  case VtfImageFormat.Dxt1:  case VtfImageFormat.Dxt1Onebitalpha:  	DecompressDxt1 (buffer' br' width' height);  	break;  case VtfImageFormat.Dxt3:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Dxt5:  	DecompressDxt5 (buffer' br' width' height);  	break;  case VtfImageFormat.Bgrx8888:  	TransformBytes (buffer' br' width' height' 4' -1' 2' 1' 0' false);  	break;  case VtfImageFormat.Bgr565:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Bgrx5551:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Bgra4444:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Bgra5551:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Uv88:  	TransformBytes (buffer' br' width' height' 2' -1' 0' 1' -1' false);  	break;  case VtfImageFormat.Uvwq8888:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgba16161616F:  	TransformRgba16161616F (buffer' br' width' height);  	break;  case VtfImageFormat.Rgba16161616:  	TransformShorts (buffer' br' width' height' 8' 3' 0' 1' 2);  	break;  case VtfImageFormat.Uvlx8888:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.R32F:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgb323232F:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgba32323232F:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvDst16:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvDst24:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvIntz:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvRawz:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.AtiDst16:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.AtiDst24:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvNull:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Ati2N:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Ati1N:  	throw new NotImplementedException ();  	break;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,LoadImage,The following statement contains a magic number: switch (format) {  case VtfImageFormat.Rgba8888:  	TransformBytes (buffer' br' width' height' 4' 3' 0' 1' 2' false);  	break;  case VtfImageFormat.Abgr8888:  	TransformBytes (buffer' br' width' height' 4' 0' 3' 2' 1' false);  	break;  case VtfImageFormat.Rgb888:  	TransformBytes (buffer' br' width' height' 3' -1' 0' 1' 2' false);  	break;  case VtfImageFormat.Bgr888:  	TransformBytes (buffer' br' width' height' 3' -1' 2' 1' 0' false);  	break;  case VtfImageFormat.Rgb565:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.I8:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Ia88:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.P8:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.A8:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgb888Bluescreen:  	TransformBytes (buffer' br' width' height' 3' -1' 0' 1' 2' true);  	break;  case VtfImageFormat.Bgr888Bluescreen:  	TransformBytes (buffer' br' width' height' 3' -1' 2' 1' 0' true);  	break;  case VtfImageFormat.Argb8888:  	TransformBytes (buffer' br' width' height' 4' 0' 1' 2' 3' false);  	break;  case VtfImageFormat.Bgra8888:  	br.Read (buffer' 0' buffer.Length);  	break;  case VtfImageFormat.Dxt1:  case VtfImageFormat.Dxt1Onebitalpha:  	DecompressDxt1 (buffer' br' width' height);  	break;  case VtfImageFormat.Dxt3:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Dxt5:  	DecompressDxt5 (buffer' br' width' height);  	break;  case VtfImageFormat.Bgrx8888:  	TransformBytes (buffer' br' width' height' 4' -1' 2' 1' 0' false);  	break;  case VtfImageFormat.Bgr565:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Bgrx5551:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Bgra4444:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Bgra5551:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Uv88:  	TransformBytes (buffer' br' width' height' 2' -1' 0' 1' -1' false);  	break;  case VtfImageFormat.Uvwq8888:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgba16161616F:  	TransformRgba16161616F (buffer' br' width' height);  	break;  case VtfImageFormat.Rgba16161616:  	TransformShorts (buffer' br' width' height' 8' 3' 0' 1' 2);  	break;  case VtfImageFormat.Uvlx8888:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.R32F:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgb323232F:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgba32323232F:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvDst16:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvDst24:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvIntz:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvRawz:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.AtiDst16:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.AtiDst24:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvNull:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Ati2N:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Ati1N:  	throw new NotImplementedException ();  	break;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,LoadImage,The following statement contains a magic number: switch (format) {  case VtfImageFormat.Rgba8888:  	TransformBytes (buffer' br' width' height' 4' 3' 0' 1' 2' false);  	break;  case VtfImageFormat.Abgr8888:  	TransformBytes (buffer' br' width' height' 4' 0' 3' 2' 1' false);  	break;  case VtfImageFormat.Rgb888:  	TransformBytes (buffer' br' width' height' 3' -1' 0' 1' 2' false);  	break;  case VtfImageFormat.Bgr888:  	TransformBytes (buffer' br' width' height' 3' -1' 2' 1' 0' false);  	break;  case VtfImageFormat.Rgb565:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.I8:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Ia88:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.P8:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.A8:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgb888Bluescreen:  	TransformBytes (buffer' br' width' height' 3' -1' 0' 1' 2' true);  	break;  case VtfImageFormat.Bgr888Bluescreen:  	TransformBytes (buffer' br' width' height' 3' -1' 2' 1' 0' true);  	break;  case VtfImageFormat.Argb8888:  	TransformBytes (buffer' br' width' height' 4' 0' 1' 2' 3' false);  	break;  case VtfImageFormat.Bgra8888:  	br.Read (buffer' 0' buffer.Length);  	break;  case VtfImageFormat.Dxt1:  case VtfImageFormat.Dxt1Onebitalpha:  	DecompressDxt1 (buffer' br' width' height);  	break;  case VtfImageFormat.Dxt3:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Dxt5:  	DecompressDxt5 (buffer' br' width' height);  	break;  case VtfImageFormat.Bgrx8888:  	TransformBytes (buffer' br' width' height' 4' -1' 2' 1' 0' false);  	break;  case VtfImageFormat.Bgr565:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Bgrx5551:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Bgra4444:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Bgra5551:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Uv88:  	TransformBytes (buffer' br' width' height' 2' -1' 0' 1' -1' false);  	break;  case VtfImageFormat.Uvwq8888:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgba16161616F:  	TransformRgba16161616F (buffer' br' width' height);  	break;  case VtfImageFormat.Rgba16161616:  	TransformShorts (buffer' br' width' height' 8' 3' 0' 1' 2);  	break;  case VtfImageFormat.Uvlx8888:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.R32F:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgb323232F:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgba32323232F:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvDst16:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvDst24:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvIntz:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvRawz:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.AtiDst16:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.AtiDst24:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvNull:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Ati2N:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Ati1N:  	throw new NotImplementedException ();  	break;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,LoadImage,The following statement contains a magic number: switch (format) {  case VtfImageFormat.Rgba8888:  	TransformBytes (buffer' br' width' height' 4' 3' 0' 1' 2' false);  	break;  case VtfImageFormat.Abgr8888:  	TransformBytes (buffer' br' width' height' 4' 0' 3' 2' 1' false);  	break;  case VtfImageFormat.Rgb888:  	TransformBytes (buffer' br' width' height' 3' -1' 0' 1' 2' false);  	break;  case VtfImageFormat.Bgr888:  	TransformBytes (buffer' br' width' height' 3' -1' 2' 1' 0' false);  	break;  case VtfImageFormat.Rgb565:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.I8:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Ia88:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.P8:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.A8:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgb888Bluescreen:  	TransformBytes (buffer' br' width' height' 3' -1' 0' 1' 2' true);  	break;  case VtfImageFormat.Bgr888Bluescreen:  	TransformBytes (buffer' br' width' height' 3' -1' 2' 1' 0' true);  	break;  case VtfImageFormat.Argb8888:  	TransformBytes (buffer' br' width' height' 4' 0' 1' 2' 3' false);  	break;  case VtfImageFormat.Bgra8888:  	br.Read (buffer' 0' buffer.Length);  	break;  case VtfImageFormat.Dxt1:  case VtfImageFormat.Dxt1Onebitalpha:  	DecompressDxt1 (buffer' br' width' height);  	break;  case VtfImageFormat.Dxt3:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Dxt5:  	DecompressDxt5 (buffer' br' width' height);  	break;  case VtfImageFormat.Bgrx8888:  	TransformBytes (buffer' br' width' height' 4' -1' 2' 1' 0' false);  	break;  case VtfImageFormat.Bgr565:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Bgrx5551:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Bgra4444:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Bgra5551:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Uv88:  	TransformBytes (buffer' br' width' height' 2' -1' 0' 1' -1' false);  	break;  case VtfImageFormat.Uvwq8888:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgba16161616F:  	TransformRgba16161616F (buffer' br' width' height);  	break;  case VtfImageFormat.Rgba16161616:  	TransformShorts (buffer' br' width' height' 8' 3' 0' 1' 2);  	break;  case VtfImageFormat.Uvlx8888:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.R32F:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgb323232F:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgba32323232F:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvDst16:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvDst24:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvIntz:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvRawz:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.AtiDst16:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.AtiDst24:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvNull:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Ati2N:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Ati1N:  	throw new NotImplementedException ();  	break;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,LoadImage,The following statement contains a magic number: switch (format) {  case VtfImageFormat.Rgba8888:  	TransformBytes (buffer' br' width' height' 4' 3' 0' 1' 2' false);  	break;  case VtfImageFormat.Abgr8888:  	TransformBytes (buffer' br' width' height' 4' 0' 3' 2' 1' false);  	break;  case VtfImageFormat.Rgb888:  	TransformBytes (buffer' br' width' height' 3' -1' 0' 1' 2' false);  	break;  case VtfImageFormat.Bgr888:  	TransformBytes (buffer' br' width' height' 3' -1' 2' 1' 0' false);  	break;  case VtfImageFormat.Rgb565:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.I8:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Ia88:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.P8:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.A8:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgb888Bluescreen:  	TransformBytes (buffer' br' width' height' 3' -1' 0' 1' 2' true);  	break;  case VtfImageFormat.Bgr888Bluescreen:  	TransformBytes (buffer' br' width' height' 3' -1' 2' 1' 0' true);  	break;  case VtfImageFormat.Argb8888:  	TransformBytes (buffer' br' width' height' 4' 0' 1' 2' 3' false);  	break;  case VtfImageFormat.Bgra8888:  	br.Read (buffer' 0' buffer.Length);  	break;  case VtfImageFormat.Dxt1:  case VtfImageFormat.Dxt1Onebitalpha:  	DecompressDxt1 (buffer' br' width' height);  	break;  case VtfImageFormat.Dxt3:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Dxt5:  	DecompressDxt5 (buffer' br' width' height);  	break;  case VtfImageFormat.Bgrx8888:  	TransformBytes (buffer' br' width' height' 4' -1' 2' 1' 0' false);  	break;  case VtfImageFormat.Bgr565:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Bgrx5551:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Bgra4444:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Bgra5551:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Uv88:  	TransformBytes (buffer' br' width' height' 2' -1' 0' 1' -1' false);  	break;  case VtfImageFormat.Uvwq8888:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgba16161616F:  	TransformRgba16161616F (buffer' br' width' height);  	break;  case VtfImageFormat.Rgba16161616:  	TransformShorts (buffer' br' width' height' 8' 3' 0' 1' 2);  	break;  case VtfImageFormat.Uvlx8888:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.R32F:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgb323232F:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgba32323232F:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvDst16:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvDst24:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvIntz:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvRawz:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.AtiDst16:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.AtiDst24:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvNull:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Ati2N:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Ati1N:  	throw new NotImplementedException ();  	break;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,LoadImage,The following statement contains a magic number: TransformBytes (buffer' br' width' height' 4' 3' 0' 1' 2' false);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,LoadImage,The following statement contains a magic number: TransformBytes (buffer' br' width' height' 4' 3' 0' 1' 2' false);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,LoadImage,The following statement contains a magic number: TransformBytes (buffer' br' width' height' 4' 3' 0' 1' 2' false);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,LoadImage,The following statement contains a magic number: TransformBytes (buffer' br' width' height' 4' 0' 3' 2' 1' false);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,LoadImage,The following statement contains a magic number: TransformBytes (buffer' br' width' height' 4' 0' 3' 2' 1' false);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,LoadImage,The following statement contains a magic number: TransformBytes (buffer' br' width' height' 4' 0' 3' 2' 1' false);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,LoadImage,The following statement contains a magic number: TransformBytes (buffer' br' width' height' 3' -1' 0' 1' 2' false);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,LoadImage,The following statement contains a magic number: TransformBytes (buffer' br' width' height' 3' -1' 0' 1' 2' false);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,LoadImage,The following statement contains a magic number: TransformBytes (buffer' br' width' height' 3' -1' 2' 1' 0' false);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,LoadImage,The following statement contains a magic number: TransformBytes (buffer' br' width' height' 3' -1' 2' 1' 0' false);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,LoadImage,The following statement contains a magic number: TransformBytes (buffer' br' width' height' 3' -1' 0' 1' 2' true);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,LoadImage,The following statement contains a magic number: TransformBytes (buffer' br' width' height' 3' -1' 0' 1' 2' true);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,LoadImage,The following statement contains a magic number: TransformBytes (buffer' br' width' height' 3' -1' 2' 1' 0' true);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,LoadImage,The following statement contains a magic number: TransformBytes (buffer' br' width' height' 3' -1' 2' 1' 0' true);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,LoadImage,The following statement contains a magic number: TransformBytes (buffer' br' width' height' 4' 0' 1' 2' 3' false);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,LoadImage,The following statement contains a magic number: TransformBytes (buffer' br' width' height' 4' 0' 1' 2' 3' false);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,LoadImage,The following statement contains a magic number: TransformBytes (buffer' br' width' height' 4' 0' 1' 2' 3' false);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,LoadImage,The following statement contains a magic number: TransformBytes (buffer' br' width' height' 4' -1' 2' 1' 0' false);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,LoadImage,The following statement contains a magic number: TransformBytes (buffer' br' width' height' 4' -1' 2' 1' 0' false);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,LoadImage,The following statement contains a magic number: TransformBytes (buffer' br' width' height' 2' -1' 0' 1' -1' false);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,LoadImage,The following statement contains a magic number: TransformShorts (buffer' br' width' height' 8' 3' 0' 1' 2);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,LoadImage,The following statement contains a magic number: TransformShorts (buffer' br' width' height' 8' 3' 0' 1' 2);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,LoadImage,The following statement contains a magic number: TransformShorts (buffer' br' width' height' 8' 3' 0' 1' 2);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		if (c0 > c1) {  			// No alpha channel  			c [8] = (byte)((2 * c [0] + c [4]) / 3);  			c [9] = (byte)((2 * c [1] + c [5]) / 3);  			c [10] = (byte)((2 * c [2] + c [6]) / 3);  			c [11] = 255;  			c [12] = (byte)((c [0] + 2 * c [4]) / 3);  			c [13] = (byte)((c [1] + 2 * c [5]) / 3);  			c [14] = (byte)((c [2] + 2 * c [6]) / 3);  			c [15] = 255;  		} else {  			// 1-bit alpha channel  			c [8] = (byte)((c [0] + c [4]) / 2);  			c [9] = (byte)((c [1] + c [5]) / 2);  			c [10] = (byte)((c [2] + c [6]) / 2);  			c [11] = 255;  			c [12] = 0;  			c [13] = 0;  			c [14] = 0;  			c [15] = 0;  		}  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = c [index + 3];  					// a  				}  				bytes >>= 2;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: y += 4
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	if (c0 > c1) {  		// No alpha channel  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  	} else {  		// 1-bit alpha channel  		c [8] = (byte)((c [0] + c [4]) / 2);  		c [9] = (byte)((c [1] + c [5]) / 2);  		c [10] = (byte)((c [2] + c [6]) / 2);  		c [11] = 255;  		c [12] = 0;  		c [13] = 0;  		c [14] = 0;  		c [15] = 0;  	}  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = c [index + 3];  				// a  			}  			bytes >>= 2;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: x += 4
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: c0 |= all [pos++] << 8;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: c1 |= all [pos++] << 8;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: c [0] = (byte)((c0 & 0xF800) >> 8);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: c [1] = (byte)((c0 & 0x07E0) >> 3);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: c [2] = (byte)((c0 & 0x001F) << 3);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: c [2] = (byte)((c0 & 0x001F) << 3);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: c [3] = 255;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: c [3] = 255;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: c [4] = (byte)((c1 & 0xF800) >> 8);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: c [4] = (byte)((c1 & 0xF800) >> 8);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: c [5] = (byte)((c1 & 0x07E0) >> 3);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: c [5] = (byte)((c1 & 0x07E0) >> 3);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: c [6] = (byte)((c1 & 0x001F) << 3);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: c [6] = (byte)((c1 & 0x001F) << 3);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: c [7] = 255;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: c [7] = 255;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: if (c0 > c1) {  	// No alpha channel  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  } else {  	// 1-bit alpha channel  	c [8] = (byte)((c [0] + c [4]) / 2);  	c [9] = (byte)((c [1] + c [5]) / 2);  	c [10] = (byte)((c [2] + c [6]) / 2);  	c [11] = 255;  	c [12] = 0;  	c [13] = 0;  	c [14] = 0;  	c [15] = 0;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: if (c0 > c1) {  	// No alpha channel  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  } else {  	// 1-bit alpha channel  	c [8] = (byte)((c [0] + c [4]) / 2);  	c [9] = (byte)((c [1] + c [5]) / 2);  	c [10] = (byte)((c [2] + c [6]) / 2);  	c [11] = 255;  	c [12] = 0;  	c [13] = 0;  	c [14] = 0;  	c [15] = 0;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: if (c0 > c1) {  	// No alpha channel  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  } else {  	// 1-bit alpha channel  	c [8] = (byte)((c [0] + c [4]) / 2);  	c [9] = (byte)((c [1] + c [5]) / 2);  	c [10] = (byte)((c [2] + c [6]) / 2);  	c [11] = 255;  	c [12] = 0;  	c [13] = 0;  	c [14] = 0;  	c [15] = 0;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: if (c0 > c1) {  	// No alpha channel  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  } else {  	// 1-bit alpha channel  	c [8] = (byte)((c [0] + c [4]) / 2);  	c [9] = (byte)((c [1] + c [5]) / 2);  	c [10] = (byte)((c [2] + c [6]) / 2);  	c [11] = 255;  	c [12] = 0;  	c [13] = 0;  	c [14] = 0;  	c [15] = 0;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: if (c0 > c1) {  	// No alpha channel  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  } else {  	// 1-bit alpha channel  	c [8] = (byte)((c [0] + c [4]) / 2);  	c [9] = (byte)((c [1] + c [5]) / 2);  	c [10] = (byte)((c [2] + c [6]) / 2);  	c [11] = 255;  	c [12] = 0;  	c [13] = 0;  	c [14] = 0;  	c [15] = 0;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: if (c0 > c1) {  	// No alpha channel  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  } else {  	// 1-bit alpha channel  	c [8] = (byte)((c [0] + c [4]) / 2);  	c [9] = (byte)((c [1] + c [5]) / 2);  	c [10] = (byte)((c [2] + c [6]) / 2);  	c [11] = 255;  	c [12] = 0;  	c [13] = 0;  	c [14] = 0;  	c [15] = 0;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: if (c0 > c1) {  	// No alpha channel  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  } else {  	// 1-bit alpha channel  	c [8] = (byte)((c [0] + c [4]) / 2);  	c [9] = (byte)((c [1] + c [5]) / 2);  	c [10] = (byte)((c [2] + c [6]) / 2);  	c [11] = 255;  	c [12] = 0;  	c [13] = 0;  	c [14] = 0;  	c [15] = 0;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: if (c0 > c1) {  	// No alpha channel  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  } else {  	// 1-bit alpha channel  	c [8] = (byte)((c [0] + c [4]) / 2);  	c [9] = (byte)((c [1] + c [5]) / 2);  	c [10] = (byte)((c [2] + c [6]) / 2);  	c [11] = 255;  	c [12] = 0;  	c [13] = 0;  	c [14] = 0;  	c [15] = 0;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: if (c0 > c1) {  	// No alpha channel  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  } else {  	// 1-bit alpha channel  	c [8] = (byte)((c [0] + c [4]) / 2);  	c [9] = (byte)((c [1] + c [5]) / 2);  	c [10] = (byte)((c [2] + c [6]) / 2);  	c [11] = 255;  	c [12] = 0;  	c [13] = 0;  	c [14] = 0;  	c [15] = 0;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: if (c0 > c1) {  	// No alpha channel  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  } else {  	// 1-bit alpha channel  	c [8] = (byte)((c [0] + c [4]) / 2);  	c [9] = (byte)((c [1] + c [5]) / 2);  	c [10] = (byte)((c [2] + c [6]) / 2);  	c [11] = 255;  	c [12] = 0;  	c [13] = 0;  	c [14] = 0;  	c [15] = 0;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: if (c0 > c1) {  	// No alpha channel  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  } else {  	// 1-bit alpha channel  	c [8] = (byte)((c [0] + c [4]) / 2);  	c [9] = (byte)((c [1] + c [5]) / 2);  	c [10] = (byte)((c [2] + c [6]) / 2);  	c [11] = 255;  	c [12] = 0;  	c [13] = 0;  	c [14] = 0;  	c [15] = 0;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: if (c0 > c1) {  	// No alpha channel  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  } else {  	// 1-bit alpha channel  	c [8] = (byte)((c [0] + c [4]) / 2);  	c [9] = (byte)((c [1] + c [5]) / 2);  	c [10] = (byte)((c [2] + c [6]) / 2);  	c [11] = 255;  	c [12] = 0;  	c [13] = 0;  	c [14] = 0;  	c [15] = 0;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: if (c0 > c1) {  	// No alpha channel  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  } else {  	// 1-bit alpha channel  	c [8] = (byte)((c [0] + c [4]) / 2);  	c [9] = (byte)((c [1] + c [5]) / 2);  	c [10] = (byte)((c [2] + c [6]) / 2);  	c [11] = 255;  	c [12] = 0;  	c [13] = 0;  	c [14] = 0;  	c [15] = 0;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: if (c0 > c1) {  	// No alpha channel  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  } else {  	// 1-bit alpha channel  	c [8] = (byte)((c [0] + c [4]) / 2);  	c [9] = (byte)((c [1] + c [5]) / 2);  	c [10] = (byte)((c [2] + c [6]) / 2);  	c [11] = 255;  	c [12] = 0;  	c [13] = 0;  	c [14] = 0;  	c [15] = 0;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: if (c0 > c1) {  	// No alpha channel  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  } else {  	// 1-bit alpha channel  	c [8] = (byte)((c [0] + c [4]) / 2);  	c [9] = (byte)((c [1] + c [5]) / 2);  	c [10] = (byte)((c [2] + c [6]) / 2);  	c [11] = 255;  	c [12] = 0;  	c [13] = 0;  	c [14] = 0;  	c [15] = 0;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: if (c0 > c1) {  	// No alpha channel  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  } else {  	// 1-bit alpha channel  	c [8] = (byte)((c [0] + c [4]) / 2);  	c [9] = (byte)((c [1] + c [5]) / 2);  	c [10] = (byte)((c [2] + c [6]) / 2);  	c [11] = 255;  	c [12] = 0;  	c [13] = 0;  	c [14] = 0;  	c [15] = 0;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: if (c0 > c1) {  	// No alpha channel  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  } else {  	// 1-bit alpha channel  	c [8] = (byte)((c [0] + c [4]) / 2);  	c [9] = (byte)((c [1] + c [5]) / 2);  	c [10] = (byte)((c [2] + c [6]) / 2);  	c [11] = 255;  	c [12] = 0;  	c [13] = 0;  	c [14] = 0;  	c [15] = 0;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: if (c0 > c1) {  	// No alpha channel  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  } else {  	// 1-bit alpha channel  	c [8] = (byte)((c [0] + c [4]) / 2);  	c [9] = (byte)((c [1] + c [5]) / 2);  	c [10] = (byte)((c [2] + c [6]) / 2);  	c [11] = 255;  	c [12] = 0;  	c [13] = 0;  	c [14] = 0;  	c [15] = 0;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: if (c0 > c1) {  	// No alpha channel  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  } else {  	// 1-bit alpha channel  	c [8] = (byte)((c [0] + c [4]) / 2);  	c [9] = (byte)((c [1] + c [5]) / 2);  	c [10] = (byte)((c [2] + c [6]) / 2);  	c [11] = 255;  	c [12] = 0;  	c [13] = 0;  	c [14] = 0;  	c [15] = 0;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: if (c0 > c1) {  	// No alpha channel  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  } else {  	// 1-bit alpha channel  	c [8] = (byte)((c [0] + c [4]) / 2);  	c [9] = (byte)((c [1] + c [5]) / 2);  	c [10] = (byte)((c [2] + c [6]) / 2);  	c [11] = 255;  	c [12] = 0;  	c [13] = 0;  	c [14] = 0;  	c [15] = 0;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: if (c0 > c1) {  	// No alpha channel  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  } else {  	// 1-bit alpha channel  	c [8] = (byte)((c [0] + c [4]) / 2);  	c [9] = (byte)((c [1] + c [5]) / 2);  	c [10] = (byte)((c [2] + c [6]) / 2);  	c [11] = 255;  	c [12] = 0;  	c [13] = 0;  	c [14] = 0;  	c [15] = 0;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: if (c0 > c1) {  	// No alpha channel  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  } else {  	// 1-bit alpha channel  	c [8] = (byte)((c [0] + c [4]) / 2);  	c [9] = (byte)((c [1] + c [5]) / 2);  	c [10] = (byte)((c [2] + c [6]) / 2);  	c [11] = 255;  	c [12] = 0;  	c [13] = 0;  	c [14] = 0;  	c [15] = 0;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: if (c0 > c1) {  	// No alpha channel  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  } else {  	// 1-bit alpha channel  	c [8] = (byte)((c [0] + c [4]) / 2);  	c [9] = (byte)((c [1] + c [5]) / 2);  	c [10] = (byte)((c [2] + c [6]) / 2);  	c [11] = 255;  	c [12] = 0;  	c [13] = 0;  	c [14] = 0;  	c [15] = 0;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: if (c0 > c1) {  	// No alpha channel  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  } else {  	// 1-bit alpha channel  	c [8] = (byte)((c [0] + c [4]) / 2);  	c [9] = (byte)((c [1] + c [5]) / 2);  	c [10] = (byte)((c [2] + c [6]) / 2);  	c [11] = 255;  	c [12] = 0;  	c [13] = 0;  	c [14] = 0;  	c [15] = 0;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: if (c0 > c1) {  	// No alpha channel  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  } else {  	// 1-bit alpha channel  	c [8] = (byte)((c [0] + c [4]) / 2);  	c [9] = (byte)((c [1] + c [5]) / 2);  	c [10] = (byte)((c [2] + c [6]) / 2);  	c [11] = 255;  	c [12] = 0;  	c [13] = 0;  	c [14] = 0;  	c [15] = 0;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: if (c0 > c1) {  	// No alpha channel  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  } else {  	// 1-bit alpha channel  	c [8] = (byte)((c [0] + c [4]) / 2);  	c [9] = (byte)((c [1] + c [5]) / 2);  	c [10] = (byte)((c [2] + c [6]) / 2);  	c [11] = 255;  	c [12] = 0;  	c [13] = 0;  	c [14] = 0;  	c [15] = 0;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: if (c0 > c1) {  	// No alpha channel  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  } else {  	// 1-bit alpha channel  	c [8] = (byte)((c [0] + c [4]) / 2);  	c [9] = (byte)((c [1] + c [5]) / 2);  	c [10] = (byte)((c [2] + c [6]) / 2);  	c [11] = 255;  	c [12] = 0;  	c [13] = 0;  	c [14] = 0;  	c [15] = 0;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: if (c0 > c1) {  	// No alpha channel  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  } else {  	// 1-bit alpha channel  	c [8] = (byte)((c [0] + c [4]) / 2);  	c [9] = (byte)((c [1] + c [5]) / 2);  	c [10] = (byte)((c [2] + c [6]) / 2);  	c [11] = 255;  	c [12] = 0;  	c [13] = 0;  	c [14] = 0;  	c [15] = 0;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: if (c0 > c1) {  	// No alpha channel  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  } else {  	// 1-bit alpha channel  	c [8] = (byte)((c [0] + c [4]) / 2);  	c [9] = (byte)((c [1] + c [5]) / 2);  	c [10] = (byte)((c [2] + c [6]) / 2);  	c [11] = 255;  	c [12] = 0;  	c [13] = 0;  	c [14] = 0;  	c [15] = 0;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: if (c0 > c1) {  	// No alpha channel  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  } else {  	// 1-bit alpha channel  	c [8] = (byte)((c [0] + c [4]) / 2);  	c [9] = (byte)((c [1] + c [5]) / 2);  	c [10] = (byte)((c [2] + c [6]) / 2);  	c [11] = 255;  	c [12] = 0;  	c [13] = 0;  	c [14] = 0;  	c [15] = 0;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: if (c0 > c1) {  	// No alpha channel  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  } else {  	// 1-bit alpha channel  	c [8] = (byte)((c [0] + c [4]) / 2);  	c [9] = (byte)((c [1] + c [5]) / 2);  	c [10] = (byte)((c [2] + c [6]) / 2);  	c [11] = 255;  	c [12] = 0;  	c [13] = 0;  	c [14] = 0;  	c [15] = 0;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: if (c0 > c1) {  	// No alpha channel  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  } else {  	// 1-bit alpha channel  	c [8] = (byte)((c [0] + c [4]) / 2);  	c [9] = (byte)((c [1] + c [5]) / 2);  	c [10] = (byte)((c [2] + c [6]) / 2);  	c [11] = 255;  	c [12] = 0;  	c [13] = 0;  	c [14] = 0;  	c [15] = 0;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: if (c0 > c1) {  	// No alpha channel  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  } else {  	// 1-bit alpha channel  	c [8] = (byte)((c [0] + c [4]) / 2);  	c [9] = (byte)((c [1] + c [5]) / 2);  	c [10] = (byte)((c [2] + c [6]) / 2);  	c [11] = 255;  	c [12] = 0;  	c [13] = 0;  	c [14] = 0;  	c [15] = 0;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: if (c0 > c1) {  	// No alpha channel  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  } else {  	// 1-bit alpha channel  	c [8] = (byte)((c [0] + c [4]) / 2);  	c [9] = (byte)((c [1] + c [5]) / 2);  	c [10] = (byte)((c [2] + c [6]) / 2);  	c [11] = 255;  	c [12] = 0;  	c [13] = 0;  	c [14] = 0;  	c [15] = 0;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: if (c0 > c1) {  	// No alpha channel  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  } else {  	// 1-bit alpha channel  	c [8] = (byte)((c [0] + c [4]) / 2);  	c [9] = (byte)((c [1] + c [5]) / 2);  	c [10] = (byte)((c [2] + c [6]) / 2);  	c [11] = 255;  	c [12] = 0;  	c [13] = 0;  	c [14] = 0;  	c [15] = 0;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: if (c0 > c1) {  	// No alpha channel  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  } else {  	// 1-bit alpha channel  	c [8] = (byte)((c [0] + c [4]) / 2);  	c [9] = (byte)((c [1] + c [5]) / 2);  	c [10] = (byte)((c [2] + c [6]) / 2);  	c [11] = 255;  	c [12] = 0;  	c [13] = 0;  	c [14] = 0;  	c [15] = 0;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: if (c0 > c1) {  	// No alpha channel  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  } else {  	// 1-bit alpha channel  	c [8] = (byte)((c [0] + c [4]) / 2);  	c [9] = (byte)((c [1] + c [5]) / 2);  	c [10] = (byte)((c [2] + c [6]) / 2);  	c [11] = 255;  	c [12] = 0;  	c [13] = 0;  	c [14] = 0;  	c [15] = 0;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: if (c0 > c1) {  	// No alpha channel  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  } else {  	// 1-bit alpha channel  	c [8] = (byte)((c [0] + c [4]) / 2);  	c [9] = (byte)((c [1] + c [5]) / 2);  	c [10] = (byte)((c [2] + c [6]) / 2);  	c [11] = 255;  	c [12] = 0;  	c [13] = 0;  	c [14] = 0;  	c [15] = 0;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: if (c0 > c1) {  	// No alpha channel  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  } else {  	// 1-bit alpha channel  	c [8] = (byte)((c [0] + c [4]) / 2);  	c [9] = (byte)((c [1] + c [5]) / 2);  	c [10] = (byte)((c [2] + c [6]) / 2);  	c [11] = 255;  	c [12] = 0;  	c [13] = 0;  	c [14] = 0;  	c [15] = 0;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: if (c0 > c1) {  	// No alpha channel  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  } else {  	// 1-bit alpha channel  	c [8] = (byte)((c [0] + c [4]) / 2);  	c [9] = (byte)((c [1] + c [5]) / 2);  	c [10] = (byte)((c [2] + c [6]) / 2);  	c [11] = 255;  	c [12] = 0;  	c [13] = 0;  	c [14] = 0;  	c [15] = 0;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: if (c0 > c1) {  	// No alpha channel  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  } else {  	// 1-bit alpha channel  	c [8] = (byte)((c [0] + c [4]) / 2);  	c [9] = (byte)((c [1] + c [5]) / 2);  	c [10] = (byte)((c [2] + c [6]) / 2);  	c [11] = 255;  	c [12] = 0;  	c [13] = 0;  	c [14] = 0;  	c [15] = 0;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: if (c0 > c1) {  	// No alpha channel  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  } else {  	// 1-bit alpha channel  	c [8] = (byte)((c [0] + c [4]) / 2);  	c [9] = (byte)((c [1] + c [5]) / 2);  	c [10] = (byte)((c [2] + c [6]) / 2);  	c [11] = 255;  	c [12] = 0;  	c [13] = 0;  	c [14] = 0;  	c [15] = 0;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: if (c0 > c1) {  	// No alpha channel  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  } else {  	// 1-bit alpha channel  	c [8] = (byte)((c [0] + c [4]) / 2);  	c [9] = (byte)((c [1] + c [5]) / 2);  	c [10] = (byte)((c [2] + c [6]) / 2);  	c [11] = 255;  	c [12] = 0;  	c [13] = 0;  	c [14] = 0;  	c [15] = 0;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: if (c0 > c1) {  	// No alpha channel  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  } else {  	// 1-bit alpha channel  	c [8] = (byte)((c [0] + c [4]) / 2);  	c [9] = (byte)((c [1] + c [5]) / 2);  	c [10] = (byte)((c [2] + c [6]) / 2);  	c [11] = 255;  	c [12] = 0;  	c [13] = 0;  	c [14] = 0;  	c [15] = 0;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: if (c0 > c1) {  	// No alpha channel  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  } else {  	// 1-bit alpha channel  	c [8] = (byte)((c [0] + c [4]) / 2);  	c [9] = (byte)((c [1] + c [5]) / 2);  	c [10] = (byte)((c [2] + c [6]) / 2);  	c [11] = 255;  	c [12] = 0;  	c [13] = 0;  	c [14] = 0;  	c [15] = 0;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: if (c0 > c1) {  	// No alpha channel  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  } else {  	// 1-bit alpha channel  	c [8] = (byte)((c [0] + c [4]) / 2);  	c [9] = (byte)((c [1] + c [5]) / 2);  	c [10] = (byte)((c [2] + c [6]) / 2);  	c [11] = 255;  	c [12] = 0;  	c [13] = 0;  	c [14] = 0;  	c [15] = 0;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: c [8] = (byte)((2 * c [0] + c [4]) / 3);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: c [8] = (byte)((2 * c [0] + c [4]) / 3);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: c [8] = (byte)((2 * c [0] + c [4]) / 3);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: c [8] = (byte)((2 * c [0] + c [4]) / 3);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: c [9] = (byte)((2 * c [1] + c [5]) / 3);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: c [9] = (byte)((2 * c [1] + c [5]) / 3);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: c [9] = (byte)((2 * c [1] + c [5]) / 3);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: c [9] = (byte)((2 * c [1] + c [5]) / 3);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: c [10] = (byte)((2 * c [2] + c [6]) / 3);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: c [10] = (byte)((2 * c [2] + c [6]) / 3);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: c [10] = (byte)((2 * c [2] + c [6]) / 3);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: c [10] = (byte)((2 * c [2] + c [6]) / 3);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: c [10] = (byte)((2 * c [2] + c [6]) / 3);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: c [11] = 255;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: c [11] = 255;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: c [12] = (byte)((c [0] + 2 * c [4]) / 3);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: c [12] = (byte)((c [0] + 2 * c [4]) / 3);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: c [12] = (byte)((c [0] + 2 * c [4]) / 3);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: c [12] = (byte)((c [0] + 2 * c [4]) / 3);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: c [13] = (byte)((c [1] + 2 * c [5]) / 3);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: c [13] = (byte)((c [1] + 2 * c [5]) / 3);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: c [13] = (byte)((c [1] + 2 * c [5]) / 3);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: c [13] = (byte)((c [1] + 2 * c [5]) / 3);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: c [14] = (byte)((c [2] + 2 * c [6]) / 3);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: c [14] = (byte)((c [2] + 2 * c [6]) / 3);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: c [14] = (byte)((c [2] + 2 * c [6]) / 3);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: c [14] = (byte)((c [2] + 2 * c [6]) / 3);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: c [14] = (byte)((c [2] + 2 * c [6]) / 3);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: c [15] = 255;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: c [15] = 255;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: c [8] = (byte)((c [0] + c [4]) / 2);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: c [8] = (byte)((c [0] + c [4]) / 2);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: c [8] = (byte)((c [0] + c [4]) / 2);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: c [9] = (byte)((c [1] + c [5]) / 2);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: c [9] = (byte)((c [1] + c [5]) / 2);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: c [9] = (byte)((c [1] + c [5]) / 2);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: c [10] = (byte)((c [2] + c [6]) / 2);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: c [10] = (byte)((c [2] + c [6]) / 2);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: c [10] = (byte)((c [2] + c [6]) / 2);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: c [10] = (byte)((c [2] + c [6]) / 2);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: c [11] = 255;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: c [11] = 255;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: c [12] = 0;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: c [13] = 0;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: c [14] = 0;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: c [15] = 0;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: bytes |= all [pos++] << 8;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: bytes |= all [pos++] << 16;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: bytes |= all [pos++] << 24;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var yy = 0; yy < 4; yy++) {  	for (var xx = 0; xx < 4; xx++) {  		var xpos = x + xx;  		var ypos = y + yy;  		if (xpos < width && ypos < height) {  			var index = bytes & 0x0003;  			index *= 4;  			var pointer = ypos * width * 4 + xpos * 4;  			buffer [pointer + 0] = c [index + 2];  			// b  			buffer [pointer + 1] = c [index + 1];  			// g  			buffer [pointer + 2] = c [index + 0];  			// r  			buffer [pointer + 3] = c [index + 3];  			// a  		}  		bytes >>= 2;  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var yy = 0; yy < 4; yy++) {  	for (var xx = 0; xx < 4; xx++) {  		var xpos = x + xx;  		var ypos = y + yy;  		if (xpos < width && ypos < height) {  			var index = bytes & 0x0003;  			index *= 4;  			var pointer = ypos * width * 4 + xpos * 4;  			buffer [pointer + 0] = c [index + 2];  			// b  			buffer [pointer + 1] = c [index + 1];  			// g  			buffer [pointer + 2] = c [index + 0];  			// r  			buffer [pointer + 3] = c [index + 3];  			// a  		}  		bytes >>= 2;  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var yy = 0; yy < 4; yy++) {  	for (var xx = 0; xx < 4; xx++) {  		var xpos = x + xx;  		var ypos = y + yy;  		if (xpos < width && ypos < height) {  			var index = bytes & 0x0003;  			index *= 4;  			var pointer = ypos * width * 4 + xpos * 4;  			buffer [pointer + 0] = c [index + 2];  			// b  			buffer [pointer + 1] = c [index + 1];  			// g  			buffer [pointer + 2] = c [index + 0];  			// r  			buffer [pointer + 3] = c [index + 3];  			// a  		}  		bytes >>= 2;  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var yy = 0; yy < 4; yy++) {  	for (var xx = 0; xx < 4; xx++) {  		var xpos = x + xx;  		var ypos = y + yy;  		if (xpos < width && ypos < height) {  			var index = bytes & 0x0003;  			index *= 4;  			var pointer = ypos * width * 4 + xpos * 4;  			buffer [pointer + 0] = c [index + 2];  			// b  			buffer [pointer + 1] = c [index + 1];  			// g  			buffer [pointer + 2] = c [index + 0];  			// r  			buffer [pointer + 3] = c [index + 3];  			// a  		}  		bytes >>= 2;  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var yy = 0; yy < 4; yy++) {  	for (var xx = 0; xx < 4; xx++) {  		var xpos = x + xx;  		var ypos = y + yy;  		if (xpos < width && ypos < height) {  			var index = bytes & 0x0003;  			index *= 4;  			var pointer = ypos * width * 4 + xpos * 4;  			buffer [pointer + 0] = c [index + 2];  			// b  			buffer [pointer + 1] = c [index + 1];  			// g  			buffer [pointer + 2] = c [index + 0];  			// r  			buffer [pointer + 3] = c [index + 3];  			// a  		}  		bytes >>= 2;  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var yy = 0; yy < 4; yy++) {  	for (var xx = 0; xx < 4; xx++) {  		var xpos = x + xx;  		var ypos = y + yy;  		if (xpos < width && ypos < height) {  			var index = bytes & 0x0003;  			index *= 4;  			var pointer = ypos * width * 4 + xpos * 4;  			buffer [pointer + 0] = c [index + 2];  			// b  			buffer [pointer + 1] = c [index + 1];  			// g  			buffer [pointer + 2] = c [index + 0];  			// r  			buffer [pointer + 3] = c [index + 3];  			// a  		}  		bytes >>= 2;  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var yy = 0; yy < 4; yy++) {  	for (var xx = 0; xx < 4; xx++) {  		var xpos = x + xx;  		var ypos = y + yy;  		if (xpos < width && ypos < height) {  			var index = bytes & 0x0003;  			index *= 4;  			var pointer = ypos * width * 4 + xpos * 4;  			buffer [pointer + 0] = c [index + 2];  			// b  			buffer [pointer + 1] = c [index + 1];  			// g  			buffer [pointer + 2] = c [index + 0];  			// r  			buffer [pointer + 3] = c [index + 3];  			// a  		}  		bytes >>= 2;  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var yy = 0; yy < 4; yy++) {  	for (var xx = 0; xx < 4; xx++) {  		var xpos = x + xx;  		var ypos = y + yy;  		if (xpos < width && ypos < height) {  			var index = bytes & 0x0003;  			index *= 4;  			var pointer = ypos * width * 4 + xpos * 4;  			buffer [pointer + 0] = c [index + 2];  			// b  			buffer [pointer + 1] = c [index + 1];  			// g  			buffer [pointer + 2] = c [index + 0];  			// r  			buffer [pointer + 3] = c [index + 3];  			// a  		}  		bytes >>= 2;  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var yy = 0; yy < 4; yy++) {  	for (var xx = 0; xx < 4; xx++) {  		var xpos = x + xx;  		var ypos = y + yy;  		if (xpos < width && ypos < height) {  			var index = bytes & 0x0003;  			index *= 4;  			var pointer = ypos * width * 4 + xpos * 4;  			buffer [pointer + 0] = c [index + 2];  			// b  			buffer [pointer + 1] = c [index + 1];  			// g  			buffer [pointer + 2] = c [index + 0];  			// r  			buffer [pointer + 3] = c [index + 3];  			// a  		}  		bytes >>= 2;  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var yy = 0; yy < 4; yy++) {  	for (var xx = 0; xx < 4; xx++) {  		var xpos = x + xx;  		var ypos = y + yy;  		if (xpos < width && ypos < height) {  			var index = bytes & 0x0003;  			index *= 4;  			var pointer = ypos * width * 4 + xpos * 4;  			buffer [pointer + 0] = c [index + 2];  			// b  			buffer [pointer + 1] = c [index + 1];  			// g  			buffer [pointer + 2] = c [index + 0];  			// r  			buffer [pointer + 3] = c [index + 3];  			// a  		}  		bytes >>= 2;  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var xx = 0; xx < 4; xx++) {  	var xpos = x + xx;  	var ypos = y + yy;  	if (xpos < width && ypos < height) {  		var index = bytes & 0x0003;  		index *= 4;  		var pointer = ypos * width * 4 + xpos * 4;  		buffer [pointer + 0] = c [index + 2];  		// b  		buffer [pointer + 1] = c [index + 1];  		// g  		buffer [pointer + 2] = c [index + 0];  		// r  		buffer [pointer + 3] = c [index + 3];  		// a  	}  	bytes >>= 2;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var xx = 0; xx < 4; xx++) {  	var xpos = x + xx;  	var ypos = y + yy;  	if (xpos < width && ypos < height) {  		var index = bytes & 0x0003;  		index *= 4;  		var pointer = ypos * width * 4 + xpos * 4;  		buffer [pointer + 0] = c [index + 2];  		// b  		buffer [pointer + 1] = c [index + 1];  		// g  		buffer [pointer + 2] = c [index + 0];  		// r  		buffer [pointer + 3] = c [index + 3];  		// a  	}  	bytes >>= 2;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var xx = 0; xx < 4; xx++) {  	var xpos = x + xx;  	var ypos = y + yy;  	if (xpos < width && ypos < height) {  		var index = bytes & 0x0003;  		index *= 4;  		var pointer = ypos * width * 4 + xpos * 4;  		buffer [pointer + 0] = c [index + 2];  		// b  		buffer [pointer + 1] = c [index + 1];  		// g  		buffer [pointer + 2] = c [index + 0];  		// r  		buffer [pointer + 3] = c [index + 3];  		// a  	}  	bytes >>= 2;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var xx = 0; xx < 4; xx++) {  	var xpos = x + xx;  	var ypos = y + yy;  	if (xpos < width && ypos < height) {  		var index = bytes & 0x0003;  		index *= 4;  		var pointer = ypos * width * 4 + xpos * 4;  		buffer [pointer + 0] = c [index + 2];  		// b  		buffer [pointer + 1] = c [index + 1];  		// g  		buffer [pointer + 2] = c [index + 0];  		// r  		buffer [pointer + 3] = c [index + 3];  		// a  	}  	bytes >>= 2;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var xx = 0; xx < 4; xx++) {  	var xpos = x + xx;  	var ypos = y + yy;  	if (xpos < width && ypos < height) {  		var index = bytes & 0x0003;  		index *= 4;  		var pointer = ypos * width * 4 + xpos * 4;  		buffer [pointer + 0] = c [index + 2];  		// b  		buffer [pointer + 1] = c [index + 1];  		// g  		buffer [pointer + 2] = c [index + 0];  		// r  		buffer [pointer + 3] = c [index + 3];  		// a  	}  	bytes >>= 2;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var xx = 0; xx < 4; xx++) {  	var xpos = x + xx;  	var ypos = y + yy;  	if (xpos < width && ypos < height) {  		var index = bytes & 0x0003;  		index *= 4;  		var pointer = ypos * width * 4 + xpos * 4;  		buffer [pointer + 0] = c [index + 2];  		// b  		buffer [pointer + 1] = c [index + 1];  		// g  		buffer [pointer + 2] = c [index + 0];  		// r  		buffer [pointer + 3] = c [index + 3];  		// a  	}  	bytes >>= 2;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var xx = 0; xx < 4; xx++) {  	var xpos = x + xx;  	var ypos = y + yy;  	if (xpos < width && ypos < height) {  		var index = bytes & 0x0003;  		index *= 4;  		var pointer = ypos * width * 4 + xpos * 4;  		buffer [pointer + 0] = c [index + 2];  		// b  		buffer [pointer + 1] = c [index + 1];  		// g  		buffer [pointer + 2] = c [index + 0];  		// r  		buffer [pointer + 3] = c [index + 3];  		// a  	}  	bytes >>= 2;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var xx = 0; xx < 4; xx++) {  	var xpos = x + xx;  	var ypos = y + yy;  	if (xpos < width && ypos < height) {  		var index = bytes & 0x0003;  		index *= 4;  		var pointer = ypos * width * 4 + xpos * 4;  		buffer [pointer + 0] = c [index + 2];  		// b  		buffer [pointer + 1] = c [index + 1];  		// g  		buffer [pointer + 2] = c [index + 0];  		// r  		buffer [pointer + 3] = c [index + 3];  		// a  	}  	bytes >>= 2;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: for (var xx = 0; xx < 4; xx++) {  	var xpos = x + xx;  	var ypos = y + yy;  	if (xpos < width && ypos < height) {  		var index = bytes & 0x0003;  		index *= 4;  		var pointer = ypos * width * 4 + xpos * 4;  		buffer [pointer + 0] = c [index + 2];  		// b  		buffer [pointer + 1] = c [index + 1];  		// g  		buffer [pointer + 2] = c [index + 0];  		// r  		buffer [pointer + 3] = c [index + 3];  		// a  	}  	bytes >>= 2;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: if (xpos < width && ypos < height) {  	var index = bytes & 0x0003;  	index *= 4;  	var pointer = ypos * width * 4 + xpos * 4;  	buffer [pointer + 0] = c [index + 2];  	// b  	buffer [pointer + 1] = c [index + 1];  	// g  	buffer [pointer + 2] = c [index + 0];  	// r  	buffer [pointer + 3] = c [index + 3];  	// a  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: if (xpos < width && ypos < height) {  	var index = bytes & 0x0003;  	index *= 4;  	var pointer = ypos * width * 4 + xpos * 4;  	buffer [pointer + 0] = c [index + 2];  	// b  	buffer [pointer + 1] = c [index + 1];  	// g  	buffer [pointer + 2] = c [index + 0];  	// r  	buffer [pointer + 3] = c [index + 3];  	// a  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: if (xpos < width && ypos < height) {  	var index = bytes & 0x0003;  	index *= 4;  	var pointer = ypos * width * 4 + xpos * 4;  	buffer [pointer + 0] = c [index + 2];  	// b  	buffer [pointer + 1] = c [index + 1];  	// g  	buffer [pointer + 2] = c [index + 0];  	// r  	buffer [pointer + 3] = c [index + 3];  	// a  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: if (xpos < width && ypos < height) {  	var index = bytes & 0x0003;  	index *= 4;  	var pointer = ypos * width * 4 + xpos * 4;  	buffer [pointer + 0] = c [index + 2];  	// b  	buffer [pointer + 1] = c [index + 1];  	// g  	buffer [pointer + 2] = c [index + 0];  	// r  	buffer [pointer + 3] = c [index + 3];  	// a  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: if (xpos < width && ypos < height) {  	var index = bytes & 0x0003;  	index *= 4;  	var pointer = ypos * width * 4 + xpos * 4;  	buffer [pointer + 0] = c [index + 2];  	// b  	buffer [pointer + 1] = c [index + 1];  	// g  	buffer [pointer + 2] = c [index + 0];  	// r  	buffer [pointer + 3] = c [index + 3];  	// a  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: if (xpos < width && ypos < height) {  	var index = bytes & 0x0003;  	index *= 4;  	var pointer = ypos * width * 4 + xpos * 4;  	buffer [pointer + 0] = c [index + 2];  	// b  	buffer [pointer + 1] = c [index + 1];  	// g  	buffer [pointer + 2] = c [index + 0];  	// r  	buffer [pointer + 3] = c [index + 3];  	// a  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: if (xpos < width && ypos < height) {  	var index = bytes & 0x0003;  	index *= 4;  	var pointer = ypos * width * 4 + xpos * 4;  	buffer [pointer + 0] = c [index + 2];  	// b  	buffer [pointer + 1] = c [index + 1];  	// g  	buffer [pointer + 2] = c [index + 0];  	// r  	buffer [pointer + 3] = c [index + 3];  	// a  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: index *= 4;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: buffer [pointer + 0] = c [index + 2];  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: buffer [pointer + 2] = c [index + 0];  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: buffer [pointer + 3] = c [index + 3];  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: buffer [pointer + 3] = c [index + 3];  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt1,The following statement contains a magic number: bytes >>= 2;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var y = 0; y < height; y += 4) {  	for (var x = 0; x < width; x += 4) {  		var a0 = all [pos++];  		var a1 = all [pos++];  		a [0] = a0;  		a [1] = a1;  		if (a0 > a1) {  			a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  			a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  			a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  			a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  			a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  			a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  		} else {  			a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  			a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  			a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  			a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  			a [6] = 0x00;  			a [7] = 0xFF;  		}  		var aindex = 0L;  		for (var i = 0; i < 6; i++)  			aindex |= ((long)all [pos++]) << (8 * i);  		int c0 = all [pos++];  		c0 |= all [pos++] << 8;  		int c1 = all [pos++];  		c1 |= all [pos++] << 8;  		c [0] = (byte)((c0 & 0xF800) >> 8);  		c [1] = (byte)((c0 & 0x07E0) >> 3);  		c [2] = (byte)((c0 & 0x001F) << 3);  		c [3] = 255;  		c [4] = (byte)((c1 & 0xF800) >> 8);  		c [5] = (byte)((c1 & 0x07E0) >> 3);  		c [6] = (byte)((c1 & 0x001F) << 3);  		c [7] = 255;  		c [8] = (byte)((2 * c [0] + c [4]) / 3);  		c [9] = (byte)((2 * c [1] + c [5]) / 3);  		c [10] = (byte)((2 * c [2] + c [6]) / 3);  		c [11] = 255;  		c [12] = (byte)((c [0] + 2 * c [4]) / 3);  		c [13] = (byte)((c [1] + 2 * c [5]) / 3);  		c [14] = (byte)((c [2] + 2 * c [6]) / 3);  		c [15] = 255;  		int bytes = all [pos++];  		bytes |= all [pos++] << 8;  		bytes |= all [pos++] << 16;  		bytes |= all [pos++] << 24;  		for (var yy = 0; yy < 4; yy++) {  			for (var xx = 0; xx < 4; xx++) {  				var xpos = x + xx;  				var ypos = y + yy;  				if (xpos < width && ypos < height) {  					var index = bytes & 0x0003;  					index *= 4;  					var alpha = (byte)a [aindex & 0x07];  					var pointer = ypos * width * 4 + xpos * 4;  					buffer [pointer + 0] = c [index + 2];  					// b  					buffer [pointer + 1] = c [index + 1];  					// g  					buffer [pointer + 2] = c [index + 0];  					// r  					buffer [pointer + 3] = alpha;  					// a  				}  				bytes >>= 2;  				aindex >>= 3;  			}  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: y += 4
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var x = 0; x < width; x += 4) {  	var a0 = all [pos++];  	var a1 = all [pos++];  	a [0] = a0;  	a [1] = a1;  	if (a0 > a1) {  		a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  		a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  		a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  		a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  		a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  		a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  	} else {  		a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  		a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  		a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  		a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  		a [6] = 0x00;  		a [7] = 0xFF;  	}  	var aindex = 0L;  	for (var i = 0; i < 6; i++)  		aindex |= ((long)all [pos++]) << (8 * i);  	int c0 = all [pos++];  	c0 |= all [pos++] << 8;  	int c1 = all [pos++];  	c1 |= all [pos++] << 8;  	c [0] = (byte)((c0 & 0xF800) >> 8);  	c [1] = (byte)((c0 & 0x07E0) >> 3);  	c [2] = (byte)((c0 & 0x001F) << 3);  	c [3] = 255;  	c [4] = (byte)((c1 & 0xF800) >> 8);  	c [5] = (byte)((c1 & 0x07E0) >> 3);  	c [6] = (byte)((c1 & 0x001F) << 3);  	c [7] = 255;  	c [8] = (byte)((2 * c [0] + c [4]) / 3);  	c [9] = (byte)((2 * c [1] + c [5]) / 3);  	c [10] = (byte)((2 * c [2] + c [6]) / 3);  	c [11] = 255;  	c [12] = (byte)((c [0] + 2 * c [4]) / 3);  	c [13] = (byte)((c [1] + 2 * c [5]) / 3);  	c [14] = (byte)((c [2] + 2 * c [6]) / 3);  	c [15] = 255;  	int bytes = all [pos++];  	bytes |= all [pos++] << 8;  	bytes |= all [pos++] << 16;  	bytes |= all [pos++] << 24;  	for (var yy = 0; yy < 4; yy++) {  		for (var xx = 0; xx < 4; xx++) {  			var xpos = x + xx;  			var ypos = y + yy;  			if (xpos < width && ypos < height) {  				var index = bytes & 0x0003;  				index *= 4;  				var alpha = (byte)a [aindex & 0x07];  				var pointer = ypos * width * 4 + xpos * 4;  				buffer [pointer + 0] = c [index + 2];  				// b  				buffer [pointer + 1] = c [index + 1];  				// g  				buffer [pointer + 2] = c [index + 0];  				// r  				buffer [pointer + 3] = alpha;  				// a  			}  			bytes >>= 2;  			aindex >>= 3;  		}  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: x += 4
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: if (a0 > a1) {  	a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  	a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  	a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  	a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  	a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  	a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  } else {  	a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  	a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  	a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  	a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  	a [6] = 0x00;  	a [7] = 0xFF;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: if (a0 > a1) {  	a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  	a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  	a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  	a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  	a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  	a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  } else {  	a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  	a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  	a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  	a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  	a [6] = 0x00;  	a [7] = 0xFF;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: if (a0 > a1) {  	a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  	a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  	a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  	a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  	a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  	a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  } else {  	a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  	a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  	a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  	a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  	a [6] = 0x00;  	a [7] = 0xFF;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: if (a0 > a1) {  	a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  	a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  	a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  	a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  	a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  	a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  } else {  	a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  	a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  	a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  	a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  	a [6] = 0x00;  	a [7] = 0xFF;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: if (a0 > a1) {  	a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  	a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  	a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  	a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  	a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  	a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  } else {  	a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  	a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  	a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  	a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  	a [6] = 0x00;  	a [7] = 0xFF;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: if (a0 > a1) {  	a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  	a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  	a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  	a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  	a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  	a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  } else {  	a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  	a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  	a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  	a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  	a [6] = 0x00;  	a [7] = 0xFF;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: if (a0 > a1) {  	a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  	a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  	a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  	a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  	a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  	a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  } else {  	a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  	a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  	a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  	a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  	a [6] = 0x00;  	a [7] = 0xFF;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: if (a0 > a1) {  	a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  	a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  	a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  	a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  	a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  	a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  } else {  	a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  	a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  	a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  	a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  	a [6] = 0x00;  	a [7] = 0xFF;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: if (a0 > a1) {  	a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  	a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  	a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  	a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  	a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  	a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  } else {  	a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  	a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  	a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  	a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  	a [6] = 0x00;  	a [7] = 0xFF;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: if (a0 > a1) {  	a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  	a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  	a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  	a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  	a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  	a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  } else {  	a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  	a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  	a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  	a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  	a [6] = 0x00;  	a [7] = 0xFF;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: if (a0 > a1) {  	a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  	a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  	a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  	a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  	a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  	a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  } else {  	a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  	a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  	a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  	a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  	a [6] = 0x00;  	a [7] = 0xFF;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: if (a0 > a1) {  	a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  	a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  	a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  	a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  	a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  	a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  } else {  	a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  	a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  	a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  	a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  	a [6] = 0x00;  	a [7] = 0xFF;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: if (a0 > a1) {  	a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  	a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  	a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  	a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  	a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  	a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  } else {  	a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  	a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  	a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  	a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  	a [6] = 0x00;  	a [7] = 0xFF;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: if (a0 > a1) {  	a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  	a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  	a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  	a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  	a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  	a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  } else {  	a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  	a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  	a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  	a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  	a [6] = 0x00;  	a [7] = 0xFF;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: if (a0 > a1) {  	a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  	a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  	a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  	a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  	a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  	a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  } else {  	a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  	a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  	a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  	a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  	a [6] = 0x00;  	a [7] = 0xFF;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: if (a0 > a1) {  	a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  	a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  	a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  	a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  	a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  	a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  } else {  	a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  	a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  	a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  	a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  	a [6] = 0x00;  	a [7] = 0xFF;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: if (a0 > a1) {  	a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  	a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  	a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  	a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  	a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  	a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  } else {  	a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  	a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  	a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  	a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  	a [6] = 0x00;  	a [7] = 0xFF;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: if (a0 > a1) {  	a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  	a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  	a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  	a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  	a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  	a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  } else {  	a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  	a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  	a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  	a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  	a [6] = 0x00;  	a [7] = 0xFF;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: if (a0 > a1) {  	a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  	a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  	a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  	a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  	a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  	a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  } else {  	a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  	a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  	a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  	a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  	a [6] = 0x00;  	a [7] = 0xFF;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: if (a0 > a1) {  	a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  	a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  	a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  	a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  	a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  	a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  } else {  	a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  	a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  	a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  	a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  	a [6] = 0x00;  	a [7] = 0xFF;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: if (a0 > a1) {  	a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  	a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  	a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  	a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  	a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  	a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  } else {  	a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  	a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  	a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  	a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  	a [6] = 0x00;  	a [7] = 0xFF;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: if (a0 > a1) {  	a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  	a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  	a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  	a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  	a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  	a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  } else {  	a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  	a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  	a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  	a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  	a [6] = 0x00;  	a [7] = 0xFF;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: if (a0 > a1) {  	a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  	a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  	a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  	a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  	a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  	a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  } else {  	a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  	a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  	a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  	a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  	a [6] = 0x00;  	a [7] = 0xFF;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: if (a0 > a1) {  	a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  	a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  	a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  	a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  	a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  	a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  } else {  	a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  	a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  	a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  	a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  	a [6] = 0x00;  	a [7] = 0xFF;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: if (a0 > a1) {  	a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  	a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  	a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  	a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  	a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  	a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  } else {  	a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  	a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  	a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  	a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  	a [6] = 0x00;  	a [7] = 0xFF;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: if (a0 > a1) {  	a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  	a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  	a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  	a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  	a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  	a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  } else {  	a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  	a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  	a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  	a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  	a [6] = 0x00;  	a [7] = 0xFF;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: if (a0 > a1) {  	a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  	a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  	a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  	a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  	a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  	a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  } else {  	a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  	a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  	a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  	a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  	a [6] = 0x00;  	a [7] = 0xFF;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: if (a0 > a1) {  	a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  	a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  	a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  	a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  	a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  	a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  } else {  	a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  	a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  	a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  	a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  	a [6] = 0x00;  	a [7] = 0xFF;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: if (a0 > a1) {  	a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  	a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  	a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  	a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  	a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  	a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  } else {  	a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  	a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  	a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  	a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  	a [6] = 0x00;  	a [7] = 0xFF;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: if (a0 > a1) {  	a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  	a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  	a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  	a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  	a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  	a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  } else {  	a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  	a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  	a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  	a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  	a [6] = 0x00;  	a [7] = 0xFF;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: if (a0 > a1) {  	a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  	a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  	a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  	a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  	a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  	a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  } else {  	a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  	a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  	a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  	a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  	a [6] = 0x00;  	a [7] = 0xFF;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: if (a0 > a1) {  	a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  	a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  	a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  	a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  	a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  	a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  } else {  	a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  	a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  	a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  	a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  	a [6] = 0x00;  	a [7] = 0xFF;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: if (a0 > a1) {  	a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  	a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  	a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  	a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  	a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  	a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  } else {  	a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  	a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  	a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  	a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  	a [6] = 0x00;  	a [7] = 0xFF;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: if (a0 > a1) {  	a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  	a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  	a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  	a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  	a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  	a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  } else {  	a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  	a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  	a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  	a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  	a [6] = 0x00;  	a [7] = 0xFF;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: if (a0 > a1) {  	a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  	a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  	a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  	a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  	a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  	a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  } else {  	a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  	a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  	a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  	a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  	a [6] = 0x00;  	a [7] = 0xFF;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: if (a0 > a1) {  	a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  	a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  	a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  	a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  	a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  	a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  } else {  	a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  	a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  	a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  	a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  	a [6] = 0x00;  	a [7] = 0xFF;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: if (a0 > a1) {  	a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  	a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  	a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  	a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  	a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  	a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  } else {  	a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  	a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  	a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  	a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  	a [6] = 0x00;  	a [7] = 0xFF;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: if (a0 > a1) {  	a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  	a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  	a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  	a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  	a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  	a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  } else {  	a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  	a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  	a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  	a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  	a [6] = 0x00;  	a [7] = 0xFF;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: if (a0 > a1) {  	a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  	a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  	a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  	a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  	a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  	a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  } else {  	a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  	a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  	a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  	a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  	a [6] = 0x00;  	a [7] = 0xFF;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: if (a0 > a1) {  	a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  	a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  	a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  	a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  	a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  	a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  } else {  	a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  	a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  	a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  	a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  	a [6] = 0x00;  	a [7] = 0xFF;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: if (a0 > a1) {  	a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  	a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  	a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  	a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  	a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  	a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  } else {  	a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  	a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  	a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  	a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  	a [6] = 0x00;  	a [7] = 0xFF;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: if (a0 > a1) {  	a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  	a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  	a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  	a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  	a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  	a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  } else {  	a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  	a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  	a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  	a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  	a [6] = 0x00;  	a [7] = 0xFF;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: if (a0 > a1) {  	a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  	a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  	a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  	a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  	a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  	a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  } else {  	a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  	a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  	a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  	a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  	a [6] = 0x00;  	a [7] = 0xFF;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: if (a0 > a1) {  	a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  	a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  	a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  	a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  	a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  	a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  } else {  	a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  	a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  	a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  	a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  	a [6] = 0x00;  	a [7] = 0xFF;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: if (a0 > a1) {  	a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  	a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  	a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  	a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  	a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  	a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  } else {  	a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  	a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  	a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  	a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  	a [6] = 0x00;  	a [7] = 0xFF;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: if (a0 > a1) {  	a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  	a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  	a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  	a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  	a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  	a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  } else {  	a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  	a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  	a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  	a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  	a [6] = 0x00;  	a [7] = 0xFF;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: if (a0 > a1) {  	a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  	a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  	a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  	a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  	a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  	a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  } else {  	a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  	a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  	a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  	a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  	a [6] = 0x00;  	a [7] = 0xFF;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: if (a0 > a1) {  	a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  	a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  	a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  	a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  	a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  	a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  } else {  	a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  	a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  	a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  	a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  	a [6] = 0x00;  	a [7] = 0xFF;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: a [2] = (6 * a [0] + 1 * a [1] + 3) / 7;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: a [3] = (5 * a [0] + 2 * a [1] + 3) / 7;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: a [4] = (4 * a [0] + 3 * a [1] + 3) / 7;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: a [5] = (3 * a [0] + 4 * a [1] + 3) / 7;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: a [6] = (2 * a [0] + 5 * a [1] + 3) / 7;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: a [7] = (1 * a [0] + 6 * a [1] + 3) / 7;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: a [2] = (4 * a [0] + 1 * a [1] + 2) / 5;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: a [3] = (3 * a [0] + 2 * a [1] + 2) / 5;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: a [4] = (2 * a [0] + 3 * a [1] + 2) / 5;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: a [5] = (1 * a [0] + 4 * a [1] + 2) / 5;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: a [6] = 0x00;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: a [7] = 0xFF;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var i = 0; i < 6; i++)  	aindex |= ((long)all [pos++]) << (8 * i);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var i = 0; i < 6; i++)  	aindex |= ((long)all [pos++]) << (8 * i);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: aindex |= ((long)all [pos++]) << (8 * i);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: c0 |= all [pos++] << 8;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: c1 |= all [pos++] << 8;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: c [0] = (byte)((c0 & 0xF800) >> 8);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: c [1] = (byte)((c0 & 0x07E0) >> 3);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: c [2] = (byte)((c0 & 0x001F) << 3);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: c [2] = (byte)((c0 & 0x001F) << 3);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: c [3] = 255;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: c [3] = 255;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: c [4] = (byte)((c1 & 0xF800) >> 8);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: c [4] = (byte)((c1 & 0xF800) >> 8);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: c [5] = (byte)((c1 & 0x07E0) >> 3);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: c [5] = (byte)((c1 & 0x07E0) >> 3);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: c [6] = (byte)((c1 & 0x001F) << 3);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: c [6] = (byte)((c1 & 0x001F) << 3);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: c [7] = 255;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: c [7] = 255;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: c [8] = (byte)((2 * c [0] + c [4]) / 3);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: c [8] = (byte)((2 * c [0] + c [4]) / 3);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: c [8] = (byte)((2 * c [0] + c [4]) / 3);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: c [8] = (byte)((2 * c [0] + c [4]) / 3);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: c [9] = (byte)((2 * c [1] + c [5]) / 3);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: c [9] = (byte)((2 * c [1] + c [5]) / 3);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: c [9] = (byte)((2 * c [1] + c [5]) / 3);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: c [9] = (byte)((2 * c [1] + c [5]) / 3);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: c [10] = (byte)((2 * c [2] + c [6]) / 3);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: c [10] = (byte)((2 * c [2] + c [6]) / 3);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: c [10] = (byte)((2 * c [2] + c [6]) / 3);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: c [10] = (byte)((2 * c [2] + c [6]) / 3);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: c [10] = (byte)((2 * c [2] + c [6]) / 3);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: c [11] = 255;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: c [11] = 255;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: c [12] = (byte)((c [0] + 2 * c [4]) / 3);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: c [12] = (byte)((c [0] + 2 * c [4]) / 3);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: c [12] = (byte)((c [0] + 2 * c [4]) / 3);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: c [12] = (byte)((c [0] + 2 * c [4]) / 3);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: c [13] = (byte)((c [1] + 2 * c [5]) / 3);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: c [13] = (byte)((c [1] + 2 * c [5]) / 3);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: c [13] = (byte)((c [1] + 2 * c [5]) / 3);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: c [13] = (byte)((c [1] + 2 * c [5]) / 3);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: c [14] = (byte)((c [2] + 2 * c [6]) / 3);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: c [14] = (byte)((c [2] + 2 * c [6]) / 3);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: c [14] = (byte)((c [2] + 2 * c [6]) / 3);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: c [14] = (byte)((c [2] + 2 * c [6]) / 3);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: c [14] = (byte)((c [2] + 2 * c [6]) / 3);  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: c [15] = 255;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: c [15] = 255;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: bytes |= all [pos++] << 8;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: bytes |= all [pos++] << 16;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: bytes |= all [pos++] << 24;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var yy = 0; yy < 4; yy++) {  	for (var xx = 0; xx < 4; xx++) {  		var xpos = x + xx;  		var ypos = y + yy;  		if (xpos < width && ypos < height) {  			var index = bytes & 0x0003;  			index *= 4;  			var alpha = (byte)a [aindex & 0x07];  			var pointer = ypos * width * 4 + xpos * 4;  			buffer [pointer + 0] = c [index + 2];  			// b  			buffer [pointer + 1] = c [index + 1];  			// g  			buffer [pointer + 2] = c [index + 0];  			// r  			buffer [pointer + 3] = alpha;  			// a  		}  		bytes >>= 2;  		aindex >>= 3;  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var yy = 0; yy < 4; yy++) {  	for (var xx = 0; xx < 4; xx++) {  		var xpos = x + xx;  		var ypos = y + yy;  		if (xpos < width && ypos < height) {  			var index = bytes & 0x0003;  			index *= 4;  			var alpha = (byte)a [aindex & 0x07];  			var pointer = ypos * width * 4 + xpos * 4;  			buffer [pointer + 0] = c [index + 2];  			// b  			buffer [pointer + 1] = c [index + 1];  			// g  			buffer [pointer + 2] = c [index + 0];  			// r  			buffer [pointer + 3] = alpha;  			// a  		}  		bytes >>= 2;  		aindex >>= 3;  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var yy = 0; yy < 4; yy++) {  	for (var xx = 0; xx < 4; xx++) {  		var xpos = x + xx;  		var ypos = y + yy;  		if (xpos < width && ypos < height) {  			var index = bytes & 0x0003;  			index *= 4;  			var alpha = (byte)a [aindex & 0x07];  			var pointer = ypos * width * 4 + xpos * 4;  			buffer [pointer + 0] = c [index + 2];  			// b  			buffer [pointer + 1] = c [index + 1];  			// g  			buffer [pointer + 2] = c [index + 0];  			// r  			buffer [pointer + 3] = alpha;  			// a  		}  		bytes >>= 2;  		aindex >>= 3;  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var yy = 0; yy < 4; yy++) {  	for (var xx = 0; xx < 4; xx++) {  		var xpos = x + xx;  		var ypos = y + yy;  		if (xpos < width && ypos < height) {  			var index = bytes & 0x0003;  			index *= 4;  			var alpha = (byte)a [aindex & 0x07];  			var pointer = ypos * width * 4 + xpos * 4;  			buffer [pointer + 0] = c [index + 2];  			// b  			buffer [pointer + 1] = c [index + 1];  			// g  			buffer [pointer + 2] = c [index + 0];  			// r  			buffer [pointer + 3] = alpha;  			// a  		}  		bytes >>= 2;  		aindex >>= 3;  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var yy = 0; yy < 4; yy++) {  	for (var xx = 0; xx < 4; xx++) {  		var xpos = x + xx;  		var ypos = y + yy;  		if (xpos < width && ypos < height) {  			var index = bytes & 0x0003;  			index *= 4;  			var alpha = (byte)a [aindex & 0x07];  			var pointer = ypos * width * 4 + xpos * 4;  			buffer [pointer + 0] = c [index + 2];  			// b  			buffer [pointer + 1] = c [index + 1];  			// g  			buffer [pointer + 2] = c [index + 0];  			// r  			buffer [pointer + 3] = alpha;  			// a  		}  		bytes >>= 2;  		aindex >>= 3;  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var yy = 0; yy < 4; yy++) {  	for (var xx = 0; xx < 4; xx++) {  		var xpos = x + xx;  		var ypos = y + yy;  		if (xpos < width && ypos < height) {  			var index = bytes & 0x0003;  			index *= 4;  			var alpha = (byte)a [aindex & 0x07];  			var pointer = ypos * width * 4 + xpos * 4;  			buffer [pointer + 0] = c [index + 2];  			// b  			buffer [pointer + 1] = c [index + 1];  			// g  			buffer [pointer + 2] = c [index + 0];  			// r  			buffer [pointer + 3] = alpha;  			// a  		}  		bytes >>= 2;  		aindex >>= 3;  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var yy = 0; yy < 4; yy++) {  	for (var xx = 0; xx < 4; xx++) {  		var xpos = x + xx;  		var ypos = y + yy;  		if (xpos < width && ypos < height) {  			var index = bytes & 0x0003;  			index *= 4;  			var alpha = (byte)a [aindex & 0x07];  			var pointer = ypos * width * 4 + xpos * 4;  			buffer [pointer + 0] = c [index + 2];  			// b  			buffer [pointer + 1] = c [index + 1];  			// g  			buffer [pointer + 2] = c [index + 0];  			// r  			buffer [pointer + 3] = alpha;  			// a  		}  		bytes >>= 2;  		aindex >>= 3;  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var yy = 0; yy < 4; yy++) {  	for (var xx = 0; xx < 4; xx++) {  		var xpos = x + xx;  		var ypos = y + yy;  		if (xpos < width && ypos < height) {  			var index = bytes & 0x0003;  			index *= 4;  			var alpha = (byte)a [aindex & 0x07];  			var pointer = ypos * width * 4 + xpos * 4;  			buffer [pointer + 0] = c [index + 2];  			// b  			buffer [pointer + 1] = c [index + 1];  			// g  			buffer [pointer + 2] = c [index + 0];  			// r  			buffer [pointer + 3] = alpha;  			// a  		}  		bytes >>= 2;  		aindex >>= 3;  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var yy = 0; yy < 4; yy++) {  	for (var xx = 0; xx < 4; xx++) {  		var xpos = x + xx;  		var ypos = y + yy;  		if (xpos < width && ypos < height) {  			var index = bytes & 0x0003;  			index *= 4;  			var alpha = (byte)a [aindex & 0x07];  			var pointer = ypos * width * 4 + xpos * 4;  			buffer [pointer + 0] = c [index + 2];  			// b  			buffer [pointer + 1] = c [index + 1];  			// g  			buffer [pointer + 2] = c [index + 0];  			// r  			buffer [pointer + 3] = alpha;  			// a  		}  		bytes >>= 2;  		aindex >>= 3;  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var yy = 0; yy < 4; yy++) {  	for (var xx = 0; xx < 4; xx++) {  		var xpos = x + xx;  		var ypos = y + yy;  		if (xpos < width && ypos < height) {  			var index = bytes & 0x0003;  			index *= 4;  			var alpha = (byte)a [aindex & 0x07];  			var pointer = ypos * width * 4 + xpos * 4;  			buffer [pointer + 0] = c [index + 2];  			// b  			buffer [pointer + 1] = c [index + 1];  			// g  			buffer [pointer + 2] = c [index + 0];  			// r  			buffer [pointer + 3] = alpha;  			// a  		}  		bytes >>= 2;  		aindex >>= 3;  	}  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var xx = 0; xx < 4; xx++) {  	var xpos = x + xx;  	var ypos = y + yy;  	if (xpos < width && ypos < height) {  		var index = bytes & 0x0003;  		index *= 4;  		var alpha = (byte)a [aindex & 0x07];  		var pointer = ypos * width * 4 + xpos * 4;  		buffer [pointer + 0] = c [index + 2];  		// b  		buffer [pointer + 1] = c [index + 1];  		// g  		buffer [pointer + 2] = c [index + 0];  		// r  		buffer [pointer + 3] = alpha;  		// a  	}  	bytes >>= 2;  	aindex >>= 3;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var xx = 0; xx < 4; xx++) {  	var xpos = x + xx;  	var ypos = y + yy;  	if (xpos < width && ypos < height) {  		var index = bytes & 0x0003;  		index *= 4;  		var alpha = (byte)a [aindex & 0x07];  		var pointer = ypos * width * 4 + xpos * 4;  		buffer [pointer + 0] = c [index + 2];  		// b  		buffer [pointer + 1] = c [index + 1];  		// g  		buffer [pointer + 2] = c [index + 0];  		// r  		buffer [pointer + 3] = alpha;  		// a  	}  	bytes >>= 2;  	aindex >>= 3;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var xx = 0; xx < 4; xx++) {  	var xpos = x + xx;  	var ypos = y + yy;  	if (xpos < width && ypos < height) {  		var index = bytes & 0x0003;  		index *= 4;  		var alpha = (byte)a [aindex & 0x07];  		var pointer = ypos * width * 4 + xpos * 4;  		buffer [pointer + 0] = c [index + 2];  		// b  		buffer [pointer + 1] = c [index + 1];  		// g  		buffer [pointer + 2] = c [index + 0];  		// r  		buffer [pointer + 3] = alpha;  		// a  	}  	bytes >>= 2;  	aindex >>= 3;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var xx = 0; xx < 4; xx++) {  	var xpos = x + xx;  	var ypos = y + yy;  	if (xpos < width && ypos < height) {  		var index = bytes & 0x0003;  		index *= 4;  		var alpha = (byte)a [aindex & 0x07];  		var pointer = ypos * width * 4 + xpos * 4;  		buffer [pointer + 0] = c [index + 2];  		// b  		buffer [pointer + 1] = c [index + 1];  		// g  		buffer [pointer + 2] = c [index + 0];  		// r  		buffer [pointer + 3] = alpha;  		// a  	}  	bytes >>= 2;  	aindex >>= 3;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var xx = 0; xx < 4; xx++) {  	var xpos = x + xx;  	var ypos = y + yy;  	if (xpos < width && ypos < height) {  		var index = bytes & 0x0003;  		index *= 4;  		var alpha = (byte)a [aindex & 0x07];  		var pointer = ypos * width * 4 + xpos * 4;  		buffer [pointer + 0] = c [index + 2];  		// b  		buffer [pointer + 1] = c [index + 1];  		// g  		buffer [pointer + 2] = c [index + 0];  		// r  		buffer [pointer + 3] = alpha;  		// a  	}  	bytes >>= 2;  	aindex >>= 3;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var xx = 0; xx < 4; xx++) {  	var xpos = x + xx;  	var ypos = y + yy;  	if (xpos < width && ypos < height) {  		var index = bytes & 0x0003;  		index *= 4;  		var alpha = (byte)a [aindex & 0x07];  		var pointer = ypos * width * 4 + xpos * 4;  		buffer [pointer + 0] = c [index + 2];  		// b  		buffer [pointer + 1] = c [index + 1];  		// g  		buffer [pointer + 2] = c [index + 0];  		// r  		buffer [pointer + 3] = alpha;  		// a  	}  	bytes >>= 2;  	aindex >>= 3;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var xx = 0; xx < 4; xx++) {  	var xpos = x + xx;  	var ypos = y + yy;  	if (xpos < width && ypos < height) {  		var index = bytes & 0x0003;  		index *= 4;  		var alpha = (byte)a [aindex & 0x07];  		var pointer = ypos * width * 4 + xpos * 4;  		buffer [pointer + 0] = c [index + 2];  		// b  		buffer [pointer + 1] = c [index + 1];  		// g  		buffer [pointer + 2] = c [index + 0];  		// r  		buffer [pointer + 3] = alpha;  		// a  	}  	bytes >>= 2;  	aindex >>= 3;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var xx = 0; xx < 4; xx++) {  	var xpos = x + xx;  	var ypos = y + yy;  	if (xpos < width && ypos < height) {  		var index = bytes & 0x0003;  		index *= 4;  		var alpha = (byte)a [aindex & 0x07];  		var pointer = ypos * width * 4 + xpos * 4;  		buffer [pointer + 0] = c [index + 2];  		// b  		buffer [pointer + 1] = c [index + 1];  		// g  		buffer [pointer + 2] = c [index + 0];  		// r  		buffer [pointer + 3] = alpha;  		// a  	}  	bytes >>= 2;  	aindex >>= 3;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: for (var xx = 0; xx < 4; xx++) {  	var xpos = x + xx;  	var ypos = y + yy;  	if (xpos < width && ypos < height) {  		var index = bytes & 0x0003;  		index *= 4;  		var alpha = (byte)a [aindex & 0x07];  		var pointer = ypos * width * 4 + xpos * 4;  		buffer [pointer + 0] = c [index + 2];  		// b  		buffer [pointer + 1] = c [index + 1];  		// g  		buffer [pointer + 2] = c [index + 0];  		// r  		buffer [pointer + 3] = alpha;  		// a  	}  	bytes >>= 2;  	aindex >>= 3;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: if (xpos < width && ypos < height) {  	var index = bytes & 0x0003;  	index *= 4;  	var alpha = (byte)a [aindex & 0x07];  	var pointer = ypos * width * 4 + xpos * 4;  	buffer [pointer + 0] = c [index + 2];  	// b  	buffer [pointer + 1] = c [index + 1];  	// g  	buffer [pointer + 2] = c [index + 0];  	// r  	buffer [pointer + 3] = alpha;  	// a  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: if (xpos < width && ypos < height) {  	var index = bytes & 0x0003;  	index *= 4;  	var alpha = (byte)a [aindex & 0x07];  	var pointer = ypos * width * 4 + xpos * 4;  	buffer [pointer + 0] = c [index + 2];  	// b  	buffer [pointer + 1] = c [index + 1];  	// g  	buffer [pointer + 2] = c [index + 0];  	// r  	buffer [pointer + 3] = alpha;  	// a  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: if (xpos < width && ypos < height) {  	var index = bytes & 0x0003;  	index *= 4;  	var alpha = (byte)a [aindex & 0x07];  	var pointer = ypos * width * 4 + xpos * 4;  	buffer [pointer + 0] = c [index + 2];  	// b  	buffer [pointer + 1] = c [index + 1];  	// g  	buffer [pointer + 2] = c [index + 0];  	// r  	buffer [pointer + 3] = alpha;  	// a  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: if (xpos < width && ypos < height) {  	var index = bytes & 0x0003;  	index *= 4;  	var alpha = (byte)a [aindex & 0x07];  	var pointer = ypos * width * 4 + xpos * 4;  	buffer [pointer + 0] = c [index + 2];  	// b  	buffer [pointer + 1] = c [index + 1];  	// g  	buffer [pointer + 2] = c [index + 0];  	// r  	buffer [pointer + 3] = alpha;  	// a  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: if (xpos < width && ypos < height) {  	var index = bytes & 0x0003;  	index *= 4;  	var alpha = (byte)a [aindex & 0x07];  	var pointer = ypos * width * 4 + xpos * 4;  	buffer [pointer + 0] = c [index + 2];  	// b  	buffer [pointer + 1] = c [index + 1];  	// g  	buffer [pointer + 2] = c [index + 0];  	// r  	buffer [pointer + 3] = alpha;  	// a  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: if (xpos < width && ypos < height) {  	var index = bytes & 0x0003;  	index *= 4;  	var alpha = (byte)a [aindex & 0x07];  	var pointer = ypos * width * 4 + xpos * 4;  	buffer [pointer + 0] = c [index + 2];  	// b  	buffer [pointer + 1] = c [index + 1];  	// g  	buffer [pointer + 2] = c [index + 0];  	// r  	buffer [pointer + 3] = alpha;  	// a  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: index *= 4;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: buffer [pointer + 0] = c [index + 2];  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: buffer [pointer + 2] = c [index + 0];  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: buffer [pointer + 3] = alpha;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: bytes >>= 2;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,DecompressDxt5,The following statement contains a magic number: aindex >>= 3;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,ComputeImageSize,The following statement contains a magic number: switch (imageFormat) {  case VtfImageFormat.Dxt1:  case VtfImageFormat.Dxt1Onebitalpha:  	if (width < 4 && width > 0)  		width = 4;  	if (height < 4 && height > 0)  		height = 4;  	return ((width + 3) / 4) * ((height + 3) / 4) * 8 * depth;  case VtfImageFormat.Dxt3:  case VtfImageFormat.Dxt5:  	if (width < 4 && width > 0)  		width = 4;  	if (height < 4 && height > 0)  		height = 4;  	return ((width + 3) / 4) * ((height + 3) / 4) * 16 * depth;  default:  	return width * height * depth * GetImageFormatInfo (imageFormat).BytesPerPixel;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,ComputeImageSize,The following statement contains a magic number: switch (imageFormat) {  case VtfImageFormat.Dxt1:  case VtfImageFormat.Dxt1Onebitalpha:  	if (width < 4 && width > 0)  		width = 4;  	if (height < 4 && height > 0)  		height = 4;  	return ((width + 3) / 4) * ((height + 3) / 4) * 8 * depth;  case VtfImageFormat.Dxt3:  case VtfImageFormat.Dxt5:  	if (width < 4 && width > 0)  		width = 4;  	if (height < 4 && height > 0)  		height = 4;  	return ((width + 3) / 4) * ((height + 3) / 4) * 16 * depth;  default:  	return width * height * depth * GetImageFormatInfo (imageFormat).BytesPerPixel;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,ComputeImageSize,The following statement contains a magic number: switch (imageFormat) {  case VtfImageFormat.Dxt1:  case VtfImageFormat.Dxt1Onebitalpha:  	if (width < 4 && width > 0)  		width = 4;  	if (height < 4 && height > 0)  		height = 4;  	return ((width + 3) / 4) * ((height + 3) / 4) * 8 * depth;  case VtfImageFormat.Dxt3:  case VtfImageFormat.Dxt5:  	if (width < 4 && width > 0)  		width = 4;  	if (height < 4 && height > 0)  		height = 4;  	return ((width + 3) / 4) * ((height + 3) / 4) * 16 * depth;  default:  	return width * height * depth * GetImageFormatInfo (imageFormat).BytesPerPixel;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,ComputeImageSize,The following statement contains a magic number: switch (imageFormat) {  case VtfImageFormat.Dxt1:  case VtfImageFormat.Dxt1Onebitalpha:  	if (width < 4 && width > 0)  		width = 4;  	if (height < 4 && height > 0)  		height = 4;  	return ((width + 3) / 4) * ((height + 3) / 4) * 8 * depth;  case VtfImageFormat.Dxt3:  case VtfImageFormat.Dxt5:  	if (width < 4 && width > 0)  		width = 4;  	if (height < 4 && height > 0)  		height = 4;  	return ((width + 3) / 4) * ((height + 3) / 4) * 16 * depth;  default:  	return width * height * depth * GetImageFormatInfo (imageFormat).BytesPerPixel;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,ComputeImageSize,The following statement contains a magic number: switch (imageFormat) {  case VtfImageFormat.Dxt1:  case VtfImageFormat.Dxt1Onebitalpha:  	if (width < 4 && width > 0)  		width = 4;  	if (height < 4 && height > 0)  		height = 4;  	return ((width + 3) / 4) * ((height + 3) / 4) * 8 * depth;  case VtfImageFormat.Dxt3:  case VtfImageFormat.Dxt5:  	if (width < 4 && width > 0)  		width = 4;  	if (height < 4 && height > 0)  		height = 4;  	return ((width + 3) / 4) * ((height + 3) / 4) * 16 * depth;  default:  	return width * height * depth * GetImageFormatInfo (imageFormat).BytesPerPixel;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,ComputeImageSize,The following statement contains a magic number: switch (imageFormat) {  case VtfImageFormat.Dxt1:  case VtfImageFormat.Dxt1Onebitalpha:  	if (width < 4 && width > 0)  		width = 4;  	if (height < 4 && height > 0)  		height = 4;  	return ((width + 3) / 4) * ((height + 3) / 4) * 8 * depth;  case VtfImageFormat.Dxt3:  case VtfImageFormat.Dxt5:  	if (width < 4 && width > 0)  		width = 4;  	if (height < 4 && height > 0)  		height = 4;  	return ((width + 3) / 4) * ((height + 3) / 4) * 16 * depth;  default:  	return width * height * depth * GetImageFormatInfo (imageFormat).BytesPerPixel;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,ComputeImageSize,The following statement contains a magic number: switch (imageFormat) {  case VtfImageFormat.Dxt1:  case VtfImageFormat.Dxt1Onebitalpha:  	if (width < 4 && width > 0)  		width = 4;  	if (height < 4 && height > 0)  		height = 4;  	return ((width + 3) / 4) * ((height + 3) / 4) * 8 * depth;  case VtfImageFormat.Dxt3:  case VtfImageFormat.Dxt5:  	if (width < 4 && width > 0)  		width = 4;  	if (height < 4 && height > 0)  		height = 4;  	return ((width + 3) / 4) * ((height + 3) / 4) * 16 * depth;  default:  	return width * height * depth * GetImageFormatInfo (imageFormat).BytesPerPixel;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,ComputeImageSize,The following statement contains a magic number: switch (imageFormat) {  case VtfImageFormat.Dxt1:  case VtfImageFormat.Dxt1Onebitalpha:  	if (width < 4 && width > 0)  		width = 4;  	if (height < 4 && height > 0)  		height = 4;  	return ((width + 3) / 4) * ((height + 3) / 4) * 8 * depth;  case VtfImageFormat.Dxt3:  case VtfImageFormat.Dxt5:  	if (width < 4 && width > 0)  		width = 4;  	if (height < 4 && height > 0)  		height = 4;  	return ((width + 3) / 4) * ((height + 3) / 4) * 16 * depth;  default:  	return width * height * depth * GetImageFormatInfo (imageFormat).BytesPerPixel;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,ComputeImageSize,The following statement contains a magic number: switch (imageFormat) {  case VtfImageFormat.Dxt1:  case VtfImageFormat.Dxt1Onebitalpha:  	if (width < 4 && width > 0)  		width = 4;  	if (height < 4 && height > 0)  		height = 4;  	return ((width + 3) / 4) * ((height + 3) / 4) * 8 * depth;  case VtfImageFormat.Dxt3:  case VtfImageFormat.Dxt5:  	if (width < 4 && width > 0)  		width = 4;  	if (height < 4 && height > 0)  		height = 4;  	return ((width + 3) / 4) * ((height + 3) / 4) * 16 * depth;  default:  	return width * height * depth * GetImageFormatInfo (imageFormat).BytesPerPixel;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,ComputeImageSize,The following statement contains a magic number: switch (imageFormat) {  case VtfImageFormat.Dxt1:  case VtfImageFormat.Dxt1Onebitalpha:  	if (width < 4 && width > 0)  		width = 4;  	if (height < 4 && height > 0)  		height = 4;  	return ((width + 3) / 4) * ((height + 3) / 4) * 8 * depth;  case VtfImageFormat.Dxt3:  case VtfImageFormat.Dxt5:  	if (width < 4 && width > 0)  		width = 4;  	if (height < 4 && height > 0)  		height = 4;  	return ((width + 3) / 4) * ((height + 3) / 4) * 16 * depth;  default:  	return width * height * depth * GetImageFormatInfo (imageFormat).BytesPerPixel;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,ComputeImageSize,The following statement contains a magic number: switch (imageFormat) {  case VtfImageFormat.Dxt1:  case VtfImageFormat.Dxt1Onebitalpha:  	if (width < 4 && width > 0)  		width = 4;  	if (height < 4 && height > 0)  		height = 4;  	return ((width + 3) / 4) * ((height + 3) / 4) * 8 * depth;  case VtfImageFormat.Dxt3:  case VtfImageFormat.Dxt5:  	if (width < 4 && width > 0)  		width = 4;  	if (height < 4 && height > 0)  		height = 4;  	return ((width + 3) / 4) * ((height + 3) / 4) * 16 * depth;  default:  	return width * height * depth * GetImageFormatInfo (imageFormat).BytesPerPixel;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,ComputeImageSize,The following statement contains a magic number: switch (imageFormat) {  case VtfImageFormat.Dxt1:  case VtfImageFormat.Dxt1Onebitalpha:  	if (width < 4 && width > 0)  		width = 4;  	if (height < 4 && height > 0)  		height = 4;  	return ((width + 3) / 4) * ((height + 3) / 4) * 8 * depth;  case VtfImageFormat.Dxt3:  case VtfImageFormat.Dxt5:  	if (width < 4 && width > 0)  		width = 4;  	if (height < 4 && height > 0)  		height = 4;  	return ((width + 3) / 4) * ((height + 3) / 4) * 16 * depth;  default:  	return width * height * depth * GetImageFormatInfo (imageFormat).BytesPerPixel;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,ComputeImageSize,The following statement contains a magic number: switch (imageFormat) {  case VtfImageFormat.Dxt1:  case VtfImageFormat.Dxt1Onebitalpha:  	if (width < 4 && width > 0)  		width = 4;  	if (height < 4 && height > 0)  		height = 4;  	return ((width + 3) / 4) * ((height + 3) / 4) * 8 * depth;  case VtfImageFormat.Dxt3:  case VtfImageFormat.Dxt5:  	if (width < 4 && width > 0)  		width = 4;  	if (height < 4 && height > 0)  		height = 4;  	return ((width + 3) / 4) * ((height + 3) / 4) * 16 * depth;  default:  	return width * height * depth * GetImageFormatInfo (imageFormat).BytesPerPixel;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,ComputeImageSize,The following statement contains a magic number: switch (imageFormat) {  case VtfImageFormat.Dxt1:  case VtfImageFormat.Dxt1Onebitalpha:  	if (width < 4 && width > 0)  		width = 4;  	if (height < 4 && height > 0)  		height = 4;  	return ((width + 3) / 4) * ((height + 3) / 4) * 8 * depth;  case VtfImageFormat.Dxt3:  case VtfImageFormat.Dxt5:  	if (width < 4 && width > 0)  		width = 4;  	if (height < 4 && height > 0)  		height = 4;  	return ((width + 3) / 4) * ((height + 3) / 4) * 16 * depth;  default:  	return width * height * depth * GetImageFormatInfo (imageFormat).BytesPerPixel;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,ComputeImageSize,The following statement contains a magic number: switch (imageFormat) {  case VtfImageFormat.Dxt1:  case VtfImageFormat.Dxt1Onebitalpha:  	if (width < 4 && width > 0)  		width = 4;  	if (height < 4 && height > 0)  		height = 4;  	return ((width + 3) / 4) * ((height + 3) / 4) * 8 * depth;  case VtfImageFormat.Dxt3:  case VtfImageFormat.Dxt5:  	if (width < 4 && width > 0)  		width = 4;  	if (height < 4 && height > 0)  		height = 4;  	return ((width + 3) / 4) * ((height + 3) / 4) * 16 * depth;  default:  	return width * height * depth * GetImageFormatInfo (imageFormat).BytesPerPixel;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,ComputeImageSize,The following statement contains a magic number: switch (imageFormat) {  case VtfImageFormat.Dxt1:  case VtfImageFormat.Dxt1Onebitalpha:  	if (width < 4 && width > 0)  		width = 4;  	if (height < 4 && height > 0)  		height = 4;  	return ((width + 3) / 4) * ((height + 3) / 4) * 8 * depth;  case VtfImageFormat.Dxt3:  case VtfImageFormat.Dxt5:  	if (width < 4 && width > 0)  		width = 4;  	if (height < 4 && height > 0)  		height = 4;  	return ((width + 3) / 4) * ((height + 3) / 4) * 16 * depth;  default:  	return width * height * depth * GetImageFormatInfo (imageFormat).BytesPerPixel;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,ComputeImageSize,The following statement contains a magic number: switch (imageFormat) {  case VtfImageFormat.Dxt1:  case VtfImageFormat.Dxt1Onebitalpha:  	if (width < 4 && width > 0)  		width = 4;  	if (height < 4 && height > 0)  		height = 4;  	return ((width + 3) / 4) * ((height + 3) / 4) * 8 * depth;  case VtfImageFormat.Dxt3:  case VtfImageFormat.Dxt5:  	if (width < 4 && width > 0)  		width = 4;  	if (height < 4 && height > 0)  		height = 4;  	return ((width + 3) / 4) * ((height + 3) / 4) * 16 * depth;  default:  	return width * height * depth * GetImageFormatInfo (imageFormat).BytesPerPixel;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,ComputeImageSize,The following statement contains a magic number: switch (imageFormat) {  case VtfImageFormat.Dxt1:  case VtfImageFormat.Dxt1Onebitalpha:  	if (width < 4 && width > 0)  		width = 4;  	if (height < 4 && height > 0)  		height = 4;  	return ((width + 3) / 4) * ((height + 3) / 4) * 8 * depth;  case VtfImageFormat.Dxt3:  case VtfImageFormat.Dxt5:  	if (width < 4 && width > 0)  		width = 4;  	if (height < 4 && height > 0)  		height = 4;  	return ((width + 3) / 4) * ((height + 3) / 4) * 16 * depth;  default:  	return width * height * depth * GetImageFormatInfo (imageFormat).BytesPerPixel;  }  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,ComputeImageSize,The following statement contains a magic number: if (width < 4 && width > 0)  	width = 4;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,ComputeImageSize,The following statement contains a magic number: if (width < 4 && width > 0)  	width = 4;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,ComputeImageSize,The following statement contains a magic number: width = 4;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,ComputeImageSize,The following statement contains a magic number: if (height < 4 && height > 0)  	height = 4;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,ComputeImageSize,The following statement contains a magic number: if (height < 4 && height > 0)  	height = 4;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,ComputeImageSize,The following statement contains a magic number: height = 4;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,ComputeImageSize,The following statement contains a magic number: return ((width + 3) / 4) * ((height + 3) / 4) * 8 * depth;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,ComputeImageSize,The following statement contains a magic number: return ((width + 3) / 4) * ((height + 3) / 4) * 8 * depth;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,ComputeImageSize,The following statement contains a magic number: return ((width + 3) / 4) * ((height + 3) / 4) * 8 * depth;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,ComputeImageSize,The following statement contains a magic number: return ((width + 3) / 4) * ((height + 3) / 4) * 8 * depth;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,ComputeImageSize,The following statement contains a magic number: return ((width + 3) / 4) * ((height + 3) / 4) * 8 * depth;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,ComputeImageSize,The following statement contains a magic number: if (width < 4 && width > 0)  	width = 4;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,ComputeImageSize,The following statement contains a magic number: if (width < 4 && width > 0)  	width = 4;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,ComputeImageSize,The following statement contains a magic number: width = 4;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,ComputeImageSize,The following statement contains a magic number: if (height < 4 && height > 0)  	height = 4;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,ComputeImageSize,The following statement contains a magic number: if (height < 4 && height > 0)  	height = 4;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,ComputeImageSize,The following statement contains a magic number: height = 4;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,ComputeImageSize,The following statement contains a magic number: return ((width + 3) / 4) * ((height + 3) / 4) * 16 * depth;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,ComputeImageSize,The following statement contains a magic number: return ((width + 3) / 4) * ((height + 3) / 4) * 16 * depth;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,ComputeImageSize,The following statement contains a magic number: return ((width + 3) / 4) * ((height + 3) / 4) * 16 * depth;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,ComputeImageSize,The following statement contains a magic number: return ((width + 3) / 4) * ((height + 3) / 4) * 16 * depth;  
Magic Number,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,ComputeImageSize,The following statement contains a magic number: return ((width + 3) / 4) * ((height + 3) / 4) * 16 * depth;  
Missing Default,Sledge.Providers.GameData,FgdProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\GameData\FgdProvider.cs,ParseAt,The following switch statement is missing a default case: switch (iterator.Current.Value) {  case "readonly":  	prop.ReadOnly = true;  	iterator.MoveNext ();  	break;  case "report":  	prop.ShowInEntityReport = true;  	iterator.MoveNext ();  	break;  }  
Missing Default,Sledge.Providers.Map,ObjProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Map\ObjProvider.cs,Read,The following switch statement is missing a default case: switch (keyword.ToLower ()) {  // Things I care about  case "v":  	// geometric vertices  	points.Add (Coordinate.Parse (vals [0]' vals [1]' vals [2]) * scale);  	break;  case "f":  	// face  	faces.Add (new ObjFace (currentGroup' vals.Select (x => ParseFaceIndex (points' x))));  	break;  case "g":  	// group name  	currentGroup = (values ?? "").Trim ();  	break;  // Things I don't care about  #region Not Implemented  // Vertex data  // "v"  case "vt":  	// texture vertices  	break;  case "vn":  	// vertex normals  	break;  case "vp":  // parameter space vertices  case "cstype":  // rational or non-rational forms of curve or surface type: basis matrix' Bezier' B-spline' Cardinal' Taylor  case "degree":  // degree  case "bmat":  // basis matrix  case "step":  	// step size  	// not supported  	break;  // Elements  // "f"  case "p":  // point  case "l":  // line  case "curv":  // curve  case "curv2":  // 2D curve  case "surf":  	// surface  	// not supported  	break;  // Free-form curve/surface body statements  case "parm":  // parameter name  case "trim":  // outer trimming loop (trim)  case "hole":  // inner trimming loop (hole)  case "scrv":  // special curve (scrv)  case "sp":  // special point (sp)  case "end":  	// end statement (end)  	// not supported  	break;  // Connectivity between free-form surfaces  case "con":  	// connect  	// not supported  	break;  // Grouping  // "g"  case "s":  	// smoothing group  	break;  case "mg":  	// merging group  	break;  case "o":  	// object name  	// not supported  	break;  // Display/render attributes  case "mtllib":  // material library  case "usemtl":  // material name  case "usemap":  // texture map name  case "bevel":  // bevel interpolation  case "c_interp":  // color interpolation  case "d_interp":  // dissolve interpolation  case "lod":  // level of detail  case "shadow_obj":  // shadow casting  case "trace_obj":  // ray tracing  case "ctech":  // curve approximation technique  case "stech":  	// surface approximation technique  	// not relevant  	break;  #endregion  }  
Missing Default,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,GetImage,The following switch statement is missing a default case: switch (type) {  case 0x01:  	// Low res image  	thumbnailPos = data;  	break;  case 0x30:  	// Regular image  	dataPos = data;  	break;  }  
Missing Default,Sledge.Providers.Texture.Vtf,VtfProvider,F:\newReposMay17\LogicAndTrick_sledge\Sledge.Providers\Texture\Vtf\VtfProvider.cs,LoadImage,The following switch statement is missing a default case: switch (format) {  case VtfImageFormat.Rgba8888:  	TransformBytes (buffer' br' width' height' 4' 3' 0' 1' 2' false);  	break;  case VtfImageFormat.Abgr8888:  	TransformBytes (buffer' br' width' height' 4' 0' 3' 2' 1' false);  	break;  case VtfImageFormat.Rgb888:  	TransformBytes (buffer' br' width' height' 3' -1' 0' 1' 2' false);  	break;  case VtfImageFormat.Bgr888:  	TransformBytes (buffer' br' width' height' 3' -1' 2' 1' 0' false);  	break;  case VtfImageFormat.Rgb565:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.I8:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Ia88:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.P8:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.A8:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgb888Bluescreen:  	TransformBytes (buffer' br' width' height' 3' -1' 0' 1' 2' true);  	break;  case VtfImageFormat.Bgr888Bluescreen:  	TransformBytes (buffer' br' width' height' 3' -1' 2' 1' 0' true);  	break;  case VtfImageFormat.Argb8888:  	TransformBytes (buffer' br' width' height' 4' 0' 1' 2' 3' false);  	break;  case VtfImageFormat.Bgra8888:  	br.Read (buffer' 0' buffer.Length);  	break;  case VtfImageFormat.Dxt1:  case VtfImageFormat.Dxt1Onebitalpha:  	DecompressDxt1 (buffer' br' width' height);  	break;  case VtfImageFormat.Dxt3:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Dxt5:  	DecompressDxt5 (buffer' br' width' height);  	break;  case VtfImageFormat.Bgrx8888:  	TransformBytes (buffer' br' width' height' 4' -1' 2' 1' 0' false);  	break;  case VtfImageFormat.Bgr565:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Bgrx5551:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Bgra4444:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Bgra5551:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Uv88:  	TransformBytes (buffer' br' width' height' 2' -1' 0' 1' -1' false);  	break;  case VtfImageFormat.Uvwq8888:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgba16161616F:  	TransformRgba16161616F (buffer' br' width' height);  	break;  case VtfImageFormat.Rgba16161616:  	TransformShorts (buffer' br' width' height' 8' 3' 0' 1' 2);  	break;  case VtfImageFormat.Uvlx8888:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.R32F:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgb323232F:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Rgba32323232F:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvDst16:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvDst24:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvIntz:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvRawz:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.AtiDst16:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.AtiDst24:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.NvNull:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Ati2N:  	throw new NotImplementedException ();  	break;  case VtfImageFormat.Ati1N:  	throw new NotImplementedException ();  	break;  }  
