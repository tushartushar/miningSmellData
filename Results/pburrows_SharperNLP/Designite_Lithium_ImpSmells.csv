Implementation smell,Namespace,Class,File,Method,Description
Long Method,Netron.Lithium,GraphSerializer,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\IO\GraphSerializer.cs,Deserialize,The method has 102 lines of code.
Complex Method,Netron.Lithium,Connection,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Paint,Cyclomatic complexity of the method is 8
Complex Method,Netron.Lithium,Connection,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Hit,Cyclomatic complexity of the method is 8
Complex Method,Netron.Lithium,GraphSerializer,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\IO\GraphSerializer.cs,Deserialize,Cyclomatic complexity of the method is 17
Complex Method,Netron.Lithium,LithiumControl,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,OnMouseDown,Cyclomatic complexity of the method is 13
Complex Method,Netron.Lithium,LithiumControl,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,OnMouseMove,Cyclomatic complexity of the method is 12
Complex Method,Netron.Lithium,LithiumControl,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,DrawTree,Cyclomatic complexity of the method is 10
Complex Method,Netron.Lithium,LithiumControl,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,VerticalDrawTree,Cyclomatic complexity of the method is 9
Long Statement,Netron.Lithium,ShapeBase,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\ShapeBase.cs,Fit,The length of the statement  "				//rectangle.Width =s.Width +10 + this.childNodes.Count.ToString().Length*5 +5; //the last part is to addition for the '[child count]' part " is 138.
Long Statement,Netron.Lithium,SimpleRectangle,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The length of the statement  "				g.DrawLine(blackPen' (toggleNode.X + 2)' (toggleNode.Y + (toggleNode.Height / 2))' (toggleNode.X + (toggleNode.Width - 2))' (toggleNode.Y + (toggleNode.Height / 2)) ); " is 167.
Long Statement,Netron.Lithium,SimpleRectangle,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The length of the statement  "					g.DrawLine(blackPen' (toggleNode.X + (toggleNode.Width /2))' (toggleNode.Y + 2)' (toggleNode.X + (toggleNode.Width /2))' (toggleNode.Y + (toggleNode.Height - 2))); " is 163.
Long Statement,Netron.Lithium,LithiumControl,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,OnPaintBackground,The length of the statement  "//			g.DrawString("Lithium Tree Layout Control [version " + System.Reflection.Assembly.GetExecutingAssembly().GetName().Version.ToString() + "]"'Font'Brushes.SlateGray'new Point(20'10)); " is 186.
Long Statement,Netron.Lithium,LithiumControl,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,VerticalDrawTree,The length of the statement  "					returned = VerticalDrawTree(containerNode.childNodes[i]' isFirst' shiftLeft + childrenWidth' shiftTop + verticalDelta );									 " is 120.
Long Statement,Netron.Lithium,LithiumControl,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,VerticalDrawTree,The length of the statement  "				childrenWidth=Math.Max(Convert.ToInt32(childrenWidth + (containerNode.Width-childrenWidth)/2)' childrenWidth); //in case the length of the containerNode is bigger than the total length of the children " is 200.
Long Statement,Netron.Lithium,LithiumControl,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,VerticalDrawTree,The length of the statement  "					float lastChild = containerNode.childNodes[containerNode.childNodes.Count-1].Left + containerNode.childNodes[containerNode.childNodes.Count-1].Width/2; " is 151.
Long Statement,Netron.Lithium,LithiumControl,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,HorizontalDrawTree,The length of the statement  "					returned = HorizontalDrawTree(containerNode.childNodes[i]' isFirst' shiftLeft + horizontalDelta ' shiftTop + childrenHeight );					 " is 126.
Complex Conditional,Netron.Lithium,ConnectionCollection,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Collections\ConnectionCollection.cs,Remove,The conditional expression  "(this[k].From ==one && this[k].To==two) || (this[k].From ==two && this[k].To==one)"  is complex.
Complex Conditional,Netron.Lithium,LithiumControl,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,SeekNewParent,The conditional expression  "other!=shape && other.visible && other.parentNode!=shape && !other.pickup"  is complex.
Magic Number,Netron.Lithium,Connection,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Paint,The following statement contains a magic number: switch(site.ConnectionType)  				{  					case ConnectionType.Default:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top);   							p2 = new PointF(to.Left + to.Width/2' to.Bottom+5);  							g.DrawLine(pen'p1'p2);  							break;  						case TreeDirection.Horizontal:  							p1 = new PointF(from.Left' from.Top +  from.Height/2);   							p2 = new PointF(to.Right +4' to.Top + to.Height/2);  							g.DrawLine(pen'p1'p2);  							break;  					}  						break;  					case ConnectionType.Traditional:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p2 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  					}  						break;  					  					case ConnectionType.Bezier:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left+from.Width/2'from.Top);  							p2 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p3 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							p4 = new PointF(to.Left+to.Width/2'to.Bottom);  							g.DrawBezier(pen' p1' p2' p3' p4);  							  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right' to.Top + to.Height/2); 							  							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							p3 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p4 = new PointF(from.Left'from.Top + from.Height/2);  							g.DrawBezier(pen' p1' p2' p3' p4);  							break;  					}  						break;  				}
Magic Number,Netron.Lithium,Connection,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Paint,The following statement contains a magic number: switch(site.ConnectionType)  				{  					case ConnectionType.Default:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top);   							p2 = new PointF(to.Left + to.Width/2' to.Bottom+5);  							g.DrawLine(pen'p1'p2);  							break;  						case TreeDirection.Horizontal:  							p1 = new PointF(from.Left' from.Top +  from.Height/2);   							p2 = new PointF(to.Right +4' to.Top + to.Height/2);  							g.DrawLine(pen'p1'p2);  							break;  					}  						break;  					case ConnectionType.Traditional:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p2 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  					}  						break;  					  					case ConnectionType.Bezier:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left+from.Width/2'from.Top);  							p2 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p3 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							p4 = new PointF(to.Left+to.Width/2'to.Bottom);  							g.DrawBezier(pen' p1' p2' p3' p4);  							  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right' to.Top + to.Height/2); 							  							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							p3 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p4 = new PointF(from.Left'from.Top + from.Height/2);  							g.DrawBezier(pen' p1' p2' p3' p4);  							break;  					}  						break;  				}
Magic Number,Netron.Lithium,Connection,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Paint,The following statement contains a magic number: switch(site.ConnectionType)  				{  					case ConnectionType.Default:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top);   							p2 = new PointF(to.Left + to.Width/2' to.Bottom+5);  							g.DrawLine(pen'p1'p2);  							break;  						case TreeDirection.Horizontal:  							p1 = new PointF(from.Left' from.Top +  from.Height/2);   							p2 = new PointF(to.Right +4' to.Top + to.Height/2);  							g.DrawLine(pen'p1'p2);  							break;  					}  						break;  					case ConnectionType.Traditional:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p2 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  					}  						break;  					  					case ConnectionType.Bezier:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left+from.Width/2'from.Top);  							p2 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p3 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							p4 = new PointF(to.Left+to.Width/2'to.Bottom);  							g.DrawBezier(pen' p1' p2' p3' p4);  							  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right' to.Top + to.Height/2); 							  							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							p3 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p4 = new PointF(from.Left'from.Top + from.Height/2);  							g.DrawBezier(pen' p1' p2' p3' p4);  							break;  					}  						break;  				}
Magic Number,Netron.Lithium,Connection,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Paint,The following statement contains a magic number: switch(site.ConnectionType)  				{  					case ConnectionType.Default:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top);   							p2 = new PointF(to.Left + to.Width/2' to.Bottom+5);  							g.DrawLine(pen'p1'p2);  							break;  						case TreeDirection.Horizontal:  							p1 = new PointF(from.Left' from.Top +  from.Height/2);   							p2 = new PointF(to.Right +4' to.Top + to.Height/2);  							g.DrawLine(pen'p1'p2);  							break;  					}  						break;  					case ConnectionType.Traditional:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p2 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  					}  						break;  					  					case ConnectionType.Bezier:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left+from.Width/2'from.Top);  							p2 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p3 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							p4 = new PointF(to.Left+to.Width/2'to.Bottom);  							g.DrawBezier(pen' p1' p2' p3' p4);  							  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right' to.Top + to.Height/2); 							  							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							p3 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p4 = new PointF(from.Left'from.Top + from.Height/2);  							g.DrawBezier(pen' p1' p2' p3' p4);  							break;  					}  						break;  				}
Magic Number,Netron.Lithium,Connection,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Paint,The following statement contains a magic number: switch(site.ConnectionType)  				{  					case ConnectionType.Default:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top);   							p2 = new PointF(to.Left + to.Width/2' to.Bottom+5);  							g.DrawLine(pen'p1'p2);  							break;  						case TreeDirection.Horizontal:  							p1 = new PointF(from.Left' from.Top +  from.Height/2);   							p2 = new PointF(to.Right +4' to.Top + to.Height/2);  							g.DrawLine(pen'p1'p2);  							break;  					}  						break;  					case ConnectionType.Traditional:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p2 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  					}  						break;  					  					case ConnectionType.Bezier:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left+from.Width/2'from.Top);  							p2 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p3 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							p4 = new PointF(to.Left+to.Width/2'to.Bottom);  							g.DrawBezier(pen' p1' p2' p3' p4);  							  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right' to.Top + to.Height/2); 							  							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							p3 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p4 = new PointF(from.Left'from.Top + from.Height/2);  							g.DrawBezier(pen' p1' p2' p3' p4);  							break;  					}  						break;  				}
Magic Number,Netron.Lithium,Connection,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Paint,The following statement contains a magic number: switch(site.ConnectionType)  				{  					case ConnectionType.Default:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top);   							p2 = new PointF(to.Left + to.Width/2' to.Bottom+5);  							g.DrawLine(pen'p1'p2);  							break;  						case TreeDirection.Horizontal:  							p1 = new PointF(from.Left' from.Top +  from.Height/2);   							p2 = new PointF(to.Right +4' to.Top + to.Height/2);  							g.DrawLine(pen'p1'p2);  							break;  					}  						break;  					case ConnectionType.Traditional:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p2 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  					}  						break;  					  					case ConnectionType.Bezier:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left+from.Width/2'from.Top);  							p2 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p3 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							p4 = new PointF(to.Left+to.Width/2'to.Bottom);  							g.DrawBezier(pen' p1' p2' p3' p4);  							  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right' to.Top + to.Height/2); 							  							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							p3 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p4 = new PointF(from.Left'from.Top + from.Height/2);  							g.DrawBezier(pen' p1' p2' p3' p4);  							break;  					}  						break;  				}
Magic Number,Netron.Lithium,Connection,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Paint,The following statement contains a magic number: switch(site.ConnectionType)  				{  					case ConnectionType.Default:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top);   							p2 = new PointF(to.Left + to.Width/2' to.Bottom+5);  							g.DrawLine(pen'p1'p2);  							break;  						case TreeDirection.Horizontal:  							p1 = new PointF(from.Left' from.Top +  from.Height/2);   							p2 = new PointF(to.Right +4' to.Top + to.Height/2);  							g.DrawLine(pen'p1'p2);  							break;  					}  						break;  					case ConnectionType.Traditional:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p2 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  					}  						break;  					  					case ConnectionType.Bezier:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left+from.Width/2'from.Top);  							p2 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p3 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							p4 = new PointF(to.Left+to.Width/2'to.Bottom);  							g.DrawBezier(pen' p1' p2' p3' p4);  							  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right' to.Top + to.Height/2); 							  							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							p3 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p4 = new PointF(from.Left'from.Top + from.Height/2);  							g.DrawBezier(pen' p1' p2' p3' p4);  							break;  					}  						break;  				}
Magic Number,Netron.Lithium,Connection,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Paint,The following statement contains a magic number: switch(site.ConnectionType)  				{  					case ConnectionType.Default:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top);   							p2 = new PointF(to.Left + to.Width/2' to.Bottom+5);  							g.DrawLine(pen'p1'p2);  							break;  						case TreeDirection.Horizontal:  							p1 = new PointF(from.Left' from.Top +  from.Height/2);   							p2 = new PointF(to.Right +4' to.Top + to.Height/2);  							g.DrawLine(pen'p1'p2);  							break;  					}  						break;  					case ConnectionType.Traditional:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p2 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  					}  						break;  					  					case ConnectionType.Bezier:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left+from.Width/2'from.Top);  							p2 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p3 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							p4 = new PointF(to.Left+to.Width/2'to.Bottom);  							g.DrawBezier(pen' p1' p2' p3' p4);  							  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right' to.Top + to.Height/2); 							  							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							p3 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p4 = new PointF(from.Left'from.Top + from.Height/2);  							g.DrawBezier(pen' p1' p2' p3' p4);  							break;  					}  						break;  				}
Magic Number,Netron.Lithium,Connection,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Paint,The following statement contains a magic number: switch(site.ConnectionType)  				{  					case ConnectionType.Default:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top);   							p2 = new PointF(to.Left + to.Width/2' to.Bottom+5);  							g.DrawLine(pen'p1'p2);  							break;  						case TreeDirection.Horizontal:  							p1 = new PointF(from.Left' from.Top +  from.Height/2);   							p2 = new PointF(to.Right +4' to.Top + to.Height/2);  							g.DrawLine(pen'p1'p2);  							break;  					}  						break;  					case ConnectionType.Traditional:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p2 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  					}  						break;  					  					case ConnectionType.Bezier:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left+from.Width/2'from.Top);  							p2 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p3 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							p4 = new PointF(to.Left+to.Width/2'to.Bottom);  							g.DrawBezier(pen' p1' p2' p3' p4);  							  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right' to.Top + to.Height/2); 							  							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							p3 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p4 = new PointF(from.Left'from.Top + from.Height/2);  							g.DrawBezier(pen' p1' p2' p3' p4);  							break;  					}  						break;  				}
Magic Number,Netron.Lithium,Connection,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Paint,The following statement contains a magic number: switch(site.ConnectionType)  				{  					case ConnectionType.Default:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top);   							p2 = new PointF(to.Left + to.Width/2' to.Bottom+5);  							g.DrawLine(pen'p1'p2);  							break;  						case TreeDirection.Horizontal:  							p1 = new PointF(from.Left' from.Top +  from.Height/2);   							p2 = new PointF(to.Right +4' to.Top + to.Height/2);  							g.DrawLine(pen'p1'p2);  							break;  					}  						break;  					case ConnectionType.Traditional:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p2 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  					}  						break;  					  					case ConnectionType.Bezier:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left+from.Width/2'from.Top);  							p2 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p3 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							p4 = new PointF(to.Left+to.Width/2'to.Bottom);  							g.DrawBezier(pen' p1' p2' p3' p4);  							  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right' to.Top + to.Height/2); 							  							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							p3 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p4 = new PointF(from.Left'from.Top + from.Height/2);  							g.DrawBezier(pen' p1' p2' p3' p4);  							break;  					}  						break;  				}
Magic Number,Netron.Lithium,Connection,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Paint,The following statement contains a magic number: switch(site.ConnectionType)  				{  					case ConnectionType.Default:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top);   							p2 = new PointF(to.Left + to.Width/2' to.Bottom+5);  							g.DrawLine(pen'p1'p2);  							break;  						case TreeDirection.Horizontal:  							p1 = new PointF(from.Left' from.Top +  from.Height/2);   							p2 = new PointF(to.Right +4' to.Top + to.Height/2);  							g.DrawLine(pen'p1'p2);  							break;  					}  						break;  					case ConnectionType.Traditional:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p2 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  					}  						break;  					  					case ConnectionType.Bezier:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left+from.Width/2'from.Top);  							p2 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p3 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							p4 = new PointF(to.Left+to.Width/2'to.Bottom);  							g.DrawBezier(pen' p1' p2' p3' p4);  							  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right' to.Top + to.Height/2); 							  							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							p3 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p4 = new PointF(from.Left'from.Top + from.Height/2);  							g.DrawBezier(pen' p1' p2' p3' p4);  							break;  					}  						break;  				}
Magic Number,Netron.Lithium,Connection,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Paint,The following statement contains a magic number: switch(site.ConnectionType)  				{  					case ConnectionType.Default:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top);   							p2 = new PointF(to.Left + to.Width/2' to.Bottom+5);  							g.DrawLine(pen'p1'p2);  							break;  						case TreeDirection.Horizontal:  							p1 = new PointF(from.Left' from.Top +  from.Height/2);   							p2 = new PointF(to.Right +4' to.Top + to.Height/2);  							g.DrawLine(pen'p1'p2);  							break;  					}  						break;  					case ConnectionType.Traditional:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p2 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  					}  						break;  					  					case ConnectionType.Bezier:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left+from.Width/2'from.Top);  							p2 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p3 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							p4 = new PointF(to.Left+to.Width/2'to.Bottom);  							g.DrawBezier(pen' p1' p2' p3' p4);  							  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right' to.Top + to.Height/2); 							  							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							p3 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p4 = new PointF(from.Left'from.Top + from.Height/2);  							g.DrawBezier(pen' p1' p2' p3' p4);  							break;  					}  						break;  				}
Magic Number,Netron.Lithium,Connection,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Paint,The following statement contains a magic number: switch(site.ConnectionType)  				{  					case ConnectionType.Default:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top);   							p2 = new PointF(to.Left + to.Width/2' to.Bottom+5);  							g.DrawLine(pen'p1'p2);  							break;  						case TreeDirection.Horizontal:  							p1 = new PointF(from.Left' from.Top +  from.Height/2);   							p2 = new PointF(to.Right +4' to.Top + to.Height/2);  							g.DrawLine(pen'p1'p2);  							break;  					}  						break;  					case ConnectionType.Traditional:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p2 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  					}  						break;  					  					case ConnectionType.Bezier:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left+from.Width/2'from.Top);  							p2 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p3 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							p4 = new PointF(to.Left+to.Width/2'to.Bottom);  							g.DrawBezier(pen' p1' p2' p3' p4);  							  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right' to.Top + to.Height/2); 							  							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							p3 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p4 = new PointF(from.Left'from.Top + from.Height/2);  							g.DrawBezier(pen' p1' p2' p3' p4);  							break;  					}  						break;  				}
Magic Number,Netron.Lithium,Connection,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Paint,The following statement contains a magic number: switch(site.ConnectionType)  				{  					case ConnectionType.Default:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top);   							p2 = new PointF(to.Left + to.Width/2' to.Bottom+5);  							g.DrawLine(pen'p1'p2);  							break;  						case TreeDirection.Horizontal:  							p1 = new PointF(from.Left' from.Top +  from.Height/2);   							p2 = new PointF(to.Right +4' to.Top + to.Height/2);  							g.DrawLine(pen'p1'p2);  							break;  					}  						break;  					case ConnectionType.Traditional:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p2 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  					}  						break;  					  					case ConnectionType.Bezier:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left+from.Width/2'from.Top);  							p2 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p3 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							p4 = new PointF(to.Left+to.Width/2'to.Bottom);  							g.DrawBezier(pen' p1' p2' p3' p4);  							  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right' to.Top + to.Height/2); 							  							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							p3 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p4 = new PointF(from.Left'from.Top + from.Height/2);  							g.DrawBezier(pen' p1' p2' p3' p4);  							break;  					}  						break;  				}
Magic Number,Netron.Lithium,Connection,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Paint,The following statement contains a magic number: switch(site.ConnectionType)  				{  					case ConnectionType.Default:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top);   							p2 = new PointF(to.Left + to.Width/2' to.Bottom+5);  							g.DrawLine(pen'p1'p2);  							break;  						case TreeDirection.Horizontal:  							p1 = new PointF(from.Left' from.Top +  from.Height/2);   							p2 = new PointF(to.Right +4' to.Top + to.Height/2);  							g.DrawLine(pen'p1'p2);  							break;  					}  						break;  					case ConnectionType.Traditional:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p2 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  					}  						break;  					  					case ConnectionType.Bezier:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left+from.Width/2'from.Top);  							p2 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p3 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							p4 = new PointF(to.Left+to.Width/2'to.Bottom);  							g.DrawBezier(pen' p1' p2' p3' p4);  							  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right' to.Top + to.Height/2); 							  							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							p3 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p4 = new PointF(from.Left'from.Top + from.Height/2);  							g.DrawBezier(pen' p1' p2' p3' p4);  							break;  					}  						break;  				}
Magic Number,Netron.Lithium,Connection,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Paint,The following statement contains a magic number: switch(site.ConnectionType)  				{  					case ConnectionType.Default:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top);   							p2 = new PointF(to.Left + to.Width/2' to.Bottom+5);  							g.DrawLine(pen'p1'p2);  							break;  						case TreeDirection.Horizontal:  							p1 = new PointF(from.Left' from.Top +  from.Height/2);   							p2 = new PointF(to.Right +4' to.Top + to.Height/2);  							g.DrawLine(pen'p1'p2);  							break;  					}  						break;  					case ConnectionType.Traditional:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p2 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  					}  						break;  					  					case ConnectionType.Bezier:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left+from.Width/2'from.Top);  							p2 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p3 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							p4 = new PointF(to.Left+to.Width/2'to.Bottom);  							g.DrawBezier(pen' p1' p2' p3' p4);  							  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right' to.Top + to.Height/2); 							  							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							p3 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p4 = new PointF(from.Left'from.Top + from.Height/2);  							g.DrawBezier(pen' p1' p2' p3' p4);  							break;  					}  						break;  				}
Magic Number,Netron.Lithium,Connection,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Paint,The following statement contains a magic number: switch(site.ConnectionType)  				{  					case ConnectionType.Default:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top);   							p2 = new PointF(to.Left + to.Width/2' to.Bottom+5);  							g.DrawLine(pen'p1'p2);  							break;  						case TreeDirection.Horizontal:  							p1 = new PointF(from.Left' from.Top +  from.Height/2);   							p2 = new PointF(to.Right +4' to.Top + to.Height/2);  							g.DrawLine(pen'p1'p2);  							break;  					}  						break;  					case ConnectionType.Traditional:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p2 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  					}  						break;  					  					case ConnectionType.Bezier:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left+from.Width/2'from.Top);  							p2 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p3 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							p4 = new PointF(to.Left+to.Width/2'to.Bottom);  							g.DrawBezier(pen' p1' p2' p3' p4);  							  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right' to.Top + to.Height/2); 							  							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							p3 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p4 = new PointF(from.Left'from.Top + from.Height/2);  							g.DrawBezier(pen' p1' p2' p3' p4);  							break;  					}  						break;  				}
Magic Number,Netron.Lithium,Connection,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Paint,The following statement contains a magic number: switch(site.ConnectionType)  				{  					case ConnectionType.Default:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top);   							p2 = new PointF(to.Left + to.Width/2' to.Bottom+5);  							g.DrawLine(pen'p1'p2);  							break;  						case TreeDirection.Horizontal:  							p1 = new PointF(from.Left' from.Top +  from.Height/2);   							p2 = new PointF(to.Right +4' to.Top + to.Height/2);  							g.DrawLine(pen'p1'p2);  							break;  					}  						break;  					case ConnectionType.Traditional:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p2 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  					}  						break;  					  					case ConnectionType.Bezier:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left+from.Width/2'from.Top);  							p2 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p3 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							p4 = new PointF(to.Left+to.Width/2'to.Bottom);  							g.DrawBezier(pen' p1' p2' p3' p4);  							  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right' to.Top + to.Height/2); 							  							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							p3 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p4 = new PointF(from.Left'from.Top + from.Height/2);  							g.DrawBezier(pen' p1' p2' p3' p4);  							break;  					}  						break;  				}
Magic Number,Netron.Lithium,Connection,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Paint,The following statement contains a magic number: switch(site.ConnectionType)  				{  					case ConnectionType.Default:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top);   							p2 = new PointF(to.Left + to.Width/2' to.Bottom+5);  							g.DrawLine(pen'p1'p2);  							break;  						case TreeDirection.Horizontal:  							p1 = new PointF(from.Left' from.Top +  from.Height/2);   							p2 = new PointF(to.Right +4' to.Top + to.Height/2);  							g.DrawLine(pen'p1'p2);  							break;  					}  						break;  					case ConnectionType.Traditional:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p2 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  					}  						break;  					  					case ConnectionType.Bezier:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left+from.Width/2'from.Top);  							p2 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p3 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							p4 = new PointF(to.Left+to.Width/2'to.Bottom);  							g.DrawBezier(pen' p1' p2' p3' p4);  							  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right' to.Top + to.Height/2); 							  							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							p3 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p4 = new PointF(from.Left'from.Top + from.Height/2);  							g.DrawBezier(pen' p1' p2' p3' p4);  							break;  					}  						break;  				}
Magic Number,Netron.Lithium,Connection,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Paint,The following statement contains a magic number: switch(site.ConnectionType)  				{  					case ConnectionType.Default:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top);   							p2 = new PointF(to.Left + to.Width/2' to.Bottom+5);  							g.DrawLine(pen'p1'p2);  							break;  						case TreeDirection.Horizontal:  							p1 = new PointF(from.Left' from.Top +  from.Height/2);   							p2 = new PointF(to.Right +4' to.Top + to.Height/2);  							g.DrawLine(pen'p1'p2);  							break;  					}  						break;  					case ConnectionType.Traditional:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p2 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  					}  						break;  					  					case ConnectionType.Bezier:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left+from.Width/2'from.Top);  							p2 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p3 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							p4 = new PointF(to.Left+to.Width/2'to.Bottom);  							g.DrawBezier(pen' p1' p2' p3' p4);  							  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right' to.Top + to.Height/2); 							  							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							p3 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p4 = new PointF(from.Left'from.Top + from.Height/2);  							g.DrawBezier(pen' p1' p2' p3' p4);  							break;  					}  						break;  				}
Magic Number,Netron.Lithium,Connection,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Paint,The following statement contains a magic number: switch(site.ConnectionType)  				{  					case ConnectionType.Default:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top);   							p2 = new PointF(to.Left + to.Width/2' to.Bottom+5);  							g.DrawLine(pen'p1'p2);  							break;  						case TreeDirection.Horizontal:  							p1 = new PointF(from.Left' from.Top +  from.Height/2);   							p2 = new PointF(to.Right +4' to.Top + to.Height/2);  							g.DrawLine(pen'p1'p2);  							break;  					}  						break;  					case ConnectionType.Traditional:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p2 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  					}  						break;  					  					case ConnectionType.Bezier:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left+from.Width/2'from.Top);  							p2 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p3 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							p4 = new PointF(to.Left+to.Width/2'to.Bottom);  							g.DrawBezier(pen' p1' p2' p3' p4);  							  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right' to.Top + to.Height/2); 							  							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							p3 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p4 = new PointF(from.Left'from.Top + from.Height/2);  							g.DrawBezier(pen' p1' p2' p3' p4);  							break;  					}  						break;  				}
Magic Number,Netron.Lithium,Connection,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Paint,The following statement contains a magic number: switch(site.ConnectionType)  				{  					case ConnectionType.Default:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top);   							p2 = new PointF(to.Left + to.Width/2' to.Bottom+5);  							g.DrawLine(pen'p1'p2);  							break;  						case TreeDirection.Horizontal:  							p1 = new PointF(from.Left' from.Top +  from.Height/2);   							p2 = new PointF(to.Right +4' to.Top + to.Height/2);  							g.DrawLine(pen'p1'p2);  							break;  					}  						break;  					case ConnectionType.Traditional:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p2 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  					}  						break;  					  					case ConnectionType.Bezier:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left+from.Width/2'from.Top);  							p2 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p3 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							p4 = new PointF(to.Left+to.Width/2'to.Bottom);  							g.DrawBezier(pen' p1' p2' p3' p4);  							  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right' to.Top + to.Height/2); 							  							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							p3 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p4 = new PointF(from.Left'from.Top + from.Height/2);  							g.DrawBezier(pen' p1' p2' p3' p4);  							break;  					}  						break;  				}
Magic Number,Netron.Lithium,Connection,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Paint,The following statement contains a magic number: switch(site.ConnectionType)  				{  					case ConnectionType.Default:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top);   							p2 = new PointF(to.Left + to.Width/2' to.Bottom+5);  							g.DrawLine(pen'p1'p2);  							break;  						case TreeDirection.Horizontal:  							p1 = new PointF(from.Left' from.Top +  from.Height/2);   							p2 = new PointF(to.Right +4' to.Top + to.Height/2);  							g.DrawLine(pen'p1'p2);  							break;  					}  						break;  					case ConnectionType.Traditional:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p2 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  					}  						break;  					  					case ConnectionType.Bezier:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left+from.Width/2'from.Top);  							p2 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p3 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							p4 = new PointF(to.Left+to.Width/2'to.Bottom);  							g.DrawBezier(pen' p1' p2' p3' p4);  							  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right' to.Top + to.Height/2); 							  							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							p3 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p4 = new PointF(from.Left'from.Top + from.Height/2);  							g.DrawBezier(pen' p1' p2' p3' p4);  							break;  					}  						break;  				}
Magic Number,Netron.Lithium,Connection,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Paint,The following statement contains a magic number: switch(site.ConnectionType)  				{  					case ConnectionType.Default:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top);   							p2 = new PointF(to.Left + to.Width/2' to.Bottom+5);  							g.DrawLine(pen'p1'p2);  							break;  						case TreeDirection.Horizontal:  							p1 = new PointF(from.Left' from.Top +  from.Height/2);   							p2 = new PointF(to.Right +4' to.Top + to.Height/2);  							g.DrawLine(pen'p1'p2);  							break;  					}  						break;  					case ConnectionType.Traditional:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p2 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  					}  						break;  					  					case ConnectionType.Bezier:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left+from.Width/2'from.Top);  							p2 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p3 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							p4 = new PointF(to.Left+to.Width/2'to.Bottom);  							g.DrawBezier(pen' p1' p2' p3' p4);  							  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right' to.Top + to.Height/2); 							  							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							p3 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p4 = new PointF(from.Left'from.Top + from.Height/2);  							g.DrawBezier(pen' p1' p2' p3' p4);  							break;  					}  						break;  				}
Magic Number,Netron.Lithium,Connection,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Paint,The following statement contains a magic number: switch(site.ConnectionType)  				{  					case ConnectionType.Default:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top);   							p2 = new PointF(to.Left + to.Width/2' to.Bottom+5);  							g.DrawLine(pen'p1'p2);  							break;  						case TreeDirection.Horizontal:  							p1 = new PointF(from.Left' from.Top +  from.Height/2);   							p2 = new PointF(to.Right +4' to.Top + to.Height/2);  							g.DrawLine(pen'p1'p2);  							break;  					}  						break;  					case ConnectionType.Traditional:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p2 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  					}  						break;  					  					case ConnectionType.Bezier:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left+from.Width/2'from.Top);  							p2 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p3 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							p4 = new PointF(to.Left+to.Width/2'to.Bottom);  							g.DrawBezier(pen' p1' p2' p3' p4);  							  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right' to.Top + to.Height/2); 							  							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							p3 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p4 = new PointF(from.Left'from.Top + from.Height/2);  							g.DrawBezier(pen' p1' p2' p3' p4);  							break;  					}  						break;  				}
Magic Number,Netron.Lithium,Connection,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Paint,The following statement contains a magic number: switch(site.ConnectionType)  				{  					case ConnectionType.Default:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top);   							p2 = new PointF(to.Left + to.Width/2' to.Bottom+5);  							g.DrawLine(pen'p1'p2);  							break;  						case TreeDirection.Horizontal:  							p1 = new PointF(from.Left' from.Top +  from.Height/2);   							p2 = new PointF(to.Right +4' to.Top + to.Height/2);  							g.DrawLine(pen'p1'p2);  							break;  					}  						break;  					case ConnectionType.Traditional:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p2 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  					}  						break;  					  					case ConnectionType.Bezier:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left+from.Width/2'from.Top);  							p2 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p3 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							p4 = new PointF(to.Left+to.Width/2'to.Bottom);  							g.DrawBezier(pen' p1' p2' p3' p4);  							  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right' to.Top + to.Height/2); 							  							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							p3 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p4 = new PointF(from.Left'from.Top + from.Height/2);  							g.DrawBezier(pen' p1' p2' p3' p4);  							break;  					}  						break;  				}
Magic Number,Netron.Lithium,Connection,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Hit,The following statement contains a magic number: switch(site.ConnectionType)  			{  				case ConnectionType.Default:  					#region The default Hit method  					  					float o'u;  					p1 = start; p2 = end; 	 					// p1 must be the leftmost point. 					if (p1.X > p2.X) { s = p2; p2 = p1; p1 = s; }  					//this is specifically necessary when the layout works horizontally 					//the method beneth will not return true as should be in this case 					if(p1.Y==p2.Y) 					{ 						p1.Y+=-3; 						return new RectangleF(p1'new SizeF(p2.X-p1.X'6)).Contains(p); 					} 					r1 = new RectangleF(p1.X' p1.Y' 0' 0); 					r2 = new RectangleF(p2.X' p2.Y' 0' 0); 					r1.Inflate(3' 3); 					r2.Inflate(3' 3); 					//this is like a topological neighborhood 					//the connection is shifted left and right 					//and the point under consideration has to be in between.						 					if (RectangleF.Union(r1' r2).Contains(p)) 					{ 				 						if (p1.Y < p2.Y) //SWNE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							return ((p.X > o) && (p.X < u)); 						} 						else //NWSE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							return ((p.X > o) && (p.X < u)); 						} 					}  					#endregion  					break;  				case ConnectionType.Traditional:  					#region The rectangular Hit method  						switch(site.LayoutDirection)  						{  							case TreeDirection.Vertical:  								p1 = new PointF(from.Left + from.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5); //shift 5 to contain the connection  								p2 = new PointF(to.Left + to.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5);  								p3 = new Point(to.Left+to.Width/2-5'to.Bottom-5);    								r1 = new RectangleF(p1' new SizeF(10'(from.Top - to.Bottom)/2+5));   								if(p1.X<p2.X)  									r2 = new RectangleF(p1'new SizeF(p2.X-p1.X'10));  								else  									r2 = new RectangleF(p2'new SizeF(p1.X-p2.X'10));  								r3 = new RectangleF(p3' new SizeF(10' (from.Top - to.Bottom)/2+5));  								return r1.Contains(p.X'p.Y) || r2.Contains(p.X'p.Y) || r3.Contains(p.X'p.Y) ;  								  							case TreeDirection.Horizontal:    								p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   								p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							  								break;  						}  					#endregion  					break;  			}
Magic Number,Netron.Lithium,Connection,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Hit,The following statement contains a magic number: switch(site.ConnectionType)  			{  				case ConnectionType.Default:  					#region The default Hit method  					  					float o'u;  					p1 = start; p2 = end; 	 					// p1 must be the leftmost point. 					if (p1.X > p2.X) { s = p2; p2 = p1; p1 = s; }  					//this is specifically necessary when the layout works horizontally 					//the method beneth will not return true as should be in this case 					if(p1.Y==p2.Y) 					{ 						p1.Y+=-3; 						return new RectangleF(p1'new SizeF(p2.X-p1.X'6)).Contains(p); 					} 					r1 = new RectangleF(p1.X' p1.Y' 0' 0); 					r2 = new RectangleF(p2.X' p2.Y' 0' 0); 					r1.Inflate(3' 3); 					r2.Inflate(3' 3); 					//this is like a topological neighborhood 					//the connection is shifted left and right 					//and the point under consideration has to be in between.						 					if (RectangleF.Union(r1' r2).Contains(p)) 					{ 				 						if (p1.Y < p2.Y) //SWNE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							return ((p.X > o) && (p.X < u)); 						} 						else //NWSE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							return ((p.X > o) && (p.X < u)); 						} 					}  					#endregion  					break;  				case ConnectionType.Traditional:  					#region The rectangular Hit method  						switch(site.LayoutDirection)  						{  							case TreeDirection.Vertical:  								p1 = new PointF(from.Left + from.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5); //shift 5 to contain the connection  								p2 = new PointF(to.Left + to.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5);  								p3 = new Point(to.Left+to.Width/2-5'to.Bottom-5);    								r1 = new RectangleF(p1' new SizeF(10'(from.Top - to.Bottom)/2+5));   								if(p1.X<p2.X)  									r2 = new RectangleF(p1'new SizeF(p2.X-p1.X'10));  								else  									r2 = new RectangleF(p2'new SizeF(p1.X-p2.X'10));  								r3 = new RectangleF(p3' new SizeF(10' (from.Top - to.Bottom)/2+5));  								return r1.Contains(p.X'p.Y) || r2.Contains(p.X'p.Y) || r3.Contains(p.X'p.Y) ;  								  							case TreeDirection.Horizontal:    								p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   								p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							  								break;  						}  					#endregion  					break;  			}
Magic Number,Netron.Lithium,Connection,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Hit,The following statement contains a magic number: switch(site.ConnectionType)  			{  				case ConnectionType.Default:  					#region The default Hit method  					  					float o'u;  					p1 = start; p2 = end; 	 					// p1 must be the leftmost point. 					if (p1.X > p2.X) { s = p2; p2 = p1; p1 = s; }  					//this is specifically necessary when the layout works horizontally 					//the method beneth will not return true as should be in this case 					if(p1.Y==p2.Y) 					{ 						p1.Y+=-3; 						return new RectangleF(p1'new SizeF(p2.X-p1.X'6)).Contains(p); 					} 					r1 = new RectangleF(p1.X' p1.Y' 0' 0); 					r2 = new RectangleF(p2.X' p2.Y' 0' 0); 					r1.Inflate(3' 3); 					r2.Inflate(3' 3); 					//this is like a topological neighborhood 					//the connection is shifted left and right 					//and the point under consideration has to be in between.						 					if (RectangleF.Union(r1' r2).Contains(p)) 					{ 				 						if (p1.Y < p2.Y) //SWNE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							return ((p.X > o) && (p.X < u)); 						} 						else //NWSE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							return ((p.X > o) && (p.X < u)); 						} 					}  					#endregion  					break;  				case ConnectionType.Traditional:  					#region The rectangular Hit method  						switch(site.LayoutDirection)  						{  							case TreeDirection.Vertical:  								p1 = new PointF(from.Left + from.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5); //shift 5 to contain the connection  								p2 = new PointF(to.Left + to.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5);  								p3 = new Point(to.Left+to.Width/2-5'to.Bottom-5);    								r1 = new RectangleF(p1' new SizeF(10'(from.Top - to.Bottom)/2+5));   								if(p1.X<p2.X)  									r2 = new RectangleF(p1'new SizeF(p2.X-p1.X'10));  								else  									r2 = new RectangleF(p2'new SizeF(p1.X-p2.X'10));  								r3 = new RectangleF(p3' new SizeF(10' (from.Top - to.Bottom)/2+5));  								return r1.Contains(p.X'p.Y) || r2.Contains(p.X'p.Y) || r3.Contains(p.X'p.Y) ;  								  							case TreeDirection.Horizontal:    								p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   								p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							  								break;  						}  					#endregion  					break;  			}
Magic Number,Netron.Lithium,Connection,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Hit,The following statement contains a magic number: switch(site.ConnectionType)  			{  				case ConnectionType.Default:  					#region The default Hit method  					  					float o'u;  					p1 = start; p2 = end; 	 					// p1 must be the leftmost point. 					if (p1.X > p2.X) { s = p2; p2 = p1; p1 = s; }  					//this is specifically necessary when the layout works horizontally 					//the method beneth will not return true as should be in this case 					if(p1.Y==p2.Y) 					{ 						p1.Y+=-3; 						return new RectangleF(p1'new SizeF(p2.X-p1.X'6)).Contains(p); 					} 					r1 = new RectangleF(p1.X' p1.Y' 0' 0); 					r2 = new RectangleF(p2.X' p2.Y' 0' 0); 					r1.Inflate(3' 3); 					r2.Inflate(3' 3); 					//this is like a topological neighborhood 					//the connection is shifted left and right 					//and the point under consideration has to be in between.						 					if (RectangleF.Union(r1' r2).Contains(p)) 					{ 				 						if (p1.Y < p2.Y) //SWNE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							return ((p.X > o) && (p.X < u)); 						} 						else //NWSE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							return ((p.X > o) && (p.X < u)); 						} 					}  					#endregion  					break;  				case ConnectionType.Traditional:  					#region The rectangular Hit method  						switch(site.LayoutDirection)  						{  							case TreeDirection.Vertical:  								p1 = new PointF(from.Left + from.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5); //shift 5 to contain the connection  								p2 = new PointF(to.Left + to.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5);  								p3 = new Point(to.Left+to.Width/2-5'to.Bottom-5);    								r1 = new RectangleF(p1' new SizeF(10'(from.Top - to.Bottom)/2+5));   								if(p1.X<p2.X)  									r2 = new RectangleF(p1'new SizeF(p2.X-p1.X'10));  								else  									r2 = new RectangleF(p2'new SizeF(p1.X-p2.X'10));  								r3 = new RectangleF(p3' new SizeF(10' (from.Top - to.Bottom)/2+5));  								return r1.Contains(p.X'p.Y) || r2.Contains(p.X'p.Y) || r3.Contains(p.X'p.Y) ;  								  							case TreeDirection.Horizontal:    								p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   								p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							  								break;  						}  					#endregion  					break;  			}
Magic Number,Netron.Lithium,Connection,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Hit,The following statement contains a magic number: switch(site.ConnectionType)  			{  				case ConnectionType.Default:  					#region The default Hit method  					  					float o'u;  					p1 = start; p2 = end; 	 					// p1 must be the leftmost point. 					if (p1.X > p2.X) { s = p2; p2 = p1; p1 = s; }  					//this is specifically necessary when the layout works horizontally 					//the method beneth will not return true as should be in this case 					if(p1.Y==p2.Y) 					{ 						p1.Y+=-3; 						return new RectangleF(p1'new SizeF(p2.X-p1.X'6)).Contains(p); 					} 					r1 = new RectangleF(p1.X' p1.Y' 0' 0); 					r2 = new RectangleF(p2.X' p2.Y' 0' 0); 					r1.Inflate(3' 3); 					r2.Inflate(3' 3); 					//this is like a topological neighborhood 					//the connection is shifted left and right 					//and the point under consideration has to be in between.						 					if (RectangleF.Union(r1' r2).Contains(p)) 					{ 				 						if (p1.Y < p2.Y) //SWNE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							return ((p.X > o) && (p.X < u)); 						} 						else //NWSE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							return ((p.X > o) && (p.X < u)); 						} 					}  					#endregion  					break;  				case ConnectionType.Traditional:  					#region The rectangular Hit method  						switch(site.LayoutDirection)  						{  							case TreeDirection.Vertical:  								p1 = new PointF(from.Left + from.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5); //shift 5 to contain the connection  								p2 = new PointF(to.Left + to.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5);  								p3 = new Point(to.Left+to.Width/2-5'to.Bottom-5);    								r1 = new RectangleF(p1' new SizeF(10'(from.Top - to.Bottom)/2+5));   								if(p1.X<p2.X)  									r2 = new RectangleF(p1'new SizeF(p2.X-p1.X'10));  								else  									r2 = new RectangleF(p2'new SizeF(p1.X-p2.X'10));  								r3 = new RectangleF(p3' new SizeF(10' (from.Top - to.Bottom)/2+5));  								return r1.Contains(p.X'p.Y) || r2.Contains(p.X'p.Y) || r3.Contains(p.X'p.Y) ;  								  							case TreeDirection.Horizontal:    								p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   								p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							  								break;  						}  					#endregion  					break;  			}
Magic Number,Netron.Lithium,Connection,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Hit,The following statement contains a magic number: switch(site.ConnectionType)  			{  				case ConnectionType.Default:  					#region The default Hit method  					  					float o'u;  					p1 = start; p2 = end; 	 					// p1 must be the leftmost point. 					if (p1.X > p2.X) { s = p2; p2 = p1; p1 = s; }  					//this is specifically necessary when the layout works horizontally 					//the method beneth will not return true as should be in this case 					if(p1.Y==p2.Y) 					{ 						p1.Y+=-3; 						return new RectangleF(p1'new SizeF(p2.X-p1.X'6)).Contains(p); 					} 					r1 = new RectangleF(p1.X' p1.Y' 0' 0); 					r2 = new RectangleF(p2.X' p2.Y' 0' 0); 					r1.Inflate(3' 3); 					r2.Inflate(3' 3); 					//this is like a topological neighborhood 					//the connection is shifted left and right 					//and the point under consideration has to be in between.						 					if (RectangleF.Union(r1' r2).Contains(p)) 					{ 				 						if (p1.Y < p2.Y) //SWNE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							return ((p.X > o) && (p.X < u)); 						} 						else //NWSE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							return ((p.X > o) && (p.X < u)); 						} 					}  					#endregion  					break;  				case ConnectionType.Traditional:  					#region The rectangular Hit method  						switch(site.LayoutDirection)  						{  							case TreeDirection.Vertical:  								p1 = new PointF(from.Left + from.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5); //shift 5 to contain the connection  								p2 = new PointF(to.Left + to.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5);  								p3 = new Point(to.Left+to.Width/2-5'to.Bottom-5);    								r1 = new RectangleF(p1' new SizeF(10'(from.Top - to.Bottom)/2+5));   								if(p1.X<p2.X)  									r2 = new RectangleF(p1'new SizeF(p2.X-p1.X'10));  								else  									r2 = new RectangleF(p2'new SizeF(p1.X-p2.X'10));  								r3 = new RectangleF(p3' new SizeF(10' (from.Top - to.Bottom)/2+5));  								return r1.Contains(p.X'p.Y) || r2.Contains(p.X'p.Y) || r3.Contains(p.X'p.Y) ;  								  							case TreeDirection.Horizontal:    								p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   								p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							  								break;  						}  					#endregion  					break;  			}
Magic Number,Netron.Lithium,Connection,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Hit,The following statement contains a magic number: switch(site.ConnectionType)  			{  				case ConnectionType.Default:  					#region The default Hit method  					  					float o'u;  					p1 = start; p2 = end; 	 					// p1 must be the leftmost point. 					if (p1.X > p2.X) { s = p2; p2 = p1; p1 = s; }  					//this is specifically necessary when the layout works horizontally 					//the method beneth will not return true as should be in this case 					if(p1.Y==p2.Y) 					{ 						p1.Y+=-3; 						return new RectangleF(p1'new SizeF(p2.X-p1.X'6)).Contains(p); 					} 					r1 = new RectangleF(p1.X' p1.Y' 0' 0); 					r2 = new RectangleF(p2.X' p2.Y' 0' 0); 					r1.Inflate(3' 3); 					r2.Inflate(3' 3); 					//this is like a topological neighborhood 					//the connection is shifted left and right 					//and the point under consideration has to be in between.						 					if (RectangleF.Union(r1' r2).Contains(p)) 					{ 				 						if (p1.Y < p2.Y) //SWNE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							return ((p.X > o) && (p.X < u)); 						} 						else //NWSE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							return ((p.X > o) && (p.X < u)); 						} 					}  					#endregion  					break;  				case ConnectionType.Traditional:  					#region The rectangular Hit method  						switch(site.LayoutDirection)  						{  							case TreeDirection.Vertical:  								p1 = new PointF(from.Left + from.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5); //shift 5 to contain the connection  								p2 = new PointF(to.Left + to.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5);  								p3 = new Point(to.Left+to.Width/2-5'to.Bottom-5);    								r1 = new RectangleF(p1' new SizeF(10'(from.Top - to.Bottom)/2+5));   								if(p1.X<p2.X)  									r2 = new RectangleF(p1'new SizeF(p2.X-p1.X'10));  								else  									r2 = new RectangleF(p2'new SizeF(p1.X-p2.X'10));  								r3 = new RectangleF(p3' new SizeF(10' (from.Top - to.Bottom)/2+5));  								return r1.Contains(p.X'p.Y) || r2.Contains(p.X'p.Y) || r3.Contains(p.X'p.Y) ;  								  							case TreeDirection.Horizontal:    								p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   								p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							  								break;  						}  					#endregion  					break;  			}
Magic Number,Netron.Lithium,Connection,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Hit,The following statement contains a magic number: switch(site.ConnectionType)  			{  				case ConnectionType.Default:  					#region The default Hit method  					  					float o'u;  					p1 = start; p2 = end; 	 					// p1 must be the leftmost point. 					if (p1.X > p2.X) { s = p2; p2 = p1; p1 = s; }  					//this is specifically necessary when the layout works horizontally 					//the method beneth will not return true as should be in this case 					if(p1.Y==p2.Y) 					{ 						p1.Y+=-3; 						return new RectangleF(p1'new SizeF(p2.X-p1.X'6)).Contains(p); 					} 					r1 = new RectangleF(p1.X' p1.Y' 0' 0); 					r2 = new RectangleF(p2.X' p2.Y' 0' 0); 					r1.Inflate(3' 3); 					r2.Inflate(3' 3); 					//this is like a topological neighborhood 					//the connection is shifted left and right 					//and the point under consideration has to be in between.						 					if (RectangleF.Union(r1' r2).Contains(p)) 					{ 				 						if (p1.Y < p2.Y) //SWNE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							return ((p.X > o) && (p.X < u)); 						} 						else //NWSE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							return ((p.X > o) && (p.X < u)); 						} 					}  					#endregion  					break;  				case ConnectionType.Traditional:  					#region The rectangular Hit method  						switch(site.LayoutDirection)  						{  							case TreeDirection.Vertical:  								p1 = new PointF(from.Left + from.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5); //shift 5 to contain the connection  								p2 = new PointF(to.Left + to.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5);  								p3 = new Point(to.Left+to.Width/2-5'to.Bottom-5);    								r1 = new RectangleF(p1' new SizeF(10'(from.Top - to.Bottom)/2+5));   								if(p1.X<p2.X)  									r2 = new RectangleF(p1'new SizeF(p2.X-p1.X'10));  								else  									r2 = new RectangleF(p2'new SizeF(p1.X-p2.X'10));  								r3 = new RectangleF(p3' new SizeF(10' (from.Top - to.Bottom)/2+5));  								return r1.Contains(p.X'p.Y) || r2.Contains(p.X'p.Y) || r3.Contains(p.X'p.Y) ;  								  							case TreeDirection.Horizontal:    								p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   								p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							  								break;  						}  					#endregion  					break;  			}
Magic Number,Netron.Lithium,Connection,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Hit,The following statement contains a magic number: switch(site.ConnectionType)  			{  				case ConnectionType.Default:  					#region The default Hit method  					  					float o'u;  					p1 = start; p2 = end; 	 					// p1 must be the leftmost point. 					if (p1.X > p2.X) { s = p2; p2 = p1; p1 = s; }  					//this is specifically necessary when the layout works horizontally 					//the method beneth will not return true as should be in this case 					if(p1.Y==p2.Y) 					{ 						p1.Y+=-3; 						return new RectangleF(p1'new SizeF(p2.X-p1.X'6)).Contains(p); 					} 					r1 = new RectangleF(p1.X' p1.Y' 0' 0); 					r2 = new RectangleF(p2.X' p2.Y' 0' 0); 					r1.Inflate(3' 3); 					r2.Inflate(3' 3); 					//this is like a topological neighborhood 					//the connection is shifted left and right 					//and the point under consideration has to be in between.						 					if (RectangleF.Union(r1' r2).Contains(p)) 					{ 				 						if (p1.Y < p2.Y) //SWNE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							return ((p.X > o) && (p.X < u)); 						} 						else //NWSE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							return ((p.X > o) && (p.X < u)); 						} 					}  					#endregion  					break;  				case ConnectionType.Traditional:  					#region The rectangular Hit method  						switch(site.LayoutDirection)  						{  							case TreeDirection.Vertical:  								p1 = new PointF(from.Left + from.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5); //shift 5 to contain the connection  								p2 = new PointF(to.Left + to.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5);  								p3 = new Point(to.Left+to.Width/2-5'to.Bottom-5);    								r1 = new RectangleF(p1' new SizeF(10'(from.Top - to.Bottom)/2+5));   								if(p1.X<p2.X)  									r2 = new RectangleF(p1'new SizeF(p2.X-p1.X'10));  								else  									r2 = new RectangleF(p2'new SizeF(p1.X-p2.X'10));  								r3 = new RectangleF(p3' new SizeF(10' (from.Top - to.Bottom)/2+5));  								return r1.Contains(p.X'p.Y) || r2.Contains(p.X'p.Y) || r3.Contains(p.X'p.Y) ;  								  							case TreeDirection.Horizontal:    								p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   								p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							  								break;  						}  					#endregion  					break;  			}
Magic Number,Netron.Lithium,Connection,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Hit,The following statement contains a magic number: switch(site.ConnectionType)  			{  				case ConnectionType.Default:  					#region The default Hit method  					  					float o'u;  					p1 = start; p2 = end; 	 					// p1 must be the leftmost point. 					if (p1.X > p2.X) { s = p2; p2 = p1; p1 = s; }  					//this is specifically necessary when the layout works horizontally 					//the method beneth will not return true as should be in this case 					if(p1.Y==p2.Y) 					{ 						p1.Y+=-3; 						return new RectangleF(p1'new SizeF(p2.X-p1.X'6)).Contains(p); 					} 					r1 = new RectangleF(p1.X' p1.Y' 0' 0); 					r2 = new RectangleF(p2.X' p2.Y' 0' 0); 					r1.Inflate(3' 3); 					r2.Inflate(3' 3); 					//this is like a topological neighborhood 					//the connection is shifted left and right 					//and the point under consideration has to be in between.						 					if (RectangleF.Union(r1' r2).Contains(p)) 					{ 				 						if (p1.Y < p2.Y) //SWNE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							return ((p.X > o) && (p.X < u)); 						} 						else //NWSE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							return ((p.X > o) && (p.X < u)); 						} 					}  					#endregion  					break;  				case ConnectionType.Traditional:  					#region The rectangular Hit method  						switch(site.LayoutDirection)  						{  							case TreeDirection.Vertical:  								p1 = new PointF(from.Left + from.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5); //shift 5 to contain the connection  								p2 = new PointF(to.Left + to.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5);  								p3 = new Point(to.Left+to.Width/2-5'to.Bottom-5);    								r1 = new RectangleF(p1' new SizeF(10'(from.Top - to.Bottom)/2+5));   								if(p1.X<p2.X)  									r2 = new RectangleF(p1'new SizeF(p2.X-p1.X'10));  								else  									r2 = new RectangleF(p2'new SizeF(p1.X-p2.X'10));  								r3 = new RectangleF(p3' new SizeF(10' (from.Top - to.Bottom)/2+5));  								return r1.Contains(p.X'p.Y) || r2.Contains(p.X'p.Y) || r3.Contains(p.X'p.Y) ;  								  							case TreeDirection.Horizontal:    								p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   								p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							  								break;  						}  					#endregion  					break;  			}
Magic Number,Netron.Lithium,Connection,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Hit,The following statement contains a magic number: switch(site.ConnectionType)  			{  				case ConnectionType.Default:  					#region The default Hit method  					  					float o'u;  					p1 = start; p2 = end; 	 					// p1 must be the leftmost point. 					if (p1.X > p2.X) { s = p2; p2 = p1; p1 = s; }  					//this is specifically necessary when the layout works horizontally 					//the method beneth will not return true as should be in this case 					if(p1.Y==p2.Y) 					{ 						p1.Y+=-3; 						return new RectangleF(p1'new SizeF(p2.X-p1.X'6)).Contains(p); 					} 					r1 = new RectangleF(p1.X' p1.Y' 0' 0); 					r2 = new RectangleF(p2.X' p2.Y' 0' 0); 					r1.Inflate(3' 3); 					r2.Inflate(3' 3); 					//this is like a topological neighborhood 					//the connection is shifted left and right 					//and the point under consideration has to be in between.						 					if (RectangleF.Union(r1' r2).Contains(p)) 					{ 				 						if (p1.Y < p2.Y) //SWNE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							return ((p.X > o) && (p.X < u)); 						} 						else //NWSE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							return ((p.X > o) && (p.X < u)); 						} 					}  					#endregion  					break;  				case ConnectionType.Traditional:  					#region The rectangular Hit method  						switch(site.LayoutDirection)  						{  							case TreeDirection.Vertical:  								p1 = new PointF(from.Left + from.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5); //shift 5 to contain the connection  								p2 = new PointF(to.Left + to.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5);  								p3 = new Point(to.Left+to.Width/2-5'to.Bottom-5);    								r1 = new RectangleF(p1' new SizeF(10'(from.Top - to.Bottom)/2+5));   								if(p1.X<p2.X)  									r2 = new RectangleF(p1'new SizeF(p2.X-p1.X'10));  								else  									r2 = new RectangleF(p2'new SizeF(p1.X-p2.X'10));  								r3 = new RectangleF(p3' new SizeF(10' (from.Top - to.Bottom)/2+5));  								return r1.Contains(p.X'p.Y) || r2.Contains(p.X'p.Y) || r3.Contains(p.X'p.Y) ;  								  							case TreeDirection.Horizontal:    								p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   								p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							  								break;  						}  					#endregion  					break;  			}
Magic Number,Netron.Lithium,Connection,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Hit,The following statement contains a magic number: switch(site.ConnectionType)  			{  				case ConnectionType.Default:  					#region The default Hit method  					  					float o'u;  					p1 = start; p2 = end; 	 					// p1 must be the leftmost point. 					if (p1.X > p2.X) { s = p2; p2 = p1; p1 = s; }  					//this is specifically necessary when the layout works horizontally 					//the method beneth will not return true as should be in this case 					if(p1.Y==p2.Y) 					{ 						p1.Y+=-3; 						return new RectangleF(p1'new SizeF(p2.X-p1.X'6)).Contains(p); 					} 					r1 = new RectangleF(p1.X' p1.Y' 0' 0); 					r2 = new RectangleF(p2.X' p2.Y' 0' 0); 					r1.Inflate(3' 3); 					r2.Inflate(3' 3); 					//this is like a topological neighborhood 					//the connection is shifted left and right 					//and the point under consideration has to be in between.						 					if (RectangleF.Union(r1' r2).Contains(p)) 					{ 				 						if (p1.Y < p2.Y) //SWNE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							return ((p.X > o) && (p.X < u)); 						} 						else //NWSE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							return ((p.X > o) && (p.X < u)); 						} 					}  					#endregion  					break;  				case ConnectionType.Traditional:  					#region The rectangular Hit method  						switch(site.LayoutDirection)  						{  							case TreeDirection.Vertical:  								p1 = new PointF(from.Left + from.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5); //shift 5 to contain the connection  								p2 = new PointF(to.Left + to.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5);  								p3 = new Point(to.Left+to.Width/2-5'to.Bottom-5);    								r1 = new RectangleF(p1' new SizeF(10'(from.Top - to.Bottom)/2+5));   								if(p1.X<p2.X)  									r2 = new RectangleF(p1'new SizeF(p2.X-p1.X'10));  								else  									r2 = new RectangleF(p2'new SizeF(p1.X-p2.X'10));  								r3 = new RectangleF(p3' new SizeF(10' (from.Top - to.Bottom)/2+5));  								return r1.Contains(p.X'p.Y) || r2.Contains(p.X'p.Y) || r3.Contains(p.X'p.Y) ;  								  							case TreeDirection.Horizontal:    								p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   								p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							  								break;  						}  					#endregion  					break;  			}
Magic Number,Netron.Lithium,Connection,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Hit,The following statement contains a magic number: switch(site.ConnectionType)  			{  				case ConnectionType.Default:  					#region The default Hit method  					  					float o'u;  					p1 = start; p2 = end; 	 					// p1 must be the leftmost point. 					if (p1.X > p2.X) { s = p2; p2 = p1; p1 = s; }  					//this is specifically necessary when the layout works horizontally 					//the method beneth will not return true as should be in this case 					if(p1.Y==p2.Y) 					{ 						p1.Y+=-3; 						return new RectangleF(p1'new SizeF(p2.X-p1.X'6)).Contains(p); 					} 					r1 = new RectangleF(p1.X' p1.Y' 0' 0); 					r2 = new RectangleF(p2.X' p2.Y' 0' 0); 					r1.Inflate(3' 3); 					r2.Inflate(3' 3); 					//this is like a topological neighborhood 					//the connection is shifted left and right 					//and the point under consideration has to be in between.						 					if (RectangleF.Union(r1' r2).Contains(p)) 					{ 				 						if (p1.Y < p2.Y) //SWNE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							return ((p.X > o) && (p.X < u)); 						} 						else //NWSE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							return ((p.X > o) && (p.X < u)); 						} 					}  					#endregion  					break;  				case ConnectionType.Traditional:  					#region The rectangular Hit method  						switch(site.LayoutDirection)  						{  							case TreeDirection.Vertical:  								p1 = new PointF(from.Left + from.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5); //shift 5 to contain the connection  								p2 = new PointF(to.Left + to.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5);  								p3 = new Point(to.Left+to.Width/2-5'to.Bottom-5);    								r1 = new RectangleF(p1' new SizeF(10'(from.Top - to.Bottom)/2+5));   								if(p1.X<p2.X)  									r2 = new RectangleF(p1'new SizeF(p2.X-p1.X'10));  								else  									r2 = new RectangleF(p2'new SizeF(p1.X-p2.X'10));  								r3 = new RectangleF(p3' new SizeF(10' (from.Top - to.Bottom)/2+5));  								return r1.Contains(p.X'p.Y) || r2.Contains(p.X'p.Y) || r3.Contains(p.X'p.Y) ;  								  							case TreeDirection.Horizontal:    								p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   								p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							  								break;  						}  					#endregion  					break;  			}
Magic Number,Netron.Lithium,Connection,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Hit,The following statement contains a magic number: switch(site.ConnectionType)  			{  				case ConnectionType.Default:  					#region The default Hit method  					  					float o'u;  					p1 = start; p2 = end; 	 					// p1 must be the leftmost point. 					if (p1.X > p2.X) { s = p2; p2 = p1; p1 = s; }  					//this is specifically necessary when the layout works horizontally 					//the method beneth will not return true as should be in this case 					if(p1.Y==p2.Y) 					{ 						p1.Y+=-3; 						return new RectangleF(p1'new SizeF(p2.X-p1.X'6)).Contains(p); 					} 					r1 = new RectangleF(p1.X' p1.Y' 0' 0); 					r2 = new RectangleF(p2.X' p2.Y' 0' 0); 					r1.Inflate(3' 3); 					r2.Inflate(3' 3); 					//this is like a topological neighborhood 					//the connection is shifted left and right 					//and the point under consideration has to be in between.						 					if (RectangleF.Union(r1' r2).Contains(p)) 					{ 				 						if (p1.Y < p2.Y) //SWNE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							return ((p.X > o) && (p.X < u)); 						} 						else //NWSE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							return ((p.X > o) && (p.X < u)); 						} 					}  					#endregion  					break;  				case ConnectionType.Traditional:  					#region The rectangular Hit method  						switch(site.LayoutDirection)  						{  							case TreeDirection.Vertical:  								p1 = new PointF(from.Left + from.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5); //shift 5 to contain the connection  								p2 = new PointF(to.Left + to.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5);  								p3 = new Point(to.Left+to.Width/2-5'to.Bottom-5);    								r1 = new RectangleF(p1' new SizeF(10'(from.Top - to.Bottom)/2+5));   								if(p1.X<p2.X)  									r2 = new RectangleF(p1'new SizeF(p2.X-p1.X'10));  								else  									r2 = new RectangleF(p2'new SizeF(p1.X-p2.X'10));  								r3 = new RectangleF(p3' new SizeF(10' (from.Top - to.Bottom)/2+5));  								return r1.Contains(p.X'p.Y) || r2.Contains(p.X'p.Y) || r3.Contains(p.X'p.Y) ;  								  							case TreeDirection.Horizontal:    								p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   								p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							  								break;  						}  					#endregion  					break;  			}
Magic Number,Netron.Lithium,Connection,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Hit,The following statement contains a magic number: switch(site.ConnectionType)  			{  				case ConnectionType.Default:  					#region The default Hit method  					  					float o'u;  					p1 = start; p2 = end; 	 					// p1 must be the leftmost point. 					if (p1.X > p2.X) { s = p2; p2 = p1; p1 = s; }  					//this is specifically necessary when the layout works horizontally 					//the method beneth will not return true as should be in this case 					if(p1.Y==p2.Y) 					{ 						p1.Y+=-3; 						return new RectangleF(p1'new SizeF(p2.X-p1.X'6)).Contains(p); 					} 					r1 = new RectangleF(p1.X' p1.Y' 0' 0); 					r2 = new RectangleF(p2.X' p2.Y' 0' 0); 					r1.Inflate(3' 3); 					r2.Inflate(3' 3); 					//this is like a topological neighborhood 					//the connection is shifted left and right 					//and the point under consideration has to be in between.						 					if (RectangleF.Union(r1' r2).Contains(p)) 					{ 				 						if (p1.Y < p2.Y) //SWNE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							return ((p.X > o) && (p.X < u)); 						} 						else //NWSE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							return ((p.X > o) && (p.X < u)); 						} 					}  					#endregion  					break;  				case ConnectionType.Traditional:  					#region The rectangular Hit method  						switch(site.LayoutDirection)  						{  							case TreeDirection.Vertical:  								p1 = new PointF(from.Left + from.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5); //shift 5 to contain the connection  								p2 = new PointF(to.Left + to.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5);  								p3 = new Point(to.Left+to.Width/2-5'to.Bottom-5);    								r1 = new RectangleF(p1' new SizeF(10'(from.Top - to.Bottom)/2+5));   								if(p1.X<p2.X)  									r2 = new RectangleF(p1'new SizeF(p2.X-p1.X'10));  								else  									r2 = new RectangleF(p2'new SizeF(p1.X-p2.X'10));  								r3 = new RectangleF(p3' new SizeF(10' (from.Top - to.Bottom)/2+5));  								return r1.Contains(p.X'p.Y) || r2.Contains(p.X'p.Y) || r3.Contains(p.X'p.Y) ;  								  							case TreeDirection.Horizontal:    								p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   								p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							  								break;  						}  					#endregion  					break;  			}
Magic Number,Netron.Lithium,Connection,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Hit,The following statement contains a magic number: switch(site.ConnectionType)  			{  				case ConnectionType.Default:  					#region The default Hit method  					  					float o'u;  					p1 = start; p2 = end; 	 					// p1 must be the leftmost point. 					if (p1.X > p2.X) { s = p2; p2 = p1; p1 = s; }  					//this is specifically necessary when the layout works horizontally 					//the method beneth will not return true as should be in this case 					if(p1.Y==p2.Y) 					{ 						p1.Y+=-3; 						return new RectangleF(p1'new SizeF(p2.X-p1.X'6)).Contains(p); 					} 					r1 = new RectangleF(p1.X' p1.Y' 0' 0); 					r2 = new RectangleF(p2.X' p2.Y' 0' 0); 					r1.Inflate(3' 3); 					r2.Inflate(3' 3); 					//this is like a topological neighborhood 					//the connection is shifted left and right 					//and the point under consideration has to be in between.						 					if (RectangleF.Union(r1' r2).Contains(p)) 					{ 				 						if (p1.Y < p2.Y) //SWNE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							return ((p.X > o) && (p.X < u)); 						} 						else //NWSE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							return ((p.X > o) && (p.X < u)); 						} 					}  					#endregion  					break;  				case ConnectionType.Traditional:  					#region The rectangular Hit method  						switch(site.LayoutDirection)  						{  							case TreeDirection.Vertical:  								p1 = new PointF(from.Left + from.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5); //shift 5 to contain the connection  								p2 = new PointF(to.Left + to.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5);  								p3 = new Point(to.Left+to.Width/2-5'to.Bottom-5);    								r1 = new RectangleF(p1' new SizeF(10'(from.Top - to.Bottom)/2+5));   								if(p1.X<p2.X)  									r2 = new RectangleF(p1'new SizeF(p2.X-p1.X'10));  								else  									r2 = new RectangleF(p2'new SizeF(p1.X-p2.X'10));  								r3 = new RectangleF(p3' new SizeF(10' (from.Top - to.Bottom)/2+5));  								return r1.Contains(p.X'p.Y) || r2.Contains(p.X'p.Y) || r3.Contains(p.X'p.Y) ;  								  							case TreeDirection.Horizontal:    								p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   								p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							  								break;  						}  					#endregion  					break;  			}
Magic Number,Netron.Lithium,Connection,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Hit,The following statement contains a magic number: switch(site.ConnectionType)  			{  				case ConnectionType.Default:  					#region The default Hit method  					  					float o'u;  					p1 = start; p2 = end; 	 					// p1 must be the leftmost point. 					if (p1.X > p2.X) { s = p2; p2 = p1; p1 = s; }  					//this is specifically necessary when the layout works horizontally 					//the method beneth will not return true as should be in this case 					if(p1.Y==p2.Y) 					{ 						p1.Y+=-3; 						return new RectangleF(p1'new SizeF(p2.X-p1.X'6)).Contains(p); 					} 					r1 = new RectangleF(p1.X' p1.Y' 0' 0); 					r2 = new RectangleF(p2.X' p2.Y' 0' 0); 					r1.Inflate(3' 3); 					r2.Inflate(3' 3); 					//this is like a topological neighborhood 					//the connection is shifted left and right 					//and the point under consideration has to be in between.						 					if (RectangleF.Union(r1' r2).Contains(p)) 					{ 				 						if (p1.Y < p2.Y) //SWNE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							return ((p.X > o) && (p.X < u)); 						} 						else //NWSE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							return ((p.X > o) && (p.X < u)); 						} 					}  					#endregion  					break;  				case ConnectionType.Traditional:  					#region The rectangular Hit method  						switch(site.LayoutDirection)  						{  							case TreeDirection.Vertical:  								p1 = new PointF(from.Left + from.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5); //shift 5 to contain the connection  								p2 = new PointF(to.Left + to.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5);  								p3 = new Point(to.Left+to.Width/2-5'to.Bottom-5);    								r1 = new RectangleF(p1' new SizeF(10'(from.Top - to.Bottom)/2+5));   								if(p1.X<p2.X)  									r2 = new RectangleF(p1'new SizeF(p2.X-p1.X'10));  								else  									r2 = new RectangleF(p2'new SizeF(p1.X-p2.X'10));  								r3 = new RectangleF(p3' new SizeF(10' (from.Top - to.Bottom)/2+5));  								return r1.Contains(p.X'p.Y) || r2.Contains(p.X'p.Y) || r3.Contains(p.X'p.Y) ;  								  							case TreeDirection.Horizontal:    								p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   								p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							  								break;  						}  					#endregion  					break;  			}
Magic Number,Netron.Lithium,Connection,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Hit,The following statement contains a magic number: switch(site.ConnectionType)  			{  				case ConnectionType.Default:  					#region The default Hit method  					  					float o'u;  					p1 = start; p2 = end; 	 					// p1 must be the leftmost point. 					if (p1.X > p2.X) { s = p2; p2 = p1; p1 = s; }  					//this is specifically necessary when the layout works horizontally 					//the method beneth will not return true as should be in this case 					if(p1.Y==p2.Y) 					{ 						p1.Y+=-3; 						return new RectangleF(p1'new SizeF(p2.X-p1.X'6)).Contains(p); 					} 					r1 = new RectangleF(p1.X' p1.Y' 0' 0); 					r2 = new RectangleF(p2.X' p2.Y' 0' 0); 					r1.Inflate(3' 3); 					r2.Inflate(3' 3); 					//this is like a topological neighborhood 					//the connection is shifted left and right 					//and the point under consideration has to be in between.						 					if (RectangleF.Union(r1' r2).Contains(p)) 					{ 				 						if (p1.Y < p2.Y) //SWNE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							return ((p.X > o) && (p.X < u)); 						} 						else //NWSE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							return ((p.X > o) && (p.X < u)); 						} 					}  					#endregion  					break;  				case ConnectionType.Traditional:  					#region The rectangular Hit method  						switch(site.LayoutDirection)  						{  							case TreeDirection.Vertical:  								p1 = new PointF(from.Left + from.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5); //shift 5 to contain the connection  								p2 = new PointF(to.Left + to.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5);  								p3 = new Point(to.Left+to.Width/2-5'to.Bottom-5);    								r1 = new RectangleF(p1' new SizeF(10'(from.Top - to.Bottom)/2+5));   								if(p1.X<p2.X)  									r2 = new RectangleF(p1'new SizeF(p2.X-p1.X'10));  								else  									r2 = new RectangleF(p2'new SizeF(p1.X-p2.X'10));  								r3 = new RectangleF(p3' new SizeF(10' (from.Top - to.Bottom)/2+5));  								return r1.Contains(p.X'p.Y) || r2.Contains(p.X'p.Y) || r3.Contains(p.X'p.Y) ;  								  							case TreeDirection.Horizontal:    								p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   								p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							  								break;  						}  					#endregion  					break;  			}
Magic Number,Netron.Lithium,Connection,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Hit,The following statement contains a magic number: switch(site.ConnectionType)  			{  				case ConnectionType.Default:  					#region The default Hit method  					  					float o'u;  					p1 = start; p2 = end; 	 					// p1 must be the leftmost point. 					if (p1.X > p2.X) { s = p2; p2 = p1; p1 = s; }  					//this is specifically necessary when the layout works horizontally 					//the method beneth will not return true as should be in this case 					if(p1.Y==p2.Y) 					{ 						p1.Y+=-3; 						return new RectangleF(p1'new SizeF(p2.X-p1.X'6)).Contains(p); 					} 					r1 = new RectangleF(p1.X' p1.Y' 0' 0); 					r2 = new RectangleF(p2.X' p2.Y' 0' 0); 					r1.Inflate(3' 3); 					r2.Inflate(3' 3); 					//this is like a topological neighborhood 					//the connection is shifted left and right 					//and the point under consideration has to be in between.						 					if (RectangleF.Union(r1' r2).Contains(p)) 					{ 				 						if (p1.Y < p2.Y) //SWNE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							return ((p.X > o) && (p.X < u)); 						} 						else //NWSE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							return ((p.X > o) && (p.X < u)); 						} 					}  					#endregion  					break;  				case ConnectionType.Traditional:  					#region The rectangular Hit method  						switch(site.LayoutDirection)  						{  							case TreeDirection.Vertical:  								p1 = new PointF(from.Left + from.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5); //shift 5 to contain the connection  								p2 = new PointF(to.Left + to.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5);  								p3 = new Point(to.Left+to.Width/2-5'to.Bottom-5);    								r1 = new RectangleF(p1' new SizeF(10'(from.Top - to.Bottom)/2+5));   								if(p1.X<p2.X)  									r2 = new RectangleF(p1'new SizeF(p2.X-p1.X'10));  								else  									r2 = new RectangleF(p2'new SizeF(p1.X-p2.X'10));  								r3 = new RectangleF(p3' new SizeF(10' (from.Top - to.Bottom)/2+5));  								return r1.Contains(p.X'p.Y) || r2.Contains(p.X'p.Y) || r3.Contains(p.X'p.Y) ;  								  							case TreeDirection.Horizontal:    								p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   								p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							  								break;  						}  					#endregion  					break;  			}
Magic Number,Netron.Lithium,Connection,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Hit,The following statement contains a magic number: switch(site.ConnectionType)  			{  				case ConnectionType.Default:  					#region The default Hit method  					  					float o'u;  					p1 = start; p2 = end; 	 					// p1 must be the leftmost point. 					if (p1.X > p2.X) { s = p2; p2 = p1; p1 = s; }  					//this is specifically necessary when the layout works horizontally 					//the method beneth will not return true as should be in this case 					if(p1.Y==p2.Y) 					{ 						p1.Y+=-3; 						return new RectangleF(p1'new SizeF(p2.X-p1.X'6)).Contains(p); 					} 					r1 = new RectangleF(p1.X' p1.Y' 0' 0); 					r2 = new RectangleF(p2.X' p2.Y' 0' 0); 					r1.Inflate(3' 3); 					r2.Inflate(3' 3); 					//this is like a topological neighborhood 					//the connection is shifted left and right 					//and the point under consideration has to be in between.						 					if (RectangleF.Union(r1' r2).Contains(p)) 					{ 				 						if (p1.Y < p2.Y) //SWNE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							return ((p.X > o) && (p.X < u)); 						} 						else //NWSE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							return ((p.X > o) && (p.X < u)); 						} 					}  					#endregion  					break;  				case ConnectionType.Traditional:  					#region The rectangular Hit method  						switch(site.LayoutDirection)  						{  							case TreeDirection.Vertical:  								p1 = new PointF(from.Left + from.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5); //shift 5 to contain the connection  								p2 = new PointF(to.Left + to.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5);  								p3 = new Point(to.Left+to.Width/2-5'to.Bottom-5);    								r1 = new RectangleF(p1' new SizeF(10'(from.Top - to.Bottom)/2+5));   								if(p1.X<p2.X)  									r2 = new RectangleF(p1'new SizeF(p2.X-p1.X'10));  								else  									r2 = new RectangleF(p2'new SizeF(p1.X-p2.X'10));  								r3 = new RectangleF(p3' new SizeF(10' (from.Top - to.Bottom)/2+5));  								return r1.Contains(p.X'p.Y) || r2.Contains(p.X'p.Y) || r3.Contains(p.X'p.Y) ;  								  							case TreeDirection.Horizontal:    								p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   								p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							  								break;  						}  					#endregion  					break;  			}
Magic Number,Netron.Lithium,Connection,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Hit,The following statement contains a magic number: switch(site.ConnectionType)  			{  				case ConnectionType.Default:  					#region The default Hit method  					  					float o'u;  					p1 = start; p2 = end; 	 					// p1 must be the leftmost point. 					if (p1.X > p2.X) { s = p2; p2 = p1; p1 = s; }  					//this is specifically necessary when the layout works horizontally 					//the method beneth will not return true as should be in this case 					if(p1.Y==p2.Y) 					{ 						p1.Y+=-3; 						return new RectangleF(p1'new SizeF(p2.X-p1.X'6)).Contains(p); 					} 					r1 = new RectangleF(p1.X' p1.Y' 0' 0); 					r2 = new RectangleF(p2.X' p2.Y' 0' 0); 					r1.Inflate(3' 3); 					r2.Inflate(3' 3); 					//this is like a topological neighborhood 					//the connection is shifted left and right 					//and the point under consideration has to be in between.						 					if (RectangleF.Union(r1' r2).Contains(p)) 					{ 				 						if (p1.Y < p2.Y) //SWNE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							return ((p.X > o) && (p.X < u)); 						} 						else //NWSE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							return ((p.X > o) && (p.X < u)); 						} 					}  					#endregion  					break;  				case ConnectionType.Traditional:  					#region The rectangular Hit method  						switch(site.LayoutDirection)  						{  							case TreeDirection.Vertical:  								p1 = new PointF(from.Left + from.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5); //shift 5 to contain the connection  								p2 = new PointF(to.Left + to.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5);  								p3 = new Point(to.Left+to.Width/2-5'to.Bottom-5);    								r1 = new RectangleF(p1' new SizeF(10'(from.Top - to.Bottom)/2+5));   								if(p1.X<p2.X)  									r2 = new RectangleF(p1'new SizeF(p2.X-p1.X'10));  								else  									r2 = new RectangleF(p2'new SizeF(p1.X-p2.X'10));  								r3 = new RectangleF(p3' new SizeF(10' (from.Top - to.Bottom)/2+5));  								return r1.Contains(p.X'p.Y) || r2.Contains(p.X'p.Y) || r3.Contains(p.X'p.Y) ;  								  							case TreeDirection.Horizontal:    								p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   								p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							  								break;  						}  					#endregion  					break;  			}
Magic Number,Netron.Lithium,Connection,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Hit,The following statement contains a magic number: switch(site.ConnectionType)  			{  				case ConnectionType.Default:  					#region The default Hit method  					  					float o'u;  					p1 = start; p2 = end; 	 					// p1 must be the leftmost point. 					if (p1.X > p2.X) { s = p2; p2 = p1; p1 = s; }  					//this is specifically necessary when the layout works horizontally 					//the method beneth will not return true as should be in this case 					if(p1.Y==p2.Y) 					{ 						p1.Y+=-3; 						return new RectangleF(p1'new SizeF(p2.X-p1.X'6)).Contains(p); 					} 					r1 = new RectangleF(p1.X' p1.Y' 0' 0); 					r2 = new RectangleF(p2.X' p2.Y' 0' 0); 					r1.Inflate(3' 3); 					r2.Inflate(3' 3); 					//this is like a topological neighborhood 					//the connection is shifted left and right 					//and the point under consideration has to be in between.						 					if (RectangleF.Union(r1' r2).Contains(p)) 					{ 				 						if (p1.Y < p2.Y) //SWNE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							return ((p.X > o) && (p.X < u)); 						} 						else //NWSE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							return ((p.X > o) && (p.X < u)); 						} 					}  					#endregion  					break;  				case ConnectionType.Traditional:  					#region The rectangular Hit method  						switch(site.LayoutDirection)  						{  							case TreeDirection.Vertical:  								p1 = new PointF(from.Left + from.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5); //shift 5 to contain the connection  								p2 = new PointF(to.Left + to.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5);  								p3 = new Point(to.Left+to.Width/2-5'to.Bottom-5);    								r1 = new RectangleF(p1' new SizeF(10'(from.Top - to.Bottom)/2+5));   								if(p1.X<p2.X)  									r2 = new RectangleF(p1'new SizeF(p2.X-p1.X'10));  								else  									r2 = new RectangleF(p2'new SizeF(p1.X-p2.X'10));  								r3 = new RectangleF(p3' new SizeF(10' (from.Top - to.Bottom)/2+5));  								return r1.Contains(p.X'p.Y) || r2.Contains(p.X'p.Y) || r3.Contains(p.X'p.Y) ;  								  							case TreeDirection.Horizontal:    								p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   								p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							  								break;  						}  					#endregion  					break;  			}
Magic Number,Netron.Lithium,Connection,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Hit,The following statement contains a magic number: switch(site.ConnectionType)  			{  				case ConnectionType.Default:  					#region The default Hit method  					  					float o'u;  					p1 = start; p2 = end; 	 					// p1 must be the leftmost point. 					if (p1.X > p2.X) { s = p2; p2 = p1; p1 = s; }  					//this is specifically necessary when the layout works horizontally 					//the method beneth will not return true as should be in this case 					if(p1.Y==p2.Y) 					{ 						p1.Y+=-3; 						return new RectangleF(p1'new SizeF(p2.X-p1.X'6)).Contains(p); 					} 					r1 = new RectangleF(p1.X' p1.Y' 0' 0); 					r2 = new RectangleF(p2.X' p2.Y' 0' 0); 					r1.Inflate(3' 3); 					r2.Inflate(3' 3); 					//this is like a topological neighborhood 					//the connection is shifted left and right 					//and the point under consideration has to be in between.						 					if (RectangleF.Union(r1' r2).Contains(p)) 					{ 				 						if (p1.Y < p2.Y) //SWNE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							return ((p.X > o) && (p.X < u)); 						} 						else //NWSE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							return ((p.X > o) && (p.X < u)); 						} 					}  					#endregion  					break;  				case ConnectionType.Traditional:  					#region The rectangular Hit method  						switch(site.LayoutDirection)  						{  							case TreeDirection.Vertical:  								p1 = new PointF(from.Left + from.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5); //shift 5 to contain the connection  								p2 = new PointF(to.Left + to.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5);  								p3 = new Point(to.Left+to.Width/2-5'to.Bottom-5);    								r1 = new RectangleF(p1' new SizeF(10'(from.Top - to.Bottom)/2+5));   								if(p1.X<p2.X)  									r2 = new RectangleF(p1'new SizeF(p2.X-p1.X'10));  								else  									r2 = new RectangleF(p2'new SizeF(p1.X-p2.X'10));  								r3 = new RectangleF(p3' new SizeF(10' (from.Top - to.Bottom)/2+5));  								return r1.Contains(p.X'p.Y) || r2.Contains(p.X'p.Y) || r3.Contains(p.X'p.Y) ;  								  							case TreeDirection.Horizontal:    								p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   								p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							  								break;  						}  					#endregion  					break;  			}
Magic Number,Netron.Lithium,Connection,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Hit,The following statement contains a magic number: switch(site.ConnectionType)  			{  				case ConnectionType.Default:  					#region The default Hit method  					  					float o'u;  					p1 = start; p2 = end; 	 					// p1 must be the leftmost point. 					if (p1.X > p2.X) { s = p2; p2 = p1; p1 = s; }  					//this is specifically necessary when the layout works horizontally 					//the method beneth will not return true as should be in this case 					if(p1.Y==p2.Y) 					{ 						p1.Y+=-3; 						return new RectangleF(p1'new SizeF(p2.X-p1.X'6)).Contains(p); 					} 					r1 = new RectangleF(p1.X' p1.Y' 0' 0); 					r2 = new RectangleF(p2.X' p2.Y' 0' 0); 					r1.Inflate(3' 3); 					r2.Inflate(3' 3); 					//this is like a topological neighborhood 					//the connection is shifted left and right 					//and the point under consideration has to be in between.						 					if (RectangleF.Union(r1' r2).Contains(p)) 					{ 				 						if (p1.Y < p2.Y) //SWNE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							return ((p.X > o) && (p.X < u)); 						} 						else //NWSE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							return ((p.X > o) && (p.X < u)); 						} 					}  					#endregion  					break;  				case ConnectionType.Traditional:  					#region The rectangular Hit method  						switch(site.LayoutDirection)  						{  							case TreeDirection.Vertical:  								p1 = new PointF(from.Left + from.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5); //shift 5 to contain the connection  								p2 = new PointF(to.Left + to.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5);  								p3 = new Point(to.Left+to.Width/2-5'to.Bottom-5);    								r1 = new RectangleF(p1' new SizeF(10'(from.Top - to.Bottom)/2+5));   								if(p1.X<p2.X)  									r2 = new RectangleF(p1'new SizeF(p2.X-p1.X'10));  								else  									r2 = new RectangleF(p2'new SizeF(p1.X-p2.X'10));  								r3 = new RectangleF(p3' new SizeF(10' (from.Top - to.Bottom)/2+5));  								return r1.Contains(p.X'p.Y) || r2.Contains(p.X'p.Y) || r3.Contains(p.X'p.Y) ;  								  							case TreeDirection.Horizontal:    								p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   								p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							  								break;  						}  					#endregion  					break;  			}
Magic Number,Netron.Lithium,Connection,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Hit,The following statement contains a magic number: switch(site.ConnectionType)  			{  				case ConnectionType.Default:  					#region The default Hit method  					  					float o'u;  					p1 = start; p2 = end; 	 					// p1 must be the leftmost point. 					if (p1.X > p2.X) { s = p2; p2 = p1; p1 = s; }  					//this is specifically necessary when the layout works horizontally 					//the method beneth will not return true as should be in this case 					if(p1.Y==p2.Y) 					{ 						p1.Y+=-3; 						return new RectangleF(p1'new SizeF(p2.X-p1.X'6)).Contains(p); 					} 					r1 = new RectangleF(p1.X' p1.Y' 0' 0); 					r2 = new RectangleF(p2.X' p2.Y' 0' 0); 					r1.Inflate(3' 3); 					r2.Inflate(3' 3); 					//this is like a topological neighborhood 					//the connection is shifted left and right 					//and the point under consideration has to be in between.						 					if (RectangleF.Union(r1' r2).Contains(p)) 					{ 				 						if (p1.Y < p2.Y) //SWNE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							return ((p.X > o) && (p.X < u)); 						} 						else //NWSE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							return ((p.X > o) && (p.X < u)); 						} 					}  					#endregion  					break;  				case ConnectionType.Traditional:  					#region The rectangular Hit method  						switch(site.LayoutDirection)  						{  							case TreeDirection.Vertical:  								p1 = new PointF(from.Left + from.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5); //shift 5 to contain the connection  								p2 = new PointF(to.Left + to.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5);  								p3 = new Point(to.Left+to.Width/2-5'to.Bottom-5);    								r1 = new RectangleF(p1' new SizeF(10'(from.Top - to.Bottom)/2+5));   								if(p1.X<p2.X)  									r2 = new RectangleF(p1'new SizeF(p2.X-p1.X'10));  								else  									r2 = new RectangleF(p2'new SizeF(p1.X-p2.X'10));  								r3 = new RectangleF(p3' new SizeF(10' (from.Top - to.Bottom)/2+5));  								return r1.Contains(p.X'p.Y) || r2.Contains(p.X'p.Y) || r3.Contains(p.X'p.Y) ;  								  							case TreeDirection.Horizontal:    								p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   								p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							  								break;  						}  					#endregion  					break;  			}
Magic Number,Netron.Lithium,Connection,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Hit,The following statement contains a magic number: switch(site.ConnectionType)  			{  				case ConnectionType.Default:  					#region The default Hit method  					  					float o'u;  					p1 = start; p2 = end; 	 					// p1 must be the leftmost point. 					if (p1.X > p2.X) { s = p2; p2 = p1; p1 = s; }  					//this is specifically necessary when the layout works horizontally 					//the method beneth will not return true as should be in this case 					if(p1.Y==p2.Y) 					{ 						p1.Y+=-3; 						return new RectangleF(p1'new SizeF(p2.X-p1.X'6)).Contains(p); 					} 					r1 = new RectangleF(p1.X' p1.Y' 0' 0); 					r2 = new RectangleF(p2.X' p2.Y' 0' 0); 					r1.Inflate(3' 3); 					r2.Inflate(3' 3); 					//this is like a topological neighborhood 					//the connection is shifted left and right 					//and the point under consideration has to be in between.						 					if (RectangleF.Union(r1' r2).Contains(p)) 					{ 				 						if (p1.Y < p2.Y) //SWNE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							return ((p.X > o) && (p.X < u)); 						} 						else //NWSE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							return ((p.X > o) && (p.X < u)); 						} 					}  					#endregion  					break;  				case ConnectionType.Traditional:  					#region The rectangular Hit method  						switch(site.LayoutDirection)  						{  							case TreeDirection.Vertical:  								p1 = new PointF(from.Left + from.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5); //shift 5 to contain the connection  								p2 = new PointF(to.Left + to.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5);  								p3 = new Point(to.Left+to.Width/2-5'to.Bottom-5);    								r1 = new RectangleF(p1' new SizeF(10'(from.Top - to.Bottom)/2+5));   								if(p1.X<p2.X)  									r2 = new RectangleF(p1'new SizeF(p2.X-p1.X'10));  								else  									r2 = new RectangleF(p2'new SizeF(p1.X-p2.X'10));  								r3 = new RectangleF(p3' new SizeF(10' (from.Top - to.Bottom)/2+5));  								return r1.Contains(p.X'p.Y) || r2.Contains(p.X'p.Y) || r3.Contains(p.X'p.Y) ;  								  							case TreeDirection.Horizontal:    								p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   								p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							  								break;  						}  					#endregion  					break;  			}
Magic Number,Netron.Lithium,Connection,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Hit,The following statement contains a magic number: switch(site.ConnectionType)  			{  				case ConnectionType.Default:  					#region The default Hit method  					  					float o'u;  					p1 = start; p2 = end; 	 					// p1 must be the leftmost point. 					if (p1.X > p2.X) { s = p2; p2 = p1; p1 = s; }  					//this is specifically necessary when the layout works horizontally 					//the method beneth will not return true as should be in this case 					if(p1.Y==p2.Y) 					{ 						p1.Y+=-3; 						return new RectangleF(p1'new SizeF(p2.X-p1.X'6)).Contains(p); 					} 					r1 = new RectangleF(p1.X' p1.Y' 0' 0); 					r2 = new RectangleF(p2.X' p2.Y' 0' 0); 					r1.Inflate(3' 3); 					r2.Inflate(3' 3); 					//this is like a topological neighborhood 					//the connection is shifted left and right 					//and the point under consideration has to be in between.						 					if (RectangleF.Union(r1' r2).Contains(p)) 					{ 				 						if (p1.Y < p2.Y) //SWNE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							return ((p.X > o) && (p.X < u)); 						} 						else //NWSE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							return ((p.X > o) && (p.X < u)); 						} 					}  					#endregion  					break;  				case ConnectionType.Traditional:  					#region The rectangular Hit method  						switch(site.LayoutDirection)  						{  							case TreeDirection.Vertical:  								p1 = new PointF(from.Left + from.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5); //shift 5 to contain the connection  								p2 = new PointF(to.Left + to.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5);  								p3 = new Point(to.Left+to.Width/2-5'to.Bottom-5);    								r1 = new RectangleF(p1' new SizeF(10'(from.Top - to.Bottom)/2+5));   								if(p1.X<p2.X)  									r2 = new RectangleF(p1'new SizeF(p2.X-p1.X'10));  								else  									r2 = new RectangleF(p2'new SizeF(p1.X-p2.X'10));  								r3 = new RectangleF(p3' new SizeF(10' (from.Top - to.Bottom)/2+5));  								return r1.Contains(p.X'p.Y) || r2.Contains(p.X'p.Y) || r3.Contains(p.X'p.Y) ;  								  							case TreeDirection.Horizontal:    								p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   								p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							  								break;  						}  					#endregion  					break;  			}
Magic Number,Netron.Lithium,Connection,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Hit,The following statement contains a magic number: switch(site.ConnectionType)  			{  				case ConnectionType.Default:  					#region The default Hit method  					  					float o'u;  					p1 = start; p2 = end; 	 					// p1 must be the leftmost point. 					if (p1.X > p2.X) { s = p2; p2 = p1; p1 = s; }  					//this is specifically necessary when the layout works horizontally 					//the method beneth will not return true as should be in this case 					if(p1.Y==p2.Y) 					{ 						p1.Y+=-3; 						return new RectangleF(p1'new SizeF(p2.X-p1.X'6)).Contains(p); 					} 					r1 = new RectangleF(p1.X' p1.Y' 0' 0); 					r2 = new RectangleF(p2.X' p2.Y' 0' 0); 					r1.Inflate(3' 3); 					r2.Inflate(3' 3); 					//this is like a topological neighborhood 					//the connection is shifted left and right 					//and the point under consideration has to be in between.						 					if (RectangleF.Union(r1' r2).Contains(p)) 					{ 				 						if (p1.Y < p2.Y) //SWNE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							return ((p.X > o) && (p.X < u)); 						} 						else //NWSE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							return ((p.X > o) && (p.X < u)); 						} 					}  					#endregion  					break;  				case ConnectionType.Traditional:  					#region The rectangular Hit method  						switch(site.LayoutDirection)  						{  							case TreeDirection.Vertical:  								p1 = new PointF(from.Left + from.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5); //shift 5 to contain the connection  								p2 = new PointF(to.Left + to.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5);  								p3 = new Point(to.Left+to.Width/2-5'to.Bottom-5);    								r1 = new RectangleF(p1' new SizeF(10'(from.Top - to.Bottom)/2+5));   								if(p1.X<p2.X)  									r2 = new RectangleF(p1'new SizeF(p2.X-p1.X'10));  								else  									r2 = new RectangleF(p2'new SizeF(p1.X-p2.X'10));  								r3 = new RectangleF(p3' new SizeF(10' (from.Top - to.Bottom)/2+5));  								return r1.Contains(p.X'p.Y) || r2.Contains(p.X'p.Y) || r3.Contains(p.X'p.Y) ;  								  							case TreeDirection.Horizontal:    								p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   								p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							  								break;  						}  					#endregion  					break;  			}
Magic Number,Netron.Lithium,Connection,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Hit,The following statement contains a magic number: switch(site.ConnectionType)  			{  				case ConnectionType.Default:  					#region The default Hit method  					  					float o'u;  					p1 = start; p2 = end; 	 					// p1 must be the leftmost point. 					if (p1.X > p2.X) { s = p2; p2 = p1; p1 = s; }  					//this is specifically necessary when the layout works horizontally 					//the method beneth will not return true as should be in this case 					if(p1.Y==p2.Y) 					{ 						p1.Y+=-3; 						return new RectangleF(p1'new SizeF(p2.X-p1.X'6)).Contains(p); 					} 					r1 = new RectangleF(p1.X' p1.Y' 0' 0); 					r2 = new RectangleF(p2.X' p2.Y' 0' 0); 					r1.Inflate(3' 3); 					r2.Inflate(3' 3); 					//this is like a topological neighborhood 					//the connection is shifted left and right 					//and the point under consideration has to be in between.						 					if (RectangleF.Union(r1' r2).Contains(p)) 					{ 				 						if (p1.Y < p2.Y) //SWNE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							return ((p.X > o) && (p.X < u)); 						} 						else //NWSE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							return ((p.X > o) && (p.X < u)); 						} 					}  					#endregion  					break;  				case ConnectionType.Traditional:  					#region The rectangular Hit method  						switch(site.LayoutDirection)  						{  							case TreeDirection.Vertical:  								p1 = new PointF(from.Left + from.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5); //shift 5 to contain the connection  								p2 = new PointF(to.Left + to.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5);  								p3 = new Point(to.Left+to.Width/2-5'to.Bottom-5);    								r1 = new RectangleF(p1' new SizeF(10'(from.Top - to.Bottom)/2+5));   								if(p1.X<p2.X)  									r2 = new RectangleF(p1'new SizeF(p2.X-p1.X'10));  								else  									r2 = new RectangleF(p2'new SizeF(p1.X-p2.X'10));  								r3 = new RectangleF(p3' new SizeF(10' (from.Top - to.Bottom)/2+5));  								return r1.Contains(p.X'p.Y) || r2.Contains(p.X'p.Y) || r3.Contains(p.X'p.Y) ;  								  							case TreeDirection.Horizontal:    								p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   								p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							  								break;  						}  					#endregion  					break;  			}
Magic Number,Netron.Lithium,ShapeBase,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\ShapeBase.cs,Fit,The following statement contains a magic number: rectangle.Width =s.Width +10;
Magic Number,Netron.Lithium,ShapeBase,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\ShapeBase.cs,Fit,The following statement contains a magic number: rectangle.Height = s.Height+8;
Magic Number,Netron.Lithium,ShapeBase,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\ShapeBase.cs,AddChild,The following statement contains a magic number: shape.Location = new Point(Width/2+50'Height/2+50);
Magic Number,Netron.Lithium,ShapeBase,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\ShapeBase.cs,AddChild,The following statement contains a magic number: shape.Location = new Point(Width/2+50'Height/2+50);
Magic Number,Netron.Lithium,ShapeBase,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\ShapeBase.cs,AddChild,The following statement contains a magic number: shape.Location = new Point(Width/2+50'Height/2+50);
Magic Number,Netron.Lithium,ShapeBase,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\ShapeBase.cs,AddChild,The following statement contains a magic number: shape.Location = new Point(Width/2+50'Height/2+50);
Magic Number,Netron.Lithium,ShapeBase,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\ShapeBase.cs,AddChild,The following statement contains a magic number: shape.Width = 50;
Magic Number,Netron.Lithium,ShapeBase,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\ShapeBase.cs,AddChild,The following statement contains a magic number: shape.Height = 25;
Magic Number,Netron.Lithium,ShapeBase,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\ShapeBase.cs,Init,The following statement contains a magic number: rectangle = new Rectangle(0'0'100'70);
Magic Number,Netron.Lithium,ShapeBase,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\ShapeBase.cs,Init,The following statement contains a magic number: rectangle = new Rectangle(0'0'100'70);
Magic Number,Netron.Lithium,OvalShape,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\OvalShape.cs,Hit,The following statement contains a magic number: Rectangle r= new Rectangle(p' new Size(5'5));
Magic Number,Netron.Lithium,OvalShape,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\OvalShape.cs,Hit,The following statement contains a magic number: Rectangle r= new Rectangle(p' new Size(5'5));
Magic Number,Netron.Lithium,OvalShape,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\OvalShape.cs,Paint,The following statement contains a magic number: g.DrawEllipse(new Pen(Color.Red'2F)'rectangle);
Magic Number,Netron.Lithium,OvalShape,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\OvalShape.cs,Paint,The following statement contains a magic number: g.DrawString(text'font'Brushes.Black' rectangle.X+10'rectangle.Y+10);
Magic Number,Netron.Lithium,OvalShape,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\OvalShape.cs,Paint,The following statement contains a magic number: g.DrawString(text'font'Brushes.Black' rectangle.X+10'rectangle.Y+10);
Magic Number,Netron.Lithium,OvalShape,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\OvalShape.cs,Invalidate,The following statement contains a magic number: r.Offset(-5'-5);
Magic Number,Netron.Lithium,OvalShape,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\OvalShape.cs,Invalidate,The following statement contains a magic number: r.Offset(-5'-5);
Magic Number,Netron.Lithium,OvalShape,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\OvalShape.cs,Invalidate,The following statement contains a magic number: r.Inflate(20'20);
Magic Number,Netron.Lithium,OvalShape,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\OvalShape.cs,Invalidate,The following statement contains a magic number: r.Inflate(20'20);
Magic Number,Netron.Lithium,SimpleRectangle,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Hit,The following statement contains a magic number: Rectangle r= new Rectangle(p' new Size(2'2));
Magic Number,Netron.Lithium,SimpleRectangle,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Hit,The following statement contains a magic number: Rectangle r= new Rectangle(p' new Size(2'2));
Magic Number,Netron.Lithium,SimpleRectangle,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: Point[] pts = new Point[12]  				{  					new Point(rectangle.X'rectangle.Y)' //0  					new Point(rectangle.X+bshift'rectangle.Y)' //1  					new Point(rectangle.Right-bshift'rectangle.Y)' //2  					new Point(rectangle.Right'rectangle.Y)' //3  					new Point(rectangle.Right'rectangle.Y+bshift)' //4  					new Point(rectangle.Right'rectangle.Bottom-bshift)' //5  					new Point(rectangle.Right'rectangle.Bottom)' //6  					new Point(rectangle.Right-bshift'rectangle.Bottom)' //7  					new Point(rectangle.X+bshift'rectangle.Bottom)' //8  					new Point(rectangle.X'rectangle.Bottom)' //9  					new Point(rectangle.X'rectangle.Bottom - bshift)' //10  					new Point(rectangle.X'rectangle.Y+bshift)' //11				  			};
Magic Number,Netron.Lithium,SimpleRectangle,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: path.AddBezier(pts[11]'pts[0]'pts[0]'pts[1]);
Magic Number,Netron.Lithium,SimpleRectangle,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: path.AddLine(pts[1]'pts[2]);
Magic Number,Netron.Lithium,SimpleRectangle,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: path.AddBezier(pts[2]'pts[3]'pts[3]'pts[4]);
Magic Number,Netron.Lithium,SimpleRectangle,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: path.AddBezier(pts[2]'pts[3]'pts[3]'pts[4]);
Magic Number,Netron.Lithium,SimpleRectangle,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: path.AddBezier(pts[2]'pts[3]'pts[3]'pts[4]);
Magic Number,Netron.Lithium,SimpleRectangle,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: path.AddBezier(pts[2]'pts[3]'pts[3]'pts[4]);
Magic Number,Netron.Lithium,SimpleRectangle,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: path.AddLine(pts[4]'pts[5]);
Magic Number,Netron.Lithium,SimpleRectangle,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: path.AddLine(pts[4]'pts[5]);
Magic Number,Netron.Lithium,SimpleRectangle,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: path.AddBezier(pts[5]'pts[6]'pts[6]'pts[7]);
Magic Number,Netron.Lithium,SimpleRectangle,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: path.AddBezier(pts[5]'pts[6]'pts[6]'pts[7]);
Magic Number,Netron.Lithium,SimpleRectangle,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: path.AddBezier(pts[5]'pts[6]'pts[6]'pts[7]);
Magic Number,Netron.Lithium,SimpleRectangle,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: path.AddBezier(pts[5]'pts[6]'pts[6]'pts[7]);
Magic Number,Netron.Lithium,SimpleRectangle,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: path.AddLine(pts[7]'pts[8]);
Magic Number,Netron.Lithium,SimpleRectangle,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: path.AddLine(pts[7]'pts[8]);
Magic Number,Netron.Lithium,SimpleRectangle,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: path.AddBezier(pts[8]'pts[9]'pts[9]'pts[10]);
Magic Number,Netron.Lithium,SimpleRectangle,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: path.AddBezier(pts[8]'pts[9]'pts[9]'pts[10]);
Magic Number,Netron.Lithium,SimpleRectangle,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: path.AddBezier(pts[8]'pts[9]'pts[9]'pts[10]);
Magic Number,Netron.Lithium,SimpleRectangle,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: path.AddBezier(pts[8]'pts[9]'pts[9]'pts[10]);
Magic Number,Netron.Lithium,SimpleRectangle,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: path.AddLine(pts[10]'pts[11]);
Magic Number,Netron.Lithium,SimpleRectangle,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: path.AddLine(pts[10]'pts[11]);
Magic Number,Netron.Lithium,SimpleRectangle,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: shadow.Translate(5' 5);
Magic Number,Netron.Lithium,SimpleRectangle,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: shadow.Translate(5' 5);
Magic Number,Netron.Lithium,SimpleRectangle,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: g.DrawString(text'font'Brushes.Black' rectangle.X+5'rectangle.Y+5);
Magic Number,Netron.Lithium,SimpleRectangle,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: g.DrawString(text'font'Brushes.Black' rectangle.X+5'rectangle.Y+5);
Magic Number,Netron.Lithium,SimpleRectangle,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: switch(site.LayoutDirection)  				{  				  					case TreeDirection.Vertical:  						toggleNode = new Rectangle(Left + this.Width/2 - 5' Bottom' 10' 10);  						break;  					case TreeDirection.Horizontal:  						toggleNode = new Rectangle(Right ' Top +Height/2-5 ' 10' 10);  						break;  				}
Magic Number,Netron.Lithium,SimpleRectangle,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: switch(site.LayoutDirection)  				{  				  					case TreeDirection.Vertical:  						toggleNode = new Rectangle(Left + this.Width/2 - 5' Bottom' 10' 10);  						break;  					case TreeDirection.Horizontal:  						toggleNode = new Rectangle(Right ' Top +Height/2-5 ' 10' 10);  						break;  				}
Magic Number,Netron.Lithium,SimpleRectangle,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: switch(site.LayoutDirection)  				{  				  					case TreeDirection.Vertical:  						toggleNode = new Rectangle(Left + this.Width/2 - 5' Bottom' 10' 10);  						break;  					case TreeDirection.Horizontal:  						toggleNode = new Rectangle(Right ' Top +Height/2-5 ' 10' 10);  						break;  				}
Magic Number,Netron.Lithium,SimpleRectangle,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: switch(site.LayoutDirection)  				{  				  					case TreeDirection.Vertical:  						toggleNode = new Rectangle(Left + this.Width/2 - 5' Bottom' 10' 10);  						break;  					case TreeDirection.Horizontal:  						toggleNode = new Rectangle(Right ' Top +Height/2-5 ' 10' 10);  						break;  				}
Magic Number,Netron.Lithium,SimpleRectangle,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: switch(site.LayoutDirection)  				{  				  					case TreeDirection.Vertical:  						toggleNode = new Rectangle(Left + this.Width/2 - 5' Bottom' 10' 10);  						break;  					case TreeDirection.Horizontal:  						toggleNode = new Rectangle(Right ' Top +Height/2-5 ' 10' 10);  						break;  				}
Magic Number,Netron.Lithium,SimpleRectangle,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: switch(site.LayoutDirection)  				{  				  					case TreeDirection.Vertical:  						toggleNode = new Rectangle(Left + this.Width/2 - 5' Bottom' 10' 10);  						break;  					case TreeDirection.Horizontal:  						toggleNode = new Rectangle(Right ' Top +Height/2-5 ' 10' 10);  						break;  				}
Magic Number,Netron.Lithium,SimpleRectangle,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: switch(site.LayoutDirection)  				{  				  					case TreeDirection.Vertical:  						toggleNode = new Rectangle(Left + this.Width/2 - 5' Bottom' 10' 10);  						break;  					case TreeDirection.Horizontal:  						toggleNode = new Rectangle(Right ' Top +Height/2-5 ' 10' 10);  						break;  				}
Magic Number,Netron.Lithium,SimpleRectangle,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: switch(site.LayoutDirection)  				{  				  					case TreeDirection.Vertical:  						toggleNode = new Rectangle(Left + this.Width/2 - 5' Bottom' 10' 10);  						break;  					case TreeDirection.Horizontal:  						toggleNode = new Rectangle(Right ' Top +Height/2-5 ' 10' 10);  						break;  				}
Magic Number,Netron.Lithium,SimpleRectangle,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: g.DrawLine(blackPen' (toggleNode.X + 2)' (toggleNode.Y + (toggleNode.Height / 2))' (toggleNode.X + (toggleNode.Width - 2))' (toggleNode.Y + (toggleNode.Height / 2)) );
Magic Number,Netron.Lithium,SimpleRectangle,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: g.DrawLine(blackPen' (toggleNode.X + 2)' (toggleNode.Y + (toggleNode.Height / 2))' (toggleNode.X + (toggleNode.Width - 2))' (toggleNode.Y + (toggleNode.Height / 2)) );
Magic Number,Netron.Lithium,SimpleRectangle,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: g.DrawLine(blackPen' (toggleNode.X + 2)' (toggleNode.Y + (toggleNode.Height / 2))' (toggleNode.X + (toggleNode.Width - 2))' (toggleNode.Y + (toggleNode.Height / 2)) );
Magic Number,Netron.Lithium,SimpleRectangle,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: g.DrawLine(blackPen' (toggleNode.X + 2)' (toggleNode.Y + (toggleNode.Height / 2))' (toggleNode.X + (toggleNode.Width - 2))' (toggleNode.Y + (toggleNode.Height / 2)) );
Magic Number,Netron.Lithium,SimpleRectangle,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: g.DrawLine(blackPen' (toggleNode.X + (toggleNode.Width /2))' (toggleNode.Y + 2)' (toggleNode.X + (toggleNode.Width /2))' (toggleNode.Y + (toggleNode.Height - 2)));
Magic Number,Netron.Lithium,SimpleRectangle,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: g.DrawLine(blackPen' (toggleNode.X + (toggleNode.Width /2))' (toggleNode.Y + 2)' (toggleNode.X + (toggleNode.Width /2))' (toggleNode.Y + (toggleNode.Height - 2)));
Magic Number,Netron.Lithium,SimpleRectangle,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: g.DrawLine(blackPen' (toggleNode.X + (toggleNode.Width /2))' (toggleNode.Y + 2)' (toggleNode.X + (toggleNode.Width /2))' (toggleNode.Y + (toggleNode.Height - 2)));
Magic Number,Netron.Lithium,SimpleRectangle,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: g.DrawLine(blackPen' (toggleNode.X + (toggleNode.Width /2))' (toggleNode.Y + 2)' (toggleNode.X + (toggleNode.Width /2))' (toggleNode.Y + (toggleNode.Height - 2)));
Magic Number,Netron.Lithium,SimpleRectangle,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Invalidate,The following statement contains a magic number: r.Offset(-5'-5);
Magic Number,Netron.Lithium,SimpleRectangle,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Invalidate,The following statement contains a magic number: r.Offset(-5'-5);
Magic Number,Netron.Lithium,SimpleRectangle,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Invalidate,The following statement contains a magic number: r.Inflate(40'40);
Magic Number,Netron.Lithium,SimpleRectangle,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Invalidate,The following statement contains a magic number: r.Inflate(40'40);
Magic Number,Netron.Lithium,TextLabel,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\TextLabel.cs,Hit,The following statement contains a magic number: Rectangle r= new Rectangle(p' new Size(5'5));
Magic Number,Netron.Lithium,TextLabel,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\TextLabel.cs,Hit,The following statement contains a magic number: Rectangle r= new Rectangle(p' new Size(5'5));
Magic Number,Netron.Lithium,TextLabel,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\TextLabel.cs,Paint,The following statement contains a magic number: g.DrawRectangle(new Pen(Color.Red'2F)'rectangle);
Magic Number,Netron.Lithium,TextLabel,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\TextLabel.cs,Paint,The following statement contains a magic number: g.DrawString(text'font'Brushes.Black' rectangle.X+10'rectangle.Y+10);
Magic Number,Netron.Lithium,TextLabel,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\TextLabel.cs,Paint,The following statement contains a magic number: g.DrawString(text'font'Brushes.Black' rectangle.X+10'rectangle.Y+10);
Magic Number,Netron.Lithium,TextLabel,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\TextLabel.cs,Invalidate,The following statement contains a magic number: r.Offset(-5'-5);
Magic Number,Netron.Lithium,TextLabel,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\TextLabel.cs,Invalidate,The following statement contains a magic number: r.Offset(-5'-5);
Magic Number,Netron.Lithium,TextLabel,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\TextLabel.cs,Invalidate,The following statement contains a magic number: r.Inflate(20'20);
Magic Number,Netron.Lithium,TextLabel,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\TextLabel.cs,Invalidate,The following statement contains a magic number: r.Inflate(20'20);
Magic Number,Netron.Lithium,LithiumControl,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,AddRoot,The following statement contains a magic number: root.Location = new Point(Width/2+50'Height/2+50);
Magic Number,Netron.Lithium,LithiumControl,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,AddRoot,The following statement contains a magic number: root.Location = new Point(Width/2+50'Height/2+50);
Magic Number,Netron.Lithium,LithiumControl,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,AddRoot,The following statement contains a magic number: root.Location = new Point(Width/2+50'Height/2+50);
Magic Number,Netron.Lithium,LithiumControl,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,AddRoot,The following statement contains a magic number: root.Location = new Point(Width/2+50'Height/2+50);
Magic Number,Netron.Lithium,LithiumControl,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,AddRoot,The following statement contains a magic number: root.Width = 50;
Magic Number,Netron.Lithium,LithiumControl,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,AddRoot,The following statement contains a magic number: root.Height = 25;
Magic Number,Netron.Lithium,LithiumControl,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,CenterRoot,The following statement contains a magic number: graphAbstract.Root.rectangle.Location = new Point(Width/2'Height/2);
Magic Number,Netron.Lithium,LithiumControl,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,CenterRoot,The following statement contains a magic number: graphAbstract.Root.rectangle.Location = new Point(Width/2'Height/2);
Magic Number,Netron.Lithium,LithiumControl,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,AddShape,The following statement contains a magic number: switch(type)  			{  				case ShapeTypes.Rectangular:  					shape = new SimpleRectangle(this);  					break;  				case ShapeTypes.Oval:  					shape = new OvalShape(this);  					break;  				case ShapeTypes.TextLabel:  					shape = new TextLabel(this);  					shape.Location = location;  					shape.ShapeColor = Color.Transparent;  					shape.Text = "A text label (change the text in the property grid)";  					shape.Width = 350;  					shape.Height = 30;  					Shapes.Add(shape);  					return shape;      			}
Magic Number,Netron.Lithium,LithiumControl,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,AddShape,The following statement contains a magic number: switch(type)  			{  				case ShapeTypes.Rectangular:  					shape = new SimpleRectangle(this);  					break;  				case ShapeTypes.Oval:  					shape = new OvalShape(this);  					break;  				case ShapeTypes.TextLabel:  					shape = new TextLabel(this);  					shape.Location = location;  					shape.ShapeColor = Color.Transparent;  					shape.Text = "A text label (change the text in the property grid)";  					shape.Width = 350;  					shape.Height = 30;  					Shapes.Add(shape);  					return shape;      			}
Magic Number,Netron.Lithium,LithiumControl,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,AddShape,The following statement contains a magic number: shape.ShapeColor = Color.FromArgb(rnd.Next(0'255)'rnd.Next(0'255)'rnd.Next(0'255));
Magic Number,Netron.Lithium,LithiumControl,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,AddShape,The following statement contains a magic number: shape.ShapeColor = Color.FromArgb(rnd.Next(0'255)'rnd.Next(0'255)'rnd.Next(0'255));
Magic Number,Netron.Lithium,LithiumControl,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,AddShape,The following statement contains a magic number: shape.ShapeColor = Color.FromArgb(rnd.Next(0'255)'rnd.Next(0'255)'rnd.Next(0'255));
Magic Number,Netron.Lithium,LithiumControl,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,OnMouseDown,The following statement contains a magic number: r = new Rectangle(sh.Left + sh.Width/2 - 5' sh.Bottom' 10' 10);
Magic Number,Netron.Lithium,LithiumControl,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,OnMouseDown,The following statement contains a magic number: r = new Rectangle(sh.Left + sh.Width/2 - 5' sh.Bottom' 10' 10);
Magic Number,Netron.Lithium,LithiumControl,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,OnMouseDown,The following statement contains a magic number: r = new Rectangle(sh.Left + sh.Width/2 - 5' sh.Bottom' 10' 10);
Magic Number,Netron.Lithium,LithiumControl,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,OnMouseDown,The following statement contains a magic number: r = new Rectangle(sh.Left + sh.Width/2 - 5' sh.Bottom' 10' 10);
Magic Number,Netron.Lithium,LithiumControl,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,OnMouseDown,The following statement contains a magic number: e.Button==MouseButtons.Left && e.Clicks==2
Magic Number,Netron.Lithium,LithiumControl,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,SeekNewParent,The following statement contains a magic number: double best = 10000d;
Magic Number,Netron.Lithium,LithiumControl,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,SeekNewParent,The following statement contains a magic number: dist<best && dist< 120
Magic Number,Netron.Lithium,LithiumControl,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,SeekNewParent,The following statement contains a magic number: neoCon = new Connection(shape' Shapes[chosen]'  Color.Red'2f);
Magic Number,Netron.Lithium,LithiumControl,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,Environment,The following statement contains a magic number: return Math.Sqrt((shape1.X-shape2.X)*(shape1.X-shape2.X)+(shape1.Y-shape2.Y)*(shape1.Y-shape2.Y))<100;
Magic Number,Netron.Lithium,LithiumControl,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,DrawTree,The following statement contains a magic number: switch(layoutDirection)  				{  					case TreeDirection.Vertical:  						  						p = new Point(graphAbstract.Root.X' graphAbstract.Root.Y);  						VerticalDrawTree(graphAbstract.Root'false'marginLeft'this.graphAbstract.Root.Y);						  						p = new Point(-graphAbstract.Root.X+p.X' -graphAbstract.Root.Y+ p.Y);						  						MoveDiagram(p);						  						break;  					case TreeDirection.Horizontal:  						p = new Point(graphAbstract.Root.X' graphAbstract.Root.Y);  						HorizontalDrawTree(graphAbstract.Root'false'marginLeft'10);  						p = new Point(-graphAbstract.Root.X+p.X' -graphAbstract.Root.Y+ p.Y);		  						MoveDiagram(p);	  						break;  				}
Magic Number,Netron.Lithium,LithiumControl,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,CalculateScrollBars,The following statement contains a magic number: MoveDiagram(new Point(50 - minPoint.X' 50 - minPoint.Y));
Magic Number,Netron.Lithium,LithiumControl,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,CalculateScrollBars,The following statement contains a magic number: MoveDiagram(new Point(50 - minPoint.X' 50 - minPoint.Y));
Magic Number,Netron.Lithium,LithiumControl,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,CalculateScrollBars,The following statement contains a magic number: maxSize.Width = maxSize.Width - minPoint.X + 100;
Magic Number,Netron.Lithium,LithiumControl,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,CalculateScrollBars,The following statement contains a magic number: maxSize.Height = maxSize.Height - minPoint.Y + 100;
Magic Number,Netron.Lithium,LithiumControl,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,VerticalDrawTree,The following statement contains a magic number: verticalDelta = containerNode.Height + 40;
Magic Number,Netron.Lithium,LithiumControl,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,VerticalDrawTree,The following statement contains a magic number: (branchHeight - containerNode.Height) < 30
Magic Number,Netron.Lithium,LithiumControl,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,VerticalDrawTree,The following statement contains a magic number: childrenWidth=Math.Max(Convert.ToInt32(childrenWidth + (containerNode.Width-childrenWidth)/2)' childrenWidth);
Magic Number,Netron.Lithium,LithiumControl,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,VerticalDrawTree,The following statement contains a magic number: thisX = Convert.ToInt32(containerNode.childNodes[0].X+containerNode.childNodes[0].Width/2 - containerNode.Width/2);
Magic Number,Netron.Lithium,LithiumControl,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,VerticalDrawTree,The following statement contains a magic number: thisX = Convert.ToInt32(containerNode.childNodes[0].X+containerNode.childNodes[0].Width/2 - containerNode.Width/2);
Magic Number,Netron.Lithium,LithiumControl,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,HorizontalDrawTree,The following statement contains a magic number: horizontalDelta = containerNode.Width + 40;
Magic Number,Netron.Lithium,LithiumControl,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,HorizontalDrawTree,The following statement contains a magic number: (branchHeight - containerNode.Width) < 30
Magic Number,Netron.Lithium,LithiumControl,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,HorizontalDrawTree,The following statement contains a magic number: thisY = Convert.ToInt32(firstChild + (lastChild - firstChild)/2);
Magic Number,Netron.Lithium,LithiumControl,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,Measure,The following statement contains a magic number: return Size.Round(g.MeasureString(text'Font)).Width +37;
Magic Number,Netron.Lithium,LithiumControl,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,Fit,The following statement contains a magic number: shape.Width =s.Width +20;
Magic Number,Netron.Lithium,LithiumControl,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,Fit,The following statement contains a magic number: shape.Height = s.Height+8;
Missing Default,Netron.Lithium,Connection,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Paint,The following switch statement is missing a default case: switch(site.ConnectionType)  				{  					case ConnectionType.Default:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top);   							p2 = new PointF(to.Left + to.Width/2' to.Bottom+5);  							g.DrawLine(pen'p1'p2);  							break;  						case TreeDirection.Horizontal:  							p1 = new PointF(from.Left' from.Top +  from.Height/2);   							p2 = new PointF(to.Right +4' to.Top + to.Height/2);  							g.DrawLine(pen'p1'p2);  							break;  					}  						break;  					case ConnectionType.Traditional:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p2 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  					}  						break;  					  					case ConnectionType.Bezier:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left+from.Width/2'from.Top);  							p2 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p3 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							p4 = new PointF(to.Left+to.Width/2'to.Bottom);  							g.DrawBezier(pen' p1' p2' p3' p4);  							  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right' to.Top + to.Height/2); 							  							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							p3 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p4 = new PointF(from.Left'from.Top + from.Height/2);  							g.DrawBezier(pen' p1' p2' p3' p4);  							break;  					}  						break;  				}
Missing Default,Netron.Lithium,Connection,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Paint,The following switch statement is missing a default case: switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top);   							p2 = new PointF(to.Left + to.Width/2' to.Bottom+5);  							g.DrawLine(pen'p1'p2);  							break;  						case TreeDirection.Horizontal:  							p1 = new PointF(from.Left' from.Top +  from.Height/2);   							p2 = new PointF(to.Right +4' to.Top + to.Height/2);  							g.DrawLine(pen'p1'p2);  							break;  					}
Missing Default,Netron.Lithium,Connection,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Paint,The following switch statement is missing a default case: switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p2 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  					}
Missing Default,Netron.Lithium,Connection,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Paint,The following switch statement is missing a default case: switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left+from.Width/2'from.Top);  							p2 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p3 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							p4 = new PointF(to.Left+to.Width/2'to.Bottom);  							g.DrawBezier(pen' p1' p2' p3' p4);  							  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right' to.Top + to.Height/2); 							  							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							p3 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p4 = new PointF(from.Left'from.Top + from.Height/2);  							g.DrawBezier(pen' p1' p2' p3' p4);  							break;  					}
Missing Default,Netron.Lithium,Connection,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Hit,The following switch statement is missing a default case: switch(site.ConnectionType)  			{  				case ConnectionType.Default:  					#region The default Hit method  					  					float o'u;  					p1 = start; p2 = end; 	 					// p1 must be the leftmost point. 					if (p1.X > p2.X) { s = p2; p2 = p1; p1 = s; }  					//this is specifically necessary when the layout works horizontally 					//the method beneth will not return true as should be in this case 					if(p1.Y==p2.Y) 					{ 						p1.Y+=-3; 						return new RectangleF(p1'new SizeF(p2.X-p1.X'6)).Contains(p); 					} 					r1 = new RectangleF(p1.X' p1.Y' 0' 0); 					r2 = new RectangleF(p2.X' p2.Y' 0' 0); 					r1.Inflate(3' 3); 					r2.Inflate(3' 3); 					//this is like a topological neighborhood 					//the connection is shifted left and right 					//and the point under consideration has to be in between.						 					if (RectangleF.Union(r1' r2).Contains(p)) 					{ 				 						if (p1.Y < p2.Y) //SWNE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							return ((p.X > o) && (p.X < u)); 						} 						else //NWSE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							return ((p.X > o) && (p.X < u)); 						} 					}  					#endregion  					break;  				case ConnectionType.Traditional:  					#region The rectangular Hit method  						switch(site.LayoutDirection)  						{  							case TreeDirection.Vertical:  								p1 = new PointF(from.Left + from.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5); //shift 5 to contain the connection  								p2 = new PointF(to.Left + to.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5);  								p3 = new Point(to.Left+to.Width/2-5'to.Bottom-5);    								r1 = new RectangleF(p1' new SizeF(10'(from.Top - to.Bottom)/2+5));   								if(p1.X<p2.X)  									r2 = new RectangleF(p1'new SizeF(p2.X-p1.X'10));  								else  									r2 = new RectangleF(p2'new SizeF(p1.X-p2.X'10));  								r3 = new RectangleF(p3' new SizeF(10' (from.Top - to.Bottom)/2+5));  								return r1.Contains(p.X'p.Y) || r2.Contains(p.X'p.Y) || r3.Contains(p.X'p.Y) ;  								  							case TreeDirection.Horizontal:    								p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   								p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							  								break;  						}  					#endregion  					break;  			}
Missing Default,Netron.Lithium,Connection,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Hit,The following switch statement is missing a default case: switch(site.LayoutDirection)  						{  							case TreeDirection.Vertical:  								p1 = new PointF(from.Left + from.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5); //shift 5 to contain the connection  								p2 = new PointF(to.Left + to.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5);  								p3 = new Point(to.Left+to.Width/2-5'to.Bottom-5);    								r1 = new RectangleF(p1' new SizeF(10'(from.Top - to.Bottom)/2+5));   								if(p1.X<p2.X)  									r2 = new RectangleF(p1'new SizeF(p2.X-p1.X'10));  								else  									r2 = new RectangleF(p2'new SizeF(p1.X-p2.X'10));  								r3 = new RectangleF(p3' new SizeF(10' (from.Top - to.Bottom)/2+5));  								return r1.Contains(p.X'p.Y) || r2.Contains(p.X'p.Y) || r3.Contains(p.X'p.Y) ;  								  							case TreeDirection.Horizontal:    								p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   								p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							  								break;  						}
Missing Default,Netron.Lithium,SimpleRectangle,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following switch statement is missing a default case: switch(site.LayoutDirection)  				{  				  					case TreeDirection.Vertical:  						toggleNode = new Rectangle(Left + this.Width/2 - 5' Bottom' 10' 10);  						break;  					case TreeDirection.Horizontal:  						toggleNode = new Rectangle(Right ' Top +Height/2-5 ' 10' 10);  						break;  				}
Missing Default,Netron.Lithium,LithiumControl,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,AddShape,The following switch statement is missing a default case: switch(type)  			{  				case ShapeTypes.Rectangular:  					shape = new SimpleRectangle(this);  					break;  				case ShapeTypes.Oval:  					shape = new OvalShape(this);  					break;  				case ShapeTypes.TextLabel:  					shape = new TextLabel(this);  					shape.Location = location;  					shape.ShapeColor = Color.Transparent;  					shape.Text = "A text label (change the text in the property grid)";  					shape.Width = 350;  					shape.Height = 30;  					Shapes.Add(shape);  					return shape;      			}
Missing Default,Netron.Lithium,LithiumControl,C:\research\architectureSmells\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,DrawTree,The following switch statement is missing a default case: switch(layoutDirection)  				{  					case TreeDirection.Vertical:  						  						p = new Point(graphAbstract.Root.X' graphAbstract.Root.Y);  						VerticalDrawTree(graphAbstract.Root'false'marginLeft'this.graphAbstract.Root.Y);						  						p = new Point(-graphAbstract.Root.X+p.X' -graphAbstract.Root.Y+ p.Y);						  						MoveDiagram(p);						  						break;  					case TreeDirection.Horizontal:  						p = new Point(graphAbstract.Root.X' graphAbstract.Root.Y);  						HorizontalDrawTree(graphAbstract.Root'false'marginLeft'10);  						p = new Point(-graphAbstract.Root.X+p.X' -graphAbstract.Root.Y+ p.Y);		  						MoveDiagram(p);	  						break;  				}
