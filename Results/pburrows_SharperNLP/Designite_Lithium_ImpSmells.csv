Implementation smell,Namespace,Class,File,Method,Description
Long Method,Netron.Lithium,GraphSerializer,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\IO\GraphSerializer.cs,Deserialize,The method has 102 lines of code.
Complex Method,Netron.Lithium,GraphSerializer,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\IO\GraphSerializer.cs,Deserialize,Cyclomatic complexity of the method is 13
Complex Method,Netron.Lithium,LithiumControl,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,OnMouseDown,Cyclomatic complexity of the method is 13
Complex Method,Netron.Lithium,LithiumControl,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,OnMouseMove,Cyclomatic complexity of the method is 12
Complex Method,Netron.Lithium,LithiumControl,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,DrawTree,Cyclomatic complexity of the method is 10
Complex Method,Netron.Lithium,LithiumControl,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,VerticalDrawTree,Cyclomatic complexity of the method is 9
Long Statement,Netron.Lithium,ShapeBase,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\ShapeBase.cs,Fit,The length of the statement  "				//rectangle.Width =s.Width +10 + this.childNodes.Count.ToString().Length*5 +5; //the last part is to addition for the '[child count]' part " is 138.
Long Statement,Netron.Lithium,SimpleRectangle,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The length of the statement  "				g.DrawLine(blackPen' (toggleNode.X + 2)' (toggleNode.Y + (toggleNode.Height / 2))' (toggleNode.X + (toggleNode.Width - 2))' (toggleNode.Y + (toggleNode.Height / 2)) ); " is 167.
Long Statement,Netron.Lithium,SimpleRectangle,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The length of the statement  "					g.DrawLine(blackPen' (toggleNode.X + (toggleNode.Width /2))' (toggleNode.Y + 2)' (toggleNode.X + (toggleNode.Width /2))' (toggleNode.Y + (toggleNode.Height - 2))); " is 163.
Long Statement,Netron.Lithium,LithiumControl,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,OnPaintBackground,The length of the statement  "//			g.DrawString("Lithium Tree Layout Control [version " + System.Reflection.Assembly.GetExecutingAssembly().GetName().Version.ToString() + "]"'Font'Brushes.SlateGray'new Point(20'10)); " is 186.
Long Statement,Netron.Lithium,LithiumControl,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,VerticalDrawTree,The length of the statement  "					returned = VerticalDrawTree(containerNode.childNodes[i]' isFirst' shiftLeft + childrenWidth' shiftTop + verticalDelta );									 " is 120.
Long Statement,Netron.Lithium,LithiumControl,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,VerticalDrawTree,The length of the statement  "				childrenWidth=Math.Max(Convert.ToInt32(childrenWidth + (containerNode.Width-childrenWidth)/2)' childrenWidth); //in case the length of the containerNode is bigger than the total length of the children " is 200.
Long Statement,Netron.Lithium,LithiumControl,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,VerticalDrawTree,The length of the statement  "					float lastChild = containerNode.childNodes[containerNode.childNodes.Count-1].Left + containerNode.childNodes[containerNode.childNodes.Count-1].Width/2; " is 151.
Long Statement,Netron.Lithium,LithiumControl,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,HorizontalDrawTree,The length of the statement  "					returned = HorizontalDrawTree(containerNode.childNodes[i]' isFirst' shiftLeft + horizontalDelta ' shiftTop + childrenHeight );					 " is 126.
Complex Conditional,Netron.Lithium,ConnectionCollection,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Collections\ConnectionCollection.cs,Remove,The conditional expression  "(this[k].From ==one && this[k].To==two) || (this[k].From ==two && this[k].To==one)"  is complex.
Complex Conditional,Netron.Lithium,LithiumControl,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,SeekNewParent,The conditional expression  "other!=shape && other.visible && other.parentNode!=shape && !other.pickup"  is complex.
Magic Number,Netron.Lithium,Connection,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Paint,The following statement contains a magic number: if(visible)  			{  				if(hovered || isSelected)  					pen = redPen;  				else  					pen = currentPen;    				switch(site.ConnectionType)  				{  					case ConnectionType.Default:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top);   							p2 = new PointF(to.Left + to.Width/2' to.Bottom+5);  							g.DrawLine(pen'p1'p2);  							break;  						case TreeDirection.Horizontal:  							p1 = new PointF(from.Left' from.Top +  from.Height/2);   							p2 = new PointF(to.Right +4' to.Top + to.Height/2);  							g.DrawLine(pen'p1'p2);  							break;  					}  						break;  					case ConnectionType.Traditional:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p2 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  					}  						break;  					  					case ConnectionType.Bezier:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left+from.Width/2'from.Top);  							p2 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p3 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							p4 = new PointF(to.Left+to.Width/2'to.Bottom);  							g.DrawBezier(pen' p1' p2' p3' p4);  							  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right' to.Top + to.Height/2); 							  							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							p3 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p4 = new PointF(from.Left'from.Top + from.Height/2);  							g.DrawBezier(pen' p1' p2' p3' p4);  							break;  					}  						break;  				}  			}
Magic Number,Netron.Lithium,Connection,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Paint,The following statement contains a magic number: if(visible)  			{  				if(hovered || isSelected)  					pen = redPen;  				else  					pen = currentPen;    				switch(site.ConnectionType)  				{  					case ConnectionType.Default:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top);   							p2 = new PointF(to.Left + to.Width/2' to.Bottom+5);  							g.DrawLine(pen'p1'p2);  							break;  						case TreeDirection.Horizontal:  							p1 = new PointF(from.Left' from.Top +  from.Height/2);   							p2 = new PointF(to.Right +4' to.Top + to.Height/2);  							g.DrawLine(pen'p1'p2);  							break;  					}  						break;  					case ConnectionType.Traditional:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p2 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  					}  						break;  					  					case ConnectionType.Bezier:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left+from.Width/2'from.Top);  							p2 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p3 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							p4 = new PointF(to.Left+to.Width/2'to.Bottom);  							g.DrawBezier(pen' p1' p2' p3' p4);  							  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right' to.Top + to.Height/2); 							  							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							p3 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p4 = new PointF(from.Left'from.Top + from.Height/2);  							g.DrawBezier(pen' p1' p2' p3' p4);  							break;  					}  						break;  				}  			}
Magic Number,Netron.Lithium,Connection,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Paint,The following statement contains a magic number: if(visible)  			{  				if(hovered || isSelected)  					pen = redPen;  				else  					pen = currentPen;    				switch(site.ConnectionType)  				{  					case ConnectionType.Default:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top);   							p2 = new PointF(to.Left + to.Width/2' to.Bottom+5);  							g.DrawLine(pen'p1'p2);  							break;  						case TreeDirection.Horizontal:  							p1 = new PointF(from.Left' from.Top +  from.Height/2);   							p2 = new PointF(to.Right +4' to.Top + to.Height/2);  							g.DrawLine(pen'p1'p2);  							break;  					}  						break;  					case ConnectionType.Traditional:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p2 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  					}  						break;  					  					case ConnectionType.Bezier:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left+from.Width/2'from.Top);  							p2 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p3 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							p4 = new PointF(to.Left+to.Width/2'to.Bottom);  							g.DrawBezier(pen' p1' p2' p3' p4);  							  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right' to.Top + to.Height/2); 							  							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							p3 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p4 = new PointF(from.Left'from.Top + from.Height/2);  							g.DrawBezier(pen' p1' p2' p3' p4);  							break;  					}  						break;  				}  			}
Magic Number,Netron.Lithium,Connection,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Paint,The following statement contains a magic number: if(visible)  			{  				if(hovered || isSelected)  					pen = redPen;  				else  					pen = currentPen;    				switch(site.ConnectionType)  				{  					case ConnectionType.Default:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top);   							p2 = new PointF(to.Left + to.Width/2' to.Bottom+5);  							g.DrawLine(pen'p1'p2);  							break;  						case TreeDirection.Horizontal:  							p1 = new PointF(from.Left' from.Top +  from.Height/2);   							p2 = new PointF(to.Right +4' to.Top + to.Height/2);  							g.DrawLine(pen'p1'p2);  							break;  					}  						break;  					case ConnectionType.Traditional:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p2 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  					}  						break;  					  					case ConnectionType.Bezier:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left+from.Width/2'from.Top);  							p2 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p3 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							p4 = new PointF(to.Left+to.Width/2'to.Bottom);  							g.DrawBezier(pen' p1' p2' p3' p4);  							  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right' to.Top + to.Height/2); 							  							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							p3 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p4 = new PointF(from.Left'from.Top + from.Height/2);  							g.DrawBezier(pen' p1' p2' p3' p4);  							break;  					}  						break;  				}  			}
Magic Number,Netron.Lithium,Connection,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Paint,The following statement contains a magic number: if(visible)  			{  				if(hovered || isSelected)  					pen = redPen;  				else  					pen = currentPen;    				switch(site.ConnectionType)  				{  					case ConnectionType.Default:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top);   							p2 = new PointF(to.Left + to.Width/2' to.Bottom+5);  							g.DrawLine(pen'p1'p2);  							break;  						case TreeDirection.Horizontal:  							p1 = new PointF(from.Left' from.Top +  from.Height/2);   							p2 = new PointF(to.Right +4' to.Top + to.Height/2);  							g.DrawLine(pen'p1'p2);  							break;  					}  						break;  					case ConnectionType.Traditional:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p2 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  					}  						break;  					  					case ConnectionType.Bezier:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left+from.Width/2'from.Top);  							p2 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p3 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							p4 = new PointF(to.Left+to.Width/2'to.Bottom);  							g.DrawBezier(pen' p1' p2' p3' p4);  							  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right' to.Top + to.Height/2); 							  							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							p3 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p4 = new PointF(from.Left'from.Top + from.Height/2);  							g.DrawBezier(pen' p1' p2' p3' p4);  							break;  					}  						break;  				}  			}
Magic Number,Netron.Lithium,Connection,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Paint,The following statement contains a magic number: if(visible)  			{  				if(hovered || isSelected)  					pen = redPen;  				else  					pen = currentPen;    				switch(site.ConnectionType)  				{  					case ConnectionType.Default:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top);   							p2 = new PointF(to.Left + to.Width/2' to.Bottom+5);  							g.DrawLine(pen'p1'p2);  							break;  						case TreeDirection.Horizontal:  							p1 = new PointF(from.Left' from.Top +  from.Height/2);   							p2 = new PointF(to.Right +4' to.Top + to.Height/2);  							g.DrawLine(pen'p1'p2);  							break;  					}  						break;  					case ConnectionType.Traditional:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p2 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  					}  						break;  					  					case ConnectionType.Bezier:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left+from.Width/2'from.Top);  							p2 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p3 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							p4 = new PointF(to.Left+to.Width/2'to.Bottom);  							g.DrawBezier(pen' p1' p2' p3' p4);  							  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right' to.Top + to.Height/2); 							  							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							p3 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p4 = new PointF(from.Left'from.Top + from.Height/2);  							g.DrawBezier(pen' p1' p2' p3' p4);  							break;  					}  						break;  				}  			}
Magic Number,Netron.Lithium,Connection,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Paint,The following statement contains a magic number: if(visible)  			{  				if(hovered || isSelected)  					pen = redPen;  				else  					pen = currentPen;    				switch(site.ConnectionType)  				{  					case ConnectionType.Default:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top);   							p2 = new PointF(to.Left + to.Width/2' to.Bottom+5);  							g.DrawLine(pen'p1'p2);  							break;  						case TreeDirection.Horizontal:  							p1 = new PointF(from.Left' from.Top +  from.Height/2);   							p2 = new PointF(to.Right +4' to.Top + to.Height/2);  							g.DrawLine(pen'p1'p2);  							break;  					}  						break;  					case ConnectionType.Traditional:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p2 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  					}  						break;  					  					case ConnectionType.Bezier:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left+from.Width/2'from.Top);  							p2 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p3 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							p4 = new PointF(to.Left+to.Width/2'to.Bottom);  							g.DrawBezier(pen' p1' p2' p3' p4);  							  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right' to.Top + to.Height/2); 							  							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							p3 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p4 = new PointF(from.Left'from.Top + from.Height/2);  							g.DrawBezier(pen' p1' p2' p3' p4);  							break;  					}  						break;  				}  			}
Magic Number,Netron.Lithium,Connection,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Paint,The following statement contains a magic number: if(visible)  			{  				if(hovered || isSelected)  					pen = redPen;  				else  					pen = currentPen;    				switch(site.ConnectionType)  				{  					case ConnectionType.Default:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top);   							p2 = new PointF(to.Left + to.Width/2' to.Bottom+5);  							g.DrawLine(pen'p1'p2);  							break;  						case TreeDirection.Horizontal:  							p1 = new PointF(from.Left' from.Top +  from.Height/2);   							p2 = new PointF(to.Right +4' to.Top + to.Height/2);  							g.DrawLine(pen'p1'p2);  							break;  					}  						break;  					case ConnectionType.Traditional:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p2 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  					}  						break;  					  					case ConnectionType.Bezier:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left+from.Width/2'from.Top);  							p2 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p3 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							p4 = new PointF(to.Left+to.Width/2'to.Bottom);  							g.DrawBezier(pen' p1' p2' p3' p4);  							  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right' to.Top + to.Height/2); 							  							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							p3 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p4 = new PointF(from.Left'from.Top + from.Height/2);  							g.DrawBezier(pen' p1' p2' p3' p4);  							break;  					}  						break;  				}  			}
Magic Number,Netron.Lithium,Connection,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Paint,The following statement contains a magic number: if(visible)  			{  				if(hovered || isSelected)  					pen = redPen;  				else  					pen = currentPen;    				switch(site.ConnectionType)  				{  					case ConnectionType.Default:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top);   							p2 = new PointF(to.Left + to.Width/2' to.Bottom+5);  							g.DrawLine(pen'p1'p2);  							break;  						case TreeDirection.Horizontal:  							p1 = new PointF(from.Left' from.Top +  from.Height/2);   							p2 = new PointF(to.Right +4' to.Top + to.Height/2);  							g.DrawLine(pen'p1'p2);  							break;  					}  						break;  					case ConnectionType.Traditional:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p2 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  					}  						break;  					  					case ConnectionType.Bezier:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left+from.Width/2'from.Top);  							p2 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p3 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							p4 = new PointF(to.Left+to.Width/2'to.Bottom);  							g.DrawBezier(pen' p1' p2' p3' p4);  							  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right' to.Top + to.Height/2); 							  							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							p3 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p4 = new PointF(from.Left'from.Top + from.Height/2);  							g.DrawBezier(pen' p1' p2' p3' p4);  							break;  					}  						break;  				}  			}
Magic Number,Netron.Lithium,Connection,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Paint,The following statement contains a magic number: if(visible)  			{  				if(hovered || isSelected)  					pen = redPen;  				else  					pen = currentPen;    				switch(site.ConnectionType)  				{  					case ConnectionType.Default:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top);   							p2 = new PointF(to.Left + to.Width/2' to.Bottom+5);  							g.DrawLine(pen'p1'p2);  							break;  						case TreeDirection.Horizontal:  							p1 = new PointF(from.Left' from.Top +  from.Height/2);   							p2 = new PointF(to.Right +4' to.Top + to.Height/2);  							g.DrawLine(pen'p1'p2);  							break;  					}  						break;  					case ConnectionType.Traditional:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p2 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  					}  						break;  					  					case ConnectionType.Bezier:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left+from.Width/2'from.Top);  							p2 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p3 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							p4 = new PointF(to.Left+to.Width/2'to.Bottom);  							g.DrawBezier(pen' p1' p2' p3' p4);  							  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right' to.Top + to.Height/2); 							  							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							p3 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p4 = new PointF(from.Left'from.Top + from.Height/2);  							g.DrawBezier(pen' p1' p2' p3' p4);  							break;  					}  						break;  				}  			}
Magic Number,Netron.Lithium,Connection,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Paint,The following statement contains a magic number: if(visible)  			{  				if(hovered || isSelected)  					pen = redPen;  				else  					pen = currentPen;    				switch(site.ConnectionType)  				{  					case ConnectionType.Default:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top);   							p2 = new PointF(to.Left + to.Width/2' to.Bottom+5);  							g.DrawLine(pen'p1'p2);  							break;  						case TreeDirection.Horizontal:  							p1 = new PointF(from.Left' from.Top +  from.Height/2);   							p2 = new PointF(to.Right +4' to.Top + to.Height/2);  							g.DrawLine(pen'p1'p2);  							break;  					}  						break;  					case ConnectionType.Traditional:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p2 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  					}  						break;  					  					case ConnectionType.Bezier:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left+from.Width/2'from.Top);  							p2 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p3 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							p4 = new PointF(to.Left+to.Width/2'to.Bottom);  							g.DrawBezier(pen' p1' p2' p3' p4);  							  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right' to.Top + to.Height/2); 							  							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							p3 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p4 = new PointF(from.Left'from.Top + from.Height/2);  							g.DrawBezier(pen' p1' p2' p3' p4);  							break;  					}  						break;  				}  			}
Magic Number,Netron.Lithium,Connection,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Paint,The following statement contains a magic number: if(visible)  			{  				if(hovered || isSelected)  					pen = redPen;  				else  					pen = currentPen;    				switch(site.ConnectionType)  				{  					case ConnectionType.Default:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top);   							p2 = new PointF(to.Left + to.Width/2' to.Bottom+5);  							g.DrawLine(pen'p1'p2);  							break;  						case TreeDirection.Horizontal:  							p1 = new PointF(from.Left' from.Top +  from.Height/2);   							p2 = new PointF(to.Right +4' to.Top + to.Height/2);  							g.DrawLine(pen'p1'p2);  							break;  					}  						break;  					case ConnectionType.Traditional:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p2 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  					}  						break;  					  					case ConnectionType.Bezier:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left+from.Width/2'from.Top);  							p2 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p3 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							p4 = new PointF(to.Left+to.Width/2'to.Bottom);  							g.DrawBezier(pen' p1' p2' p3' p4);  							  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right' to.Top + to.Height/2); 							  							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							p3 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p4 = new PointF(from.Left'from.Top + from.Height/2);  							g.DrawBezier(pen' p1' p2' p3' p4);  							break;  					}  						break;  				}  			}
Magic Number,Netron.Lithium,Connection,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Paint,The following statement contains a magic number: if(visible)  			{  				if(hovered || isSelected)  					pen = redPen;  				else  					pen = currentPen;    				switch(site.ConnectionType)  				{  					case ConnectionType.Default:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top);   							p2 = new PointF(to.Left + to.Width/2' to.Bottom+5);  							g.DrawLine(pen'p1'p2);  							break;  						case TreeDirection.Horizontal:  							p1 = new PointF(from.Left' from.Top +  from.Height/2);   							p2 = new PointF(to.Right +4' to.Top + to.Height/2);  							g.DrawLine(pen'p1'p2);  							break;  					}  						break;  					case ConnectionType.Traditional:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p2 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  					}  						break;  					  					case ConnectionType.Bezier:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left+from.Width/2'from.Top);  							p2 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p3 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							p4 = new PointF(to.Left+to.Width/2'to.Bottom);  							g.DrawBezier(pen' p1' p2' p3' p4);  							  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right' to.Top + to.Height/2); 							  							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							p3 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p4 = new PointF(from.Left'from.Top + from.Height/2);  							g.DrawBezier(pen' p1' p2' p3' p4);  							break;  					}  						break;  				}  			}
Magic Number,Netron.Lithium,Connection,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Paint,The following statement contains a magic number: if(visible)  			{  				if(hovered || isSelected)  					pen = redPen;  				else  					pen = currentPen;    				switch(site.ConnectionType)  				{  					case ConnectionType.Default:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top);   							p2 = new PointF(to.Left + to.Width/2' to.Bottom+5);  							g.DrawLine(pen'p1'p2);  							break;  						case TreeDirection.Horizontal:  							p1 = new PointF(from.Left' from.Top +  from.Height/2);   							p2 = new PointF(to.Right +4' to.Top + to.Height/2);  							g.DrawLine(pen'p1'p2);  							break;  					}  						break;  					case ConnectionType.Traditional:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p2 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  					}  						break;  					  					case ConnectionType.Bezier:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left+from.Width/2'from.Top);  							p2 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p3 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							p4 = new PointF(to.Left+to.Width/2'to.Bottom);  							g.DrawBezier(pen' p1' p2' p3' p4);  							  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right' to.Top + to.Height/2); 							  							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							p3 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p4 = new PointF(from.Left'from.Top + from.Height/2);  							g.DrawBezier(pen' p1' p2' p3' p4);  							break;  					}  						break;  				}  			}
Magic Number,Netron.Lithium,Connection,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Paint,The following statement contains a magic number: if(visible)  			{  				if(hovered || isSelected)  					pen = redPen;  				else  					pen = currentPen;    				switch(site.ConnectionType)  				{  					case ConnectionType.Default:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top);   							p2 = new PointF(to.Left + to.Width/2' to.Bottom+5);  							g.DrawLine(pen'p1'p2);  							break;  						case TreeDirection.Horizontal:  							p1 = new PointF(from.Left' from.Top +  from.Height/2);   							p2 = new PointF(to.Right +4' to.Top + to.Height/2);  							g.DrawLine(pen'p1'p2);  							break;  					}  						break;  					case ConnectionType.Traditional:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p2 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  					}  						break;  					  					case ConnectionType.Bezier:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left+from.Width/2'from.Top);  							p2 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p3 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							p4 = new PointF(to.Left+to.Width/2'to.Bottom);  							g.DrawBezier(pen' p1' p2' p3' p4);  							  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right' to.Top + to.Height/2); 							  							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							p3 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p4 = new PointF(from.Left'from.Top + from.Height/2);  							g.DrawBezier(pen' p1' p2' p3' p4);  							break;  					}  						break;  				}  			}
Magic Number,Netron.Lithium,Connection,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Paint,The following statement contains a magic number: if(visible)  			{  				if(hovered || isSelected)  					pen = redPen;  				else  					pen = currentPen;    				switch(site.ConnectionType)  				{  					case ConnectionType.Default:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top);   							p2 = new PointF(to.Left + to.Width/2' to.Bottom+5);  							g.DrawLine(pen'p1'p2);  							break;  						case TreeDirection.Horizontal:  							p1 = new PointF(from.Left' from.Top +  from.Height/2);   							p2 = new PointF(to.Right +4' to.Top + to.Height/2);  							g.DrawLine(pen'p1'p2);  							break;  					}  						break;  					case ConnectionType.Traditional:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p2 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  					}  						break;  					  					case ConnectionType.Bezier:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left+from.Width/2'from.Top);  							p2 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p3 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							p4 = new PointF(to.Left+to.Width/2'to.Bottom);  							g.DrawBezier(pen' p1' p2' p3' p4);  							  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right' to.Top + to.Height/2); 							  							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							p3 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p4 = new PointF(from.Left'from.Top + from.Height/2);  							g.DrawBezier(pen' p1' p2' p3' p4);  							break;  					}  						break;  				}  			}
Magic Number,Netron.Lithium,Connection,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Paint,The following statement contains a magic number: if(visible)  			{  				if(hovered || isSelected)  					pen = redPen;  				else  					pen = currentPen;    				switch(site.ConnectionType)  				{  					case ConnectionType.Default:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top);   							p2 = new PointF(to.Left + to.Width/2' to.Bottom+5);  							g.DrawLine(pen'p1'p2);  							break;  						case TreeDirection.Horizontal:  							p1 = new PointF(from.Left' from.Top +  from.Height/2);   							p2 = new PointF(to.Right +4' to.Top + to.Height/2);  							g.DrawLine(pen'p1'p2);  							break;  					}  						break;  					case ConnectionType.Traditional:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p2 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  					}  						break;  					  					case ConnectionType.Bezier:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left+from.Width/2'from.Top);  							p2 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p3 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							p4 = new PointF(to.Left+to.Width/2'to.Bottom);  							g.DrawBezier(pen' p1' p2' p3' p4);  							  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right' to.Top + to.Height/2); 							  							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							p3 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p4 = new PointF(from.Left'from.Top + from.Height/2);  							g.DrawBezier(pen' p1' p2' p3' p4);  							break;  					}  						break;  				}  			}
Magic Number,Netron.Lithium,Connection,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Paint,The following statement contains a magic number: if(visible)  			{  				if(hovered || isSelected)  					pen = redPen;  				else  					pen = currentPen;    				switch(site.ConnectionType)  				{  					case ConnectionType.Default:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top);   							p2 = new PointF(to.Left + to.Width/2' to.Bottom+5);  							g.DrawLine(pen'p1'p2);  							break;  						case TreeDirection.Horizontal:  							p1 = new PointF(from.Left' from.Top +  from.Height/2);   							p2 = new PointF(to.Right +4' to.Top + to.Height/2);  							g.DrawLine(pen'p1'p2);  							break;  					}  						break;  					case ConnectionType.Traditional:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p2 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  					}  						break;  					  					case ConnectionType.Bezier:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left+from.Width/2'from.Top);  							p2 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p3 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							p4 = new PointF(to.Left+to.Width/2'to.Bottom);  							g.DrawBezier(pen' p1' p2' p3' p4);  							  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right' to.Top + to.Height/2); 							  							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							p3 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p4 = new PointF(from.Left'from.Top + from.Height/2);  							g.DrawBezier(pen' p1' p2' p3' p4);  							break;  					}  						break;  				}  			}
Magic Number,Netron.Lithium,Connection,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Paint,The following statement contains a magic number: if(visible)  			{  				if(hovered || isSelected)  					pen = redPen;  				else  					pen = currentPen;    				switch(site.ConnectionType)  				{  					case ConnectionType.Default:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top);   							p2 = new PointF(to.Left + to.Width/2' to.Bottom+5);  							g.DrawLine(pen'p1'p2);  							break;  						case TreeDirection.Horizontal:  							p1 = new PointF(from.Left' from.Top +  from.Height/2);   							p2 = new PointF(to.Right +4' to.Top + to.Height/2);  							g.DrawLine(pen'p1'p2);  							break;  					}  						break;  					case ConnectionType.Traditional:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p2 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  					}  						break;  					  					case ConnectionType.Bezier:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left+from.Width/2'from.Top);  							p2 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p3 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							p4 = new PointF(to.Left+to.Width/2'to.Bottom);  							g.DrawBezier(pen' p1' p2' p3' p4);  							  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right' to.Top + to.Height/2); 							  							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							p3 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p4 = new PointF(from.Left'from.Top + from.Height/2);  							g.DrawBezier(pen' p1' p2' p3' p4);  							break;  					}  						break;  				}  			}
Magic Number,Netron.Lithium,Connection,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Paint,The following statement contains a magic number: if(visible)  			{  				if(hovered || isSelected)  					pen = redPen;  				else  					pen = currentPen;    				switch(site.ConnectionType)  				{  					case ConnectionType.Default:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top);   							p2 = new PointF(to.Left + to.Width/2' to.Bottom+5);  							g.DrawLine(pen'p1'p2);  							break;  						case TreeDirection.Horizontal:  							p1 = new PointF(from.Left' from.Top +  from.Height/2);   							p2 = new PointF(to.Right +4' to.Top + to.Height/2);  							g.DrawLine(pen'p1'p2);  							break;  					}  						break;  					case ConnectionType.Traditional:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p2 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  					}  						break;  					  					case ConnectionType.Bezier:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left+from.Width/2'from.Top);  							p2 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p3 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							p4 = new PointF(to.Left+to.Width/2'to.Bottom);  							g.DrawBezier(pen' p1' p2' p3' p4);  							  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right' to.Top + to.Height/2); 							  							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							p3 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p4 = new PointF(from.Left'from.Top + from.Height/2);  							g.DrawBezier(pen' p1' p2' p3' p4);  							break;  					}  						break;  				}  			}
Magic Number,Netron.Lithium,Connection,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Paint,The following statement contains a magic number: if(visible)  			{  				if(hovered || isSelected)  					pen = redPen;  				else  					pen = currentPen;    				switch(site.ConnectionType)  				{  					case ConnectionType.Default:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top);   							p2 = new PointF(to.Left + to.Width/2' to.Bottom+5);  							g.DrawLine(pen'p1'p2);  							break;  						case TreeDirection.Horizontal:  							p1 = new PointF(from.Left' from.Top +  from.Height/2);   							p2 = new PointF(to.Right +4' to.Top + to.Height/2);  							g.DrawLine(pen'p1'p2);  							break;  					}  						break;  					case ConnectionType.Traditional:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p2 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  					}  						break;  					  					case ConnectionType.Bezier:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left+from.Width/2'from.Top);  							p2 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p3 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							p4 = new PointF(to.Left+to.Width/2'to.Bottom);  							g.DrawBezier(pen' p1' p2' p3' p4);  							  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right' to.Top + to.Height/2); 							  							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							p3 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p4 = new PointF(from.Left'from.Top + from.Height/2);  							g.DrawBezier(pen' p1' p2' p3' p4);  							break;  					}  						break;  				}  			}
Magic Number,Netron.Lithium,Connection,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Paint,The following statement contains a magic number: if(visible)  			{  				if(hovered || isSelected)  					pen = redPen;  				else  					pen = currentPen;    				switch(site.ConnectionType)  				{  					case ConnectionType.Default:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top);   							p2 = new PointF(to.Left + to.Width/2' to.Bottom+5);  							g.DrawLine(pen'p1'p2);  							break;  						case TreeDirection.Horizontal:  							p1 = new PointF(from.Left' from.Top +  from.Height/2);   							p2 = new PointF(to.Right +4' to.Top + to.Height/2);  							g.DrawLine(pen'p1'p2);  							break;  					}  						break;  					case ConnectionType.Traditional:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p2 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  					}  						break;  					  					case ConnectionType.Bezier:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left+from.Width/2'from.Top);  							p2 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p3 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							p4 = new PointF(to.Left+to.Width/2'to.Bottom);  							g.DrawBezier(pen' p1' p2' p3' p4);  							  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right' to.Top + to.Height/2); 							  							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							p3 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p4 = new PointF(from.Left'from.Top + from.Height/2);  							g.DrawBezier(pen' p1' p2' p3' p4);  							break;  					}  						break;  				}  			}
Magic Number,Netron.Lithium,Connection,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Paint,The following statement contains a magic number: if(visible)  			{  				if(hovered || isSelected)  					pen = redPen;  				else  					pen = currentPen;    				switch(site.ConnectionType)  				{  					case ConnectionType.Default:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top);   							p2 = new PointF(to.Left + to.Width/2' to.Bottom+5);  							g.DrawLine(pen'p1'p2);  							break;  						case TreeDirection.Horizontal:  							p1 = new PointF(from.Left' from.Top +  from.Height/2);   							p2 = new PointF(to.Right +4' to.Top + to.Height/2);  							g.DrawLine(pen'p1'p2);  							break;  					}  						break;  					case ConnectionType.Traditional:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p2 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  					}  						break;  					  					case ConnectionType.Bezier:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left+from.Width/2'from.Top);  							p2 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p3 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							p4 = new PointF(to.Left+to.Width/2'to.Bottom);  							g.DrawBezier(pen' p1' p2' p3' p4);  							  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right' to.Top + to.Height/2); 							  							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							p3 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p4 = new PointF(from.Left'from.Top + from.Height/2);  							g.DrawBezier(pen' p1' p2' p3' p4);  							break;  					}  						break;  				}  			}
Magic Number,Netron.Lithium,Connection,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Paint,The following statement contains a magic number: if(visible)  			{  				if(hovered || isSelected)  					pen = redPen;  				else  					pen = currentPen;    				switch(site.ConnectionType)  				{  					case ConnectionType.Default:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top);   							p2 = new PointF(to.Left + to.Width/2' to.Bottom+5);  							g.DrawLine(pen'p1'p2);  							break;  						case TreeDirection.Horizontal:  							p1 = new PointF(from.Left' from.Top +  from.Height/2);   							p2 = new PointF(to.Right +4' to.Top + to.Height/2);  							g.DrawLine(pen'p1'p2);  							break;  					}  						break;  					case ConnectionType.Traditional:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p2 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  					}  						break;  					  					case ConnectionType.Bezier:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left+from.Width/2'from.Top);  							p2 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p3 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							p4 = new PointF(to.Left+to.Width/2'to.Bottom);  							g.DrawBezier(pen' p1' p2' p3' p4);  							  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right' to.Top + to.Height/2); 							  							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							p3 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p4 = new PointF(from.Left'from.Top + from.Height/2);  							g.DrawBezier(pen' p1' p2' p3' p4);  							break;  					}  						break;  				}  			}
Magic Number,Netron.Lithium,Connection,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Paint,The following statement contains a magic number: if(visible)  			{  				if(hovered || isSelected)  					pen = redPen;  				else  					pen = currentPen;    				switch(site.ConnectionType)  				{  					case ConnectionType.Default:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top);   							p2 = new PointF(to.Left + to.Width/2' to.Bottom+5);  							g.DrawLine(pen'p1'p2);  							break;  						case TreeDirection.Horizontal:  							p1 = new PointF(from.Left' from.Top +  from.Height/2);   							p2 = new PointF(to.Right +4' to.Top + to.Height/2);  							g.DrawLine(pen'p1'p2);  							break;  					}  						break;  					case ConnectionType.Traditional:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p2 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  					}  						break;  					  					case ConnectionType.Bezier:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left+from.Width/2'from.Top);  							p2 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p3 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							p4 = new PointF(to.Left+to.Width/2'to.Bottom);  							g.DrawBezier(pen' p1' p2' p3' p4);  							  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right' to.Top + to.Height/2); 							  							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							p3 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p4 = new PointF(from.Left'from.Top + from.Height/2);  							g.DrawBezier(pen' p1' p2' p3' p4);  							break;  					}  						break;  				}  			}
Magic Number,Netron.Lithium,Connection,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Paint,The following statement contains a magic number: if(visible)  			{  				if(hovered || isSelected)  					pen = redPen;  				else  					pen = currentPen;    				switch(site.ConnectionType)  				{  					case ConnectionType.Default:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top);   							p2 = new PointF(to.Left + to.Width/2' to.Bottom+5);  							g.DrawLine(pen'p1'p2);  							break;  						case TreeDirection.Horizontal:  							p1 = new PointF(from.Left' from.Top +  from.Height/2);   							p2 = new PointF(to.Right +4' to.Top + to.Height/2);  							g.DrawLine(pen'p1'p2);  							break;  					}  						break;  					case ConnectionType.Traditional:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p2 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  					}  						break;  					  					case ConnectionType.Bezier:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left+from.Width/2'from.Top);  							p2 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p3 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							p4 = new PointF(to.Left+to.Width/2'to.Bottom);  							g.DrawBezier(pen' p1' p2' p3' p4);  							  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right' to.Top + to.Height/2); 							  							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							p3 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p4 = new PointF(from.Left'from.Top + from.Height/2);  							g.DrawBezier(pen' p1' p2' p3' p4);  							break;  					}  						break;  				}  			}
Magic Number,Netron.Lithium,Connection,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Hit,The following statement contains a magic number: switch(site.ConnectionType)  			{  				case ConnectionType.Default:  					#region The default Hit method  					  					float o'u;  					p1 = start; p2 = end; 	 					// p1 must be the leftmost point. 					if (p1.X > p2.X) { s = p2; p2 = p1; p1 = s; }  					//this is specifically necessary when the layout works horizontally 					//the method beneth will not return true as should be in this case 					if(p1.Y==p2.Y) 					{ 						p1.Y+=-3; 						return new RectangleF(p1'new SizeF(p2.X-p1.X'6)).Contains(p); 					} 					r1 = new RectangleF(p1.X' p1.Y' 0' 0); 					r2 = new RectangleF(p2.X' p2.Y' 0' 0); 					r1.Inflate(3' 3); 					r2.Inflate(3' 3); 					//this is like a topological neighborhood 					//the connection is shifted left and right 					//and the point under consideration has to be in between.						 					if (RectangleF.Union(r1' r2).Contains(p)) 					{ 				 						if (p1.Y < p2.Y) //SWNE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							return ((p.X > o) && (p.X < u)); 						} 						else //NWSE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							return ((p.X > o) && (p.X < u)); 						} 					}  					#endregion  					break;  				case ConnectionType.Traditional:  					#region The rectangular Hit method  						switch(site.LayoutDirection)  						{  							case TreeDirection.Vertical:  								p1 = new PointF(from.Left + from.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5); //shift 5 to contain the connection  								p2 = new PointF(to.Left + to.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5);  								p3 = new Point(to.Left+to.Width/2-5'to.Bottom-5);    								r1 = new RectangleF(p1' new SizeF(10'(from.Top - to.Bottom)/2+5));   								if(p1.X<p2.X)  									r2 = new RectangleF(p1'new SizeF(p2.X-p1.X'10));  								else  									r2 = new RectangleF(p2'new SizeF(p1.X-p2.X'10));  								r3 = new RectangleF(p3' new SizeF(10' (from.Top - to.Bottom)/2+5));  								return r1.Contains(p.X'p.Y) || r2.Contains(p.X'p.Y) || r3.Contains(p.X'p.Y) ;  								  							case TreeDirection.Horizontal:    								p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   								p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							  								break;  						}  					#endregion  					break;  			}
Magic Number,Netron.Lithium,Connection,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Hit,The following statement contains a magic number: switch(site.ConnectionType)  			{  				case ConnectionType.Default:  					#region The default Hit method  					  					float o'u;  					p1 = start; p2 = end; 	 					// p1 must be the leftmost point. 					if (p1.X > p2.X) { s = p2; p2 = p1; p1 = s; }  					//this is specifically necessary when the layout works horizontally 					//the method beneth will not return true as should be in this case 					if(p1.Y==p2.Y) 					{ 						p1.Y+=-3; 						return new RectangleF(p1'new SizeF(p2.X-p1.X'6)).Contains(p); 					} 					r1 = new RectangleF(p1.X' p1.Y' 0' 0); 					r2 = new RectangleF(p2.X' p2.Y' 0' 0); 					r1.Inflate(3' 3); 					r2.Inflate(3' 3); 					//this is like a topological neighborhood 					//the connection is shifted left and right 					//and the point under consideration has to be in between.						 					if (RectangleF.Union(r1' r2).Contains(p)) 					{ 				 						if (p1.Y < p2.Y) //SWNE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							return ((p.X > o) && (p.X < u)); 						} 						else //NWSE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							return ((p.X > o) && (p.X < u)); 						} 					}  					#endregion  					break;  				case ConnectionType.Traditional:  					#region The rectangular Hit method  						switch(site.LayoutDirection)  						{  							case TreeDirection.Vertical:  								p1 = new PointF(from.Left + from.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5); //shift 5 to contain the connection  								p2 = new PointF(to.Left + to.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5);  								p3 = new Point(to.Left+to.Width/2-5'to.Bottom-5);    								r1 = new RectangleF(p1' new SizeF(10'(from.Top - to.Bottom)/2+5));   								if(p1.X<p2.X)  									r2 = new RectangleF(p1'new SizeF(p2.X-p1.X'10));  								else  									r2 = new RectangleF(p2'new SizeF(p1.X-p2.X'10));  								r3 = new RectangleF(p3' new SizeF(10' (from.Top - to.Bottom)/2+5));  								return r1.Contains(p.X'p.Y) || r2.Contains(p.X'p.Y) || r3.Contains(p.X'p.Y) ;  								  							case TreeDirection.Horizontal:    								p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   								p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							  								break;  						}  					#endregion  					break;  			}
Magic Number,Netron.Lithium,Connection,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Hit,The following statement contains a magic number: switch(site.ConnectionType)  			{  				case ConnectionType.Default:  					#region The default Hit method  					  					float o'u;  					p1 = start; p2 = end; 	 					// p1 must be the leftmost point. 					if (p1.X > p2.X) { s = p2; p2 = p1; p1 = s; }  					//this is specifically necessary when the layout works horizontally 					//the method beneth will not return true as should be in this case 					if(p1.Y==p2.Y) 					{ 						p1.Y+=-3; 						return new RectangleF(p1'new SizeF(p2.X-p1.X'6)).Contains(p); 					} 					r1 = new RectangleF(p1.X' p1.Y' 0' 0); 					r2 = new RectangleF(p2.X' p2.Y' 0' 0); 					r1.Inflate(3' 3); 					r2.Inflate(3' 3); 					//this is like a topological neighborhood 					//the connection is shifted left and right 					//and the point under consideration has to be in between.						 					if (RectangleF.Union(r1' r2).Contains(p)) 					{ 				 						if (p1.Y < p2.Y) //SWNE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							return ((p.X > o) && (p.X < u)); 						} 						else //NWSE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							return ((p.X > o) && (p.X < u)); 						} 					}  					#endregion  					break;  				case ConnectionType.Traditional:  					#region The rectangular Hit method  						switch(site.LayoutDirection)  						{  							case TreeDirection.Vertical:  								p1 = new PointF(from.Left + from.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5); //shift 5 to contain the connection  								p2 = new PointF(to.Left + to.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5);  								p3 = new Point(to.Left+to.Width/2-5'to.Bottom-5);    								r1 = new RectangleF(p1' new SizeF(10'(from.Top - to.Bottom)/2+5));   								if(p1.X<p2.X)  									r2 = new RectangleF(p1'new SizeF(p2.X-p1.X'10));  								else  									r2 = new RectangleF(p2'new SizeF(p1.X-p2.X'10));  								r3 = new RectangleF(p3' new SizeF(10' (from.Top - to.Bottom)/2+5));  								return r1.Contains(p.X'p.Y) || r2.Contains(p.X'p.Y) || r3.Contains(p.X'p.Y) ;  								  							case TreeDirection.Horizontal:    								p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   								p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							  								break;  						}  					#endregion  					break;  			}
Magic Number,Netron.Lithium,Connection,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Hit,The following statement contains a magic number: switch(site.ConnectionType)  			{  				case ConnectionType.Default:  					#region The default Hit method  					  					float o'u;  					p1 = start; p2 = end; 	 					// p1 must be the leftmost point. 					if (p1.X > p2.X) { s = p2; p2 = p1; p1 = s; }  					//this is specifically necessary when the layout works horizontally 					//the method beneth will not return true as should be in this case 					if(p1.Y==p2.Y) 					{ 						p1.Y+=-3; 						return new RectangleF(p1'new SizeF(p2.X-p1.X'6)).Contains(p); 					} 					r1 = new RectangleF(p1.X' p1.Y' 0' 0); 					r2 = new RectangleF(p2.X' p2.Y' 0' 0); 					r1.Inflate(3' 3); 					r2.Inflate(3' 3); 					//this is like a topological neighborhood 					//the connection is shifted left and right 					//and the point under consideration has to be in between.						 					if (RectangleF.Union(r1' r2).Contains(p)) 					{ 				 						if (p1.Y < p2.Y) //SWNE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							return ((p.X > o) && (p.X < u)); 						} 						else //NWSE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							return ((p.X > o) && (p.X < u)); 						} 					}  					#endregion  					break;  				case ConnectionType.Traditional:  					#region The rectangular Hit method  						switch(site.LayoutDirection)  						{  							case TreeDirection.Vertical:  								p1 = new PointF(from.Left + from.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5); //shift 5 to contain the connection  								p2 = new PointF(to.Left + to.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5);  								p3 = new Point(to.Left+to.Width/2-5'to.Bottom-5);    								r1 = new RectangleF(p1' new SizeF(10'(from.Top - to.Bottom)/2+5));   								if(p1.X<p2.X)  									r2 = new RectangleF(p1'new SizeF(p2.X-p1.X'10));  								else  									r2 = new RectangleF(p2'new SizeF(p1.X-p2.X'10));  								r3 = new RectangleF(p3' new SizeF(10' (from.Top - to.Bottom)/2+5));  								return r1.Contains(p.X'p.Y) || r2.Contains(p.X'p.Y) || r3.Contains(p.X'p.Y) ;  								  							case TreeDirection.Horizontal:    								p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   								p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							  								break;  						}  					#endregion  					break;  			}
Magic Number,Netron.Lithium,Connection,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Hit,The following statement contains a magic number: switch(site.ConnectionType)  			{  				case ConnectionType.Default:  					#region The default Hit method  					  					float o'u;  					p1 = start; p2 = end; 	 					// p1 must be the leftmost point. 					if (p1.X > p2.X) { s = p2; p2 = p1; p1 = s; }  					//this is specifically necessary when the layout works horizontally 					//the method beneth will not return true as should be in this case 					if(p1.Y==p2.Y) 					{ 						p1.Y+=-3; 						return new RectangleF(p1'new SizeF(p2.X-p1.X'6)).Contains(p); 					} 					r1 = new RectangleF(p1.X' p1.Y' 0' 0); 					r2 = new RectangleF(p2.X' p2.Y' 0' 0); 					r1.Inflate(3' 3); 					r2.Inflate(3' 3); 					//this is like a topological neighborhood 					//the connection is shifted left and right 					//and the point under consideration has to be in between.						 					if (RectangleF.Union(r1' r2).Contains(p)) 					{ 				 						if (p1.Y < p2.Y) //SWNE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							return ((p.X > o) && (p.X < u)); 						} 						else //NWSE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							return ((p.X > o) && (p.X < u)); 						} 					}  					#endregion  					break;  				case ConnectionType.Traditional:  					#region The rectangular Hit method  						switch(site.LayoutDirection)  						{  							case TreeDirection.Vertical:  								p1 = new PointF(from.Left + from.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5); //shift 5 to contain the connection  								p2 = new PointF(to.Left + to.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5);  								p3 = new Point(to.Left+to.Width/2-5'to.Bottom-5);    								r1 = new RectangleF(p1' new SizeF(10'(from.Top - to.Bottom)/2+5));   								if(p1.X<p2.X)  									r2 = new RectangleF(p1'new SizeF(p2.X-p1.X'10));  								else  									r2 = new RectangleF(p2'new SizeF(p1.X-p2.X'10));  								r3 = new RectangleF(p3' new SizeF(10' (from.Top - to.Bottom)/2+5));  								return r1.Contains(p.X'p.Y) || r2.Contains(p.X'p.Y) || r3.Contains(p.X'p.Y) ;  								  							case TreeDirection.Horizontal:    								p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   								p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							  								break;  						}  					#endregion  					break;  			}
Magic Number,Netron.Lithium,Connection,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Hit,The following statement contains a magic number: switch(site.ConnectionType)  			{  				case ConnectionType.Default:  					#region The default Hit method  					  					float o'u;  					p1 = start; p2 = end; 	 					// p1 must be the leftmost point. 					if (p1.X > p2.X) { s = p2; p2 = p1; p1 = s; }  					//this is specifically necessary when the layout works horizontally 					//the method beneth will not return true as should be in this case 					if(p1.Y==p2.Y) 					{ 						p1.Y+=-3; 						return new RectangleF(p1'new SizeF(p2.X-p1.X'6)).Contains(p); 					} 					r1 = new RectangleF(p1.X' p1.Y' 0' 0); 					r2 = new RectangleF(p2.X' p2.Y' 0' 0); 					r1.Inflate(3' 3); 					r2.Inflate(3' 3); 					//this is like a topological neighborhood 					//the connection is shifted left and right 					//and the point under consideration has to be in between.						 					if (RectangleF.Union(r1' r2).Contains(p)) 					{ 				 						if (p1.Y < p2.Y) //SWNE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							return ((p.X > o) && (p.X < u)); 						} 						else //NWSE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							return ((p.X > o) && (p.X < u)); 						} 					}  					#endregion  					break;  				case ConnectionType.Traditional:  					#region The rectangular Hit method  						switch(site.LayoutDirection)  						{  							case TreeDirection.Vertical:  								p1 = new PointF(from.Left + from.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5); //shift 5 to contain the connection  								p2 = new PointF(to.Left + to.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5);  								p3 = new Point(to.Left+to.Width/2-5'to.Bottom-5);    								r1 = new RectangleF(p1' new SizeF(10'(from.Top - to.Bottom)/2+5));   								if(p1.X<p2.X)  									r2 = new RectangleF(p1'new SizeF(p2.X-p1.X'10));  								else  									r2 = new RectangleF(p2'new SizeF(p1.X-p2.X'10));  								r3 = new RectangleF(p3' new SizeF(10' (from.Top - to.Bottom)/2+5));  								return r1.Contains(p.X'p.Y) || r2.Contains(p.X'p.Y) || r3.Contains(p.X'p.Y) ;  								  							case TreeDirection.Horizontal:    								p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   								p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							  								break;  						}  					#endregion  					break;  			}
Magic Number,Netron.Lithium,Connection,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Hit,The following statement contains a magic number: switch(site.ConnectionType)  			{  				case ConnectionType.Default:  					#region The default Hit method  					  					float o'u;  					p1 = start; p2 = end; 	 					// p1 must be the leftmost point. 					if (p1.X > p2.X) { s = p2; p2 = p1; p1 = s; }  					//this is specifically necessary when the layout works horizontally 					//the method beneth will not return true as should be in this case 					if(p1.Y==p2.Y) 					{ 						p1.Y+=-3; 						return new RectangleF(p1'new SizeF(p2.X-p1.X'6)).Contains(p); 					} 					r1 = new RectangleF(p1.X' p1.Y' 0' 0); 					r2 = new RectangleF(p2.X' p2.Y' 0' 0); 					r1.Inflate(3' 3); 					r2.Inflate(3' 3); 					//this is like a topological neighborhood 					//the connection is shifted left and right 					//and the point under consideration has to be in between.						 					if (RectangleF.Union(r1' r2).Contains(p)) 					{ 				 						if (p1.Y < p2.Y) //SWNE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							return ((p.X > o) && (p.X < u)); 						} 						else //NWSE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							return ((p.X > o) && (p.X < u)); 						} 					}  					#endregion  					break;  				case ConnectionType.Traditional:  					#region The rectangular Hit method  						switch(site.LayoutDirection)  						{  							case TreeDirection.Vertical:  								p1 = new PointF(from.Left + from.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5); //shift 5 to contain the connection  								p2 = new PointF(to.Left + to.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5);  								p3 = new Point(to.Left+to.Width/2-5'to.Bottom-5);    								r1 = new RectangleF(p1' new SizeF(10'(from.Top - to.Bottom)/2+5));   								if(p1.X<p2.X)  									r2 = new RectangleF(p1'new SizeF(p2.X-p1.X'10));  								else  									r2 = new RectangleF(p2'new SizeF(p1.X-p2.X'10));  								r3 = new RectangleF(p3' new SizeF(10' (from.Top - to.Bottom)/2+5));  								return r1.Contains(p.X'p.Y) || r2.Contains(p.X'p.Y) || r3.Contains(p.X'p.Y) ;  								  							case TreeDirection.Horizontal:    								p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   								p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							  								break;  						}  					#endregion  					break;  			}
Magic Number,Netron.Lithium,Connection,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Hit,The following statement contains a magic number: switch(site.ConnectionType)  			{  				case ConnectionType.Default:  					#region The default Hit method  					  					float o'u;  					p1 = start; p2 = end; 	 					// p1 must be the leftmost point. 					if (p1.X > p2.X) { s = p2; p2 = p1; p1 = s; }  					//this is specifically necessary when the layout works horizontally 					//the method beneth will not return true as should be in this case 					if(p1.Y==p2.Y) 					{ 						p1.Y+=-3; 						return new RectangleF(p1'new SizeF(p2.X-p1.X'6)).Contains(p); 					} 					r1 = new RectangleF(p1.X' p1.Y' 0' 0); 					r2 = new RectangleF(p2.X' p2.Y' 0' 0); 					r1.Inflate(3' 3); 					r2.Inflate(3' 3); 					//this is like a topological neighborhood 					//the connection is shifted left and right 					//and the point under consideration has to be in between.						 					if (RectangleF.Union(r1' r2).Contains(p)) 					{ 				 						if (p1.Y < p2.Y) //SWNE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							return ((p.X > o) && (p.X < u)); 						} 						else //NWSE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							return ((p.X > o) && (p.X < u)); 						} 					}  					#endregion  					break;  				case ConnectionType.Traditional:  					#region The rectangular Hit method  						switch(site.LayoutDirection)  						{  							case TreeDirection.Vertical:  								p1 = new PointF(from.Left + from.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5); //shift 5 to contain the connection  								p2 = new PointF(to.Left + to.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5);  								p3 = new Point(to.Left+to.Width/2-5'to.Bottom-5);    								r1 = new RectangleF(p1' new SizeF(10'(from.Top - to.Bottom)/2+5));   								if(p1.X<p2.X)  									r2 = new RectangleF(p1'new SizeF(p2.X-p1.X'10));  								else  									r2 = new RectangleF(p2'new SizeF(p1.X-p2.X'10));  								r3 = new RectangleF(p3' new SizeF(10' (from.Top - to.Bottom)/2+5));  								return r1.Contains(p.X'p.Y) || r2.Contains(p.X'p.Y) || r3.Contains(p.X'p.Y) ;  								  							case TreeDirection.Horizontal:    								p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   								p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							  								break;  						}  					#endregion  					break;  			}
Magic Number,Netron.Lithium,Connection,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Hit,The following statement contains a magic number: switch(site.ConnectionType)  			{  				case ConnectionType.Default:  					#region The default Hit method  					  					float o'u;  					p1 = start; p2 = end; 	 					// p1 must be the leftmost point. 					if (p1.X > p2.X) { s = p2; p2 = p1; p1 = s; }  					//this is specifically necessary when the layout works horizontally 					//the method beneth will not return true as should be in this case 					if(p1.Y==p2.Y) 					{ 						p1.Y+=-3; 						return new RectangleF(p1'new SizeF(p2.X-p1.X'6)).Contains(p); 					} 					r1 = new RectangleF(p1.X' p1.Y' 0' 0); 					r2 = new RectangleF(p2.X' p2.Y' 0' 0); 					r1.Inflate(3' 3); 					r2.Inflate(3' 3); 					//this is like a topological neighborhood 					//the connection is shifted left and right 					//and the point under consideration has to be in between.						 					if (RectangleF.Union(r1' r2).Contains(p)) 					{ 				 						if (p1.Y < p2.Y) //SWNE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							return ((p.X > o) && (p.X < u)); 						} 						else //NWSE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							return ((p.X > o) && (p.X < u)); 						} 					}  					#endregion  					break;  				case ConnectionType.Traditional:  					#region The rectangular Hit method  						switch(site.LayoutDirection)  						{  							case TreeDirection.Vertical:  								p1 = new PointF(from.Left + from.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5); //shift 5 to contain the connection  								p2 = new PointF(to.Left + to.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5);  								p3 = new Point(to.Left+to.Width/2-5'to.Bottom-5);    								r1 = new RectangleF(p1' new SizeF(10'(from.Top - to.Bottom)/2+5));   								if(p1.X<p2.X)  									r2 = new RectangleF(p1'new SizeF(p2.X-p1.X'10));  								else  									r2 = new RectangleF(p2'new SizeF(p1.X-p2.X'10));  								r3 = new RectangleF(p3' new SizeF(10' (from.Top - to.Bottom)/2+5));  								return r1.Contains(p.X'p.Y) || r2.Contains(p.X'p.Y) || r3.Contains(p.X'p.Y) ;  								  							case TreeDirection.Horizontal:    								p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   								p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							  								break;  						}  					#endregion  					break;  			}
Magic Number,Netron.Lithium,Connection,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Hit,The following statement contains a magic number: switch(site.ConnectionType)  			{  				case ConnectionType.Default:  					#region The default Hit method  					  					float o'u;  					p1 = start; p2 = end; 	 					// p1 must be the leftmost point. 					if (p1.X > p2.X) { s = p2; p2 = p1; p1 = s; }  					//this is specifically necessary when the layout works horizontally 					//the method beneth will not return true as should be in this case 					if(p1.Y==p2.Y) 					{ 						p1.Y+=-3; 						return new RectangleF(p1'new SizeF(p2.X-p1.X'6)).Contains(p); 					} 					r1 = new RectangleF(p1.X' p1.Y' 0' 0); 					r2 = new RectangleF(p2.X' p2.Y' 0' 0); 					r1.Inflate(3' 3); 					r2.Inflate(3' 3); 					//this is like a topological neighborhood 					//the connection is shifted left and right 					//and the point under consideration has to be in between.						 					if (RectangleF.Union(r1' r2).Contains(p)) 					{ 				 						if (p1.Y < p2.Y) //SWNE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							return ((p.X > o) && (p.X < u)); 						} 						else //NWSE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							return ((p.X > o) && (p.X < u)); 						} 					}  					#endregion  					break;  				case ConnectionType.Traditional:  					#region The rectangular Hit method  						switch(site.LayoutDirection)  						{  							case TreeDirection.Vertical:  								p1 = new PointF(from.Left + from.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5); //shift 5 to contain the connection  								p2 = new PointF(to.Left + to.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5);  								p3 = new Point(to.Left+to.Width/2-5'to.Bottom-5);    								r1 = new RectangleF(p1' new SizeF(10'(from.Top - to.Bottom)/2+5));   								if(p1.X<p2.X)  									r2 = new RectangleF(p1'new SizeF(p2.X-p1.X'10));  								else  									r2 = new RectangleF(p2'new SizeF(p1.X-p2.X'10));  								r3 = new RectangleF(p3' new SizeF(10' (from.Top - to.Bottom)/2+5));  								return r1.Contains(p.X'p.Y) || r2.Contains(p.X'p.Y) || r3.Contains(p.X'p.Y) ;  								  							case TreeDirection.Horizontal:    								p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   								p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							  								break;  						}  					#endregion  					break;  			}
Magic Number,Netron.Lithium,Connection,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Hit,The following statement contains a magic number: switch(site.ConnectionType)  			{  				case ConnectionType.Default:  					#region The default Hit method  					  					float o'u;  					p1 = start; p2 = end; 	 					// p1 must be the leftmost point. 					if (p1.X > p2.X) { s = p2; p2 = p1; p1 = s; }  					//this is specifically necessary when the layout works horizontally 					//the method beneth will not return true as should be in this case 					if(p1.Y==p2.Y) 					{ 						p1.Y+=-3; 						return new RectangleF(p1'new SizeF(p2.X-p1.X'6)).Contains(p); 					} 					r1 = new RectangleF(p1.X' p1.Y' 0' 0); 					r2 = new RectangleF(p2.X' p2.Y' 0' 0); 					r1.Inflate(3' 3); 					r2.Inflate(3' 3); 					//this is like a topological neighborhood 					//the connection is shifted left and right 					//and the point under consideration has to be in between.						 					if (RectangleF.Union(r1' r2).Contains(p)) 					{ 				 						if (p1.Y < p2.Y) //SWNE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							return ((p.X > o) && (p.X < u)); 						} 						else //NWSE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							return ((p.X > o) && (p.X < u)); 						} 					}  					#endregion  					break;  				case ConnectionType.Traditional:  					#region The rectangular Hit method  						switch(site.LayoutDirection)  						{  							case TreeDirection.Vertical:  								p1 = new PointF(from.Left + from.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5); //shift 5 to contain the connection  								p2 = new PointF(to.Left + to.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5);  								p3 = new Point(to.Left+to.Width/2-5'to.Bottom-5);    								r1 = new RectangleF(p1' new SizeF(10'(from.Top - to.Bottom)/2+5));   								if(p1.X<p2.X)  									r2 = new RectangleF(p1'new SizeF(p2.X-p1.X'10));  								else  									r2 = new RectangleF(p2'new SizeF(p1.X-p2.X'10));  								r3 = new RectangleF(p3' new SizeF(10' (from.Top - to.Bottom)/2+5));  								return r1.Contains(p.X'p.Y) || r2.Contains(p.X'p.Y) || r3.Contains(p.X'p.Y) ;  								  							case TreeDirection.Horizontal:    								p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   								p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							  								break;  						}  					#endregion  					break;  			}
Magic Number,Netron.Lithium,Connection,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Hit,The following statement contains a magic number: switch(site.ConnectionType)  			{  				case ConnectionType.Default:  					#region The default Hit method  					  					float o'u;  					p1 = start; p2 = end; 	 					// p1 must be the leftmost point. 					if (p1.X > p2.X) { s = p2; p2 = p1; p1 = s; }  					//this is specifically necessary when the layout works horizontally 					//the method beneth will not return true as should be in this case 					if(p1.Y==p2.Y) 					{ 						p1.Y+=-3; 						return new RectangleF(p1'new SizeF(p2.X-p1.X'6)).Contains(p); 					} 					r1 = new RectangleF(p1.X' p1.Y' 0' 0); 					r2 = new RectangleF(p2.X' p2.Y' 0' 0); 					r1.Inflate(3' 3); 					r2.Inflate(3' 3); 					//this is like a topological neighborhood 					//the connection is shifted left and right 					//and the point under consideration has to be in between.						 					if (RectangleF.Union(r1' r2).Contains(p)) 					{ 				 						if (p1.Y < p2.Y) //SWNE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							return ((p.X > o) && (p.X < u)); 						} 						else //NWSE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							return ((p.X > o) && (p.X < u)); 						} 					}  					#endregion  					break;  				case ConnectionType.Traditional:  					#region The rectangular Hit method  						switch(site.LayoutDirection)  						{  							case TreeDirection.Vertical:  								p1 = new PointF(from.Left + from.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5); //shift 5 to contain the connection  								p2 = new PointF(to.Left + to.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5);  								p3 = new Point(to.Left+to.Width/2-5'to.Bottom-5);    								r1 = new RectangleF(p1' new SizeF(10'(from.Top - to.Bottom)/2+5));   								if(p1.X<p2.X)  									r2 = new RectangleF(p1'new SizeF(p2.X-p1.X'10));  								else  									r2 = new RectangleF(p2'new SizeF(p1.X-p2.X'10));  								r3 = new RectangleF(p3' new SizeF(10' (from.Top - to.Bottom)/2+5));  								return r1.Contains(p.X'p.Y) || r2.Contains(p.X'p.Y) || r3.Contains(p.X'p.Y) ;  								  							case TreeDirection.Horizontal:    								p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   								p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							  								break;  						}  					#endregion  					break;  			}
Magic Number,Netron.Lithium,Connection,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Hit,The following statement contains a magic number: switch(site.ConnectionType)  			{  				case ConnectionType.Default:  					#region The default Hit method  					  					float o'u;  					p1 = start; p2 = end; 	 					// p1 must be the leftmost point. 					if (p1.X > p2.X) { s = p2; p2 = p1; p1 = s; }  					//this is specifically necessary when the layout works horizontally 					//the method beneth will not return true as should be in this case 					if(p1.Y==p2.Y) 					{ 						p1.Y+=-3; 						return new RectangleF(p1'new SizeF(p2.X-p1.X'6)).Contains(p); 					} 					r1 = new RectangleF(p1.X' p1.Y' 0' 0); 					r2 = new RectangleF(p2.X' p2.Y' 0' 0); 					r1.Inflate(3' 3); 					r2.Inflate(3' 3); 					//this is like a topological neighborhood 					//the connection is shifted left and right 					//and the point under consideration has to be in between.						 					if (RectangleF.Union(r1' r2).Contains(p)) 					{ 				 						if (p1.Y < p2.Y) //SWNE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							return ((p.X > o) && (p.X < u)); 						} 						else //NWSE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							return ((p.X > o) && (p.X < u)); 						} 					}  					#endregion  					break;  				case ConnectionType.Traditional:  					#region The rectangular Hit method  						switch(site.LayoutDirection)  						{  							case TreeDirection.Vertical:  								p1 = new PointF(from.Left + from.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5); //shift 5 to contain the connection  								p2 = new PointF(to.Left + to.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5);  								p3 = new Point(to.Left+to.Width/2-5'to.Bottom-5);    								r1 = new RectangleF(p1' new SizeF(10'(from.Top - to.Bottom)/2+5));   								if(p1.X<p2.X)  									r2 = new RectangleF(p1'new SizeF(p2.X-p1.X'10));  								else  									r2 = new RectangleF(p2'new SizeF(p1.X-p2.X'10));  								r3 = new RectangleF(p3' new SizeF(10' (from.Top - to.Bottom)/2+5));  								return r1.Contains(p.X'p.Y) || r2.Contains(p.X'p.Y) || r3.Contains(p.X'p.Y) ;  								  							case TreeDirection.Horizontal:    								p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   								p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							  								break;  						}  					#endregion  					break;  			}
Magic Number,Netron.Lithium,Connection,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Hit,The following statement contains a magic number: switch(site.ConnectionType)  			{  				case ConnectionType.Default:  					#region The default Hit method  					  					float o'u;  					p1 = start; p2 = end; 	 					// p1 must be the leftmost point. 					if (p1.X > p2.X) { s = p2; p2 = p1; p1 = s; }  					//this is specifically necessary when the layout works horizontally 					//the method beneth will not return true as should be in this case 					if(p1.Y==p2.Y) 					{ 						p1.Y+=-3; 						return new RectangleF(p1'new SizeF(p2.X-p1.X'6)).Contains(p); 					} 					r1 = new RectangleF(p1.X' p1.Y' 0' 0); 					r2 = new RectangleF(p2.X' p2.Y' 0' 0); 					r1.Inflate(3' 3); 					r2.Inflate(3' 3); 					//this is like a topological neighborhood 					//the connection is shifted left and right 					//and the point under consideration has to be in between.						 					if (RectangleF.Union(r1' r2).Contains(p)) 					{ 				 						if (p1.Y < p2.Y) //SWNE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							return ((p.X > o) && (p.X < u)); 						} 						else //NWSE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							return ((p.X > o) && (p.X < u)); 						} 					}  					#endregion  					break;  				case ConnectionType.Traditional:  					#region The rectangular Hit method  						switch(site.LayoutDirection)  						{  							case TreeDirection.Vertical:  								p1 = new PointF(from.Left + from.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5); //shift 5 to contain the connection  								p2 = new PointF(to.Left + to.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5);  								p3 = new Point(to.Left+to.Width/2-5'to.Bottom-5);    								r1 = new RectangleF(p1' new SizeF(10'(from.Top - to.Bottom)/2+5));   								if(p1.X<p2.X)  									r2 = new RectangleF(p1'new SizeF(p2.X-p1.X'10));  								else  									r2 = new RectangleF(p2'new SizeF(p1.X-p2.X'10));  								r3 = new RectangleF(p3' new SizeF(10' (from.Top - to.Bottom)/2+5));  								return r1.Contains(p.X'p.Y) || r2.Contains(p.X'p.Y) || r3.Contains(p.X'p.Y) ;  								  							case TreeDirection.Horizontal:    								p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   								p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							  								break;  						}  					#endregion  					break;  			}
Magic Number,Netron.Lithium,Connection,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Hit,The following statement contains a magic number: switch(site.ConnectionType)  			{  				case ConnectionType.Default:  					#region The default Hit method  					  					float o'u;  					p1 = start; p2 = end; 	 					// p1 must be the leftmost point. 					if (p1.X > p2.X) { s = p2; p2 = p1; p1 = s; }  					//this is specifically necessary when the layout works horizontally 					//the method beneth will not return true as should be in this case 					if(p1.Y==p2.Y) 					{ 						p1.Y+=-3; 						return new RectangleF(p1'new SizeF(p2.X-p1.X'6)).Contains(p); 					} 					r1 = new RectangleF(p1.X' p1.Y' 0' 0); 					r2 = new RectangleF(p2.X' p2.Y' 0' 0); 					r1.Inflate(3' 3); 					r2.Inflate(3' 3); 					//this is like a topological neighborhood 					//the connection is shifted left and right 					//and the point under consideration has to be in between.						 					if (RectangleF.Union(r1' r2).Contains(p)) 					{ 				 						if (p1.Y < p2.Y) //SWNE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							return ((p.X > o) && (p.X < u)); 						} 						else //NWSE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							return ((p.X > o) && (p.X < u)); 						} 					}  					#endregion  					break;  				case ConnectionType.Traditional:  					#region The rectangular Hit method  						switch(site.LayoutDirection)  						{  							case TreeDirection.Vertical:  								p1 = new PointF(from.Left + from.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5); //shift 5 to contain the connection  								p2 = new PointF(to.Left + to.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5);  								p3 = new Point(to.Left+to.Width/2-5'to.Bottom-5);    								r1 = new RectangleF(p1' new SizeF(10'(from.Top - to.Bottom)/2+5));   								if(p1.X<p2.X)  									r2 = new RectangleF(p1'new SizeF(p2.X-p1.X'10));  								else  									r2 = new RectangleF(p2'new SizeF(p1.X-p2.X'10));  								r3 = new RectangleF(p3' new SizeF(10' (from.Top - to.Bottom)/2+5));  								return r1.Contains(p.X'p.Y) || r2.Contains(p.X'p.Y) || r3.Contains(p.X'p.Y) ;  								  							case TreeDirection.Horizontal:    								p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   								p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							  								break;  						}  					#endregion  					break;  			}
Magic Number,Netron.Lithium,Connection,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Hit,The following statement contains a magic number: switch(site.ConnectionType)  			{  				case ConnectionType.Default:  					#region The default Hit method  					  					float o'u;  					p1 = start; p2 = end; 	 					// p1 must be the leftmost point. 					if (p1.X > p2.X) { s = p2; p2 = p1; p1 = s; }  					//this is specifically necessary when the layout works horizontally 					//the method beneth will not return true as should be in this case 					if(p1.Y==p2.Y) 					{ 						p1.Y+=-3; 						return new RectangleF(p1'new SizeF(p2.X-p1.X'6)).Contains(p); 					} 					r1 = new RectangleF(p1.X' p1.Y' 0' 0); 					r2 = new RectangleF(p2.X' p2.Y' 0' 0); 					r1.Inflate(3' 3); 					r2.Inflate(3' 3); 					//this is like a topological neighborhood 					//the connection is shifted left and right 					//and the point under consideration has to be in between.						 					if (RectangleF.Union(r1' r2).Contains(p)) 					{ 				 						if (p1.Y < p2.Y) //SWNE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							return ((p.X > o) && (p.X < u)); 						} 						else //NWSE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							return ((p.X > o) && (p.X < u)); 						} 					}  					#endregion  					break;  				case ConnectionType.Traditional:  					#region The rectangular Hit method  						switch(site.LayoutDirection)  						{  							case TreeDirection.Vertical:  								p1 = new PointF(from.Left + from.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5); //shift 5 to contain the connection  								p2 = new PointF(to.Left + to.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5);  								p3 = new Point(to.Left+to.Width/2-5'to.Bottom-5);    								r1 = new RectangleF(p1' new SizeF(10'(from.Top - to.Bottom)/2+5));   								if(p1.X<p2.X)  									r2 = new RectangleF(p1'new SizeF(p2.X-p1.X'10));  								else  									r2 = new RectangleF(p2'new SizeF(p1.X-p2.X'10));  								r3 = new RectangleF(p3' new SizeF(10' (from.Top - to.Bottom)/2+5));  								return r1.Contains(p.X'p.Y) || r2.Contains(p.X'p.Y) || r3.Contains(p.X'p.Y) ;  								  							case TreeDirection.Horizontal:    								p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   								p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							  								break;  						}  					#endregion  					break;  			}
Magic Number,Netron.Lithium,Connection,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Hit,The following statement contains a magic number: switch(site.ConnectionType)  			{  				case ConnectionType.Default:  					#region The default Hit method  					  					float o'u;  					p1 = start; p2 = end; 	 					// p1 must be the leftmost point. 					if (p1.X > p2.X) { s = p2; p2 = p1; p1 = s; }  					//this is specifically necessary when the layout works horizontally 					//the method beneth will not return true as should be in this case 					if(p1.Y==p2.Y) 					{ 						p1.Y+=-3; 						return new RectangleF(p1'new SizeF(p2.X-p1.X'6)).Contains(p); 					} 					r1 = new RectangleF(p1.X' p1.Y' 0' 0); 					r2 = new RectangleF(p2.X' p2.Y' 0' 0); 					r1.Inflate(3' 3); 					r2.Inflate(3' 3); 					//this is like a topological neighborhood 					//the connection is shifted left and right 					//and the point under consideration has to be in between.						 					if (RectangleF.Union(r1' r2).Contains(p)) 					{ 				 						if (p1.Y < p2.Y) //SWNE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							return ((p.X > o) && (p.X < u)); 						} 						else //NWSE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							return ((p.X > o) && (p.X < u)); 						} 					}  					#endregion  					break;  				case ConnectionType.Traditional:  					#region The rectangular Hit method  						switch(site.LayoutDirection)  						{  							case TreeDirection.Vertical:  								p1 = new PointF(from.Left + from.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5); //shift 5 to contain the connection  								p2 = new PointF(to.Left + to.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5);  								p3 = new Point(to.Left+to.Width/2-5'to.Bottom-5);    								r1 = new RectangleF(p1' new SizeF(10'(from.Top - to.Bottom)/2+5));   								if(p1.X<p2.X)  									r2 = new RectangleF(p1'new SizeF(p2.X-p1.X'10));  								else  									r2 = new RectangleF(p2'new SizeF(p1.X-p2.X'10));  								r3 = new RectangleF(p3' new SizeF(10' (from.Top - to.Bottom)/2+5));  								return r1.Contains(p.X'p.Y) || r2.Contains(p.X'p.Y) || r3.Contains(p.X'p.Y) ;  								  							case TreeDirection.Horizontal:    								p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   								p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							  								break;  						}  					#endregion  					break;  			}
Magic Number,Netron.Lithium,Connection,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Hit,The following statement contains a magic number: switch(site.ConnectionType)  			{  				case ConnectionType.Default:  					#region The default Hit method  					  					float o'u;  					p1 = start; p2 = end; 	 					// p1 must be the leftmost point. 					if (p1.X > p2.X) { s = p2; p2 = p1; p1 = s; }  					//this is specifically necessary when the layout works horizontally 					//the method beneth will not return true as should be in this case 					if(p1.Y==p2.Y) 					{ 						p1.Y+=-3; 						return new RectangleF(p1'new SizeF(p2.X-p1.X'6)).Contains(p); 					} 					r1 = new RectangleF(p1.X' p1.Y' 0' 0); 					r2 = new RectangleF(p2.X' p2.Y' 0' 0); 					r1.Inflate(3' 3); 					r2.Inflate(3' 3); 					//this is like a topological neighborhood 					//the connection is shifted left and right 					//and the point under consideration has to be in between.						 					if (RectangleF.Union(r1' r2).Contains(p)) 					{ 				 						if (p1.Y < p2.Y) //SWNE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							return ((p.X > o) && (p.X < u)); 						} 						else //NWSE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							return ((p.X > o) && (p.X < u)); 						} 					}  					#endregion  					break;  				case ConnectionType.Traditional:  					#region The rectangular Hit method  						switch(site.LayoutDirection)  						{  							case TreeDirection.Vertical:  								p1 = new PointF(from.Left + from.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5); //shift 5 to contain the connection  								p2 = new PointF(to.Left + to.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5);  								p3 = new Point(to.Left+to.Width/2-5'to.Bottom-5);    								r1 = new RectangleF(p1' new SizeF(10'(from.Top - to.Bottom)/2+5));   								if(p1.X<p2.X)  									r2 = new RectangleF(p1'new SizeF(p2.X-p1.X'10));  								else  									r2 = new RectangleF(p2'new SizeF(p1.X-p2.X'10));  								r3 = new RectangleF(p3' new SizeF(10' (from.Top - to.Bottom)/2+5));  								return r1.Contains(p.X'p.Y) || r2.Contains(p.X'p.Y) || r3.Contains(p.X'p.Y) ;  								  							case TreeDirection.Horizontal:    								p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   								p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							  								break;  						}  					#endregion  					break;  			}
Magic Number,Netron.Lithium,Connection,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Hit,The following statement contains a magic number: switch(site.ConnectionType)  			{  				case ConnectionType.Default:  					#region The default Hit method  					  					float o'u;  					p1 = start; p2 = end; 	 					// p1 must be the leftmost point. 					if (p1.X > p2.X) { s = p2; p2 = p1; p1 = s; }  					//this is specifically necessary when the layout works horizontally 					//the method beneth will not return true as should be in this case 					if(p1.Y==p2.Y) 					{ 						p1.Y+=-3; 						return new RectangleF(p1'new SizeF(p2.X-p1.X'6)).Contains(p); 					} 					r1 = new RectangleF(p1.X' p1.Y' 0' 0); 					r2 = new RectangleF(p2.X' p2.Y' 0' 0); 					r1.Inflate(3' 3); 					r2.Inflate(3' 3); 					//this is like a topological neighborhood 					//the connection is shifted left and right 					//and the point under consideration has to be in between.						 					if (RectangleF.Union(r1' r2).Contains(p)) 					{ 				 						if (p1.Y < p2.Y) //SWNE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							return ((p.X > o) && (p.X < u)); 						} 						else //NWSE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							return ((p.X > o) && (p.X < u)); 						} 					}  					#endregion  					break;  				case ConnectionType.Traditional:  					#region The rectangular Hit method  						switch(site.LayoutDirection)  						{  							case TreeDirection.Vertical:  								p1 = new PointF(from.Left + from.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5); //shift 5 to contain the connection  								p2 = new PointF(to.Left + to.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5);  								p3 = new Point(to.Left+to.Width/2-5'to.Bottom-5);    								r1 = new RectangleF(p1' new SizeF(10'(from.Top - to.Bottom)/2+5));   								if(p1.X<p2.X)  									r2 = new RectangleF(p1'new SizeF(p2.X-p1.X'10));  								else  									r2 = new RectangleF(p2'new SizeF(p1.X-p2.X'10));  								r3 = new RectangleF(p3' new SizeF(10' (from.Top - to.Bottom)/2+5));  								return r1.Contains(p.X'p.Y) || r2.Contains(p.X'p.Y) || r3.Contains(p.X'p.Y) ;  								  							case TreeDirection.Horizontal:    								p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   								p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							  								break;  						}  					#endregion  					break;  			}
Magic Number,Netron.Lithium,Connection,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Hit,The following statement contains a magic number: switch(site.ConnectionType)  			{  				case ConnectionType.Default:  					#region The default Hit method  					  					float o'u;  					p1 = start; p2 = end; 	 					// p1 must be the leftmost point. 					if (p1.X > p2.X) { s = p2; p2 = p1; p1 = s; }  					//this is specifically necessary when the layout works horizontally 					//the method beneth will not return true as should be in this case 					if(p1.Y==p2.Y) 					{ 						p1.Y+=-3; 						return new RectangleF(p1'new SizeF(p2.X-p1.X'6)).Contains(p); 					} 					r1 = new RectangleF(p1.X' p1.Y' 0' 0); 					r2 = new RectangleF(p2.X' p2.Y' 0' 0); 					r1.Inflate(3' 3); 					r2.Inflate(3' 3); 					//this is like a topological neighborhood 					//the connection is shifted left and right 					//and the point under consideration has to be in between.						 					if (RectangleF.Union(r1' r2).Contains(p)) 					{ 				 						if (p1.Y < p2.Y) //SWNE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							return ((p.X > o) && (p.X < u)); 						} 						else //NWSE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							return ((p.X > o) && (p.X < u)); 						} 					}  					#endregion  					break;  				case ConnectionType.Traditional:  					#region The rectangular Hit method  						switch(site.LayoutDirection)  						{  							case TreeDirection.Vertical:  								p1 = new PointF(from.Left + from.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5); //shift 5 to contain the connection  								p2 = new PointF(to.Left + to.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5);  								p3 = new Point(to.Left+to.Width/2-5'to.Bottom-5);    								r1 = new RectangleF(p1' new SizeF(10'(from.Top - to.Bottom)/2+5));   								if(p1.X<p2.X)  									r2 = new RectangleF(p1'new SizeF(p2.X-p1.X'10));  								else  									r2 = new RectangleF(p2'new SizeF(p1.X-p2.X'10));  								r3 = new RectangleF(p3' new SizeF(10' (from.Top - to.Bottom)/2+5));  								return r1.Contains(p.X'p.Y) || r2.Contains(p.X'p.Y) || r3.Contains(p.X'p.Y) ;  								  							case TreeDirection.Horizontal:    								p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   								p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							  								break;  						}  					#endregion  					break;  			}
Magic Number,Netron.Lithium,Connection,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Hit,The following statement contains a magic number: switch(site.ConnectionType)  			{  				case ConnectionType.Default:  					#region The default Hit method  					  					float o'u;  					p1 = start; p2 = end; 	 					// p1 must be the leftmost point. 					if (p1.X > p2.X) { s = p2; p2 = p1; p1 = s; }  					//this is specifically necessary when the layout works horizontally 					//the method beneth will not return true as should be in this case 					if(p1.Y==p2.Y) 					{ 						p1.Y+=-3; 						return new RectangleF(p1'new SizeF(p2.X-p1.X'6)).Contains(p); 					} 					r1 = new RectangleF(p1.X' p1.Y' 0' 0); 					r2 = new RectangleF(p2.X' p2.Y' 0' 0); 					r1.Inflate(3' 3); 					r2.Inflate(3' 3); 					//this is like a topological neighborhood 					//the connection is shifted left and right 					//and the point under consideration has to be in between.						 					if (RectangleF.Union(r1' r2).Contains(p)) 					{ 				 						if (p1.Y < p2.Y) //SWNE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							return ((p.X > o) && (p.X < u)); 						} 						else //NWSE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							return ((p.X > o) && (p.X < u)); 						} 					}  					#endregion  					break;  				case ConnectionType.Traditional:  					#region The rectangular Hit method  						switch(site.LayoutDirection)  						{  							case TreeDirection.Vertical:  								p1 = new PointF(from.Left + from.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5); //shift 5 to contain the connection  								p2 = new PointF(to.Left + to.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5);  								p3 = new Point(to.Left+to.Width/2-5'to.Bottom-5);    								r1 = new RectangleF(p1' new SizeF(10'(from.Top - to.Bottom)/2+5));   								if(p1.X<p2.X)  									r2 = new RectangleF(p1'new SizeF(p2.X-p1.X'10));  								else  									r2 = new RectangleF(p2'new SizeF(p1.X-p2.X'10));  								r3 = new RectangleF(p3' new SizeF(10' (from.Top - to.Bottom)/2+5));  								return r1.Contains(p.X'p.Y) || r2.Contains(p.X'p.Y) || r3.Contains(p.X'p.Y) ;  								  							case TreeDirection.Horizontal:    								p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   								p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							  								break;  						}  					#endregion  					break;  			}
Magic Number,Netron.Lithium,Connection,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Hit,The following statement contains a magic number: switch(site.ConnectionType)  			{  				case ConnectionType.Default:  					#region The default Hit method  					  					float o'u;  					p1 = start; p2 = end; 	 					// p1 must be the leftmost point. 					if (p1.X > p2.X) { s = p2; p2 = p1; p1 = s; }  					//this is specifically necessary when the layout works horizontally 					//the method beneth will not return true as should be in this case 					if(p1.Y==p2.Y) 					{ 						p1.Y+=-3; 						return new RectangleF(p1'new SizeF(p2.X-p1.X'6)).Contains(p); 					} 					r1 = new RectangleF(p1.X' p1.Y' 0' 0); 					r2 = new RectangleF(p2.X' p2.Y' 0' 0); 					r1.Inflate(3' 3); 					r2.Inflate(3' 3); 					//this is like a topological neighborhood 					//the connection is shifted left and right 					//and the point under consideration has to be in between.						 					if (RectangleF.Union(r1' r2).Contains(p)) 					{ 				 						if (p1.Y < p2.Y) //SWNE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							return ((p.X > o) && (p.X < u)); 						} 						else //NWSE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							return ((p.X > o) && (p.X < u)); 						} 					}  					#endregion  					break;  				case ConnectionType.Traditional:  					#region The rectangular Hit method  						switch(site.LayoutDirection)  						{  							case TreeDirection.Vertical:  								p1 = new PointF(from.Left + from.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5); //shift 5 to contain the connection  								p2 = new PointF(to.Left + to.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5);  								p3 = new Point(to.Left+to.Width/2-5'to.Bottom-5);    								r1 = new RectangleF(p1' new SizeF(10'(from.Top - to.Bottom)/2+5));   								if(p1.X<p2.X)  									r2 = new RectangleF(p1'new SizeF(p2.X-p1.X'10));  								else  									r2 = new RectangleF(p2'new SizeF(p1.X-p2.X'10));  								r3 = new RectangleF(p3' new SizeF(10' (from.Top - to.Bottom)/2+5));  								return r1.Contains(p.X'p.Y) || r2.Contains(p.X'p.Y) || r3.Contains(p.X'p.Y) ;  								  							case TreeDirection.Horizontal:    								p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   								p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							  								break;  						}  					#endregion  					break;  			}
Magic Number,Netron.Lithium,Connection,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Hit,The following statement contains a magic number: switch(site.ConnectionType)  			{  				case ConnectionType.Default:  					#region The default Hit method  					  					float o'u;  					p1 = start; p2 = end; 	 					// p1 must be the leftmost point. 					if (p1.X > p2.X) { s = p2; p2 = p1; p1 = s; }  					//this is specifically necessary when the layout works horizontally 					//the method beneth will not return true as should be in this case 					if(p1.Y==p2.Y) 					{ 						p1.Y+=-3; 						return new RectangleF(p1'new SizeF(p2.X-p1.X'6)).Contains(p); 					} 					r1 = new RectangleF(p1.X' p1.Y' 0' 0); 					r2 = new RectangleF(p2.X' p2.Y' 0' 0); 					r1.Inflate(3' 3); 					r2.Inflate(3' 3); 					//this is like a topological neighborhood 					//the connection is shifted left and right 					//and the point under consideration has to be in between.						 					if (RectangleF.Union(r1' r2).Contains(p)) 					{ 				 						if (p1.Y < p2.Y) //SWNE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							return ((p.X > o) && (p.X < u)); 						} 						else //NWSE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							return ((p.X > o) && (p.X < u)); 						} 					}  					#endregion  					break;  				case ConnectionType.Traditional:  					#region The rectangular Hit method  						switch(site.LayoutDirection)  						{  							case TreeDirection.Vertical:  								p1 = new PointF(from.Left + from.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5); //shift 5 to contain the connection  								p2 = new PointF(to.Left + to.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5);  								p3 = new Point(to.Left+to.Width/2-5'to.Bottom-5);    								r1 = new RectangleF(p1' new SizeF(10'(from.Top - to.Bottom)/2+5));   								if(p1.X<p2.X)  									r2 = new RectangleF(p1'new SizeF(p2.X-p1.X'10));  								else  									r2 = new RectangleF(p2'new SizeF(p1.X-p2.X'10));  								r3 = new RectangleF(p3' new SizeF(10' (from.Top - to.Bottom)/2+5));  								return r1.Contains(p.X'p.Y) || r2.Contains(p.X'p.Y) || r3.Contains(p.X'p.Y) ;  								  							case TreeDirection.Horizontal:    								p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   								p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							  								break;  						}  					#endregion  					break;  			}
Magic Number,Netron.Lithium,Connection,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Hit,The following statement contains a magic number: switch(site.ConnectionType)  			{  				case ConnectionType.Default:  					#region The default Hit method  					  					float o'u;  					p1 = start; p2 = end; 	 					// p1 must be the leftmost point. 					if (p1.X > p2.X) { s = p2; p2 = p1; p1 = s; }  					//this is specifically necessary when the layout works horizontally 					//the method beneth will not return true as should be in this case 					if(p1.Y==p2.Y) 					{ 						p1.Y+=-3; 						return new RectangleF(p1'new SizeF(p2.X-p1.X'6)).Contains(p); 					} 					r1 = new RectangleF(p1.X' p1.Y' 0' 0); 					r2 = new RectangleF(p2.X' p2.Y' 0' 0); 					r1.Inflate(3' 3); 					r2.Inflate(3' 3); 					//this is like a topological neighborhood 					//the connection is shifted left and right 					//and the point under consideration has to be in between.						 					if (RectangleF.Union(r1' r2).Contains(p)) 					{ 				 						if (p1.Y < p2.Y) //SWNE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							return ((p.X > o) && (p.X < u)); 						} 						else //NWSE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							return ((p.X > o) && (p.X < u)); 						} 					}  					#endregion  					break;  				case ConnectionType.Traditional:  					#region The rectangular Hit method  						switch(site.LayoutDirection)  						{  							case TreeDirection.Vertical:  								p1 = new PointF(from.Left + from.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5); //shift 5 to contain the connection  								p2 = new PointF(to.Left + to.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5);  								p3 = new Point(to.Left+to.Width/2-5'to.Bottom-5);    								r1 = new RectangleF(p1' new SizeF(10'(from.Top - to.Bottom)/2+5));   								if(p1.X<p2.X)  									r2 = new RectangleF(p1'new SizeF(p2.X-p1.X'10));  								else  									r2 = new RectangleF(p2'new SizeF(p1.X-p2.X'10));  								r3 = new RectangleF(p3' new SizeF(10' (from.Top - to.Bottom)/2+5));  								return r1.Contains(p.X'p.Y) || r2.Contains(p.X'p.Y) || r3.Contains(p.X'p.Y) ;  								  							case TreeDirection.Horizontal:    								p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   								p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							  								break;  						}  					#endregion  					break;  			}
Magic Number,Netron.Lithium,Connection,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Hit,The following statement contains a magic number: switch(site.ConnectionType)  			{  				case ConnectionType.Default:  					#region The default Hit method  					  					float o'u;  					p1 = start; p2 = end; 	 					// p1 must be the leftmost point. 					if (p1.X > p2.X) { s = p2; p2 = p1; p1 = s; }  					//this is specifically necessary when the layout works horizontally 					//the method beneth will not return true as should be in this case 					if(p1.Y==p2.Y) 					{ 						p1.Y+=-3; 						return new RectangleF(p1'new SizeF(p2.X-p1.X'6)).Contains(p); 					} 					r1 = new RectangleF(p1.X' p1.Y' 0' 0); 					r2 = new RectangleF(p2.X' p2.Y' 0' 0); 					r1.Inflate(3' 3); 					r2.Inflate(3' 3); 					//this is like a topological neighborhood 					//the connection is shifted left and right 					//and the point under consideration has to be in between.						 					if (RectangleF.Union(r1' r2).Contains(p)) 					{ 				 						if (p1.Y < p2.Y) //SWNE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							return ((p.X > o) && (p.X < u)); 						} 						else //NWSE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							return ((p.X > o) && (p.X < u)); 						} 					}  					#endregion  					break;  				case ConnectionType.Traditional:  					#region The rectangular Hit method  						switch(site.LayoutDirection)  						{  							case TreeDirection.Vertical:  								p1 = new PointF(from.Left + from.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5); //shift 5 to contain the connection  								p2 = new PointF(to.Left + to.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5);  								p3 = new Point(to.Left+to.Width/2-5'to.Bottom-5);    								r1 = new RectangleF(p1' new SizeF(10'(from.Top - to.Bottom)/2+5));   								if(p1.X<p2.X)  									r2 = new RectangleF(p1'new SizeF(p2.X-p1.X'10));  								else  									r2 = new RectangleF(p2'new SizeF(p1.X-p2.X'10));  								r3 = new RectangleF(p3' new SizeF(10' (from.Top - to.Bottom)/2+5));  								return r1.Contains(p.X'p.Y) || r2.Contains(p.X'p.Y) || r3.Contains(p.X'p.Y) ;  								  							case TreeDirection.Horizontal:    								p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   								p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							  								break;  						}  					#endregion  					break;  			}
Magic Number,Netron.Lithium,Connection,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Hit,The following statement contains a magic number: switch(site.ConnectionType)  			{  				case ConnectionType.Default:  					#region The default Hit method  					  					float o'u;  					p1 = start; p2 = end; 	 					// p1 must be the leftmost point. 					if (p1.X > p2.X) { s = p2; p2 = p1; p1 = s; }  					//this is specifically necessary when the layout works horizontally 					//the method beneth will not return true as should be in this case 					if(p1.Y==p2.Y) 					{ 						p1.Y+=-3; 						return new RectangleF(p1'new SizeF(p2.X-p1.X'6)).Contains(p); 					} 					r1 = new RectangleF(p1.X' p1.Y' 0' 0); 					r2 = new RectangleF(p2.X' p2.Y' 0' 0); 					r1.Inflate(3' 3); 					r2.Inflate(3' 3); 					//this is like a topological neighborhood 					//the connection is shifted left and right 					//and the point under consideration has to be in between.						 					if (RectangleF.Union(r1' r2).Contains(p)) 					{ 				 						if (p1.Y < p2.Y) //SWNE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							return ((p.X > o) && (p.X < u)); 						} 						else //NWSE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							return ((p.X > o) && (p.X < u)); 						} 					}  					#endregion  					break;  				case ConnectionType.Traditional:  					#region The rectangular Hit method  						switch(site.LayoutDirection)  						{  							case TreeDirection.Vertical:  								p1 = new PointF(from.Left + from.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5); //shift 5 to contain the connection  								p2 = new PointF(to.Left + to.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5);  								p3 = new Point(to.Left+to.Width/2-5'to.Bottom-5);    								r1 = new RectangleF(p1' new SizeF(10'(from.Top - to.Bottom)/2+5));   								if(p1.X<p2.X)  									r2 = new RectangleF(p1'new SizeF(p2.X-p1.X'10));  								else  									r2 = new RectangleF(p2'new SizeF(p1.X-p2.X'10));  								r3 = new RectangleF(p3' new SizeF(10' (from.Top - to.Bottom)/2+5));  								return r1.Contains(p.X'p.Y) || r2.Contains(p.X'p.Y) || r3.Contains(p.X'p.Y) ;  								  							case TreeDirection.Horizontal:    								p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   								p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							  								break;  						}  					#endregion  					break;  			}
Magic Number,Netron.Lithium,Connection,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Hit,The following statement contains a magic number: switch(site.ConnectionType)  			{  				case ConnectionType.Default:  					#region The default Hit method  					  					float o'u;  					p1 = start; p2 = end; 	 					// p1 must be the leftmost point. 					if (p1.X > p2.X) { s = p2; p2 = p1; p1 = s; }  					//this is specifically necessary when the layout works horizontally 					//the method beneth will not return true as should be in this case 					if(p1.Y==p2.Y) 					{ 						p1.Y+=-3; 						return new RectangleF(p1'new SizeF(p2.X-p1.X'6)).Contains(p); 					} 					r1 = new RectangleF(p1.X' p1.Y' 0' 0); 					r2 = new RectangleF(p2.X' p2.Y' 0' 0); 					r1.Inflate(3' 3); 					r2.Inflate(3' 3); 					//this is like a topological neighborhood 					//the connection is shifted left and right 					//and the point under consideration has to be in between.						 					if (RectangleF.Union(r1' r2).Contains(p)) 					{ 				 						if (p1.Y < p2.Y) //SWNE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							return ((p.X > o) && (p.X < u)); 						} 						else //NWSE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							return ((p.X > o) && (p.X < u)); 						} 					}  					#endregion  					break;  				case ConnectionType.Traditional:  					#region The rectangular Hit method  						switch(site.LayoutDirection)  						{  							case TreeDirection.Vertical:  								p1 = new PointF(from.Left + from.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5); //shift 5 to contain the connection  								p2 = new PointF(to.Left + to.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5);  								p3 = new Point(to.Left+to.Width/2-5'to.Bottom-5);    								r1 = new RectangleF(p1' new SizeF(10'(from.Top - to.Bottom)/2+5));   								if(p1.X<p2.X)  									r2 = new RectangleF(p1'new SizeF(p2.X-p1.X'10));  								else  									r2 = new RectangleF(p2'new SizeF(p1.X-p2.X'10));  								r3 = new RectangleF(p3' new SizeF(10' (from.Top - to.Bottom)/2+5));  								return r1.Contains(p.X'p.Y) || r2.Contains(p.X'p.Y) || r3.Contains(p.X'p.Y) ;  								  							case TreeDirection.Horizontal:    								p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   								p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							  								break;  						}  					#endregion  					break;  			}
Magic Number,Netron.Lithium,Connection,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Hit,The following statement contains a magic number: switch(site.ConnectionType)  			{  				case ConnectionType.Default:  					#region The default Hit method  					  					float o'u;  					p1 = start; p2 = end; 	 					// p1 must be the leftmost point. 					if (p1.X > p2.X) { s = p2; p2 = p1; p1 = s; }  					//this is specifically necessary when the layout works horizontally 					//the method beneth will not return true as should be in this case 					if(p1.Y==p2.Y) 					{ 						p1.Y+=-3; 						return new RectangleF(p1'new SizeF(p2.X-p1.X'6)).Contains(p); 					} 					r1 = new RectangleF(p1.X' p1.Y' 0' 0); 					r2 = new RectangleF(p2.X' p2.Y' 0' 0); 					r1.Inflate(3' 3); 					r2.Inflate(3' 3); 					//this is like a topological neighborhood 					//the connection is shifted left and right 					//and the point under consideration has to be in between.						 					if (RectangleF.Union(r1' r2).Contains(p)) 					{ 				 						if (p1.Y < p2.Y) //SWNE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							return ((p.X > o) && (p.X < u)); 						} 						else //NWSE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							return ((p.X > o) && (p.X < u)); 						} 					}  					#endregion  					break;  				case ConnectionType.Traditional:  					#region The rectangular Hit method  						switch(site.LayoutDirection)  						{  							case TreeDirection.Vertical:  								p1 = new PointF(from.Left + from.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5); //shift 5 to contain the connection  								p2 = new PointF(to.Left + to.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5);  								p3 = new Point(to.Left+to.Width/2-5'to.Bottom-5);    								r1 = new RectangleF(p1' new SizeF(10'(from.Top - to.Bottom)/2+5));   								if(p1.X<p2.X)  									r2 = new RectangleF(p1'new SizeF(p2.X-p1.X'10));  								else  									r2 = new RectangleF(p2'new SizeF(p1.X-p2.X'10));  								r3 = new RectangleF(p3' new SizeF(10' (from.Top - to.Bottom)/2+5));  								return r1.Contains(p.X'p.Y) || r2.Contains(p.X'p.Y) || r3.Contains(p.X'p.Y) ;  								  							case TreeDirection.Horizontal:    								p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   								p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							  								break;  						}  					#endregion  					break;  			}
Magic Number,Netron.Lithium,Connection,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Hit,The following statement contains a magic number: switch(site.ConnectionType)  			{  				case ConnectionType.Default:  					#region The default Hit method  					  					float o'u;  					p1 = start; p2 = end; 	 					// p1 must be the leftmost point. 					if (p1.X > p2.X) { s = p2; p2 = p1; p1 = s; }  					//this is specifically necessary when the layout works horizontally 					//the method beneth will not return true as should be in this case 					if(p1.Y==p2.Y) 					{ 						p1.Y+=-3; 						return new RectangleF(p1'new SizeF(p2.X-p1.X'6)).Contains(p); 					} 					r1 = new RectangleF(p1.X' p1.Y' 0' 0); 					r2 = new RectangleF(p2.X' p2.Y' 0' 0); 					r1.Inflate(3' 3); 					r2.Inflate(3' 3); 					//this is like a topological neighborhood 					//the connection is shifted left and right 					//and the point under consideration has to be in between.						 					if (RectangleF.Union(r1' r2).Contains(p)) 					{ 				 						if (p1.Y < p2.Y) //SWNE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							return ((p.X > o) && (p.X < u)); 						} 						else //NWSE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							return ((p.X > o) && (p.X < u)); 						} 					}  					#endregion  					break;  				case ConnectionType.Traditional:  					#region The rectangular Hit method  						switch(site.LayoutDirection)  						{  							case TreeDirection.Vertical:  								p1 = new PointF(from.Left + from.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5); //shift 5 to contain the connection  								p2 = new PointF(to.Left + to.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5);  								p3 = new Point(to.Left+to.Width/2-5'to.Bottom-5);    								r1 = new RectangleF(p1' new SizeF(10'(from.Top - to.Bottom)/2+5));   								if(p1.X<p2.X)  									r2 = new RectangleF(p1'new SizeF(p2.X-p1.X'10));  								else  									r2 = new RectangleF(p2'new SizeF(p1.X-p2.X'10));  								r3 = new RectangleF(p3' new SizeF(10' (from.Top - to.Bottom)/2+5));  								return r1.Contains(p.X'p.Y) || r2.Contains(p.X'p.Y) || r3.Contains(p.X'p.Y) ;  								  							case TreeDirection.Horizontal:    								p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   								p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							  								break;  						}  					#endregion  					break;  			}
Magic Number,Netron.Lithium,ShapeBase,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\ShapeBase.cs,Fit,The following statement contains a magic number: rectangle.Width =s.Width +10;
Magic Number,Netron.Lithium,ShapeBase,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\ShapeBase.cs,Fit,The following statement contains a magic number: rectangle.Height = s.Height+8;
Magic Number,Netron.Lithium,ShapeBase,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\ShapeBase.cs,AddChild,The following statement contains a magic number: shape.Location = new Point(Width/2+50'Height/2+50);
Magic Number,Netron.Lithium,ShapeBase,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\ShapeBase.cs,AddChild,The following statement contains a magic number: shape.Location = new Point(Width/2+50'Height/2+50);
Magic Number,Netron.Lithium,ShapeBase,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\ShapeBase.cs,AddChild,The following statement contains a magic number: shape.Location = new Point(Width/2+50'Height/2+50);
Magic Number,Netron.Lithium,ShapeBase,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\ShapeBase.cs,AddChild,The following statement contains a magic number: shape.Location = new Point(Width/2+50'Height/2+50);
Magic Number,Netron.Lithium,ShapeBase,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\ShapeBase.cs,AddChild,The following statement contains a magic number: shape.Width = 50;
Magic Number,Netron.Lithium,ShapeBase,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\ShapeBase.cs,AddChild,The following statement contains a magic number: shape.Height = 25;
Magic Number,Netron.Lithium,ShapeBase,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\ShapeBase.cs,Init,The following statement contains a magic number: rectangle = new Rectangle(0'0'100'70);
Magic Number,Netron.Lithium,ShapeBase,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\ShapeBase.cs,Init,The following statement contains a magic number: rectangle = new Rectangle(0'0'100'70);
Magic Number,Netron.Lithium,OvalShape,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\OvalShape.cs,Hit,The following statement contains a magic number: Rectangle r= new Rectangle(p' new Size(5'5));
Magic Number,Netron.Lithium,OvalShape,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\OvalShape.cs,Hit,The following statement contains a magic number: Rectangle r= new Rectangle(p' new Size(5'5));
Magic Number,Netron.Lithium,OvalShape,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\OvalShape.cs,Paint,The following statement contains a magic number: if(text !=string.Empty)  				g.DrawString(text'font'Brushes.Black' rectangle.X+10'rectangle.Y+10);
Magic Number,Netron.Lithium,OvalShape,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\OvalShape.cs,Paint,The following statement contains a magic number: if(text !=string.Empty)  				g.DrawString(text'font'Brushes.Black' rectangle.X+10'rectangle.Y+10);
Magic Number,Netron.Lithium,OvalShape,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\OvalShape.cs,Invalidate,The following statement contains a magic number: r.Offset(-5'-5);
Magic Number,Netron.Lithium,OvalShape,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\OvalShape.cs,Invalidate,The following statement contains a magic number: r.Offset(-5'-5);
Magic Number,Netron.Lithium,OvalShape,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\OvalShape.cs,Invalidate,The following statement contains a magic number: r.Inflate(20'20);
Magic Number,Netron.Lithium,OvalShape,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\OvalShape.cs,Invalidate,The following statement contains a magic number: r.Inflate(20'20);
Magic Number,Netron.Lithium,SimpleRectangle,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Hit,The following statement contains a magic number: Rectangle r= new Rectangle(p' new Size(2'2));
Magic Number,Netron.Lithium,SimpleRectangle,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Hit,The following statement contains a magic number: Rectangle r= new Rectangle(p' new Size(2'2));
Magic Number,Netron.Lithium,SimpleRectangle,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: Point[] pts = new Point[12]  				{  					new Point(rectangle.X'rectangle.Y)' //0  					new Point(rectangle.X+bshift'rectangle.Y)' //1  					new Point(rectangle.Right-bshift'rectangle.Y)' //2  					new Point(rectangle.Right'rectangle.Y)' //3  					new Point(rectangle.Right'rectangle.Y+bshift)' //4  					new Point(rectangle.Right'rectangle.Bottom-bshift)' //5  					new Point(rectangle.Right'rectangle.Bottom)' //6  					new Point(rectangle.Right-bshift'rectangle.Bottom)' //7  					new Point(rectangle.X+bshift'rectangle.Bottom)' //8  					new Point(rectangle.X'rectangle.Bottom)' //9  					new Point(rectangle.X'rectangle.Bottom - bshift)' //10  					new Point(rectangle.X'rectangle.Y+bshift)' //11				  			};
Magic Number,Netron.Lithium,SimpleRectangle,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: path.AddBezier(pts[11]'pts[0]'pts[0]'pts[1]);
Magic Number,Netron.Lithium,SimpleRectangle,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: path.AddLine(pts[1]'pts[2]);
Magic Number,Netron.Lithium,SimpleRectangle,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: path.AddBezier(pts[2]'pts[3]'pts[3]'pts[4]);
Magic Number,Netron.Lithium,SimpleRectangle,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: path.AddBezier(pts[2]'pts[3]'pts[3]'pts[4]);
Magic Number,Netron.Lithium,SimpleRectangle,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: path.AddBezier(pts[2]'pts[3]'pts[3]'pts[4]);
Magic Number,Netron.Lithium,SimpleRectangle,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: path.AddBezier(pts[2]'pts[3]'pts[3]'pts[4]);
Magic Number,Netron.Lithium,SimpleRectangle,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: path.AddLine(pts[4]'pts[5]);
Magic Number,Netron.Lithium,SimpleRectangle,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: path.AddLine(pts[4]'pts[5]);
Magic Number,Netron.Lithium,SimpleRectangle,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: path.AddBezier(pts[5]'pts[6]'pts[6]'pts[7]);
Magic Number,Netron.Lithium,SimpleRectangle,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: path.AddBezier(pts[5]'pts[6]'pts[6]'pts[7]);
Magic Number,Netron.Lithium,SimpleRectangle,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: path.AddBezier(pts[5]'pts[6]'pts[6]'pts[7]);
Magic Number,Netron.Lithium,SimpleRectangle,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: path.AddBezier(pts[5]'pts[6]'pts[6]'pts[7]);
Magic Number,Netron.Lithium,SimpleRectangle,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: path.AddLine(pts[7]'pts[8]);
Magic Number,Netron.Lithium,SimpleRectangle,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: path.AddLine(pts[7]'pts[8]);
Magic Number,Netron.Lithium,SimpleRectangle,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: path.AddBezier(pts[8]'pts[9]'pts[9]'pts[10]);
Magic Number,Netron.Lithium,SimpleRectangle,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: path.AddBezier(pts[8]'pts[9]'pts[9]'pts[10]);
Magic Number,Netron.Lithium,SimpleRectangle,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: path.AddBezier(pts[8]'pts[9]'pts[9]'pts[10]);
Magic Number,Netron.Lithium,SimpleRectangle,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: path.AddBezier(pts[8]'pts[9]'pts[9]'pts[10]);
Magic Number,Netron.Lithium,SimpleRectangle,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: path.AddLine(pts[10]'pts[11]);
Magic Number,Netron.Lithium,SimpleRectangle,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: path.AddLine(pts[10]'pts[11]);
Magic Number,Netron.Lithium,SimpleRectangle,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: shadow.Translate(5' 5);
Magic Number,Netron.Lithium,SimpleRectangle,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: shadow.Translate(5' 5);
Magic Number,Netron.Lithium,SimpleRectangle,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: if (text != string.Empty)  			{  				//g.DrawString(text + plus'font'Brushes.Black' rectangle.X+5'rectangle.Y+5);  				g.DrawString(text'font'Brushes.Black' rectangle.X+5'rectangle.Y+5);  			}
Magic Number,Netron.Lithium,SimpleRectangle,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: if (text != string.Empty)  			{  				//g.DrawString(text + plus'font'Brushes.Black' rectangle.X+5'rectangle.Y+5);  				g.DrawString(text'font'Brushes.Black' rectangle.X+5'rectangle.Y+5);  			}
Magic Number,Netron.Lithium,SimpleRectangle,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: if (childNodes.Count > 0)  			{  				switch(site.LayoutDirection)  				{  				  					case TreeDirection.Vertical:  						toggleNode = new Rectangle(Left + this.Width/2 - 5' Bottom' 10' 10);  						break;  					case TreeDirection.Horizontal:  						toggleNode = new Rectangle(Right ' Top +Height/2-5 ' 10' 10);  						break;  				}  				                    				//Draw [ ]  				g.FillRectangle(new SolidBrush(Color.White)' toggleNode);  				g.DrawRectangle(blackPen' toggleNode);                    				//Draw -  				g.DrawLine(blackPen' (toggleNode.X + 2)' (toggleNode.Y + (toggleNode.Height / 2))' (toggleNode.X + (toggleNode.Width - 2))' (toggleNode.Y + (toggleNode.Height / 2)) );                    				if (!this.Expanded)  				{  					//Draw |  					g.DrawLine(blackPen' (toggleNode.X + (toggleNode.Width /2))' (toggleNode.Y + 2)' (toggleNode.X + (toggleNode.Width /2))' (toggleNode.Y + (toggleNode.Height - 2)));  				}  			}
Magic Number,Netron.Lithium,SimpleRectangle,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: if (childNodes.Count > 0)  			{  				switch(site.LayoutDirection)  				{  				  					case TreeDirection.Vertical:  						toggleNode = new Rectangle(Left + this.Width/2 - 5' Bottom' 10' 10);  						break;  					case TreeDirection.Horizontal:  						toggleNode = new Rectangle(Right ' Top +Height/2-5 ' 10' 10);  						break;  				}  				                    				//Draw [ ]  				g.FillRectangle(new SolidBrush(Color.White)' toggleNode);  				g.DrawRectangle(blackPen' toggleNode);                    				//Draw -  				g.DrawLine(blackPen' (toggleNode.X + 2)' (toggleNode.Y + (toggleNode.Height / 2))' (toggleNode.X + (toggleNode.Width - 2))' (toggleNode.Y + (toggleNode.Height / 2)) );                    				if (!this.Expanded)  				{  					//Draw |  					g.DrawLine(blackPen' (toggleNode.X + (toggleNode.Width /2))' (toggleNode.Y + 2)' (toggleNode.X + (toggleNode.Width /2))' (toggleNode.Y + (toggleNode.Height - 2)));  				}  			}
Magic Number,Netron.Lithium,SimpleRectangle,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: if (childNodes.Count > 0)  			{  				switch(site.LayoutDirection)  				{  				  					case TreeDirection.Vertical:  						toggleNode = new Rectangle(Left + this.Width/2 - 5' Bottom' 10' 10);  						break;  					case TreeDirection.Horizontal:  						toggleNode = new Rectangle(Right ' Top +Height/2-5 ' 10' 10);  						break;  				}  				                    				//Draw [ ]  				g.FillRectangle(new SolidBrush(Color.White)' toggleNode);  				g.DrawRectangle(blackPen' toggleNode);                    				//Draw -  				g.DrawLine(blackPen' (toggleNode.X + 2)' (toggleNode.Y + (toggleNode.Height / 2))' (toggleNode.X + (toggleNode.Width - 2))' (toggleNode.Y + (toggleNode.Height / 2)) );                    				if (!this.Expanded)  				{  					//Draw |  					g.DrawLine(blackPen' (toggleNode.X + (toggleNode.Width /2))' (toggleNode.Y + 2)' (toggleNode.X + (toggleNode.Width /2))' (toggleNode.Y + (toggleNode.Height - 2)));  				}  			}
Magic Number,Netron.Lithium,SimpleRectangle,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: if (childNodes.Count > 0)  			{  				switch(site.LayoutDirection)  				{  				  					case TreeDirection.Vertical:  						toggleNode = new Rectangle(Left + this.Width/2 - 5' Bottom' 10' 10);  						break;  					case TreeDirection.Horizontal:  						toggleNode = new Rectangle(Right ' Top +Height/2-5 ' 10' 10);  						break;  				}  				                    				//Draw [ ]  				g.FillRectangle(new SolidBrush(Color.White)' toggleNode);  				g.DrawRectangle(blackPen' toggleNode);                    				//Draw -  				g.DrawLine(blackPen' (toggleNode.X + 2)' (toggleNode.Y + (toggleNode.Height / 2))' (toggleNode.X + (toggleNode.Width - 2))' (toggleNode.Y + (toggleNode.Height / 2)) );                    				if (!this.Expanded)  				{  					//Draw |  					g.DrawLine(blackPen' (toggleNode.X + (toggleNode.Width /2))' (toggleNode.Y + 2)' (toggleNode.X + (toggleNode.Width /2))' (toggleNode.Y + (toggleNode.Height - 2)));  				}  			}
Magic Number,Netron.Lithium,SimpleRectangle,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: if (childNodes.Count > 0)  			{  				switch(site.LayoutDirection)  				{  				  					case TreeDirection.Vertical:  						toggleNode = new Rectangle(Left + this.Width/2 - 5' Bottom' 10' 10);  						break;  					case TreeDirection.Horizontal:  						toggleNode = new Rectangle(Right ' Top +Height/2-5 ' 10' 10);  						break;  				}  				                    				//Draw [ ]  				g.FillRectangle(new SolidBrush(Color.White)' toggleNode);  				g.DrawRectangle(blackPen' toggleNode);                    				//Draw -  				g.DrawLine(blackPen' (toggleNode.X + 2)' (toggleNode.Y + (toggleNode.Height / 2))' (toggleNode.X + (toggleNode.Width - 2))' (toggleNode.Y + (toggleNode.Height / 2)) );                    				if (!this.Expanded)  				{  					//Draw |  					g.DrawLine(blackPen' (toggleNode.X + (toggleNode.Width /2))' (toggleNode.Y + 2)' (toggleNode.X + (toggleNode.Width /2))' (toggleNode.Y + (toggleNode.Height - 2)));  				}  			}
Magic Number,Netron.Lithium,SimpleRectangle,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: if (childNodes.Count > 0)  			{  				switch(site.LayoutDirection)  				{  				  					case TreeDirection.Vertical:  						toggleNode = new Rectangle(Left + this.Width/2 - 5' Bottom' 10' 10);  						break;  					case TreeDirection.Horizontal:  						toggleNode = new Rectangle(Right ' Top +Height/2-5 ' 10' 10);  						break;  				}  				                    				//Draw [ ]  				g.FillRectangle(new SolidBrush(Color.White)' toggleNode);  				g.DrawRectangle(blackPen' toggleNode);                    				//Draw -  				g.DrawLine(blackPen' (toggleNode.X + 2)' (toggleNode.Y + (toggleNode.Height / 2))' (toggleNode.X + (toggleNode.Width - 2))' (toggleNode.Y + (toggleNode.Height / 2)) );                    				if (!this.Expanded)  				{  					//Draw |  					g.DrawLine(blackPen' (toggleNode.X + (toggleNode.Width /2))' (toggleNode.Y + 2)' (toggleNode.X + (toggleNode.Width /2))' (toggleNode.Y + (toggleNode.Height - 2)));  				}  			}
Magic Number,Netron.Lithium,SimpleRectangle,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: if (childNodes.Count > 0)  			{  				switch(site.LayoutDirection)  				{  				  					case TreeDirection.Vertical:  						toggleNode = new Rectangle(Left + this.Width/2 - 5' Bottom' 10' 10);  						break;  					case TreeDirection.Horizontal:  						toggleNode = new Rectangle(Right ' Top +Height/2-5 ' 10' 10);  						break;  				}  				                    				//Draw [ ]  				g.FillRectangle(new SolidBrush(Color.White)' toggleNode);  				g.DrawRectangle(blackPen' toggleNode);                    				//Draw -  				g.DrawLine(blackPen' (toggleNode.X + 2)' (toggleNode.Y + (toggleNode.Height / 2))' (toggleNode.X + (toggleNode.Width - 2))' (toggleNode.Y + (toggleNode.Height / 2)) );                    				if (!this.Expanded)  				{  					//Draw |  					g.DrawLine(blackPen' (toggleNode.X + (toggleNode.Width /2))' (toggleNode.Y + 2)' (toggleNode.X + (toggleNode.Width /2))' (toggleNode.Y + (toggleNode.Height - 2)));  				}  			}
Magic Number,Netron.Lithium,SimpleRectangle,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: if (childNodes.Count > 0)  			{  				switch(site.LayoutDirection)  				{  				  					case TreeDirection.Vertical:  						toggleNode = new Rectangle(Left + this.Width/2 - 5' Bottom' 10' 10);  						break;  					case TreeDirection.Horizontal:  						toggleNode = new Rectangle(Right ' Top +Height/2-5 ' 10' 10);  						break;  				}  				                    				//Draw [ ]  				g.FillRectangle(new SolidBrush(Color.White)' toggleNode);  				g.DrawRectangle(blackPen' toggleNode);                    				//Draw -  				g.DrawLine(blackPen' (toggleNode.X + 2)' (toggleNode.Y + (toggleNode.Height / 2))' (toggleNode.X + (toggleNode.Width - 2))' (toggleNode.Y + (toggleNode.Height / 2)) );                    				if (!this.Expanded)  				{  					//Draw |  					g.DrawLine(blackPen' (toggleNode.X + (toggleNode.Width /2))' (toggleNode.Y + 2)' (toggleNode.X + (toggleNode.Width /2))' (toggleNode.Y + (toggleNode.Height - 2)));  				}  			}
Magic Number,Netron.Lithium,SimpleRectangle,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: if (childNodes.Count > 0)  			{  				switch(site.LayoutDirection)  				{  				  					case TreeDirection.Vertical:  						toggleNode = new Rectangle(Left + this.Width/2 - 5' Bottom' 10' 10);  						break;  					case TreeDirection.Horizontal:  						toggleNode = new Rectangle(Right ' Top +Height/2-5 ' 10' 10);  						break;  				}  				                    				//Draw [ ]  				g.FillRectangle(new SolidBrush(Color.White)' toggleNode);  				g.DrawRectangle(blackPen' toggleNode);                    				//Draw -  				g.DrawLine(blackPen' (toggleNode.X + 2)' (toggleNode.Y + (toggleNode.Height / 2))' (toggleNode.X + (toggleNode.Width - 2))' (toggleNode.Y + (toggleNode.Height / 2)) );                    				if (!this.Expanded)  				{  					//Draw |  					g.DrawLine(blackPen' (toggleNode.X + (toggleNode.Width /2))' (toggleNode.Y + 2)' (toggleNode.X + (toggleNode.Width /2))' (toggleNode.Y + (toggleNode.Height - 2)));  				}  			}
Magic Number,Netron.Lithium,SimpleRectangle,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: if (childNodes.Count > 0)  			{  				switch(site.LayoutDirection)  				{  				  					case TreeDirection.Vertical:  						toggleNode = new Rectangle(Left + this.Width/2 - 5' Bottom' 10' 10);  						break;  					case TreeDirection.Horizontal:  						toggleNode = new Rectangle(Right ' Top +Height/2-5 ' 10' 10);  						break;  				}  				                    				//Draw [ ]  				g.FillRectangle(new SolidBrush(Color.White)' toggleNode);  				g.DrawRectangle(blackPen' toggleNode);                    				//Draw -  				g.DrawLine(blackPen' (toggleNode.X + 2)' (toggleNode.Y + (toggleNode.Height / 2))' (toggleNode.X + (toggleNode.Width - 2))' (toggleNode.Y + (toggleNode.Height / 2)) );                    				if (!this.Expanded)  				{  					//Draw |  					g.DrawLine(blackPen' (toggleNode.X + (toggleNode.Width /2))' (toggleNode.Y + 2)' (toggleNode.X + (toggleNode.Width /2))' (toggleNode.Y + (toggleNode.Height - 2)));  				}  			}
Magic Number,Netron.Lithium,SimpleRectangle,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: if (childNodes.Count > 0)  			{  				switch(site.LayoutDirection)  				{  				  					case TreeDirection.Vertical:  						toggleNode = new Rectangle(Left + this.Width/2 - 5' Bottom' 10' 10);  						break;  					case TreeDirection.Horizontal:  						toggleNode = new Rectangle(Right ' Top +Height/2-5 ' 10' 10);  						break;  				}  				                    				//Draw [ ]  				g.FillRectangle(new SolidBrush(Color.White)' toggleNode);  				g.DrawRectangle(blackPen' toggleNode);                    				//Draw -  				g.DrawLine(blackPen' (toggleNode.X + 2)' (toggleNode.Y + (toggleNode.Height / 2))' (toggleNode.X + (toggleNode.Width - 2))' (toggleNode.Y + (toggleNode.Height / 2)) );                    				if (!this.Expanded)  				{  					//Draw |  					g.DrawLine(blackPen' (toggleNode.X + (toggleNode.Width /2))' (toggleNode.Y + 2)' (toggleNode.X + (toggleNode.Width /2))' (toggleNode.Y + (toggleNode.Height - 2)));  				}  			}
Magic Number,Netron.Lithium,SimpleRectangle,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: if (childNodes.Count > 0)  			{  				switch(site.LayoutDirection)  				{  				  					case TreeDirection.Vertical:  						toggleNode = new Rectangle(Left + this.Width/2 - 5' Bottom' 10' 10);  						break;  					case TreeDirection.Horizontal:  						toggleNode = new Rectangle(Right ' Top +Height/2-5 ' 10' 10);  						break;  				}  				                    				//Draw [ ]  				g.FillRectangle(new SolidBrush(Color.White)' toggleNode);  				g.DrawRectangle(blackPen' toggleNode);                    				//Draw -  				g.DrawLine(blackPen' (toggleNode.X + 2)' (toggleNode.Y + (toggleNode.Height / 2))' (toggleNode.X + (toggleNode.Width - 2))' (toggleNode.Y + (toggleNode.Height / 2)) );                    				if (!this.Expanded)  				{  					//Draw |  					g.DrawLine(blackPen' (toggleNode.X + (toggleNode.Width /2))' (toggleNode.Y + 2)' (toggleNode.X + (toggleNode.Width /2))' (toggleNode.Y + (toggleNode.Height - 2)));  				}  			}
Magic Number,Netron.Lithium,SimpleRectangle,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: if (childNodes.Count > 0)  			{  				switch(site.LayoutDirection)  				{  				  					case TreeDirection.Vertical:  						toggleNode = new Rectangle(Left + this.Width/2 - 5' Bottom' 10' 10);  						break;  					case TreeDirection.Horizontal:  						toggleNode = new Rectangle(Right ' Top +Height/2-5 ' 10' 10);  						break;  				}  				                    				//Draw [ ]  				g.FillRectangle(new SolidBrush(Color.White)' toggleNode);  				g.DrawRectangle(blackPen' toggleNode);                    				//Draw -  				g.DrawLine(blackPen' (toggleNode.X + 2)' (toggleNode.Y + (toggleNode.Height / 2))' (toggleNode.X + (toggleNode.Width - 2))' (toggleNode.Y + (toggleNode.Height / 2)) );                    				if (!this.Expanded)  				{  					//Draw |  					g.DrawLine(blackPen' (toggleNode.X + (toggleNode.Width /2))' (toggleNode.Y + 2)' (toggleNode.X + (toggleNode.Width /2))' (toggleNode.Y + (toggleNode.Height - 2)));  				}  			}
Magic Number,Netron.Lithium,SimpleRectangle,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: if (childNodes.Count > 0)  			{  				switch(site.LayoutDirection)  				{  				  					case TreeDirection.Vertical:  						toggleNode = new Rectangle(Left + this.Width/2 - 5' Bottom' 10' 10);  						break;  					case TreeDirection.Horizontal:  						toggleNode = new Rectangle(Right ' Top +Height/2-5 ' 10' 10);  						break;  				}  				                    				//Draw [ ]  				g.FillRectangle(new SolidBrush(Color.White)' toggleNode);  				g.DrawRectangle(blackPen' toggleNode);                    				//Draw -  				g.DrawLine(blackPen' (toggleNode.X + 2)' (toggleNode.Y + (toggleNode.Height / 2))' (toggleNode.X + (toggleNode.Width - 2))' (toggleNode.Y + (toggleNode.Height / 2)) );                    				if (!this.Expanded)  				{  					//Draw |  					g.DrawLine(blackPen' (toggleNode.X + (toggleNode.Width /2))' (toggleNode.Y + 2)' (toggleNode.X + (toggleNode.Width /2))' (toggleNode.Y + (toggleNode.Height - 2)));  				}  			}
Magic Number,Netron.Lithium,SimpleRectangle,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: if (childNodes.Count > 0)  			{  				switch(site.LayoutDirection)  				{  				  					case TreeDirection.Vertical:  						toggleNode = new Rectangle(Left + this.Width/2 - 5' Bottom' 10' 10);  						break;  					case TreeDirection.Horizontal:  						toggleNode = new Rectangle(Right ' Top +Height/2-5 ' 10' 10);  						break;  				}  				                    				//Draw [ ]  				g.FillRectangle(new SolidBrush(Color.White)' toggleNode);  				g.DrawRectangle(blackPen' toggleNode);                    				//Draw -  				g.DrawLine(blackPen' (toggleNode.X + 2)' (toggleNode.Y + (toggleNode.Height / 2))' (toggleNode.X + (toggleNode.Width - 2))' (toggleNode.Y + (toggleNode.Height / 2)) );                    				if (!this.Expanded)  				{  					//Draw |  					g.DrawLine(blackPen' (toggleNode.X + (toggleNode.Width /2))' (toggleNode.Y + 2)' (toggleNode.X + (toggleNode.Width /2))' (toggleNode.Y + (toggleNode.Height - 2)));  				}  			}
Magic Number,Netron.Lithium,SimpleRectangle,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following statement contains a magic number: if (childNodes.Count > 0)  			{  				switch(site.LayoutDirection)  				{  				  					case TreeDirection.Vertical:  						toggleNode = new Rectangle(Left + this.Width/2 - 5' Bottom' 10' 10);  						break;  					case TreeDirection.Horizontal:  						toggleNode = new Rectangle(Right ' Top +Height/2-5 ' 10' 10);  						break;  				}  				                    				//Draw [ ]  				g.FillRectangle(new SolidBrush(Color.White)' toggleNode);  				g.DrawRectangle(blackPen' toggleNode);                    				//Draw -  				g.DrawLine(blackPen' (toggleNode.X + 2)' (toggleNode.Y + (toggleNode.Height / 2))' (toggleNode.X + (toggleNode.Width - 2))' (toggleNode.Y + (toggleNode.Height / 2)) );                    				if (!this.Expanded)  				{  					//Draw |  					g.DrawLine(blackPen' (toggleNode.X + (toggleNode.Width /2))' (toggleNode.Y + 2)' (toggleNode.X + (toggleNode.Width /2))' (toggleNode.Y + (toggleNode.Height - 2)));  				}  			}
Magic Number,Netron.Lithium,SimpleRectangle,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Invalidate,The following statement contains a magic number: r.Offset(-5'-5);
Magic Number,Netron.Lithium,SimpleRectangle,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Invalidate,The following statement contains a magic number: r.Offset(-5'-5);
Magic Number,Netron.Lithium,SimpleRectangle,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Invalidate,The following statement contains a magic number: r.Inflate(40'40);
Magic Number,Netron.Lithium,SimpleRectangle,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Invalidate,The following statement contains a magic number: r.Inflate(40'40);
Magic Number,Netron.Lithium,TextLabel,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\TextLabel.cs,Hit,The following statement contains a magic number: Rectangle r= new Rectangle(p' new Size(5'5));
Magic Number,Netron.Lithium,TextLabel,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\TextLabel.cs,Hit,The following statement contains a magic number: Rectangle r= new Rectangle(p' new Size(5'5));
Magic Number,Netron.Lithium,TextLabel,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\TextLabel.cs,Paint,The following statement contains a magic number: if(text !=string.Empty)  				g.DrawString(text'font'Brushes.Black' rectangle.X+10'rectangle.Y+10);
Magic Number,Netron.Lithium,TextLabel,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\TextLabel.cs,Paint,The following statement contains a magic number: if(text !=string.Empty)  				g.DrawString(text'font'Brushes.Black' rectangle.X+10'rectangle.Y+10);
Magic Number,Netron.Lithium,TextLabel,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\TextLabel.cs,Invalidate,The following statement contains a magic number: r.Offset(-5'-5);
Magic Number,Netron.Lithium,TextLabel,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\TextLabel.cs,Invalidate,The following statement contains a magic number: r.Offset(-5'-5);
Magic Number,Netron.Lithium,TextLabel,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\TextLabel.cs,Invalidate,The following statement contains a magic number: r.Inflate(20'20);
Magic Number,Netron.Lithium,TextLabel,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\TextLabel.cs,Invalidate,The following statement contains a magic number: r.Inflate(20'20);
Magic Number,Netron.Lithium,LithiumControl,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,AddRoot,The following statement contains a magic number: root.Location = new Point(Width/2+50'Height/2+50);
Magic Number,Netron.Lithium,LithiumControl,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,AddRoot,The following statement contains a magic number: root.Location = new Point(Width/2+50'Height/2+50);
Magic Number,Netron.Lithium,LithiumControl,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,AddRoot,The following statement contains a magic number: root.Location = new Point(Width/2+50'Height/2+50);
Magic Number,Netron.Lithium,LithiumControl,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,AddRoot,The following statement contains a magic number: root.Location = new Point(Width/2+50'Height/2+50);
Magic Number,Netron.Lithium,LithiumControl,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,AddRoot,The following statement contains a magic number: root.Width = 50;
Magic Number,Netron.Lithium,LithiumControl,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,AddRoot,The following statement contains a magic number: root.Height = 25;
Magic Number,Netron.Lithium,LithiumControl,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,CenterRoot,The following statement contains a magic number: graphAbstract.Root.rectangle.Location = new Point(Width/2'Height/2);
Magic Number,Netron.Lithium,LithiumControl,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,CenterRoot,The following statement contains a magic number: graphAbstract.Root.rectangle.Location = new Point(Width/2'Height/2);
Magic Number,Netron.Lithium,LithiumControl,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,AddShape,The following statement contains a magic number: switch(type)  			{  				case ShapeTypes.Rectangular:  					shape = new SimpleRectangle(this);  					break;  				case ShapeTypes.Oval:  					shape = new OvalShape(this);  					break;  				case ShapeTypes.TextLabel:  					shape = new TextLabel(this);  					shape.Location = location;  					shape.ShapeColor = Color.Transparent;  					shape.Text = "A text label (change the text in the property grid)";  					shape.Width = 350;  					shape.Height = 30;  					Shapes.Add(shape);  					return shape;      			}
Magic Number,Netron.Lithium,LithiumControl,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,AddShape,The following statement contains a magic number: switch(type)  			{  				case ShapeTypes.Rectangular:  					shape = new SimpleRectangle(this);  					break;  				case ShapeTypes.Oval:  					shape = new OvalShape(this);  					break;  				case ShapeTypes.TextLabel:  					shape = new TextLabel(this);  					shape.Location = location;  					shape.ShapeColor = Color.Transparent;  					shape.Text = "A text label (change the text in the property grid)";  					shape.Width = 350;  					shape.Height = 30;  					Shapes.Add(shape);  					return shape;      			}
Magic Number,Netron.Lithium,LithiumControl,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,AddShape,The following statement contains a magic number: shape.ShapeColor = Color.FromArgb(rnd.Next(0'255)'rnd.Next(0'255)'rnd.Next(0'255));
Magic Number,Netron.Lithium,LithiumControl,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,AddShape,The following statement contains a magic number: shape.ShapeColor = Color.FromArgb(rnd.Next(0'255)'rnd.Next(0'255)'rnd.Next(0'255));
Magic Number,Netron.Lithium,LithiumControl,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,AddShape,The following statement contains a magic number: shape.ShapeColor = Color.FromArgb(rnd.Next(0'255)'rnd.Next(0'255)'rnd.Next(0'255));
Magic Number,Netron.Lithium,LithiumControl,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,OnMouseDown,The following statement contains a magic number: for(int k=0; k<Shapes.Count; k++)  			{  				sh = Shapes[k];  				if(sh.childNodes.Count>0)//has a [+/-]  				{  					if(layoutDirection==TreeDirection.Vertical)  						r = new Rectangle(sh.Left + sh.Width/2 - 5' sh.Bottom' 10' 10);  					else  						r = new Rectangle(sh.Right' sh.Y + sh.Height/2-5' 10' 10);    					if(r.Contains(p))  					{  						if(sh.expanded)  							sh.Collapse(true);  						else  							sh.Expand();  						DrawTree();  					}  				}  				if(Shapes[k].Hit(p))  				{  					//shapes[k].ShapeColor = Color.WhiteSmoke;  					if(selectedEntity!=null)   						selectedEntity.IsSelected=false;  					selectedEntity = Shapes[k];  					selectedEntity.IsSelected = true;  					sh = selectedEntity as ShapeBase;	  					#region CONTROL  //					if(Control.ModifierKeys==Keys.Control && !sh.IsRoot)  //					{  //						tracking = true;  //						//remove from parent							  //						sh.parentNode.childNodes.Remove(sh);  //						Connections.Remove(sh' sh.parentNode);						  //						//...but keep the reference in case the user didn't find a new location  //						memChild = sh;  //						memParent = sh.parentNode;  //						//now remove the reference  //						sh.parentNode = null;  //					}  					#endregion  					//set the point for the next round  					refp=p;    					#region Double-click  					if(e.Button==MouseButtons.Left && e.Clicks==2)  					{							  						if(sh.expanded)  							sh.Collapse(true);  						else  							sh.Expand();  						DrawTree();  					}  					#endregion    					#region ALT  //					if(Control.ModifierKeys==Keys.Alt)  //					{  //						sh.AddChild("New");	  //						DrawTree();  //					}        					#endregion  					if(OnShowProps!=null)  						OnShowProps(Shapes[k]);  						  					return;  				}  			}
Magic Number,Netron.Lithium,LithiumControl,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,OnMouseDown,The following statement contains a magic number: for(int k=0; k<Shapes.Count; k++)  			{  				sh = Shapes[k];  				if(sh.childNodes.Count>0)//has a [+/-]  				{  					if(layoutDirection==TreeDirection.Vertical)  						r = new Rectangle(sh.Left + sh.Width/2 - 5' sh.Bottom' 10' 10);  					else  						r = new Rectangle(sh.Right' sh.Y + sh.Height/2-5' 10' 10);    					if(r.Contains(p))  					{  						if(sh.expanded)  							sh.Collapse(true);  						else  							sh.Expand();  						DrawTree();  					}  				}  				if(Shapes[k].Hit(p))  				{  					//shapes[k].ShapeColor = Color.WhiteSmoke;  					if(selectedEntity!=null)   						selectedEntity.IsSelected=false;  					selectedEntity = Shapes[k];  					selectedEntity.IsSelected = true;  					sh = selectedEntity as ShapeBase;	  					#region CONTROL  //					if(Control.ModifierKeys==Keys.Control && !sh.IsRoot)  //					{  //						tracking = true;  //						//remove from parent							  //						sh.parentNode.childNodes.Remove(sh);  //						Connections.Remove(sh' sh.parentNode);						  //						//...but keep the reference in case the user didn't find a new location  //						memChild = sh;  //						memParent = sh.parentNode;  //						//now remove the reference  //						sh.parentNode = null;  //					}  					#endregion  					//set the point for the next round  					refp=p;    					#region Double-click  					if(e.Button==MouseButtons.Left && e.Clicks==2)  					{							  						if(sh.expanded)  							sh.Collapse(true);  						else  							sh.Expand();  						DrawTree();  					}  					#endregion    					#region ALT  //					if(Control.ModifierKeys==Keys.Alt)  //					{  //						sh.AddChild("New");	  //						DrawTree();  //					}        					#endregion  					if(OnShowProps!=null)  						OnShowProps(Shapes[k]);  						  					return;  				}  			}
Magic Number,Netron.Lithium,LithiumControl,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,OnMouseDown,The following statement contains a magic number: for(int k=0; k<Shapes.Count; k++)  			{  				sh = Shapes[k];  				if(sh.childNodes.Count>0)//has a [+/-]  				{  					if(layoutDirection==TreeDirection.Vertical)  						r = new Rectangle(sh.Left + sh.Width/2 - 5' sh.Bottom' 10' 10);  					else  						r = new Rectangle(sh.Right' sh.Y + sh.Height/2-5' 10' 10);    					if(r.Contains(p))  					{  						if(sh.expanded)  							sh.Collapse(true);  						else  							sh.Expand();  						DrawTree();  					}  				}  				if(Shapes[k].Hit(p))  				{  					//shapes[k].ShapeColor = Color.WhiteSmoke;  					if(selectedEntity!=null)   						selectedEntity.IsSelected=false;  					selectedEntity = Shapes[k];  					selectedEntity.IsSelected = true;  					sh = selectedEntity as ShapeBase;	  					#region CONTROL  //					if(Control.ModifierKeys==Keys.Control && !sh.IsRoot)  //					{  //						tracking = true;  //						//remove from parent							  //						sh.parentNode.childNodes.Remove(sh);  //						Connections.Remove(sh' sh.parentNode);						  //						//...but keep the reference in case the user didn't find a new location  //						memChild = sh;  //						memParent = sh.parentNode;  //						//now remove the reference  //						sh.parentNode = null;  //					}  					#endregion  					//set the point for the next round  					refp=p;    					#region Double-click  					if(e.Button==MouseButtons.Left && e.Clicks==2)  					{							  						if(sh.expanded)  							sh.Collapse(true);  						else  							sh.Expand();  						DrawTree();  					}  					#endregion    					#region ALT  //					if(Control.ModifierKeys==Keys.Alt)  //					{  //						sh.AddChild("New");	  //						DrawTree();  //					}        					#endregion  					if(OnShowProps!=null)  						OnShowProps(Shapes[k]);  						  					return;  				}  			}
Magic Number,Netron.Lithium,LithiumControl,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,OnMouseDown,The following statement contains a magic number: for(int k=0; k<Shapes.Count; k++)  			{  				sh = Shapes[k];  				if(sh.childNodes.Count>0)//has a [+/-]  				{  					if(layoutDirection==TreeDirection.Vertical)  						r = new Rectangle(sh.Left + sh.Width/2 - 5' sh.Bottom' 10' 10);  					else  						r = new Rectangle(sh.Right' sh.Y + sh.Height/2-5' 10' 10);    					if(r.Contains(p))  					{  						if(sh.expanded)  							sh.Collapse(true);  						else  							sh.Expand();  						DrawTree();  					}  				}  				if(Shapes[k].Hit(p))  				{  					//shapes[k].ShapeColor = Color.WhiteSmoke;  					if(selectedEntity!=null)   						selectedEntity.IsSelected=false;  					selectedEntity = Shapes[k];  					selectedEntity.IsSelected = true;  					sh = selectedEntity as ShapeBase;	  					#region CONTROL  //					if(Control.ModifierKeys==Keys.Control && !sh.IsRoot)  //					{  //						tracking = true;  //						//remove from parent							  //						sh.parentNode.childNodes.Remove(sh);  //						Connections.Remove(sh' sh.parentNode);						  //						//...but keep the reference in case the user didn't find a new location  //						memChild = sh;  //						memParent = sh.parentNode;  //						//now remove the reference  //						sh.parentNode = null;  //					}  					#endregion  					//set the point for the next round  					refp=p;    					#region Double-click  					if(e.Button==MouseButtons.Left && e.Clicks==2)  					{							  						if(sh.expanded)  							sh.Collapse(true);  						else  							sh.Expand();  						DrawTree();  					}  					#endregion    					#region ALT  //					if(Control.ModifierKeys==Keys.Alt)  //					{  //						sh.AddChild("New");	  //						DrawTree();  //					}        					#endregion  					if(OnShowProps!=null)  						OnShowProps(Shapes[k]);  						  					return;  				}  			}
Magic Number,Netron.Lithium,LithiumControl,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,OnMouseDown,The following statement contains a magic number: for(int k=0; k<Shapes.Count; k++)  			{  				sh = Shapes[k];  				if(sh.childNodes.Count>0)//has a [+/-]  				{  					if(layoutDirection==TreeDirection.Vertical)  						r = new Rectangle(sh.Left + sh.Width/2 - 5' sh.Bottom' 10' 10);  					else  						r = new Rectangle(sh.Right' sh.Y + sh.Height/2-5' 10' 10);    					if(r.Contains(p))  					{  						if(sh.expanded)  							sh.Collapse(true);  						else  							sh.Expand();  						DrawTree();  					}  				}  				if(Shapes[k].Hit(p))  				{  					//shapes[k].ShapeColor = Color.WhiteSmoke;  					if(selectedEntity!=null)   						selectedEntity.IsSelected=false;  					selectedEntity = Shapes[k];  					selectedEntity.IsSelected = true;  					sh = selectedEntity as ShapeBase;	  					#region CONTROL  //					if(Control.ModifierKeys==Keys.Control && !sh.IsRoot)  //					{  //						tracking = true;  //						//remove from parent							  //						sh.parentNode.childNodes.Remove(sh);  //						Connections.Remove(sh' sh.parentNode);						  //						//...but keep the reference in case the user didn't find a new location  //						memChild = sh;  //						memParent = sh.parentNode;  //						//now remove the reference  //						sh.parentNode = null;  //					}  					#endregion  					//set the point for the next round  					refp=p;    					#region Double-click  					if(e.Button==MouseButtons.Left && e.Clicks==2)  					{							  						if(sh.expanded)  							sh.Collapse(true);  						else  							sh.Expand();  						DrawTree();  					}  					#endregion    					#region ALT  //					if(Control.ModifierKeys==Keys.Alt)  //					{  //						sh.AddChild("New");	  //						DrawTree();  //					}        					#endregion  					if(OnShowProps!=null)  						OnShowProps(Shapes[k]);  						  					return;  				}  			}
Magic Number,Netron.Lithium,LithiumControl,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,OnMouseDown,The following statement contains a magic number: for(int k=0; k<Shapes.Count; k++)  			{  				sh = Shapes[k];  				if(sh.childNodes.Count>0)//has a [+/-]  				{  					if(layoutDirection==TreeDirection.Vertical)  						r = new Rectangle(sh.Left + sh.Width/2 - 5' sh.Bottom' 10' 10);  					else  						r = new Rectangle(sh.Right' sh.Y + sh.Height/2-5' 10' 10);    					if(r.Contains(p))  					{  						if(sh.expanded)  							sh.Collapse(true);  						else  							sh.Expand();  						DrawTree();  					}  				}  				if(Shapes[k].Hit(p))  				{  					//shapes[k].ShapeColor = Color.WhiteSmoke;  					if(selectedEntity!=null)   						selectedEntity.IsSelected=false;  					selectedEntity = Shapes[k];  					selectedEntity.IsSelected = true;  					sh = selectedEntity as ShapeBase;	  					#region CONTROL  //					if(Control.ModifierKeys==Keys.Control && !sh.IsRoot)  //					{  //						tracking = true;  //						//remove from parent							  //						sh.parentNode.childNodes.Remove(sh);  //						Connections.Remove(sh' sh.parentNode);						  //						//...but keep the reference in case the user didn't find a new location  //						memChild = sh;  //						memParent = sh.parentNode;  //						//now remove the reference  //						sh.parentNode = null;  //					}  					#endregion  					//set the point for the next round  					refp=p;    					#region Double-click  					if(e.Button==MouseButtons.Left && e.Clicks==2)  					{							  						if(sh.expanded)  							sh.Collapse(true);  						else  							sh.Expand();  						DrawTree();  					}  					#endregion    					#region ALT  //					if(Control.ModifierKeys==Keys.Alt)  //					{  //						sh.AddChild("New");	  //						DrawTree();  //					}        					#endregion  					if(OnShowProps!=null)  						OnShowProps(Shapes[k]);  						  					return;  				}  			}
Magic Number,Netron.Lithium,LithiumControl,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,OnMouseDown,The following statement contains a magic number: for(int k=0; k<Shapes.Count; k++)  			{  				sh = Shapes[k];  				if(sh.childNodes.Count>0)//has a [+/-]  				{  					if(layoutDirection==TreeDirection.Vertical)  						r = new Rectangle(sh.Left + sh.Width/2 - 5' sh.Bottom' 10' 10);  					else  						r = new Rectangle(sh.Right' sh.Y + sh.Height/2-5' 10' 10);    					if(r.Contains(p))  					{  						if(sh.expanded)  							sh.Collapse(true);  						else  							sh.Expand();  						DrawTree();  					}  				}  				if(Shapes[k].Hit(p))  				{  					//shapes[k].ShapeColor = Color.WhiteSmoke;  					if(selectedEntity!=null)   						selectedEntity.IsSelected=false;  					selectedEntity = Shapes[k];  					selectedEntity.IsSelected = true;  					sh = selectedEntity as ShapeBase;	  					#region CONTROL  //					if(Control.ModifierKeys==Keys.Control && !sh.IsRoot)  //					{  //						tracking = true;  //						//remove from parent							  //						sh.parentNode.childNodes.Remove(sh);  //						Connections.Remove(sh' sh.parentNode);						  //						//...but keep the reference in case the user didn't find a new location  //						memChild = sh;  //						memParent = sh.parentNode;  //						//now remove the reference  //						sh.parentNode = null;  //					}  					#endregion  					//set the point for the next round  					refp=p;    					#region Double-click  					if(e.Button==MouseButtons.Left && e.Clicks==2)  					{							  						if(sh.expanded)  							sh.Collapse(true);  						else  							sh.Expand();  						DrawTree();  					}  					#endregion    					#region ALT  //					if(Control.ModifierKeys==Keys.Alt)  //					{  //						sh.AddChild("New");	  //						DrawTree();  //					}        					#endregion  					if(OnShowProps!=null)  						OnShowProps(Shapes[k]);  						  					return;  				}  			}
Magic Number,Netron.Lithium,LithiumControl,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,OnMouseDown,The following statement contains a magic number: for(int k=0; k<Shapes.Count; k++)  			{  				sh = Shapes[k];  				if(sh.childNodes.Count>0)//has a [+/-]  				{  					if(layoutDirection==TreeDirection.Vertical)  						r = new Rectangle(sh.Left + sh.Width/2 - 5' sh.Bottom' 10' 10);  					else  						r = new Rectangle(sh.Right' sh.Y + sh.Height/2-5' 10' 10);    					if(r.Contains(p))  					{  						if(sh.expanded)  							sh.Collapse(true);  						else  							sh.Expand();  						DrawTree();  					}  				}  				if(Shapes[k].Hit(p))  				{  					//shapes[k].ShapeColor = Color.WhiteSmoke;  					if(selectedEntity!=null)   						selectedEntity.IsSelected=false;  					selectedEntity = Shapes[k];  					selectedEntity.IsSelected = true;  					sh = selectedEntity as ShapeBase;	  					#region CONTROL  //					if(Control.ModifierKeys==Keys.Control && !sh.IsRoot)  //					{  //						tracking = true;  //						//remove from parent							  //						sh.parentNode.childNodes.Remove(sh);  //						Connections.Remove(sh' sh.parentNode);						  //						//...but keep the reference in case the user didn't find a new location  //						memChild = sh;  //						memParent = sh.parentNode;  //						//now remove the reference  //						sh.parentNode = null;  //					}  					#endregion  					//set the point for the next round  					refp=p;    					#region Double-click  					if(e.Button==MouseButtons.Left && e.Clicks==2)  					{							  						if(sh.expanded)  							sh.Collapse(true);  						else  							sh.Expand();  						DrawTree();  					}  					#endregion    					#region ALT  //					if(Control.ModifierKeys==Keys.Alt)  //					{  //						sh.AddChild("New");	  //						DrawTree();  //					}        					#endregion  					if(OnShowProps!=null)  						OnShowProps(Shapes[k]);  						  					return;  				}  			}
Magic Number,Netron.Lithium,LithiumControl,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,OnMouseDown,The following statement contains a magic number: for(int k=0; k<Shapes.Count; k++)  			{  				sh = Shapes[k];  				if(sh.childNodes.Count>0)//has a [+/-]  				{  					if(layoutDirection==TreeDirection.Vertical)  						r = new Rectangle(sh.Left + sh.Width/2 - 5' sh.Bottom' 10' 10);  					else  						r = new Rectangle(sh.Right' sh.Y + sh.Height/2-5' 10' 10);    					if(r.Contains(p))  					{  						if(sh.expanded)  							sh.Collapse(true);  						else  							sh.Expand();  						DrawTree();  					}  				}  				if(Shapes[k].Hit(p))  				{  					//shapes[k].ShapeColor = Color.WhiteSmoke;  					if(selectedEntity!=null)   						selectedEntity.IsSelected=false;  					selectedEntity = Shapes[k];  					selectedEntity.IsSelected = true;  					sh = selectedEntity as ShapeBase;	  					#region CONTROL  //					if(Control.ModifierKeys==Keys.Control && !sh.IsRoot)  //					{  //						tracking = true;  //						//remove from parent							  //						sh.parentNode.childNodes.Remove(sh);  //						Connections.Remove(sh' sh.parentNode);						  //						//...but keep the reference in case the user didn't find a new location  //						memChild = sh;  //						memParent = sh.parentNode;  //						//now remove the reference  //						sh.parentNode = null;  //					}  					#endregion  					//set the point for the next round  					refp=p;    					#region Double-click  					if(e.Button==MouseButtons.Left && e.Clicks==2)  					{							  						if(sh.expanded)  							sh.Collapse(true);  						else  							sh.Expand();  						DrawTree();  					}  					#endregion    					#region ALT  //					if(Control.ModifierKeys==Keys.Alt)  //					{  //						sh.AddChild("New");	  //						DrawTree();  //					}        					#endregion  					if(OnShowProps!=null)  						OnShowProps(Shapes[k]);  						  					return;  				}  			}
Magic Number,Netron.Lithium,LithiumControl,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,SeekNewParent,The following statement contains a magic number: for(int k=0;k<Shapes.Count; k++)  			{  				other = Shapes[k];  				if(other!=shape && other.visible && other.parentNode!=shape && !other.pickup)  				{  					dist = Math.Sqrt((other.X-shape.X)*(other.X-shape.X)+(other.Y-shape.Y)*(other.Y-shape.Y));  					if(dist<best && dist< 120)  						chosen = k;				  				}  			}
Magic Number,Netron.Lithium,LithiumControl,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,Environment,The following statement contains a magic number: return Math.Sqrt((shape1.X-shape2.X)*(shape1.X-shape2.X)+(shape1.Y-shape2.Y)*(shape1.Y-shape2.Y))<100;
Magic Number,Netron.Lithium,LithiumControl,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,DrawTree,The following statement contains a magic number: try  			{  				//start the recursion  				//the layout will move the root but it's reset to its original position  				switch(layoutDirection)  				{  					case TreeDirection.Vertical:  						  						p = new Point(graphAbstract.Root.X' graphAbstract.Root.Y);  						VerticalDrawTree(graphAbstract.Root'false'marginLeft'this.graphAbstract.Root.Y);						  						p = new Point(-graphAbstract.Root.X+p.X' -graphAbstract.Root.Y+ p.Y);						  						MoveDiagram(p);						  						break;  					case TreeDirection.Horizontal:  						p = new Point(graphAbstract.Root.X' graphAbstract.Root.Y);  						HorizontalDrawTree(graphAbstract.Root'false'marginLeft'10);  						p = new Point(-graphAbstract.Root.X+p.X' -graphAbstract.Root.Y+ p.Y);		  						MoveDiagram(p);	  						break;  				}    				int maxY = 0;  				foreach (ShapeBase shape in Shapes)  				{  					if (shape.ShapeColor == Color.Ivory)  					{  						if (shape.Visible)  						{  							if (shape.Y > maxY)  							{  								maxY = shape.Y;  							}  						}  					}  				}    				foreach (ShapeBase shape in Shapes)  				{  					if (shape.ShapeColor == Color.Ivory)  					{  						if (shape.Visible)  						{  							shape.Move(new Point(0' maxY - shape.Y));  						}  					}  				}    				CalculateScrollBars();  				  				Invalidate();  			}  			catch(Exception exc)  			{  				Trace.WriteLine(exc.Message);				  			}
Magic Number,Netron.Lithium,LithiumControl,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,CalculateScrollBars,The following statement contains a magic number: MoveDiagram(new Point(50 - minPoint.X' 50 - minPoint.Y));
Magic Number,Netron.Lithium,LithiumControl,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,CalculateScrollBars,The following statement contains a magic number: MoveDiagram(new Point(50 - minPoint.X' 50 - minPoint.Y));
Magic Number,Netron.Lithium,LithiumControl,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,CalculateScrollBars,The following statement contains a magic number: maxSize.Width = maxSize.Width - minPoint.X + 100;
Magic Number,Netron.Lithium,LithiumControl,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,CalculateScrollBars,The following statement contains a magic number: maxSize.Height = maxSize.Height - minPoint.Y + 100;
Magic Number,Netron.Lithium,LithiumControl,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,VerticalDrawTree,The following statement contains a magic number: for(int i =0; i<containerNode.childNodes.Count; i++)  			{  				//determine the width of the label  				if(i==0)			  					isFirst = true;				  				else 				  					isFirst = false;  				if(containerNode.childNodes[i].visible)  				{  					if((branchHeight - containerNode.Height) < 30) //if too close to the child' shift it with 40 units  						verticalDelta = containerNode.Height + 40;  					returned = VerticalDrawTree(containerNode.childNodes[i]' isFirst' shiftLeft + childrenWidth' shiftTop + verticalDelta );									  					childrenWidth += returned;  					  				}		    			}
Magic Number,Netron.Lithium,LithiumControl,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,VerticalDrawTree,The following statement contains a magic number: for(int i =0; i<containerNode.childNodes.Count; i++)  			{  				//determine the width of the label  				if(i==0)			  					isFirst = true;				  				else 				  					isFirst = false;  				if(containerNode.childNodes[i].visible)  				{  					if((branchHeight - containerNode.Height) < 30) //if too close to the child' shift it with 40 units  						verticalDelta = containerNode.Height + 40;  					returned = VerticalDrawTree(containerNode.childNodes[i]' isFirst' shiftLeft + childrenWidth' shiftTop + verticalDelta );									  					childrenWidth += returned;  					  				}		    			}
Magic Number,Netron.Lithium,LithiumControl,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,VerticalDrawTree,The following statement contains a magic number: if(childrenWidth>0 && containerNode.expanded)  				childrenWidth=Math.Max(Convert.ToInt32(childrenWidth + (containerNode.Width-childrenWidth)/2)' childrenWidth);
Magic Number,Netron.Lithium,LithiumControl,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,VerticalDrawTree,The following statement contains a magic number: if(containerNode.childNodes.Count>0 && containerNode.expanded)  			{  				if(containerNode.childNodes.Count==1)  				{    					thisX = Convert.ToInt32(containerNode.childNodes[0].X+containerNode.childNodes[0].Width/2 - containerNode.Width/2);  				}  				else  				{  					float firstChild = containerNode.childNodes[0].Left+ containerNode.childNodes[0].Width/2;  					float lastChild = containerNode.childNodes[containerNode.childNodes.Count-1].Left + containerNode.childNodes[containerNode.childNodes.Count-1].Width/2;  					//the following max in case the containerNode is larger than the childrenWidth  					thisX = Convert.ToInt32(Math.Max(firstChild + (lastChild -firstChild - containerNode.Width)/2' firstChild));  				}  			}  			else  			{  				thisX = shiftLeft;		  				  			}
Magic Number,Netron.Lithium,LithiumControl,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,VerticalDrawTree,The following statement contains a magic number: if(containerNode.childNodes.Count>0 && containerNode.expanded)  			{  				if(containerNode.childNodes.Count==1)  				{    					thisX = Convert.ToInt32(containerNode.childNodes[0].X+containerNode.childNodes[0].Width/2 - containerNode.Width/2);  				}  				else  				{  					float firstChild = containerNode.childNodes[0].Left+ containerNode.childNodes[0].Width/2;  					float lastChild = containerNode.childNodes[containerNode.childNodes.Count-1].Left + containerNode.childNodes[containerNode.childNodes.Count-1].Width/2;  					//the following max in case the containerNode is larger than the childrenWidth  					thisX = Convert.ToInt32(Math.Max(firstChild + (lastChild -firstChild - containerNode.Width)/2' firstChild));  				}  			}  			else  			{  				thisX = shiftLeft;		  				  			}
Magic Number,Netron.Lithium,LithiumControl,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,VerticalDrawTree,The following statement contains a magic number: if(containerNode.childNodes.Count>0 && containerNode.expanded)  			{  				if(containerNode.childNodes.Count==1)  				{    					thisX = Convert.ToInt32(containerNode.childNodes[0].X+containerNode.childNodes[0].Width/2 - containerNode.Width/2);  				}  				else  				{  					float firstChild = containerNode.childNodes[0].Left+ containerNode.childNodes[0].Width/2;  					float lastChild = containerNode.childNodes[containerNode.childNodes.Count-1].Left + containerNode.childNodes[containerNode.childNodes.Count-1].Width/2;  					//the following max in case the containerNode is larger than the childrenWidth  					thisX = Convert.ToInt32(Math.Max(firstChild + (lastChild -firstChild - containerNode.Width)/2' firstChild));  				}  			}  			else  			{  				thisX = shiftLeft;		  				  			}
Magic Number,Netron.Lithium,LithiumControl,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,VerticalDrawTree,The following statement contains a magic number: if(containerNode.childNodes.Count>0 && containerNode.expanded)  			{  				if(containerNode.childNodes.Count==1)  				{    					thisX = Convert.ToInt32(containerNode.childNodes[0].X+containerNode.childNodes[0].Width/2 - containerNode.Width/2);  				}  				else  				{  					float firstChild = containerNode.childNodes[0].Left+ containerNode.childNodes[0].Width/2;  					float lastChild = containerNode.childNodes[containerNode.childNodes.Count-1].Left + containerNode.childNodes[containerNode.childNodes.Count-1].Width/2;  					//the following max in case the containerNode is larger than the childrenWidth  					thisX = Convert.ToInt32(Math.Max(firstChild + (lastChild -firstChild - containerNode.Width)/2' firstChild));  				}  			}  			else  			{  				thisX = shiftLeft;		  				  			}
Magic Number,Netron.Lithium,LithiumControl,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,VerticalDrawTree,The following statement contains a magic number: if(containerNode.childNodes.Count>0 && containerNode.expanded)  			{  				if(containerNode.childNodes.Count==1)  				{    					thisX = Convert.ToInt32(containerNode.childNodes[0].X+containerNode.childNodes[0].Width/2 - containerNode.Width/2);  				}  				else  				{  					float firstChild = containerNode.childNodes[0].Left+ containerNode.childNodes[0].Width/2;  					float lastChild = containerNode.childNodes[containerNode.childNodes.Count-1].Left + containerNode.childNodes[containerNode.childNodes.Count-1].Width/2;  					//the following max in case the containerNode is larger than the childrenWidth  					thisX = Convert.ToInt32(Math.Max(firstChild + (lastChild -firstChild - containerNode.Width)/2' firstChild));  				}  			}  			else  			{  				thisX = shiftLeft;		  				  			}
Magic Number,Netron.Lithium,LithiumControl,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,HorizontalDrawTree,The following statement contains a magic number: for(int i =0; i<containerNode.childNodes.Count; i++)  			{  				//determine the width of the label  				if(i==0)			  					isFirst = true;				  				else 				  					isFirst = false;  				if(containerNode.childNodes[i].visible)  				{  					if((branchHeight - containerNode.Width) < 30) //if too close to the child' shift it with 40 units  						horizontalDelta = containerNode.Width + 40;  					returned = HorizontalDrawTree(containerNode.childNodes[i]' isFirst' shiftLeft + horizontalDelta ' shiftTop + childrenHeight );					  					childrenHeight += returned;  				}  				    			}
Magic Number,Netron.Lithium,LithiumControl,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,HorizontalDrawTree,The following statement contains a magic number: for(int i =0; i<containerNode.childNodes.Count; i++)  			{  				//determine the width of the label  				if(i==0)			  					isFirst = true;				  				else 				  					isFirst = false;  				if(containerNode.childNodes[i].visible)  				{  					if((branchHeight - containerNode.Width) < 30) //if too close to the child' shift it with 40 units  						horizontalDelta = containerNode.Width + 40;  					returned = HorizontalDrawTree(containerNode.childNodes[i]' isFirst' shiftLeft + horizontalDelta ' shiftTop + childrenHeight );					  					childrenHeight += returned;  				}  				    			}
Magic Number,Netron.Lithium,LithiumControl,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,HorizontalDrawTree,The following statement contains a magic number: if(containerNode.childNodes.Count>0 && containerNode.expanded)  			{  				  					int firstChild = containerNode.childNodes[0].Y;  					int lastChild = containerNode.childNodes[containerNode.childNodes.Count-1].Y;  					thisY = Convert.ToInt32(firstChild + (lastChild - firstChild)/2);  				  			}  			else  			{  				thisY = Convert.ToInt32(shiftTop);		  				  			}
Magic Number,Netron.Lithium,LithiumControl,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,Measure,The following statement contains a magic number: return Size.Round(g.MeasureString(text'Font)).Width +37;
Magic Number,Netron.Lithium,LithiumControl,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,Fit,The following statement contains a magic number: shape.Width =s.Width +20;
Magic Number,Netron.Lithium,LithiumControl,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,Fit,The following statement contains a magic number: shape.Height = s.Height+8;
Missing Default,Netron.Lithium,Connection,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Paint,The following switch statement is missing a default case: switch(site.ConnectionType)  				{  					case ConnectionType.Default:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top);   							p2 = new PointF(to.Left + to.Width/2' to.Bottom+5);  							g.DrawLine(pen'p1'p2);  							break;  						case TreeDirection.Horizontal:  							p1 = new PointF(from.Left' from.Top +  from.Height/2);   							p2 = new PointF(to.Right +4' to.Top + to.Height/2);  							g.DrawLine(pen'p1'p2);  							break;  					}  						break;  					case ConnectionType.Traditional:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p2 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  					}  						break;  					  					case ConnectionType.Bezier:  					switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left+from.Width/2'from.Top);  							p2 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p3 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							p4 = new PointF(to.Left+to.Width/2'to.Bottom);  							g.DrawBezier(pen' p1' p2' p3' p4);  							  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right' to.Top + to.Height/2); 							  							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							p3 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p4 = new PointF(from.Left'from.Top + from.Height/2);  							g.DrawBezier(pen' p1' p2' p3' p4);  							break;  					}  						break;  				}
Missing Default,Netron.Lithium,Connection,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Paint,The following switch statement is missing a default case: switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top);   							p2 = new PointF(to.Left + to.Width/2' to.Bottom+5);  							g.DrawLine(pen'p1'p2);  							break;  						case TreeDirection.Horizontal:  							p1 = new PointF(from.Left' from.Top +  from.Height/2);   							p2 = new PointF(to.Right +4' to.Top + to.Height/2);  							g.DrawLine(pen'p1'p2);  							break;  					}
Missing Default,Netron.Lithium,Connection,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Paint,The following switch statement is missing a default case: switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p2 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							g.DrawLine(pen' Start'p1);  							g.DrawLine(pen' p1' p2);  							g.DrawLine(pen' End' p2);  							break;  					}
Missing Default,Netron.Lithium,Connection,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Paint,The following switch statement is missing a default case: switch(site.LayoutDirection)  					{  						case TreeDirection.Vertical:  							p1 = new PointF(from.Left+from.Width/2'from.Top);  							p2 = new PointF(from.Left + from.Width/2' from.Top - (from.Top - to.Bottom)/2);   							p3 = new PointF(to.Left + to.Width/2' from.Top - (from.Top - to.Bottom)/2);  							p4 = new PointF(to.Left+to.Width/2'to.Bottom);  							g.DrawBezier(pen' p1' p2' p3' p4);  							  							break;  						case TreeDirection.Horizontal:    							p1 = new PointF(to.Right' to.Top + to.Height/2); 							  							p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							p3 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   							p4 = new PointF(from.Left'from.Top + from.Height/2);  							g.DrawBezier(pen' p1' p2' p3' p4);  							break;  					}
Missing Default,Netron.Lithium,Connection,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Hit,The following switch statement is missing a default case: switch(site.ConnectionType)  			{  				case ConnectionType.Default:  					#region The default Hit method  					  					float o'u;  					p1 = start; p2 = end; 	 					// p1 must be the leftmost point. 					if (p1.X > p2.X) { s = p2; p2 = p1; p1 = s; }  					//this is specifically necessary when the layout works horizontally 					//the method beneth will not return true as should be in this case 					if(p1.Y==p2.Y) 					{ 						p1.Y+=-3; 						return new RectangleF(p1'new SizeF(p2.X-p1.X'6)).Contains(p); 					} 					r1 = new RectangleF(p1.X' p1.Y' 0' 0); 					r2 = new RectangleF(p2.X' p2.Y' 0' 0); 					r1.Inflate(3' 3); 					r2.Inflate(3' 3); 					//this is like a topological neighborhood 					//the connection is shifted left and right 					//and the point under consideration has to be in between.						 					if (RectangleF.Union(r1' r2).Contains(p)) 					{ 				 						if (p1.Y < p2.Y) //SWNE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							return ((p.X > o) && (p.X < u)); 						} 						else //NWSE 						{ 							o = r1.Left + (((r2.Left - r1.Left) * (p.Y - r1.Top)) / (r2.Top - r1.Top)); 							u = r1.Right + (((r2.Right - r1.Right) * (p.Y - r1.Bottom)) / (r2.Bottom - r1.Bottom)); 							return ((p.X > o) && (p.X < u)); 						} 					}  					#endregion  					break;  				case ConnectionType.Traditional:  					#region The rectangular Hit method  						switch(site.LayoutDirection)  						{  							case TreeDirection.Vertical:  								p1 = new PointF(from.Left + from.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5); //shift 5 to contain the connection  								p2 = new PointF(to.Left + to.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5);  								p3 = new Point(to.Left+to.Width/2-5'to.Bottom-5);    								r1 = new RectangleF(p1' new SizeF(10'(from.Top - to.Bottom)/2+5));   								if(p1.X<p2.X)  									r2 = new RectangleF(p1'new SizeF(p2.X-p1.X'10));  								else  									r2 = new RectangleF(p2'new SizeF(p1.X-p2.X'10));  								r3 = new RectangleF(p3' new SizeF(10' (from.Top - to.Bottom)/2+5));  								return r1.Contains(p.X'p.Y) || r2.Contains(p.X'p.Y) || r3.Contains(p.X'p.Y) ;  								  							case TreeDirection.Horizontal:    								p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   								p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							  								break;  						}  					#endregion  					break;  			}
Missing Default,Netron.Lithium,Connection,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Connection.cs,Hit,The following switch statement is missing a default case: switch(site.LayoutDirection)  						{  							case TreeDirection.Vertical:  								p1 = new PointF(from.Left + from.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5); //shift 5 to contain the connection  								p2 = new PointF(to.Left + to.Width/2-5' from.Top - (from.Top - to.Bottom)/2-5);  								p3 = new Point(to.Left+to.Width/2-5'to.Bottom-5);    								r1 = new RectangleF(p1' new SizeF(10'(from.Top - to.Bottom)/2+5));   								if(p1.X<p2.X)  									r2 = new RectangleF(p1'new SizeF(p2.X-p1.X'10));  								else  									r2 = new RectangleF(p2'new SizeF(p1.X-p2.X'10));  								r3 = new RectangleF(p3' new SizeF(10' (from.Top - to.Bottom)/2+5));  								return r1.Contains(p.X'p.Y) || r2.Contains(p.X'p.Y) || r3.Contains(p.X'p.Y) ;  								  							case TreeDirection.Horizontal:    								p1 = new PointF(to.Right + (from.Left - to.Right)/2' from.Top + from.Height/2);   								p2 = new PointF(to.Right + (from.Left - to.Right)/2' to.Top + to.Height/2);  							  								break;  						}
Missing Default,Netron.Lithium,SimpleRectangle,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\Shapes\SimpleRectangle.cs,Paint,The following switch statement is missing a default case: switch(site.LayoutDirection)  				{  				  					case TreeDirection.Vertical:  						toggleNode = new Rectangle(Left + this.Width/2 - 5' Bottom' 10' 10);  						break;  					case TreeDirection.Horizontal:  						toggleNode = new Rectangle(Right ' Top +Height/2-5 ' 10' 10);  						break;  				}
Missing Default,Netron.Lithium,LithiumControl,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,AddShape,The following switch statement is missing a default case: switch(type)  			{  				case ShapeTypes.Rectangular:  					shape = new SimpleRectangle(this);  					break;  				case ShapeTypes.Oval:  					shape = new OvalShape(this);  					break;  				case ShapeTypes.TextLabel:  					shape = new TextLabel(this);  					shape.Location = location;  					shape.ShapeColor = Color.Transparent;  					shape.Text = "A text label (change the text in the property grid)";  					shape.Width = 350;  					shape.Height = 30;  					Shapes.Add(shape);  					return shape;      			}
Missing Default,Netron.Lithium,LithiumControl,C:\repos\pburrows_SharperNLP\SharpNLP-Original\SharpNLP\OpenNLP\Lithium\UI\LithiumControl.cs,DrawTree,The following switch statement is missing a default case: switch(layoutDirection)  				{  					case TreeDirection.Vertical:  						  						p = new Point(graphAbstract.Root.X' graphAbstract.Root.Y);  						VerticalDrawTree(graphAbstract.Root'false'marginLeft'this.graphAbstract.Root.Y);						  						p = new Point(-graphAbstract.Root.X+p.X' -graphAbstract.Root.Y+ p.Y);						  						MoveDiagram(p);						  						break;  					case TreeDirection.Horizontal:  						p = new Point(graphAbstract.Root.X' graphAbstract.Root.Y);  						HorizontalDrawTree(graphAbstract.Root'false'marginLeft'10);  						p = new Point(-graphAbstract.Root.X+p.X' -graphAbstract.Root.Y+ p.Y);		  						MoveDiagram(p);	  						break;  				}
