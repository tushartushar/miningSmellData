Implementation smell,Namespace,Class,File,Method,Description
Complex Method,sharpcalculator.Math,ReversePolishNotation,C:\repos\nissehutt_sharp-calculator\sharp-calculator\Math\ReversePolishNotation.cs,Solve,Cyclomatic complexity of the method is 69
Long Statement,SharpCalculator.Math,BigDecimal,C:\repos\nissehutt_sharp-calculator\sharp-calculator\Math\BigDecimal.cs,Add,The length of the statement  "	return left.Exponent > right.Exponent ? new BigDecimal (AlignExponent (left' right) + right.Mantissa' right.Exponent) : new BigDecimal (AlignExponent (right' left) + left.Mantissa' left.Exponent); " is 196.
Magic Number,SharpCalculator.Math,BigDecimal,C:\repos\nissehutt_sharp-calculator\sharp-calculator\Math\BigDecimal.cs,Normalize,The following statement contains a magic number: if (Mantissa.IsZero) {  	Exponent = 0;  }  else {  	BigInteger remainder = 0;  	while (remainder == 0) {  		var shortened = BigInteger.DivRem (Mantissa' 10' out remainder);  		if (remainder == 0) {  			Mantissa = shortened;  			Exponent++;  		}  	}  }  
Magic Number,SharpCalculator.Math,BigDecimal,C:\repos\nissehutt_sharp-calculator\sharp-calculator\Math\BigDecimal.cs,Normalize,The following statement contains a magic number: while (remainder == 0) {  	var shortened = BigInteger.DivRem (Mantissa' 10' out remainder);  	if (remainder == 0) {  		Mantissa = shortened;  		Exponent++;  	}  }  
Magic Number,SharpCalculator.Math,BigDecimal,C:\repos\nissehutt_sharp-calculator\sharp-calculator\Math\BigDecimal.cs,Truncate,The following statement contains a magic number: while (NumberOfDigits (shortened.Mantissa) > precision) {  	shortened.Mantissa /= 10;  	shortened.Exponent++;  }  
Magic Number,SharpCalculator.Math,BigDecimal,C:\repos\nissehutt_sharp-calculator\sharp-calculator\Math\BigDecimal.cs,Truncate,The following statement contains a magic number: shortened.Mantissa /= 10;  
Magic Number,SharpCalculator.Math,BigDecimal,C:\repos\nissehutt_sharp-calculator\sharp-calculator\Math\BigDecimal.cs,AlignExponent,The following statement contains a magic number: return value.Mantissa * BigInteger.Pow (10' value.Exponent - reference.Exponent);  
Magic Number,SharpCalculator.Math,BigDecimal,C:\repos\nissehutt_sharp-calculator\sharp-calculator\Math\BigDecimal.cs,Exp,The following statement contains a magic number: while (System.Math.Abs (exponent) > 100) {  	var diff = exponent > 0 ? 100 : -100;  	tmp *= System.Math.Exp (diff);  	exponent -= diff;  }  
Magic Number,SharpCalculator.Math,BigDecimal,C:\repos\nissehutt_sharp-calculator\sharp-calculator\Math\BigDecimal.cs,Exp,The following statement contains a magic number: while (System.Math.Abs (exponent) > 100) {  	var diff = exponent > 0 ? 100 : -100;  	tmp *= System.Math.Exp (diff);  	exponent -= diff;  }  
Magic Number,SharpCalculator.Math,BigDecimal,C:\repos\nissehutt_sharp-calculator\sharp-calculator\Math\BigDecimal.cs,Exp,The following statement contains a magic number: while (System.Math.Abs (exponent) > 100) {  	var diff = exponent > 0 ? 100 : -100;  	tmp *= System.Math.Exp (diff);  	exponent -= diff;  }  
Magic Number,SharpCalculator.Math,BigDecimal,C:\repos\nissehutt_sharp-calculator\sharp-calculator\Math\BigDecimal.cs,Pow,The following statement contains a magic number: while (System.Math.Abs (exponent) > 100) {  	var diff = exponent > 0 ? 100 : -100;  	tmp *= System.Math.Pow ((double)basis' diff);  	exponent -= diff;  }  
Magic Number,SharpCalculator.Math,BigDecimal,C:\repos\nissehutt_sharp-calculator\sharp-calculator\Math\BigDecimal.cs,Pow,The following statement contains a magic number: while (System.Math.Abs (exponent) > 100) {  	var diff = exponent > 0 ? 100 : -100;  	tmp *= System.Math.Pow ((double)basis' diff);  	exponent -= diff;  }  
Magic Number,SharpCalculator.Math,BigDecimal,C:\repos\nissehutt_sharp-calculator\sharp-calculator\Math\BigDecimal.cs,Pow,The following statement contains a magic number: while (System.Math.Abs (exponent) > 100) {  	var diff = exponent > 0 ? 100 : -100;  	tmp *= System.Math.Pow ((double)basis' diff);  	exponent -= diff;  }  
Magic Number,SharpCalculator.Math,BigDecimal,C:\repos\nissehutt_sharp-calculator\sharp-calculator\Math\BigDecimal.cs,GetHashCode,The following statement contains a magic number: unchecked {  	return (Mantissa.GetHashCode () * 397) ^ Exponent;  }  
Magic Number,SharpCalculator.Math,BigDecimal,C:\repos\nissehutt_sharp-calculator\sharp-calculator\Math\BigDecimal.cs,GetHashCode,The following statement contains a magic number: return (Mantissa.GetHashCode () * 397) ^ Exponent;  
Magic Number,sharpcalculator.Math,ReversePolishNotation,C:\repos\nissehutt_sharp-calculator\sharp-calculator\Math\ReversePolishNotation.cs,Solve,The following statement contains a magic number: while (queue.Any ()) {  	var token = queue.Dequeue ();  	if (token.IsValue) {  		stack.Push (token);  	}  	else {  		Token a;  		Token b;  		switch (token.InnerText) {  		case "+":  			if (stack.Count < 2)  				throw new ArgumentException ("Invalid RPN.");  			a = stack.Pop ();  			b = stack.Pop ();  			stack.Push (new Token (a.InnerValue + b.InnerValue));  			break;  		case "-":  			if (stack.Count == 1) {  				a = stack.Pop ();  				stack.Push (new Token (-a.InnerValue));  				break;  			}  			if (stack.Count != 2)  				throw new ArgumentException ("Invalid RPN.");  			a = stack.Pop ();  			b = stack.Pop ();  			stack.Push (new Token (a.InnerValue - b.InnerValue));  			break;  		case "*":  			if (stack.Count < 2)  				throw new ArgumentException ("Invalid RPN.");  			a = stack.Pop ();  			b = stack.Pop ();  			stack.Push (new Token (a.InnerValue * b.InnerValue));  			break;  		case "/":  			if (stack.Count < 2)  				throw new ArgumentException ("Invalid RPN.");  			a = stack.Pop ();  			b = stack.Pop ();  			stack.Push (new Token (a.InnerValue / b.InnerValue));  			break;  		case "cos":  			if (stack.Count < 1)  				throw new ArgumentException ("Invalid RPN.");  			a = stack.Pop ();  			stack.Push (new Token (System.Math.Cos ((double)a.InnerValue)));  			break;  		case "sin":  			if (stack.Count < 1)  				throw new ArgumentException ("Invalid RPN.");  			a = stack.Pop ();  			stack.Push (new Token (System.Math.Sin ((double)a.InnerValue)));  			break;  		case "tan":  			if (stack.Count < 1)  				throw new ArgumentException ("Invalid RPN.");  			a = stack.Pop ();  			stack.Push (new Token (System.Math.Tan ((double)a.InnerValue)));  			break;  		case "pow":  			if (stack.Count < 2)  				throw new ArgumentException ("Invalid RPN.");  			a = stack.Pop ();  			b = stack.Pop ();  			stack.Push (new Token (BigDecimal.Pow (a.InnerValue' (double)b.InnerValue)));  			break;  		case "sqrt":  			if (stack.Count < 1)  				throw new ArgumentException ("Invalid RPN.");  			a = stack.Pop ();  			stack.Push (new Token (System.Math.Sqrt ((double)a.InnerValue)));  			break;  		case "pi":  			stack.Push (new Token (System.Math.PI));  			break;  		default:  			throw new ArgumentException ("Invalid RPN.");  		}  	}  }  
Magic Number,sharpcalculator.Math,ReversePolishNotation,C:\repos\nissehutt_sharp-calculator\sharp-calculator\Math\ReversePolishNotation.cs,Solve,The following statement contains a magic number: while (queue.Any ()) {  	var token = queue.Dequeue ();  	if (token.IsValue) {  		stack.Push (token);  	}  	else {  		Token a;  		Token b;  		switch (token.InnerText) {  		case "+":  			if (stack.Count < 2)  				throw new ArgumentException ("Invalid RPN.");  			a = stack.Pop ();  			b = stack.Pop ();  			stack.Push (new Token (a.InnerValue + b.InnerValue));  			break;  		case "-":  			if (stack.Count == 1) {  				a = stack.Pop ();  				stack.Push (new Token (-a.InnerValue));  				break;  			}  			if (stack.Count != 2)  				throw new ArgumentException ("Invalid RPN.");  			a = stack.Pop ();  			b = stack.Pop ();  			stack.Push (new Token (a.InnerValue - b.InnerValue));  			break;  		case "*":  			if (stack.Count < 2)  				throw new ArgumentException ("Invalid RPN.");  			a = stack.Pop ();  			b = stack.Pop ();  			stack.Push (new Token (a.InnerValue * b.InnerValue));  			break;  		case "/":  			if (stack.Count < 2)  				throw new ArgumentException ("Invalid RPN.");  			a = stack.Pop ();  			b = stack.Pop ();  			stack.Push (new Token (a.InnerValue / b.InnerValue));  			break;  		case "cos":  			if (stack.Count < 1)  				throw new ArgumentException ("Invalid RPN.");  			a = stack.Pop ();  			stack.Push (new Token (System.Math.Cos ((double)a.InnerValue)));  			break;  		case "sin":  			if (stack.Count < 1)  				throw new ArgumentException ("Invalid RPN.");  			a = stack.Pop ();  			stack.Push (new Token (System.Math.Sin ((double)a.InnerValue)));  			break;  		case "tan":  			if (stack.Count < 1)  				throw new ArgumentException ("Invalid RPN.");  			a = stack.Pop ();  			stack.Push (new Token (System.Math.Tan ((double)a.InnerValue)));  			break;  		case "pow":  			if (stack.Count < 2)  				throw new ArgumentException ("Invalid RPN.");  			a = stack.Pop ();  			b = stack.Pop ();  			stack.Push (new Token (BigDecimal.Pow (a.InnerValue' (double)b.InnerValue)));  			break;  		case "sqrt":  			if (stack.Count < 1)  				throw new ArgumentException ("Invalid RPN.");  			a = stack.Pop ();  			stack.Push (new Token (System.Math.Sqrt ((double)a.InnerValue)));  			break;  		case "pi":  			stack.Push (new Token (System.Math.PI));  			break;  		default:  			throw new ArgumentException ("Invalid RPN.");  		}  	}  }  
Magic Number,sharpcalculator.Math,ReversePolishNotation,C:\repos\nissehutt_sharp-calculator\sharp-calculator\Math\ReversePolishNotation.cs,Solve,The following statement contains a magic number: while (queue.Any ()) {  	var token = queue.Dequeue ();  	if (token.IsValue) {  		stack.Push (token);  	}  	else {  		Token a;  		Token b;  		switch (token.InnerText) {  		case "+":  			if (stack.Count < 2)  				throw new ArgumentException ("Invalid RPN.");  			a = stack.Pop ();  			b = stack.Pop ();  			stack.Push (new Token (a.InnerValue + b.InnerValue));  			break;  		case "-":  			if (stack.Count == 1) {  				a = stack.Pop ();  				stack.Push (new Token (-a.InnerValue));  				break;  			}  			if (stack.Count != 2)  				throw new ArgumentException ("Invalid RPN.");  			a = stack.Pop ();  			b = stack.Pop ();  			stack.Push (new Token (a.InnerValue - b.InnerValue));  			break;  		case "*":  			if (stack.Count < 2)  				throw new ArgumentException ("Invalid RPN.");  			a = stack.Pop ();  			b = stack.Pop ();  			stack.Push (new Token (a.InnerValue * b.InnerValue));  			break;  		case "/":  			if (stack.Count < 2)  				throw new ArgumentException ("Invalid RPN.");  			a = stack.Pop ();  			b = stack.Pop ();  			stack.Push (new Token (a.InnerValue / b.InnerValue));  			break;  		case "cos":  			if (stack.Count < 1)  				throw new ArgumentException ("Invalid RPN.");  			a = stack.Pop ();  			stack.Push (new Token (System.Math.Cos ((double)a.InnerValue)));  			break;  		case "sin":  			if (stack.Count < 1)  				throw new ArgumentException ("Invalid RPN.");  			a = stack.Pop ();  			stack.Push (new Token (System.Math.Sin ((double)a.InnerValue)));  			break;  		case "tan":  			if (stack.Count < 1)  				throw new ArgumentException ("Invalid RPN.");  			a = stack.Pop ();  			stack.Push (new Token (System.Math.Tan ((double)a.InnerValue)));  			break;  		case "pow":  			if (stack.Count < 2)  				throw new ArgumentException ("Invalid RPN.");  			a = stack.Pop ();  			b = stack.Pop ();  			stack.Push (new Token (BigDecimal.Pow (a.InnerValue' (double)b.InnerValue)));  			break;  		case "sqrt":  			if (stack.Count < 1)  				throw new ArgumentException ("Invalid RPN.");  			a = stack.Pop ();  			stack.Push (new Token (System.Math.Sqrt ((double)a.InnerValue)));  			break;  		case "pi":  			stack.Push (new Token (System.Math.PI));  			break;  		default:  			throw new ArgumentException ("Invalid RPN.");  		}  	}  }  
Magic Number,sharpcalculator.Math,ReversePolishNotation,C:\repos\nissehutt_sharp-calculator\sharp-calculator\Math\ReversePolishNotation.cs,Solve,The following statement contains a magic number: while (queue.Any ()) {  	var token = queue.Dequeue ();  	if (token.IsValue) {  		stack.Push (token);  	}  	else {  		Token a;  		Token b;  		switch (token.InnerText) {  		case "+":  			if (stack.Count < 2)  				throw new ArgumentException ("Invalid RPN.");  			a = stack.Pop ();  			b = stack.Pop ();  			stack.Push (new Token (a.InnerValue + b.InnerValue));  			break;  		case "-":  			if (stack.Count == 1) {  				a = stack.Pop ();  				stack.Push (new Token (-a.InnerValue));  				break;  			}  			if (stack.Count != 2)  				throw new ArgumentException ("Invalid RPN.");  			a = stack.Pop ();  			b = stack.Pop ();  			stack.Push (new Token (a.InnerValue - b.InnerValue));  			break;  		case "*":  			if (stack.Count < 2)  				throw new ArgumentException ("Invalid RPN.");  			a = stack.Pop ();  			b = stack.Pop ();  			stack.Push (new Token (a.InnerValue * b.InnerValue));  			break;  		case "/":  			if (stack.Count < 2)  				throw new ArgumentException ("Invalid RPN.");  			a = stack.Pop ();  			b = stack.Pop ();  			stack.Push (new Token (a.InnerValue / b.InnerValue));  			break;  		case "cos":  			if (stack.Count < 1)  				throw new ArgumentException ("Invalid RPN.");  			a = stack.Pop ();  			stack.Push (new Token (System.Math.Cos ((double)a.InnerValue)));  			break;  		case "sin":  			if (stack.Count < 1)  				throw new ArgumentException ("Invalid RPN.");  			a = stack.Pop ();  			stack.Push (new Token (System.Math.Sin ((double)a.InnerValue)));  			break;  		case "tan":  			if (stack.Count < 1)  				throw new ArgumentException ("Invalid RPN.");  			a = stack.Pop ();  			stack.Push (new Token (System.Math.Tan ((double)a.InnerValue)));  			break;  		case "pow":  			if (stack.Count < 2)  				throw new ArgumentException ("Invalid RPN.");  			a = stack.Pop ();  			b = stack.Pop ();  			stack.Push (new Token (BigDecimal.Pow (a.InnerValue' (double)b.InnerValue)));  			break;  		case "sqrt":  			if (stack.Count < 1)  				throw new ArgumentException ("Invalid RPN.");  			a = stack.Pop ();  			stack.Push (new Token (System.Math.Sqrt ((double)a.InnerValue)));  			break;  		case "pi":  			stack.Push (new Token (System.Math.PI));  			break;  		default:  			throw new ArgumentException ("Invalid RPN.");  		}  	}  }  
Magic Number,sharpcalculator.Math,ReversePolishNotation,C:\repos\nissehutt_sharp-calculator\sharp-calculator\Math\ReversePolishNotation.cs,Solve,The following statement contains a magic number: while (queue.Any ()) {  	var token = queue.Dequeue ();  	if (token.IsValue) {  		stack.Push (token);  	}  	else {  		Token a;  		Token b;  		switch (token.InnerText) {  		case "+":  			if (stack.Count < 2)  				throw new ArgumentException ("Invalid RPN.");  			a = stack.Pop ();  			b = stack.Pop ();  			stack.Push (new Token (a.InnerValue + b.InnerValue));  			break;  		case "-":  			if (stack.Count == 1) {  				a = stack.Pop ();  				stack.Push (new Token (-a.InnerValue));  				break;  			}  			if (stack.Count != 2)  				throw new ArgumentException ("Invalid RPN.");  			a = stack.Pop ();  			b = stack.Pop ();  			stack.Push (new Token (a.InnerValue - b.InnerValue));  			break;  		case "*":  			if (stack.Count < 2)  				throw new ArgumentException ("Invalid RPN.");  			a = stack.Pop ();  			b = stack.Pop ();  			stack.Push (new Token (a.InnerValue * b.InnerValue));  			break;  		case "/":  			if (stack.Count < 2)  				throw new ArgumentException ("Invalid RPN.");  			a = stack.Pop ();  			b = stack.Pop ();  			stack.Push (new Token (a.InnerValue / b.InnerValue));  			break;  		case "cos":  			if (stack.Count < 1)  				throw new ArgumentException ("Invalid RPN.");  			a = stack.Pop ();  			stack.Push (new Token (System.Math.Cos ((double)a.InnerValue)));  			break;  		case "sin":  			if (stack.Count < 1)  				throw new ArgumentException ("Invalid RPN.");  			a = stack.Pop ();  			stack.Push (new Token (System.Math.Sin ((double)a.InnerValue)));  			break;  		case "tan":  			if (stack.Count < 1)  				throw new ArgumentException ("Invalid RPN.");  			a = stack.Pop ();  			stack.Push (new Token (System.Math.Tan ((double)a.InnerValue)));  			break;  		case "pow":  			if (stack.Count < 2)  				throw new ArgumentException ("Invalid RPN.");  			a = stack.Pop ();  			b = stack.Pop ();  			stack.Push (new Token (BigDecimal.Pow (a.InnerValue' (double)b.InnerValue)));  			break;  		case "sqrt":  			if (stack.Count < 1)  				throw new ArgumentException ("Invalid RPN.");  			a = stack.Pop ();  			stack.Push (new Token (System.Math.Sqrt ((double)a.InnerValue)));  			break;  		case "pi":  			stack.Push (new Token (System.Math.PI));  			break;  		default:  			throw new ArgumentException ("Invalid RPN.");  		}  	}  }  
Magic Number,sharpcalculator.Math,ReversePolishNotation,C:\repos\nissehutt_sharp-calculator\sharp-calculator\Math\ReversePolishNotation.cs,Solve,The following statement contains a magic number: if (token.IsValue) {  	stack.Push (token);  }  else {  	Token a;  	Token b;  	switch (token.InnerText) {  	case "+":  		if (stack.Count < 2)  			throw new ArgumentException ("Invalid RPN.");  		a = stack.Pop ();  		b = stack.Pop ();  		stack.Push (new Token (a.InnerValue + b.InnerValue));  		break;  	case "-":  		if (stack.Count == 1) {  			a = stack.Pop ();  			stack.Push (new Token (-a.InnerValue));  			break;  		}  		if (stack.Count != 2)  			throw new ArgumentException ("Invalid RPN.");  		a = stack.Pop ();  		b = stack.Pop ();  		stack.Push (new Token (a.InnerValue - b.InnerValue));  		break;  	case "*":  		if (stack.Count < 2)  			throw new ArgumentException ("Invalid RPN.");  		a = stack.Pop ();  		b = stack.Pop ();  		stack.Push (new Token (a.InnerValue * b.InnerValue));  		break;  	case "/":  		if (stack.Count < 2)  			throw new ArgumentException ("Invalid RPN.");  		a = stack.Pop ();  		b = stack.Pop ();  		stack.Push (new Token (a.InnerValue / b.InnerValue));  		break;  	case "cos":  		if (stack.Count < 1)  			throw new ArgumentException ("Invalid RPN.");  		a = stack.Pop ();  		stack.Push (new Token (System.Math.Cos ((double)a.InnerValue)));  		break;  	case "sin":  		if (stack.Count < 1)  			throw new ArgumentException ("Invalid RPN.");  		a = stack.Pop ();  		stack.Push (new Token (System.Math.Sin ((double)a.InnerValue)));  		break;  	case "tan":  		if (stack.Count < 1)  			throw new ArgumentException ("Invalid RPN.");  		a = stack.Pop ();  		stack.Push (new Token (System.Math.Tan ((double)a.InnerValue)));  		break;  	case "pow":  		if (stack.Count < 2)  			throw new ArgumentException ("Invalid RPN.");  		a = stack.Pop ();  		b = stack.Pop ();  		stack.Push (new Token (BigDecimal.Pow (a.InnerValue' (double)b.InnerValue)));  		break;  	case "sqrt":  		if (stack.Count < 1)  			throw new ArgumentException ("Invalid RPN.");  		a = stack.Pop ();  		stack.Push (new Token (System.Math.Sqrt ((double)a.InnerValue)));  		break;  	case "pi":  		stack.Push (new Token (System.Math.PI));  		break;  	default:  		throw new ArgumentException ("Invalid RPN.");  	}  }  
Magic Number,sharpcalculator.Math,ReversePolishNotation,C:\repos\nissehutt_sharp-calculator\sharp-calculator\Math\ReversePolishNotation.cs,Solve,The following statement contains a magic number: if (token.IsValue) {  	stack.Push (token);  }  else {  	Token a;  	Token b;  	switch (token.InnerText) {  	case "+":  		if (stack.Count < 2)  			throw new ArgumentException ("Invalid RPN.");  		a = stack.Pop ();  		b = stack.Pop ();  		stack.Push (new Token (a.InnerValue + b.InnerValue));  		break;  	case "-":  		if (stack.Count == 1) {  			a = stack.Pop ();  			stack.Push (new Token (-a.InnerValue));  			break;  		}  		if (stack.Count != 2)  			throw new ArgumentException ("Invalid RPN.");  		a = stack.Pop ();  		b = stack.Pop ();  		stack.Push (new Token (a.InnerValue - b.InnerValue));  		break;  	case "*":  		if (stack.Count < 2)  			throw new ArgumentException ("Invalid RPN.");  		a = stack.Pop ();  		b = stack.Pop ();  		stack.Push (new Token (a.InnerValue * b.InnerValue));  		break;  	case "/":  		if (stack.Count < 2)  			throw new ArgumentException ("Invalid RPN.");  		a = stack.Pop ();  		b = stack.Pop ();  		stack.Push (new Token (a.InnerValue / b.InnerValue));  		break;  	case "cos":  		if (stack.Count < 1)  			throw new ArgumentException ("Invalid RPN.");  		a = stack.Pop ();  		stack.Push (new Token (System.Math.Cos ((double)a.InnerValue)));  		break;  	case "sin":  		if (stack.Count < 1)  			throw new ArgumentException ("Invalid RPN.");  		a = stack.Pop ();  		stack.Push (new Token (System.Math.Sin ((double)a.InnerValue)));  		break;  	case "tan":  		if (stack.Count < 1)  			throw new ArgumentException ("Invalid RPN.");  		a = stack.Pop ();  		stack.Push (new Token (System.Math.Tan ((double)a.InnerValue)));  		break;  	case "pow":  		if (stack.Count < 2)  			throw new ArgumentException ("Invalid RPN.");  		a = stack.Pop ();  		b = stack.Pop ();  		stack.Push (new Token (BigDecimal.Pow (a.InnerValue' (double)b.InnerValue)));  		break;  	case "sqrt":  		if (stack.Count < 1)  			throw new ArgumentException ("Invalid RPN.");  		a = stack.Pop ();  		stack.Push (new Token (System.Math.Sqrt ((double)a.InnerValue)));  		break;  	case "pi":  		stack.Push (new Token (System.Math.PI));  		break;  	default:  		throw new ArgumentException ("Invalid RPN.");  	}  }  
Magic Number,sharpcalculator.Math,ReversePolishNotation,C:\repos\nissehutt_sharp-calculator\sharp-calculator\Math\ReversePolishNotation.cs,Solve,The following statement contains a magic number: if (token.IsValue) {  	stack.Push (token);  }  else {  	Token a;  	Token b;  	switch (token.InnerText) {  	case "+":  		if (stack.Count < 2)  			throw new ArgumentException ("Invalid RPN.");  		a = stack.Pop ();  		b = stack.Pop ();  		stack.Push (new Token (a.InnerValue + b.InnerValue));  		break;  	case "-":  		if (stack.Count == 1) {  			a = stack.Pop ();  			stack.Push (new Token (-a.InnerValue));  			break;  		}  		if (stack.Count != 2)  			throw new ArgumentException ("Invalid RPN.");  		a = stack.Pop ();  		b = stack.Pop ();  		stack.Push (new Token (a.InnerValue - b.InnerValue));  		break;  	case "*":  		if (stack.Count < 2)  			throw new ArgumentException ("Invalid RPN.");  		a = stack.Pop ();  		b = stack.Pop ();  		stack.Push (new Token (a.InnerValue * b.InnerValue));  		break;  	case "/":  		if (stack.Count < 2)  			throw new ArgumentException ("Invalid RPN.");  		a = stack.Pop ();  		b = stack.Pop ();  		stack.Push (new Token (a.InnerValue / b.InnerValue));  		break;  	case "cos":  		if (stack.Count < 1)  			throw new ArgumentException ("Invalid RPN.");  		a = stack.Pop ();  		stack.Push (new Token (System.Math.Cos ((double)a.InnerValue)));  		break;  	case "sin":  		if (stack.Count < 1)  			throw new ArgumentException ("Invalid RPN.");  		a = stack.Pop ();  		stack.Push (new Token (System.Math.Sin ((double)a.InnerValue)));  		break;  	case "tan":  		if (stack.Count < 1)  			throw new ArgumentException ("Invalid RPN.");  		a = stack.Pop ();  		stack.Push (new Token (System.Math.Tan ((double)a.InnerValue)));  		break;  	case "pow":  		if (stack.Count < 2)  			throw new ArgumentException ("Invalid RPN.");  		a = stack.Pop ();  		b = stack.Pop ();  		stack.Push (new Token (BigDecimal.Pow (a.InnerValue' (double)b.InnerValue)));  		break;  	case "sqrt":  		if (stack.Count < 1)  			throw new ArgumentException ("Invalid RPN.");  		a = stack.Pop ();  		stack.Push (new Token (System.Math.Sqrt ((double)a.InnerValue)));  		break;  	case "pi":  		stack.Push (new Token (System.Math.PI));  		break;  	default:  		throw new ArgumentException ("Invalid RPN.");  	}  }  
Magic Number,sharpcalculator.Math,ReversePolishNotation,C:\repos\nissehutt_sharp-calculator\sharp-calculator\Math\ReversePolishNotation.cs,Solve,The following statement contains a magic number: if (token.IsValue) {  	stack.Push (token);  }  else {  	Token a;  	Token b;  	switch (token.InnerText) {  	case "+":  		if (stack.Count < 2)  			throw new ArgumentException ("Invalid RPN.");  		a = stack.Pop ();  		b = stack.Pop ();  		stack.Push (new Token (a.InnerValue + b.InnerValue));  		break;  	case "-":  		if (stack.Count == 1) {  			a = stack.Pop ();  			stack.Push (new Token (-a.InnerValue));  			break;  		}  		if (stack.Count != 2)  			throw new ArgumentException ("Invalid RPN.");  		a = stack.Pop ();  		b = stack.Pop ();  		stack.Push (new Token (a.InnerValue - b.InnerValue));  		break;  	case "*":  		if (stack.Count < 2)  			throw new ArgumentException ("Invalid RPN.");  		a = stack.Pop ();  		b = stack.Pop ();  		stack.Push (new Token (a.InnerValue * b.InnerValue));  		break;  	case "/":  		if (stack.Count < 2)  			throw new ArgumentException ("Invalid RPN.");  		a = stack.Pop ();  		b = stack.Pop ();  		stack.Push (new Token (a.InnerValue / b.InnerValue));  		break;  	case "cos":  		if (stack.Count < 1)  			throw new ArgumentException ("Invalid RPN.");  		a = stack.Pop ();  		stack.Push (new Token (System.Math.Cos ((double)a.InnerValue)));  		break;  	case "sin":  		if (stack.Count < 1)  			throw new ArgumentException ("Invalid RPN.");  		a = stack.Pop ();  		stack.Push (new Token (System.Math.Sin ((double)a.InnerValue)));  		break;  	case "tan":  		if (stack.Count < 1)  			throw new ArgumentException ("Invalid RPN.");  		a = stack.Pop ();  		stack.Push (new Token (System.Math.Tan ((double)a.InnerValue)));  		break;  	case "pow":  		if (stack.Count < 2)  			throw new ArgumentException ("Invalid RPN.");  		a = stack.Pop ();  		b = stack.Pop ();  		stack.Push (new Token (BigDecimal.Pow (a.InnerValue' (double)b.InnerValue)));  		break;  	case "sqrt":  		if (stack.Count < 1)  			throw new ArgumentException ("Invalid RPN.");  		a = stack.Pop ();  		stack.Push (new Token (System.Math.Sqrt ((double)a.InnerValue)));  		break;  	case "pi":  		stack.Push (new Token (System.Math.PI));  		break;  	default:  		throw new ArgumentException ("Invalid RPN.");  	}  }  
Magic Number,sharpcalculator.Math,ReversePolishNotation,C:\repos\nissehutt_sharp-calculator\sharp-calculator\Math\ReversePolishNotation.cs,Solve,The following statement contains a magic number: if (token.IsValue) {  	stack.Push (token);  }  else {  	Token a;  	Token b;  	switch (token.InnerText) {  	case "+":  		if (stack.Count < 2)  			throw new ArgumentException ("Invalid RPN.");  		a = stack.Pop ();  		b = stack.Pop ();  		stack.Push (new Token (a.InnerValue + b.InnerValue));  		break;  	case "-":  		if (stack.Count == 1) {  			a = stack.Pop ();  			stack.Push (new Token (-a.InnerValue));  			break;  		}  		if (stack.Count != 2)  			throw new ArgumentException ("Invalid RPN.");  		a = stack.Pop ();  		b = stack.Pop ();  		stack.Push (new Token (a.InnerValue - b.InnerValue));  		break;  	case "*":  		if (stack.Count < 2)  			throw new ArgumentException ("Invalid RPN.");  		a = stack.Pop ();  		b = stack.Pop ();  		stack.Push (new Token (a.InnerValue * b.InnerValue));  		break;  	case "/":  		if (stack.Count < 2)  			throw new ArgumentException ("Invalid RPN.");  		a = stack.Pop ();  		b = stack.Pop ();  		stack.Push (new Token (a.InnerValue / b.InnerValue));  		break;  	case "cos":  		if (stack.Count < 1)  			throw new ArgumentException ("Invalid RPN.");  		a = stack.Pop ();  		stack.Push (new Token (System.Math.Cos ((double)a.InnerValue)));  		break;  	case "sin":  		if (stack.Count < 1)  			throw new ArgumentException ("Invalid RPN.");  		a = stack.Pop ();  		stack.Push (new Token (System.Math.Sin ((double)a.InnerValue)));  		break;  	case "tan":  		if (stack.Count < 1)  			throw new ArgumentException ("Invalid RPN.");  		a = stack.Pop ();  		stack.Push (new Token (System.Math.Tan ((double)a.InnerValue)));  		break;  	case "pow":  		if (stack.Count < 2)  			throw new ArgumentException ("Invalid RPN.");  		a = stack.Pop ();  		b = stack.Pop ();  		stack.Push (new Token (BigDecimal.Pow (a.InnerValue' (double)b.InnerValue)));  		break;  	case "sqrt":  		if (stack.Count < 1)  			throw new ArgumentException ("Invalid RPN.");  		a = stack.Pop ();  		stack.Push (new Token (System.Math.Sqrt ((double)a.InnerValue)));  		break;  	case "pi":  		stack.Push (new Token (System.Math.PI));  		break;  	default:  		throw new ArgumentException ("Invalid RPN.");  	}  }  
Magic Number,sharpcalculator.Math,ReversePolishNotation,C:\repos\nissehutt_sharp-calculator\sharp-calculator\Math\ReversePolishNotation.cs,Solve,The following statement contains a magic number: switch (token.InnerText) {  case "+":  	if (stack.Count < 2)  		throw new ArgumentException ("Invalid RPN.");  	a = stack.Pop ();  	b = stack.Pop ();  	stack.Push (new Token (a.InnerValue + b.InnerValue));  	break;  case "-":  	if (stack.Count == 1) {  		a = stack.Pop ();  		stack.Push (new Token (-a.InnerValue));  		break;  	}  	if (stack.Count != 2)  		throw new ArgumentException ("Invalid RPN.");  	a = stack.Pop ();  	b = stack.Pop ();  	stack.Push (new Token (a.InnerValue - b.InnerValue));  	break;  case "*":  	if (stack.Count < 2)  		throw new ArgumentException ("Invalid RPN.");  	a = stack.Pop ();  	b = stack.Pop ();  	stack.Push (new Token (a.InnerValue * b.InnerValue));  	break;  case "/":  	if (stack.Count < 2)  		throw new ArgumentException ("Invalid RPN.");  	a = stack.Pop ();  	b = stack.Pop ();  	stack.Push (new Token (a.InnerValue / b.InnerValue));  	break;  case "cos":  	if (stack.Count < 1)  		throw new ArgumentException ("Invalid RPN.");  	a = stack.Pop ();  	stack.Push (new Token (System.Math.Cos ((double)a.InnerValue)));  	break;  case "sin":  	if (stack.Count < 1)  		throw new ArgumentException ("Invalid RPN.");  	a = stack.Pop ();  	stack.Push (new Token (System.Math.Sin ((double)a.InnerValue)));  	break;  case "tan":  	if (stack.Count < 1)  		throw new ArgumentException ("Invalid RPN.");  	a = stack.Pop ();  	stack.Push (new Token (System.Math.Tan ((double)a.InnerValue)));  	break;  case "pow":  	if (stack.Count < 2)  		throw new ArgumentException ("Invalid RPN.");  	a = stack.Pop ();  	b = stack.Pop ();  	stack.Push (new Token (BigDecimal.Pow (a.InnerValue' (double)b.InnerValue)));  	break;  case "sqrt":  	if (stack.Count < 1)  		throw new ArgumentException ("Invalid RPN.");  	a = stack.Pop ();  	stack.Push (new Token (System.Math.Sqrt ((double)a.InnerValue)));  	break;  case "pi":  	stack.Push (new Token (System.Math.PI));  	break;  default:  	throw new ArgumentException ("Invalid RPN.");  }  
Magic Number,sharpcalculator.Math,ReversePolishNotation,C:\repos\nissehutt_sharp-calculator\sharp-calculator\Math\ReversePolishNotation.cs,Solve,The following statement contains a magic number: switch (token.InnerText) {  case "+":  	if (stack.Count < 2)  		throw new ArgumentException ("Invalid RPN.");  	a = stack.Pop ();  	b = stack.Pop ();  	stack.Push (new Token (a.InnerValue + b.InnerValue));  	break;  case "-":  	if (stack.Count == 1) {  		a = stack.Pop ();  		stack.Push (new Token (-a.InnerValue));  		break;  	}  	if (stack.Count != 2)  		throw new ArgumentException ("Invalid RPN.");  	a = stack.Pop ();  	b = stack.Pop ();  	stack.Push (new Token (a.InnerValue - b.InnerValue));  	break;  case "*":  	if (stack.Count < 2)  		throw new ArgumentException ("Invalid RPN.");  	a = stack.Pop ();  	b = stack.Pop ();  	stack.Push (new Token (a.InnerValue * b.InnerValue));  	break;  case "/":  	if (stack.Count < 2)  		throw new ArgumentException ("Invalid RPN.");  	a = stack.Pop ();  	b = stack.Pop ();  	stack.Push (new Token (a.InnerValue / b.InnerValue));  	break;  case "cos":  	if (stack.Count < 1)  		throw new ArgumentException ("Invalid RPN.");  	a = stack.Pop ();  	stack.Push (new Token (System.Math.Cos ((double)a.InnerValue)));  	break;  case "sin":  	if (stack.Count < 1)  		throw new ArgumentException ("Invalid RPN.");  	a = stack.Pop ();  	stack.Push (new Token (System.Math.Sin ((double)a.InnerValue)));  	break;  case "tan":  	if (stack.Count < 1)  		throw new ArgumentException ("Invalid RPN.");  	a = stack.Pop ();  	stack.Push (new Token (System.Math.Tan ((double)a.InnerValue)));  	break;  case "pow":  	if (stack.Count < 2)  		throw new ArgumentException ("Invalid RPN.");  	a = stack.Pop ();  	b = stack.Pop ();  	stack.Push (new Token (BigDecimal.Pow (a.InnerValue' (double)b.InnerValue)));  	break;  case "sqrt":  	if (stack.Count < 1)  		throw new ArgumentException ("Invalid RPN.");  	a = stack.Pop ();  	stack.Push (new Token (System.Math.Sqrt ((double)a.InnerValue)));  	break;  case "pi":  	stack.Push (new Token (System.Math.PI));  	break;  default:  	throw new ArgumentException ("Invalid RPN.");  }  
Magic Number,sharpcalculator.Math,ReversePolishNotation,C:\repos\nissehutt_sharp-calculator\sharp-calculator\Math\ReversePolishNotation.cs,Solve,The following statement contains a magic number: switch (token.InnerText) {  case "+":  	if (stack.Count < 2)  		throw new ArgumentException ("Invalid RPN.");  	a = stack.Pop ();  	b = stack.Pop ();  	stack.Push (new Token (a.InnerValue + b.InnerValue));  	break;  case "-":  	if (stack.Count == 1) {  		a = stack.Pop ();  		stack.Push (new Token (-a.InnerValue));  		break;  	}  	if (stack.Count != 2)  		throw new ArgumentException ("Invalid RPN.");  	a = stack.Pop ();  	b = stack.Pop ();  	stack.Push (new Token (a.InnerValue - b.InnerValue));  	break;  case "*":  	if (stack.Count < 2)  		throw new ArgumentException ("Invalid RPN.");  	a = stack.Pop ();  	b = stack.Pop ();  	stack.Push (new Token (a.InnerValue * b.InnerValue));  	break;  case "/":  	if (stack.Count < 2)  		throw new ArgumentException ("Invalid RPN.");  	a = stack.Pop ();  	b = stack.Pop ();  	stack.Push (new Token (a.InnerValue / b.InnerValue));  	break;  case "cos":  	if (stack.Count < 1)  		throw new ArgumentException ("Invalid RPN.");  	a = stack.Pop ();  	stack.Push (new Token (System.Math.Cos ((double)a.InnerValue)));  	break;  case "sin":  	if (stack.Count < 1)  		throw new ArgumentException ("Invalid RPN.");  	a = stack.Pop ();  	stack.Push (new Token (System.Math.Sin ((double)a.InnerValue)));  	break;  case "tan":  	if (stack.Count < 1)  		throw new ArgumentException ("Invalid RPN.");  	a = stack.Pop ();  	stack.Push (new Token (System.Math.Tan ((double)a.InnerValue)));  	break;  case "pow":  	if (stack.Count < 2)  		throw new ArgumentException ("Invalid RPN.");  	a = stack.Pop ();  	b = stack.Pop ();  	stack.Push (new Token (BigDecimal.Pow (a.InnerValue' (double)b.InnerValue)));  	break;  case "sqrt":  	if (stack.Count < 1)  		throw new ArgumentException ("Invalid RPN.");  	a = stack.Pop ();  	stack.Push (new Token (System.Math.Sqrt ((double)a.InnerValue)));  	break;  case "pi":  	stack.Push (new Token (System.Math.PI));  	break;  default:  	throw new ArgumentException ("Invalid RPN.");  }  
Magic Number,sharpcalculator.Math,ReversePolishNotation,C:\repos\nissehutt_sharp-calculator\sharp-calculator\Math\ReversePolishNotation.cs,Solve,The following statement contains a magic number: switch (token.InnerText) {  case "+":  	if (stack.Count < 2)  		throw new ArgumentException ("Invalid RPN.");  	a = stack.Pop ();  	b = stack.Pop ();  	stack.Push (new Token (a.InnerValue + b.InnerValue));  	break;  case "-":  	if (stack.Count == 1) {  		a = stack.Pop ();  		stack.Push (new Token (-a.InnerValue));  		break;  	}  	if (stack.Count != 2)  		throw new ArgumentException ("Invalid RPN.");  	a = stack.Pop ();  	b = stack.Pop ();  	stack.Push (new Token (a.InnerValue - b.InnerValue));  	break;  case "*":  	if (stack.Count < 2)  		throw new ArgumentException ("Invalid RPN.");  	a = stack.Pop ();  	b = stack.Pop ();  	stack.Push (new Token (a.InnerValue * b.InnerValue));  	break;  case "/":  	if (stack.Count < 2)  		throw new ArgumentException ("Invalid RPN.");  	a = stack.Pop ();  	b = stack.Pop ();  	stack.Push (new Token (a.InnerValue / b.InnerValue));  	break;  case "cos":  	if (stack.Count < 1)  		throw new ArgumentException ("Invalid RPN.");  	a = stack.Pop ();  	stack.Push (new Token (System.Math.Cos ((double)a.InnerValue)));  	break;  case "sin":  	if (stack.Count < 1)  		throw new ArgumentException ("Invalid RPN.");  	a = stack.Pop ();  	stack.Push (new Token (System.Math.Sin ((double)a.InnerValue)));  	break;  case "tan":  	if (stack.Count < 1)  		throw new ArgumentException ("Invalid RPN.");  	a = stack.Pop ();  	stack.Push (new Token (System.Math.Tan ((double)a.InnerValue)));  	break;  case "pow":  	if (stack.Count < 2)  		throw new ArgumentException ("Invalid RPN.");  	a = stack.Pop ();  	b = stack.Pop ();  	stack.Push (new Token (BigDecimal.Pow (a.InnerValue' (double)b.InnerValue)));  	break;  case "sqrt":  	if (stack.Count < 1)  		throw new ArgumentException ("Invalid RPN.");  	a = stack.Pop ();  	stack.Push (new Token (System.Math.Sqrt ((double)a.InnerValue)));  	break;  case "pi":  	stack.Push (new Token (System.Math.PI));  	break;  default:  	throw new ArgumentException ("Invalid RPN.");  }  
Magic Number,sharpcalculator.Math,ReversePolishNotation,C:\repos\nissehutt_sharp-calculator\sharp-calculator\Math\ReversePolishNotation.cs,Solve,The following statement contains a magic number: switch (token.InnerText) {  case "+":  	if (stack.Count < 2)  		throw new ArgumentException ("Invalid RPN.");  	a = stack.Pop ();  	b = stack.Pop ();  	stack.Push (new Token (a.InnerValue + b.InnerValue));  	break;  case "-":  	if (stack.Count == 1) {  		a = stack.Pop ();  		stack.Push (new Token (-a.InnerValue));  		break;  	}  	if (stack.Count != 2)  		throw new ArgumentException ("Invalid RPN.");  	a = stack.Pop ();  	b = stack.Pop ();  	stack.Push (new Token (a.InnerValue - b.InnerValue));  	break;  case "*":  	if (stack.Count < 2)  		throw new ArgumentException ("Invalid RPN.");  	a = stack.Pop ();  	b = stack.Pop ();  	stack.Push (new Token (a.InnerValue * b.InnerValue));  	break;  case "/":  	if (stack.Count < 2)  		throw new ArgumentException ("Invalid RPN.");  	a = stack.Pop ();  	b = stack.Pop ();  	stack.Push (new Token (a.InnerValue / b.InnerValue));  	break;  case "cos":  	if (stack.Count < 1)  		throw new ArgumentException ("Invalid RPN.");  	a = stack.Pop ();  	stack.Push (new Token (System.Math.Cos ((double)a.InnerValue)));  	break;  case "sin":  	if (stack.Count < 1)  		throw new ArgumentException ("Invalid RPN.");  	a = stack.Pop ();  	stack.Push (new Token (System.Math.Sin ((double)a.InnerValue)));  	break;  case "tan":  	if (stack.Count < 1)  		throw new ArgumentException ("Invalid RPN.");  	a = stack.Pop ();  	stack.Push (new Token (System.Math.Tan ((double)a.InnerValue)));  	break;  case "pow":  	if (stack.Count < 2)  		throw new ArgumentException ("Invalid RPN.");  	a = stack.Pop ();  	b = stack.Pop ();  	stack.Push (new Token (BigDecimal.Pow (a.InnerValue' (double)b.InnerValue)));  	break;  case "sqrt":  	if (stack.Count < 1)  		throw new ArgumentException ("Invalid RPN.");  	a = stack.Pop ();  	stack.Push (new Token (System.Math.Sqrt ((double)a.InnerValue)));  	break;  case "pi":  	stack.Push (new Token (System.Math.PI));  	break;  default:  	throw new ArgumentException ("Invalid RPN.");  }  
Magic Number,sharpcalculator.Math,ReversePolishNotation,C:\repos\nissehutt_sharp-calculator\sharp-calculator\Math\ReversePolishNotation.cs,Solve,The following statement contains a magic number: if (stack.Count < 2)  	throw new ArgumentException ("Invalid RPN.");  
Magic Number,sharpcalculator.Math,ReversePolishNotation,C:\repos\nissehutt_sharp-calculator\sharp-calculator\Math\ReversePolishNotation.cs,Solve,The following statement contains a magic number: if (stack.Count != 2)  	throw new ArgumentException ("Invalid RPN.");  
Magic Number,sharpcalculator.Math,ReversePolishNotation,C:\repos\nissehutt_sharp-calculator\sharp-calculator\Math\ReversePolishNotation.cs,Solve,The following statement contains a magic number: if (stack.Count < 2)  	throw new ArgumentException ("Invalid RPN.");  
Magic Number,sharpcalculator.Math,ReversePolishNotation,C:\repos\nissehutt_sharp-calculator\sharp-calculator\Math\ReversePolishNotation.cs,Solve,The following statement contains a magic number: if (stack.Count < 2)  	throw new ArgumentException ("Invalid RPN.");  
Magic Number,sharpcalculator.Math,ReversePolishNotation,C:\repos\nissehutt_sharp-calculator\sharp-calculator\Math\ReversePolishNotation.cs,Solve,The following statement contains a magic number: if (stack.Count < 2)  	throw new ArgumentException ("Invalid RPN.");  
