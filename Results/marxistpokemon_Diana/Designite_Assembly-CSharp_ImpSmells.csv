Implementation smell,Namespace,Class,File,Method,Description
Long Method,Spine,SkeletonJson,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonJson.cs,ReadAnimation,The method has 148 lines of code.
Complex Method,Spine,RotateTimeline,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Animation.cs,Apply,Cyclomatic complexity of the method is 14
Complex Method,Spine,AnimationState,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\AnimationState.cs,Update,Cyclomatic complexity of the method is 9
Complex Method,Spine,AnimationState,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\AnimationState.cs,Apply,Cyclomatic complexity of the method is 9
Complex Method,Spine,Atlas,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Atlas.cs,Load,Cyclomatic complexity of the method is 12
Complex Method,Spine,AtlasAttachmentLoader,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Attachments\AtlasAttachmentLoader.cs,NewAttachment,Cyclomatic complexity of the method is 14
Complex Method,Spine,SkeletonBounds,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonBounds.cs,Update,Cyclomatic complexity of the method is 8
Complex Method,Spine,SkeletonJson,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonJson.cs,ReadSkeletonData,Cyclomatic complexity of the method is 23
Complex Method,Spine,SkeletonJson,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonJson.cs,ReadAnimation,Cyclomatic complexity of the method is 34
Long Parameter List,Spine,Animation,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Animation.cs,Apply,The method has 5 parameters.
Long Parameter List,Spine,Animation,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Animation.cs,Mix,The method has 6 parameters.
Long Parameter List,Spine,Timeline,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Animation.cs,Apply,The method has 5 parameters.
Long Parameter List,Spine,CurveTimeline,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Animation.cs,Apply,The method has 5 parameters.
Long Parameter List,Spine,CurveTimeline,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Animation.cs,SetCurve,The method has 5 parameters.
Long Parameter List,Spine,RotateTimeline,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Animation.cs,Apply,The method has 5 parameters.
Long Parameter List,Spine,TranslateTimeline,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Animation.cs,Apply,The method has 5 parameters.
Long Parameter List,Spine,ScaleTimeline,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Animation.cs,Apply,The method has 5 parameters.
Long Parameter List,Spine,ColorTimeline,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Animation.cs,setFrame,The method has 6 parameters.
Long Parameter List,Spine,ColorTimeline,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Animation.cs,Apply,The method has 5 parameters.
Long Parameter List,Spine,AttachmentTimeline,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Animation.cs,Apply,The method has 5 parameters.
Long Parameter List,Spine,EventTimeline,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Animation.cs,Apply,The method has 5 parameters.
Long Parameter List,Spine,DrawOrderTimeline,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Animation.cs,Apply,The method has 5 parameters.
Long Parameter List,Spine,RegionAttachment,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Attachments\RegionAttachment.cs,SetUVs,The method has 5 parameters.
Long Parameter List,Spine,SkeletonBounds,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonBounds.cs,IntersectsSegment,The method has 5 parameters.
Long Statement,Spine,ScaleTimeline,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Animation.cs,Apply,The length of the statement  "	bone.scaleX += (bone.data.scaleX - 1 + lastFrameX + (frames [frameIndex + FRAME_X] - lastFrameX) * percent - bone.scaleX) * alpha; " is 130.
Long Statement,Spine,ScaleTimeline,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Animation.cs,Apply,The length of the statement  "	bone.scaleY += (bone.data.scaleY - 1 + lastFrameY + (frames [frameIndex + FRAME_Y] - lastFrameY) * percent - bone.scaleY) * alpha; " is 130.
Long Statement,Spine,AttachmentTimeline,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Animation.cs,Apply,The length of the statement  "	skeleton.slots [slotIndex].Attachment = attachmentName == null ? null : skeleton.GetAttachment (slotIndex' attachmentName); " is 123.
Long Statement,Spine,SkeletonBounds,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonBounds.cs,AabbIntersectsSegment,The length of the statement  "	if ((x1 <= minX && x2 <= minX) || (y1 <= minY && y2 <= minY) || (x1 >= maxX && x2 >= maxX) || (y1 >= maxY && y2 >= maxY)) " is 121.
Complex Conditional,Spine,SkeletonBounds,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonBounds.cs,AabbIntersectsSegment,The conditional expression  "(x1 <= minX && x2 <= minX) || (y1 <= minY && y2 <= minY) || (x1 >= maxX && x2 >= maxX) || (y1 >= maxY && y2 >= maxY)"  is complex.
Complex Conditional,Spine,SkeletonBounds,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonBounds.cs,ContainsPoint,The conditional expression  "(vertexY < y && prevY >= y) || (prevY < y && vertexY >= y)"  is complex.
Complex Conditional,Spine,SkeletonBounds,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonBounds.cs,IntersectsSegment,The conditional expression  "((x >= x3 && x <= x4) || (x >= x4 && x <= x3)) && ((x >= x1 && x <= x2) || (x >= x2 && x <= x1))"  is complex.
Complex Conditional,Spine,SkeletonBounds,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonBounds.cs,IntersectsSegment,The conditional expression  "((y >= y3 && y <= y4) || (y >= y4 && y <= y3)) && ((y >= y1 && y <= y2) || (y >= y2 && y <= y1))"  is complex.
Magic Number,Spine,CurveTimeline,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Animation.cs,CurveTimeline,The following statement contains a magic number: curves = new float[(frameCount - 1) * 6];  
Magic Number,Spine,CurveTimeline,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Animation.cs,SetLinear,The following statement contains a magic number: curves [frameIndex * 6] = LINEAR;  
Magic Number,Spine,CurveTimeline,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Animation.cs,SetStepped,The following statement contains a magic number: curves [frameIndex * 6] = STEPPED;  
Magic Number,Spine,CurveTimeline,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Animation.cs,SetCurve,The following statement contains a magic number: curves [i + 2] = tmp1x * pre4 + tmp2x * pre5;  
Magic Number,Spine,CurveTimeline,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Animation.cs,SetCurve,The following statement contains a magic number: curves [i + 3] = tmp1y * pre4 + tmp2y * pre5;  
Magic Number,Spine,CurveTimeline,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Animation.cs,SetCurve,The following statement contains a magic number: curves [i + 4] = tmp2x * pre5;  
Magic Number,Spine,CurveTimeline,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Animation.cs,SetCurve,The following statement contains a magic number: curves [i + 5] = tmp2y * pre5;  
Magic Number,Spine,RotateTimeline,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Animation.cs,RotateTimeline,The following statement contains a magic number: frames = new float[frameCount * 2];  
Magic Number,Spine,RotateTimeline,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Animation.cs,SetFrame,The following statement contains a magic number: frameIndex *= 2;  
Magic Number,Spine,RotateTimeline,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: if (time >= frames [frames.Length - 2]) {  	// Time is after last frame.  	amount = bone.data.rotation + frames [frames.Length - 1] - bone.rotation;  	while (amount > 180)  		amount -= 360;  	while (amount < -180)  		amount += 360;  	bone.rotation += amount * alpha;  	return;  }  
Magic Number,Spine,RotateTimeline,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: if (time >= frames [frames.Length - 2]) {  	// Time is after last frame.  	amount = bone.data.rotation + frames [frames.Length - 1] - bone.rotation;  	while (amount > 180)  		amount -= 360;  	while (amount < -180)  		amount += 360;  	bone.rotation += amount * alpha;  	return;  }  
Magic Number,Spine,RotateTimeline,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: if (time >= frames [frames.Length - 2]) {  	// Time is after last frame.  	amount = bone.data.rotation + frames [frames.Length - 1] - bone.rotation;  	while (amount > 180)  		amount -= 360;  	while (amount < -180)  		amount += 360;  	bone.rotation += amount * alpha;  	return;  }  
Magic Number,Spine,RotateTimeline,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: if (time >= frames [frames.Length - 2]) {  	// Time is after last frame.  	amount = bone.data.rotation + frames [frames.Length - 1] - bone.rotation;  	while (amount > 180)  		amount -= 360;  	while (amount < -180)  		amount += 360;  	bone.rotation += amount * alpha;  	return;  }  
Magic Number,Spine,RotateTimeline,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: if (time >= frames [frames.Length - 2]) {  	// Time is after last frame.  	amount = bone.data.rotation + frames [frames.Length - 1] - bone.rotation;  	while (amount > 180)  		amount -= 360;  	while (amount < -180)  		amount += 360;  	bone.rotation += amount * alpha;  	return;  }  
Magic Number,Spine,RotateTimeline,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: while (amount > 180)  	amount -= 360;  
Magic Number,Spine,RotateTimeline,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: while (amount > 180)  	amount -= 360;  
Magic Number,Spine,RotateTimeline,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: amount -= 360;  
Magic Number,Spine,RotateTimeline,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: while (amount < -180)  	amount += 360;  
Magic Number,Spine,RotateTimeline,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: while (amount < -180)  	amount += 360;  
Magic Number,Spine,RotateTimeline,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: amount += 360;  
Magic Number,Spine,RotateTimeline,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: percent = GetCurvePercent (frameIndex / 2 - 1' percent < 0 ? 0 : (percent > 1 ? 1 : percent));  
Magic Number,Spine,RotateTimeline,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: while (amount > 180)  	amount -= 360;  
Magic Number,Spine,RotateTimeline,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: while (amount > 180)  	amount -= 360;  
Magic Number,Spine,RotateTimeline,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: amount -= 360;  
Magic Number,Spine,RotateTimeline,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: while (amount < -180)  	amount += 360;  
Magic Number,Spine,RotateTimeline,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: while (amount < -180)  	amount += 360;  
Magic Number,Spine,RotateTimeline,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: amount += 360;  
Magic Number,Spine,RotateTimeline,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: while (amount > 180)  	amount -= 360;  
Magic Number,Spine,RotateTimeline,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: while (amount > 180)  	amount -= 360;  
Magic Number,Spine,RotateTimeline,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: amount -= 360;  
Magic Number,Spine,RotateTimeline,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: while (amount < -180)  	amount += 360;  
Magic Number,Spine,RotateTimeline,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: while (amount < -180)  	amount += 360;  
Magic Number,Spine,RotateTimeline,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: amount += 360;  
Magic Number,Spine,TranslateTimeline,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Animation.cs,TranslateTimeline,The following statement contains a magic number: frames = new float[frameCount * 3];  
Magic Number,Spine,TranslateTimeline,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Animation.cs,SetFrame,The following statement contains a magic number: frameIndex *= 3;  
Magic Number,Spine,TranslateTimeline,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Animation.cs,SetFrame,The following statement contains a magic number: frames [frameIndex + 2] = y;  
Magic Number,Spine,TranslateTimeline,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: if (time >= frames [frames.Length - 3]) {  	// Time is after last frame.  	bone.x += (bone.data.x + frames [frames.Length - 2] - bone.x) * alpha;  	bone.y += (bone.data.y + frames [frames.Length - 1] - bone.y) * alpha;  	return;  }  
Magic Number,Spine,TranslateTimeline,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: if (time >= frames [frames.Length - 3]) {  	// Time is after last frame.  	bone.x += (bone.data.x + frames [frames.Length - 2] - bone.x) * alpha;  	bone.y += (bone.data.y + frames [frames.Length - 1] - bone.y) * alpha;  	return;  }  
Magic Number,Spine,TranslateTimeline,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: bone.x += (bone.data.x + frames [frames.Length - 2] - bone.x) * alpha;  
Magic Number,Spine,TranslateTimeline,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: percent = GetCurvePercent (frameIndex / 3 - 1' percent < 0 ? 0 : (percent > 1 ? 1 : percent));  
Magic Number,Spine,ScaleTimeline,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: if (time >= frames [frames.Length - 3]) {  	// Time is after last frame.  	bone.scaleX += (bone.data.scaleX - 1 + frames [frames.Length - 2] - bone.scaleX) * alpha;  	bone.scaleY += (bone.data.scaleY - 1 + frames [frames.Length - 1] - bone.scaleY) * alpha;  	return;  }  
Magic Number,Spine,ScaleTimeline,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: if (time >= frames [frames.Length - 3]) {  	// Time is after last frame.  	bone.scaleX += (bone.data.scaleX - 1 + frames [frames.Length - 2] - bone.scaleX) * alpha;  	bone.scaleY += (bone.data.scaleY - 1 + frames [frames.Length - 1] - bone.scaleY) * alpha;  	return;  }  
Magic Number,Spine,ScaleTimeline,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: bone.scaleX += (bone.data.scaleX - 1 + frames [frames.Length - 2] - bone.scaleX) * alpha;  
Magic Number,Spine,ScaleTimeline,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: percent = GetCurvePercent (frameIndex / 3 - 1' percent < 0 ? 0 : (percent > 1 ? 1 : percent));  
Magic Number,Spine,ColorTimeline,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Animation.cs,ColorTimeline,The following statement contains a magic number: frames = new float[frameCount * 5];  
Magic Number,Spine,ColorTimeline,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Animation.cs,setFrame,The following statement contains a magic number: frameIndex *= 5;  
Magic Number,Spine,ColorTimeline,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Animation.cs,setFrame,The following statement contains a magic number: frames [frameIndex + 2] = g;  
Magic Number,Spine,ColorTimeline,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Animation.cs,setFrame,The following statement contains a magic number: frames [frameIndex + 3] = b;  
Magic Number,Spine,ColorTimeline,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Animation.cs,setFrame,The following statement contains a magic number: frames [frameIndex + 4] = a;  
Magic Number,Spine,ColorTimeline,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: if (time >= frames [frames.Length - 5]) {  	// Time is after last frame.  	int i = frames.Length - 1;  	slot.r = frames [i - 3];  	slot.g = frames [i - 2];  	slot.b = frames [i - 1];  	slot.a = frames [i];  	return;  }  
Magic Number,Spine,ColorTimeline,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: if (time >= frames [frames.Length - 5]) {  	// Time is after last frame.  	int i = frames.Length - 1;  	slot.r = frames [i - 3];  	slot.g = frames [i - 2];  	slot.b = frames [i - 1];  	slot.a = frames [i];  	return;  }  
Magic Number,Spine,ColorTimeline,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: if (time >= frames [frames.Length - 5]) {  	// Time is after last frame.  	int i = frames.Length - 1;  	slot.r = frames [i - 3];  	slot.g = frames [i - 2];  	slot.b = frames [i - 1];  	slot.a = frames [i];  	return;  }  
Magic Number,Spine,ColorTimeline,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: slot.r = frames [i - 3];  
Magic Number,Spine,ColorTimeline,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: slot.g = frames [i - 2];  
Magic Number,Spine,ColorTimeline,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Animation.cs,Apply,The following statement contains a magic number: percent = GetCurvePercent (frameIndex / 5 - 1' percent < 0 ? 0 : (percent > 1 ? 1 : percent));  
Magic Number,Spine,Atlas,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Atlas.cs,Load,The following statement contains a magic number: while (true) {  	String line = reader.ReadLine ();  	if (line == null)  		break;  	if (line.Trim ().Length == 0)  		page = null;  	else if (page == null) {  		page = new AtlasPage ();  		page.name = line;  		page.format = (Format)Enum.Parse (typeof(Format)' readValue (reader)' false);  		readTuple (reader' tuple);  		page.minFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [0]' false);  		page.magFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [1]' false);  		String direction = readValue (reader);  		page.uWrap = TextureWrap.ClampToEdge;  		page.vWrap = TextureWrap.ClampToEdge;  		if (direction == "x")  			page.uWrap = TextureWrap.Repeat;  		else if (direction == "y")  			page.vWrap = TextureWrap.Repeat;  		else if (direction == "xy")  			page.uWrap = page.vWrap = TextureWrap.Repeat;  		textureLoader.Load (page' Path.Combine (imagesDir' line));  		pages.Add (page);  	}  	else {  		AtlasRegion region = new AtlasRegion ();  		region.name = line;  		region.page = page;  		region.rotate = Boolean.Parse (readValue (reader));  		readTuple (reader' tuple);  		int x = int.Parse (tuple [0]);  		int y = int.Parse (tuple [1]);  		readTuple (reader' tuple);  		int width = int.Parse (tuple [0]);  		int height = int.Parse (tuple [1]);  		region.u = x / (float)page.width;  		region.v = y / (float)page.height;  		if (region.rotate) {  			region.u2 = (x + height) / (float)page.width;  			region.v2 = (y + width) / (float)page.height;  		}  		else {  			region.u2 = (x + width) / (float)page.width;  			region.v2 = (y + height) / (float)page.height;  		}  		region.x = x;  		region.y = y;  		region.width = Math.Abs (width);  		region.height = Math.Abs (height);  		if (readTuple (reader' tuple) == 4) {  			// split is optional  			region.splits = new int[] {  				int.Parse (tuple [0])'  				int.Parse (tuple [1])'  				int.Parse (tuple [2])'  				int.Parse (tuple [3])  			};  			if (readTuple (reader' tuple) == 4) {  				// pad is optional' but only present with splits  				region.pads = new int[] {  					int.Parse (tuple [0])'  					int.Parse (tuple [1])'  					int.Parse (tuple [2])'  					int.Parse (tuple [3])  				};  				readTuple (reader' tuple);  			}  		}  		region.originalWidth = int.Parse (tuple [0]);  		region.originalHeight = int.Parse (tuple [1]);  		readTuple (reader' tuple);  		region.offsetX = int.Parse (tuple [0]);  		region.offsetY = int.Parse (tuple [1]);  		region.index = int.Parse (readValue (reader));  		regions.Add (region);  	}  }  
Magic Number,Spine,Atlas,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Atlas.cs,Load,The following statement contains a magic number: while (true) {  	String line = reader.ReadLine ();  	if (line == null)  		break;  	if (line.Trim ().Length == 0)  		page = null;  	else if (page == null) {  		page = new AtlasPage ();  		page.name = line;  		page.format = (Format)Enum.Parse (typeof(Format)' readValue (reader)' false);  		readTuple (reader' tuple);  		page.minFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [0]' false);  		page.magFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [1]' false);  		String direction = readValue (reader);  		page.uWrap = TextureWrap.ClampToEdge;  		page.vWrap = TextureWrap.ClampToEdge;  		if (direction == "x")  			page.uWrap = TextureWrap.Repeat;  		else if (direction == "y")  			page.vWrap = TextureWrap.Repeat;  		else if (direction == "xy")  			page.uWrap = page.vWrap = TextureWrap.Repeat;  		textureLoader.Load (page' Path.Combine (imagesDir' line));  		pages.Add (page);  	}  	else {  		AtlasRegion region = new AtlasRegion ();  		region.name = line;  		region.page = page;  		region.rotate = Boolean.Parse (readValue (reader));  		readTuple (reader' tuple);  		int x = int.Parse (tuple [0]);  		int y = int.Parse (tuple [1]);  		readTuple (reader' tuple);  		int width = int.Parse (tuple [0]);  		int height = int.Parse (tuple [1]);  		region.u = x / (float)page.width;  		region.v = y / (float)page.height;  		if (region.rotate) {  			region.u2 = (x + height) / (float)page.width;  			region.v2 = (y + width) / (float)page.height;  		}  		else {  			region.u2 = (x + width) / (float)page.width;  			region.v2 = (y + height) / (float)page.height;  		}  		region.x = x;  		region.y = y;  		region.width = Math.Abs (width);  		region.height = Math.Abs (height);  		if (readTuple (reader' tuple) == 4) {  			// split is optional  			region.splits = new int[] {  				int.Parse (tuple [0])'  				int.Parse (tuple [1])'  				int.Parse (tuple [2])'  				int.Parse (tuple [3])  			};  			if (readTuple (reader' tuple) == 4) {  				// pad is optional' but only present with splits  				region.pads = new int[] {  					int.Parse (tuple [0])'  					int.Parse (tuple [1])'  					int.Parse (tuple [2])'  					int.Parse (tuple [3])  				};  				readTuple (reader' tuple);  			}  		}  		region.originalWidth = int.Parse (tuple [0]);  		region.originalHeight = int.Parse (tuple [1]);  		readTuple (reader' tuple);  		region.offsetX = int.Parse (tuple [0]);  		region.offsetY = int.Parse (tuple [1]);  		region.index = int.Parse (readValue (reader));  		regions.Add (region);  	}  }  
Magic Number,Spine,Atlas,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Atlas.cs,Load,The following statement contains a magic number: while (true) {  	String line = reader.ReadLine ();  	if (line == null)  		break;  	if (line.Trim ().Length == 0)  		page = null;  	else if (page == null) {  		page = new AtlasPage ();  		page.name = line;  		page.format = (Format)Enum.Parse (typeof(Format)' readValue (reader)' false);  		readTuple (reader' tuple);  		page.minFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [0]' false);  		page.magFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [1]' false);  		String direction = readValue (reader);  		page.uWrap = TextureWrap.ClampToEdge;  		page.vWrap = TextureWrap.ClampToEdge;  		if (direction == "x")  			page.uWrap = TextureWrap.Repeat;  		else if (direction == "y")  			page.vWrap = TextureWrap.Repeat;  		else if (direction == "xy")  			page.uWrap = page.vWrap = TextureWrap.Repeat;  		textureLoader.Load (page' Path.Combine (imagesDir' line));  		pages.Add (page);  	}  	else {  		AtlasRegion region = new AtlasRegion ();  		region.name = line;  		region.page = page;  		region.rotate = Boolean.Parse (readValue (reader));  		readTuple (reader' tuple);  		int x = int.Parse (tuple [0]);  		int y = int.Parse (tuple [1]);  		readTuple (reader' tuple);  		int width = int.Parse (tuple [0]);  		int height = int.Parse (tuple [1]);  		region.u = x / (float)page.width;  		region.v = y / (float)page.height;  		if (region.rotate) {  			region.u2 = (x + height) / (float)page.width;  			region.v2 = (y + width) / (float)page.height;  		}  		else {  			region.u2 = (x + width) / (float)page.width;  			region.v2 = (y + height) / (float)page.height;  		}  		region.x = x;  		region.y = y;  		region.width = Math.Abs (width);  		region.height = Math.Abs (height);  		if (readTuple (reader' tuple) == 4) {  			// split is optional  			region.splits = new int[] {  				int.Parse (tuple [0])'  				int.Parse (tuple [1])'  				int.Parse (tuple [2])'  				int.Parse (tuple [3])  			};  			if (readTuple (reader' tuple) == 4) {  				// pad is optional' but only present with splits  				region.pads = new int[] {  					int.Parse (tuple [0])'  					int.Parse (tuple [1])'  					int.Parse (tuple [2])'  					int.Parse (tuple [3])  				};  				readTuple (reader' tuple);  			}  		}  		region.originalWidth = int.Parse (tuple [0]);  		region.originalHeight = int.Parse (tuple [1]);  		readTuple (reader' tuple);  		region.offsetX = int.Parse (tuple [0]);  		region.offsetY = int.Parse (tuple [1]);  		region.index = int.Parse (readValue (reader));  		regions.Add (region);  	}  }  
Magic Number,Spine,Atlas,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Atlas.cs,Load,The following statement contains a magic number: while (true) {  	String line = reader.ReadLine ();  	if (line == null)  		break;  	if (line.Trim ().Length == 0)  		page = null;  	else if (page == null) {  		page = new AtlasPage ();  		page.name = line;  		page.format = (Format)Enum.Parse (typeof(Format)' readValue (reader)' false);  		readTuple (reader' tuple);  		page.minFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [0]' false);  		page.magFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [1]' false);  		String direction = readValue (reader);  		page.uWrap = TextureWrap.ClampToEdge;  		page.vWrap = TextureWrap.ClampToEdge;  		if (direction == "x")  			page.uWrap = TextureWrap.Repeat;  		else if (direction == "y")  			page.vWrap = TextureWrap.Repeat;  		else if (direction == "xy")  			page.uWrap = page.vWrap = TextureWrap.Repeat;  		textureLoader.Load (page' Path.Combine (imagesDir' line));  		pages.Add (page);  	}  	else {  		AtlasRegion region = new AtlasRegion ();  		region.name = line;  		region.page = page;  		region.rotate = Boolean.Parse (readValue (reader));  		readTuple (reader' tuple);  		int x = int.Parse (tuple [0]);  		int y = int.Parse (tuple [1]);  		readTuple (reader' tuple);  		int width = int.Parse (tuple [0]);  		int height = int.Parse (tuple [1]);  		region.u = x / (float)page.width;  		region.v = y / (float)page.height;  		if (region.rotate) {  			region.u2 = (x + height) / (float)page.width;  			region.v2 = (y + width) / (float)page.height;  		}  		else {  			region.u2 = (x + width) / (float)page.width;  			region.v2 = (y + height) / (float)page.height;  		}  		region.x = x;  		region.y = y;  		region.width = Math.Abs (width);  		region.height = Math.Abs (height);  		if (readTuple (reader' tuple) == 4) {  			// split is optional  			region.splits = new int[] {  				int.Parse (tuple [0])'  				int.Parse (tuple [1])'  				int.Parse (tuple [2])'  				int.Parse (tuple [3])  			};  			if (readTuple (reader' tuple) == 4) {  				// pad is optional' but only present with splits  				region.pads = new int[] {  					int.Parse (tuple [0])'  					int.Parse (tuple [1])'  					int.Parse (tuple [2])'  					int.Parse (tuple [3])  				};  				readTuple (reader' tuple);  			}  		}  		region.originalWidth = int.Parse (tuple [0]);  		region.originalHeight = int.Parse (tuple [1]);  		readTuple (reader' tuple);  		region.offsetX = int.Parse (tuple [0]);  		region.offsetY = int.Parse (tuple [1]);  		region.index = int.Parse (readValue (reader));  		regions.Add (region);  	}  }  
Magic Number,Spine,Atlas,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Atlas.cs,Load,The following statement contains a magic number: while (true) {  	String line = reader.ReadLine ();  	if (line == null)  		break;  	if (line.Trim ().Length == 0)  		page = null;  	else if (page == null) {  		page = new AtlasPage ();  		page.name = line;  		page.format = (Format)Enum.Parse (typeof(Format)' readValue (reader)' false);  		readTuple (reader' tuple);  		page.minFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [0]' false);  		page.magFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [1]' false);  		String direction = readValue (reader);  		page.uWrap = TextureWrap.ClampToEdge;  		page.vWrap = TextureWrap.ClampToEdge;  		if (direction == "x")  			page.uWrap = TextureWrap.Repeat;  		else if (direction == "y")  			page.vWrap = TextureWrap.Repeat;  		else if (direction == "xy")  			page.uWrap = page.vWrap = TextureWrap.Repeat;  		textureLoader.Load (page' Path.Combine (imagesDir' line));  		pages.Add (page);  	}  	else {  		AtlasRegion region = new AtlasRegion ();  		region.name = line;  		region.page = page;  		region.rotate = Boolean.Parse (readValue (reader));  		readTuple (reader' tuple);  		int x = int.Parse (tuple [0]);  		int y = int.Parse (tuple [1]);  		readTuple (reader' tuple);  		int width = int.Parse (tuple [0]);  		int height = int.Parse (tuple [1]);  		region.u = x / (float)page.width;  		region.v = y / (float)page.height;  		if (region.rotate) {  			region.u2 = (x + height) / (float)page.width;  			region.v2 = (y + width) / (float)page.height;  		}  		else {  			region.u2 = (x + width) / (float)page.width;  			region.v2 = (y + height) / (float)page.height;  		}  		region.x = x;  		region.y = y;  		region.width = Math.Abs (width);  		region.height = Math.Abs (height);  		if (readTuple (reader' tuple) == 4) {  			// split is optional  			region.splits = new int[] {  				int.Parse (tuple [0])'  				int.Parse (tuple [1])'  				int.Parse (tuple [2])'  				int.Parse (tuple [3])  			};  			if (readTuple (reader' tuple) == 4) {  				// pad is optional' but only present with splits  				region.pads = new int[] {  					int.Parse (tuple [0])'  					int.Parse (tuple [1])'  					int.Parse (tuple [2])'  					int.Parse (tuple [3])  				};  				readTuple (reader' tuple);  			}  		}  		region.originalWidth = int.Parse (tuple [0]);  		region.originalHeight = int.Parse (tuple [1]);  		readTuple (reader' tuple);  		region.offsetX = int.Parse (tuple [0]);  		region.offsetY = int.Parse (tuple [1]);  		region.index = int.Parse (readValue (reader));  		regions.Add (region);  	}  }  
Magic Number,Spine,Atlas,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Atlas.cs,Load,The following statement contains a magic number: while (true) {  	String line = reader.ReadLine ();  	if (line == null)  		break;  	if (line.Trim ().Length == 0)  		page = null;  	else if (page == null) {  		page = new AtlasPage ();  		page.name = line;  		page.format = (Format)Enum.Parse (typeof(Format)' readValue (reader)' false);  		readTuple (reader' tuple);  		page.minFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [0]' false);  		page.magFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [1]' false);  		String direction = readValue (reader);  		page.uWrap = TextureWrap.ClampToEdge;  		page.vWrap = TextureWrap.ClampToEdge;  		if (direction == "x")  			page.uWrap = TextureWrap.Repeat;  		else if (direction == "y")  			page.vWrap = TextureWrap.Repeat;  		else if (direction == "xy")  			page.uWrap = page.vWrap = TextureWrap.Repeat;  		textureLoader.Load (page' Path.Combine (imagesDir' line));  		pages.Add (page);  	}  	else {  		AtlasRegion region = new AtlasRegion ();  		region.name = line;  		region.page = page;  		region.rotate = Boolean.Parse (readValue (reader));  		readTuple (reader' tuple);  		int x = int.Parse (tuple [0]);  		int y = int.Parse (tuple [1]);  		readTuple (reader' tuple);  		int width = int.Parse (tuple [0]);  		int height = int.Parse (tuple [1]);  		region.u = x / (float)page.width;  		region.v = y / (float)page.height;  		if (region.rotate) {  			region.u2 = (x + height) / (float)page.width;  			region.v2 = (y + width) / (float)page.height;  		}  		else {  			region.u2 = (x + width) / (float)page.width;  			region.v2 = (y + height) / (float)page.height;  		}  		region.x = x;  		region.y = y;  		region.width = Math.Abs (width);  		region.height = Math.Abs (height);  		if (readTuple (reader' tuple) == 4) {  			// split is optional  			region.splits = new int[] {  				int.Parse (tuple [0])'  				int.Parse (tuple [1])'  				int.Parse (tuple [2])'  				int.Parse (tuple [3])  			};  			if (readTuple (reader' tuple) == 4) {  				// pad is optional' but only present with splits  				region.pads = new int[] {  					int.Parse (tuple [0])'  					int.Parse (tuple [1])'  					int.Parse (tuple [2])'  					int.Parse (tuple [3])  				};  				readTuple (reader' tuple);  			}  		}  		region.originalWidth = int.Parse (tuple [0]);  		region.originalHeight = int.Parse (tuple [1]);  		readTuple (reader' tuple);  		region.offsetX = int.Parse (tuple [0]);  		region.offsetY = int.Parse (tuple [1]);  		region.index = int.Parse (readValue (reader));  		regions.Add (region);  	}  }  
Magic Number,Spine,Atlas,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Atlas.cs,Load,The following statement contains a magic number: if (line.Trim ().Length == 0)  	page = null;  else if (page == null) {  	page = new AtlasPage ();  	page.name = line;  	page.format = (Format)Enum.Parse (typeof(Format)' readValue (reader)' false);  	readTuple (reader' tuple);  	page.minFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [0]' false);  	page.magFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [1]' false);  	String direction = readValue (reader);  	page.uWrap = TextureWrap.ClampToEdge;  	page.vWrap = TextureWrap.ClampToEdge;  	if (direction == "x")  		page.uWrap = TextureWrap.Repeat;  	else if (direction == "y")  		page.vWrap = TextureWrap.Repeat;  	else if (direction == "xy")  		page.uWrap = page.vWrap = TextureWrap.Repeat;  	textureLoader.Load (page' Path.Combine (imagesDir' line));  	pages.Add (page);  }  else {  	AtlasRegion region = new AtlasRegion ();  	region.name = line;  	region.page = page;  	region.rotate = Boolean.Parse (readValue (reader));  	readTuple (reader' tuple);  	int x = int.Parse (tuple [0]);  	int y = int.Parse (tuple [1]);  	readTuple (reader' tuple);  	int width = int.Parse (tuple [0]);  	int height = int.Parse (tuple [1]);  	region.u = x / (float)page.width;  	region.v = y / (float)page.height;  	if (region.rotate) {  		region.u2 = (x + height) / (float)page.width;  		region.v2 = (y + width) / (float)page.height;  	}  	else {  		region.u2 = (x + width) / (float)page.width;  		region.v2 = (y + height) / (float)page.height;  	}  	region.x = x;  	region.y = y;  	region.width = Math.Abs (width);  	region.height = Math.Abs (height);  	if (readTuple (reader' tuple) == 4) {  		// split is optional  		region.splits = new int[] {  			int.Parse (tuple [0])'  			int.Parse (tuple [1])'  			int.Parse (tuple [2])'  			int.Parse (tuple [3])  		};  		if (readTuple (reader' tuple) == 4) {  			// pad is optional' but only present with splits  			region.pads = new int[] {  				int.Parse (tuple [0])'  				int.Parse (tuple [1])'  				int.Parse (tuple [2])'  				int.Parse (tuple [3])  			};  			readTuple (reader' tuple);  		}  	}  	region.originalWidth = int.Parse (tuple [0]);  	region.originalHeight = int.Parse (tuple [1]);  	readTuple (reader' tuple);  	region.offsetX = int.Parse (tuple [0]);  	region.offsetY = int.Parse (tuple [1]);  	region.index = int.Parse (readValue (reader));  	regions.Add (region);  }  
Magic Number,Spine,Atlas,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Atlas.cs,Load,The following statement contains a magic number: if (line.Trim ().Length == 0)  	page = null;  else if (page == null) {  	page = new AtlasPage ();  	page.name = line;  	page.format = (Format)Enum.Parse (typeof(Format)' readValue (reader)' false);  	readTuple (reader' tuple);  	page.minFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [0]' false);  	page.magFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [1]' false);  	String direction = readValue (reader);  	page.uWrap = TextureWrap.ClampToEdge;  	page.vWrap = TextureWrap.ClampToEdge;  	if (direction == "x")  		page.uWrap = TextureWrap.Repeat;  	else if (direction == "y")  		page.vWrap = TextureWrap.Repeat;  	else if (direction == "xy")  		page.uWrap = page.vWrap = TextureWrap.Repeat;  	textureLoader.Load (page' Path.Combine (imagesDir' line));  	pages.Add (page);  }  else {  	AtlasRegion region = new AtlasRegion ();  	region.name = line;  	region.page = page;  	region.rotate = Boolean.Parse (readValue (reader));  	readTuple (reader' tuple);  	int x = int.Parse (tuple [0]);  	int y = int.Parse (tuple [1]);  	readTuple (reader' tuple);  	int width = int.Parse (tuple [0]);  	int height = int.Parse (tuple [1]);  	region.u = x / (float)page.width;  	region.v = y / (float)page.height;  	if (region.rotate) {  		region.u2 = (x + height) / (float)page.width;  		region.v2 = (y + width) / (float)page.height;  	}  	else {  		region.u2 = (x + width) / (float)page.width;  		region.v2 = (y + height) / (float)page.height;  	}  	region.x = x;  	region.y = y;  	region.width = Math.Abs (width);  	region.height = Math.Abs (height);  	if (readTuple (reader' tuple) == 4) {  		// split is optional  		region.splits = new int[] {  			int.Parse (tuple [0])'  			int.Parse (tuple [1])'  			int.Parse (tuple [2])'  			int.Parse (tuple [3])  		};  		if (readTuple (reader' tuple) == 4) {  			// pad is optional' but only present with splits  			region.pads = new int[] {  				int.Parse (tuple [0])'  				int.Parse (tuple [1])'  				int.Parse (tuple [2])'  				int.Parse (tuple [3])  			};  			readTuple (reader' tuple);  		}  	}  	region.originalWidth = int.Parse (tuple [0]);  	region.originalHeight = int.Parse (tuple [1]);  	readTuple (reader' tuple);  	region.offsetX = int.Parse (tuple [0]);  	region.offsetY = int.Parse (tuple [1]);  	region.index = int.Parse (readValue (reader));  	regions.Add (region);  }  
Magic Number,Spine,Atlas,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Atlas.cs,Load,The following statement contains a magic number: if (line.Trim ().Length == 0)  	page = null;  else if (page == null) {  	page = new AtlasPage ();  	page.name = line;  	page.format = (Format)Enum.Parse (typeof(Format)' readValue (reader)' false);  	readTuple (reader' tuple);  	page.minFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [0]' false);  	page.magFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [1]' false);  	String direction = readValue (reader);  	page.uWrap = TextureWrap.ClampToEdge;  	page.vWrap = TextureWrap.ClampToEdge;  	if (direction == "x")  		page.uWrap = TextureWrap.Repeat;  	else if (direction == "y")  		page.vWrap = TextureWrap.Repeat;  	else if (direction == "xy")  		page.uWrap = page.vWrap = TextureWrap.Repeat;  	textureLoader.Load (page' Path.Combine (imagesDir' line));  	pages.Add (page);  }  else {  	AtlasRegion region = new AtlasRegion ();  	region.name = line;  	region.page = page;  	region.rotate = Boolean.Parse (readValue (reader));  	readTuple (reader' tuple);  	int x = int.Parse (tuple [0]);  	int y = int.Parse (tuple [1]);  	readTuple (reader' tuple);  	int width = int.Parse (tuple [0]);  	int height = int.Parse (tuple [1]);  	region.u = x / (float)page.width;  	region.v = y / (float)page.height;  	if (region.rotate) {  		region.u2 = (x + height) / (float)page.width;  		region.v2 = (y + width) / (float)page.height;  	}  	else {  		region.u2 = (x + width) / (float)page.width;  		region.v2 = (y + height) / (float)page.height;  	}  	region.x = x;  	region.y = y;  	region.width = Math.Abs (width);  	region.height = Math.Abs (height);  	if (readTuple (reader' tuple) == 4) {  		// split is optional  		region.splits = new int[] {  			int.Parse (tuple [0])'  			int.Parse (tuple [1])'  			int.Parse (tuple [2])'  			int.Parse (tuple [3])  		};  		if (readTuple (reader' tuple) == 4) {  			// pad is optional' but only present with splits  			region.pads = new int[] {  				int.Parse (tuple [0])'  				int.Parse (tuple [1])'  				int.Parse (tuple [2])'  				int.Parse (tuple [3])  			};  			readTuple (reader' tuple);  		}  	}  	region.originalWidth = int.Parse (tuple [0]);  	region.originalHeight = int.Parse (tuple [1]);  	readTuple (reader' tuple);  	region.offsetX = int.Parse (tuple [0]);  	region.offsetY = int.Parse (tuple [1]);  	region.index = int.Parse (readValue (reader));  	regions.Add (region);  }  
Magic Number,Spine,Atlas,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Atlas.cs,Load,The following statement contains a magic number: if (line.Trim ().Length == 0)  	page = null;  else if (page == null) {  	page = new AtlasPage ();  	page.name = line;  	page.format = (Format)Enum.Parse (typeof(Format)' readValue (reader)' false);  	readTuple (reader' tuple);  	page.minFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [0]' false);  	page.magFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [1]' false);  	String direction = readValue (reader);  	page.uWrap = TextureWrap.ClampToEdge;  	page.vWrap = TextureWrap.ClampToEdge;  	if (direction == "x")  		page.uWrap = TextureWrap.Repeat;  	else if (direction == "y")  		page.vWrap = TextureWrap.Repeat;  	else if (direction == "xy")  		page.uWrap = page.vWrap = TextureWrap.Repeat;  	textureLoader.Load (page' Path.Combine (imagesDir' line));  	pages.Add (page);  }  else {  	AtlasRegion region = new AtlasRegion ();  	region.name = line;  	region.page = page;  	region.rotate = Boolean.Parse (readValue (reader));  	readTuple (reader' tuple);  	int x = int.Parse (tuple [0]);  	int y = int.Parse (tuple [1]);  	readTuple (reader' tuple);  	int width = int.Parse (tuple [0]);  	int height = int.Parse (tuple [1]);  	region.u = x / (float)page.width;  	region.v = y / (float)page.height;  	if (region.rotate) {  		region.u2 = (x + height) / (float)page.width;  		region.v2 = (y + width) / (float)page.height;  	}  	else {  		region.u2 = (x + width) / (float)page.width;  		region.v2 = (y + height) / (float)page.height;  	}  	region.x = x;  	region.y = y;  	region.width = Math.Abs (width);  	region.height = Math.Abs (height);  	if (readTuple (reader' tuple) == 4) {  		// split is optional  		region.splits = new int[] {  			int.Parse (tuple [0])'  			int.Parse (tuple [1])'  			int.Parse (tuple [2])'  			int.Parse (tuple [3])  		};  		if (readTuple (reader' tuple) == 4) {  			// pad is optional' but only present with splits  			region.pads = new int[] {  				int.Parse (tuple [0])'  				int.Parse (tuple [1])'  				int.Parse (tuple [2])'  				int.Parse (tuple [3])  			};  			readTuple (reader' tuple);  		}  	}  	region.originalWidth = int.Parse (tuple [0]);  	region.originalHeight = int.Parse (tuple [1]);  	readTuple (reader' tuple);  	region.offsetX = int.Parse (tuple [0]);  	region.offsetY = int.Parse (tuple [1]);  	region.index = int.Parse (readValue (reader));  	regions.Add (region);  }  
Magic Number,Spine,Atlas,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Atlas.cs,Load,The following statement contains a magic number: if (line.Trim ().Length == 0)  	page = null;  else if (page == null) {  	page = new AtlasPage ();  	page.name = line;  	page.format = (Format)Enum.Parse (typeof(Format)' readValue (reader)' false);  	readTuple (reader' tuple);  	page.minFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [0]' false);  	page.magFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [1]' false);  	String direction = readValue (reader);  	page.uWrap = TextureWrap.ClampToEdge;  	page.vWrap = TextureWrap.ClampToEdge;  	if (direction == "x")  		page.uWrap = TextureWrap.Repeat;  	else if (direction == "y")  		page.vWrap = TextureWrap.Repeat;  	else if (direction == "xy")  		page.uWrap = page.vWrap = TextureWrap.Repeat;  	textureLoader.Load (page' Path.Combine (imagesDir' line));  	pages.Add (page);  }  else {  	AtlasRegion region = new AtlasRegion ();  	region.name = line;  	region.page = page;  	region.rotate = Boolean.Parse (readValue (reader));  	readTuple (reader' tuple);  	int x = int.Parse (tuple [0]);  	int y = int.Parse (tuple [1]);  	readTuple (reader' tuple);  	int width = int.Parse (tuple [0]);  	int height = int.Parse (tuple [1]);  	region.u = x / (float)page.width;  	region.v = y / (float)page.height;  	if (region.rotate) {  		region.u2 = (x + height) / (float)page.width;  		region.v2 = (y + width) / (float)page.height;  	}  	else {  		region.u2 = (x + width) / (float)page.width;  		region.v2 = (y + height) / (float)page.height;  	}  	region.x = x;  	region.y = y;  	region.width = Math.Abs (width);  	region.height = Math.Abs (height);  	if (readTuple (reader' tuple) == 4) {  		// split is optional  		region.splits = new int[] {  			int.Parse (tuple [0])'  			int.Parse (tuple [1])'  			int.Parse (tuple [2])'  			int.Parse (tuple [3])  		};  		if (readTuple (reader' tuple) == 4) {  			// pad is optional' but only present with splits  			region.pads = new int[] {  				int.Parse (tuple [0])'  				int.Parse (tuple [1])'  				int.Parse (tuple [2])'  				int.Parse (tuple [3])  			};  			readTuple (reader' tuple);  		}  	}  	region.originalWidth = int.Parse (tuple [0]);  	region.originalHeight = int.Parse (tuple [1]);  	readTuple (reader' tuple);  	region.offsetX = int.Parse (tuple [0]);  	region.offsetY = int.Parse (tuple [1]);  	region.index = int.Parse (readValue (reader));  	regions.Add (region);  }  
Magic Number,Spine,Atlas,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Atlas.cs,Load,The following statement contains a magic number: if (line.Trim ().Length == 0)  	page = null;  else if (page == null) {  	page = new AtlasPage ();  	page.name = line;  	page.format = (Format)Enum.Parse (typeof(Format)' readValue (reader)' false);  	readTuple (reader' tuple);  	page.minFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [0]' false);  	page.magFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [1]' false);  	String direction = readValue (reader);  	page.uWrap = TextureWrap.ClampToEdge;  	page.vWrap = TextureWrap.ClampToEdge;  	if (direction == "x")  		page.uWrap = TextureWrap.Repeat;  	else if (direction == "y")  		page.vWrap = TextureWrap.Repeat;  	else if (direction == "xy")  		page.uWrap = page.vWrap = TextureWrap.Repeat;  	textureLoader.Load (page' Path.Combine (imagesDir' line));  	pages.Add (page);  }  else {  	AtlasRegion region = new AtlasRegion ();  	region.name = line;  	region.page = page;  	region.rotate = Boolean.Parse (readValue (reader));  	readTuple (reader' tuple);  	int x = int.Parse (tuple [0]);  	int y = int.Parse (tuple [1]);  	readTuple (reader' tuple);  	int width = int.Parse (tuple [0]);  	int height = int.Parse (tuple [1]);  	region.u = x / (float)page.width;  	region.v = y / (float)page.height;  	if (region.rotate) {  		region.u2 = (x + height) / (float)page.width;  		region.v2 = (y + width) / (float)page.height;  	}  	else {  		region.u2 = (x + width) / (float)page.width;  		region.v2 = (y + height) / (float)page.height;  	}  	region.x = x;  	region.y = y;  	region.width = Math.Abs (width);  	region.height = Math.Abs (height);  	if (readTuple (reader' tuple) == 4) {  		// split is optional  		region.splits = new int[] {  			int.Parse (tuple [0])'  			int.Parse (tuple [1])'  			int.Parse (tuple [2])'  			int.Parse (tuple [3])  		};  		if (readTuple (reader' tuple) == 4) {  			// pad is optional' but only present with splits  			region.pads = new int[] {  				int.Parse (tuple [0])'  				int.Parse (tuple [1])'  				int.Parse (tuple [2])'  				int.Parse (tuple [3])  			};  			readTuple (reader' tuple);  		}  	}  	region.originalWidth = int.Parse (tuple [0]);  	region.originalHeight = int.Parse (tuple [1]);  	readTuple (reader' tuple);  	region.offsetX = int.Parse (tuple [0]);  	region.offsetY = int.Parse (tuple [1]);  	region.index = int.Parse (readValue (reader));  	regions.Add (region);  }  
Magic Number,Spine,Atlas,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Atlas.cs,Load,The following statement contains a magic number: if (page == null) {  	page = new AtlasPage ();  	page.name = line;  	page.format = (Format)Enum.Parse (typeof(Format)' readValue (reader)' false);  	readTuple (reader' tuple);  	page.minFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [0]' false);  	page.magFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [1]' false);  	String direction = readValue (reader);  	page.uWrap = TextureWrap.ClampToEdge;  	page.vWrap = TextureWrap.ClampToEdge;  	if (direction == "x")  		page.uWrap = TextureWrap.Repeat;  	else if (direction == "y")  		page.vWrap = TextureWrap.Repeat;  	else if (direction == "xy")  		page.uWrap = page.vWrap = TextureWrap.Repeat;  	textureLoader.Load (page' Path.Combine (imagesDir' line));  	pages.Add (page);  }  else {  	AtlasRegion region = new AtlasRegion ();  	region.name = line;  	region.page = page;  	region.rotate = Boolean.Parse (readValue (reader));  	readTuple (reader' tuple);  	int x = int.Parse (tuple [0]);  	int y = int.Parse (tuple [1]);  	readTuple (reader' tuple);  	int width = int.Parse (tuple [0]);  	int height = int.Parse (tuple [1]);  	region.u = x / (float)page.width;  	region.v = y / (float)page.height;  	if (region.rotate) {  		region.u2 = (x + height) / (float)page.width;  		region.v2 = (y + width) / (float)page.height;  	}  	else {  		region.u2 = (x + width) / (float)page.width;  		region.v2 = (y + height) / (float)page.height;  	}  	region.x = x;  	region.y = y;  	region.width = Math.Abs (width);  	region.height = Math.Abs (height);  	if (readTuple (reader' tuple) == 4) {  		// split is optional  		region.splits = new int[] {  			int.Parse (tuple [0])'  			int.Parse (tuple [1])'  			int.Parse (tuple [2])'  			int.Parse (tuple [3])  		};  		if (readTuple (reader' tuple) == 4) {  			// pad is optional' but only present with splits  			region.pads = new int[] {  				int.Parse (tuple [0])'  				int.Parse (tuple [1])'  				int.Parse (tuple [2])'  				int.Parse (tuple [3])  			};  			readTuple (reader' tuple);  		}  	}  	region.originalWidth = int.Parse (tuple [0]);  	region.originalHeight = int.Parse (tuple [1]);  	readTuple (reader' tuple);  	region.offsetX = int.Parse (tuple [0]);  	region.offsetY = int.Parse (tuple [1]);  	region.index = int.Parse (readValue (reader));  	regions.Add (region);  }  
Magic Number,Spine,Atlas,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Atlas.cs,Load,The following statement contains a magic number: if (page == null) {  	page = new AtlasPage ();  	page.name = line;  	page.format = (Format)Enum.Parse (typeof(Format)' readValue (reader)' false);  	readTuple (reader' tuple);  	page.minFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [0]' false);  	page.magFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [1]' false);  	String direction = readValue (reader);  	page.uWrap = TextureWrap.ClampToEdge;  	page.vWrap = TextureWrap.ClampToEdge;  	if (direction == "x")  		page.uWrap = TextureWrap.Repeat;  	else if (direction == "y")  		page.vWrap = TextureWrap.Repeat;  	else if (direction == "xy")  		page.uWrap = page.vWrap = TextureWrap.Repeat;  	textureLoader.Load (page' Path.Combine (imagesDir' line));  	pages.Add (page);  }  else {  	AtlasRegion region = new AtlasRegion ();  	region.name = line;  	region.page = page;  	region.rotate = Boolean.Parse (readValue (reader));  	readTuple (reader' tuple);  	int x = int.Parse (tuple [0]);  	int y = int.Parse (tuple [1]);  	readTuple (reader' tuple);  	int width = int.Parse (tuple [0]);  	int height = int.Parse (tuple [1]);  	region.u = x / (float)page.width;  	region.v = y / (float)page.height;  	if (region.rotate) {  		region.u2 = (x + height) / (float)page.width;  		region.v2 = (y + width) / (float)page.height;  	}  	else {  		region.u2 = (x + width) / (float)page.width;  		region.v2 = (y + height) / (float)page.height;  	}  	region.x = x;  	region.y = y;  	region.width = Math.Abs (width);  	region.height = Math.Abs (height);  	if (readTuple (reader' tuple) == 4) {  		// split is optional  		region.splits = new int[] {  			int.Parse (tuple [0])'  			int.Parse (tuple [1])'  			int.Parse (tuple [2])'  			int.Parse (tuple [3])  		};  		if (readTuple (reader' tuple) == 4) {  			// pad is optional' but only present with splits  			region.pads = new int[] {  				int.Parse (tuple [0])'  				int.Parse (tuple [1])'  				int.Parse (tuple [2])'  				int.Parse (tuple [3])  			};  			readTuple (reader' tuple);  		}  	}  	region.originalWidth = int.Parse (tuple [0]);  	region.originalHeight = int.Parse (tuple [1]);  	readTuple (reader' tuple);  	region.offsetX = int.Parse (tuple [0]);  	region.offsetY = int.Parse (tuple [1]);  	region.index = int.Parse (readValue (reader));  	regions.Add (region);  }  
Magic Number,Spine,Atlas,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Atlas.cs,Load,The following statement contains a magic number: if (page == null) {  	page = new AtlasPage ();  	page.name = line;  	page.format = (Format)Enum.Parse (typeof(Format)' readValue (reader)' false);  	readTuple (reader' tuple);  	page.minFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [0]' false);  	page.magFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [1]' false);  	String direction = readValue (reader);  	page.uWrap = TextureWrap.ClampToEdge;  	page.vWrap = TextureWrap.ClampToEdge;  	if (direction == "x")  		page.uWrap = TextureWrap.Repeat;  	else if (direction == "y")  		page.vWrap = TextureWrap.Repeat;  	else if (direction == "xy")  		page.uWrap = page.vWrap = TextureWrap.Repeat;  	textureLoader.Load (page' Path.Combine (imagesDir' line));  	pages.Add (page);  }  else {  	AtlasRegion region = new AtlasRegion ();  	region.name = line;  	region.page = page;  	region.rotate = Boolean.Parse (readValue (reader));  	readTuple (reader' tuple);  	int x = int.Parse (tuple [0]);  	int y = int.Parse (tuple [1]);  	readTuple (reader' tuple);  	int width = int.Parse (tuple [0]);  	int height = int.Parse (tuple [1]);  	region.u = x / (float)page.width;  	region.v = y / (float)page.height;  	if (region.rotate) {  		region.u2 = (x + height) / (float)page.width;  		region.v2 = (y + width) / (float)page.height;  	}  	else {  		region.u2 = (x + width) / (float)page.width;  		region.v2 = (y + height) / (float)page.height;  	}  	region.x = x;  	region.y = y;  	region.width = Math.Abs (width);  	region.height = Math.Abs (height);  	if (readTuple (reader' tuple) == 4) {  		// split is optional  		region.splits = new int[] {  			int.Parse (tuple [0])'  			int.Parse (tuple [1])'  			int.Parse (tuple [2])'  			int.Parse (tuple [3])  		};  		if (readTuple (reader' tuple) == 4) {  			// pad is optional' but only present with splits  			region.pads = new int[] {  				int.Parse (tuple [0])'  				int.Parse (tuple [1])'  				int.Parse (tuple [2])'  				int.Parse (tuple [3])  			};  			readTuple (reader' tuple);  		}  	}  	region.originalWidth = int.Parse (tuple [0]);  	region.originalHeight = int.Parse (tuple [1]);  	readTuple (reader' tuple);  	region.offsetX = int.Parse (tuple [0]);  	region.offsetY = int.Parse (tuple [1]);  	region.index = int.Parse (readValue (reader));  	regions.Add (region);  }  
Magic Number,Spine,Atlas,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Atlas.cs,Load,The following statement contains a magic number: if (page == null) {  	page = new AtlasPage ();  	page.name = line;  	page.format = (Format)Enum.Parse (typeof(Format)' readValue (reader)' false);  	readTuple (reader' tuple);  	page.minFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [0]' false);  	page.magFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [1]' false);  	String direction = readValue (reader);  	page.uWrap = TextureWrap.ClampToEdge;  	page.vWrap = TextureWrap.ClampToEdge;  	if (direction == "x")  		page.uWrap = TextureWrap.Repeat;  	else if (direction == "y")  		page.vWrap = TextureWrap.Repeat;  	else if (direction == "xy")  		page.uWrap = page.vWrap = TextureWrap.Repeat;  	textureLoader.Load (page' Path.Combine (imagesDir' line));  	pages.Add (page);  }  else {  	AtlasRegion region = new AtlasRegion ();  	region.name = line;  	region.page = page;  	region.rotate = Boolean.Parse (readValue (reader));  	readTuple (reader' tuple);  	int x = int.Parse (tuple [0]);  	int y = int.Parse (tuple [1]);  	readTuple (reader' tuple);  	int width = int.Parse (tuple [0]);  	int height = int.Parse (tuple [1]);  	region.u = x / (float)page.width;  	region.v = y / (float)page.height;  	if (region.rotate) {  		region.u2 = (x + height) / (float)page.width;  		region.v2 = (y + width) / (float)page.height;  	}  	else {  		region.u2 = (x + width) / (float)page.width;  		region.v2 = (y + height) / (float)page.height;  	}  	region.x = x;  	region.y = y;  	region.width = Math.Abs (width);  	region.height = Math.Abs (height);  	if (readTuple (reader' tuple) == 4) {  		// split is optional  		region.splits = new int[] {  			int.Parse (tuple [0])'  			int.Parse (tuple [1])'  			int.Parse (tuple [2])'  			int.Parse (tuple [3])  		};  		if (readTuple (reader' tuple) == 4) {  			// pad is optional' but only present with splits  			region.pads = new int[] {  				int.Parse (tuple [0])'  				int.Parse (tuple [1])'  				int.Parse (tuple [2])'  				int.Parse (tuple [3])  			};  			readTuple (reader' tuple);  		}  	}  	region.originalWidth = int.Parse (tuple [0]);  	region.originalHeight = int.Parse (tuple [1]);  	readTuple (reader' tuple);  	region.offsetX = int.Parse (tuple [0]);  	region.offsetY = int.Parse (tuple [1]);  	region.index = int.Parse (readValue (reader));  	regions.Add (region);  }  
Magic Number,Spine,Atlas,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Atlas.cs,Load,The following statement contains a magic number: if (page == null) {  	page = new AtlasPage ();  	page.name = line;  	page.format = (Format)Enum.Parse (typeof(Format)' readValue (reader)' false);  	readTuple (reader' tuple);  	page.minFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [0]' false);  	page.magFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [1]' false);  	String direction = readValue (reader);  	page.uWrap = TextureWrap.ClampToEdge;  	page.vWrap = TextureWrap.ClampToEdge;  	if (direction == "x")  		page.uWrap = TextureWrap.Repeat;  	else if (direction == "y")  		page.vWrap = TextureWrap.Repeat;  	else if (direction == "xy")  		page.uWrap = page.vWrap = TextureWrap.Repeat;  	textureLoader.Load (page' Path.Combine (imagesDir' line));  	pages.Add (page);  }  else {  	AtlasRegion region = new AtlasRegion ();  	region.name = line;  	region.page = page;  	region.rotate = Boolean.Parse (readValue (reader));  	readTuple (reader' tuple);  	int x = int.Parse (tuple [0]);  	int y = int.Parse (tuple [1]);  	readTuple (reader' tuple);  	int width = int.Parse (tuple [0]);  	int height = int.Parse (tuple [1]);  	region.u = x / (float)page.width;  	region.v = y / (float)page.height;  	if (region.rotate) {  		region.u2 = (x + height) / (float)page.width;  		region.v2 = (y + width) / (float)page.height;  	}  	else {  		region.u2 = (x + width) / (float)page.width;  		region.v2 = (y + height) / (float)page.height;  	}  	region.x = x;  	region.y = y;  	region.width = Math.Abs (width);  	region.height = Math.Abs (height);  	if (readTuple (reader' tuple) == 4) {  		// split is optional  		region.splits = new int[] {  			int.Parse (tuple [0])'  			int.Parse (tuple [1])'  			int.Parse (tuple [2])'  			int.Parse (tuple [3])  		};  		if (readTuple (reader' tuple) == 4) {  			// pad is optional' but only present with splits  			region.pads = new int[] {  				int.Parse (tuple [0])'  				int.Parse (tuple [1])'  				int.Parse (tuple [2])'  				int.Parse (tuple [3])  			};  			readTuple (reader' tuple);  		}  	}  	region.originalWidth = int.Parse (tuple [0]);  	region.originalHeight = int.Parse (tuple [1]);  	readTuple (reader' tuple);  	region.offsetX = int.Parse (tuple [0]);  	region.offsetY = int.Parse (tuple [1]);  	region.index = int.Parse (readValue (reader));  	regions.Add (region);  }  
Magic Number,Spine,Atlas,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Atlas.cs,Load,The following statement contains a magic number: if (page == null) {  	page = new AtlasPage ();  	page.name = line;  	page.format = (Format)Enum.Parse (typeof(Format)' readValue (reader)' false);  	readTuple (reader' tuple);  	page.minFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [0]' false);  	page.magFilter = (TextureFilter)Enum.Parse (typeof(TextureFilter)' tuple [1]' false);  	String direction = readValue (reader);  	page.uWrap = TextureWrap.ClampToEdge;  	page.vWrap = TextureWrap.ClampToEdge;  	if (direction == "x")  		page.uWrap = TextureWrap.Repeat;  	else if (direction == "y")  		page.vWrap = TextureWrap.Repeat;  	else if (direction == "xy")  		page.uWrap = page.vWrap = TextureWrap.Repeat;  	textureLoader.Load (page' Path.Combine (imagesDir' line));  	pages.Add (page);  }  else {  	AtlasRegion region = new AtlasRegion ();  	region.name = line;  	region.page = page;  	region.rotate = Boolean.Parse (readValue (reader));  	readTuple (reader' tuple);  	int x = int.Parse (tuple [0]);  	int y = int.Parse (tuple [1]);  	readTuple (reader' tuple);  	int width = int.Parse (tuple [0]);  	int height = int.Parse (tuple [1]);  	region.u = x / (float)page.width;  	region.v = y / (float)page.height;  	if (region.rotate) {  		region.u2 = (x + height) / (float)page.width;  		region.v2 = (y + width) / (float)page.height;  	}  	else {  		region.u2 = (x + width) / (float)page.width;  		region.v2 = (y + height) / (float)page.height;  	}  	region.x = x;  	region.y = y;  	region.width = Math.Abs (width);  	region.height = Math.Abs (height);  	if (readTuple (reader' tuple) == 4) {  		// split is optional  		region.splits = new int[] {  			int.Parse (tuple [0])'  			int.Parse (tuple [1])'  			int.Parse (tuple [2])'  			int.Parse (tuple [3])  		};  		if (readTuple (reader' tuple) == 4) {  			// pad is optional' but only present with splits  			region.pads = new int[] {  				int.Parse (tuple [0])'  				int.Parse (tuple [1])'  				int.Parse (tuple [2])'  				int.Parse (tuple [3])  			};  			readTuple (reader' tuple);  		}  	}  	region.originalWidth = int.Parse (tuple [0]);  	region.originalHeight = int.Parse (tuple [1]);  	readTuple (reader' tuple);  	region.offsetX = int.Parse (tuple [0]);  	region.offsetY = int.Parse (tuple [1]);  	region.index = int.Parse (readValue (reader));  	regions.Add (region);  }  
Magic Number,Spine,Atlas,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Atlas.cs,Load,The following statement contains a magic number: if (readTuple (reader' tuple) == 4) {  	// split is optional  	region.splits = new int[] {  		int.Parse (tuple [0])'  		int.Parse (tuple [1])'  		int.Parse (tuple [2])'  		int.Parse (tuple [3])  	};  	if (readTuple (reader' tuple) == 4) {  		// pad is optional' but only present with splits  		region.pads = new int[] {  			int.Parse (tuple [0])'  			int.Parse (tuple [1])'  			int.Parse (tuple [2])'  			int.Parse (tuple [3])  		};  		readTuple (reader' tuple);  	}  }  
Magic Number,Spine,Atlas,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Atlas.cs,Load,The following statement contains a magic number: if (readTuple (reader' tuple) == 4) {  	// split is optional  	region.splits = new int[] {  		int.Parse (tuple [0])'  		int.Parse (tuple [1])'  		int.Parse (tuple [2])'  		int.Parse (tuple [3])  	};  	if (readTuple (reader' tuple) == 4) {  		// pad is optional' but only present with splits  		region.pads = new int[] {  			int.Parse (tuple [0])'  			int.Parse (tuple [1])'  			int.Parse (tuple [2])'  			int.Parse (tuple [3])  		};  		readTuple (reader' tuple);  	}  }  
Magic Number,Spine,Atlas,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Atlas.cs,Load,The following statement contains a magic number: if (readTuple (reader' tuple) == 4) {  	// split is optional  	region.splits = new int[] {  		int.Parse (tuple [0])'  		int.Parse (tuple [1])'  		int.Parse (tuple [2])'  		int.Parse (tuple [3])  	};  	if (readTuple (reader' tuple) == 4) {  		// pad is optional' but only present with splits  		region.pads = new int[] {  			int.Parse (tuple [0])'  			int.Parse (tuple [1])'  			int.Parse (tuple [2])'  			int.Parse (tuple [3])  		};  		readTuple (reader' tuple);  	}  }  
Magic Number,Spine,Atlas,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Atlas.cs,Load,The following statement contains a magic number: if (readTuple (reader' tuple) == 4) {  	// split is optional  	region.splits = new int[] {  		int.Parse (tuple [0])'  		int.Parse (tuple [1])'  		int.Parse (tuple [2])'  		int.Parse (tuple [3])  	};  	if (readTuple (reader' tuple) == 4) {  		// pad is optional' but only present with splits  		region.pads = new int[] {  			int.Parse (tuple [0])'  			int.Parse (tuple [1])'  			int.Parse (tuple [2])'  			int.Parse (tuple [3])  		};  		readTuple (reader' tuple);  	}  }  
Magic Number,Spine,Atlas,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Atlas.cs,Load,The following statement contains a magic number: if (readTuple (reader' tuple) == 4) {  	// split is optional  	region.splits = new int[] {  		int.Parse (tuple [0])'  		int.Parse (tuple [1])'  		int.Parse (tuple [2])'  		int.Parse (tuple [3])  	};  	if (readTuple (reader' tuple) == 4) {  		// pad is optional' but only present with splits  		region.pads = new int[] {  			int.Parse (tuple [0])'  			int.Parse (tuple [1])'  			int.Parse (tuple [2])'  			int.Parse (tuple [3])  		};  		readTuple (reader' tuple);  	}  }  
Magic Number,Spine,Atlas,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Atlas.cs,Load,The following statement contains a magic number: if (readTuple (reader' tuple) == 4) {  	// split is optional  	region.splits = new int[] {  		int.Parse (tuple [0])'  		int.Parse (tuple [1])'  		int.Parse (tuple [2])'  		int.Parse (tuple [3])  	};  	if (readTuple (reader' tuple) == 4) {  		// pad is optional' but only present with splits  		region.pads = new int[] {  			int.Parse (tuple [0])'  			int.Parse (tuple [1])'  			int.Parse (tuple [2])'  			int.Parse (tuple [3])  		};  		readTuple (reader' tuple);  	}  }  
Magic Number,Spine,Atlas,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Atlas.cs,Load,The following statement contains a magic number: region.splits = new int[] {  	int.Parse (tuple [0])'  	int.Parse (tuple [1])'  	int.Parse (tuple [2])'  	int.Parse (tuple [3])  };  
Magic Number,Spine,Atlas,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Atlas.cs,Load,The following statement contains a magic number: region.splits = new int[] {  	int.Parse (tuple [0])'  	int.Parse (tuple [1])'  	int.Parse (tuple [2])'  	int.Parse (tuple [3])  };  
Magic Number,Spine,Atlas,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Atlas.cs,Load,The following statement contains a magic number: if (readTuple (reader' tuple) == 4) {  	// pad is optional' but only present with splits  	region.pads = new int[] {  		int.Parse (tuple [0])'  		int.Parse (tuple [1])'  		int.Parse (tuple [2])'  		int.Parse (tuple [3])  	};  	readTuple (reader' tuple);  }  
Magic Number,Spine,Atlas,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Atlas.cs,Load,The following statement contains a magic number: if (readTuple (reader' tuple) == 4) {  	// pad is optional' but only present with splits  	region.pads = new int[] {  		int.Parse (tuple [0])'  		int.Parse (tuple [1])'  		int.Parse (tuple [2])'  		int.Parse (tuple [3])  	};  	readTuple (reader' tuple);  }  
Magic Number,Spine,Atlas,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Atlas.cs,Load,The following statement contains a magic number: if (readTuple (reader' tuple) == 4) {  	// pad is optional' but only present with splits  	region.pads = new int[] {  		int.Parse (tuple [0])'  		int.Parse (tuple [1])'  		int.Parse (tuple [2])'  		int.Parse (tuple [3])  	};  	readTuple (reader' tuple);  }  
Magic Number,Spine,Atlas,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Atlas.cs,Load,The following statement contains a magic number: region.pads = new int[] {  	int.Parse (tuple [0])'  	int.Parse (tuple [1])'  	int.Parse (tuple [2])'  	int.Parse (tuple [3])  };  
Magic Number,Spine,Atlas,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Atlas.cs,Load,The following statement contains a magic number: region.pads = new int[] {  	int.Parse (tuple [0])'  	int.Parse (tuple [1])'  	int.Parse (tuple [2])'  	int.Parse (tuple [3])  };  
Magic Number,Spine,Atlas,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Atlas.cs,readTuple,The following statement contains a magic number: for (; i < 3; i++) {  	int comma = line.IndexOf ('''' lastMatch);  	if (comma == -1) {  		if (i == 0)  			throw new Exception ("Invalid line: " + line);  		break;  	}  	tuple [i] = line.Substring (lastMatch' comma - lastMatch).Trim ();  	lastMatch = comma + 1;  }  
Magic Number,Spine,BoundingBoxAttachment,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Attachments\BoundingBoxAttachment.cs,ComputeWorldVertices,The following statement contains a magic number: for (int i = 0' n = vertices.Length; i < n; i += 2) {  	float px = vertices [i];  	float py = vertices [i + 1];  	worldVertices [i] = px * m00 + py * m01 + x;  	worldVertices [i + 1] = px * m10 + py * m11 + y;  }  
Magic Number,Spine,BoundingBoxAttachment,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Attachments\BoundingBoxAttachment.cs,ComputeWorldVertices,The following statement contains a magic number: i += 2
Magic Number,Spine,SkeletonBounds,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonBounds.cs,aabbCompute,The following statement contains a magic number: for (int i = 0' n = polygons.Count; i < n; i++) {  	Polygon polygon = polygons [i];  	float[] vertices = polygon.Vertices;  	for (int ii = 0' nn = polygon.Count; ii < nn; ii += 2) {  		float x = vertices [ii];  		float y = vertices [ii + 1];  		minX = Math.Min (minX' x);  		minY = Math.Min (minY' y);  		maxX = Math.Max (maxX' x);  		maxY = Math.Max (maxY' y);  	}  }  
Magic Number,Spine,SkeletonBounds,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonBounds.cs,aabbCompute,The following statement contains a magic number: for (int ii = 0' nn = polygon.Count; ii < nn; ii += 2) {  	float x = vertices [ii];  	float y = vertices [ii + 1];  	minX = Math.Min (minX' x);  	minY = Math.Min (minY' y);  	maxX = Math.Max (maxX' x);  	maxY = Math.Max (maxY' y);  }  
Magic Number,Spine,SkeletonBounds,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonBounds.cs,aabbCompute,The following statement contains a magic number: ii += 2
Magic Number,Spine,SkeletonBounds,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonBounds.cs,ContainsPoint,The following statement contains a magic number: for (int ii = 0; ii < nn; ii += 2) {  	float vertexY = vertices [ii + 1];  	float prevY = vertices [prevIndex + 1];  	if ((vertexY < y && prevY >= y) || (prevY < y && vertexY >= y)) {  		float vertexX = vertices [ii];  		if (vertexX + (y - vertexY) / (prevY - vertexY) * (vertices [prevIndex] - vertexX) < x)  			inside = !inside;  	}  	prevIndex = ii;  }  
Magic Number,Spine,SkeletonBounds,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonBounds.cs,ContainsPoint,The following statement contains a magic number: ii += 2
Magic Number,Spine,SkeletonBounds,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonBounds.cs,IntersectsSegment,The following statement contains a magic number: for (int ii = 0; ii < nn; ii += 2) {  	float x4 = vertices [ii]' y4 = vertices [ii + 1];  	float det2 = x3 * y4 - y3 * x4;  	float width34 = x3 - x4' height34 = y3 - y4;  	float det3 = width12 * height34 - height12 * width34;  	float x = (det1 * width34 - width12 * det2) / det3;  	if (((x >= x3 && x <= x4) || (x >= x4 && x <= x3)) && ((x >= x1 && x <= x2) || (x >= x2 && x <= x1))) {  		float y = (det1 * height34 - height12 * det2) / det3;  		if (((y >= y3 && y <= y4) || (y >= y4 && y <= y3)) && ((y >= y1 && y <= y2) || (y >= y2 && y <= y1)))  			return true;  	}  	x3 = x4;  	y3 = y4;  }  
Magic Number,Spine,SkeletonBounds,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonBounds.cs,IntersectsSegment,The following statement contains a magic number: ii += 2
Magic Number,Spine,Polygon,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonBounds.cs,Polygon,The following statement contains a magic number: Vertices = new float[16];  
Magic Number,Spine,SkeletonJson,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonJson.cs,ReadSkeletonData,The following statement contains a magic number: if (root.ContainsKey ("slots")) {  	foreach (Dictionary<String' Object> slotMap in (List<Object>)root ["slots"]) {  		String slotName = (String)slotMap ["name"];  		String boneName = (String)slotMap ["bone"];  		BoneData boneData = skeletonData.FindBone (boneName);  		if (boneData == null)  			throw new Exception ("Slot bone not found: " + boneName);  		SlotData slotData = new SlotData (slotName' boneData);  		if (slotMap.ContainsKey ("color")) {  			String color = (String)slotMap ["color"];  			slotData.r = ToColor (color' 0);  			slotData.g = ToColor (color' 1);  			slotData.b = ToColor (color' 2);  			slotData.a = ToColor (color' 3);  		}  		if (slotMap.ContainsKey ("attachment"))  			slotData.attachmentName = (String)slotMap ["attachment"];  		if (slotMap.ContainsKey ("additive"))  			slotData.additiveBlending = (bool)slotMap ["additive"];  		skeletonData.AddSlot (slotData);  	}  }  
Magic Number,Spine,SkeletonJson,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonJson.cs,ReadSkeletonData,The following statement contains a magic number: if (root.ContainsKey ("slots")) {  	foreach (Dictionary<String' Object> slotMap in (List<Object>)root ["slots"]) {  		String slotName = (String)slotMap ["name"];  		String boneName = (String)slotMap ["bone"];  		BoneData boneData = skeletonData.FindBone (boneName);  		if (boneData == null)  			throw new Exception ("Slot bone not found: " + boneName);  		SlotData slotData = new SlotData (slotName' boneData);  		if (slotMap.ContainsKey ("color")) {  			String color = (String)slotMap ["color"];  			slotData.r = ToColor (color' 0);  			slotData.g = ToColor (color' 1);  			slotData.b = ToColor (color' 2);  			slotData.a = ToColor (color' 3);  		}  		if (slotMap.ContainsKey ("attachment"))  			slotData.attachmentName = (String)slotMap ["attachment"];  		if (slotMap.ContainsKey ("additive"))  			slotData.additiveBlending = (bool)slotMap ["additive"];  		skeletonData.AddSlot (slotData);  	}  }  
Magic Number,Spine,SkeletonJson,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonJson.cs,ReadSkeletonData,The following statement contains a magic number: foreach (Dictionary<String' Object> slotMap in (List<Object>)root ["slots"]) {  	String slotName = (String)slotMap ["name"];  	String boneName = (String)slotMap ["bone"];  	BoneData boneData = skeletonData.FindBone (boneName);  	if (boneData == null)  		throw new Exception ("Slot bone not found: " + boneName);  	SlotData slotData = new SlotData (slotName' boneData);  	if (slotMap.ContainsKey ("color")) {  		String color = (String)slotMap ["color"];  		slotData.r = ToColor (color' 0);  		slotData.g = ToColor (color' 1);  		slotData.b = ToColor (color' 2);  		slotData.a = ToColor (color' 3);  	}  	if (slotMap.ContainsKey ("attachment"))  		slotData.attachmentName = (String)slotMap ["attachment"];  	if (slotMap.ContainsKey ("additive"))  		slotData.additiveBlending = (bool)slotMap ["additive"];  	skeletonData.AddSlot (slotData);  }  
Magic Number,Spine,SkeletonJson,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonJson.cs,ReadSkeletonData,The following statement contains a magic number: foreach (Dictionary<String' Object> slotMap in (List<Object>)root ["slots"]) {  	String slotName = (String)slotMap ["name"];  	String boneName = (String)slotMap ["bone"];  	BoneData boneData = skeletonData.FindBone (boneName);  	if (boneData == null)  		throw new Exception ("Slot bone not found: " + boneName);  	SlotData slotData = new SlotData (slotName' boneData);  	if (slotMap.ContainsKey ("color")) {  		String color = (String)slotMap ["color"];  		slotData.r = ToColor (color' 0);  		slotData.g = ToColor (color' 1);  		slotData.b = ToColor (color' 2);  		slotData.a = ToColor (color' 3);  	}  	if (slotMap.ContainsKey ("attachment"))  		slotData.attachmentName = (String)slotMap ["attachment"];  	if (slotMap.ContainsKey ("additive"))  		slotData.additiveBlending = (bool)slotMap ["additive"];  	skeletonData.AddSlot (slotData);  }  
Magic Number,Spine,SkeletonJson,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonJson.cs,ReadSkeletonData,The following statement contains a magic number: if (slotMap.ContainsKey ("color")) {  	String color = (String)slotMap ["color"];  	slotData.r = ToColor (color' 0);  	slotData.g = ToColor (color' 1);  	slotData.b = ToColor (color' 2);  	slotData.a = ToColor (color' 3);  }  
Magic Number,Spine,SkeletonJson,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonJson.cs,ReadSkeletonData,The following statement contains a magic number: if (slotMap.ContainsKey ("color")) {  	String color = (String)slotMap ["color"];  	slotData.r = ToColor (color' 0);  	slotData.g = ToColor (color' 1);  	slotData.b = ToColor (color' 2);  	slotData.a = ToColor (color' 3);  }  
Magic Number,Spine,SkeletonJson,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonJson.cs,ReadSkeletonData,The following statement contains a magic number: slotData.b = ToColor (color' 2);  
Magic Number,Spine,SkeletonJson,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonJson.cs,ReadSkeletonData,The following statement contains a magic number: slotData.a = ToColor (color' 3);  
Magic Number,Spine,SkeletonJson,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: if (regionAttachment != null) {  	regionAttachment.x = GetFloat (map' "x"' 0) * Scale;  	regionAttachment.y = GetFloat (map' "y"' 0) * Scale;  	regionAttachment.scaleX = GetFloat (map' "scaleX"' 1);  	regionAttachment.scaleY = GetFloat (map' "scaleY"' 1);  	regionAttachment.rotation = GetFloat (map' "rotation"' 0);  	regionAttachment.width = GetFloat (map' "width"' 32) * Scale;  	regionAttachment.height = GetFloat (map' "height"' 32) * Scale;  	regionAttachment.UpdateOffset ();  }  
Magic Number,Spine,SkeletonJson,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: if (regionAttachment != null) {  	regionAttachment.x = GetFloat (map' "x"' 0) * Scale;  	regionAttachment.y = GetFloat (map' "y"' 0) * Scale;  	regionAttachment.scaleX = GetFloat (map' "scaleX"' 1);  	regionAttachment.scaleY = GetFloat (map' "scaleY"' 1);  	regionAttachment.rotation = GetFloat (map' "rotation"' 0);  	regionAttachment.width = GetFloat (map' "width"' 32) * Scale;  	regionAttachment.height = GetFloat (map' "height"' 32) * Scale;  	regionAttachment.UpdateOffset ();  }  
Magic Number,Spine,SkeletonJson,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: regionAttachment.width = GetFloat (map' "width"' 32) * Scale;  
Magic Number,Spine,SkeletonJson,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: regionAttachment.height = GetFloat (map' "height"' 32) * Scale;  
Magic Number,Spine,SkeletonJson,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonJson.cs,ToColor,The following statement contains a magic number: if (hexString.Length != 8)  	throw new ArgumentException ("Color hexidecimal length must be 8' recieved: " + hexString);  
Magic Number,Spine,SkeletonJson,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonJson.cs,ToColor,The following statement contains a magic number: return Convert.ToInt32 (hexString.Substring (colorIndex * 2' 2)' 16) / (float)255;  
Magic Number,Spine,SkeletonJson,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonJson.cs,ToColor,The following statement contains a magic number: return Convert.ToInt32 (hexString.Substring (colorIndex * 2' 2)' 16) / (float)255;  
Magic Number,Spine,SkeletonJson,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonJson.cs,ToColor,The following statement contains a magic number: return Convert.ToInt32 (hexString.Substring (colorIndex * 2' 2)' 16) / (float)255;  
Magic Number,Spine,SkeletonJson,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonJson.cs,ToColor,The following statement contains a magic number: return Convert.ToInt32 (hexString.Substring (colorIndex * 2' 2)' 16) / (float)255;  
Magic Number,Spine,SkeletonJson,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: if (map.ContainsKey ("bones")) {  	foreach (KeyValuePair<String' Object> entry in (Dictionary<String' Object>)map ["bones"]) {  		String boneName = entry.Key;  		int boneIndex = skeletonData.FindBoneIndex (boneName);  		if (boneIndex == -1)  			throw new Exception ("Bone not found: " + boneName);  		var timelineMap = (Dictionary<String' Object>)entry.Value;  		foreach (KeyValuePair<String' Object> timelineEntry in timelineMap) {  			var values = (List<Object>)timelineEntry.Value;  			String timelineName = (String)timelineEntry.Key;  			if (timelineName.Equals ("rotate")) {  				RotateTimeline timeline = new RotateTimeline (values.Count);  				timeline.boneIndex = boneIndex;  				int frameIndex = 0;  				foreach (Dictionary<String' Object> valueMap in values) {  					float time = (float)valueMap ["time"];  					timeline.SetFrame (frameIndex' time' (float)valueMap ["angle"]);  					ReadCurve (timeline' frameIndex' valueMap);  					frameIndex++;  				}  				timelines.Add (timeline);  				duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 2 - 2]);  			}  			else if (timelineName.Equals ("translate") || timelineName.Equals ("scale")) {  				TranslateTimeline timeline;  				float timelineScale = 1;  				if (timelineName.Equals ("scale"))  					timeline = new ScaleTimeline (values.Count);  				else {  					timeline = new TranslateTimeline (values.Count);  					timelineScale = Scale;  				}  				timeline.boneIndex = boneIndex;  				int frameIndex = 0;  				foreach (Dictionary<String' Object> valueMap in values) {  					float time = (float)valueMap ["time"];  					float x = valueMap.ContainsKey ("x") ? (float)valueMap ["x"] : 0;  					float y = valueMap.ContainsKey ("y") ? (float)valueMap ["y"] : 0;  					timeline.SetFrame (frameIndex' time' (float)x * timelineScale' (float)y * timelineScale);  					ReadCurve (timeline' frameIndex' valueMap);  					frameIndex++;  				}  				timelines.Add (timeline);  				duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 3 - 3]);  			}  			else  				throw new Exception ("Invalid timeline type for a bone: " + timelineName + " (" + boneName + ")");  		}  	}  }  
Magic Number,Spine,SkeletonJson,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: if (map.ContainsKey ("bones")) {  	foreach (KeyValuePair<String' Object> entry in (Dictionary<String' Object>)map ["bones"]) {  		String boneName = entry.Key;  		int boneIndex = skeletonData.FindBoneIndex (boneName);  		if (boneIndex == -1)  			throw new Exception ("Bone not found: " + boneName);  		var timelineMap = (Dictionary<String' Object>)entry.Value;  		foreach (KeyValuePair<String' Object> timelineEntry in timelineMap) {  			var values = (List<Object>)timelineEntry.Value;  			String timelineName = (String)timelineEntry.Key;  			if (timelineName.Equals ("rotate")) {  				RotateTimeline timeline = new RotateTimeline (values.Count);  				timeline.boneIndex = boneIndex;  				int frameIndex = 0;  				foreach (Dictionary<String' Object> valueMap in values) {  					float time = (float)valueMap ["time"];  					timeline.SetFrame (frameIndex' time' (float)valueMap ["angle"]);  					ReadCurve (timeline' frameIndex' valueMap);  					frameIndex++;  				}  				timelines.Add (timeline);  				duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 2 - 2]);  			}  			else if (timelineName.Equals ("translate") || timelineName.Equals ("scale")) {  				TranslateTimeline timeline;  				float timelineScale = 1;  				if (timelineName.Equals ("scale"))  					timeline = new ScaleTimeline (values.Count);  				else {  					timeline = new TranslateTimeline (values.Count);  					timelineScale = Scale;  				}  				timeline.boneIndex = boneIndex;  				int frameIndex = 0;  				foreach (Dictionary<String' Object> valueMap in values) {  					float time = (float)valueMap ["time"];  					float x = valueMap.ContainsKey ("x") ? (float)valueMap ["x"] : 0;  					float y = valueMap.ContainsKey ("y") ? (float)valueMap ["y"] : 0;  					timeline.SetFrame (frameIndex' time' (float)x * timelineScale' (float)y * timelineScale);  					ReadCurve (timeline' frameIndex' valueMap);  					frameIndex++;  				}  				timelines.Add (timeline);  				duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 3 - 3]);  			}  			else  				throw new Exception ("Invalid timeline type for a bone: " + timelineName + " (" + boneName + ")");  		}  	}  }  
Magic Number,Spine,SkeletonJson,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: if (map.ContainsKey ("bones")) {  	foreach (KeyValuePair<String' Object> entry in (Dictionary<String' Object>)map ["bones"]) {  		String boneName = entry.Key;  		int boneIndex = skeletonData.FindBoneIndex (boneName);  		if (boneIndex == -1)  			throw new Exception ("Bone not found: " + boneName);  		var timelineMap = (Dictionary<String' Object>)entry.Value;  		foreach (KeyValuePair<String' Object> timelineEntry in timelineMap) {  			var values = (List<Object>)timelineEntry.Value;  			String timelineName = (String)timelineEntry.Key;  			if (timelineName.Equals ("rotate")) {  				RotateTimeline timeline = new RotateTimeline (values.Count);  				timeline.boneIndex = boneIndex;  				int frameIndex = 0;  				foreach (Dictionary<String' Object> valueMap in values) {  					float time = (float)valueMap ["time"];  					timeline.SetFrame (frameIndex' time' (float)valueMap ["angle"]);  					ReadCurve (timeline' frameIndex' valueMap);  					frameIndex++;  				}  				timelines.Add (timeline);  				duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 2 - 2]);  			}  			else if (timelineName.Equals ("translate") || timelineName.Equals ("scale")) {  				TranslateTimeline timeline;  				float timelineScale = 1;  				if (timelineName.Equals ("scale"))  					timeline = new ScaleTimeline (values.Count);  				else {  					timeline = new TranslateTimeline (values.Count);  					timelineScale = Scale;  				}  				timeline.boneIndex = boneIndex;  				int frameIndex = 0;  				foreach (Dictionary<String' Object> valueMap in values) {  					float time = (float)valueMap ["time"];  					float x = valueMap.ContainsKey ("x") ? (float)valueMap ["x"] : 0;  					float y = valueMap.ContainsKey ("y") ? (float)valueMap ["y"] : 0;  					timeline.SetFrame (frameIndex' time' (float)x * timelineScale' (float)y * timelineScale);  					ReadCurve (timeline' frameIndex' valueMap);  					frameIndex++;  				}  				timelines.Add (timeline);  				duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 3 - 3]);  			}  			else  				throw new Exception ("Invalid timeline type for a bone: " + timelineName + " (" + boneName + ")");  		}  	}  }  
Magic Number,Spine,SkeletonJson,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: if (map.ContainsKey ("bones")) {  	foreach (KeyValuePair<String' Object> entry in (Dictionary<String' Object>)map ["bones"]) {  		String boneName = entry.Key;  		int boneIndex = skeletonData.FindBoneIndex (boneName);  		if (boneIndex == -1)  			throw new Exception ("Bone not found: " + boneName);  		var timelineMap = (Dictionary<String' Object>)entry.Value;  		foreach (KeyValuePair<String' Object> timelineEntry in timelineMap) {  			var values = (List<Object>)timelineEntry.Value;  			String timelineName = (String)timelineEntry.Key;  			if (timelineName.Equals ("rotate")) {  				RotateTimeline timeline = new RotateTimeline (values.Count);  				timeline.boneIndex = boneIndex;  				int frameIndex = 0;  				foreach (Dictionary<String' Object> valueMap in values) {  					float time = (float)valueMap ["time"];  					timeline.SetFrame (frameIndex' time' (float)valueMap ["angle"]);  					ReadCurve (timeline' frameIndex' valueMap);  					frameIndex++;  				}  				timelines.Add (timeline);  				duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 2 - 2]);  			}  			else if (timelineName.Equals ("translate") || timelineName.Equals ("scale")) {  				TranslateTimeline timeline;  				float timelineScale = 1;  				if (timelineName.Equals ("scale"))  					timeline = new ScaleTimeline (values.Count);  				else {  					timeline = new TranslateTimeline (values.Count);  					timelineScale = Scale;  				}  				timeline.boneIndex = boneIndex;  				int frameIndex = 0;  				foreach (Dictionary<String' Object> valueMap in values) {  					float time = (float)valueMap ["time"];  					float x = valueMap.ContainsKey ("x") ? (float)valueMap ["x"] : 0;  					float y = valueMap.ContainsKey ("y") ? (float)valueMap ["y"] : 0;  					timeline.SetFrame (frameIndex' time' (float)x * timelineScale' (float)y * timelineScale);  					ReadCurve (timeline' frameIndex' valueMap);  					frameIndex++;  				}  				timelines.Add (timeline);  				duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 3 - 3]);  			}  			else  				throw new Exception ("Invalid timeline type for a bone: " + timelineName + " (" + boneName + ")");  		}  	}  }  
Magic Number,Spine,SkeletonJson,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: foreach (KeyValuePair<String' Object> entry in (Dictionary<String' Object>)map ["bones"]) {  	String boneName = entry.Key;  	int boneIndex = skeletonData.FindBoneIndex (boneName);  	if (boneIndex == -1)  		throw new Exception ("Bone not found: " + boneName);  	var timelineMap = (Dictionary<String' Object>)entry.Value;  	foreach (KeyValuePair<String' Object> timelineEntry in timelineMap) {  		var values = (List<Object>)timelineEntry.Value;  		String timelineName = (String)timelineEntry.Key;  		if (timelineName.Equals ("rotate")) {  			RotateTimeline timeline = new RotateTimeline (values.Count);  			timeline.boneIndex = boneIndex;  			int frameIndex = 0;  			foreach (Dictionary<String' Object> valueMap in values) {  				float time = (float)valueMap ["time"];  				timeline.SetFrame (frameIndex' time' (float)valueMap ["angle"]);  				ReadCurve (timeline' frameIndex' valueMap);  				frameIndex++;  			}  			timelines.Add (timeline);  			duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 2 - 2]);  		}  		else if (timelineName.Equals ("translate") || timelineName.Equals ("scale")) {  			TranslateTimeline timeline;  			float timelineScale = 1;  			if (timelineName.Equals ("scale"))  				timeline = new ScaleTimeline (values.Count);  			else {  				timeline = new TranslateTimeline (values.Count);  				timelineScale = Scale;  			}  			timeline.boneIndex = boneIndex;  			int frameIndex = 0;  			foreach (Dictionary<String' Object> valueMap in values) {  				float time = (float)valueMap ["time"];  				float x = valueMap.ContainsKey ("x") ? (float)valueMap ["x"] : 0;  				float y = valueMap.ContainsKey ("y") ? (float)valueMap ["y"] : 0;  				timeline.SetFrame (frameIndex' time' (float)x * timelineScale' (float)y * timelineScale);  				ReadCurve (timeline' frameIndex' valueMap);  				frameIndex++;  			}  			timelines.Add (timeline);  			duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 3 - 3]);  		}  		else  			throw new Exception ("Invalid timeline type for a bone: " + timelineName + " (" + boneName + ")");  	}  }  
Magic Number,Spine,SkeletonJson,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: foreach (KeyValuePair<String' Object> entry in (Dictionary<String' Object>)map ["bones"]) {  	String boneName = entry.Key;  	int boneIndex = skeletonData.FindBoneIndex (boneName);  	if (boneIndex == -1)  		throw new Exception ("Bone not found: " + boneName);  	var timelineMap = (Dictionary<String' Object>)entry.Value;  	foreach (KeyValuePair<String' Object> timelineEntry in timelineMap) {  		var values = (List<Object>)timelineEntry.Value;  		String timelineName = (String)timelineEntry.Key;  		if (timelineName.Equals ("rotate")) {  			RotateTimeline timeline = new RotateTimeline (values.Count);  			timeline.boneIndex = boneIndex;  			int frameIndex = 0;  			foreach (Dictionary<String' Object> valueMap in values) {  				float time = (float)valueMap ["time"];  				timeline.SetFrame (frameIndex' time' (float)valueMap ["angle"]);  				ReadCurve (timeline' frameIndex' valueMap);  				frameIndex++;  			}  			timelines.Add (timeline);  			duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 2 - 2]);  		}  		else if (timelineName.Equals ("translate") || timelineName.Equals ("scale")) {  			TranslateTimeline timeline;  			float timelineScale = 1;  			if (timelineName.Equals ("scale"))  				timeline = new ScaleTimeline (values.Count);  			else {  				timeline = new TranslateTimeline (values.Count);  				timelineScale = Scale;  			}  			timeline.boneIndex = boneIndex;  			int frameIndex = 0;  			foreach (Dictionary<String' Object> valueMap in values) {  				float time = (float)valueMap ["time"];  				float x = valueMap.ContainsKey ("x") ? (float)valueMap ["x"] : 0;  				float y = valueMap.ContainsKey ("y") ? (float)valueMap ["y"] : 0;  				timeline.SetFrame (frameIndex' time' (float)x * timelineScale' (float)y * timelineScale);  				ReadCurve (timeline' frameIndex' valueMap);  				frameIndex++;  			}  			timelines.Add (timeline);  			duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 3 - 3]);  		}  		else  			throw new Exception ("Invalid timeline type for a bone: " + timelineName + " (" + boneName + ")");  	}  }  
Magic Number,Spine,SkeletonJson,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: foreach (KeyValuePair<String' Object> entry in (Dictionary<String' Object>)map ["bones"]) {  	String boneName = entry.Key;  	int boneIndex = skeletonData.FindBoneIndex (boneName);  	if (boneIndex == -1)  		throw new Exception ("Bone not found: " + boneName);  	var timelineMap = (Dictionary<String' Object>)entry.Value;  	foreach (KeyValuePair<String' Object> timelineEntry in timelineMap) {  		var values = (List<Object>)timelineEntry.Value;  		String timelineName = (String)timelineEntry.Key;  		if (timelineName.Equals ("rotate")) {  			RotateTimeline timeline = new RotateTimeline (values.Count);  			timeline.boneIndex = boneIndex;  			int frameIndex = 0;  			foreach (Dictionary<String' Object> valueMap in values) {  				float time = (float)valueMap ["time"];  				timeline.SetFrame (frameIndex' time' (float)valueMap ["angle"]);  				ReadCurve (timeline' frameIndex' valueMap);  				frameIndex++;  			}  			timelines.Add (timeline);  			duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 2 - 2]);  		}  		else if (timelineName.Equals ("translate") || timelineName.Equals ("scale")) {  			TranslateTimeline timeline;  			float timelineScale = 1;  			if (timelineName.Equals ("scale"))  				timeline = new ScaleTimeline (values.Count);  			else {  				timeline = new TranslateTimeline (values.Count);  				timelineScale = Scale;  			}  			timeline.boneIndex = boneIndex;  			int frameIndex = 0;  			foreach (Dictionary<String' Object> valueMap in values) {  				float time = (float)valueMap ["time"];  				float x = valueMap.ContainsKey ("x") ? (float)valueMap ["x"] : 0;  				float y = valueMap.ContainsKey ("y") ? (float)valueMap ["y"] : 0;  				timeline.SetFrame (frameIndex' time' (float)x * timelineScale' (float)y * timelineScale);  				ReadCurve (timeline' frameIndex' valueMap);  				frameIndex++;  			}  			timelines.Add (timeline);  			duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 3 - 3]);  		}  		else  			throw new Exception ("Invalid timeline type for a bone: " + timelineName + " (" + boneName + ")");  	}  }  
Magic Number,Spine,SkeletonJson,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: foreach (KeyValuePair<String' Object> entry in (Dictionary<String' Object>)map ["bones"]) {  	String boneName = entry.Key;  	int boneIndex = skeletonData.FindBoneIndex (boneName);  	if (boneIndex == -1)  		throw new Exception ("Bone not found: " + boneName);  	var timelineMap = (Dictionary<String' Object>)entry.Value;  	foreach (KeyValuePair<String' Object> timelineEntry in timelineMap) {  		var values = (List<Object>)timelineEntry.Value;  		String timelineName = (String)timelineEntry.Key;  		if (timelineName.Equals ("rotate")) {  			RotateTimeline timeline = new RotateTimeline (values.Count);  			timeline.boneIndex = boneIndex;  			int frameIndex = 0;  			foreach (Dictionary<String' Object> valueMap in values) {  				float time = (float)valueMap ["time"];  				timeline.SetFrame (frameIndex' time' (float)valueMap ["angle"]);  				ReadCurve (timeline' frameIndex' valueMap);  				frameIndex++;  			}  			timelines.Add (timeline);  			duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 2 - 2]);  		}  		else if (timelineName.Equals ("translate") || timelineName.Equals ("scale")) {  			TranslateTimeline timeline;  			float timelineScale = 1;  			if (timelineName.Equals ("scale"))  				timeline = new ScaleTimeline (values.Count);  			else {  				timeline = new TranslateTimeline (values.Count);  				timelineScale = Scale;  			}  			timeline.boneIndex = boneIndex;  			int frameIndex = 0;  			foreach (Dictionary<String' Object> valueMap in values) {  				float time = (float)valueMap ["time"];  				float x = valueMap.ContainsKey ("x") ? (float)valueMap ["x"] : 0;  				float y = valueMap.ContainsKey ("y") ? (float)valueMap ["y"] : 0;  				timeline.SetFrame (frameIndex' time' (float)x * timelineScale' (float)y * timelineScale);  				ReadCurve (timeline' frameIndex' valueMap);  				frameIndex++;  			}  			timelines.Add (timeline);  			duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 3 - 3]);  		}  		else  			throw new Exception ("Invalid timeline type for a bone: " + timelineName + " (" + boneName + ")");  	}  }  
Magic Number,Spine,SkeletonJson,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: foreach (KeyValuePair<String' Object> timelineEntry in timelineMap) {  	var values = (List<Object>)timelineEntry.Value;  	String timelineName = (String)timelineEntry.Key;  	if (timelineName.Equals ("rotate")) {  		RotateTimeline timeline = new RotateTimeline (values.Count);  		timeline.boneIndex = boneIndex;  		int frameIndex = 0;  		foreach (Dictionary<String' Object> valueMap in values) {  			float time = (float)valueMap ["time"];  			timeline.SetFrame (frameIndex' time' (float)valueMap ["angle"]);  			ReadCurve (timeline' frameIndex' valueMap);  			frameIndex++;  		}  		timelines.Add (timeline);  		duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 2 - 2]);  	}  	else if (timelineName.Equals ("translate") || timelineName.Equals ("scale")) {  		TranslateTimeline timeline;  		float timelineScale = 1;  		if (timelineName.Equals ("scale"))  			timeline = new ScaleTimeline (values.Count);  		else {  			timeline = new TranslateTimeline (values.Count);  			timelineScale = Scale;  		}  		timeline.boneIndex = boneIndex;  		int frameIndex = 0;  		foreach (Dictionary<String' Object> valueMap in values) {  			float time = (float)valueMap ["time"];  			float x = valueMap.ContainsKey ("x") ? (float)valueMap ["x"] : 0;  			float y = valueMap.ContainsKey ("y") ? (float)valueMap ["y"] : 0;  			timeline.SetFrame (frameIndex' time' (float)x * timelineScale' (float)y * timelineScale);  			ReadCurve (timeline' frameIndex' valueMap);  			frameIndex++;  		}  		timelines.Add (timeline);  		duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 3 - 3]);  	}  	else  		throw new Exception ("Invalid timeline type for a bone: " + timelineName + " (" + boneName + ")");  }  
Magic Number,Spine,SkeletonJson,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: foreach (KeyValuePair<String' Object> timelineEntry in timelineMap) {  	var values = (List<Object>)timelineEntry.Value;  	String timelineName = (String)timelineEntry.Key;  	if (timelineName.Equals ("rotate")) {  		RotateTimeline timeline = new RotateTimeline (values.Count);  		timeline.boneIndex = boneIndex;  		int frameIndex = 0;  		foreach (Dictionary<String' Object> valueMap in values) {  			float time = (float)valueMap ["time"];  			timeline.SetFrame (frameIndex' time' (float)valueMap ["angle"]);  			ReadCurve (timeline' frameIndex' valueMap);  			frameIndex++;  		}  		timelines.Add (timeline);  		duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 2 - 2]);  	}  	else if (timelineName.Equals ("translate") || timelineName.Equals ("scale")) {  		TranslateTimeline timeline;  		float timelineScale = 1;  		if (timelineName.Equals ("scale"))  			timeline = new ScaleTimeline (values.Count);  		else {  			timeline = new TranslateTimeline (values.Count);  			timelineScale = Scale;  		}  		timeline.boneIndex = boneIndex;  		int frameIndex = 0;  		foreach (Dictionary<String' Object> valueMap in values) {  			float time = (float)valueMap ["time"];  			float x = valueMap.ContainsKey ("x") ? (float)valueMap ["x"] : 0;  			float y = valueMap.ContainsKey ("y") ? (float)valueMap ["y"] : 0;  			timeline.SetFrame (frameIndex' time' (float)x * timelineScale' (float)y * timelineScale);  			ReadCurve (timeline' frameIndex' valueMap);  			frameIndex++;  		}  		timelines.Add (timeline);  		duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 3 - 3]);  	}  	else  		throw new Exception ("Invalid timeline type for a bone: " + timelineName + " (" + boneName + ")");  }  
Magic Number,Spine,SkeletonJson,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: foreach (KeyValuePair<String' Object> timelineEntry in timelineMap) {  	var values = (List<Object>)timelineEntry.Value;  	String timelineName = (String)timelineEntry.Key;  	if (timelineName.Equals ("rotate")) {  		RotateTimeline timeline = new RotateTimeline (values.Count);  		timeline.boneIndex = boneIndex;  		int frameIndex = 0;  		foreach (Dictionary<String' Object> valueMap in values) {  			float time = (float)valueMap ["time"];  			timeline.SetFrame (frameIndex' time' (float)valueMap ["angle"]);  			ReadCurve (timeline' frameIndex' valueMap);  			frameIndex++;  		}  		timelines.Add (timeline);  		duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 2 - 2]);  	}  	else if (timelineName.Equals ("translate") || timelineName.Equals ("scale")) {  		TranslateTimeline timeline;  		float timelineScale = 1;  		if (timelineName.Equals ("scale"))  			timeline = new ScaleTimeline (values.Count);  		else {  			timeline = new TranslateTimeline (values.Count);  			timelineScale = Scale;  		}  		timeline.boneIndex = boneIndex;  		int frameIndex = 0;  		foreach (Dictionary<String' Object> valueMap in values) {  			float time = (float)valueMap ["time"];  			float x = valueMap.ContainsKey ("x") ? (float)valueMap ["x"] : 0;  			float y = valueMap.ContainsKey ("y") ? (float)valueMap ["y"] : 0;  			timeline.SetFrame (frameIndex' time' (float)x * timelineScale' (float)y * timelineScale);  			ReadCurve (timeline' frameIndex' valueMap);  			frameIndex++;  		}  		timelines.Add (timeline);  		duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 3 - 3]);  	}  	else  		throw new Exception ("Invalid timeline type for a bone: " + timelineName + " (" + boneName + ")");  }  
Magic Number,Spine,SkeletonJson,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: foreach (KeyValuePair<String' Object> timelineEntry in timelineMap) {  	var values = (List<Object>)timelineEntry.Value;  	String timelineName = (String)timelineEntry.Key;  	if (timelineName.Equals ("rotate")) {  		RotateTimeline timeline = new RotateTimeline (values.Count);  		timeline.boneIndex = boneIndex;  		int frameIndex = 0;  		foreach (Dictionary<String' Object> valueMap in values) {  			float time = (float)valueMap ["time"];  			timeline.SetFrame (frameIndex' time' (float)valueMap ["angle"]);  			ReadCurve (timeline' frameIndex' valueMap);  			frameIndex++;  		}  		timelines.Add (timeline);  		duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 2 - 2]);  	}  	else if (timelineName.Equals ("translate") || timelineName.Equals ("scale")) {  		TranslateTimeline timeline;  		float timelineScale = 1;  		if (timelineName.Equals ("scale"))  			timeline = new ScaleTimeline (values.Count);  		else {  			timeline = new TranslateTimeline (values.Count);  			timelineScale = Scale;  		}  		timeline.boneIndex = boneIndex;  		int frameIndex = 0;  		foreach (Dictionary<String' Object> valueMap in values) {  			float time = (float)valueMap ["time"];  			float x = valueMap.ContainsKey ("x") ? (float)valueMap ["x"] : 0;  			float y = valueMap.ContainsKey ("y") ? (float)valueMap ["y"] : 0;  			timeline.SetFrame (frameIndex' time' (float)x * timelineScale' (float)y * timelineScale);  			ReadCurve (timeline' frameIndex' valueMap);  			frameIndex++;  		}  		timelines.Add (timeline);  		duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 3 - 3]);  	}  	else  		throw new Exception ("Invalid timeline type for a bone: " + timelineName + " (" + boneName + ")");  }  
Magic Number,Spine,SkeletonJson,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: if (timelineName.Equals ("rotate")) {  	RotateTimeline timeline = new RotateTimeline (values.Count);  	timeline.boneIndex = boneIndex;  	int frameIndex = 0;  	foreach (Dictionary<String' Object> valueMap in values) {  		float time = (float)valueMap ["time"];  		timeline.SetFrame (frameIndex' time' (float)valueMap ["angle"]);  		ReadCurve (timeline' frameIndex' valueMap);  		frameIndex++;  	}  	timelines.Add (timeline);  	duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 2 - 2]);  }  else if (timelineName.Equals ("translate") || timelineName.Equals ("scale")) {  	TranslateTimeline timeline;  	float timelineScale = 1;  	if (timelineName.Equals ("scale"))  		timeline = new ScaleTimeline (values.Count);  	else {  		timeline = new TranslateTimeline (values.Count);  		timelineScale = Scale;  	}  	timeline.boneIndex = boneIndex;  	int frameIndex = 0;  	foreach (Dictionary<String' Object> valueMap in values) {  		float time = (float)valueMap ["time"];  		float x = valueMap.ContainsKey ("x") ? (float)valueMap ["x"] : 0;  		float y = valueMap.ContainsKey ("y") ? (float)valueMap ["y"] : 0;  		timeline.SetFrame (frameIndex' time' (float)x * timelineScale' (float)y * timelineScale);  		ReadCurve (timeline' frameIndex' valueMap);  		frameIndex++;  	}  	timelines.Add (timeline);  	duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 3 - 3]);  }  else  	throw new Exception ("Invalid timeline type for a bone: " + timelineName + " (" + boneName + ")");  
Magic Number,Spine,SkeletonJson,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: if (timelineName.Equals ("rotate")) {  	RotateTimeline timeline = new RotateTimeline (values.Count);  	timeline.boneIndex = boneIndex;  	int frameIndex = 0;  	foreach (Dictionary<String' Object> valueMap in values) {  		float time = (float)valueMap ["time"];  		timeline.SetFrame (frameIndex' time' (float)valueMap ["angle"]);  		ReadCurve (timeline' frameIndex' valueMap);  		frameIndex++;  	}  	timelines.Add (timeline);  	duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 2 - 2]);  }  else if (timelineName.Equals ("translate") || timelineName.Equals ("scale")) {  	TranslateTimeline timeline;  	float timelineScale = 1;  	if (timelineName.Equals ("scale"))  		timeline = new ScaleTimeline (values.Count);  	else {  		timeline = new TranslateTimeline (values.Count);  		timelineScale = Scale;  	}  	timeline.boneIndex = boneIndex;  	int frameIndex = 0;  	foreach (Dictionary<String' Object> valueMap in values) {  		float time = (float)valueMap ["time"];  		float x = valueMap.ContainsKey ("x") ? (float)valueMap ["x"] : 0;  		float y = valueMap.ContainsKey ("y") ? (float)valueMap ["y"] : 0;  		timeline.SetFrame (frameIndex' time' (float)x * timelineScale' (float)y * timelineScale);  		ReadCurve (timeline' frameIndex' valueMap);  		frameIndex++;  	}  	timelines.Add (timeline);  	duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 3 - 3]);  }  else  	throw new Exception ("Invalid timeline type for a bone: " + timelineName + " (" + boneName + ")");  
Magic Number,Spine,SkeletonJson,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: if (timelineName.Equals ("rotate")) {  	RotateTimeline timeline = new RotateTimeline (values.Count);  	timeline.boneIndex = boneIndex;  	int frameIndex = 0;  	foreach (Dictionary<String' Object> valueMap in values) {  		float time = (float)valueMap ["time"];  		timeline.SetFrame (frameIndex' time' (float)valueMap ["angle"]);  		ReadCurve (timeline' frameIndex' valueMap);  		frameIndex++;  	}  	timelines.Add (timeline);  	duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 2 - 2]);  }  else if (timelineName.Equals ("translate") || timelineName.Equals ("scale")) {  	TranslateTimeline timeline;  	float timelineScale = 1;  	if (timelineName.Equals ("scale"))  		timeline = new ScaleTimeline (values.Count);  	else {  		timeline = new TranslateTimeline (values.Count);  		timelineScale = Scale;  	}  	timeline.boneIndex = boneIndex;  	int frameIndex = 0;  	foreach (Dictionary<String' Object> valueMap in values) {  		float time = (float)valueMap ["time"];  		float x = valueMap.ContainsKey ("x") ? (float)valueMap ["x"] : 0;  		float y = valueMap.ContainsKey ("y") ? (float)valueMap ["y"] : 0;  		timeline.SetFrame (frameIndex' time' (float)x * timelineScale' (float)y * timelineScale);  		ReadCurve (timeline' frameIndex' valueMap);  		frameIndex++;  	}  	timelines.Add (timeline);  	duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 3 - 3]);  }  else  	throw new Exception ("Invalid timeline type for a bone: " + timelineName + " (" + boneName + ")");  
Magic Number,Spine,SkeletonJson,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: if (timelineName.Equals ("rotate")) {  	RotateTimeline timeline = new RotateTimeline (values.Count);  	timeline.boneIndex = boneIndex;  	int frameIndex = 0;  	foreach (Dictionary<String' Object> valueMap in values) {  		float time = (float)valueMap ["time"];  		timeline.SetFrame (frameIndex' time' (float)valueMap ["angle"]);  		ReadCurve (timeline' frameIndex' valueMap);  		frameIndex++;  	}  	timelines.Add (timeline);  	duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 2 - 2]);  }  else if (timelineName.Equals ("translate") || timelineName.Equals ("scale")) {  	TranslateTimeline timeline;  	float timelineScale = 1;  	if (timelineName.Equals ("scale"))  		timeline = new ScaleTimeline (values.Count);  	else {  		timeline = new TranslateTimeline (values.Count);  		timelineScale = Scale;  	}  	timeline.boneIndex = boneIndex;  	int frameIndex = 0;  	foreach (Dictionary<String' Object> valueMap in values) {  		float time = (float)valueMap ["time"];  		float x = valueMap.ContainsKey ("x") ? (float)valueMap ["x"] : 0;  		float y = valueMap.ContainsKey ("y") ? (float)valueMap ["y"] : 0;  		timeline.SetFrame (frameIndex' time' (float)x * timelineScale' (float)y * timelineScale);  		ReadCurve (timeline' frameIndex' valueMap);  		frameIndex++;  	}  	timelines.Add (timeline);  	duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 3 - 3]);  }  else  	throw new Exception ("Invalid timeline type for a bone: " + timelineName + " (" + boneName + ")");  
Magic Number,Spine,SkeletonJson,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 2 - 2]);  
Magic Number,Spine,SkeletonJson,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 2 - 2]);  
Magic Number,Spine,SkeletonJson,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: if (timelineName.Equals ("translate") || timelineName.Equals ("scale")) {  	TranslateTimeline timeline;  	float timelineScale = 1;  	if (timelineName.Equals ("scale"))  		timeline = new ScaleTimeline (values.Count);  	else {  		timeline = new TranslateTimeline (values.Count);  		timelineScale = Scale;  	}  	timeline.boneIndex = boneIndex;  	int frameIndex = 0;  	foreach (Dictionary<String' Object> valueMap in values) {  		float time = (float)valueMap ["time"];  		float x = valueMap.ContainsKey ("x") ? (float)valueMap ["x"] : 0;  		float y = valueMap.ContainsKey ("y") ? (float)valueMap ["y"] : 0;  		timeline.SetFrame (frameIndex' time' (float)x * timelineScale' (float)y * timelineScale);  		ReadCurve (timeline' frameIndex' valueMap);  		frameIndex++;  	}  	timelines.Add (timeline);  	duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 3 - 3]);  }  else  	throw new Exception ("Invalid timeline type for a bone: " + timelineName + " (" + boneName + ")");  
Magic Number,Spine,SkeletonJson,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: if (timelineName.Equals ("translate") || timelineName.Equals ("scale")) {  	TranslateTimeline timeline;  	float timelineScale = 1;  	if (timelineName.Equals ("scale"))  		timeline = new ScaleTimeline (values.Count);  	else {  		timeline = new TranslateTimeline (values.Count);  		timelineScale = Scale;  	}  	timeline.boneIndex = boneIndex;  	int frameIndex = 0;  	foreach (Dictionary<String' Object> valueMap in values) {  		float time = (float)valueMap ["time"];  		float x = valueMap.ContainsKey ("x") ? (float)valueMap ["x"] : 0;  		float y = valueMap.ContainsKey ("y") ? (float)valueMap ["y"] : 0;  		timeline.SetFrame (frameIndex' time' (float)x * timelineScale' (float)y * timelineScale);  		ReadCurve (timeline' frameIndex' valueMap);  		frameIndex++;  	}  	timelines.Add (timeline);  	duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 3 - 3]);  }  else  	throw new Exception ("Invalid timeline type for a bone: " + timelineName + " (" + boneName + ")");  
Magic Number,Spine,SkeletonJson,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 3 - 3]);  
Magic Number,Spine,SkeletonJson,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 3 - 3]);  
Magic Number,Spine,SkeletonJson,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: if (map.ContainsKey ("slots")) {  	foreach (KeyValuePair<String' Object> entry in (Dictionary<String' Object>)map ["slots"]) {  		String slotName = entry.Key;  		int slotIndex = skeletonData.FindSlotIndex (slotName);  		var timelineMap = (Dictionary<String' Object>)entry.Value;  		foreach (KeyValuePair<String' Object> timelineEntry in timelineMap) {  			var values = (List<Object>)timelineEntry.Value;  			String timelineName = (String)timelineEntry.Key;  			if (timelineName.Equals ("color")) {  				ColorTimeline timeline = new ColorTimeline (values.Count);  				timeline.slotIndex = slotIndex;  				int frameIndex = 0;  				foreach (Dictionary<String' Object> valueMap in values) {  					float time = (float)valueMap ["time"];  					String c = (String)valueMap ["color"];  					timeline.setFrame (frameIndex' time' ToColor (c' 0)' ToColor (c' 1)' ToColor (c' 2)' ToColor (c' 3));  					ReadCurve (timeline' frameIndex' valueMap);  					frameIndex++;  				}  				timelines.Add (timeline);  				duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 5 - 5]);  			}  			else if (timelineName.Equals ("attachment")) {  				AttachmentTimeline timeline = new AttachmentTimeline (values.Count);  				timeline.slotIndex = slotIndex;  				int frameIndex = 0;  				foreach (Dictionary<String' Object> valueMap in values) {  					float time = (float)valueMap ["time"];  					timeline.setFrame (frameIndex++' time' (String)valueMap ["name"]);  				}  				timelines.Add (timeline);  				duration = Math.Max (duration' timeline.frames [timeline.FrameCount - 1]);  			}  			else  				throw new Exception ("Invalid timeline type for a slot: " + timelineName + " (" + slotName + ")");  		}  	}  }  
Magic Number,Spine,SkeletonJson,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: if (map.ContainsKey ("slots")) {  	foreach (KeyValuePair<String' Object> entry in (Dictionary<String' Object>)map ["slots"]) {  		String slotName = entry.Key;  		int slotIndex = skeletonData.FindSlotIndex (slotName);  		var timelineMap = (Dictionary<String' Object>)entry.Value;  		foreach (KeyValuePair<String' Object> timelineEntry in timelineMap) {  			var values = (List<Object>)timelineEntry.Value;  			String timelineName = (String)timelineEntry.Key;  			if (timelineName.Equals ("color")) {  				ColorTimeline timeline = new ColorTimeline (values.Count);  				timeline.slotIndex = slotIndex;  				int frameIndex = 0;  				foreach (Dictionary<String' Object> valueMap in values) {  					float time = (float)valueMap ["time"];  					String c = (String)valueMap ["color"];  					timeline.setFrame (frameIndex' time' ToColor (c' 0)' ToColor (c' 1)' ToColor (c' 2)' ToColor (c' 3));  					ReadCurve (timeline' frameIndex' valueMap);  					frameIndex++;  				}  				timelines.Add (timeline);  				duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 5 - 5]);  			}  			else if (timelineName.Equals ("attachment")) {  				AttachmentTimeline timeline = new AttachmentTimeline (values.Count);  				timeline.slotIndex = slotIndex;  				int frameIndex = 0;  				foreach (Dictionary<String' Object> valueMap in values) {  					float time = (float)valueMap ["time"];  					timeline.setFrame (frameIndex++' time' (String)valueMap ["name"]);  				}  				timelines.Add (timeline);  				duration = Math.Max (duration' timeline.frames [timeline.FrameCount - 1]);  			}  			else  				throw new Exception ("Invalid timeline type for a slot: " + timelineName + " (" + slotName + ")");  		}  	}  }  
Magic Number,Spine,SkeletonJson,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: if (map.ContainsKey ("slots")) {  	foreach (KeyValuePair<String' Object> entry in (Dictionary<String' Object>)map ["slots"]) {  		String slotName = entry.Key;  		int slotIndex = skeletonData.FindSlotIndex (slotName);  		var timelineMap = (Dictionary<String' Object>)entry.Value;  		foreach (KeyValuePair<String' Object> timelineEntry in timelineMap) {  			var values = (List<Object>)timelineEntry.Value;  			String timelineName = (String)timelineEntry.Key;  			if (timelineName.Equals ("color")) {  				ColorTimeline timeline = new ColorTimeline (values.Count);  				timeline.slotIndex = slotIndex;  				int frameIndex = 0;  				foreach (Dictionary<String' Object> valueMap in values) {  					float time = (float)valueMap ["time"];  					String c = (String)valueMap ["color"];  					timeline.setFrame (frameIndex' time' ToColor (c' 0)' ToColor (c' 1)' ToColor (c' 2)' ToColor (c' 3));  					ReadCurve (timeline' frameIndex' valueMap);  					frameIndex++;  				}  				timelines.Add (timeline);  				duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 5 - 5]);  			}  			else if (timelineName.Equals ("attachment")) {  				AttachmentTimeline timeline = new AttachmentTimeline (values.Count);  				timeline.slotIndex = slotIndex;  				int frameIndex = 0;  				foreach (Dictionary<String' Object> valueMap in values) {  					float time = (float)valueMap ["time"];  					timeline.setFrame (frameIndex++' time' (String)valueMap ["name"]);  				}  				timelines.Add (timeline);  				duration = Math.Max (duration' timeline.frames [timeline.FrameCount - 1]);  			}  			else  				throw new Exception ("Invalid timeline type for a slot: " + timelineName + " (" + slotName + ")");  		}  	}  }  
Magic Number,Spine,SkeletonJson,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: if (map.ContainsKey ("slots")) {  	foreach (KeyValuePair<String' Object> entry in (Dictionary<String' Object>)map ["slots"]) {  		String slotName = entry.Key;  		int slotIndex = skeletonData.FindSlotIndex (slotName);  		var timelineMap = (Dictionary<String' Object>)entry.Value;  		foreach (KeyValuePair<String' Object> timelineEntry in timelineMap) {  			var values = (List<Object>)timelineEntry.Value;  			String timelineName = (String)timelineEntry.Key;  			if (timelineName.Equals ("color")) {  				ColorTimeline timeline = new ColorTimeline (values.Count);  				timeline.slotIndex = slotIndex;  				int frameIndex = 0;  				foreach (Dictionary<String' Object> valueMap in values) {  					float time = (float)valueMap ["time"];  					String c = (String)valueMap ["color"];  					timeline.setFrame (frameIndex' time' ToColor (c' 0)' ToColor (c' 1)' ToColor (c' 2)' ToColor (c' 3));  					ReadCurve (timeline' frameIndex' valueMap);  					frameIndex++;  				}  				timelines.Add (timeline);  				duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 5 - 5]);  			}  			else if (timelineName.Equals ("attachment")) {  				AttachmentTimeline timeline = new AttachmentTimeline (values.Count);  				timeline.slotIndex = slotIndex;  				int frameIndex = 0;  				foreach (Dictionary<String' Object> valueMap in values) {  					float time = (float)valueMap ["time"];  					timeline.setFrame (frameIndex++' time' (String)valueMap ["name"]);  				}  				timelines.Add (timeline);  				duration = Math.Max (duration' timeline.frames [timeline.FrameCount - 1]);  			}  			else  				throw new Exception ("Invalid timeline type for a slot: " + timelineName + " (" + slotName + ")");  		}  	}  }  
Magic Number,Spine,SkeletonJson,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: foreach (KeyValuePair<String' Object> entry in (Dictionary<String' Object>)map ["slots"]) {  	String slotName = entry.Key;  	int slotIndex = skeletonData.FindSlotIndex (slotName);  	var timelineMap = (Dictionary<String' Object>)entry.Value;  	foreach (KeyValuePair<String' Object> timelineEntry in timelineMap) {  		var values = (List<Object>)timelineEntry.Value;  		String timelineName = (String)timelineEntry.Key;  		if (timelineName.Equals ("color")) {  			ColorTimeline timeline = new ColorTimeline (values.Count);  			timeline.slotIndex = slotIndex;  			int frameIndex = 0;  			foreach (Dictionary<String' Object> valueMap in values) {  				float time = (float)valueMap ["time"];  				String c = (String)valueMap ["color"];  				timeline.setFrame (frameIndex' time' ToColor (c' 0)' ToColor (c' 1)' ToColor (c' 2)' ToColor (c' 3));  				ReadCurve (timeline' frameIndex' valueMap);  				frameIndex++;  			}  			timelines.Add (timeline);  			duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 5 - 5]);  		}  		else if (timelineName.Equals ("attachment")) {  			AttachmentTimeline timeline = new AttachmentTimeline (values.Count);  			timeline.slotIndex = slotIndex;  			int frameIndex = 0;  			foreach (Dictionary<String' Object> valueMap in values) {  				float time = (float)valueMap ["time"];  				timeline.setFrame (frameIndex++' time' (String)valueMap ["name"]);  			}  			timelines.Add (timeline);  			duration = Math.Max (duration' timeline.frames [timeline.FrameCount - 1]);  		}  		else  			throw new Exception ("Invalid timeline type for a slot: " + timelineName + " (" + slotName + ")");  	}  }  
Magic Number,Spine,SkeletonJson,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: foreach (KeyValuePair<String' Object> entry in (Dictionary<String' Object>)map ["slots"]) {  	String slotName = entry.Key;  	int slotIndex = skeletonData.FindSlotIndex (slotName);  	var timelineMap = (Dictionary<String' Object>)entry.Value;  	foreach (KeyValuePair<String' Object> timelineEntry in timelineMap) {  		var values = (List<Object>)timelineEntry.Value;  		String timelineName = (String)timelineEntry.Key;  		if (timelineName.Equals ("color")) {  			ColorTimeline timeline = new ColorTimeline (values.Count);  			timeline.slotIndex = slotIndex;  			int frameIndex = 0;  			foreach (Dictionary<String' Object> valueMap in values) {  				float time = (float)valueMap ["time"];  				String c = (String)valueMap ["color"];  				timeline.setFrame (frameIndex' time' ToColor (c' 0)' ToColor (c' 1)' ToColor (c' 2)' ToColor (c' 3));  				ReadCurve (timeline' frameIndex' valueMap);  				frameIndex++;  			}  			timelines.Add (timeline);  			duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 5 - 5]);  		}  		else if (timelineName.Equals ("attachment")) {  			AttachmentTimeline timeline = new AttachmentTimeline (values.Count);  			timeline.slotIndex = slotIndex;  			int frameIndex = 0;  			foreach (Dictionary<String' Object> valueMap in values) {  				float time = (float)valueMap ["time"];  				timeline.setFrame (frameIndex++' time' (String)valueMap ["name"]);  			}  			timelines.Add (timeline);  			duration = Math.Max (duration' timeline.frames [timeline.FrameCount - 1]);  		}  		else  			throw new Exception ("Invalid timeline type for a slot: " + timelineName + " (" + slotName + ")");  	}  }  
Magic Number,Spine,SkeletonJson,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: foreach (KeyValuePair<String' Object> entry in (Dictionary<String' Object>)map ["slots"]) {  	String slotName = entry.Key;  	int slotIndex = skeletonData.FindSlotIndex (slotName);  	var timelineMap = (Dictionary<String' Object>)entry.Value;  	foreach (KeyValuePair<String' Object> timelineEntry in timelineMap) {  		var values = (List<Object>)timelineEntry.Value;  		String timelineName = (String)timelineEntry.Key;  		if (timelineName.Equals ("color")) {  			ColorTimeline timeline = new ColorTimeline (values.Count);  			timeline.slotIndex = slotIndex;  			int frameIndex = 0;  			foreach (Dictionary<String' Object> valueMap in values) {  				float time = (float)valueMap ["time"];  				String c = (String)valueMap ["color"];  				timeline.setFrame (frameIndex' time' ToColor (c' 0)' ToColor (c' 1)' ToColor (c' 2)' ToColor (c' 3));  				ReadCurve (timeline' frameIndex' valueMap);  				frameIndex++;  			}  			timelines.Add (timeline);  			duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 5 - 5]);  		}  		else if (timelineName.Equals ("attachment")) {  			AttachmentTimeline timeline = new AttachmentTimeline (values.Count);  			timeline.slotIndex = slotIndex;  			int frameIndex = 0;  			foreach (Dictionary<String' Object> valueMap in values) {  				float time = (float)valueMap ["time"];  				timeline.setFrame (frameIndex++' time' (String)valueMap ["name"]);  			}  			timelines.Add (timeline);  			duration = Math.Max (duration' timeline.frames [timeline.FrameCount - 1]);  		}  		else  			throw new Exception ("Invalid timeline type for a slot: " + timelineName + " (" + slotName + ")");  	}  }  
Magic Number,Spine,SkeletonJson,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: foreach (KeyValuePair<String' Object> entry in (Dictionary<String' Object>)map ["slots"]) {  	String slotName = entry.Key;  	int slotIndex = skeletonData.FindSlotIndex (slotName);  	var timelineMap = (Dictionary<String' Object>)entry.Value;  	foreach (KeyValuePair<String' Object> timelineEntry in timelineMap) {  		var values = (List<Object>)timelineEntry.Value;  		String timelineName = (String)timelineEntry.Key;  		if (timelineName.Equals ("color")) {  			ColorTimeline timeline = new ColorTimeline (values.Count);  			timeline.slotIndex = slotIndex;  			int frameIndex = 0;  			foreach (Dictionary<String' Object> valueMap in values) {  				float time = (float)valueMap ["time"];  				String c = (String)valueMap ["color"];  				timeline.setFrame (frameIndex' time' ToColor (c' 0)' ToColor (c' 1)' ToColor (c' 2)' ToColor (c' 3));  				ReadCurve (timeline' frameIndex' valueMap);  				frameIndex++;  			}  			timelines.Add (timeline);  			duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 5 - 5]);  		}  		else if (timelineName.Equals ("attachment")) {  			AttachmentTimeline timeline = new AttachmentTimeline (values.Count);  			timeline.slotIndex = slotIndex;  			int frameIndex = 0;  			foreach (Dictionary<String' Object> valueMap in values) {  				float time = (float)valueMap ["time"];  				timeline.setFrame (frameIndex++' time' (String)valueMap ["name"]);  			}  			timelines.Add (timeline);  			duration = Math.Max (duration' timeline.frames [timeline.FrameCount - 1]);  		}  		else  			throw new Exception ("Invalid timeline type for a slot: " + timelineName + " (" + slotName + ")");  	}  }  
Magic Number,Spine,SkeletonJson,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: foreach (KeyValuePair<String' Object> timelineEntry in timelineMap) {  	var values = (List<Object>)timelineEntry.Value;  	String timelineName = (String)timelineEntry.Key;  	if (timelineName.Equals ("color")) {  		ColorTimeline timeline = new ColorTimeline (values.Count);  		timeline.slotIndex = slotIndex;  		int frameIndex = 0;  		foreach (Dictionary<String' Object> valueMap in values) {  			float time = (float)valueMap ["time"];  			String c = (String)valueMap ["color"];  			timeline.setFrame (frameIndex' time' ToColor (c' 0)' ToColor (c' 1)' ToColor (c' 2)' ToColor (c' 3));  			ReadCurve (timeline' frameIndex' valueMap);  			frameIndex++;  		}  		timelines.Add (timeline);  		duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 5 - 5]);  	}  	else if (timelineName.Equals ("attachment")) {  		AttachmentTimeline timeline = new AttachmentTimeline (values.Count);  		timeline.slotIndex = slotIndex;  		int frameIndex = 0;  		foreach (Dictionary<String' Object> valueMap in values) {  			float time = (float)valueMap ["time"];  			timeline.setFrame (frameIndex++' time' (String)valueMap ["name"]);  		}  		timelines.Add (timeline);  		duration = Math.Max (duration' timeline.frames [timeline.FrameCount - 1]);  	}  	else  		throw new Exception ("Invalid timeline type for a slot: " + timelineName + " (" + slotName + ")");  }  
Magic Number,Spine,SkeletonJson,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: foreach (KeyValuePair<String' Object> timelineEntry in timelineMap) {  	var values = (List<Object>)timelineEntry.Value;  	String timelineName = (String)timelineEntry.Key;  	if (timelineName.Equals ("color")) {  		ColorTimeline timeline = new ColorTimeline (values.Count);  		timeline.slotIndex = slotIndex;  		int frameIndex = 0;  		foreach (Dictionary<String' Object> valueMap in values) {  			float time = (float)valueMap ["time"];  			String c = (String)valueMap ["color"];  			timeline.setFrame (frameIndex' time' ToColor (c' 0)' ToColor (c' 1)' ToColor (c' 2)' ToColor (c' 3));  			ReadCurve (timeline' frameIndex' valueMap);  			frameIndex++;  		}  		timelines.Add (timeline);  		duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 5 - 5]);  	}  	else if (timelineName.Equals ("attachment")) {  		AttachmentTimeline timeline = new AttachmentTimeline (values.Count);  		timeline.slotIndex = slotIndex;  		int frameIndex = 0;  		foreach (Dictionary<String' Object> valueMap in values) {  			float time = (float)valueMap ["time"];  			timeline.setFrame (frameIndex++' time' (String)valueMap ["name"]);  		}  		timelines.Add (timeline);  		duration = Math.Max (duration' timeline.frames [timeline.FrameCount - 1]);  	}  	else  		throw new Exception ("Invalid timeline type for a slot: " + timelineName + " (" + slotName + ")");  }  
Magic Number,Spine,SkeletonJson,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: foreach (KeyValuePair<String' Object> timelineEntry in timelineMap) {  	var values = (List<Object>)timelineEntry.Value;  	String timelineName = (String)timelineEntry.Key;  	if (timelineName.Equals ("color")) {  		ColorTimeline timeline = new ColorTimeline (values.Count);  		timeline.slotIndex = slotIndex;  		int frameIndex = 0;  		foreach (Dictionary<String' Object> valueMap in values) {  			float time = (float)valueMap ["time"];  			String c = (String)valueMap ["color"];  			timeline.setFrame (frameIndex' time' ToColor (c' 0)' ToColor (c' 1)' ToColor (c' 2)' ToColor (c' 3));  			ReadCurve (timeline' frameIndex' valueMap);  			frameIndex++;  		}  		timelines.Add (timeline);  		duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 5 - 5]);  	}  	else if (timelineName.Equals ("attachment")) {  		AttachmentTimeline timeline = new AttachmentTimeline (values.Count);  		timeline.slotIndex = slotIndex;  		int frameIndex = 0;  		foreach (Dictionary<String' Object> valueMap in values) {  			float time = (float)valueMap ["time"];  			timeline.setFrame (frameIndex++' time' (String)valueMap ["name"]);  		}  		timelines.Add (timeline);  		duration = Math.Max (duration' timeline.frames [timeline.FrameCount - 1]);  	}  	else  		throw new Exception ("Invalid timeline type for a slot: " + timelineName + " (" + slotName + ")");  }  
Magic Number,Spine,SkeletonJson,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: foreach (KeyValuePair<String' Object> timelineEntry in timelineMap) {  	var values = (List<Object>)timelineEntry.Value;  	String timelineName = (String)timelineEntry.Key;  	if (timelineName.Equals ("color")) {  		ColorTimeline timeline = new ColorTimeline (values.Count);  		timeline.slotIndex = slotIndex;  		int frameIndex = 0;  		foreach (Dictionary<String' Object> valueMap in values) {  			float time = (float)valueMap ["time"];  			String c = (String)valueMap ["color"];  			timeline.setFrame (frameIndex' time' ToColor (c' 0)' ToColor (c' 1)' ToColor (c' 2)' ToColor (c' 3));  			ReadCurve (timeline' frameIndex' valueMap);  			frameIndex++;  		}  		timelines.Add (timeline);  		duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 5 - 5]);  	}  	else if (timelineName.Equals ("attachment")) {  		AttachmentTimeline timeline = new AttachmentTimeline (values.Count);  		timeline.slotIndex = slotIndex;  		int frameIndex = 0;  		foreach (Dictionary<String' Object> valueMap in values) {  			float time = (float)valueMap ["time"];  			timeline.setFrame (frameIndex++' time' (String)valueMap ["name"]);  		}  		timelines.Add (timeline);  		duration = Math.Max (duration' timeline.frames [timeline.FrameCount - 1]);  	}  	else  		throw new Exception ("Invalid timeline type for a slot: " + timelineName + " (" + slotName + ")");  }  
Magic Number,Spine,SkeletonJson,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: if (timelineName.Equals ("color")) {  	ColorTimeline timeline = new ColorTimeline (values.Count);  	timeline.slotIndex = slotIndex;  	int frameIndex = 0;  	foreach (Dictionary<String' Object> valueMap in values) {  		float time = (float)valueMap ["time"];  		String c = (String)valueMap ["color"];  		timeline.setFrame (frameIndex' time' ToColor (c' 0)' ToColor (c' 1)' ToColor (c' 2)' ToColor (c' 3));  		ReadCurve (timeline' frameIndex' valueMap);  		frameIndex++;  	}  	timelines.Add (timeline);  	duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 5 - 5]);  }  else if (timelineName.Equals ("attachment")) {  	AttachmentTimeline timeline = new AttachmentTimeline (values.Count);  	timeline.slotIndex = slotIndex;  	int frameIndex = 0;  	foreach (Dictionary<String' Object> valueMap in values) {  		float time = (float)valueMap ["time"];  		timeline.setFrame (frameIndex++' time' (String)valueMap ["name"]);  	}  	timelines.Add (timeline);  	duration = Math.Max (duration' timeline.frames [timeline.FrameCount - 1]);  }  else  	throw new Exception ("Invalid timeline type for a slot: " + timelineName + " (" + slotName + ")");  
Magic Number,Spine,SkeletonJson,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: if (timelineName.Equals ("color")) {  	ColorTimeline timeline = new ColorTimeline (values.Count);  	timeline.slotIndex = slotIndex;  	int frameIndex = 0;  	foreach (Dictionary<String' Object> valueMap in values) {  		float time = (float)valueMap ["time"];  		String c = (String)valueMap ["color"];  		timeline.setFrame (frameIndex' time' ToColor (c' 0)' ToColor (c' 1)' ToColor (c' 2)' ToColor (c' 3));  		ReadCurve (timeline' frameIndex' valueMap);  		frameIndex++;  	}  	timelines.Add (timeline);  	duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 5 - 5]);  }  else if (timelineName.Equals ("attachment")) {  	AttachmentTimeline timeline = new AttachmentTimeline (values.Count);  	timeline.slotIndex = slotIndex;  	int frameIndex = 0;  	foreach (Dictionary<String' Object> valueMap in values) {  		float time = (float)valueMap ["time"];  		timeline.setFrame (frameIndex++' time' (String)valueMap ["name"]);  	}  	timelines.Add (timeline);  	duration = Math.Max (duration' timeline.frames [timeline.FrameCount - 1]);  }  else  	throw new Exception ("Invalid timeline type for a slot: " + timelineName + " (" + slotName + ")");  
Magic Number,Spine,SkeletonJson,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: if (timelineName.Equals ("color")) {  	ColorTimeline timeline = new ColorTimeline (values.Count);  	timeline.slotIndex = slotIndex;  	int frameIndex = 0;  	foreach (Dictionary<String' Object> valueMap in values) {  		float time = (float)valueMap ["time"];  		String c = (String)valueMap ["color"];  		timeline.setFrame (frameIndex' time' ToColor (c' 0)' ToColor (c' 1)' ToColor (c' 2)' ToColor (c' 3));  		ReadCurve (timeline' frameIndex' valueMap);  		frameIndex++;  	}  	timelines.Add (timeline);  	duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 5 - 5]);  }  else if (timelineName.Equals ("attachment")) {  	AttachmentTimeline timeline = new AttachmentTimeline (values.Count);  	timeline.slotIndex = slotIndex;  	int frameIndex = 0;  	foreach (Dictionary<String' Object> valueMap in values) {  		float time = (float)valueMap ["time"];  		timeline.setFrame (frameIndex++' time' (String)valueMap ["name"]);  	}  	timelines.Add (timeline);  	duration = Math.Max (duration' timeline.frames [timeline.FrameCount - 1]);  }  else  	throw new Exception ("Invalid timeline type for a slot: " + timelineName + " (" + slotName + ")");  
Magic Number,Spine,SkeletonJson,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: if (timelineName.Equals ("color")) {  	ColorTimeline timeline = new ColorTimeline (values.Count);  	timeline.slotIndex = slotIndex;  	int frameIndex = 0;  	foreach (Dictionary<String' Object> valueMap in values) {  		float time = (float)valueMap ["time"];  		String c = (String)valueMap ["color"];  		timeline.setFrame (frameIndex' time' ToColor (c' 0)' ToColor (c' 1)' ToColor (c' 2)' ToColor (c' 3));  		ReadCurve (timeline' frameIndex' valueMap);  		frameIndex++;  	}  	timelines.Add (timeline);  	duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 5 - 5]);  }  else if (timelineName.Equals ("attachment")) {  	AttachmentTimeline timeline = new AttachmentTimeline (values.Count);  	timeline.slotIndex = slotIndex;  	int frameIndex = 0;  	foreach (Dictionary<String' Object> valueMap in values) {  		float time = (float)valueMap ["time"];  		timeline.setFrame (frameIndex++' time' (String)valueMap ["name"]);  	}  	timelines.Add (timeline);  	duration = Math.Max (duration' timeline.frames [timeline.FrameCount - 1]);  }  else  	throw new Exception ("Invalid timeline type for a slot: " + timelineName + " (" + slotName + ")");  
Magic Number,Spine,SkeletonJson,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: foreach (Dictionary<String' Object> valueMap in values) {  	float time = (float)valueMap ["time"];  	String c = (String)valueMap ["color"];  	timeline.setFrame (frameIndex' time' ToColor (c' 0)' ToColor (c' 1)' ToColor (c' 2)' ToColor (c' 3));  	ReadCurve (timeline' frameIndex' valueMap);  	frameIndex++;  }  
Magic Number,Spine,SkeletonJson,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: foreach (Dictionary<String' Object> valueMap in values) {  	float time = (float)valueMap ["time"];  	String c = (String)valueMap ["color"];  	timeline.setFrame (frameIndex' time' ToColor (c' 0)' ToColor (c' 1)' ToColor (c' 2)' ToColor (c' 3));  	ReadCurve (timeline' frameIndex' valueMap);  	frameIndex++;  }  
Magic Number,Spine,SkeletonJson,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: timeline.setFrame (frameIndex' time' ToColor (c' 0)' ToColor (c' 1)' ToColor (c' 2)' ToColor (c' 3));  
Magic Number,Spine,SkeletonJson,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: timeline.setFrame (frameIndex' time' ToColor (c' 0)' ToColor (c' 1)' ToColor (c' 2)' ToColor (c' 3));  
Magic Number,Spine,SkeletonJson,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 5 - 5]);  
Magic Number,Spine,SkeletonJson,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: duration = Math.Max (duration' timeline.frames [timeline.FrameCount * 5 - 5]);  
Magic Number,Spine,SkeletonJson,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonJson.cs,ReadCurve,The following statement contains a magic number: if (curveObject.Equals ("stepped"))  	timeline.SetStepped (frameIndex);  else if (curveObject is List<Object>) {  	List<Object> curve = (List<Object>)curveObject;  	timeline.SetCurve (frameIndex' (float)curve [0]' (float)curve [1]' (float)curve [2]' (float)curve [3]);  }  
Magic Number,Spine,SkeletonJson,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonJson.cs,ReadCurve,The following statement contains a magic number: if (curveObject.Equals ("stepped"))  	timeline.SetStepped (frameIndex);  else if (curveObject is List<Object>) {  	List<Object> curve = (List<Object>)curveObject;  	timeline.SetCurve (frameIndex' (float)curve [0]' (float)curve [1]' (float)curve [2]' (float)curve [3]);  }  
Magic Number,Spine,SkeletonJson,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonJson.cs,ReadCurve,The following statement contains a magic number: if (curveObject is List<Object>) {  	List<Object> curve = (List<Object>)curveObject;  	timeline.SetCurve (frameIndex' (float)curve [0]' (float)curve [1]' (float)curve [2]' (float)curve [3]);  }  
Magic Number,Spine,SkeletonJson,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonJson.cs,ReadCurve,The following statement contains a magic number: if (curveObject is List<Object>) {  	List<Object> curve = (List<Object>)curveObject;  	timeline.SetCurve (frameIndex' (float)curve [0]' (float)curve [1]' (float)curve [2]' (float)curve [3]);  }  
Magic Number,Spine,SkeletonJson,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonJson.cs,ReadCurve,The following statement contains a magic number: timeline.SetCurve (frameIndex' (float)curve [0]' (float)curve [1]' (float)curve [2]' (float)curve [3]);  
Magic Number,Spine,SkeletonJson,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\SkeletonJson.cs,ReadCurve,The following statement contains a magic number: timeline.SetCurve (frameIndex' (float)curve [0]' (float)curve [1]' (float)curve [2]' (float)curve [3]);  
Missing Default,Spine,AtlasAttachmentLoader,C:\repos\marxistpokemon_Diana\Prototipos_Diana\Assets\Spine\spine-csharp\Attachments\AtlasAttachmentLoader.cs,NewAttachment,The following switch statement is missing a default case: switch (type) {  case AttachmentType.region:  	AtlasRegion region = atlas.FindRegion (name);  	if (region == null)  		throw new Exception ("Region not found in atlas: " + name + " (" + type + ")");  	RegionAttachment attachment = new RegionAttachment (name);  	attachment.RendererObject = region;  	attachment.SetUVs (region.u' region.v' region.u2' region.v2' region.rotate);  	attachment.regionOffsetX = region.offsetX;  	attachment.regionOffsetY = region.offsetY;  	attachment.regionWidth = region.width;  	attachment.regionHeight = region.height;  	attachment.regionOriginalWidth = region.originalWidth;  	attachment.regionOriginalHeight = region.originalHeight;  	return attachment;  case AttachmentType.boundingbox:  	return new BoundingBoxAttachment (name);  }  
