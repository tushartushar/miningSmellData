Implementation smell,Namespace,Class,File,Method,Description
Long Method,Thought.vCards,vCardStandardReader,C:\repos\drlongnecker_Thought.vCards\Solution\Thought.vCards\vCardStandardReader.cs,DecodeQuotedPrintable,The method has 147 lines of code.
Long Method,Thought.vCards,vCardStandardReader,C:\repos\drlongnecker_Thought.vCards\Solution\Thought.vCards\vCardStandardReader.cs,ReadProperty,The method has 159 lines of code.
Complex Method,Thought.vCards,vCardStandardWriter,C:\repos\drlongnecker_Thought.vCards\Solution\Thought.vCards\vCardStandardWriter.cs,BuildProperties_ADR,Cyclomatic complexity of the method is 9
Complex Method,Thought.vCards,vCardStandardWriter,C:\repos\drlongnecker_Thought.vCards\Solution\Thought.vCards\vCardStandardWriter.cs,BuildProperties_LABEL,Cyclomatic complexity of the method is 9
Complex Method,Thought.vCards,vCardStandardWriter,C:\repos\drlongnecker_Thought.vCards\Solution\Thought.vCards\vCardStandardWriter.cs,BuildProperties_TEL,Cyclomatic complexity of the method is 15
Complex Method,Thought.vCards,vCardStandardReader,C:\repos\drlongnecker_Thought.vCards\Solution\Thought.vCards\vCardStandardReader.cs,ReadInto_ADR,Cyclomatic complexity of the method is 9
Complex Conditional,Thought.vCards,vCardStandardWriter,C:\repos\drlongnecker_Thought.vCards\Solution\Thought.vCards\vCardStandardWriter.cs,BuildProperties_ADR,The conditional expression  "(!string.IsNullOrEmpty(address.City)) ||                      (!string.IsNullOrEmpty(address.Country)) ||                      (!string.IsNullOrEmpty(address.PostalCode)) ||                      (!string.IsNullOrEmpty(address.Region)) ||                      (!string.IsNullOrEmpty(address.Street))"  is complex.
Complex Conditional,Thought.vCards,vCardStandardWriter,C:\repos\drlongnecker_Thought.vCards\Solution\Thought.vCards\vCardStandardWriter.cs,EncodeQuotedPrintable,The conditional expression  "(v == 9) ||                      ((v >= 32) && (v <= 60)) ||                      ((v >= 62) && (v <= 126))"  is complex.
Complex Conditional,Thought.vCards,vCardStandardReader,C:\repos\drlongnecker_Thought.vCards\Solution\Thought.vCards\vCardStandardReader.cs,ReadInto_ADR,The conditional expression  "(string.IsNullOrEmpty(deliveryAddress.City)) &&                  (string.IsNullOrEmpty(deliveryAddress.Country)) &&                  (string.IsNullOrEmpty(deliveryAddress.PostalCode)) &&                  (string.IsNullOrEmpty(deliveryAddress.Region)) &&                  (string.IsNullOrEmpty(deliveryAddress.Street))"  is complex.
Virtual Method Call from Constructor,Thought.vCards,vCard,C:\repos\drlongnecker_Thought.vCards\Solution\Thought.vCards\vCard.cs,vCard,The constructor "vCard" calls a virtual method "ReadInto".
Virtual Method Call from Constructor,Thought.vCards,vCard,C:\repos\drlongnecker_Thought.vCards\Solution\Thought.vCards\vCard.cs,vCard,The constructor "vCard" calls a virtual method "ReadInto".
Magic Number,Thought.vCards,vCardStandardWriter,C:\repos\drlongnecker_Thought.vCards\Solution\Thought.vCards\vCardStandardWriter.cs,EncodeBase64,The following statement contains a magic number: byte[] buffer = new byte[4];
Magic Number,Thought.vCards,vCardStandardWriter,C:\repos\drlongnecker_Thought.vCards\Solution\Thought.vCards\vCardStandardWriter.cs,EncodeBase64,The following statement contains a magic number: buffer[1] = (byte)(value >> 8);
Magic Number,Thought.vCards,vCardStandardWriter,C:\repos\drlongnecker_Thought.vCards\Solution\Thought.vCards\vCardStandardWriter.cs,EncodeBase64,The following statement contains a magic number: buffer[2] = (byte)(value >> 16);
Magic Number,Thought.vCards,vCardStandardWriter,C:\repos\drlongnecker_Thought.vCards\Solution\Thought.vCards\vCardStandardWriter.cs,EncodeBase64,The following statement contains a magic number: buffer[2] = (byte)(value >> 16);
Magic Number,Thought.vCards,vCardStandardWriter,C:\repos\drlongnecker_Thought.vCards\Solution\Thought.vCards\vCardStandardWriter.cs,EncodeBase64,The following statement contains a magic number: buffer[3] = (byte)(value >> 24);
Magic Number,Thought.vCards,vCardStandardWriter,C:\repos\drlongnecker_Thought.vCards\Solution\Thought.vCards\vCardStandardWriter.cs,EncodeBase64,The following statement contains a magic number: buffer[3] = (byte)(value >> 24);
Magic Number,Thought.vCards,vCardStandardWriter,C:\repos\drlongnecker_Thought.vCards\Solution\Thought.vCards\vCardStandardWriter.cs,EncodeQuotedPrintable,The following statement contains a magic number: foreach (char c in value)              {                    int v = (int)c;                    // The following are not required to be encoded:                  //                  // - Tab (ASCII 9)                  // - Space (ASCII 32)                  // - Characters 33 to 126' except for the equal sign (61).                    if (                      (v == 9) ||                      ((v >= 32) && (v <= 60)) ||                      ((v >= 62) && (v <= 126)))                  {                      builder.Append(c);                  }                  else                  {                      builder.Append('=');                      builder.Append(v.ToString("X2"));                  }                }
Magic Number,Thought.vCards,vCardStandardWriter,C:\repos\drlongnecker_Thought.vCards\Solution\Thought.vCards\vCardStandardWriter.cs,EncodeQuotedPrintable,The following statement contains a magic number: foreach (char c in value)              {                    int v = (int)c;                    // The following are not required to be encoded:                  //                  // - Tab (ASCII 9)                  // - Space (ASCII 32)                  // - Characters 33 to 126' except for the equal sign (61).                    if (                      (v == 9) ||                      ((v >= 32) && (v <= 60)) ||                      ((v >= 62) && (v <= 126)))                  {                      builder.Append(c);                  }                  else                  {                      builder.Append('=');                      builder.Append(v.ToString("X2"));                  }                }
Magic Number,Thought.vCards,vCardStandardWriter,C:\repos\drlongnecker_Thought.vCards\Solution\Thought.vCards\vCardStandardWriter.cs,EncodeQuotedPrintable,The following statement contains a magic number: foreach (char c in value)              {                    int v = (int)c;                    // The following are not required to be encoded:                  //                  // - Tab (ASCII 9)                  // - Space (ASCII 32)                  // - Characters 33 to 126' except for the equal sign (61).                    if (                      (v == 9) ||                      ((v >= 32) && (v <= 60)) ||                      ((v >= 62) && (v <= 126)))                  {                      builder.Append(c);                  }                  else                  {                      builder.Append('=');                      builder.Append(v.ToString("X2"));                  }                }
Magic Number,Thought.vCards,vCardStandardWriter,C:\repos\drlongnecker_Thought.vCards\Solution\Thought.vCards\vCardStandardWriter.cs,EncodeQuotedPrintable,The following statement contains a magic number: foreach (char c in value)              {                    int v = (int)c;                    // The following are not required to be encoded:                  //                  // - Tab (ASCII 9)                  // - Space (ASCII 32)                  // - Characters 33 to 126' except for the equal sign (61).                    if (                      (v == 9) ||                      ((v >= 32) && (v <= 60)) ||                      ((v >= 62) && (v <= 126)))                  {                      builder.Append(c);                  }                  else                  {                      builder.Append('=');                      builder.Append(v.ToString("X2"));                  }                }
Magic Number,Thought.vCards,vCardStandardWriter,C:\repos\drlongnecker_Thought.vCards\Solution\Thought.vCards\vCardStandardWriter.cs,EncodeQuotedPrintable,The following statement contains a magic number: foreach (char c in value)              {                    int v = (int)c;                    // The following are not required to be encoded:                  //                  // - Tab (ASCII 9)                  // - Space (ASCII 32)                  // - Characters 33 to 126' except for the equal sign (61).                    if (                      (v == 9) ||                      ((v >= 32) && (v <= 60)) ||                      ((v >= 62) && (v <= 126)))                  {                      builder.Append(c);                  }                  else                  {                      builder.Append('=');                      builder.Append(v.ToString("X2"));                  }                }
Magic Number,Thought.vCards,vCardStandardReader,C:\repos\drlongnecker_Thought.vCards\Solution\Thought.vCards\vCardStandardReader.cs,DecodeEscaped,The following statement contains a magic number: do              {                    // Get the index of the next backslash character.                  // This marks the beginning of an escape sequence.                    int nextIndex = value.IndexOf('\\'' startIndex);                    if ((nextIndex == -1) || (nextIndex == value.Length - 1))                  {                      // There are no more escape codes' or the backslash                      // is located at the very end of the string.  The                      // characters between the index and the end of the                      // string need to be copied to the output buffer.                        builder.Append(                          value'                          startIndex'                          value.Length - startIndex);                        break;                    }                  else                  {                        // A backslash was located somewhere in the string.                      // The previous statement ensured the backslash is                      // not the very last character' and therefore the                      // following statement is safe.                        char code = value[nextIndex + 1];                        // Any characters between the starting point and                      // the index must be pushed into the buffer.                        builder.Append(                          value'                          startIndex'                          nextIndex - startIndex);                        switch (code)                      {                            case '\\':                          case ''':                          case ';':                                builder.Append(code);                              nextIndex += 2;                              break;                            case 'n':                          case 'N':                              builder.Append('\n');                              nextIndex += 2;                              break;                            case 'r':                          case 'R':                              builder.Append('\r');                              nextIndex += 2;                              break;                            default:                              builder.Append('\\');                              builder.Append(code);                              nextIndex += 2;                              break;                        }                      }                    startIndex = nextIndex;                } while (startIndex < value.Length);
Magic Number,Thought.vCards,vCardStandardReader,C:\repos\drlongnecker_Thought.vCards\Solution\Thought.vCards\vCardStandardReader.cs,DecodeEscaped,The following statement contains a magic number: do              {                    // Get the index of the next backslash character.                  // This marks the beginning of an escape sequence.                    int nextIndex = value.IndexOf('\\'' startIndex);                    if ((nextIndex == -1) || (nextIndex == value.Length - 1))                  {                      // There are no more escape codes' or the backslash                      // is located at the very end of the string.  The                      // characters between the index and the end of the                      // string need to be copied to the output buffer.                        builder.Append(                          value'                          startIndex'                          value.Length - startIndex);                        break;                    }                  else                  {                        // A backslash was located somewhere in the string.                      // The previous statement ensured the backslash is                      // not the very last character' and therefore the                      // following statement is safe.                        char code = value[nextIndex + 1];                        // Any characters between the starting point and                      // the index must be pushed into the buffer.                        builder.Append(                          value'                          startIndex'                          nextIndex - startIndex);                        switch (code)                      {                            case '\\':                          case ''':                          case ';':                                builder.Append(code);                              nextIndex += 2;                              break;                            case 'n':                          case 'N':                              builder.Append('\n');                              nextIndex += 2;                              break;                            case 'r':                          case 'R':                              builder.Append('\r');                              nextIndex += 2;                              break;                            default:                              builder.Append('\\');                              builder.Append(code);                              nextIndex += 2;                              break;                        }                      }                    startIndex = nextIndex;                } while (startIndex < value.Length);
Magic Number,Thought.vCards,vCardStandardReader,C:\repos\drlongnecker_Thought.vCards\Solution\Thought.vCards\vCardStandardReader.cs,DecodeEscaped,The following statement contains a magic number: do              {                    // Get the index of the next backslash character.                  // This marks the beginning of an escape sequence.                    int nextIndex = value.IndexOf('\\'' startIndex);                    if ((nextIndex == -1) || (nextIndex == value.Length - 1))                  {                      // There are no more escape codes' or the backslash                      // is located at the very end of the string.  The                      // characters between the index and the end of the                      // string need to be copied to the output buffer.                        builder.Append(                          value'                          startIndex'                          value.Length - startIndex);                        break;                    }                  else                  {                        // A backslash was located somewhere in the string.                      // The previous statement ensured the backslash is                      // not the very last character' and therefore the                      // following statement is safe.                        char code = value[nextIndex + 1];                        // Any characters between the starting point and                      // the index must be pushed into the buffer.                        builder.Append(                          value'                          startIndex'                          nextIndex - startIndex);                        switch (code)                      {                            case '\\':                          case ''':                          case ';':                                builder.Append(code);                              nextIndex += 2;                              break;                            case 'n':                          case 'N':                              builder.Append('\n');                              nextIndex += 2;                              break;                            case 'r':                          case 'R':                              builder.Append('\r');                              nextIndex += 2;                              break;                            default:                              builder.Append('\\');                              builder.Append(code);                              nextIndex += 2;                              break;                        }                      }                    startIndex = nextIndex;                } while (startIndex < value.Length);
Magic Number,Thought.vCards,vCardStandardReader,C:\repos\drlongnecker_Thought.vCards\Solution\Thought.vCards\vCardStandardReader.cs,DecodeEscaped,The following statement contains a magic number: do              {                    // Get the index of the next backslash character.                  // This marks the beginning of an escape sequence.                    int nextIndex = value.IndexOf('\\'' startIndex);                    if ((nextIndex == -1) || (nextIndex == value.Length - 1))                  {                      // There are no more escape codes' or the backslash                      // is located at the very end of the string.  The                      // characters between the index and the end of the                      // string need to be copied to the output buffer.                        builder.Append(                          value'                          startIndex'                          value.Length - startIndex);                        break;                    }                  else                  {                        // A backslash was located somewhere in the string.                      // The previous statement ensured the backslash is                      // not the very last character' and therefore the                      // following statement is safe.                        char code = value[nextIndex + 1];                        // Any characters between the starting point and                      // the index must be pushed into the buffer.                        builder.Append(                          value'                          startIndex'                          nextIndex - startIndex);                        switch (code)                      {                            case '\\':                          case ''':                          case ';':                                builder.Append(code);                              nextIndex += 2;                              break;                            case 'n':                          case 'N':                              builder.Append('\n');                              nextIndex += 2;                              break;                            case 'r':                          case 'R':                              builder.Append('\r');                              nextIndex += 2;                              break;                            default:                              builder.Append('\\');                              builder.Append(code);                              nextIndex += 2;                              break;                        }                      }                    startIndex = nextIndex;                } while (startIndex < value.Length);
Magic Number,Thought.vCards,vCardStandardReader,C:\repos\drlongnecker_Thought.vCards\Solution\Thought.vCards\vCardStandardReader.cs,DecodeHexadecimal,The following statement contains a magic number: if (char.IsDigit(value))              {                  return Convert.ToInt32(char.GetNumericValue(value));              }                // A = ASCII 65              // F = ASCII 70              // a = ASCII 97              // f = ASCII 102                else if ((value >= 'A') && (value <= 'F'))              {                    // The character is one of the characters                  // between 'A' (value 65) and 'F' (value 70).                  // The character "A" (hex) is "10" (decimal).                    return Convert.ToInt32(value) - 55;              }                else if ((value >= 'a') && (value <= 'f'))              {                    // The character is one of the characters                  // between 'a' (value 97) and 'f' (value 102).                  // The character "A" or "a" (hex) is "10" (decimal).                    return Convert.ToInt32(value) - 87;                }              else                    // The specified character cannot be interpreted                  // as a written hexadecimal character.  Raise an                  // exception.                    throw new ArgumentOutOfRangeException("value");
Magic Number,Thought.vCards,vCardStandardReader,C:\repos\drlongnecker_Thought.vCards\Solution\Thought.vCards\vCardStandardReader.cs,DecodeHexadecimal,The following statement contains a magic number: if (char.IsDigit(value))              {                  return Convert.ToInt32(char.GetNumericValue(value));              }                // A = ASCII 65              // F = ASCII 70              // a = ASCII 97              // f = ASCII 102                else if ((value >= 'A') && (value <= 'F'))              {                    // The character is one of the characters                  // between 'A' (value 65) and 'F' (value 70).                  // The character "A" (hex) is "10" (decimal).                    return Convert.ToInt32(value) - 55;              }                else if ((value >= 'a') && (value <= 'f'))              {                    // The character is one of the characters                  // between 'a' (value 97) and 'f' (value 102).                  // The character "A" or "a" (hex) is "10" (decimal).                    return Convert.ToInt32(value) - 87;                }              else                    // The specified character cannot be interpreted                  // as a written hexadecimal character.  Raise an                  // exception.                    throw new ArgumentOutOfRangeException("value");
Magic Number,Thought.vCards,vCardStandardReader,C:\repos\drlongnecker_Thought.vCards\Solution\Thought.vCards\vCardStandardReader.cs,DecodeQuotedPrintable,The following statement contains a magic number: foreach (char c in value)              {                    switch (state)                  {                        case QuotedPrintableState.None:                            // The parser is not expacting any particular                          // type of character.  If the character is an                          // equal sign (=)' then this point in the string                          // is the start of a character encoded in hexadecimal                          // format.  There are two hexadecimal characters                          // expected.                            if (c == '=')                          {                              state = QuotedPrintableState.ExpectingHexChar1;                          }                          else                          {                              charList.Add(c);                          }                          break;                        case QuotedPrintableState.ExpectingHexChar1:                            // The parser previously encountered an equal sign.                          // This has two purposes: it marks the beginning of                          // a hexadecimal escape sequence' or it marks a                          // so-called software end-of-line.                            if (IsHexDigit(c))                          {                                // The next character is a hexadecimal character.                              // Therefore the equal sign marks the beginning                              // of an escape sequence.                                firstHexChar = c;                              state = QuotedPrintableState.ExpectingHexChar2;                          }                            else if (c == '\r')                          {                                // The prior equal sign was located immediately                              // before carriage-return.  This indicates a soft                              // line break that is ignored.  The next character                              // is expected to be a line feed.                                state = QuotedPrintableState.ExpectingLineFeed;                            }                            else if (c == '=')                          {                                // Another equal sign was encountered.  This is                              // bad data.  The parser will output this bad                              // character and assume this equal sign marks                              // the beginning of a sequence.                                charList.Add('=');                              state = QuotedPrintableState.ExpectingHexChar1;                            }                            else                          {                                // The character after the equal sign was                              // not a hex digit' a carriage return' or an                              // equal sign.  It is bad data.                                charList.Add('=');                              charList.Add(c);                                state = QuotedPrintableState.None;                          }                          break;                        case QuotedPrintableState.ExpectingHexChar2:                            // The parser previously encountered an equal                          // sign and the first of two hexadecimal                          // characters.  This character is expected to                          // be the second (final) hexadecimal character.                            if (IsHexDigit(c))                          {                                // Each hexadecimal character represents                              // four bits of the encoded ASCII value.                              // The first character was the upper 4 bits.                                int charValue =                                  (DecodeHexadecimal(firstHexChar) << 4) +                                  DecodeHexadecimal(c);                                charList.Add((char)charValue);                                state = QuotedPrintableState.None;                            }                          else                          {                                // The parser was expecting the second                              // hexadecimal character after the equal sign.                              // Since this is not a hexadecimal character'                              // the partial sequence is dumped to the output                              // and skipped.                                charList.Add('=');                              charList.Add(firstHexChar);                              charList.Add(c);                              state = QuotedPrintableState.None;                            }                          break;                        case QuotedPrintableState.ExpectingLineFeed:                            // Previously the parser encountered an equal sign                          // followed by a carriage-return.  This is an indicator                          // to the decoder that the encoded value contains a                           // soft line break.  The line break is ignored.                          // Per mime standards' the character following the                          // carriage-return should be a line feed.                            if (c == '\n')                          {                              state = QuotedPrintableState.None;                          }                          else if (c == '=')                          {                              // A line feed was expected but another equal                              // sign was encountered.  Assume the encoder                              // failed to write a line feed.                                state = QuotedPrintableState.ExpectingHexChar1;                          }                          else                          {                              charList.Add(c);                              state = QuotedPrintableState.None;                          }                            break;                  }              }
Magic Number,Thought.vCards,vCardStandardReader,C:\repos\drlongnecker_Thought.vCards\Solution\Thought.vCards\vCardStandardReader.cs,ReadInto_ADR,The following statement contains a magic number: if (addressParts.Length >= 7)                  deliveryAddress.Country = addressParts[6].Trim();
Magic Number,Thought.vCards,vCardStandardReader,C:\repos\drlongnecker_Thought.vCards\Solution\Thought.vCards\vCardStandardReader.cs,ReadInto_ADR,The following statement contains a magic number: if (addressParts.Length >= 7)                  deliveryAddress.Country = addressParts[6].Trim();
Magic Number,Thought.vCards,vCardStandardReader,C:\repos\drlongnecker_Thought.vCards\Solution\Thought.vCards\vCardStandardReader.cs,ReadInto_ADR,The following statement contains a magic number: if (addressParts.Length >= 6)                  deliveryAddress.PostalCode = addressParts[5].Trim();
Magic Number,Thought.vCards,vCardStandardReader,C:\repos\drlongnecker_Thought.vCards\Solution\Thought.vCards\vCardStandardReader.cs,ReadInto_ADR,The following statement contains a magic number: if (addressParts.Length >= 6)                  deliveryAddress.PostalCode = addressParts[5].Trim();
Magic Number,Thought.vCards,vCardStandardReader,C:\repos\drlongnecker_Thought.vCards\Solution\Thought.vCards\vCardStandardReader.cs,ReadInto_ADR,The following statement contains a magic number: if (addressParts.Length >= 5)                  deliveryAddress.Region = addressParts[4].Trim();
Magic Number,Thought.vCards,vCardStandardReader,C:\repos\drlongnecker_Thought.vCards\Solution\Thought.vCards\vCardStandardReader.cs,ReadInto_ADR,The following statement contains a magic number: if (addressParts.Length >= 5)                  deliveryAddress.Region = addressParts[4].Trim();
Magic Number,Thought.vCards,vCardStandardReader,C:\repos\drlongnecker_Thought.vCards\Solution\Thought.vCards\vCardStandardReader.cs,ReadInto_ADR,The following statement contains a magic number: if (addressParts.Length >= 4)                  deliveryAddress.City = addressParts[3].Trim();
Magic Number,Thought.vCards,vCardStandardReader,C:\repos\drlongnecker_Thought.vCards\Solution\Thought.vCards\vCardStandardReader.cs,ReadInto_ADR,The following statement contains a magic number: if (addressParts.Length >= 4)                  deliveryAddress.City = addressParts[3].Trim();
Magic Number,Thought.vCards,vCardStandardReader,C:\repos\drlongnecker_Thought.vCards\Solution\Thought.vCards\vCardStandardReader.cs,ReadInto_ADR,The following statement contains a magic number: if (addressParts.Length >= 3)                  deliveryAddress.Street = addressParts[2].Trim();
Magic Number,Thought.vCards,vCardStandardReader,C:\repos\drlongnecker_Thought.vCards\Solution\Thought.vCards\vCardStandardReader.cs,ReadInto_ADR,The following statement contains a magic number: if (addressParts.Length >= 3)                  deliveryAddress.Street = addressParts[2].Trim();
Magic Number,Thought.vCards,vCardStandardReader,C:\repos\drlongnecker_Thought.vCards\Solution\Thought.vCards\vCardStandardReader.cs,ReadInto_GEO,The following statement contains a magic number: if (coordinates.Length == 2)              {                  float geoLatitude;                  float geoLongitude;                    if (                      float.TryParse(coordinates[0]' out geoLatitude) &&                      float.TryParse(coordinates[1]' out geoLongitude))                  {                      card.Latitude = geoLatitude;                      card.Longitude = geoLongitude;                  }                }
Magic Number,Thought.vCards,vCardStandardReader,C:\repos\drlongnecker_Thought.vCards\Solution\Thought.vCards\vCardStandardReader.cs,ReadInto_N,The following statement contains a magic number: if (names.Length == 2)                  return;
Magic Number,Thought.vCards,vCardStandardReader,C:\repos\drlongnecker_Thought.vCards\Solution\Thought.vCards\vCardStandardReader.cs,ReadInto_N,The following statement contains a magic number: card.AdditionalNames = names[2];
Magic Number,Thought.vCards,vCardStandardReader,C:\repos\drlongnecker_Thought.vCards\Solution\Thought.vCards\vCardStandardReader.cs,ReadInto_N,The following statement contains a magic number: if (names.Length == 3)                  return;
Magic Number,Thought.vCards,vCardStandardReader,C:\repos\drlongnecker_Thought.vCards\Solution\Thought.vCards\vCardStandardReader.cs,ReadInto_N,The following statement contains a magic number: card.NamePrefix = names[3];
Magic Number,Thought.vCards,vCardStandardReader,C:\repos\drlongnecker_Thought.vCards\Solution\Thought.vCards\vCardStandardReader.cs,ReadInto_N,The following statement contains a magic number: if (names.Length == 4)                  return;
Magic Number,Thought.vCards,vCardStandardReader,C:\repos\drlongnecker_Thought.vCards\Solution\Thought.vCards\vCardStandardReader.cs,ReadInto_N,The following statement contains a magic number: card.NameSuffix = names[4];
Magic Number,Thought.vCards,vCardStandardReader,C:\repos\drlongnecker_Thought.vCards\Solution\Thought.vCards\vCardStandardReader.cs,ReadInto_X_WAB_GENDER,The following statement contains a magic number: if (int.TryParse(property.ToString()' out genderId))              {                  switch (genderId)                  {                      case 1:                          card.Gender = vCardGender.Female;                          break;                        case 2:                          card.Gender = vCardGender.Male;                          break;                  }              }
Magic Number,Thought.vCards,vCardStandardReader,C:\repos\drlongnecker_Thought.vCards\Solution\Thought.vCards\vCardStandardReader.cs,ReadProperty,The following statement contains a magic number: do              {                    // Read the first line of the next property                  // from the input stream.  If a null string                  // is returned' then the end of the input                  // stream has been reached.                    string firstLine = reader.ReadLine();                  if (firstLine == null)                      return null;                    // See if this line is a blank line.  It is                  // blank if (a) it has no characters' or (b)                  // it consists of whitespace characters only.                    firstLine = firstLine.Trim();                  if (firstLine.Length == 0)                  {                      Warnings.Add(Thought.vCards.WarningMessages.BlankLine);                      continue;                  }                    // Get the index of the colon (:) in this                  // property line.  All vCard properties are                  // written in NAME:VALUE format.                    int colonIndex = firstLine.IndexOf(':');                  if (colonIndex == -1)                  {                      Warnings.Add(Thought.vCards.WarningMessages.ColonMissing);                      continue;                  }                    // Get the name portion of the property.  This                  // portion contains the property name as well                  // as any subproperties.                    string namePart = firstLine.Substring(0' colonIndex).Trim();                  if (string.IsNullOrEmpty(namePart))                  {                      Warnings.Add(Thought.vCards.WarningMessages.EmptyName);                      continue;                  }                    // Split apart the name portion of the property.                  // A property can have subproperties' separated                  // by semicolons.                    string[] nameParts = namePart.Split(';');                  for (int i = 0; i < nameParts.Length; i++)                      nameParts[i] = nameParts[i].Trim();                    // The name of the property is supposed to                  // be first on the line.  An empty name is not                  // legal syntax.                    if (nameParts[0].Length == 0)                  {                      Warnings.Add(Thought.vCards.WarningMessages.EmptyName);                      continue;                  }                    // At this point there is sufficient text                  // to define a vCard property.  The only                  // true minimum requirement is a name.                    vCardProperty property = new vCardProperty();                  property.Name = nameParts[0];                    // Next' store any subproperties.  Subproperties                  // are defined like "NAME;SUBNAME=VALUE:VALUE".  Note                  // that subproperties do not necessarily have to have                  // a subvalue.                    for (int index = 1; index < nameParts.Length; index++)                  {                        // Split the subproperty into its name and                       // value components.  If multiple equal signs                      // happen to exist' they are interpreted as                      // part of the value.  This may change in a                       // future version of the parser.                        string[] subNameValue =                          nameParts[index].Split(new char[] { '=' }' 2);                        if (subNameValue.Length == 1)                      {                            // The Split function above returned a single                          // array element.  This means no equal (=) sign                          // was present.  The subproperty consists of                          // a name only.                            property.Subproperties.Add(                              nameParts[index].Trim());                      }                      else                      {                          property.Subproperties.Add(                              subNameValue[0].Trim()'                              subNameValue[1].Trim());                      }                    }                    // The subproperties have been defined.  The next                  // step is to try to identify the encoding of the                  // value.  The encoding is supposed to be specified                  // with a subproperty called ENCODING.  However' older                  // versions of the format just wrote the plain                  // encoding value' e.g. "NAME;BASE64:VALUE" instead                  // of the normalized "NAME;ENCODING=BASE64:VALUE" form.                    string encodingName =                      property.Subproperties.GetValue("ENCODING"'                          new string[] { "B"' "BASE64"' "QUOTED-PRINTABLE" });                    var hasCharset = property.Subproperties.Contains("CHARSET");                  var charsetEncoding = Encoding.Default;                  if (hasCharset)                  {                      var charsetEncodingName = property.Subproperties.GetValue("CHARSET");                      charsetEncoding = GetCharsetEncoding(charsetEncodingName);                  }                    // Convert the encoding name into its corresponding                  // vCardEncoding enumeration value.                    vCardEncoding encoding =                      ParseEncoding(encodingName);                    // At this point' the first line of the property has been                  // loaded and the suggested value encoding has been                  // determined.  Get the raw value as encoded in the file.                    string rawValue = firstLine.Substring(colonIndex + 1);                    // The vCard specification allows long values                  // to be folded across multiple lines.  An example                  // is a security key encoded in MIME format.                  // When folded' each subsequent line begins with                  // a space or tab character instead of the next property.                  //                  // See: RFC 2425' Section 5.8.1                    do                  {                      int peekChar = reader.Peek();                        if ((peekChar == 32) || (peekChar == 9))                      {                          string foldedLine = reader.ReadLine();                          rawValue += foldedLine.Substring(1);                      }                      else                      {                          break;                      }                    } while (true);                    if (encoding == vCardEncoding.QuotedPrintable && rawValue.Length > 0)                  {                      while (rawValue[rawValue.Length - 1] == '=')                      {                          rawValue += "\r\n" + reader.ReadLine();                      }                  }                    // The full value has finally been loaded from the                  // input stream.  The next step is to decode it.                    switch (encoding)                  {                      case vCardEncoding.Base64:                          property.Value = DecodeBase64(rawValue);                          break;                        case vCardEncoding.Escaped:                          property.Value = DecodeEscaped(rawValue);                          break;                        case vCardEncoding.QuotedPrintable:                          property.Value = DecodeQuotedPrintable(rawValue' charsetEncoding);                          break;                        default:                          property.Value = DecodeEscaped(rawValue);                          break;                  }                    return property;                } while (true);
Magic Number,Thought.vCards,vCardStandardReader,C:\repos\drlongnecker_Thought.vCards\Solution\Thought.vCards\vCardStandardReader.cs,ReadProperty,The following statement contains a magic number: do              {                    // Read the first line of the next property                  // from the input stream.  If a null string                  // is returned' then the end of the input                  // stream has been reached.                    string firstLine = reader.ReadLine();                  if (firstLine == null)                      return null;                    // See if this line is a blank line.  It is                  // blank if (a) it has no characters' or (b)                  // it consists of whitespace characters only.                    firstLine = firstLine.Trim();                  if (firstLine.Length == 0)                  {                      Warnings.Add(Thought.vCards.WarningMessages.BlankLine);                      continue;                  }                    // Get the index of the colon (:) in this                  // property line.  All vCard properties are                  // written in NAME:VALUE format.                    int colonIndex = firstLine.IndexOf(':');                  if (colonIndex == -1)                  {                      Warnings.Add(Thought.vCards.WarningMessages.ColonMissing);                      continue;                  }                    // Get the name portion of the property.  This                  // portion contains the property name as well                  // as any subproperties.                    string namePart = firstLine.Substring(0' colonIndex).Trim();                  if (string.IsNullOrEmpty(namePart))                  {                      Warnings.Add(Thought.vCards.WarningMessages.EmptyName);                      continue;                  }                    // Split apart the name portion of the property.                  // A property can have subproperties' separated                  // by semicolons.                    string[] nameParts = namePart.Split(';');                  for (int i = 0; i < nameParts.Length; i++)                      nameParts[i] = nameParts[i].Trim();                    // The name of the property is supposed to                  // be first on the line.  An empty name is not                  // legal syntax.                    if (nameParts[0].Length == 0)                  {                      Warnings.Add(Thought.vCards.WarningMessages.EmptyName);                      continue;                  }                    // At this point there is sufficient text                  // to define a vCard property.  The only                  // true minimum requirement is a name.                    vCardProperty property = new vCardProperty();                  property.Name = nameParts[0];                    // Next' store any subproperties.  Subproperties                  // are defined like "NAME;SUBNAME=VALUE:VALUE".  Note                  // that subproperties do not necessarily have to have                  // a subvalue.                    for (int index = 1; index < nameParts.Length; index++)                  {                        // Split the subproperty into its name and                       // value components.  If multiple equal signs                      // happen to exist' they are interpreted as                      // part of the value.  This may change in a                       // future version of the parser.                        string[] subNameValue =                          nameParts[index].Split(new char[] { '=' }' 2);                        if (subNameValue.Length == 1)                      {                            // The Split function above returned a single                          // array element.  This means no equal (=) sign                          // was present.  The subproperty consists of                          // a name only.                            property.Subproperties.Add(                              nameParts[index].Trim());                      }                      else                      {                          property.Subproperties.Add(                              subNameValue[0].Trim()'                              subNameValue[1].Trim());                      }                    }                    // The subproperties have been defined.  The next                  // step is to try to identify the encoding of the                  // value.  The encoding is supposed to be specified                  // with a subproperty called ENCODING.  However' older                  // versions of the format just wrote the plain                  // encoding value' e.g. "NAME;BASE64:VALUE" instead                  // of the normalized "NAME;ENCODING=BASE64:VALUE" form.                    string encodingName =                      property.Subproperties.GetValue("ENCODING"'                          new string[] { "B"' "BASE64"' "QUOTED-PRINTABLE" });                    var hasCharset = property.Subproperties.Contains("CHARSET");                  var charsetEncoding = Encoding.Default;                  if (hasCharset)                  {                      var charsetEncodingName = property.Subproperties.GetValue("CHARSET");                      charsetEncoding = GetCharsetEncoding(charsetEncodingName);                  }                    // Convert the encoding name into its corresponding                  // vCardEncoding enumeration value.                    vCardEncoding encoding =                      ParseEncoding(encodingName);                    // At this point' the first line of the property has been                  // loaded and the suggested value encoding has been                  // determined.  Get the raw value as encoded in the file.                    string rawValue = firstLine.Substring(colonIndex + 1);                    // The vCard specification allows long values                  // to be folded across multiple lines.  An example                  // is a security key encoded in MIME format.                  // When folded' each subsequent line begins with                  // a space or tab character instead of the next property.                  //                  // See: RFC 2425' Section 5.8.1                    do                  {                      int peekChar = reader.Peek();                        if ((peekChar == 32) || (peekChar == 9))                      {                          string foldedLine = reader.ReadLine();                          rawValue += foldedLine.Substring(1);                      }                      else                      {                          break;                      }                    } while (true);                    if (encoding == vCardEncoding.QuotedPrintable && rawValue.Length > 0)                  {                      while (rawValue[rawValue.Length - 1] == '=')                      {                          rawValue += "\r\n" + reader.ReadLine();                      }                  }                    // The full value has finally been loaded from the                  // input stream.  The next step is to decode it.                    switch (encoding)                  {                      case vCardEncoding.Base64:                          property.Value = DecodeBase64(rawValue);                          break;                        case vCardEncoding.Escaped:                          property.Value = DecodeEscaped(rawValue);                          break;                        case vCardEncoding.QuotedPrintable:                          property.Value = DecodeQuotedPrintable(rawValue' charsetEncoding);                          break;                        default:                          property.Value = DecodeEscaped(rawValue);                          break;                  }                    return property;                } while (true);
Magic Number,Thought.vCards,vCardStandardReader,C:\repos\drlongnecker_Thought.vCards\Solution\Thought.vCards\vCardStandardReader.cs,ReadProperty,The following statement contains a magic number: do              {                    // Read the first line of the next property                  // from the input stream.  If a null string                  // is returned' then the end of the input                  // stream has been reached.                    string firstLine = reader.ReadLine();                  if (firstLine == null)                      return null;                    // See if this line is a blank line.  It is                  // blank if (a) it has no characters' or (b)                  // it consists of whitespace characters only.                    firstLine = firstLine.Trim();                  if (firstLine.Length == 0)                  {                      Warnings.Add(Thought.vCards.WarningMessages.BlankLine);                      continue;                  }                    // Get the index of the colon (:) in this                  // property line.  All vCard properties are                  // written in NAME:VALUE format.                    int colonIndex = firstLine.IndexOf(':');                  if (colonIndex == -1)                  {                      Warnings.Add(Thought.vCards.WarningMessages.ColonMissing);                      continue;                  }                    // Get the name portion of the property.  This                  // portion contains the property name as well                  // as any subproperties.                    string namePart = firstLine.Substring(0' colonIndex).Trim();                  if (string.IsNullOrEmpty(namePart))                  {                      Warnings.Add(Thought.vCards.WarningMessages.EmptyName);                      continue;                  }                    // Split apart the name portion of the property.                  // A property can have subproperties' separated                  // by semicolons.                    string[] nameParts = namePart.Split(';');                  for (int i = 0; i < nameParts.Length; i++)                      nameParts[i] = nameParts[i].Trim();                    // The name of the property is supposed to                  // be first on the line.  An empty name is not                  // legal syntax.                    if (nameParts[0].Length == 0)                  {                      Warnings.Add(Thought.vCards.WarningMessages.EmptyName);                      continue;                  }                    // At this point there is sufficient text                  // to define a vCard property.  The only                  // true minimum requirement is a name.                    vCardProperty property = new vCardProperty();                  property.Name = nameParts[0];                    // Next' store any subproperties.  Subproperties                  // are defined like "NAME;SUBNAME=VALUE:VALUE".  Note                  // that subproperties do not necessarily have to have                  // a subvalue.                    for (int index = 1; index < nameParts.Length; index++)                  {                        // Split the subproperty into its name and                       // value components.  If multiple equal signs                      // happen to exist' they are interpreted as                      // part of the value.  This may change in a                       // future version of the parser.                        string[] subNameValue =                          nameParts[index].Split(new char[] { '=' }' 2);                        if (subNameValue.Length == 1)                      {                            // The Split function above returned a single                          // array element.  This means no equal (=) sign                          // was present.  The subproperty consists of                          // a name only.                            property.Subproperties.Add(                              nameParts[index].Trim());                      }                      else                      {                          property.Subproperties.Add(                              subNameValue[0].Trim()'                              subNameValue[1].Trim());                      }                    }                    // The subproperties have been defined.  The next                  // step is to try to identify the encoding of the                  // value.  The encoding is supposed to be specified                  // with a subproperty called ENCODING.  However' older                  // versions of the format just wrote the plain                  // encoding value' e.g. "NAME;BASE64:VALUE" instead                  // of the normalized "NAME;ENCODING=BASE64:VALUE" form.                    string encodingName =                      property.Subproperties.GetValue("ENCODING"'                          new string[] { "B"' "BASE64"' "QUOTED-PRINTABLE" });                    var hasCharset = property.Subproperties.Contains("CHARSET");                  var charsetEncoding = Encoding.Default;                  if (hasCharset)                  {                      var charsetEncodingName = property.Subproperties.GetValue("CHARSET");                      charsetEncoding = GetCharsetEncoding(charsetEncodingName);                  }                    // Convert the encoding name into its corresponding                  // vCardEncoding enumeration value.                    vCardEncoding encoding =                      ParseEncoding(encodingName);                    // At this point' the first line of the property has been                  // loaded and the suggested value encoding has been                  // determined.  Get the raw value as encoded in the file.                    string rawValue = firstLine.Substring(colonIndex + 1);                    // The vCard specification allows long values                  // to be folded across multiple lines.  An example                  // is a security key encoded in MIME format.                  // When folded' each subsequent line begins with                  // a space or tab character instead of the next property.                  //                  // See: RFC 2425' Section 5.8.1                    do                  {                      int peekChar = reader.Peek();                        if ((peekChar == 32) || (peekChar == 9))                      {                          string foldedLine = reader.ReadLine();                          rawValue += foldedLine.Substring(1);                      }                      else                      {                          break;                      }                    } while (true);                    if (encoding == vCardEncoding.QuotedPrintable && rawValue.Length > 0)                  {                      while (rawValue[rawValue.Length - 1] == '=')                      {                          rawValue += "\r\n" + reader.ReadLine();                      }                  }                    // The full value has finally been loaded from the                  // input stream.  The next step is to decode it.                    switch (encoding)                  {                      case vCardEncoding.Base64:                          property.Value = DecodeBase64(rawValue);                          break;                        case vCardEncoding.Escaped:                          property.Value = DecodeEscaped(rawValue);                          break;                        case vCardEncoding.QuotedPrintable:                          property.Value = DecodeQuotedPrintable(rawValue' charsetEncoding);                          break;                        default:                          property.Value = DecodeEscaped(rawValue);                          break;                  }                    return property;                } while (true);
Missing Default,Thought.vCards,vCardStandardWriter,C:\repos\drlongnecker_Thought.vCards\Solution\Thought.vCards\vCardStandardWriter.cs,BuildProperties_X_WAB_GENDER,The following switch statement is missing a default case: switch (card.Gender)              {                  case vCardGender.Female:                      properties.Add(new vCardProperty("X-WAB-GENDER"' "1"));                      break;                    case vCardGender.Male:                      properties.Add(new vCardProperty("X-WAB-GENDER"' "2"));                      break;                }
Missing Default,Thought.vCards,vCardStandardReader,C:\repos\drlongnecker_Thought.vCards\Solution\Thought.vCards\vCardStandardReader.cs,DecodeQuotedPrintable,The following switch statement is missing a default case: switch (state)                  {                        case QuotedPrintableState.None:                            // The parser is not expacting any particular                          // type of character.  If the character is an                          // equal sign (=)' then this point in the string                          // is the start of a character encoded in hexadecimal                          // format.  There are two hexadecimal characters                          // expected.                            if (c == '=')                          {                              state = QuotedPrintableState.ExpectingHexChar1;                          }                          else                          {                              charList.Add(c);                          }                          break;                        case QuotedPrintableState.ExpectingHexChar1:                            // The parser previously encountered an equal sign.                          // This has two purposes: it marks the beginning of                          // a hexadecimal escape sequence' or it marks a                          // so-called software end-of-line.                            if (IsHexDigit(c))                          {                                // The next character is a hexadecimal character.                              // Therefore the equal sign marks the beginning                              // of an escape sequence.                                firstHexChar = c;                              state = QuotedPrintableState.ExpectingHexChar2;                          }                            else if (c == '\r')                          {                                // The prior equal sign was located immediately                              // before carriage-return.  This indicates a soft                              // line break that is ignored.  The next character                              // is expected to be a line feed.                                state = QuotedPrintableState.ExpectingLineFeed;                            }                            else if (c == '=')                          {                                // Another equal sign was encountered.  This is                              // bad data.  The parser will output this bad                              // character and assume this equal sign marks                              // the beginning of a sequence.                                charList.Add('=');                              state = QuotedPrintableState.ExpectingHexChar1;                            }                            else                          {                                // The character after the equal sign was                              // not a hex digit' a carriage return' or an                              // equal sign.  It is bad data.                                charList.Add('=');                              charList.Add(c);                                state = QuotedPrintableState.None;                          }                          break;                        case QuotedPrintableState.ExpectingHexChar2:                            // The parser previously encountered an equal                          // sign and the first of two hexadecimal                          // characters.  This character is expected to                          // be the second (final) hexadecimal character.                            if (IsHexDigit(c))                          {                                // Each hexadecimal character represents                              // four bits of the encoded ASCII value.                              // The first character was the upper 4 bits.                                int charValue =                                  (DecodeHexadecimal(firstHexChar) << 4) +                                  DecodeHexadecimal(c);                                charList.Add((char)charValue);                                state = QuotedPrintableState.None;                            }                          else                          {                                // The parser was expecting the second                              // hexadecimal character after the equal sign.                              // Since this is not a hexadecimal character'                              // the partial sequence is dumped to the output                              // and skipped.                                charList.Add('=');                              charList.Add(firstHexChar);                              charList.Add(c);                              state = QuotedPrintableState.None;                            }                          break;                        case QuotedPrintableState.ExpectingLineFeed:                            // Previously the parser encountered an equal sign                          // followed by a carriage-return.  This is an indicator                          // to the decoder that the encoded value contains a                           // soft line break.  The line break is ignored.                          // Per mime standards' the character following the                          // carriage-return should be a line feed.                            if (c == '\n')                          {                              state = QuotedPrintableState.None;                          }                          else if (c == '=')                          {                              // A line feed was expected but another equal                              // sign was encountered.  Assume the encoder                              // failed to write a line feed.                                state = QuotedPrintableState.ExpectingHexChar1;                          }                          else                          {                              charList.Add(c);                              state = QuotedPrintableState.None;                          }                            break;                  }
Missing Default,Thought.vCards,vCardStandardReader,C:\repos\drlongnecker_Thought.vCards\Solution\Thought.vCards\vCardStandardReader.cs,DecodeQuotedPrintable,The following switch statement is missing a default case: switch (state)              {                  case QuotedPrintableState.ExpectingHexChar1:                      charList.Add('=');                      break;                    case QuotedPrintableState.ExpectingHexChar2:                      charList.Add('=');                      charList.Add(firstHexChar);                      break;                    case QuotedPrintableState.ExpectingLineFeed:                      charList.Add('=');                      charList.Add('\r');                      break;              }
Missing Default,Thought.vCards,vCardStandardReader,C:\repos\drlongnecker_Thought.vCards\Solution\Thought.vCards\vCardStandardReader.cs,ReadInto_CLASS,The following switch statement is missing a default case: switch (property.ToString().ToUpperInvariant())              {                  case "PUBLIC":                      card.AccessClassification = vCardAccessClassification.Public;                      break;                    case "PRIVATE":                      card.AccessClassification = vCardAccessClassification.Private;                      break;                    case "CONFIDENTIAL":                      card.AccessClassification = vCardAccessClassification.Confidential;                      break;              }
Missing Default,Thought.vCards,vCardStandardReader,C:\repos\drlongnecker_Thought.vCards\Solution\Thought.vCards\vCardStandardReader.cs,ReadInto_X_WAB_GENDER,The following switch statement is missing a default case: switch (genderId)                  {                      case 1:                          card.Gender = vCardGender.Female;                          break;                        case 2:                          card.Gender = vCardGender.Male;                          break;                  }
