Implementation smell,Namespace,Class,File,Method,Description
Long Method,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,NetBigInteger,The method has 129 lines of code.
Long Method,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,Divide,The method has 106 lines of code.
Long Method,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,ModPow,The method has 138 lines of code.
Long Method,Lidgren.Network,NetConnection,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetConnection.cs,Heartbeat,The method has 112 lines of code.
Long Method,Lidgren.Network,NetConnection,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetConnection.cs,ReceivedHandshake,The method has 143 lines of code.
Long Method,Lidgren.Network,NetPeer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetNatIntroduction.cs,Heartbeat,The method has 206 lines of code.
Complex Method,Lidgren.Network,NetAESEncryption,C:\repos\Nirklav_TCPChat\Lidgren.Network\Encryption\NetAESEncryption.cs,NetAESEncryption,Cyclomatic complexity of the method is 9
Complex Method,Lidgren.Network,NetDESEncryption,C:\repos\Nirklav_TCPChat\Lidgren.Network\Encryption\NetDESEncryption.cs,NetDESEncryption,Cyclomatic complexity of the method is 9
Complex Method,Lidgren.Network,NetRC2Encryption,C:\repos\Nirklav_TCPChat\Lidgren.Network\Encryption\NetRC2Encryption.cs,NetRC2Encryption,Cyclomatic complexity of the method is 9
Complex Method,Lidgren.Network,NetTripleDESEncryption,C:\repos\Nirklav_TCPChat\Lidgren.Network\Encryption\NetTripleDESEncryption.cs,NetTripleDESEncryption,Cyclomatic complexity of the method is 9
Complex Method,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,NetBigInteger,Cyclomatic complexity of the method is 11
Complex Method,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,MakeMagnitude,Cyclomatic complexity of the method is 8
Complex Method,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,Divide,Cyclomatic complexity of the method is 18
Complex Method,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,ModPow,Cyclomatic complexity of the method is 20
Complex Method,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,Remainder,Cyclomatic complexity of the method is 17
Complex Method,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,Remainder,Cyclomatic complexity of the method is 8
Complex Method,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,ToString,Cyclomatic complexity of the method is 9
Complex Method,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteUInt64,Cyclomatic complexity of the method is 9
Complex Method,Lidgren.Network,NetConnection,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetConnection.cs,Heartbeat,Cyclomatic complexity of the method is 17
Complex Method,Lidgren.Network,NetConnectionStatistics,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetConnectionStatistics.cs,ToString,Cyclomatic complexity of the method is 12
Complex Method,Lidgren.Network,NetFragmentationHelper,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetFragmentationHelper.cs,ReadHeader,Cyclomatic complexity of the method is 9
Complex Method,Lidgren.Network,NetPeer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetNatIntroduction.cs,Heartbeat,Cyclomatic complexity of the method is 12
Complex Method,Lidgren.Network,NetPeer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetNatIntroduction.cs,SendMessage,Cyclomatic complexity of the method is 10
Complex Method,Lidgren.Network,NetUtility,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetUtility.cs,GetNetworkInterface,Cyclomatic complexity of the method is 10
Long Parameter List,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,MultiplyMonty,The method has 5 parameters. Parameters: a' x' y' m' mQuote
Long Parameter List,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,ReadBytes,The method has 5 parameters. Parameters: fromBuffer' numberOfBytes' readBitOffset' destination' destinationByteOffset
Long Parameter List,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteBytes,The method has 5 parameters. Parameters: source' sourceByteOffset' numberOfBytes' destination' destBitOffset
Long Parameter List,Lidgren.Network,NetFragmentationHelper,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetFragmentationHelper.cs,WriteHeader,The method has 6 parameters. Parameters: destination' ptr' group' totalBits' chunkByteSize' chunkNumber
Long Parameter List,Lidgren.Network,NetFragmentationHelper,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetFragmentationHelper.cs,ReadHeader,The method has 6 parameters. Parameters: buffer' ptr' group' totalBits' chunkByteSize' chunkNumber
Long Parameter List,Lidgren.Network,NetPeer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetNatIntroduction.cs,Introduce,The method has 5 parameters. Parameters: hostInternal' hostExternal' clientInternal' clientExternal' token
Long Parameter List,Lidgren.Network,NetPeer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetNatIntroduction.cs,ReceivedUnconnectedLibraryMessage,The method has 5 parameters. Parameters: now' senderEndPoint' tp' ptr' payloadByteLength
Long Identifier,Lidgren.Network,NetTripleDESEncryption,C:\repos\Nirklav_TCPChat\Lidgren.Network\Encryption\NetTripleDESEncryption.cs,Encrypt,The length of the parameter tripleDESCryptoServiceProvider is 30.
Long Identifier,Lidgren.Network,NetTripleDESEncryption,C:\repos\Nirklav_TCPChat\Lidgren.Network\Encryption\NetTripleDESEncryption.cs,Decrypt,The length of the parameter tripleDESCryptoServiceProvider is 30.
Long Identifier,Lidgren.Network,NetPeerConfiguration,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetPeerConfiguration.cs,,The length of the parameter m_defaultOutgoingMessageCapacity is 32.
Long Statement,Lidgren.Network,NetAESEncryption,C:\repos\Nirklav_TCPChat\Lidgren.Network\Encryption\NetAESEncryption.cs,Encrypt,The length of the statement  "				using (AesCryptoServiceProvider aesCryptoServiceProvider = new AesCryptoServiceProvider { KeySize = m_bitSize' Mode = CipherMode.CBC }) " is 135.
Long Statement,Lidgren.Network,NetAESEncryption,C:\repos\Nirklav_TCPChat\Lidgren.Network\Encryption\NetAESEncryption.cs,Decrypt,The length of the statement  "				using (AesCryptoServiceProvider aesCryptoServiceProvider = new AesCryptoServiceProvider { KeySize = m_bitSize' Mode = CipherMode.CBC }) " is 135.
Long Statement,Lidgren.Network,NetDESEncryption,C:\repos\Nirklav_TCPChat\Lidgren.Network\Encryption\NetDESEncryption.cs,Encrypt,The length of the statement  "				using (DESCryptoServiceProvider desCryptoServiceProvider = new DESCryptoServiceProvider { KeySize = m_bitSize' Mode = CipherMode.CBC }) " is 135.
Long Statement,Lidgren.Network,NetDESEncryption,C:\repos\Nirklav_TCPChat\Lidgren.Network\Encryption\NetDESEncryption.cs,Decrypt,The length of the statement  "				using (DESCryptoServiceProvider desCryptoServiceProvider = new DESCryptoServiceProvider { KeySize = m_bitSize' Mode = CipherMode.CBC }) " is 135.
Long Statement,Lidgren.Network,NetRC2Encryption,C:\repos\Nirklav_TCPChat\Lidgren.Network\Encryption\NetRC2Encryption.cs,Encrypt,The length of the statement  "				using (RC2CryptoServiceProvider rc2CryptoServiceProvider = new RC2CryptoServiceProvider { KeySize = m_bitSize' Mode = CipherMode.CBC }) " is 135.
Long Statement,Lidgren.Network,NetRC2Encryption,C:\repos\Nirklav_TCPChat\Lidgren.Network\Encryption\NetRC2Encryption.cs,Decrypt,The length of the statement  "				using (RC2CryptoServiceProvider rc2CryptoServiceProvider = new RC2CryptoServiceProvider { KeySize = m_bitSize' Mode = CipherMode.CBC }) " is 135.
Long Statement,Lidgren.Network,NetTripleDESEncryption,C:\repos\Nirklav_TCPChat\Lidgren.Network\Encryption\NetTripleDESEncryption.cs,Encrypt,The length of the statement  "				using (TripleDESCryptoServiceProvider tripleDESCryptoServiceProvider = new TripleDESCryptoServiceProvider { KeySize = m_bitSize' Mode = CipherMode.CBC }) " is 153.
Long Statement,Lidgren.Network,NetTripleDESEncryption,C:\repos\Nirklav_TCPChat\Lidgren.Network\Encryption\NetTripleDESEncryption.cs,Decrypt,The length of the statement  "				using (TripleDESCryptoServiceProvider tripleDESCryptoServiceProvider = new TripleDESCryptoServiceProvider { KeySize = m_bitSize' Mode = CipherMode.CBC }) " is 153.
Long Statement,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,PeekInt64,The length of the statement  "			NetException.Assert(((numberOfBits > 0) && (numberOfBits < 65))' "ReadInt64(bits) can only read between 1 and 64 bits"); " is 120.
Long Statement,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadInt64,The length of the statement  "			NetException.Assert(((numberOfBits > 0) && (numberOfBits <= 64))' "ReadInt64(bits) can only read between 1 and 64 bits"); " is 121.
Long Statement,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadAllFields,The length of the statement  "			ReadAllFields(target' BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public); " is 120.
Long Statement,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadAllProperties,The length of the statement  "			ReadAllProperties(target' BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public); " is 124.
Long Statement,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,Write,The length of the statement  "			NetException.Assert((numberOfBits > 0 && numberOfBits <= 8)' "Write(byte' numberOfBits) can only write between 1 and 8 bits"); " is 126.
Long Statement,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,Write,The length of the statement  "			NetException.Assert((numberOfBits > 0 && numberOfBits <= 16)' "Write(ushort' numberOfBits) can only write between 1 and 16 bits"); " is 130.
Long Statement,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,Write,The length of the statement  "			NetException.Assert((numberOfBits > 0 && numberOfBits <= 32)' "Write(uint' numberOfBits) can only write between 1 and 32 bits"); " is 128.
Long Statement,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,Write,The length of the statement  "			NetException.Assert((numberOfBits > 0 && numberOfBits <= 32)' "Write(int' numberOfBits) can only write between 1 and 32 bits"); " is 127.
Long Statement,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,WriteSignedSingle,The length of the statement  "			NetException.Assert(((value >= -1.0) && (value <= 1.0))' " WriteSignedSingle() must be passed a float in the range -1 to 1; val is " + value); " is 142.
Long Statement,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,WriteUnitSingle,The length of the statement  "			NetException.Assert(((value >= 0.0) && (value <= 1.0))' " WriteUnitSingle() must be passed a float in the range 0 to 1; val is " + value); " is 138.
Long Statement,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,WriteRangedSingle,The length of the statement  "			NetException.Assert(((value >= min) && (value <= max))' " WriteRangedSingle() must be passed a float in the range MIN to MAX; val is " + value); " is 144.
Long Statement,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,WriteAllProperties,The length of the statement  "			WriteAllProperties(ob' BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public); " is 121.
Long Statement,Lidgren.Network,NetConnection,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetConnection.cs,SetStatus,The length of the statement  "				NetIncomingMessage info = m_peer.CreateIncomingMessage(NetIncomingMessageType.StatusChanged' 4 + reason.Length + (reason.Length > 126 ? 2 : 1)); " is 144.
Long Statement,Lidgren.Network,NetConnection,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetConnection.cs,Heartbeat,The length of the statement  "			NetException.Assert(m_status != NetConnectionStatus.InitiatedConnect && m_status != NetConnectionStatus.RespondedConnect); " is 122.
Long Statement,Lidgren.Network,NetConnection,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetConnection.cs,Heartbeat,The length of the statement  "			// Note: at this point m_sendBufferWritePtr and m_sendBufferNumMessages may be non-null; resends may already be queued up " is 121.
Long Statement,Lidgren.Network,NetConnection,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetConnection.cs,QueueSendMessage,The length of the statement  "				NetException.Assert(m_sendBufferWritePtr > 0 && m_sendBufferNumMessages > 0); // or else the message should have been fragmented earlier " is 136.
Long Statement,Lidgren.Network,NetConnection,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetConnection.cs,ReceivedLibraryMessage,The length of the statement  "						// need to enqueue this and handle it in the netconnection heartbeat; so be able to send resends together with normal sends " is 123.
Long Statement,Lidgren.Network,NetConnection,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetConnection.cs,ReceivedLibraryMessage,The length of the statement  "					// Unusual situation where server is actually already known' but got a nat introduction - oh well' lets handle it as usual " is 122.
Long Statement,Lidgren.Network,NetConnection,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetConnection.cs,SendConnectResponse,The length of the statement  "			NetOutgoingMessage om = m_peer.CreateMessage(m_peerConfiguration.AppIdentifier.Length + 13 + (m_localHailMessage == null ? 0 : m_localHailMessage.LengthBytes)); " is 160.
Long Statement,Lidgren.Network,NetConnection,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetConnection.cs,SendConnectResponse,The length of the statement  "				m_peer.m_unsentUnconnectedMessages.Enqueue(new NetTuple<System.Net.IPEndPoint' NetOutgoingMessage>(m_remoteEndPoint' om)); " is 122.
Long Statement,Lidgren.Network,NetConnection,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetConnection.cs,SendDisconnect,The length of the statement  "				m_peer.m_unsentUnconnectedMessages.Enqueue(new NetTuple<System.Net.IPEndPoint' NetOutgoingMessage>(m_remoteEndPoint' om)); " is 122.
Long Statement,Lidgren.Network,NetConnection,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetConnection.cs,WriteLocalHail,The length of the statement  "						throw new NetException("Hail message too large; can maximally be " + (m_peerConfiguration.m_maximumTransmissionUnit - 10 - om.LengthBytes)); " is 140.
Long Statement,Lidgren.Network,NetConnection,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetConnection.cs,ReceivedHandshake,The length of the statement  "								NetIncomingMessage appMsg = m_peer.CreateIncomingMessage(NetIncomingMessageType.ConnectionApproval' (m_remoteHailMessage == null ? 0 : m_remoteHailMessage.LengthBytes)); " is 169.
Long Statement,Lidgren.Network,NetConnection,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetConnection.cs,ReceivedPong,The length of the statement  "				m_peer.LogDebug("Initiated average roundtrip time to " + NetTime.ToReadable(m_averageRoundtripTime) + " Remote time is: " + (now + diff)); " is 138.
Long Statement,Lidgren.Network,NetConnection,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetConnection.cs,ReceivedPong,The length of the statement  "				m_peer.LogVerbose("Updated average roundtrip time to " + NetTime.ToReadable(m_averageRoundtripTime) + "' remote time to " + (now + m_remoteTimeOffset) + " (ie. diff " + m_remoteTimeOffset + ")"); " is 195.
Long Statement,Lidgren.Network,NetConnection,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetConnection.cs,InitExpandMTU,The length of the statement  "			m_lastSentMTUAttemptTime = now + m_peerConfiguration.m_expandMTUFrequency + 1.5f + m_averageRoundtripTime; // wait a tiny bit before starting to expand mtu " is 155.
Long Statement,Lidgren.Network,NetConnectionStatistics,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetConnectionStatistics.cs,ToString,The length of the statement  "			bdr.AppendLine("Received " + m_receivedBytes + " bytes in " + m_receivedMessages + " messages in " + m_receivedPackets + " packets"); " is 133.
Long Statement,Lidgren.Network,NetPeer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetNatIntroduction.cs,DiscoverLocalPeers,The length of the statement  "			m_unsentUnconnectedMessages.Enqueue(new NetTuple<IPEndPoint' NetOutgoingMessage>(new IPEndPoint(IPAddress.Broadcast' serverPort)' om)); " is 135.
Long Statement,Lidgren.Network,NetPeer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetNatIntroduction.cs,SendDiscoveryResponse,The length of the statement  "				throw new NetException("Cannot send discovery message larger than MTU (currently " + m_configuration.MaximumTransmissionUnit + " bytes)"); " is 138.
Long Statement,Lidgren.Network,NetPeer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetNatIntroduction.cs,HandleReleasedFragment,The length of the statement  "			//LogVerbose("Found fragment #" + chunkNumber + " in group " + group + " offset " + offset + " of total bits " + totalBits + " (total chunks done " + cnt + ")"); " is 161.
Long Statement,Lidgren.Network,NetPeer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetNatIntroduction.cs,RegisterReceivedCallback,The length of the statement  "			m_receiveCallbacks.Add(new NetTuple<SynchronizationContext' SendOrPostCallback>(SynchronizationContext.Current' callback)); " is 123.
Long Statement,Lidgren.Network,NetPeer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetNatIntroduction.cs,UnregisterReceivedCallback,The length of the statement  "			m_receiveCallbacks.Remove(new NetTuple<SynchronizationContext' SendOrPostCallback>(SynchronizationContext.Current' callback)); " is 126.
Long Statement,Lidgren.Network,NetPeer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetNatIntroduction.cs,Heartbeat,The length of the statement  "						// we should shut down the connection; but m_senderRemote seemingly cannot be trusted' so which connection should we shut down?! " is 128.
Long Statement,Lidgren.Network,NetPeer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetNatIntroduction.cs,Heartbeat,The length of the statement  "						LogWarning("Malformed packet; stated payload length " + payloadByteLength + "' remaining bytes " + (bytesReceived - ptr)); " is 122.
Long Statement,Lidgren.Network,NetPeer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetNatIntroduction.cs,VerifyNetworkThread,The length of the statement  "				throw new NetException("Executing on wrong thread! Should be library system thread (is " + ct.Name + " mId " + ct.ManagedThreadId + ")"); " is 137.
Long Statement,Lidgren.Network,NetPeer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetNatIntroduction.cs,SendPacket,The length of the statement  "				delay = m_configuration.m_minimumOneWayLatency + (NetRandom.Instance.NextSingle() * m_configuration.m_randomOneWayLatency); " is 123.
Long Statement,Lidgren.Network,NetPeer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetNatIntroduction.cs,Recycle,The length of the statement  "			// TODO: find a way to recycle large message after all fragments has been acknowledged; or? possibly better just to garbage collect them " is 136.
Long Statement,Lidgren.Network,NetPeer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetNatIntroduction.cs,SendMessage,The length of the statement  "				throw new NetException("This message has already been sent! Use NetPeer.SendMessage() to send to multiple recipients efficiently"); " is 131.
Long Statement,Lidgren.Network,NetPeer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetNatIntroduction.cs,SendMessage,The length of the statement  "			int len = NetConstants.UnfragmentedMessageHeaderSize + msg.LengthBytes; // headers + length' faster than calling msg.GetEncodedSize " is 131.
Long Statement,Lidgren.Network,NetPeer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetNatIntroduction.cs,SendMessage,The length of the statement  "				throw new NetException("This message has already been sent! Use NetPeer.SendMessage() to send to multiple recipients efficiently"); " is 131.
Long Statement,Lidgren.Network,NetPeer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetNatIntroduction.cs,SendUnconnectedMessage,The length of the statement  "				throw new NetException("This message has already been sent! Use NetPeer.SendMessage() to send to multiple recipients efficiently"); " is 131.
Long Statement,Lidgren.Network,NetPeer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetNatIntroduction.cs,SendUnconnectedMessage,The length of the statement  "				throw new NetException("Unconnected messages too long! Must be shorter than NetConfiguration.MaximumTransmissionUnit (currently " + m_configuration.MaximumTransmissionUnit + ")"); " is 179.
Long Statement,Lidgren.Network,NetPeer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetNatIntroduction.cs,SendUnconnectedMessage,The length of the statement  "				throw new NetException("This message has already been sent! Use NetPeer.SendMessage() to send to multiple recipients efficiently"); " is 131.
Long Statement,Lidgren.Network,NetPeer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetNatIntroduction.cs,SendUnconnectedMessage,The length of the statement  "				throw new NetException("Unconnected messages too long! Must be shorter than NetConfiguration.MaximumTransmissionUnit (currently " + m_configuration.MaximumTransmissionUnit + ")"); " is 179.
Long Statement,Lidgren.Network,NetPeer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetNatIntroduction.cs,SendUnconnectedMessage,The length of the statement  "				throw new NetException("This message has already been sent! Use NetPeer.SendMessage() to send to multiple recipients efficiently"); " is 131.
Long Statement,Lidgren.Network,NetPeer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetNatIntroduction.cs,SendUnconnectedMessage,The length of the statement  "				throw new NetException("Unconnected messages too long! Must be shorter than NetConfiguration.MaximumTransmissionUnit (currently " + m_configuration.MaximumTransmissionUnit + ")"); " is 179.
Long Statement,Lidgren.Network,NetPeer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetNatIntroduction.cs,SendUnconnectedToSelf,The length of the statement  "				throw new NetException("This message has already been sent! Use NetPeer.SendMessage() to send to multiple recipients efficiently"); " is 131.
Long Statement,Lidgren.Network,NetOutgoingMessage,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetOutgoingMessage.cs,Encode,The length of the statement  "				ptr = NetFragmentationHelper.WriteHeader(intoBuffer' ptr' m_fragmentGroup' m_fragmentGroupTotalBits' m_fragmentChunkByteSize' m_fragmentChunkNumber); " is 149.
Long Statement,Lidgren.Network,NetOutgoingMessage,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetOutgoingMessage.cs,GetEncodedSize,The length of the statement  "				retval += NetFragmentationHelper.GetFragmentationHeaderSize(m_fragmentGroup' m_fragmentGroupTotalBits / 8' m_fragmentChunkByteSize' m_fragmentChunkNumber); " is 155.
Long Statement,Lidgren.Network,NetPeerStatistics,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetPeerStatistics.cs,ToString,The length of the statement  "			bdr.AppendLine("Received " + m_receivedBytes + " bytes in " + m_receivedMessages + " messages in " + m_receivedPackets + " packets"); " is 133.
Long Statement,Lidgren.Network,NetRandom,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetRandom.cs,Next,The length of the statement  "				return lowerBound + (int)((REAL_UNIT_UINT * (double)(w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)))) * (double)((long)upperBound - (long)lowerBound)); " is 141.
Long Statement,Lidgren.Network,NetRandom,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetRandom.cs,Next,The length of the statement  "			return lowerBound + (int)((REAL_UNIT_INT * (double)(int)(0x7FFFFFFF & (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8))))) * (double)range); " is 128.
Long Statement,Lidgren.Network,NetReliableSenderChannel,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetReliableSenderChannel.cs,GetAllowedSends,The length of the statement  "			int retval = m_windowSize - ((m_sendStart + NetConstants.NumSequenceNumbers) - m_windowStart) % NetConstants.NumSequenceNumbers; " is 128.
Long Statement,Lidgren.Network,NetReliableSenderChannel,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetReliableSenderChannel.cs,Enqueue,The length of the statement  "			int left = m_windowSize - ((m_sendStart + NetConstants.NumSequenceNumbers) - m_windowStart) % NetConstants.NumSequenceNumbers; " is 126.
Long Statement,Lidgren.Network,NetReliableSenderChannel,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetReliableSenderChannel.cs,SendQueuedMessages,The length of the statement  "					//m_connection.m_peer.LogVerbose("Resending due to delay #" + m_storedMessages[i].SequenceNumber + " " + om.ToString()); " is 120.
Long Statement,Lidgren.Network,NetReliableSenderChannel,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetReliableSenderChannel.cs,DestoreMessage,The length of the statement  "				throw new NetException("m_storedMessages[" + storeIndex + "].Message is null; sent " + m_storedMessages[storeIndex].NumSent + " times' last time " + (NetTime.Now - m_storedMessages[storeIndex].LastSent) + " seconds ago"); " is 221.
Long Statement,Lidgren.Network,NetUnreliableSenderChannel,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetUnreliableSenderChannel.cs,Enqueue,The length of the statement  "			int left = m_windowSize - ((m_sendStart + NetConstants.NumSequenceNumbers) - m_windowStart) % NetConstants.NumSequenceNumbers; " is 126.
Long Statement,Lidgren.Network,NetUPnP,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetUPnP.cs,ExtractServiceUrl,The length of the statement  "			XmlNode node = desc.SelectSingleNode("//tns:service[tns:serviceType=\"urn:schemas-upnp-org:service:" + m_serviceName + ":1\"]/tns:controlURL/text()"' nsMgr); " is 157.
Long Statement,Lidgren.Network,NetUPnP,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetUPnP.cs,ExtractServiceUrl,The length of the statement  "				node = desc.SelectSingleNode("//tns:service[tns:serviceType=\"urn:schemas-upnp-org:service:" + m_serviceName + ":1\"]/tns:controlURL/text()"' nsMgr); " is 149.
Long Statement,Lidgren.Network,NetUPnP,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetUPnP.cs,GetExternalIP,The length of the statement  "				XmlDocument xdoc = SOAPRequest(m_serviceUrl' "<u:GetExternalIPAddress xmlns:u=\"urn:schemas-upnp-org:service:" + m_serviceName + ":1\">" + " is 138.
Long Statement,Lidgren.Network,NetUPnP,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetUPnP.cs,SOAPRequest,The length of the statement  "			"<s:Envelope xmlns:s=\"http://schemas.xmlsoap.org/soap/envelope/\" s:encodingStyle=\"http://schemas.xmlsoap.org/soap/encoding/\">" + " is 132.
Long Statement,Lidgren.Network,NetUtility,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetUtility.cs,GetNetworkInterface,The length of the statement  "				if (adapter.NetworkInterfaceType == NetworkInterfaceType.Loopback || adapter.NetworkInterfaceType == NetworkInterfaceType.Unknown) " is 130.
Long Statement,Lidgren.Network,NetUtility,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetUtility.cs,GetNetworkInterface,The length of the statement  "					if (unicastAddress != null && unicastAddress.Address != null && unicastAddress.Address.AddressFamily == AddressFamily.InterNetwork) " is 131.
Long Statement,Lidgren.Network,NetUtility,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetUtility.cs,GetBroadcastAddress,The length of the statement  "			Android.Net.Wifi.WifiManager wifi = (Android.Net.Wifi.WifiManager)Android.App.Application.Context.GetSystemService(Android.App.Activity.WifiService); " is 149.
Long Statement,Lidgren.Network,NetUtility,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetUtility.cs,GetBroadcastAddress,The length of the statement  "					if (unicastAddress != null && unicastAddress.Address != null && unicastAddress.Address.AddressFamily == AddressFamily.InterNetwork) " is 131.
Long Statement,Lidgren.Network,NetUtility,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetUtility.cs,GetMyAddress,The length of the statement  "				Android.Net.Wifi.WifiManager wifi = (Android.Net.Wifi.WifiManager)Android.App.Application.Context.GetSystemService(Android.App.Activity.WifiService); " is 149.
Long Statement,Lidgren.Network,NetUtility,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetUtility.cs,GetMyAddress,The length of the statement  "				if (unicastAddress != null && unicastAddress.Address != null && unicastAddress.Address.AddressFamily == AddressFamily.InterNetwork) " is 131.
Long Statement,Lidgren.Network,NetUtility,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetUtility.cs,RelativeSequenceNumber,The length of the statement  "			return (nr - expected + NetConstants.NumSequenceNumbers + (NetConstants.NumSequenceNumbers / 2)) % NetConstants.NumSequenceNumbers - (NetConstants.NumSequenceNumbers / 2); " is 171.
Empty Catch Block,Lidgren.Network,NetConnection,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetConnection.cs,ReceivedHandshake,The method has an empty catch block.
Empty Catch Block,Lidgren.Network,NetPeer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetNatIntroduction.cs,InitializeNetwork,The method has an empty catch block.
Empty Catch Block,Lidgren.Network,NetPeer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetNatIntroduction.cs,InitializeNetwork,The method has an empty catch block.
Empty Catch Block,Lidgren.Network,NetPeer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetNatIntroduction.cs,ExecutePeerShutdown,The method has an empty catch block.
Empty Catch Block,Lidgren.Network,NetPeer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetNatIntroduction.cs,Heartbeat,The method has an empty catch block.
Empty Catch Block,Lidgren.Network,NetPeer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetNatIntroduction.cs,FlushDelayedPackets,The method has an empty catch block.
Magic Number,Lidgren.Network,NetAESEncryption,C:\repos\Nirklav_TCPChat\Lidgren.Network\Encryption\NetAESEncryption.cs,NetAESEncryption,The following statement contains a magic number: if (!m_keysizes.Contains(key.Length * 8))  				throw new NetException(string.Format("Not a valid key size. (Valid values are: {0})"' NetUtility.MakeCommaDelimitedList(m_keysizes)));
Magic Number,Lidgren.Network,NetAESEncryption,C:\repos\Nirklav_TCPChat\Lidgren.Network\Encryption\NetAESEncryption.cs,NetAESEncryption,The following statement contains a magic number: if (!m_blocksizes.Contains(iv.Length * 8))  				throw new NetException(string.Format("Not a valid iv size. (Valid values are: {0})"' NetUtility.MakeCommaDelimitedList(m_blocksizes)));
Magic Number,Lidgren.Network,NetAESEncryption,C:\repos\Nirklav_TCPChat\Lidgren.Network\Encryption\NetAESEncryption.cs,NetAESEncryption,The following statement contains a magic number: m_bitSize = m_key.Length * 8;
Magic Number,Lidgren.Network,NetAESEncryption,C:\repos\Nirklav_TCPChat\Lidgren.Network\Encryption\NetAESEncryption.cs,NetAESEncryption,The following statement contains a magic number: for (int i = 0; i < 1000; i++)  			{  				entropy = hmacsha512.ComputeHash(entropy);  			}
Magic Number,Lidgren.Network,NetAESEncryption,C:\repos\Nirklav_TCPChat\Lidgren.Network\Encryption\NetAESEncryption.cs,NetAESEncryption,The following statement contains a magic number: int keylen = bitsize / 8;
Magic Number,Lidgren.Network,NetAESEncryption,C:\repos\Nirklav_TCPChat\Lidgren.Network\Encryption\NetAESEncryption.cs,NetAESEncryption,The following statement contains a magic number: m_iv = new byte[m_blocksizes[0] / 8];
Magic Number,Lidgren.Network,NetBlockEncryptionBase,C:\repos\Nirklav_TCPChat\Lidgren.Network\Encryption\NetBlockEncryptionBase.cs,Encrypt,The following statement contains a magic number: msg.EnsureBufferSize(dstSize * 8 + (4 * 8));
Magic Number,Lidgren.Network,NetBlockEncryptionBase,C:\repos\Nirklav_TCPChat\Lidgren.Network\Encryption\NetBlockEncryptionBase.cs,Encrypt,The following statement contains a magic number: msg.EnsureBufferSize(dstSize * 8 + (4 * 8));
Magic Number,Lidgren.Network,NetBlockEncryptionBase,C:\repos\Nirklav_TCPChat\Lidgren.Network\Encryption\NetBlockEncryptionBase.cs,Encrypt,The following statement contains a magic number: msg.EnsureBufferSize(dstSize * 8 + (4 * 8));
Magic Number,Lidgren.Network,NetBlockEncryptionBase,C:\repos\Nirklav_TCPChat\Lidgren.Network\Encryption\NetBlockEncryptionBase.cs,Encrypt,The following statement contains a magic number: msg.LengthBits = dstSize * 8;
Magic Number,Lidgren.Network,NetBlockEncryptionBase,C:\repos\Nirklav_TCPChat\Lidgren.Network\Encryption\NetBlockEncryptionBase.cs,Decrypt,The following statement contains a magic number: int numEncryptedBytes = msg.LengthBytes - 4;
Magic Number,Lidgren.Network,NetBlockEncryptionBase,C:\repos\Nirklav_TCPChat\Lidgren.Network\Encryption\NetBlockEncryptionBase.cs,Decrypt,The following statement contains a magic number: uint realSize = NetBitWriter.ReadUInt32(msg.m_data' 32' (numEncryptedBytes * 8));
Magic Number,Lidgren.Network,NetBlockEncryptionBase,C:\repos\Nirklav_TCPChat\Lidgren.Network\Encryption\NetBlockEncryptionBase.cs,Decrypt,The following statement contains a magic number: uint realSize = NetBitWriter.ReadUInt32(msg.m_data' 32' (numEncryptedBytes * 8));
Magic Number,Lidgren.Network,NetDESEncryption,C:\repos\Nirklav_TCPChat\Lidgren.Network\Encryption\NetDESEncryption.cs,NetDESEncryption,The following statement contains a magic number: if (!m_keysizes.Contains(key.Length * 8))  				throw new NetException(string.Format("Not a valid key size. (Valid values are: {0})"' NetUtility.MakeCommaDelimitedList(m_keysizes)));
Magic Number,Lidgren.Network,NetDESEncryption,C:\repos\Nirklav_TCPChat\Lidgren.Network\Encryption\NetDESEncryption.cs,NetDESEncryption,The following statement contains a magic number: if (!m_blocksizes.Contains(iv.Length * 8))  				throw new NetException(string.Format("Not a valid iv size. (Valid values are: {0})"'  NetUtility.MakeCommaDelimitedList(m_blocksizes)));
Magic Number,Lidgren.Network,NetDESEncryption,C:\repos\Nirklav_TCPChat\Lidgren.Network\Encryption\NetDESEncryption.cs,NetDESEncryption,The following statement contains a magic number: m_bitSize = m_key.Length * 8;
Magic Number,Lidgren.Network,NetDESEncryption,C:\repos\Nirklav_TCPChat\Lidgren.Network\Encryption\NetDESEncryption.cs,NetDESEncryption,The following statement contains a magic number: for (int i = 0; i < 1000; i++)  			{  				entropy = hmacsha512.ComputeHash(entropy);  			}
Magic Number,Lidgren.Network,NetDESEncryption,C:\repos\Nirklav_TCPChat\Lidgren.Network\Encryption\NetDESEncryption.cs,NetDESEncryption,The following statement contains a magic number: int keylen = bitsize / 8;
Magic Number,Lidgren.Network,NetDESEncryption,C:\repos\Nirklav_TCPChat\Lidgren.Network\Encryption\NetDESEncryption.cs,NetDESEncryption,The following statement contains a magic number: m_iv = new byte[m_blocksizes[0] / 8];
Magic Number,Lidgren.Network,NetRC2Encryption,C:\repos\Nirklav_TCPChat\Lidgren.Network\Encryption\NetRC2Encryption.cs,NetRC2Encryption,The following statement contains a magic number: if (!m_keysizes.Contains(key.Length * 8))  				throw new NetException(string.Format("Not a valid key size. (Valid values are: {0})"' NetUtility.MakeCommaDelimitedList(m_keysizes)));
Magic Number,Lidgren.Network,NetRC2Encryption,C:\repos\Nirklav_TCPChat\Lidgren.Network\Encryption\NetRC2Encryption.cs,NetRC2Encryption,The following statement contains a magic number: if (!m_blocksizes.Contains(iv.Length * 8))  				throw new NetException(string.Format("Not a valid iv size. (Valid values are: {0})"' NetUtility.MakeCommaDelimitedList(m_blocksizes)));
Magic Number,Lidgren.Network,NetRC2Encryption,C:\repos\Nirklav_TCPChat\Lidgren.Network\Encryption\NetRC2Encryption.cs,NetRC2Encryption,The following statement contains a magic number: m_bitSize = m_key.Length * 8;
Magic Number,Lidgren.Network,NetRC2Encryption,C:\repos\Nirklav_TCPChat\Lidgren.Network\Encryption\NetRC2Encryption.cs,NetRC2Encryption,The following statement contains a magic number: for (int i = 0; i < 1000; i++)  			{  				entropy = hmacsha512.ComputeHash(entropy);  			}
Magic Number,Lidgren.Network,NetRC2Encryption,C:\repos\Nirklav_TCPChat\Lidgren.Network\Encryption\NetRC2Encryption.cs,NetRC2Encryption,The following statement contains a magic number: int keylen = bitsize / 8;
Magic Number,Lidgren.Network,NetRC2Encryption,C:\repos\Nirklav_TCPChat\Lidgren.Network\Encryption\NetRC2Encryption.cs,NetRC2Encryption,The following statement contains a magic number: m_iv = new byte[m_blocksizes[0] / 8];
Magic Number,Lidgren.Network,NetTripleDESEncryption,C:\repos\Nirklav_TCPChat\Lidgren.Network\Encryption\NetTripleDESEncryption.cs,NetTripleDESEncryption,The following statement contains a magic number: if (!m_keysizes.Contains(key.Length * 8))  				throw new NetException(string.Format("Not a valid key size. (Valid values are: {0})"' NetUtility.MakeCommaDelimitedList(m_keysizes)));
Magic Number,Lidgren.Network,NetTripleDESEncryption,C:\repos\Nirklav_TCPChat\Lidgren.Network\Encryption\NetTripleDESEncryption.cs,NetTripleDESEncryption,The following statement contains a magic number: if (!m_blocksizes.Contains(iv.Length * 8))  				throw new NetException(string.Format("Not a valid iv size. (Valid values are: {0})"' NetUtility.MakeCommaDelimitedList(m_blocksizes)));
Magic Number,Lidgren.Network,NetTripleDESEncryption,C:\repos\Nirklav_TCPChat\Lidgren.Network\Encryption\NetTripleDESEncryption.cs,NetTripleDESEncryption,The following statement contains a magic number: m_bitSize = m_key.Length * 8;
Magic Number,Lidgren.Network,NetTripleDESEncryption,C:\repos\Nirklav_TCPChat\Lidgren.Network\Encryption\NetTripleDESEncryption.cs,NetTripleDESEncryption,The following statement contains a magic number: for (int i = 0; i < 1000; i++)  			{  				entropy = hmacsha512.ComputeHash(entropy);  			}
Magic Number,Lidgren.Network,NetTripleDESEncryption,C:\repos\Nirklav_TCPChat\Lidgren.Network\Encryption\NetTripleDESEncryption.cs,NetTripleDESEncryption,The following statement contains a magic number: int keylen = bitsize / 8;
Magic Number,Lidgren.Network,NetTripleDESEncryption,C:\repos\Nirklav_TCPChat\Lidgren.Network\Encryption\NetTripleDESEncryption.cs,NetTripleDESEncryption,The following statement contains a magic number: m_iv = new byte[m_blocksizes[0] / 8];
Magic Number,Lidgren.Network,NetXtea,C:\repos\Nirklav_TCPChat\Lidgren.Network\Encryption\NetXteaEncryption.cs,NetXtea,The following statement contains a magic number: uint[] tmp = new uint[8];
Magic Number,Lidgren.Network,NetXtea,C:\repos\Nirklav_TCPChat\Lidgren.Network\Encryption\NetXteaEncryption.cs,NetXtea,The following statement contains a magic number: while (index < 4)  			{  				tmp[index] = BitConverter.ToUInt32(key' num2);  				index++;  				num2 += 4;  			}
Magic Number,Lidgren.Network,NetXtea,C:\repos\Nirklav_TCPChat\Lidgren.Network\Encryption\NetXteaEncryption.cs,NetXtea,The following statement contains a magic number: while (index < 4)  			{  				tmp[index] = BitConverter.ToUInt32(key' num2);  				index++;  				num2 += 4;  			}
Magic Number,Lidgren.Network,NetXtea,C:\repos\Nirklav_TCPChat\Lidgren.Network\Encryption\NetXteaEncryption.cs,NetXtea,The following statement contains a magic number: for (index = num2 = 0; index < 32; index++)  			{  				m_sum0[index] = ((uint)num2) + tmp[num2 & 3];  				num2 += -1640531527;  				m_sum1[index] = ((uint)num2) + tmp[(num2 >> 11) & 3];  			}
Magic Number,Lidgren.Network,NetXtea,C:\repos\Nirklav_TCPChat\Lidgren.Network\Encryption\NetXteaEncryption.cs,NetXtea,The following statement contains a magic number: for (index = num2 = 0; index < 32; index++)  			{  				m_sum0[index] = ((uint)num2) + tmp[num2 & 3];  				num2 += -1640531527;  				m_sum1[index] = ((uint)num2) + tmp[(num2 >> 11) & 3];  			}
Magic Number,Lidgren.Network,NetXtea,C:\repos\Nirklav_TCPChat\Lidgren.Network\Encryption\NetXteaEncryption.cs,NetXtea,The following statement contains a magic number: for (index = num2 = 0; index < 32; index++)  			{  				m_sum0[index] = ((uint)num2) + tmp[num2 & 3];  				num2 += -1640531527;  				m_sum1[index] = ((uint)num2) + tmp[(num2 >> 11) & 3];  			}
Magic Number,Lidgren.Network,NetXtea,C:\repos\Nirklav_TCPChat\Lidgren.Network\Encryption\NetXteaEncryption.cs,NetXtea,The following statement contains a magic number: for (index = num2 = 0; index < 32; index++)  			{  				m_sum0[index] = ((uint)num2) + tmp[num2 & 3];  				num2 += -1640531527;  				m_sum1[index] = ((uint)num2) + tmp[(num2 >> 11) & 3];  			}
Magic Number,Lidgren.Network,NetXtea,C:\repos\Nirklav_TCPChat\Lidgren.Network\Encryption\NetXteaEncryption.cs,NetXtea,The following statement contains a magic number: for (index = num2 = 0; index < 32; index++)  			{  				m_sum0[index] = ((uint)num2) + tmp[num2 & 3];  				num2 += -1640531527;  				m_sum1[index] = ((uint)num2) + tmp[(num2 >> 11) & 3];  			}
Magic Number,Lidgren.Network,NetXtea,C:\repos\Nirklav_TCPChat\Lidgren.Network\Encryption\NetXteaEncryption.cs,EncryptBlock,The following statement contains a magic number: uint v1 = BytesToUInt(source' sourceOffset + 4);
Magic Number,Lidgren.Network,NetXtea,C:\repos\Nirklav_TCPChat\Lidgren.Network\Encryption\NetXteaEncryption.cs,EncryptBlock,The following statement contains a magic number: for (int i = 0; i != m_numRounds; i++)  			{  				v0 += (((v1 << 4) ^ (v1 >> 5)) + v1) ^ m_sum0[i];  				v1 += (((v0 << 4) ^ (v0 >> 5)) + v0) ^ m_sum1[i];  			}
Magic Number,Lidgren.Network,NetXtea,C:\repos\Nirklav_TCPChat\Lidgren.Network\Encryption\NetXteaEncryption.cs,EncryptBlock,The following statement contains a magic number: for (int i = 0; i != m_numRounds; i++)  			{  				v0 += (((v1 << 4) ^ (v1 >> 5)) + v1) ^ m_sum0[i];  				v1 += (((v0 << 4) ^ (v0 >> 5)) + v0) ^ m_sum1[i];  			}
Magic Number,Lidgren.Network,NetXtea,C:\repos\Nirklav_TCPChat\Lidgren.Network\Encryption\NetXteaEncryption.cs,EncryptBlock,The following statement contains a magic number: for (int i = 0; i != m_numRounds; i++)  			{  				v0 += (((v1 << 4) ^ (v1 >> 5)) + v1) ^ m_sum0[i];  				v1 += (((v0 << 4) ^ (v0 >> 5)) + v0) ^ m_sum1[i];  			}
Magic Number,Lidgren.Network,NetXtea,C:\repos\Nirklav_TCPChat\Lidgren.Network\Encryption\NetXteaEncryption.cs,EncryptBlock,The following statement contains a magic number: for (int i = 0; i != m_numRounds; i++)  			{  				v0 += (((v1 << 4) ^ (v1 >> 5)) + v1) ^ m_sum0[i];  				v1 += (((v0 << 4) ^ (v0 >> 5)) + v0) ^ m_sum1[i];  			}
Magic Number,Lidgren.Network,NetXtea,C:\repos\Nirklav_TCPChat\Lidgren.Network\Encryption\NetXteaEncryption.cs,EncryptBlock,The following statement contains a magic number: UIntToBytes(v1' destination' 0 + 4);
Magic Number,Lidgren.Network,NetXtea,C:\repos\Nirklav_TCPChat\Lidgren.Network\Encryption\NetXteaEncryption.cs,DecryptBlock,The following statement contains a magic number: uint v1 = BytesToUInt(source' sourceOffset + 4);
Magic Number,Lidgren.Network,NetXtea,C:\repos\Nirklav_TCPChat\Lidgren.Network\Encryption\NetXteaEncryption.cs,DecryptBlock,The following statement contains a magic number: for (int i = m_numRounds - 1; i >= 0; i--)  			{  				v1 -= (((v0 << 4) ^ (v0 >> 5)) + v0) ^ m_sum1[i];  				v0 -= (((v1 << 4) ^ (v1 >> 5)) + v1) ^ m_sum0[i];  			}
Magic Number,Lidgren.Network,NetXtea,C:\repos\Nirklav_TCPChat\Lidgren.Network\Encryption\NetXteaEncryption.cs,DecryptBlock,The following statement contains a magic number: for (int i = m_numRounds - 1; i >= 0; i--)  			{  				v1 -= (((v0 << 4) ^ (v0 >> 5)) + v0) ^ m_sum1[i];  				v0 -= (((v1 << 4) ^ (v1 >> 5)) + v1) ^ m_sum0[i];  			}
Magic Number,Lidgren.Network,NetXtea,C:\repos\Nirklav_TCPChat\Lidgren.Network\Encryption\NetXteaEncryption.cs,DecryptBlock,The following statement contains a magic number: for (int i = m_numRounds - 1; i >= 0; i--)  			{  				v1 -= (((v0 << 4) ^ (v0 >> 5)) + v0) ^ m_sum1[i];  				v0 -= (((v1 << 4) ^ (v1 >> 5)) + v1) ^ m_sum0[i];  			}
Magic Number,Lidgren.Network,NetXtea,C:\repos\Nirklav_TCPChat\Lidgren.Network\Encryption\NetXteaEncryption.cs,DecryptBlock,The following statement contains a magic number: for (int i = m_numRounds - 1; i >= 0; i--)  			{  				v1 -= (((v0 << 4) ^ (v0 >> 5)) + v0) ^ m_sum1[i];  				v0 -= (((v1 << 4) ^ (v1 >> 5)) + v1) ^ m_sum0[i];  			}
Magic Number,Lidgren.Network,NetXtea,C:\repos\Nirklav_TCPChat\Lidgren.Network\Encryption\NetXteaEncryption.cs,DecryptBlock,The following statement contains a magic number: UIntToBytes(v1' destination' 0 + 4);
Magic Number,Lidgren.Network,NetXtea,C:\repos\Nirklav_TCPChat\Lidgren.Network\Encryption\NetXteaEncryption.cs,BytesToUInt,The following statement contains a magic number: uint retval = (uint)(bytes[offset] << 24);
Magic Number,Lidgren.Network,NetXtea,C:\repos\Nirklav_TCPChat\Lidgren.Network\Encryption\NetXteaEncryption.cs,BytesToUInt,The following statement contains a magic number: retval |= (uint)(bytes[++offset] << 16);
Magic Number,Lidgren.Network,NetXtea,C:\repos\Nirklav_TCPChat\Lidgren.Network\Encryption\NetXteaEncryption.cs,BytesToUInt,The following statement contains a magic number: retval |= (uint)(bytes[++offset] << 8);
Magic Number,Lidgren.Network,NetXtea,C:\repos\Nirklav_TCPChat\Lidgren.Network\Encryption\NetXteaEncryption.cs,UIntToBytes,The following statement contains a magic number: destination[destinationOffset++] = (byte)(value >> 24);
Magic Number,Lidgren.Network,NetXtea,C:\repos\Nirklav_TCPChat\Lidgren.Network\Encryption\NetXteaEncryption.cs,UIntToBytes,The following statement contains a magic number: destination[destinationOffset++] = (byte)(value >> 16);
Magic Number,Lidgren.Network,NetXtea,C:\repos\Nirklav_TCPChat\Lidgren.Network\Encryption\NetXteaEncryption.cs,UIntToBytes,The following statement contains a magic number: destination[destinationOffset++] = (byte)(value >> 8);
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,NetBigInteger,The following statement contains a magic number: switch (radix)  			{  				case 2:  					// Is there anyway to restrict to binary digits?  					style = NumberStyles.Integer;  					chunk = chunk2;  					r = radix2;  					rE = radix2E;  					break;  				case 10:  					// This style seems to handle spaces and minus sign already (our processing redundant?)  					style = NumberStyles.Integer;  					chunk = chunk10;  					r = radix10;  					rE = radix10E;  					break;  				case 16:  					// TODO Should this be HexNumber?  					style = NumberStyles.AllowHexSpecifier;  					chunk = chunk16;  					r = radix16;  					rE = radix16E;  					break;  				default:  					throw new FormatException("Only bases 2' 10' or 16 allowed");  			}
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,NetBigInteger,The following statement contains a magic number: switch (radix)  			{  				case 2:  					// Is there anyway to restrict to binary digits?  					style = NumberStyles.Integer;  					chunk = chunk2;  					r = radix2;  					rE = radix2E;  					break;  				case 10:  					// This style seems to handle spaces and minus sign already (our processing redundant?)  					style = NumberStyles.Integer;  					chunk = chunk10;  					r = radix10;  					rE = radix10E;  					break;  				case 16:  					// TODO Should this be HexNumber?  					style = NumberStyles.AllowHexSpecifier;  					chunk = chunk16;  					r = radix16;  					rE = radix16E;  					break;  				default:  					throw new FormatException("Only bases 2' 10' or 16 allowed");  			}
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,NetBigInteger,The following statement contains a magic number: switch (radix)  			{  				case 2:  					// Is there anyway to restrict to binary digits?  					style = NumberStyles.Integer;  					chunk = chunk2;  					r = radix2;  					rE = radix2E;  					break;  				case 10:  					// This style seems to handle spaces and minus sign already (our processing redundant?)  					style = NumberStyles.Integer;  					chunk = chunk10;  					r = radix10;  					rE = radix10E;  					break;  				case 16:  					// TODO Should this be HexNumber?  					style = NumberStyles.AllowHexSpecifier;  					chunk = chunk16;  					r = radix16;  					rE = radix16E;  					break;  				default:  					throw new FormatException("Only bases 2' 10' or 16 allowed");  			}
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,NetBigInteger,The following statement contains a magic number: if (next <= str.Length)  			{  				do  				{  					string s = str.Substring(index' chunk);  					ulong i = ulong.Parse(s' style);  					NetBigInteger bi = createUValueOf(i);    					switch (radix)  					{  						case 2:  							if (i > 1)  								throw new FormatException("Bad character in radix 2 string: " + s);    							b = b.ShiftLeft(1);  							break;  						case 16:  							b = b.ShiftLeft(64);  							break;  						default:  							b = b.Multiply(rE);  							break;  					}    					b = b.Add(bi);    					index = next;  					next += chunk;  				}  				while (next <= str.Length);  			}
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,NetBigInteger,The following statement contains a magic number: if (next <= str.Length)  			{  				do  				{  					string s = str.Substring(index' chunk);  					ulong i = ulong.Parse(s' style);  					NetBigInteger bi = createUValueOf(i);    					switch (radix)  					{  						case 2:  							if (i > 1)  								throw new FormatException("Bad character in radix 2 string: " + s);    							b = b.ShiftLeft(1);  							break;  						case 16:  							b = b.ShiftLeft(64);  							break;  						default:  							b = b.Multiply(rE);  							break;  					}    					b = b.Add(bi);    					index = next;  					next += chunk;  				}  				while (next <= str.Length);  			}
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,NetBigInteger,The following statement contains a magic number: if (next <= str.Length)  			{  				do  				{  					string s = str.Substring(index' chunk);  					ulong i = ulong.Parse(s' style);  					NetBigInteger bi = createUValueOf(i);    					switch (radix)  					{  						case 2:  							if (i > 1)  								throw new FormatException("Bad character in radix 2 string: " + s);    							b = b.ShiftLeft(1);  							break;  						case 16:  							b = b.ShiftLeft(64);  							break;  						default:  							b = b.Multiply(rE);  							break;  					}    					b = b.Add(bi);    					index = next;  					next += chunk;  				}  				while (next <= str.Length);  			}
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,NetBigInteger,The following statement contains a magic number: if (index < str.Length)  			{  				string s = str.Substring(index);  				ulong i = ulong.Parse(s' style);  				NetBigInteger bi = createUValueOf(i);    				if (b.m_sign > 0)  				{  					if (radix == 2)  					{  						// NB: Can't reach here since we are parsing one char at a time  						Debug.Assert(false);  					}  					else if (radix == 16)  					{  						b = b.ShiftLeft(s.Length << 2);  					}  					else  					{  						b = b.Multiply(r.Pow(s.Length));  					}    					b = b.Add(bi);  				}  				else  				{  					b = bi;  				}  			}
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,NetBigInteger,The following statement contains a magic number: if (index < str.Length)  			{  				string s = str.Substring(index);  				ulong i = ulong.Parse(s' style);  				NetBigInteger bi = createUValueOf(i);    				if (b.m_sign > 0)  				{  					if (radix == 2)  					{  						// NB: Can't reach here since we are parsing one char at a time  						Debug.Assert(false);  					}  					else if (radix == 16)  					{  						b = b.ShiftLeft(s.Length << 2);  					}  					else  					{  						b = b.Multiply(r.Pow(s.Length));  					}    					b = b.Add(bi);  				}  				else  				{  					b = bi;  				}  			}
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,NetBigInteger,The following statement contains a magic number: if (index < str.Length)  			{  				string s = str.Substring(index);  				ulong i = ulong.Parse(s' style);  				NetBigInteger bi = createUValueOf(i);    				if (b.m_sign > 0)  				{  					if (radix == 2)  					{  						// NB: Can't reach here since we are parsing one char at a time  						Debug.Assert(false);  					}  					else if (radix == 16)  					{  						b = b.ShiftLeft(s.Length << 2);  					}  					else  					{  						b = b.Multiply(r.Pow(s.Length));  					}    					b = b.Add(bi);  				}  				else  				{  					b = bi;  				}  			}
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,MakeMagnitude,The following statement contains a magic number: int nInts = (end - firstSignificant + 3) / BytesPerInt;
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,MakeMagnitude,The following statement contains a magic number: for (int i = firstSignificant; i < end; ++i)  			{  				v <<= 8;  				v |= bytes[i] & 0xff;  				bCount--;  				if (bCount <= 0)  				{  					mag[magnitudeIndex] = v;  					magnitudeIndex++;  					bCount = BytesPerInt;  					v = 0;  				}  			}
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,AddMagnitudes,The following statement contains a magic number: while (vI >= 0)  			{  				m += ((long)(uint)a[tI] + (long)(uint)b[vI--]);  				a[tI--] = (int)m;  				m = (long)((ulong)m >> 32);  			}
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,calcBitLength,The following statement contains a magic number: int bitLength = 32 * ((mag.Length - indx) - 1);
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,BitLen,The following statement contains a magic number: return (w < 1 << 15 ? (w < 1 << 7  				? (w < 1 << 3 ? (w < 1 << 1  				? (w < 1 << 0 ? (w < 0 ? 32 : 0) : 1)  				: (w < 1 << 2 ? 2 : 3)) : (w < 1 << 5  				? (w < 1 << 4 ? 4 : 5)  				: (w < 1 << 6 ? 6 : 7)))  				: (w < 1 << 11  				? (w < 1 << 9 ? (w < 1 << 8 ? 8 : 9) : (w < 1 << 10 ? 10 : 11))  				: (w < 1 << 13 ? (w < 1 << 12 ? 12 : 13) : (w < 1 << 14 ? 14 : 15)))) : (w < 1 << 23 ? (w < 1 << 19  				? (w < 1 << 17 ? (w < 1 << 16 ? 16 : 17) : (w < 1 << 18 ? 18 : 19))  				: (w < 1 << 21 ? (w < 1 << 20 ? 20 : 21) : (w < 1 << 22 ? 22 : 23))) : (w < 1 << 27  				? (w < 1 << 25 ? (w < 1 << 24 ? 24 : 25) : (w < 1 << 26 ? 26 : 27))  				: (w < 1 << 29 ? (w < 1 << 28 ? 28 : 29) : (w < 1 << 30 ? 30 : 31)))));
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,BitLen,The following statement contains a magic number: return (w < 1 << 15 ? (w < 1 << 7  				? (w < 1 << 3 ? (w < 1 << 1  				? (w < 1 << 0 ? (w < 0 ? 32 : 0) : 1)  				: (w < 1 << 2 ? 2 : 3)) : (w < 1 << 5  				? (w < 1 << 4 ? 4 : 5)  				: (w < 1 << 6 ? 6 : 7)))  				: (w < 1 << 11  				? (w < 1 << 9 ? (w < 1 << 8 ? 8 : 9) : (w < 1 << 10 ? 10 : 11))  				: (w < 1 << 13 ? (w < 1 << 12 ? 12 : 13) : (w < 1 << 14 ? 14 : 15)))) : (w < 1 << 23 ? (w < 1 << 19  				? (w < 1 << 17 ? (w < 1 << 16 ? 16 : 17) : (w < 1 << 18 ? 18 : 19))  				: (w < 1 << 21 ? (w < 1 << 20 ? 20 : 21) : (w < 1 << 22 ? 22 : 23))) : (w < 1 << 27  				? (w < 1 << 25 ? (w < 1 << 24 ? 24 : 25) : (w < 1 << 26 ? 26 : 27))  				: (w < 1 << 29 ? (w < 1 << 28 ? 28 : 29) : (w < 1 << 30 ? 30 : 31)))));
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,BitLen,The following statement contains a magic number: return (w < 1 << 15 ? (w < 1 << 7  				? (w < 1 << 3 ? (w < 1 << 1  				? (w < 1 << 0 ? (w < 0 ? 32 : 0) : 1)  				: (w < 1 << 2 ? 2 : 3)) : (w < 1 << 5  				? (w < 1 << 4 ? 4 : 5)  				: (w < 1 << 6 ? 6 : 7)))  				: (w < 1 << 11  				? (w < 1 << 9 ? (w < 1 << 8 ? 8 : 9) : (w < 1 << 10 ? 10 : 11))  				: (w < 1 << 13 ? (w < 1 << 12 ? 12 : 13) : (w < 1 << 14 ? 14 : 15)))) : (w < 1 << 23 ? (w < 1 << 19  				? (w < 1 << 17 ? (w < 1 << 16 ? 16 : 17) : (w < 1 << 18 ? 18 : 19))  				: (w < 1 << 21 ? (w < 1 << 20 ? 20 : 21) : (w < 1 << 22 ? 22 : 23))) : (w < 1 << 27  				? (w < 1 << 25 ? (w < 1 << 24 ? 24 : 25) : (w < 1 << 26 ? 26 : 27))  				: (w < 1 << 29 ? (w < 1 << 28 ? 28 : 29) : (w < 1 << 30 ? 30 : 31)))));
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,BitLen,The following statement contains a magic number: return (w < 1 << 15 ? (w < 1 << 7  				? (w < 1 << 3 ? (w < 1 << 1  				? (w < 1 << 0 ? (w < 0 ? 32 : 0) : 1)  				: (w < 1 << 2 ? 2 : 3)) : (w < 1 << 5  				? (w < 1 << 4 ? 4 : 5)  				: (w < 1 << 6 ? 6 : 7)))  				: (w < 1 << 11  				? (w < 1 << 9 ? (w < 1 << 8 ? 8 : 9) : (w < 1 << 10 ? 10 : 11))  				: (w < 1 << 13 ? (w < 1 << 12 ? 12 : 13) : (w < 1 << 14 ? 14 : 15)))) : (w < 1 << 23 ? (w < 1 << 19  				? (w < 1 << 17 ? (w < 1 << 16 ? 16 : 17) : (w < 1 << 18 ? 18 : 19))  				: (w < 1 << 21 ? (w < 1 << 20 ? 20 : 21) : (w < 1 << 22 ? 22 : 23))) : (w < 1 << 27  				? (w < 1 << 25 ? (w < 1 << 24 ? 24 : 25) : (w < 1 << 26 ? 26 : 27))  				: (w < 1 << 29 ? (w < 1 << 28 ? 28 : 29) : (w < 1 << 30 ? 30 : 31)))));
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,BitLen,The following statement contains a magic number: return (w < 1 << 15 ? (w < 1 << 7  				? (w < 1 << 3 ? (w < 1 << 1  				? (w < 1 << 0 ? (w < 0 ? 32 : 0) : 1)  				: (w < 1 << 2 ? 2 : 3)) : (w < 1 << 5  				? (w < 1 << 4 ? 4 : 5)  				: (w < 1 << 6 ? 6 : 7)))  				: (w < 1 << 11  				? (w < 1 << 9 ? (w < 1 << 8 ? 8 : 9) : (w < 1 << 10 ? 10 : 11))  				: (w < 1 << 13 ? (w < 1 << 12 ? 12 : 13) : (w < 1 << 14 ? 14 : 15)))) : (w < 1 << 23 ? (w < 1 << 19  				? (w < 1 << 17 ? (w < 1 << 16 ? 16 : 17) : (w < 1 << 18 ? 18 : 19))  				: (w < 1 << 21 ? (w < 1 << 20 ? 20 : 21) : (w < 1 << 22 ? 22 : 23))) : (w < 1 << 27  				? (w < 1 << 25 ? (w < 1 << 24 ? 24 : 25) : (w < 1 << 26 ? 26 : 27))  				: (w < 1 << 29 ? (w < 1 << 28 ? 28 : 29) : (w < 1 << 30 ? 30 : 31)))));
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,BitLen,The following statement contains a magic number: return (w < 1 << 15 ? (w < 1 << 7  				? (w < 1 << 3 ? (w < 1 << 1  				? (w < 1 << 0 ? (w < 0 ? 32 : 0) : 1)  				: (w < 1 << 2 ? 2 : 3)) : (w < 1 << 5  				? (w < 1 << 4 ? 4 : 5)  				: (w < 1 << 6 ? 6 : 7)))  				: (w < 1 << 11  				? (w < 1 << 9 ? (w < 1 << 8 ? 8 : 9) : (w < 1 << 10 ? 10 : 11))  				: (w < 1 << 13 ? (w < 1 << 12 ? 12 : 13) : (w < 1 << 14 ? 14 : 15)))) : (w < 1 << 23 ? (w < 1 << 19  				? (w < 1 << 17 ? (w < 1 << 16 ? 16 : 17) : (w < 1 << 18 ? 18 : 19))  				: (w < 1 << 21 ? (w < 1 << 20 ? 20 : 21) : (w < 1 << 22 ? 22 : 23))) : (w < 1 << 27  				? (w < 1 << 25 ? (w < 1 << 24 ? 24 : 25) : (w < 1 << 26 ? 26 : 27))  				: (w < 1 << 29 ? (w < 1 << 28 ? 28 : 29) : (w < 1 << 30 ? 30 : 31)))));
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,BitLen,The following statement contains a magic number: return (w < 1 << 15 ? (w < 1 << 7  				? (w < 1 << 3 ? (w < 1 << 1  				? (w < 1 << 0 ? (w < 0 ? 32 : 0) : 1)  				: (w < 1 << 2 ? 2 : 3)) : (w < 1 << 5  				? (w < 1 << 4 ? 4 : 5)  				: (w < 1 << 6 ? 6 : 7)))  				: (w < 1 << 11  				? (w < 1 << 9 ? (w < 1 << 8 ? 8 : 9) : (w < 1 << 10 ? 10 : 11))  				: (w < 1 << 13 ? (w < 1 << 12 ? 12 : 13) : (w < 1 << 14 ? 14 : 15)))) : (w < 1 << 23 ? (w < 1 << 19  				? (w < 1 << 17 ? (w < 1 << 16 ? 16 : 17) : (w < 1 << 18 ? 18 : 19))  				: (w < 1 << 21 ? (w < 1 << 20 ? 20 : 21) : (w < 1 << 22 ? 22 : 23))) : (w < 1 << 27  				? (w < 1 << 25 ? (w < 1 << 24 ? 24 : 25) : (w < 1 << 26 ? 26 : 27))  				: (w < 1 << 29 ? (w < 1 << 28 ? 28 : 29) : (w < 1 << 30 ? 30 : 31)))));
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,BitLen,The following statement contains a magic number: return (w < 1 << 15 ? (w < 1 << 7  				? (w < 1 << 3 ? (w < 1 << 1  				? (w < 1 << 0 ? (w < 0 ? 32 : 0) : 1)  				: (w < 1 << 2 ? 2 : 3)) : (w < 1 << 5  				? (w < 1 << 4 ? 4 : 5)  				: (w < 1 << 6 ? 6 : 7)))  				: (w < 1 << 11  				? (w < 1 << 9 ? (w < 1 << 8 ? 8 : 9) : (w < 1 << 10 ? 10 : 11))  				: (w < 1 << 13 ? (w < 1 << 12 ? 12 : 13) : (w < 1 << 14 ? 14 : 15)))) : (w < 1 << 23 ? (w < 1 << 19  				? (w < 1 << 17 ? (w < 1 << 16 ? 16 : 17) : (w < 1 << 18 ? 18 : 19))  				: (w < 1 << 21 ? (w < 1 << 20 ? 20 : 21) : (w < 1 << 22 ? 22 : 23))) : (w < 1 << 27  				? (w < 1 << 25 ? (w < 1 << 24 ? 24 : 25) : (w < 1 << 26 ? 26 : 27))  				: (w < 1 << 29 ? (w < 1 << 28 ? 28 : 29) : (w < 1 << 30 ? 30 : 31)))));
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,BitLen,The following statement contains a magic number: return (w < 1 << 15 ? (w < 1 << 7  				? (w < 1 << 3 ? (w < 1 << 1  				? (w < 1 << 0 ? (w < 0 ? 32 : 0) : 1)  				: (w < 1 << 2 ? 2 : 3)) : (w < 1 << 5  				? (w < 1 << 4 ? 4 : 5)  				: (w < 1 << 6 ? 6 : 7)))  				: (w < 1 << 11  				? (w < 1 << 9 ? (w < 1 << 8 ? 8 : 9) : (w < 1 << 10 ? 10 : 11))  				: (w < 1 << 13 ? (w < 1 << 12 ? 12 : 13) : (w < 1 << 14 ? 14 : 15)))) : (w < 1 << 23 ? (w < 1 << 19  				? (w < 1 << 17 ? (w < 1 << 16 ? 16 : 17) : (w < 1 << 18 ? 18 : 19))  				: (w < 1 << 21 ? (w < 1 << 20 ? 20 : 21) : (w < 1 << 22 ? 22 : 23))) : (w < 1 << 27  				? (w < 1 << 25 ? (w < 1 << 24 ? 24 : 25) : (w < 1 << 26 ? 26 : 27))  				: (w < 1 << 29 ? (w < 1 << 28 ? 28 : 29) : (w < 1 << 30 ? 30 : 31)))));
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,BitLen,The following statement contains a magic number: return (w < 1 << 15 ? (w < 1 << 7  				? (w < 1 << 3 ? (w < 1 << 1  				? (w < 1 << 0 ? (w < 0 ? 32 : 0) : 1)  				: (w < 1 << 2 ? 2 : 3)) : (w < 1 << 5  				? (w < 1 << 4 ? 4 : 5)  				: (w < 1 << 6 ? 6 : 7)))  				: (w < 1 << 11  				? (w < 1 << 9 ? (w < 1 << 8 ? 8 : 9) : (w < 1 << 10 ? 10 : 11))  				: (w < 1 << 13 ? (w < 1 << 12 ? 12 : 13) : (w < 1 << 14 ? 14 : 15)))) : (w < 1 << 23 ? (w < 1 << 19  				? (w < 1 << 17 ? (w < 1 << 16 ? 16 : 17) : (w < 1 << 18 ? 18 : 19))  				: (w < 1 << 21 ? (w < 1 << 20 ? 20 : 21) : (w < 1 << 22 ? 22 : 23))) : (w < 1 << 27  				? (w < 1 << 25 ? (w < 1 << 24 ? 24 : 25) : (w < 1 << 26 ? 26 : 27))  				: (w < 1 << 29 ? (w < 1 << 28 ? 28 : 29) : (w < 1 << 30 ? 30 : 31)))));
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,BitLen,The following statement contains a magic number: return (w < 1 << 15 ? (w < 1 << 7  				? (w < 1 << 3 ? (w < 1 << 1  				? (w < 1 << 0 ? (w < 0 ? 32 : 0) : 1)  				: (w < 1 << 2 ? 2 : 3)) : (w < 1 << 5  				? (w < 1 << 4 ? 4 : 5)  				: (w < 1 << 6 ? 6 : 7)))  				: (w < 1 << 11  				? (w < 1 << 9 ? (w < 1 << 8 ? 8 : 9) : (w < 1 << 10 ? 10 : 11))  				: (w < 1 << 13 ? (w < 1 << 12 ? 12 : 13) : (w < 1 << 14 ? 14 : 15)))) : (w < 1 << 23 ? (w < 1 << 19  				? (w < 1 << 17 ? (w < 1 << 16 ? 16 : 17) : (w < 1 << 18 ? 18 : 19))  				: (w < 1 << 21 ? (w < 1 << 20 ? 20 : 21) : (w < 1 << 22 ? 22 : 23))) : (w < 1 << 27  				? (w < 1 << 25 ? (w < 1 << 24 ? 24 : 25) : (w < 1 << 26 ? 26 : 27))  				: (w < 1 << 29 ? (w < 1 << 28 ? 28 : 29) : (w < 1 << 30 ? 30 : 31)))));
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,BitLen,The following statement contains a magic number: return (w < 1 << 15 ? (w < 1 << 7  				? (w < 1 << 3 ? (w < 1 << 1  				? (w < 1 << 0 ? (w < 0 ? 32 : 0) : 1)  				: (w < 1 << 2 ? 2 : 3)) : (w < 1 << 5  				? (w < 1 << 4 ? 4 : 5)  				: (w < 1 << 6 ? 6 : 7)))  				: (w < 1 << 11  				? (w < 1 << 9 ? (w < 1 << 8 ? 8 : 9) : (w < 1 << 10 ? 10 : 11))  				: (w < 1 << 13 ? (w < 1 << 12 ? 12 : 13) : (w < 1 << 14 ? 14 : 15)))) : (w < 1 << 23 ? (w < 1 << 19  				? (w < 1 << 17 ? (w < 1 << 16 ? 16 : 17) : (w < 1 << 18 ? 18 : 19))  				: (w < 1 << 21 ? (w < 1 << 20 ? 20 : 21) : (w < 1 << 22 ? 22 : 23))) : (w < 1 << 27  				? (w < 1 << 25 ? (w < 1 << 24 ? 24 : 25) : (w < 1 << 26 ? 26 : 27))  				: (w < 1 << 29 ? (w < 1 << 28 ? 28 : 29) : (w < 1 << 30 ? 30 : 31)))));
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,BitLen,The following statement contains a magic number: return (w < 1 << 15 ? (w < 1 << 7  				? (w < 1 << 3 ? (w < 1 << 1  				? (w < 1 << 0 ? (w < 0 ? 32 : 0) : 1)  				: (w < 1 << 2 ? 2 : 3)) : (w < 1 << 5  				? (w < 1 << 4 ? 4 : 5)  				: (w < 1 << 6 ? 6 : 7)))  				: (w < 1 << 11  				? (w < 1 << 9 ? (w < 1 << 8 ? 8 : 9) : (w < 1 << 10 ? 10 : 11))  				: (w < 1 << 13 ? (w < 1 << 12 ? 12 : 13) : (w < 1 << 14 ? 14 : 15)))) : (w < 1 << 23 ? (w < 1 << 19  				? (w < 1 << 17 ? (w < 1 << 16 ? 16 : 17) : (w < 1 << 18 ? 18 : 19))  				: (w < 1 << 21 ? (w < 1 << 20 ? 20 : 21) : (w < 1 << 22 ? 22 : 23))) : (w < 1 << 27  				? (w < 1 << 25 ? (w < 1 << 24 ? 24 : 25) : (w < 1 << 26 ? 26 : 27))  				: (w < 1 << 29 ? (w < 1 << 28 ? 28 : 29) : (w < 1 << 30 ? 30 : 31)))));
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,BitLen,The following statement contains a magic number: return (w < 1 << 15 ? (w < 1 << 7  				? (w < 1 << 3 ? (w < 1 << 1  				? (w < 1 << 0 ? (w < 0 ? 32 : 0) : 1)  				: (w < 1 << 2 ? 2 : 3)) : (w < 1 << 5  				? (w < 1 << 4 ? 4 : 5)  				: (w < 1 << 6 ? 6 : 7)))  				: (w < 1 << 11  				? (w < 1 << 9 ? (w < 1 << 8 ? 8 : 9) : (w < 1 << 10 ? 10 : 11))  				: (w < 1 << 13 ? (w < 1 << 12 ? 12 : 13) : (w < 1 << 14 ? 14 : 15)))) : (w < 1 << 23 ? (w < 1 << 19  				? (w < 1 << 17 ? (w < 1 << 16 ? 16 : 17) : (w < 1 << 18 ? 18 : 19))  				: (w < 1 << 21 ? (w < 1 << 20 ? 20 : 21) : (w < 1 << 22 ? 22 : 23))) : (w < 1 << 27  				? (w < 1 << 25 ? (w < 1 << 24 ? 24 : 25) : (w < 1 << 26 ? 26 : 27))  				: (w < 1 << 29 ? (w < 1 << 28 ? 28 : 29) : (w < 1 << 30 ? 30 : 31)))));
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,BitLen,The following statement contains a magic number: return (w < 1 << 15 ? (w < 1 << 7  				? (w < 1 << 3 ? (w < 1 << 1  				? (w < 1 << 0 ? (w < 0 ? 32 : 0) : 1)  				: (w < 1 << 2 ? 2 : 3)) : (w < 1 << 5  				? (w < 1 << 4 ? 4 : 5)  				: (w < 1 << 6 ? 6 : 7)))  				: (w < 1 << 11  				? (w < 1 << 9 ? (w < 1 << 8 ? 8 : 9) : (w < 1 << 10 ? 10 : 11))  				: (w < 1 << 13 ? (w < 1 << 12 ? 12 : 13) : (w < 1 << 14 ? 14 : 15)))) : (w < 1 << 23 ? (w < 1 << 19  				? (w < 1 << 17 ? (w < 1 << 16 ? 16 : 17) : (w < 1 << 18 ? 18 : 19))  				: (w < 1 << 21 ? (w < 1 << 20 ? 20 : 21) : (w < 1 << 22 ? 22 : 23))) : (w < 1 << 27  				? (w < 1 << 25 ? (w < 1 << 24 ? 24 : 25) : (w < 1 << 26 ? 26 : 27))  				: (w < 1 << 29 ? (w < 1 << 28 ? 28 : 29) : (w < 1 << 30 ? 30 : 31)))));
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,BitLen,The following statement contains a magic number: return (w < 1 << 15 ? (w < 1 << 7  				? (w < 1 << 3 ? (w < 1 << 1  				? (w < 1 << 0 ? (w < 0 ? 32 : 0) : 1)  				: (w < 1 << 2 ? 2 : 3)) : (w < 1 << 5  				? (w < 1 << 4 ? 4 : 5)  				: (w < 1 << 6 ? 6 : 7)))  				: (w < 1 << 11  				? (w < 1 << 9 ? (w < 1 << 8 ? 8 : 9) : (w < 1 << 10 ? 10 : 11))  				: (w < 1 << 13 ? (w < 1 << 12 ? 12 : 13) : (w < 1 << 14 ? 14 : 15)))) : (w < 1 << 23 ? (w < 1 << 19  				? (w < 1 << 17 ? (w < 1 << 16 ? 16 : 17) : (w < 1 << 18 ? 18 : 19))  				: (w < 1 << 21 ? (w < 1 << 20 ? 20 : 21) : (w < 1 << 22 ? 22 : 23))) : (w < 1 << 27  				? (w < 1 << 25 ? (w < 1 << 24 ? 24 : 25) : (w < 1 << 26 ? 26 : 27))  				: (w < 1 << 29 ? (w < 1 << 28 ? 28 : 29) : (w < 1 << 30 ? 30 : 31)))));
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,BitLen,The following statement contains a magic number: return (w < 1 << 15 ? (w < 1 << 7  				? (w < 1 << 3 ? (w < 1 << 1  				? (w < 1 << 0 ? (w < 0 ? 32 : 0) : 1)  				: (w < 1 << 2 ? 2 : 3)) : (w < 1 << 5  				? (w < 1 << 4 ? 4 : 5)  				: (w < 1 << 6 ? 6 : 7)))  				: (w < 1 << 11  				? (w < 1 << 9 ? (w < 1 << 8 ? 8 : 9) : (w < 1 << 10 ? 10 : 11))  				: (w < 1 << 13 ? (w < 1 << 12 ? 12 : 13) : (w < 1 << 14 ? 14 : 15)))) : (w < 1 << 23 ? (w < 1 << 19  				? (w < 1 << 17 ? (w < 1 << 16 ? 16 : 17) : (w < 1 << 18 ? 18 : 19))  				: (w < 1 << 21 ? (w < 1 << 20 ? 20 : 21) : (w < 1 << 22 ? 22 : 23))) : (w < 1 << 27  				? (w < 1 << 25 ? (w < 1 << 24 ? 24 : 25) : (w < 1 << 26 ? 26 : 27))  				: (w < 1 << 29 ? (w < 1 << 28 ? 28 : 29) : (w < 1 << 30 ? 30 : 31)))));
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,BitLen,The following statement contains a magic number: return (w < 1 << 15 ? (w < 1 << 7  				? (w < 1 << 3 ? (w < 1 << 1  				? (w < 1 << 0 ? (w < 0 ? 32 : 0) : 1)  				: (w < 1 << 2 ? 2 : 3)) : (w < 1 << 5  				? (w < 1 << 4 ? 4 : 5)  				: (w < 1 << 6 ? 6 : 7)))  				: (w < 1 << 11  				? (w < 1 << 9 ? (w < 1 << 8 ? 8 : 9) : (w < 1 << 10 ? 10 : 11))  				: (w < 1 << 13 ? (w < 1 << 12 ? 12 : 13) : (w < 1 << 14 ? 14 : 15)))) : (w < 1 << 23 ? (w < 1 << 19  				? (w < 1 << 17 ? (w < 1 << 16 ? 16 : 17) : (w < 1 << 18 ? 18 : 19))  				: (w < 1 << 21 ? (w < 1 << 20 ? 20 : 21) : (w < 1 << 22 ? 22 : 23))) : (w < 1 << 27  				? (w < 1 << 25 ? (w < 1 << 24 ? 24 : 25) : (w < 1 << 26 ? 26 : 27))  				: (w < 1 << 29 ? (w < 1 << 28 ? 28 : 29) : (w < 1 << 30 ? 30 : 31)))));
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,BitLen,The following statement contains a magic number: return (w < 1 << 15 ? (w < 1 << 7  				? (w < 1 << 3 ? (w < 1 << 1  				? (w < 1 << 0 ? (w < 0 ? 32 : 0) : 1)  				: (w < 1 << 2 ? 2 : 3)) : (w < 1 << 5  				? (w < 1 << 4 ? 4 : 5)  				: (w < 1 << 6 ? 6 : 7)))  				: (w < 1 << 11  				? (w < 1 << 9 ? (w < 1 << 8 ? 8 : 9) : (w < 1 << 10 ? 10 : 11))  				: (w < 1 << 13 ? (w < 1 << 12 ? 12 : 13) : (w < 1 << 14 ? 14 : 15)))) : (w < 1 << 23 ? (w < 1 << 19  				? (w < 1 << 17 ? (w < 1 << 16 ? 16 : 17) : (w < 1 << 18 ? 18 : 19))  				: (w < 1 << 21 ? (w < 1 << 20 ? 20 : 21) : (w < 1 << 22 ? 22 : 23))) : (w < 1 << 27  				? (w < 1 << 25 ? (w < 1 << 24 ? 24 : 25) : (w < 1 << 26 ? 26 : 27))  				: (w < 1 << 29 ? (w < 1 << 28 ? 28 : 29) : (w < 1 << 30 ? 30 : 31)))));
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,BitLen,The following statement contains a magic number: return (w < 1 << 15 ? (w < 1 << 7  				? (w < 1 << 3 ? (w < 1 << 1  				? (w < 1 << 0 ? (w < 0 ? 32 : 0) : 1)  				: (w < 1 << 2 ? 2 : 3)) : (w < 1 << 5  				? (w < 1 << 4 ? 4 : 5)  				: (w < 1 << 6 ? 6 : 7)))  				: (w < 1 << 11  				? (w < 1 << 9 ? (w < 1 << 8 ? 8 : 9) : (w < 1 << 10 ? 10 : 11))  				: (w < 1 << 13 ? (w < 1 << 12 ? 12 : 13) : (w < 1 << 14 ? 14 : 15)))) : (w < 1 << 23 ? (w < 1 << 19  				? (w < 1 << 17 ? (w < 1 << 16 ? 16 : 17) : (w < 1 << 18 ? 18 : 19))  				: (w < 1 << 21 ? (w < 1 << 20 ? 20 : 21) : (w < 1 << 22 ? 22 : 23))) : (w < 1 << 27  				? (w < 1 << 25 ? (w < 1 << 24 ? 24 : 25) : (w < 1 << 26 ? 26 : 27))  				: (w < 1 << 29 ? (w < 1 << 28 ? 28 : 29) : (w < 1 << 30 ? 30 : 31)))));
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,BitLen,The following statement contains a magic number: return (w < 1 << 15 ? (w < 1 << 7  				? (w < 1 << 3 ? (w < 1 << 1  				? (w < 1 << 0 ? (w < 0 ? 32 : 0) : 1)  				: (w < 1 << 2 ? 2 : 3)) : (w < 1 << 5  				? (w < 1 << 4 ? 4 : 5)  				: (w < 1 << 6 ? 6 : 7)))  				: (w < 1 << 11  				? (w < 1 << 9 ? (w < 1 << 8 ? 8 : 9) : (w < 1 << 10 ? 10 : 11))  				: (w < 1 << 13 ? (w < 1 << 12 ? 12 : 13) : (w < 1 << 14 ? 14 : 15)))) : (w < 1 << 23 ? (w < 1 << 19  				? (w < 1 << 17 ? (w < 1 << 16 ? 16 : 17) : (w < 1 << 18 ? 18 : 19))  				: (w < 1 << 21 ? (w < 1 << 20 ? 20 : 21) : (w < 1 << 22 ? 22 : 23))) : (w < 1 << 27  				? (w < 1 << 25 ? (w < 1 << 24 ? 24 : 25) : (w < 1 << 26 ? 26 : 27))  				: (w < 1 << 29 ? (w < 1 << 28 ? 28 : 29) : (w < 1 << 30 ? 30 : 31)))));
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,BitLen,The following statement contains a magic number: return (w < 1 << 15 ? (w < 1 << 7  				? (w < 1 << 3 ? (w < 1 << 1  				? (w < 1 << 0 ? (w < 0 ? 32 : 0) : 1)  				: (w < 1 << 2 ? 2 : 3)) : (w < 1 << 5  				? (w < 1 << 4 ? 4 : 5)  				: (w < 1 << 6 ? 6 : 7)))  				: (w < 1 << 11  				? (w < 1 << 9 ? (w < 1 << 8 ? 8 : 9) : (w < 1 << 10 ? 10 : 11))  				: (w < 1 << 13 ? (w < 1 << 12 ? 12 : 13) : (w < 1 << 14 ? 14 : 15)))) : (w < 1 << 23 ? (w < 1 << 19  				? (w < 1 << 17 ? (w < 1 << 16 ? 16 : 17) : (w < 1 << 18 ? 18 : 19))  				: (w < 1 << 21 ? (w < 1 << 20 ? 20 : 21) : (w < 1 << 22 ? 22 : 23))) : (w < 1 << 27  				? (w < 1 << 25 ? (w < 1 << 24 ? 24 : 25) : (w < 1 << 26 ? 26 : 27))  				: (w < 1 << 29 ? (w < 1 << 28 ? 28 : 29) : (w < 1 << 30 ? 30 : 31)))));
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,BitLen,The following statement contains a magic number: return (w < 1 << 15 ? (w < 1 << 7  				? (w < 1 << 3 ? (w < 1 << 1  				? (w < 1 << 0 ? (w < 0 ? 32 : 0) : 1)  				: (w < 1 << 2 ? 2 : 3)) : (w < 1 << 5  				? (w < 1 << 4 ? 4 : 5)  				: (w < 1 << 6 ? 6 : 7)))  				: (w < 1 << 11  				? (w < 1 << 9 ? (w < 1 << 8 ? 8 : 9) : (w < 1 << 10 ? 10 : 11))  				: (w < 1 << 13 ? (w < 1 << 12 ? 12 : 13) : (w < 1 << 14 ? 14 : 15)))) : (w < 1 << 23 ? (w < 1 << 19  				? (w < 1 << 17 ? (w < 1 << 16 ? 16 : 17) : (w < 1 << 18 ? 18 : 19))  				: (w < 1 << 21 ? (w < 1 << 20 ? 20 : 21) : (w < 1 << 22 ? 22 : 23))) : (w < 1 << 27  				? (w < 1 << 25 ? (w < 1 << 24 ? 24 : 25) : (w < 1 << 26 ? 26 : 27))  				: (w < 1 << 29 ? (w < 1 << 28 ? 28 : 29) : (w < 1 << 30 ? 30 : 31)))));
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,BitLen,The following statement contains a magic number: return (w < 1 << 15 ? (w < 1 << 7  				? (w < 1 << 3 ? (w < 1 << 1  				? (w < 1 << 0 ? (w < 0 ? 32 : 0) : 1)  				: (w < 1 << 2 ? 2 : 3)) : (w < 1 << 5  				? (w < 1 << 4 ? 4 : 5)  				: (w < 1 << 6 ? 6 : 7)))  				: (w < 1 << 11  				? (w < 1 << 9 ? (w < 1 << 8 ? 8 : 9) : (w < 1 << 10 ? 10 : 11))  				: (w < 1 << 13 ? (w < 1 << 12 ? 12 : 13) : (w < 1 << 14 ? 14 : 15)))) : (w < 1 << 23 ? (w < 1 << 19  				? (w < 1 << 17 ? (w < 1 << 16 ? 16 : 17) : (w < 1 << 18 ? 18 : 19))  				: (w < 1 << 21 ? (w < 1 << 20 ? 20 : 21) : (w < 1 << 22 ? 22 : 23))) : (w < 1 << 27  				? (w < 1 << 25 ? (w < 1 << 24 ? 24 : 25) : (w < 1 << 26 ? 26 : 27))  				: (w < 1 << 29 ? (w < 1 << 28 ? 28 : 29) : (w < 1 << 30 ? 30 : 31)))));
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,BitLen,The following statement contains a magic number: return (w < 1 << 15 ? (w < 1 << 7  				? (w < 1 << 3 ? (w < 1 << 1  				? (w < 1 << 0 ? (w < 0 ? 32 : 0) : 1)  				: (w < 1 << 2 ? 2 : 3)) : (w < 1 << 5  				? (w < 1 << 4 ? 4 : 5)  				: (w < 1 << 6 ? 6 : 7)))  				: (w < 1 << 11  				? (w < 1 << 9 ? (w < 1 << 8 ? 8 : 9) : (w < 1 << 10 ? 10 : 11))  				: (w < 1 << 13 ? (w < 1 << 12 ? 12 : 13) : (w < 1 << 14 ? 14 : 15)))) : (w < 1 << 23 ? (w < 1 << 19  				? (w < 1 << 17 ? (w < 1 << 16 ? 16 : 17) : (w < 1 << 18 ? 18 : 19))  				: (w < 1 << 21 ? (w < 1 << 20 ? 20 : 21) : (w < 1 << 22 ? 22 : 23))) : (w < 1 << 27  				? (w < 1 << 25 ? (w < 1 << 24 ? 24 : 25) : (w < 1 << 26 ? 26 : 27))  				: (w < 1 << 29 ? (w < 1 << 28 ? 28 : 29) : (w < 1 << 30 ? 30 : 31)))));
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,BitLen,The following statement contains a magic number: return (w < 1 << 15 ? (w < 1 << 7  				? (w < 1 << 3 ? (w < 1 << 1  				? (w < 1 << 0 ? (w < 0 ? 32 : 0) : 1)  				: (w < 1 << 2 ? 2 : 3)) : (w < 1 << 5  				? (w < 1 << 4 ? 4 : 5)  				: (w < 1 << 6 ? 6 : 7)))  				: (w < 1 << 11  				? (w < 1 << 9 ? (w < 1 << 8 ? 8 : 9) : (w < 1 << 10 ? 10 : 11))  				: (w < 1 << 13 ? (w < 1 << 12 ? 12 : 13) : (w < 1 << 14 ? 14 : 15)))) : (w < 1 << 23 ? (w < 1 << 19  				? (w < 1 << 17 ? (w < 1 << 16 ? 16 : 17) : (w < 1 << 18 ? 18 : 19))  				: (w < 1 << 21 ? (w < 1 << 20 ? 20 : 21) : (w < 1 << 22 ? 22 : 23))) : (w < 1 << 27  				? (w < 1 << 25 ? (w < 1 << 24 ? 24 : 25) : (w < 1 << 26 ? 26 : 27))  				: (w < 1 << 29 ? (w < 1 << 28 ? 28 : 29) : (w < 1 << 30 ? 30 : 31)))));
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,BitLen,The following statement contains a magic number: return (w < 1 << 15 ? (w < 1 << 7  				? (w < 1 << 3 ? (w < 1 << 1  				? (w < 1 << 0 ? (w < 0 ? 32 : 0) : 1)  				: (w < 1 << 2 ? 2 : 3)) : (w < 1 << 5  				? (w < 1 << 4 ? 4 : 5)  				: (w < 1 << 6 ? 6 : 7)))  				: (w < 1 << 11  				? (w < 1 << 9 ? (w < 1 << 8 ? 8 : 9) : (w < 1 << 10 ? 10 : 11))  				: (w < 1 << 13 ? (w < 1 << 12 ? 12 : 13) : (w < 1 << 14 ? 14 : 15)))) : (w < 1 << 23 ? (w < 1 << 19  				? (w < 1 << 17 ? (w < 1 << 16 ? 16 : 17) : (w < 1 << 18 ? 18 : 19))  				: (w < 1 << 21 ? (w < 1 << 20 ? 20 : 21) : (w < 1 << 22 ? 22 : 23))) : (w < 1 << 27  				? (w < 1 << 25 ? (w < 1 << 24 ? 24 : 25) : (w < 1 << 26 ? 26 : 27))  				: (w < 1 << 29 ? (w < 1 << 28 ? 28 : 29) : (w < 1 << 30 ? 30 : 31)))));
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,BitLen,The following statement contains a magic number: return (w < 1 << 15 ? (w < 1 << 7  				? (w < 1 << 3 ? (w < 1 << 1  				? (w < 1 << 0 ? (w < 0 ? 32 : 0) : 1)  				: (w < 1 << 2 ? 2 : 3)) : (w < 1 << 5  				? (w < 1 << 4 ? 4 : 5)  				: (w < 1 << 6 ? 6 : 7)))  				: (w < 1 << 11  				? (w < 1 << 9 ? (w < 1 << 8 ? 8 : 9) : (w < 1 << 10 ? 10 : 11))  				: (w < 1 << 13 ? (w < 1 << 12 ? 12 : 13) : (w < 1 << 14 ? 14 : 15)))) : (w < 1 << 23 ? (w < 1 << 19  				? (w < 1 << 17 ? (w < 1 << 16 ? 16 : 17) : (w < 1 << 18 ? 18 : 19))  				: (w < 1 << 21 ? (w < 1 << 20 ? 20 : 21) : (w < 1 << 22 ? 22 : 23))) : (w < 1 << 27  				? (w < 1 << 25 ? (w < 1 << 24 ? 24 : 25) : (w < 1 << 26 ? 26 : 27))  				: (w < 1 << 29 ? (w < 1 << 28 ? 28 : 29) : (w < 1 << 30 ? 30 : 31)))));
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,BitLen,The following statement contains a magic number: return (w < 1 << 15 ? (w < 1 << 7  				? (w < 1 << 3 ? (w < 1 << 1  				? (w < 1 << 0 ? (w < 0 ? 32 : 0) : 1)  				: (w < 1 << 2 ? 2 : 3)) : (w < 1 << 5  				? (w < 1 << 4 ? 4 : 5)  				: (w < 1 << 6 ? 6 : 7)))  				: (w < 1 << 11  				? (w < 1 << 9 ? (w < 1 << 8 ? 8 : 9) : (w < 1 << 10 ? 10 : 11))  				: (w < 1 << 13 ? (w < 1 << 12 ? 12 : 13) : (w < 1 << 14 ? 14 : 15)))) : (w < 1 << 23 ? (w < 1 << 19  				? (w < 1 << 17 ? (w < 1 << 16 ? 16 : 17) : (w < 1 << 18 ? 18 : 19))  				: (w < 1 << 21 ? (w < 1 << 20 ? 20 : 21) : (w < 1 << 22 ? 22 : 23))) : (w < 1 << 27  				? (w < 1 << 25 ? (w < 1 << 24 ? 24 : 25) : (w < 1 << 26 ? 26 : 27))  				: (w < 1 << 29 ? (w < 1 << 28 ? 28 : 29) : (w < 1 << 30 ? 30 : 31)))));
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,BitLen,The following statement contains a magic number: return (w < 1 << 15 ? (w < 1 << 7  				? (w < 1 << 3 ? (w < 1 << 1  				? (w < 1 << 0 ? (w < 0 ? 32 : 0) : 1)  				: (w < 1 << 2 ? 2 : 3)) : (w < 1 << 5  				? (w < 1 << 4 ? 4 : 5)  				: (w < 1 << 6 ? 6 : 7)))  				: (w < 1 << 11  				? (w < 1 << 9 ? (w < 1 << 8 ? 8 : 9) : (w < 1 << 10 ? 10 : 11))  				: (w < 1 << 13 ? (w < 1 << 12 ? 12 : 13) : (w < 1 << 14 ? 14 : 15)))) : (w < 1 << 23 ? (w < 1 << 19  				? (w < 1 << 17 ? (w < 1 << 16 ? 16 : 17) : (w < 1 << 18 ? 18 : 19))  				: (w < 1 << 21 ? (w < 1 << 20 ? 20 : 21) : (w < 1 << 22 ? 22 : 23))) : (w < 1 << 27  				? (w < 1 << 25 ? (w < 1 << 24 ? 24 : 25) : (w < 1 << 26 ? 26 : 27))  				: (w < 1 << 29 ? (w < 1 << 28 ? 28 : 29) : (w < 1 << 30 ? 30 : 31)))));
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,BitLen,The following statement contains a magic number: return (w < 1 << 15 ? (w < 1 << 7  				? (w < 1 << 3 ? (w < 1 << 1  				? (w < 1 << 0 ? (w < 0 ? 32 : 0) : 1)  				: (w < 1 << 2 ? 2 : 3)) : (w < 1 << 5  				? (w < 1 << 4 ? 4 : 5)  				: (w < 1 << 6 ? 6 : 7)))  				: (w < 1 << 11  				? (w < 1 << 9 ? (w < 1 << 8 ? 8 : 9) : (w < 1 << 10 ? 10 : 11))  				: (w < 1 << 13 ? (w < 1 << 12 ? 12 : 13) : (w < 1 << 14 ? 14 : 15)))) : (w < 1 << 23 ? (w < 1 << 19  				? (w < 1 << 17 ? (w < 1 << 16 ? 16 : 17) : (w < 1 << 18 ? 18 : 19))  				: (w < 1 << 21 ? (w < 1 << 20 ? 20 : 21) : (w < 1 << 22 ? 22 : 23))) : (w < 1 << 27  				? (w < 1 << 25 ? (w < 1 << 24 ? 24 : 25) : (w < 1 << 26 ? 26 : 27))  				: (w < 1 << 29 ? (w < 1 << 28 ? 28 : 29) : (w < 1 << 30 ? 30 : 31)))));
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,BitLen,The following statement contains a magic number: return (w < 1 << 15 ? (w < 1 << 7  				? (w < 1 << 3 ? (w < 1 << 1  				? (w < 1 << 0 ? (w < 0 ? 32 : 0) : 1)  				: (w < 1 << 2 ? 2 : 3)) : (w < 1 << 5  				? (w < 1 << 4 ? 4 : 5)  				: (w < 1 << 6 ? 6 : 7)))  				: (w < 1 << 11  				? (w < 1 << 9 ? (w < 1 << 8 ? 8 : 9) : (w < 1 << 10 ? 10 : 11))  				: (w < 1 << 13 ? (w < 1 << 12 ? 12 : 13) : (w < 1 << 14 ? 14 : 15)))) : (w < 1 << 23 ? (w < 1 << 19  				? (w < 1 << 17 ? (w < 1 << 16 ? 16 : 17) : (w < 1 << 18 ? 18 : 19))  				: (w < 1 << 21 ? (w < 1 << 20 ? 20 : 21) : (w < 1 << 22 ? 22 : 23))) : (w < 1 << 27  				? (w < 1 << 25 ? (w < 1 << 24 ? 24 : 25) : (w < 1 << 26 ? 26 : 27))  				: (w < 1 << 29 ? (w < 1 << 28 ? 28 : 29) : (w < 1 << 30 ? 30 : 31)))));
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,BitLen,The following statement contains a magic number: return (w < 1 << 15 ? (w < 1 << 7  				? (w < 1 << 3 ? (w < 1 << 1  				? (w < 1 << 0 ? (w < 0 ? 32 : 0) : 1)  				: (w < 1 << 2 ? 2 : 3)) : (w < 1 << 5  				? (w < 1 << 4 ? 4 : 5)  				: (w < 1 << 6 ? 6 : 7)))  				: (w < 1 << 11  				? (w < 1 << 9 ? (w < 1 << 8 ? 8 : 9) : (w < 1 << 10 ? 10 : 11))  				: (w < 1 << 13 ? (w < 1 << 12 ? 12 : 13) : (w < 1 << 14 ? 14 : 15)))) : (w < 1 << 23 ? (w < 1 << 19  				? (w < 1 << 17 ? (w < 1 << 16 ? 16 : 17) : (w < 1 << 18 ? 18 : 19))  				: (w < 1 << 21 ? (w < 1 << 20 ? 20 : 21) : (w < 1 << 22 ? 22 : 23))) : (w < 1 << 27  				? (w < 1 << 25 ? (w < 1 << 24 ? 24 : 25) : (w < 1 << 26 ? 26 : 27))  				: (w < 1 << 29 ? (w < 1 << 28 ? 28 : 29) : (w < 1 << 30 ? 30 : 31)))));
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,BitLen,The following statement contains a magic number: return (w < 1 << 15 ? (w < 1 << 7  				? (w < 1 << 3 ? (w < 1 << 1  				? (w < 1 << 0 ? (w < 0 ? 32 : 0) : 1)  				: (w < 1 << 2 ? 2 : 3)) : (w < 1 << 5  				? (w < 1 << 4 ? 4 : 5)  				: (w < 1 << 6 ? 6 : 7)))  				: (w < 1 << 11  				? (w < 1 << 9 ? (w < 1 << 8 ? 8 : 9) : (w < 1 << 10 ? 10 : 11))  				: (w < 1 << 13 ? (w < 1 << 12 ? 12 : 13) : (w < 1 << 14 ? 14 : 15)))) : (w < 1 << 23 ? (w < 1 << 19  				? (w < 1 << 17 ? (w < 1 << 16 ? 16 : 17) : (w < 1 << 18 ? 18 : 19))  				: (w < 1 << 21 ? (w < 1 << 20 ? 20 : 21) : (w < 1 << 22 ? 22 : 23))) : (w < 1 << 27  				? (w < 1 << 25 ? (w < 1 << 24 ? 24 : 25) : (w < 1 << 26 ? 26 : 27))  				: (w < 1 << 29 ? (w < 1 << 28 ? 28 : 29) : (w < 1 << 30 ? 30 : 31)))));
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,BitLen,The following statement contains a magic number: return (w < 1 << 15 ? (w < 1 << 7  				? (w < 1 << 3 ? (w < 1 << 1  				? (w < 1 << 0 ? (w < 0 ? 32 : 0) : 1)  				: (w < 1 << 2 ? 2 : 3)) : (w < 1 << 5  				? (w < 1 << 4 ? 4 : 5)  				: (w < 1 << 6 ? 6 : 7)))  				: (w < 1 << 11  				? (w < 1 << 9 ? (w < 1 << 8 ? 8 : 9) : (w < 1 << 10 ? 10 : 11))  				: (w < 1 << 13 ? (w < 1 << 12 ? 12 : 13) : (w < 1 << 14 ? 14 : 15)))) : (w < 1 << 23 ? (w < 1 << 19  				? (w < 1 << 17 ? (w < 1 << 16 ? 16 : 17) : (w < 1 << 18 ? 18 : 19))  				: (w < 1 << 21 ? (w < 1 << 20 ? 20 : 21) : (w < 1 << 22 ? 22 : 23))) : (w < 1 << 27  				? (w < 1 << 25 ? (w < 1 << 24 ? 24 : 25) : (w < 1 << 26 ? 26 : 27))  				: (w < 1 << 29 ? (w < 1 << 28 ? 28 : 29) : (w < 1 << 30 ? 30 : 31)))));
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,BitLen,The following statement contains a magic number: return (w < 1 << 15 ? (w < 1 << 7  				? (w < 1 << 3 ? (w < 1 << 1  				? (w < 1 << 0 ? (w < 0 ? 32 : 0) : 1)  				: (w < 1 << 2 ? 2 : 3)) : (w < 1 << 5  				? (w < 1 << 4 ? 4 : 5)  				: (w < 1 << 6 ? 6 : 7)))  				: (w < 1 << 11  				? (w < 1 << 9 ? (w < 1 << 8 ? 8 : 9) : (w < 1 << 10 ? 10 : 11))  				: (w < 1 << 13 ? (w < 1 << 12 ? 12 : 13) : (w < 1 << 14 ? 14 : 15)))) : (w < 1 << 23 ? (w < 1 << 19  				? (w < 1 << 17 ? (w < 1 << 16 ? 16 : 17) : (w < 1 << 18 ? 18 : 19))  				: (w < 1 << 21 ? (w < 1 << 20 ? 20 : 21) : (w < 1 << 22 ? 22 : 23))) : (w < 1 << 27  				? (w < 1 << 25 ? (w < 1 << 24 ? 24 : 25) : (w < 1 << 26 ? 26 : 27))  				: (w < 1 << 29 ? (w < 1 << 28 ? 28 : 29) : (w < 1 << 30 ? 30 : 31)))));
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,BitLen,The following statement contains a magic number: return (w < 1 << 15 ? (w < 1 << 7  				? (w < 1 << 3 ? (w < 1 << 1  				? (w < 1 << 0 ? (w < 0 ? 32 : 0) : 1)  				: (w < 1 << 2 ? 2 : 3)) : (w < 1 << 5  				? (w < 1 << 4 ? 4 : 5)  				: (w < 1 << 6 ? 6 : 7)))  				: (w < 1 << 11  				? (w < 1 << 9 ? (w < 1 << 8 ? 8 : 9) : (w < 1 << 10 ? 10 : 11))  				: (w < 1 << 13 ? (w < 1 << 12 ? 12 : 13) : (w < 1 << 14 ? 14 : 15)))) : (w < 1 << 23 ? (w < 1 << 19  				? (w < 1 << 17 ? (w < 1 << 16 ? 16 : 17) : (w < 1 << 18 ? 18 : 19))  				: (w < 1 << 21 ? (w < 1 << 20 ? 20 : 21) : (w < 1 << 22 ? 22 : 23))) : (w < 1 << 27  				? (w < 1 << 25 ? (w < 1 << 24 ? 24 : 25) : (w < 1 << 26 ? 26 : 27))  				: (w < 1 << 29 ? (w < 1 << 28 ? 28 : 29) : (w < 1 << 30 ? 30 : 31)))));
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,BitLen,The following statement contains a magic number: return (w < 1 << 15 ? (w < 1 << 7  				? (w < 1 << 3 ? (w < 1 << 1  				? (w < 1 << 0 ? (w < 0 ? 32 : 0) : 1)  				: (w < 1 << 2 ? 2 : 3)) : (w < 1 << 5  				? (w < 1 << 4 ? 4 : 5)  				: (w < 1 << 6 ? 6 : 7)))  				: (w < 1 << 11  				? (w < 1 << 9 ? (w < 1 << 8 ? 8 : 9) : (w < 1 << 10 ? 10 : 11))  				: (w < 1 << 13 ? (w < 1 << 12 ? 12 : 13) : (w < 1 << 14 ? 14 : 15)))) : (w < 1 << 23 ? (w < 1 << 19  				? (w < 1 << 17 ? (w < 1 << 16 ? 16 : 17) : (w < 1 << 18 ? 18 : 19))  				: (w < 1 << 21 ? (w < 1 << 20 ? 20 : 21) : (w < 1 << 22 ? 22 : 23))) : (w < 1 << 27  				? (w < 1 << 25 ? (w < 1 << 24 ? 24 : 25) : (w < 1 << 26 ? 26 : 27))  				: (w < 1 << 29 ? (w < 1 << 28 ? 28 : 29) : (w < 1 << 30 ? 30 : 31)))));
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,BitLen,The following statement contains a magic number: return (w < 1 << 15 ? (w < 1 << 7  				? (w < 1 << 3 ? (w < 1 << 1  				? (w < 1 << 0 ? (w < 0 ? 32 : 0) : 1)  				: (w < 1 << 2 ? 2 : 3)) : (w < 1 << 5  				? (w < 1 << 4 ? 4 : 5)  				: (w < 1 << 6 ? 6 : 7)))  				: (w < 1 << 11  				? (w < 1 << 9 ? (w < 1 << 8 ? 8 : 9) : (w < 1 << 10 ? 10 : 11))  				: (w < 1 << 13 ? (w < 1 << 12 ? 12 : 13) : (w < 1 << 14 ? 14 : 15)))) : (w < 1 << 23 ? (w < 1 << 19  				? (w < 1 << 17 ? (w < 1 << 16 ? 16 : 17) : (w < 1 << 18 ? 18 : 19))  				: (w < 1 << 21 ? (w < 1 << 20 ? 20 : 21) : (w < 1 << 22 ? 22 : 23))) : (w < 1 << 27  				? (w < 1 << 25 ? (w < 1 << 24 ? 24 : 25) : (w < 1 << 26 ? 26 : 27))  				: (w < 1 << 29 ? (w < 1 << 28 ? 28 : 29) : (w < 1 << 30 ? 30 : 31)))));
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,BitLen,The following statement contains a magic number: return (w < 1 << 15 ? (w < 1 << 7  				? (w < 1 << 3 ? (w < 1 << 1  				? (w < 1 << 0 ? (w < 0 ? 32 : 0) : 1)  				: (w < 1 << 2 ? 2 : 3)) : (w < 1 << 5  				? (w < 1 << 4 ? 4 : 5)  				: (w < 1 << 6 ? 6 : 7)))  				: (w < 1 << 11  				? (w < 1 << 9 ? (w < 1 << 8 ? 8 : 9) : (w < 1 << 10 ? 10 : 11))  				: (w < 1 << 13 ? (w < 1 << 12 ? 12 : 13) : (w < 1 << 14 ? 14 : 15)))) : (w < 1 << 23 ? (w < 1 << 19  				? (w < 1 << 17 ? (w < 1 << 16 ? 16 : 17) : (w < 1 << 18 ? 18 : 19))  				: (w < 1 << 21 ? (w < 1 << 20 ? 20 : 21) : (w < 1 << 22 ? 22 : 23))) : (w < 1 << 27  				? (w < 1 << 25 ? (w < 1 << 24 ? 24 : 25) : (w < 1 << 26 ? 26 : 27))  				: (w < 1 << 29 ? (w < 1 << 28 ? 28 : 29) : (w < 1 << 30 ? 30 : 31)))));
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,BitLen,The following statement contains a magic number: return (w < 1 << 15 ? (w < 1 << 7  				? (w < 1 << 3 ? (w < 1 << 1  				? (w < 1 << 0 ? (w < 0 ? 32 : 0) : 1)  				: (w < 1 << 2 ? 2 : 3)) : (w < 1 << 5  				? (w < 1 << 4 ? 4 : 5)  				: (w < 1 << 6 ? 6 : 7)))  				: (w < 1 << 11  				? (w < 1 << 9 ? (w < 1 << 8 ? 8 : 9) : (w < 1 << 10 ? 10 : 11))  				: (w < 1 << 13 ? (w < 1 << 12 ? 12 : 13) : (w < 1 << 14 ? 14 : 15)))) : (w < 1 << 23 ? (w < 1 << 19  				? (w < 1 << 17 ? (w < 1 << 16 ? 16 : 17) : (w < 1 << 18 ? 18 : 19))  				: (w < 1 << 21 ? (w < 1 << 20 ? 20 : 21) : (w < 1 << 22 ? 22 : 23))) : (w < 1 << 27  				? (w < 1 << 25 ? (w < 1 << 24 ? 24 : 25) : (w < 1 << 26 ? 26 : 27))  				: (w < 1 << 29 ? (w < 1 << 28 ? 28 : 29) : (w < 1 << 30 ? 30 : 31)))));
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,BitLen,The following statement contains a magic number: return (w < 1 << 15 ? (w < 1 << 7  				? (w < 1 << 3 ? (w < 1 << 1  				? (w < 1 << 0 ? (w < 0 ? 32 : 0) : 1)  				: (w < 1 << 2 ? 2 : 3)) : (w < 1 << 5  				? (w < 1 << 4 ? 4 : 5)  				: (w < 1 << 6 ? 6 : 7)))  				: (w < 1 << 11  				? (w < 1 << 9 ? (w < 1 << 8 ? 8 : 9) : (w < 1 << 10 ? 10 : 11))  				: (w < 1 << 13 ? (w < 1 << 12 ? 12 : 13) : (w < 1 << 14 ? 14 : 15)))) : (w < 1 << 23 ? (w < 1 << 19  				? (w < 1 << 17 ? (w < 1 << 16 ? 16 : 17) : (w < 1 << 18 ? 18 : 19))  				: (w < 1 << 21 ? (w < 1 << 20 ? 20 : 21) : (w < 1 << 22 ? 22 : 23))) : (w < 1 << 27  				? (w < 1 << 25 ? (w < 1 << 24 ? 24 : 25) : (w < 1 << 26 ? 26 : 27))  				: (w < 1 << 29 ? (w < 1 << 28 ? 28 : 29) : (w < 1 << 30 ? 30 : 31)))));
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,BitLen,The following statement contains a magic number: return (w < 1 << 15 ? (w < 1 << 7  				? (w < 1 << 3 ? (w < 1 << 1  				? (w < 1 << 0 ? (w < 0 ? 32 : 0) : 1)  				: (w < 1 << 2 ? 2 : 3)) : (w < 1 << 5  				? (w < 1 << 4 ? 4 : 5)  				: (w < 1 << 6 ? 6 : 7)))  				: (w < 1 << 11  				? (w < 1 << 9 ? (w < 1 << 8 ? 8 : 9) : (w < 1 << 10 ? 10 : 11))  				: (w < 1 << 13 ? (w < 1 << 12 ? 12 : 13) : (w < 1 << 14 ? 14 : 15)))) : (w < 1 << 23 ? (w < 1 << 19  				? (w < 1 << 17 ? (w < 1 << 16 ? 16 : 17) : (w < 1 << 18 ? 18 : 19))  				: (w < 1 << 21 ? (w < 1 << 20 ? 20 : 21) : (w < 1 << 22 ? 22 : 23))) : (w < 1 << 27  				? (w < 1 << 25 ? (w < 1 << 24 ? 24 : 25) : (w < 1 << 26 ? 26 : 27))  				: (w < 1 << 29 ? (w < 1 << 28 ? 28 : 29) : (w < 1 << 30 ? 30 : 31)))));
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,BitLen,The following statement contains a magic number: return (w < 1 << 15 ? (w < 1 << 7  				? (w < 1 << 3 ? (w < 1 << 1  				? (w < 1 << 0 ? (w < 0 ? 32 : 0) : 1)  				: (w < 1 << 2 ? 2 : 3)) : (w < 1 << 5  				? (w < 1 << 4 ? 4 : 5)  				: (w < 1 << 6 ? 6 : 7)))  				: (w < 1 << 11  				? (w < 1 << 9 ? (w < 1 << 8 ? 8 : 9) : (w < 1 << 10 ? 10 : 11))  				: (w < 1 << 13 ? (w < 1 << 12 ? 12 : 13) : (w < 1 << 14 ? 14 : 15)))) : (w < 1 << 23 ? (w < 1 << 19  				? (w < 1 << 17 ? (w < 1 << 16 ? 16 : 17) : (w < 1 << 18 ? 18 : 19))  				: (w < 1 << 21 ? (w < 1 << 20 ? 20 : 21) : (w < 1 << 22 ? 22 : 23))) : (w < 1 << 27  				? (w < 1 << 25 ? (w < 1 << 24 ? 24 : 25) : (w < 1 << 26 ? 26 : 27))  				: (w < 1 << 29 ? (w < 1 << 28 ? 28 : 29) : (w < 1 << 30 ? 30 : 31)))));
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,BitLen,The following statement contains a magic number: return (w < 1 << 15 ? (w < 1 << 7  				? (w < 1 << 3 ? (w < 1 << 1  				? (w < 1 << 0 ? (w < 0 ? 32 : 0) : 1)  				: (w < 1 << 2 ? 2 : 3)) : (w < 1 << 5  				? (w < 1 << 4 ? 4 : 5)  				: (w < 1 << 6 ? 6 : 7)))  				: (w < 1 << 11  				? (w < 1 << 9 ? (w < 1 << 8 ? 8 : 9) : (w < 1 << 10 ? 10 : 11))  				: (w < 1 << 13 ? (w < 1 << 12 ? 12 : 13) : (w < 1 << 14 ? 14 : 15)))) : (w < 1 << 23 ? (w < 1 << 19  				? (w < 1 << 17 ? (w < 1 << 16 ? 16 : 17) : (w < 1 << 18 ? 18 : 19))  				: (w < 1 << 21 ? (w < 1 << 20 ? 20 : 21) : (w < 1 << 22 ? 22 : 23))) : (w < 1 << 27  				? (w < 1 << 25 ? (w < 1 << 24 ? 24 : 25) : (w < 1 << 26 ? 26 : 27))  				: (w < 1 << 29 ? (w < 1 << 28 ? 28 : 29) : (w < 1 << 30 ? 30 : 31)))));
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,BitLen,The following statement contains a magic number: return (w < 1 << 15 ? (w < 1 << 7  				? (w < 1 << 3 ? (w < 1 << 1  				? (w < 1 << 0 ? (w < 0 ? 32 : 0) : 1)  				: (w < 1 << 2 ? 2 : 3)) : (w < 1 << 5  				? (w < 1 << 4 ? 4 : 5)  				: (w < 1 << 6 ? 6 : 7)))  				: (w < 1 << 11  				? (w < 1 << 9 ? (w < 1 << 8 ? 8 : 9) : (w < 1 << 10 ? 10 : 11))  				: (w < 1 << 13 ? (w < 1 << 12 ? 12 : 13) : (w < 1 << 14 ? 14 : 15)))) : (w < 1 << 23 ? (w < 1 << 19  				? (w < 1 << 17 ? (w < 1 << 16 ? 16 : 17) : (w < 1 << 18 ? 18 : 19))  				: (w < 1 << 21 ? (w < 1 << 20 ? 20 : 21) : (w < 1 << 22 ? 22 : 23))) : (w < 1 << 27  				? (w < 1 << 25 ? (w < 1 << 24 ? 24 : 25) : (w < 1 << 26 ? 26 : 27))  				: (w < 1 << 29 ? (w < 1 << 28 ? 28 : 29) : (w < 1 << 30 ? 30 : 31)))));
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,BitLen,The following statement contains a magic number: return (w < 1 << 15 ? (w < 1 << 7  				? (w < 1 << 3 ? (w < 1 << 1  				? (w < 1 << 0 ? (w < 0 ? 32 : 0) : 1)  				: (w < 1 << 2 ? 2 : 3)) : (w < 1 << 5  				? (w < 1 << 4 ? 4 : 5)  				: (w < 1 << 6 ? 6 : 7)))  				: (w < 1 << 11  				? (w < 1 << 9 ? (w < 1 << 8 ? 8 : 9) : (w < 1 << 10 ? 10 : 11))  				: (w < 1 << 13 ? (w < 1 << 12 ? 12 : 13) : (w < 1 << 14 ? 14 : 15)))) : (w < 1 << 23 ? (w < 1 << 19  				? (w < 1 << 17 ? (w < 1 << 16 ? 16 : 17) : (w < 1 << 18 ? 18 : 19))  				: (w < 1 << 21 ? (w < 1 << 20 ? 20 : 21) : (w < 1 << 22 ? 22 : 23))) : (w < 1 << 27  				? (w < 1 << 25 ? (w < 1 << 24 ? 24 : 25) : (w < 1 << 26 ? 26 : 27))  				: (w < 1 << 29 ? (w < 1 << 28 ? 28 : 29) : (w < 1 << 30 ? 30 : 31)))));
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,BitLen,The following statement contains a magic number: return (w < 1 << 15 ? (w < 1 << 7  				? (w < 1 << 3 ? (w < 1 << 1  				? (w < 1 << 0 ? (w < 0 ? 32 : 0) : 1)  				: (w < 1 << 2 ? 2 : 3)) : (w < 1 << 5  				? (w < 1 << 4 ? 4 : 5)  				: (w < 1 << 6 ? 6 : 7)))  				: (w < 1 << 11  				? (w < 1 << 9 ? (w < 1 << 8 ? 8 : 9) : (w < 1 << 10 ? 10 : 11))  				: (w < 1 << 13 ? (w < 1 << 12 ? 12 : 13) : (w < 1 << 14 ? 14 : 15)))) : (w < 1 << 23 ? (w < 1 << 19  				? (w < 1 << 17 ? (w < 1 << 16 ? 16 : 17) : (w < 1 << 18 ? 18 : 19))  				: (w < 1 << 21 ? (w < 1 << 20 ? 20 : 21) : (w < 1 << 22 ? 22 : 23))) : (w < 1 << 27  				? (w < 1 << 25 ? (w < 1 << 24 ? 24 : 25) : (w < 1 << 26 ? 26 : 27))  				: (w < 1 << 29 ? (w < 1 << 28 ? 28 : 29) : (w < 1 << 30 ? 30 : 31)))));
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,BitLen,The following statement contains a magic number: return (w < 1 << 15 ? (w < 1 << 7  				? (w < 1 << 3 ? (w < 1 << 1  				? (w < 1 << 0 ? (w < 0 ? 32 : 0) : 1)  				: (w < 1 << 2 ? 2 : 3)) : (w < 1 << 5  				? (w < 1 << 4 ? 4 : 5)  				: (w < 1 << 6 ? 6 : 7)))  				: (w < 1 << 11  				? (w < 1 << 9 ? (w < 1 << 8 ? 8 : 9) : (w < 1 << 10 ? 10 : 11))  				: (w < 1 << 13 ? (w < 1 << 12 ? 12 : 13) : (w < 1 << 14 ? 14 : 15)))) : (w < 1 << 23 ? (w < 1 << 19  				? (w < 1 << 17 ? (w < 1 << 16 ? 16 : 17) : (w < 1 << 18 ? 18 : 19))  				: (w < 1 << 21 ? (w < 1 << 20 ? 20 : 21) : (w < 1 << 22 ? 22 : 23))) : (w < 1 << 27  				? (w < 1 << 25 ? (w < 1 << 24 ? 24 : 25) : (w < 1 << 26 ? 26 : 27))  				: (w < 1 << 29 ? (w < 1 << 28 ? 28 : 29) : (w < 1 << 30 ? 30 : 31)))));
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,BitLen,The following statement contains a magic number: return (w < 1 << 15 ? (w < 1 << 7  				? (w < 1 << 3 ? (w < 1 << 1  				? (w < 1 << 0 ? (w < 0 ? 32 : 0) : 1)  				: (w < 1 << 2 ? 2 : 3)) : (w < 1 << 5  				? (w < 1 << 4 ? 4 : 5)  				: (w < 1 << 6 ? 6 : 7)))  				: (w < 1 << 11  				? (w < 1 << 9 ? (w < 1 << 8 ? 8 : 9) : (w < 1 << 10 ? 10 : 11))  				: (w < 1 << 13 ? (w < 1 << 12 ? 12 : 13) : (w < 1 << 14 ? 14 : 15)))) : (w < 1 << 23 ? (w < 1 << 19  				? (w < 1 << 17 ? (w < 1 << 16 ? 16 : 17) : (w < 1 << 18 ? 18 : 19))  				: (w < 1 << 21 ? (w < 1 << 20 ? 20 : 21) : (w < 1 << 22 ? 22 : 23))) : (w < 1 << 27  				? (w < 1 << 25 ? (w < 1 << 24 ? 24 : 25) : (w < 1 << 26 ? 26 : 27))  				: (w < 1 << 29 ? (w < 1 << 28 ? 28 : 29) : (w < 1 << 30 ? 30 : 31)))));
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,BitLen,The following statement contains a magic number: return (w < 1 << 15 ? (w < 1 << 7  				? (w < 1 << 3 ? (w < 1 << 1  				? (w < 1 << 0 ? (w < 0 ? 32 : 0) : 1)  				: (w < 1 << 2 ? 2 : 3)) : (w < 1 << 5  				? (w < 1 << 4 ? 4 : 5)  				: (w < 1 << 6 ? 6 : 7)))  				: (w < 1 << 11  				? (w < 1 << 9 ? (w < 1 << 8 ? 8 : 9) : (w < 1 << 10 ? 10 : 11))  				: (w < 1 << 13 ? (w < 1 << 12 ? 12 : 13) : (w < 1 << 14 ? 14 : 15)))) : (w < 1 << 23 ? (w < 1 << 19  				? (w < 1 << 17 ? (w < 1 << 16 ? 16 : 17) : (w < 1 << 18 ? 18 : 19))  				: (w < 1 << 21 ? (w < 1 << 20 ? 20 : 21) : (w < 1 << 22 ? 22 : 23))) : (w < 1 << 27  				? (w < 1 << 25 ? (w < 1 << 24 ? 24 : 25) : (w < 1 << 26 ? 26 : 27))  				: (w < 1 << 29 ? (w < 1 << 28 ? 28 : 29) : (w < 1 << 30 ? 30 : 31)))));
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,BitLen,The following statement contains a magic number: return (w < 1 << 15 ? (w < 1 << 7  				? (w < 1 << 3 ? (w < 1 << 1  				? (w < 1 << 0 ? (w < 0 ? 32 : 0) : 1)  				: (w < 1 << 2 ? 2 : 3)) : (w < 1 << 5  				? (w < 1 << 4 ? 4 : 5)  				: (w < 1 << 6 ? 6 : 7)))  				: (w < 1 << 11  				? (w < 1 << 9 ? (w < 1 << 8 ? 8 : 9) : (w < 1 << 10 ? 10 : 11))  				: (w < 1 << 13 ? (w < 1 << 12 ? 12 : 13) : (w < 1 << 14 ? 14 : 15)))) : (w < 1 << 23 ? (w < 1 << 19  				? (w < 1 << 17 ? (w < 1 << 16 ? 16 : 17) : (w < 1 << 18 ? 18 : 19))  				: (w < 1 << 21 ? (w < 1 << 20 ? 20 : 21) : (w < 1 << 22 ? 22 : 23))) : (w < 1 << 27  				? (w < 1 << 25 ? (w < 1 << 24 ? 24 : 25) : (w < 1 << 26 ? 26 : 27))  				: (w < 1 << 29 ? (w < 1 << 28 ? 28 : 29) : (w < 1 << 30 ? 30 : 31)))));
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,BitLen,The following statement contains a magic number: return (w < 1 << 15 ? (w < 1 << 7  				? (w < 1 << 3 ? (w < 1 << 1  				? (w < 1 << 0 ? (w < 0 ? 32 : 0) : 1)  				: (w < 1 << 2 ? 2 : 3)) : (w < 1 << 5  				? (w < 1 << 4 ? 4 : 5)  				: (w < 1 << 6 ? 6 : 7)))  				: (w < 1 << 11  				? (w < 1 << 9 ? (w < 1 << 8 ? 8 : 9) : (w < 1 << 10 ? 10 : 11))  				: (w < 1 << 13 ? (w < 1 << 12 ? 12 : 13) : (w < 1 << 14 ? 14 : 15)))) : (w < 1 << 23 ? (w < 1 << 19  				? (w < 1 << 17 ? (w < 1 << 16 ? 16 : 17) : (w < 1 << 18 ? 18 : 19))  				: (w < 1 << 21 ? (w < 1 << 20 ? 20 : 21) : (w < 1 << 22 ? 22 : 23))) : (w < 1 << 27  				? (w < 1 << 25 ? (w < 1 << 24 ? 24 : 25) : (w < 1 << 26 ? 26 : 27))  				: (w < 1 << 29 ? (w < 1 << 28 ? 28 : 29) : (w < 1 << 30 ? 30 : 31)))));
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,BitLen,The following statement contains a magic number: return (w < 1 << 15 ? (w < 1 << 7  				? (w < 1 << 3 ? (w < 1 << 1  				? (w < 1 << 0 ? (w < 0 ? 32 : 0) : 1)  				: (w < 1 << 2 ? 2 : 3)) : (w < 1 << 5  				? (w < 1 << 4 ? 4 : 5)  				: (w < 1 << 6 ? 6 : 7)))  				: (w < 1 << 11  				? (w < 1 << 9 ? (w < 1 << 8 ? 8 : 9) : (w < 1 << 10 ? 10 : 11))  				: (w < 1 << 13 ? (w < 1 << 12 ? 12 : 13) : (w < 1 << 14 ? 14 : 15)))) : (w < 1 << 23 ? (w < 1 << 19  				? (w < 1 << 17 ? (w < 1 << 16 ? 16 : 17) : (w < 1 << 18 ? 18 : 19))  				: (w < 1 << 21 ? (w < 1 << 20 ? 20 : 21) : (w < 1 << 22 ? 22 : 23))) : (w < 1 << 27  				? (w < 1 << 25 ? (w < 1 << 24 ? 24 : 25) : (w < 1 << 26 ? 26 : 27))  				: (w < 1 << 29 ? (w < 1 << 28 ? 28 : 29) : (w < 1 << 30 ? 30 : 31)))));
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,BitLen,The following statement contains a magic number: return (w < 1 << 15 ? (w < 1 << 7  				? (w < 1 << 3 ? (w < 1 << 1  				? (w < 1 << 0 ? (w < 0 ? 32 : 0) : 1)  				: (w < 1 << 2 ? 2 : 3)) : (w < 1 << 5  				? (w < 1 << 4 ? 4 : 5)  				: (w < 1 << 6 ? 6 : 7)))  				: (w < 1 << 11  				? (w < 1 << 9 ? (w < 1 << 8 ? 8 : 9) : (w < 1 << 10 ? 10 : 11))  				: (w < 1 << 13 ? (w < 1 << 12 ? 12 : 13) : (w < 1 << 14 ? 14 : 15)))) : (w < 1 << 23 ? (w < 1 << 19  				? (w < 1 << 17 ? (w < 1 << 16 ? 16 : 17) : (w < 1 << 18 ? 18 : 19))  				: (w < 1 << 21 ? (w < 1 << 20 ? 20 : 21) : (w < 1 << 22 ? 22 : 23))) : (w < 1 << 27  				? (w < 1 << 25 ? (w < 1 << 24 ? 24 : 25) : (w < 1 << 26 ? 26 : 27))  				: (w < 1 << 29 ? (w < 1 << 28 ? 28 : 29) : (w < 1 << 30 ? 30 : 31)))));
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,BitLen,The following statement contains a magic number: return (w < 1 << 15 ? (w < 1 << 7  				? (w < 1 << 3 ? (w < 1 << 1  				? (w < 1 << 0 ? (w < 0 ? 32 : 0) : 1)  				: (w < 1 << 2 ? 2 : 3)) : (w < 1 << 5  				? (w < 1 << 4 ? 4 : 5)  				: (w < 1 << 6 ? 6 : 7)))  				: (w < 1 << 11  				? (w < 1 << 9 ? (w < 1 << 8 ? 8 : 9) : (w < 1 << 10 ? 10 : 11))  				: (w < 1 << 13 ? (w < 1 << 12 ? 12 : 13) : (w < 1 << 14 ? 14 : 15)))) : (w < 1 << 23 ? (w < 1 << 19  				? (w < 1 << 17 ? (w < 1 << 16 ? 16 : 17) : (w < 1 << 18 ? 18 : 19))  				: (w < 1 << 21 ? (w < 1 << 20 ? 20 : 21) : (w < 1 << 22 ? 22 : 23))) : (w < 1 << 27  				? (w < 1 << 25 ? (w < 1 << 24 ? 24 : 25) : (w < 1 << 26 ? 26 : 27))  				: (w < 1 << 29 ? (w < 1 << 28 ? 28 : 29) : (w < 1 << 30 ? 30 : 31)))));
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,BitLen,The following statement contains a magic number: return (w < 1 << 15 ? (w < 1 << 7  				? (w < 1 << 3 ? (w < 1 << 1  				? (w < 1 << 0 ? (w < 0 ? 32 : 0) : 1)  				: (w < 1 << 2 ? 2 : 3)) : (w < 1 << 5  				? (w < 1 << 4 ? 4 : 5)  				: (w < 1 << 6 ? 6 : 7)))  				: (w < 1 << 11  				? (w < 1 << 9 ? (w < 1 << 8 ? 8 : 9) : (w < 1 << 10 ? 10 : 11))  				: (w < 1 << 13 ? (w < 1 << 12 ? 12 : 13) : (w < 1 << 14 ? 14 : 15)))) : (w < 1 << 23 ? (w < 1 << 19  				? (w < 1 << 17 ? (w < 1 << 16 ? 16 : 17) : (w < 1 << 18 ? 18 : 19))  				: (w < 1 << 21 ? (w < 1 << 20 ? 20 : 21) : (w < 1 << 22 ? 22 : 23))) : (w < 1 << 27  				? (w < 1 << 25 ? (w < 1 << 24 ? 24 : 25) : (w < 1 << 26 ? 26 : 27))  				: (w < 1 << 29 ? (w < 1 << 28 ? 28 : 29) : (w < 1 << 30 ? 30 : 31)))));
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,BitLen,The following statement contains a magic number: return (w < 1 << 15 ? (w < 1 << 7  				? (w < 1 << 3 ? (w < 1 << 1  				? (w < 1 << 0 ? (w < 0 ? 32 : 0) : 1)  				: (w < 1 << 2 ? 2 : 3)) : (w < 1 << 5  				? (w < 1 << 4 ? 4 : 5)  				: (w < 1 << 6 ? 6 : 7)))  				: (w < 1 << 11  				? (w < 1 << 9 ? (w < 1 << 8 ? 8 : 9) : (w < 1 << 10 ? 10 : 11))  				: (w < 1 << 13 ? (w < 1 << 12 ? 12 : 13) : (w < 1 << 14 ? 14 : 15)))) : (w < 1 << 23 ? (w < 1 << 19  				? (w < 1 << 17 ? (w < 1 << 16 ? 16 : 17) : (w < 1 << 18 ? 18 : 19))  				: (w < 1 << 21 ? (w < 1 << 20 ? 20 : 21) : (w < 1 << 22 ? 22 : 23))) : (w < 1 << 27  				? (w < 1 << 25 ? (w < 1 << 24 ? 24 : 25) : (w < 1 << 26 ? 26 : 27))  				: (w < 1 << 29 ? (w < 1 << 28 ? 28 : 29) : (w < 1 << 30 ? 30 : 31)))));
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,BitLen,The following statement contains a magic number: return (w < 1 << 15 ? (w < 1 << 7  				? (w < 1 << 3 ? (w < 1 << 1  				? (w < 1 << 0 ? (w < 0 ? 32 : 0) : 1)  				: (w < 1 << 2 ? 2 : 3)) : (w < 1 << 5  				? (w < 1 << 4 ? 4 : 5)  				: (w < 1 << 6 ? 6 : 7)))  				: (w < 1 << 11  				? (w < 1 << 9 ? (w < 1 << 8 ? 8 : 9) : (w < 1 << 10 ? 10 : 11))  				: (w < 1 << 13 ? (w < 1 << 12 ? 12 : 13) : (w < 1 << 14 ? 14 : 15)))) : (w < 1 << 23 ? (w < 1 << 19  				? (w < 1 << 17 ? (w < 1 << 16 ? 16 : 17) : (w < 1 << 18 ? 18 : 19))  				: (w < 1 << 21 ? (w < 1 << 20 ? 20 : 21) : (w < 1 << 22 ? 22 : 23))) : (w < 1 << 27  				? (w < 1 << 25 ? (w < 1 << 24 ? 24 : 25) : (w < 1 << 26 ? 26 : 27))  				: (w < 1 << 29 ? (w < 1 << 28 ? 28 : 29) : (w < 1 << 30 ? 30 : 31)))));
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,BitLen,The following statement contains a magic number: return (w < 1 << 15 ? (w < 1 << 7  				? (w < 1 << 3 ? (w < 1 << 1  				? (w < 1 << 0 ? (w < 0 ? 32 : 0) : 1)  				: (w < 1 << 2 ? 2 : 3)) : (w < 1 << 5  				? (w < 1 << 4 ? 4 : 5)  				: (w < 1 << 6 ? 6 : 7)))  				: (w < 1 << 11  				? (w < 1 << 9 ? (w < 1 << 8 ? 8 : 9) : (w < 1 << 10 ? 10 : 11))  				: (w < 1 << 13 ? (w < 1 << 12 ? 12 : 13) : (w < 1 << 14 ? 14 : 15)))) : (w < 1 << 23 ? (w < 1 << 19  				? (w < 1 << 17 ? (w < 1 << 16 ? 16 : 17) : (w < 1 << 18 ? 18 : 19))  				: (w < 1 << 21 ? (w < 1 << 20 ? 20 : 21) : (w < 1 << 22 ? 22 : 23))) : (w < 1 << 27  				? (w < 1 << 25 ? (w < 1 << 24 ? 24 : 25) : (w < 1 << 26 ? 26 : 27))  				: (w < 1 << 29 ? (w < 1 << 28 ? 28 : 29) : (w < 1 << 30 ? 30 : 31)))));
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,Divide,The following statement contains a magic number: if (xyCmp > 0)  			{  				int yBitLength = calcBitLength(yStart' y);  				int xBitLength = calcBitLength(xStart' x);  				int shift = xBitLength - yBitLength;    				int[] iCount;  				int iCountStart = 0;    				int[] c;  				int cStart = 0;  				int cBitLength = yBitLength;  				if (shift > 0)  				{  					//					iCount = ShiftLeft(One.magnitude' shift);  					iCount = new int[(shift >> 5) + 1];  					iCount[0] = 1 << (shift % 32);    					c = ShiftLeft(y' shift);  					cBitLength += shift;  				}  				else  				{  					iCount = new int[] { 1 };    					int len = y.Length - yStart;  					c = new int[len];  					Array.Copy(y' yStart' c' 0' len);  				}    				count = new int[iCount.Length];    				for (; ; )  				{  					if (cBitLength < xBitLength  						|| CompareNoLeadingZeroes(xStart' x' cStart' c) >= 0)  					{  						Subtract(xStart' x' cStart' c);  						AddMagnitudes(count' iCount);    						while (x[xStart] == 0)  						{  							if (++xStart == x.Length)  								return count;  						}    						//xBitLength = calcBitLength(xStart' x);  						xBitLength = 32 * (x.Length - xStart - 1) + BitLen(x[xStart]);    						if (xBitLength <= yBitLength)  						{  							if (xBitLength < yBitLength)  								return count;    							xyCmp = CompareNoLeadingZeroes(xStart' x' yStart' y);    							if (xyCmp <= 0)  								break;  						}  					}    					shift = cBitLength - xBitLength;    					// NB: The case where c[cStart] is 1-bit is harmless  					if (shift == 1)  					{  						uint firstC = (uint)c[cStart] >> 1;  						uint firstX = (uint)x[xStart];  						if (firstC > firstX)  							++shift;  					}    					if (shift < 2)  					{  						c = ShiftRightOneInPlace(cStart' c);  						--cBitLength;  						iCount = ShiftRightOneInPlace(iCountStart' iCount);  					}  					else  					{  						c = ShiftRightInPlace(cStart' c' shift);  						cBitLength -= shift;  						iCount = ShiftRightInPlace(iCountStart' iCount' shift);  					}    					//cStart = c.Length - ((cBitLength + 31) / 32);  					while (c[cStart] == 0)  					{  						++cStart;  					}    					while (iCount[iCountStart] == 0)  					{  						++iCountStart;  					}  				}  			}  			else  			{  				count = new int[1];  			}
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,Divide,The following statement contains a magic number: if (xyCmp > 0)  			{  				int yBitLength = calcBitLength(yStart' y);  				int xBitLength = calcBitLength(xStart' x);  				int shift = xBitLength - yBitLength;    				int[] iCount;  				int iCountStart = 0;    				int[] c;  				int cStart = 0;  				int cBitLength = yBitLength;  				if (shift > 0)  				{  					//					iCount = ShiftLeft(One.magnitude' shift);  					iCount = new int[(shift >> 5) + 1];  					iCount[0] = 1 << (shift % 32);    					c = ShiftLeft(y' shift);  					cBitLength += shift;  				}  				else  				{  					iCount = new int[] { 1 };    					int len = y.Length - yStart;  					c = new int[len];  					Array.Copy(y' yStart' c' 0' len);  				}    				count = new int[iCount.Length];    				for (; ; )  				{  					if (cBitLength < xBitLength  						|| CompareNoLeadingZeroes(xStart' x' cStart' c) >= 0)  					{  						Subtract(xStart' x' cStart' c);  						AddMagnitudes(count' iCount);    						while (x[xStart] == 0)  						{  							if (++xStart == x.Length)  								return count;  						}    						//xBitLength = calcBitLength(xStart' x);  						xBitLength = 32 * (x.Length - xStart - 1) + BitLen(x[xStart]);    						if (xBitLength <= yBitLength)  						{  							if (xBitLength < yBitLength)  								return count;    							xyCmp = CompareNoLeadingZeroes(xStart' x' yStart' y);    							if (xyCmp <= 0)  								break;  						}  					}    					shift = cBitLength - xBitLength;    					// NB: The case where c[cStart] is 1-bit is harmless  					if (shift == 1)  					{  						uint firstC = (uint)c[cStart] >> 1;  						uint firstX = (uint)x[xStart];  						if (firstC > firstX)  							++shift;  					}    					if (shift < 2)  					{  						c = ShiftRightOneInPlace(cStart' c);  						--cBitLength;  						iCount = ShiftRightOneInPlace(iCountStart' iCount);  					}  					else  					{  						c = ShiftRightInPlace(cStart' c' shift);  						cBitLength -= shift;  						iCount = ShiftRightInPlace(iCountStart' iCount' shift);  					}    					//cStart = c.Length - ((cBitLength + 31) / 32);  					while (c[cStart] == 0)  					{  						++cStart;  					}    					while (iCount[iCountStart] == 0)  					{  						++iCountStart;  					}  				}  			}  			else  			{  				count = new int[1];  			}
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,Divide,The following statement contains a magic number: if (xyCmp > 0)  			{  				int yBitLength = calcBitLength(yStart' y);  				int xBitLength = calcBitLength(xStart' x);  				int shift = xBitLength - yBitLength;    				int[] iCount;  				int iCountStart = 0;    				int[] c;  				int cStart = 0;  				int cBitLength = yBitLength;  				if (shift > 0)  				{  					//					iCount = ShiftLeft(One.magnitude' shift);  					iCount = new int[(shift >> 5) + 1];  					iCount[0] = 1 << (shift % 32);    					c = ShiftLeft(y' shift);  					cBitLength += shift;  				}  				else  				{  					iCount = new int[] { 1 };    					int len = y.Length - yStart;  					c = new int[len];  					Array.Copy(y' yStart' c' 0' len);  				}    				count = new int[iCount.Length];    				for (; ; )  				{  					if (cBitLength < xBitLength  						|| CompareNoLeadingZeroes(xStart' x' cStart' c) >= 0)  					{  						Subtract(xStart' x' cStart' c);  						AddMagnitudes(count' iCount);    						while (x[xStart] == 0)  						{  							if (++xStart == x.Length)  								return count;  						}    						//xBitLength = calcBitLength(xStart' x);  						xBitLength = 32 * (x.Length - xStart - 1) + BitLen(x[xStart]);    						if (xBitLength <= yBitLength)  						{  							if (xBitLength < yBitLength)  								return count;    							xyCmp = CompareNoLeadingZeroes(xStart' x' yStart' y);    							if (xyCmp <= 0)  								break;  						}  					}    					shift = cBitLength - xBitLength;    					// NB: The case where c[cStart] is 1-bit is harmless  					if (shift == 1)  					{  						uint firstC = (uint)c[cStart] >> 1;  						uint firstX = (uint)x[xStart];  						if (firstC > firstX)  							++shift;  					}    					if (shift < 2)  					{  						c = ShiftRightOneInPlace(cStart' c);  						--cBitLength;  						iCount = ShiftRightOneInPlace(iCountStart' iCount);  					}  					else  					{  						c = ShiftRightInPlace(cStart' c' shift);  						cBitLength -= shift;  						iCount = ShiftRightInPlace(iCountStart' iCount' shift);  					}    					//cStart = c.Length - ((cBitLength + 31) / 32);  					while (c[cStart] == 0)  					{  						++cStart;  					}    					while (iCount[iCountStart] == 0)  					{  						++iCountStart;  					}  				}  			}  			else  			{  				count = new int[1];  			}
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,Divide,The following statement contains a magic number: if (xyCmp > 0)  			{  				int yBitLength = calcBitLength(yStart' y);  				int xBitLength = calcBitLength(xStart' x);  				int shift = xBitLength - yBitLength;    				int[] iCount;  				int iCountStart = 0;    				int[] c;  				int cStart = 0;  				int cBitLength = yBitLength;  				if (shift > 0)  				{  					//					iCount = ShiftLeft(One.magnitude' shift);  					iCount = new int[(shift >> 5) + 1];  					iCount[0] = 1 << (shift % 32);    					c = ShiftLeft(y' shift);  					cBitLength += shift;  				}  				else  				{  					iCount = new int[] { 1 };    					int len = y.Length - yStart;  					c = new int[len];  					Array.Copy(y' yStart' c' 0' len);  				}    				count = new int[iCount.Length];    				for (; ; )  				{  					if (cBitLength < xBitLength  						|| CompareNoLeadingZeroes(xStart' x' cStart' c) >= 0)  					{  						Subtract(xStart' x' cStart' c);  						AddMagnitudes(count' iCount);    						while (x[xStart] == 0)  						{  							if (++xStart == x.Length)  								return count;  						}    						//xBitLength = calcBitLength(xStart' x);  						xBitLength = 32 * (x.Length - xStart - 1) + BitLen(x[xStart]);    						if (xBitLength <= yBitLength)  						{  							if (xBitLength < yBitLength)  								return count;    							xyCmp = CompareNoLeadingZeroes(xStart' x' yStart' y);    							if (xyCmp <= 0)  								break;  						}  					}    					shift = cBitLength - xBitLength;    					// NB: The case where c[cStart] is 1-bit is harmless  					if (shift == 1)  					{  						uint firstC = (uint)c[cStart] >> 1;  						uint firstX = (uint)x[xStart];  						if (firstC > firstX)  							++shift;  					}    					if (shift < 2)  					{  						c = ShiftRightOneInPlace(cStart' c);  						--cBitLength;  						iCount = ShiftRightOneInPlace(iCountStart' iCount);  					}  					else  					{  						c = ShiftRightInPlace(cStart' c' shift);  						cBitLength -= shift;  						iCount = ShiftRightInPlace(iCountStart' iCount' shift);  					}    					//cStart = c.Length - ((cBitLength + 31) / 32);  					while (c[cStart] == 0)  					{  						++cStart;  					}    					while (iCount[iCountStart] == 0)  					{  						++iCountStart;  					}  				}  			}  			else  			{  				count = new int[1];  			}
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,DivideAndRemainder,The following statement contains a magic number: NetBigInteger[] biggies = new NetBigInteger[2];
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,ModPow,The following statement contains a magic number: if (useMonty)  			{  				mQ = m.GetMQuote();    				// tmp = this * R mod m  				NetBigInteger tmp = ShiftLeft(32 * m.m_magnitude.Length).Mod(m);  				zVal = tmp.m_magnitude;    				useMonty = (zVal.Length <= m.m_magnitude.Length);    				if (useMonty)  				{  					yAccum = new int[m.m_magnitude.Length + 1];  					if (zVal.Length < m.m_magnitude.Length)  					{  						int[] longZ = new int[m.m_magnitude.Length];  						zVal.CopyTo(longZ' longZ.Length - zVal.Length);  						zVal = longZ;  					}  				}  			}
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,ModPow,The following statement contains a magic number: if (!useMonty)  			{  				if (m_magnitude.Length <= m.m_magnitude.Length)  				{  					//zAccum = new int[m.magnitude.Length * 2];  					zVal = new int[m.m_magnitude.Length];  					m_magnitude.CopyTo(zVal' zVal.Length - m_magnitude.Length);  				}  				else  				{  					//  					// in normal practice we'll never see ..  					//  					NetBigInteger tmp = Remainder(m);    					//zAccum = new int[m.magnitude.Length * 2];  					zVal = new int[m.m_magnitude.Length];  					tmp.m_magnitude.CopyTo(zVal' zVal.Length - tmp.m_magnitude.Length);  				}    				yAccum = new int[m.m_magnitude.Length * 2];  			}
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,ModPow,The following statement contains a magic number: for (int i = 0; i < exponent.m_magnitude.Length; i++)  			{  				int v = exponent.m_magnitude[i];  				int bits = 0;    				if (i == 0)  				{  					while (v > 0)  					{  						v <<= 1;  						bits++;  					}    					//  					// first time in initialise y  					//  					zVal.CopyTo(yVal' 0);    					v <<= 1;  					bits++;  				}    				while (v != 0)  				{  					if (useMonty)  					{  						// Montgomery square algo doesn't exist' and a normal  						// square followed by a Montgomery reduction proved to  						// be almost as heavy as a Montgomery mulitply.  						MultiplyMonty(yAccum' yVal' yVal' m.m_magnitude' mQ);  					}  					else  					{  						Square(yAccum' yVal);  						Remainder(yAccum' m.m_magnitude);  						Array.Copy(yAccum' yAccum.Length - yVal.Length' yVal' 0' yVal.Length);  						ZeroOut(yAccum);  					}  					bits++;    					if (v < 0)  					{  						if (useMonty)  						{  							MultiplyMonty(yAccum' yVal' zVal' m.m_magnitude' mQ);  						}  						else  						{  							Multiply(yAccum' yVal' zVal);  							Remainder(yAccum' m.m_magnitude);  							Array.Copy(yAccum' yAccum.Length - yVal.Length' yVal' 0'  								yVal.Length);  							ZeroOut(yAccum);  						}  					}    					v <<= 1;  				}    				while (bits < 32)  				{  					if (useMonty)  					{  						MultiplyMonty(yAccum' yVal' yVal' m.m_magnitude' mQ);  					}  					else  					{  						Square(yAccum' yVal);  						Remainder(yAccum' m.m_magnitude);  						Array.Copy(yAccum' yAccum.Length - yVal.Length' yVal' 0' yVal.Length);  						ZeroOut(yAccum);  					}  					bits++;  				}  			}
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,Square,The following statement contains a magic number: for (int i = x.Length - 1; i != 0; i--)  			{  				ulong v = (ulong)(uint)x[i];    				u1 = v * v;  				u2 = u1 >> 32;  				u1 = (uint)u1;    				u1 += (ulong)(uint)w[wBase];    				w[wBase] = (int)(uint)u1;  				c = u2 + (u1 >> 32);    				for (int j = i - 1; j >= 0; j--)  				{  					--wBase;  					u1 = v * (ulong)(uint)x[j];  					u2 = u1 >> 31; // multiply by 2!  					u1 = (uint)(u1 << 1); // multiply by 2!  					u1 += c + (ulong)(uint)w[wBase];    					w[wBase] = (int)(uint)u1;  					c = u2 + (u1 >> 32);  				}    				c += (ulong)(uint)w[--wBase];  				w[wBase] = (int)(uint)c;    				if (--wBase >= 0)  				{  					w[wBase] = (int)(uint)(c >> 32);  				}  				else  				{  					Debug.Assert((uint)(c >> 32) == 0);  				}  				wBase += i;  			}
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,Square,The following statement contains a magic number: for (int i = x.Length - 1; i != 0; i--)  			{  				ulong v = (ulong)(uint)x[i];    				u1 = v * v;  				u2 = u1 >> 32;  				u1 = (uint)u1;    				u1 += (ulong)(uint)w[wBase];    				w[wBase] = (int)(uint)u1;  				c = u2 + (u1 >> 32);    				for (int j = i - 1; j >= 0; j--)  				{  					--wBase;  					u1 = v * (ulong)(uint)x[j];  					u2 = u1 >> 31; // multiply by 2!  					u1 = (uint)(u1 << 1); // multiply by 2!  					u1 += c + (ulong)(uint)w[wBase];    					w[wBase] = (int)(uint)u1;  					c = u2 + (u1 >> 32);  				}    				c += (ulong)(uint)w[--wBase];  				w[wBase] = (int)(uint)c;    				if (--wBase >= 0)  				{  					w[wBase] = (int)(uint)(c >> 32);  				}  				else  				{  					Debug.Assert((uint)(c >> 32) == 0);  				}  				wBase += i;  			}
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,Square,The following statement contains a magic number: for (int i = x.Length - 1; i != 0; i--)  			{  				ulong v = (ulong)(uint)x[i];    				u1 = v * v;  				u2 = u1 >> 32;  				u1 = (uint)u1;    				u1 += (ulong)(uint)w[wBase];    				w[wBase] = (int)(uint)u1;  				c = u2 + (u1 >> 32);    				for (int j = i - 1; j >= 0; j--)  				{  					--wBase;  					u1 = v * (ulong)(uint)x[j];  					u2 = u1 >> 31; // multiply by 2!  					u1 = (uint)(u1 << 1); // multiply by 2!  					u1 += c + (ulong)(uint)w[wBase];    					w[wBase] = (int)(uint)u1;  					c = u2 + (u1 >> 32);  				}    				c += (ulong)(uint)w[--wBase];  				w[wBase] = (int)(uint)c;    				if (--wBase >= 0)  				{  					w[wBase] = (int)(uint)(c >> 32);  				}  				else  				{  					Debug.Assert((uint)(c >> 32) == 0);  				}  				wBase += i;  			}
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,Square,The following statement contains a magic number: for (int i = x.Length - 1; i != 0; i--)  			{  				ulong v = (ulong)(uint)x[i];    				u1 = v * v;  				u2 = u1 >> 32;  				u1 = (uint)u1;    				u1 += (ulong)(uint)w[wBase];    				w[wBase] = (int)(uint)u1;  				c = u2 + (u1 >> 32);    				for (int j = i - 1; j >= 0; j--)  				{  					--wBase;  					u1 = v * (ulong)(uint)x[j];  					u2 = u1 >> 31; // multiply by 2!  					u1 = (uint)(u1 << 1); // multiply by 2!  					u1 += c + (ulong)(uint)w[wBase];    					w[wBase] = (int)(uint)u1;  					c = u2 + (u1 >> 32);  				}    				c += (ulong)(uint)w[--wBase];  				w[wBase] = (int)(uint)c;    				if (--wBase >= 0)  				{  					w[wBase] = (int)(uint)(c >> 32);  				}  				else  				{  					Debug.Assert((uint)(c >> 32) == 0);  				}  				wBase += i;  			}
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,Square,The following statement contains a magic number: for (int i = x.Length - 1; i != 0; i--)  			{  				ulong v = (ulong)(uint)x[i];    				u1 = v * v;  				u2 = u1 >> 32;  				u1 = (uint)u1;    				u1 += (ulong)(uint)w[wBase];    				w[wBase] = (int)(uint)u1;  				c = u2 + (u1 >> 32);    				for (int j = i - 1; j >= 0; j--)  				{  					--wBase;  					u1 = v * (ulong)(uint)x[j];  					u2 = u1 >> 31; // multiply by 2!  					u1 = (uint)(u1 << 1); // multiply by 2!  					u1 += c + (ulong)(uint)w[wBase];    					w[wBase] = (int)(uint)u1;  					c = u2 + (u1 >> 32);  				}    				c += (ulong)(uint)w[--wBase];  				w[wBase] = (int)(uint)c;    				if (--wBase >= 0)  				{  					w[wBase] = (int)(uint)(c >> 32);  				}  				else  				{  					Debug.Assert((uint)(c >> 32) == 0);  				}  				wBase += i;  			}
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,Square,The following statement contains a magic number: for (int i = x.Length - 1; i != 0; i--)  			{  				ulong v = (ulong)(uint)x[i];    				u1 = v * v;  				u2 = u1 >> 32;  				u1 = (uint)u1;    				u1 += (ulong)(uint)w[wBase];    				w[wBase] = (int)(uint)u1;  				c = u2 + (u1 >> 32);    				for (int j = i - 1; j >= 0; j--)  				{  					--wBase;  					u1 = v * (ulong)(uint)x[j];  					u2 = u1 >> 31; // multiply by 2!  					u1 = (uint)(u1 << 1); // multiply by 2!  					u1 += c + (ulong)(uint)w[wBase];    					w[wBase] = (int)(uint)u1;  					c = u2 + (u1 >> 32);  				}    				c += (ulong)(uint)w[--wBase];  				w[wBase] = (int)(uint)c;    				if (--wBase >= 0)  				{  					w[wBase] = (int)(uint)(c >> 32);  				}  				else  				{  					Debug.Assert((uint)(c >> 32) == 0);  				}  				wBase += i;  			}
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,Square,The following statement contains a magic number: u2 = u1 >> 32;
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,Square,The following statement contains a magic number: if (--wBase >= 0)  			{  				w[wBase] = (int)(uint)(u2 + (u1 >> 32) + (ulong)(uint)w[wBase]);  			}  			else  			{  				Debug.Assert((uint)(u2 + (u1 >> 32)) == 0);  			}
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,Square,The following statement contains a magic number: if (--wBase >= 0)  			{  				w[wBase] = (int)(uint)(u2 + (u1 >> 32) + (ulong)(uint)w[wBase]);  			}  			else  			{  				Debug.Assert((uint)(u2 + (u1 >> 32)) == 0);  			}
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,Multiply,The following statement contains a magic number: for (; ; )  			{  				long a = z[--i] & IMASK;  				long val = 0;    				for (int j = y.Length - 1; j >= 0; j--)  				{  					val += a * (y[j] & IMASK) + (x[xBase + j] & IMASK);    					x[xBase + j] = (int)val;    					val = (long)((ulong)val >> 32);  				}    				--xBase;    				if (i < 1)  				{  					if (xBase >= 0)  					{  						x[xBase] = (int)val;  					}  					else  					{  						Debug.Assert(val == 0);  					}  					break;  				}    				x[xBase] = (int)val;  			}
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,FastModInverse,The following statement contains a magic number: long[] x = new long[2];
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,MultiplyMonty,The following statement contains a magic number: for (int i = n; i > 0; i--)  			{  				long x_i = x[i - 1] & IMASK;    				// 2.1 u = ((a[0] + (x[i] * y[0]) * mQuote) mod b  				long u = ((((a[n] & IMASK) + ((x_i * y_0) & IMASK)) & IMASK) * mQuote) & IMASK;    				// 2.2 a = (a + x_i * y + u * m) / b  				long prod1 = x_i * y_0;  				long prod2 = u * (m[nMinus1] & IMASK);  				long tmp = (a[n] & IMASK) + (prod1 & IMASK) + (prod2 & IMASK);  				long carry = (long)((ulong)prod1 >> 32) + (long)((ulong)prod2 >> 32) + (long)((ulong)tmp >> 32);  				for (int j = nMinus1; j > 0; j--)  				{  					prod1 = x_i * (y[j - 1] & IMASK);  					prod2 = u * (m[j - 1] & IMASK);  					tmp = (a[j] & IMASK) + (prod1 & IMASK) + (prod2 & IMASK) + (carry & IMASK);  					carry = (long)((ulong)carry >> 32) + (long)((ulong)prod1 >> 32) +  						(long)((ulong)prod2 >> 32) + (long)((ulong)tmp >> 32);  					a[j + 1] = (int)tmp; // division by b  				}  				carry += (a[0] & IMASK);  				a[1] = (int)carry;  				a[0] = (int)((ulong)carry >> 32); // OJO!!!!!  			}
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,MultiplyMonty,The following statement contains a magic number: for (int i = n; i > 0; i--)  			{  				long x_i = x[i - 1] & IMASK;    				// 2.1 u = ((a[0] + (x[i] * y[0]) * mQuote) mod b  				long u = ((((a[n] & IMASK) + ((x_i * y_0) & IMASK)) & IMASK) * mQuote) & IMASK;    				// 2.2 a = (a + x_i * y + u * m) / b  				long prod1 = x_i * y_0;  				long prod2 = u * (m[nMinus1] & IMASK);  				long tmp = (a[n] & IMASK) + (prod1 & IMASK) + (prod2 & IMASK);  				long carry = (long)((ulong)prod1 >> 32) + (long)((ulong)prod2 >> 32) + (long)((ulong)tmp >> 32);  				for (int j = nMinus1; j > 0; j--)  				{  					prod1 = x_i * (y[j - 1] & IMASK);  					prod2 = u * (m[j - 1] & IMASK);  					tmp = (a[j] & IMASK) + (prod1 & IMASK) + (prod2 & IMASK) + (carry & IMASK);  					carry = (long)((ulong)carry >> 32) + (long)((ulong)prod1 >> 32) +  						(long)((ulong)prod2 >> 32) + (long)((ulong)tmp >> 32);  					a[j + 1] = (int)tmp; // division by b  				}  				carry += (a[0] & IMASK);  				a[1] = (int)carry;  				a[0] = (int)((ulong)carry >> 32); // OJO!!!!!  			}
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,MultiplyMonty,The following statement contains a magic number: for (int i = n; i > 0; i--)  			{  				long x_i = x[i - 1] & IMASK;    				// 2.1 u = ((a[0] + (x[i] * y[0]) * mQuote) mod b  				long u = ((((a[n] & IMASK) + ((x_i * y_0) & IMASK)) & IMASK) * mQuote) & IMASK;    				// 2.2 a = (a + x_i * y + u * m) / b  				long prod1 = x_i * y_0;  				long prod2 = u * (m[nMinus1] & IMASK);  				long tmp = (a[n] & IMASK) + (prod1 & IMASK) + (prod2 & IMASK);  				long carry = (long)((ulong)prod1 >> 32) + (long)((ulong)prod2 >> 32) + (long)((ulong)tmp >> 32);  				for (int j = nMinus1; j > 0; j--)  				{  					prod1 = x_i * (y[j - 1] & IMASK);  					prod2 = u * (m[j - 1] & IMASK);  					tmp = (a[j] & IMASK) + (prod1 & IMASK) + (prod2 & IMASK) + (carry & IMASK);  					carry = (long)((ulong)carry >> 32) + (long)((ulong)prod1 >> 32) +  						(long)((ulong)prod2 >> 32) + (long)((ulong)tmp >> 32);  					a[j + 1] = (int)tmp; // division by b  				}  				carry += (a[0] & IMASK);  				a[1] = (int)carry;  				a[0] = (int)((ulong)carry >> 32); // OJO!!!!!  			}
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,MultiplyMonty,The following statement contains a magic number: for (int i = n; i > 0; i--)  			{  				long x_i = x[i - 1] & IMASK;    				// 2.1 u = ((a[0] + (x[i] * y[0]) * mQuote) mod b  				long u = ((((a[n] & IMASK) + ((x_i * y_0) & IMASK)) & IMASK) * mQuote) & IMASK;    				// 2.2 a = (a + x_i * y + u * m) / b  				long prod1 = x_i * y_0;  				long prod2 = u * (m[nMinus1] & IMASK);  				long tmp = (a[n] & IMASK) + (prod1 & IMASK) + (prod2 & IMASK);  				long carry = (long)((ulong)prod1 >> 32) + (long)((ulong)prod2 >> 32) + (long)((ulong)tmp >> 32);  				for (int j = nMinus1; j > 0; j--)  				{  					prod1 = x_i * (y[j - 1] & IMASK);  					prod2 = u * (m[j - 1] & IMASK);  					tmp = (a[j] & IMASK) + (prod1 & IMASK) + (prod2 & IMASK) + (carry & IMASK);  					carry = (long)((ulong)carry >> 32) + (long)((ulong)prod1 >> 32) +  						(long)((ulong)prod2 >> 32) + (long)((ulong)tmp >> 32);  					a[j + 1] = (int)tmp; // division by b  				}  				carry += (a[0] & IMASK);  				a[1] = (int)carry;  				a[0] = (int)((ulong)carry >> 32); // OJO!!!!!  			}
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,MultiplyMonty,The following statement contains a magic number: for (int i = n; i > 0; i--)  			{  				long x_i = x[i - 1] & IMASK;    				// 2.1 u = ((a[0] + (x[i] * y[0]) * mQuote) mod b  				long u = ((((a[n] & IMASK) + ((x_i * y_0) & IMASK)) & IMASK) * mQuote) & IMASK;    				// 2.2 a = (a + x_i * y + u * m) / b  				long prod1 = x_i * y_0;  				long prod2 = u * (m[nMinus1] & IMASK);  				long tmp = (a[n] & IMASK) + (prod1 & IMASK) + (prod2 & IMASK);  				long carry = (long)((ulong)prod1 >> 32) + (long)((ulong)prod2 >> 32) + (long)((ulong)tmp >> 32);  				for (int j = nMinus1; j > 0; j--)  				{  					prod1 = x_i * (y[j - 1] & IMASK);  					prod2 = u * (m[j - 1] & IMASK);  					tmp = (a[j] & IMASK) + (prod1 & IMASK) + (prod2 & IMASK) + (carry & IMASK);  					carry = (long)((ulong)carry >> 32) + (long)((ulong)prod1 >> 32) +  						(long)((ulong)prod2 >> 32) + (long)((ulong)tmp >> 32);  					a[j + 1] = (int)tmp; // division by b  				}  				carry += (a[0] & IMASK);  				a[1] = (int)carry;  				a[0] = (int)((ulong)carry >> 32); // OJO!!!!!  			}
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,MultiplyMonty,The following statement contains a magic number: for (int i = n; i > 0; i--)  			{  				long x_i = x[i - 1] & IMASK;    				// 2.1 u = ((a[0] + (x[i] * y[0]) * mQuote) mod b  				long u = ((((a[n] & IMASK) + ((x_i * y_0) & IMASK)) & IMASK) * mQuote) & IMASK;    				// 2.2 a = (a + x_i * y + u * m) / b  				long prod1 = x_i * y_0;  				long prod2 = u * (m[nMinus1] & IMASK);  				long tmp = (a[n] & IMASK) + (prod1 & IMASK) + (prod2 & IMASK);  				long carry = (long)((ulong)prod1 >> 32) + (long)((ulong)prod2 >> 32) + (long)((ulong)tmp >> 32);  				for (int j = nMinus1; j > 0; j--)  				{  					prod1 = x_i * (y[j - 1] & IMASK);  					prod2 = u * (m[j - 1] & IMASK);  					tmp = (a[j] & IMASK) + (prod1 & IMASK) + (prod2 & IMASK) + (carry & IMASK);  					carry = (long)((ulong)carry >> 32) + (long)((ulong)prod1 >> 32) +  						(long)((ulong)prod2 >> 32) + (long)((ulong)tmp >> 32);  					a[j + 1] = (int)tmp; // division by b  				}  				carry += (a[0] & IMASK);  				a[1] = (int)carry;  				a[0] = (int)((ulong)carry >> 32); // OJO!!!!!  			}
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,MultiplyMonty,The following statement contains a magic number: for (int i = n; i > 0; i--)  			{  				long x_i = x[i - 1] & IMASK;    				// 2.1 u = ((a[0] + (x[i] * y[0]) * mQuote) mod b  				long u = ((((a[n] & IMASK) + ((x_i * y_0) & IMASK)) & IMASK) * mQuote) & IMASK;    				// 2.2 a = (a + x_i * y + u * m) / b  				long prod1 = x_i * y_0;  				long prod2 = u * (m[nMinus1] & IMASK);  				long tmp = (a[n] & IMASK) + (prod1 & IMASK) + (prod2 & IMASK);  				long carry = (long)((ulong)prod1 >> 32) + (long)((ulong)prod2 >> 32) + (long)((ulong)tmp >> 32);  				for (int j = nMinus1; j > 0; j--)  				{  					prod1 = x_i * (y[j - 1] & IMASK);  					prod2 = u * (m[j - 1] & IMASK);  					tmp = (a[j] & IMASK) + (prod1 & IMASK) + (prod2 & IMASK) + (carry & IMASK);  					carry = (long)((ulong)carry >> 32) + (long)((ulong)prod1 >> 32) +  						(long)((ulong)prod2 >> 32) + (long)((ulong)tmp >> 32);  					a[j + 1] = (int)tmp; // division by b  				}  				carry += (a[0] & IMASK);  				a[1] = (int)carry;  				a[0] = (int)((ulong)carry >> 32); // OJO!!!!!  			}
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,MultiplyMonty,The following statement contains a magic number: for (int i = n; i > 0; i--)  			{  				long x_i = x[i - 1] & IMASK;    				// 2.1 u = ((a[0] + (x[i] * y[0]) * mQuote) mod b  				long u = ((((a[n] & IMASK) + ((x_i * y_0) & IMASK)) & IMASK) * mQuote) & IMASK;    				// 2.2 a = (a + x_i * y + u * m) / b  				long prod1 = x_i * y_0;  				long prod2 = u * (m[nMinus1] & IMASK);  				long tmp = (a[n] & IMASK) + (prod1 & IMASK) + (prod2 & IMASK);  				long carry = (long)((ulong)prod1 >> 32) + (long)((ulong)prod2 >> 32) + (long)((ulong)tmp >> 32);  				for (int j = nMinus1; j > 0; j--)  				{  					prod1 = x_i * (y[j - 1] & IMASK);  					prod2 = u * (m[j - 1] & IMASK);  					tmp = (a[j] & IMASK) + (prod1 & IMASK) + (prod2 & IMASK) + (carry & IMASK);  					carry = (long)((ulong)carry >> 32) + (long)((ulong)prod1 >> 32) +  						(long)((ulong)prod2 >> 32) + (long)((ulong)tmp >> 32);  					a[j + 1] = (int)tmp; // division by b  				}  				carry += (a[0] & IMASK);  				a[1] = (int)carry;  				a[0] = (int)((ulong)carry >> 32); // OJO!!!!!  			}
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,MultiplyMontyNIsOne,The following statement contains a magic number: ulong carry = (prod1 >> 32) + (prod2 >> 32) + (tmp >> 32);
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,MultiplyMontyNIsOne,The following statement contains a magic number: ulong carry = (prod1 >> 32) + (prod2 >> 32) + (tmp >> 32);
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,MultiplyMontyNIsOne,The following statement contains a magic number: ulong carry = (prod1 >> 32) + (prod2 >> 32) + (tmp >> 32);
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,Remainder,The following statement contains a magic number: for (int pos = 0; pos < m_magnitude.Length; ++pos)  			{  				long posVal = (uint)m_magnitude[pos];  				acc = (acc << 32 | posVal) % m;  			}
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,Remainder,The following statement contains a magic number: if (xyCmp > 0)  			{  				int yBitLength = calcBitLength(yStart' y);  				int xBitLength = calcBitLength(xStart' x);  				int shift = xBitLength - yBitLength;    				int[] c;  				int cStart = 0;  				int cBitLength = yBitLength;  				if (shift > 0)  				{  					c = ShiftLeft(y' shift);  					cBitLength += shift;  					Debug.Assert(c[0] != 0);  				}  				else  				{  					int len = y.Length - yStart;  					c = new int[len];  					Array.Copy(y' yStart' c' 0' len);  				}    				for (; ; )  				{  					if (cBitLength < xBitLength  						|| CompareNoLeadingZeroes(xStart' x' cStart' c) >= 0)  					{  						Subtract(xStart' x' cStart' c);    						while (x[xStart] == 0)  						{  							if (++xStart == x.Length)  								return x;  						}    						//xBitLength = calcBitLength(xStart' x);  						xBitLength = 32 * (x.Length - xStart - 1) + BitLen(x[xStart]);    						if (xBitLength <= yBitLength)  						{  							if (xBitLength < yBitLength)  								return x;    							xyCmp = CompareNoLeadingZeroes(xStart' x' yStart' y);    							if (xyCmp <= 0)  								break;  						}  					}    					shift = cBitLength - xBitLength;    					// NB: The case where c[cStart] is 1-bit is harmless  					if (shift == 1)  					{  						uint firstC = (uint)c[cStart] >> 1;  						uint firstX = (uint)x[xStart];  						if (firstC > firstX)  							++shift;  					}    					if (shift < 2)  					{  						c = ShiftRightOneInPlace(cStart' c);  						--cBitLength;  					}  					else  					{  						c = ShiftRightInPlace(cStart' c' shift);  						cBitLength -= shift;  					}    					//cStart = c.Length - ((cBitLength + 31) / 32);  					while (c[cStart] == 0)  					{  						++cStart;  					}  				}  			}
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,Remainder,The following statement contains a magic number: if (xyCmp > 0)  			{  				int yBitLength = calcBitLength(yStart' y);  				int xBitLength = calcBitLength(xStart' x);  				int shift = xBitLength - yBitLength;    				int[] c;  				int cStart = 0;  				int cBitLength = yBitLength;  				if (shift > 0)  				{  					c = ShiftLeft(y' shift);  					cBitLength += shift;  					Debug.Assert(c[0] != 0);  				}  				else  				{  					int len = y.Length - yStart;  					c = new int[len];  					Array.Copy(y' yStart' c' 0' len);  				}    				for (; ; )  				{  					if (cBitLength < xBitLength  						|| CompareNoLeadingZeroes(xStart' x' cStart' c) >= 0)  					{  						Subtract(xStart' x' cStart' c);    						while (x[xStart] == 0)  						{  							if (++xStart == x.Length)  								return x;  						}    						//xBitLength = calcBitLength(xStart' x);  						xBitLength = 32 * (x.Length - xStart - 1) + BitLen(x[xStart]);    						if (xBitLength <= yBitLength)  						{  							if (xBitLength < yBitLength)  								return x;    							xyCmp = CompareNoLeadingZeroes(xStart' x' yStart' y);    							if (xyCmp <= 0)  								break;  						}  					}    					shift = cBitLength - xBitLength;    					// NB: The case where c[cStart] is 1-bit is harmless  					if (shift == 1)  					{  						uint firstC = (uint)c[cStart] >> 1;  						uint firstX = (uint)x[xStart];  						if (firstC > firstX)  							++shift;  					}    					if (shift < 2)  					{  						c = ShiftRightOneInPlace(cStart' c);  						--cBitLength;  					}  					else  					{  						c = ShiftRightInPlace(cStart' c' shift);  						cBitLength -= shift;  					}    					//cStart = c.Length - ((cBitLength + 31) / 32);  					while (c[cStart] == 0)  					{  						++cStart;  					}  				}  			}
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,LastNBits,The following statement contains a magic number: int hiBits = n % 32;
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,ShiftLeft,The following statement contains a magic number: int nInts = (int)((uint)n >> 5);
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,ShiftLeft,The following statement contains a magic number: if (nBits == 0)  			{  				newMag = new int[magLen + nInts];  				mag.CopyTo(newMag' 0);  			}  			else  			{  				int i = 0;  				int nBits2 = 32 - nBits;  				int highBits = (int)((uint)mag[0] >> nBits2);    				if (highBits != 0)  				{  					newMag = new int[magLen + nInts + 1];  					newMag[i++] = highBits;  				}  				else  				{  					newMag = new int[magLen + nInts];  				}    				int m = mag[0];  				for (int j = 0; j < magLen - 1; j++)  				{  					int next = mag[j + 1];    					newMag[i++] = (m << nBits) | (int)((uint)next >> nBits2);  					m = next;  				}    				newMag[i] = mag[magLen - 1] << nBits;  			}
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,ShiftRightInPlace,The following statement contains a magic number: int nInts = (int)((uint)n >> 5) + start;
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,ShiftRightInPlace,The following statement contains a magic number: if (nBits != 0)  			{  				int nBits2 = 32 - nBits;  				int m = mag[magEnd];    				for (int i = magEnd; i > nInts; --i)  				{  					int next = mag[i - 1];    					mag[i] = (int)((uint)m >> nBits) | (next << nBits2);  					m = next;  				}    				mag[nInts] = (int)((uint)mag[nInts] >> nBits);  			}
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,ShiftRightOneInPlace,The following statement contains a magic number: while (--i > start)  			{  				int next = mag[i - 1];  				mag[i] = ((int)((uint)m >> 1)) | (next << 31);  				m = next;  			}
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,ShiftRight,The following statement contains a magic number: int resultLength = (BitLength - n + 31) >> 5;
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,ShiftRight,The following statement contains a magic number: int resultLength = (BitLength - n + 31) >> 5;
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,ShiftRight,The following statement contains a magic number: int numInts = n >> 5;
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,ShiftRight,The following statement contains a magic number: int numBits = n & 31;
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,ShiftRight,The following statement contains a magic number: if (numBits == 0)  			{  				Array.Copy(m_magnitude' 0' res' 0' res.Length);  			}  			else  			{  				int numBits2 = 32 - numBits;    				int magPos = m_magnitude.Length - 1 - numInts;  				for (int i = resultLength - 1; i >= 0; --i)  				{  					res[i] = (int)((uint)m_magnitude[magPos--] >> numBits);    					if (magPos >= 0)  					{  						res[i] |= m_magnitude[magPos] << numBits2;  					}  				}  			}
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,Subtract,The following statement contains a magic number: do  			{  				m = (x[--iT] & IMASK) - (y[--iV] & IMASK) + borrow;  				x[iT] = (int)m;    				//				borrow = (m < 0) ? -1 : 0;  				borrow = (int)(m >> 63);  			}  			while (iV > yStart);
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,ToByteArray,The following statement contains a magic number: if (m_sign > 0)  			{  				while (magIndex > 1)  				{  					uint mag = (uint)m_magnitude[--magIndex];  					bytes[--bytesIndex] = (byte)mag;  					bytes[--bytesIndex] = (byte)(mag >> 8);  					bytes[--bytesIndex] = (byte)(mag >> 16);  					bytes[--bytesIndex] = (byte)(mag >> 24);  				}    				uint lastMag = (uint)m_magnitude[0];  				while (lastMag > byte.MaxValue)  				{  					bytes[--bytesIndex] = (byte)lastMag;  					lastMag >>= 8;  				}    				bytes[--bytesIndex] = (byte)lastMag;  			}  			else // sign < 0  			{  				bool carry = true;    				while (magIndex > 1)  				{  					uint mag = ~((uint)m_magnitude[--magIndex]);    					if (carry)  					{  						carry = (++mag == uint.MinValue);  					}    					bytes[--bytesIndex] = (byte)mag;  					bytes[--bytesIndex] = (byte)(mag >> 8);  					bytes[--bytesIndex] = (byte)(mag >> 16);  					bytes[--bytesIndex] = (byte)(mag >> 24);  				}    				uint lastMag = (uint)m_magnitude[0];    				if (carry)  				{  					// Never wraps because magnitude[0] != 0  					--lastMag;  				}    				while (lastMag > byte.MaxValue)  				{  					bytes[--bytesIndex] = (byte)~lastMag;  					lastMag >>= 8;  				}    				bytes[--bytesIndex] = (byte)~lastMag;    				if (bytesIndex > 0)  				{  					bytes[--bytesIndex] = byte.MaxValue;  				}  			}
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,ToByteArray,The following statement contains a magic number: if (m_sign > 0)  			{  				while (magIndex > 1)  				{  					uint mag = (uint)m_magnitude[--magIndex];  					bytes[--bytesIndex] = (byte)mag;  					bytes[--bytesIndex] = (byte)(mag >> 8);  					bytes[--bytesIndex] = (byte)(mag >> 16);  					bytes[--bytesIndex] = (byte)(mag >> 24);  				}    				uint lastMag = (uint)m_magnitude[0];  				while (lastMag > byte.MaxValue)  				{  					bytes[--bytesIndex] = (byte)lastMag;  					lastMag >>= 8;  				}    				bytes[--bytesIndex] = (byte)lastMag;  			}  			else // sign < 0  			{  				bool carry = true;    				while (magIndex > 1)  				{  					uint mag = ~((uint)m_magnitude[--magIndex]);    					if (carry)  					{  						carry = (++mag == uint.MinValue);  					}    					bytes[--bytesIndex] = (byte)mag;  					bytes[--bytesIndex] = (byte)(mag >> 8);  					bytes[--bytesIndex] = (byte)(mag >> 16);  					bytes[--bytesIndex] = (byte)(mag >> 24);  				}    				uint lastMag = (uint)m_magnitude[0];    				if (carry)  				{  					// Never wraps because magnitude[0] != 0  					--lastMag;  				}    				while (lastMag > byte.MaxValue)  				{  					bytes[--bytesIndex] = (byte)~lastMag;  					lastMag >>= 8;  				}    				bytes[--bytesIndex] = (byte)~lastMag;    				if (bytesIndex > 0)  				{  					bytes[--bytesIndex] = byte.MaxValue;  				}  			}
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,ToByteArray,The following statement contains a magic number: if (m_sign > 0)  			{  				while (magIndex > 1)  				{  					uint mag = (uint)m_magnitude[--magIndex];  					bytes[--bytesIndex] = (byte)mag;  					bytes[--bytesIndex] = (byte)(mag >> 8);  					bytes[--bytesIndex] = (byte)(mag >> 16);  					bytes[--bytesIndex] = (byte)(mag >> 24);  				}    				uint lastMag = (uint)m_magnitude[0];  				while (lastMag > byte.MaxValue)  				{  					bytes[--bytesIndex] = (byte)lastMag;  					lastMag >>= 8;  				}    				bytes[--bytesIndex] = (byte)lastMag;  			}  			else // sign < 0  			{  				bool carry = true;    				while (magIndex > 1)  				{  					uint mag = ~((uint)m_magnitude[--magIndex]);    					if (carry)  					{  						carry = (++mag == uint.MinValue);  					}    					bytes[--bytesIndex] = (byte)mag;  					bytes[--bytesIndex] = (byte)(mag >> 8);  					bytes[--bytesIndex] = (byte)(mag >> 16);  					bytes[--bytesIndex] = (byte)(mag >> 24);  				}    				uint lastMag = (uint)m_magnitude[0];    				if (carry)  				{  					// Never wraps because magnitude[0] != 0  					--lastMag;  				}    				while (lastMag > byte.MaxValue)  				{  					bytes[--bytesIndex] = (byte)~lastMag;  					lastMag >>= 8;  				}    				bytes[--bytesIndex] = (byte)~lastMag;    				if (bytesIndex > 0)  				{  					bytes[--bytesIndex] = byte.MaxValue;  				}  			}
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,ToByteArray,The following statement contains a magic number: if (m_sign > 0)  			{  				while (magIndex > 1)  				{  					uint mag = (uint)m_magnitude[--magIndex];  					bytes[--bytesIndex] = (byte)mag;  					bytes[--bytesIndex] = (byte)(mag >> 8);  					bytes[--bytesIndex] = (byte)(mag >> 16);  					bytes[--bytesIndex] = (byte)(mag >> 24);  				}    				uint lastMag = (uint)m_magnitude[0];  				while (lastMag > byte.MaxValue)  				{  					bytes[--bytesIndex] = (byte)lastMag;  					lastMag >>= 8;  				}    				bytes[--bytesIndex] = (byte)lastMag;  			}  			else // sign < 0  			{  				bool carry = true;    				while (magIndex > 1)  				{  					uint mag = ~((uint)m_magnitude[--magIndex]);    					if (carry)  					{  						carry = (++mag == uint.MinValue);  					}    					bytes[--bytesIndex] = (byte)mag;  					bytes[--bytesIndex] = (byte)(mag >> 8);  					bytes[--bytesIndex] = (byte)(mag >> 16);  					bytes[--bytesIndex] = (byte)(mag >> 24);  				}    				uint lastMag = (uint)m_magnitude[0];    				if (carry)  				{  					// Never wraps because magnitude[0] != 0  					--lastMag;  				}    				while (lastMag > byte.MaxValue)  				{  					bytes[--bytesIndex] = (byte)~lastMag;  					lastMag >>= 8;  				}    				bytes[--bytesIndex] = (byte)~lastMag;    				if (bytesIndex > 0)  				{  					bytes[--bytesIndex] = byte.MaxValue;  				}  			}
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,ToByteArray,The following statement contains a magic number: if (m_sign > 0)  			{  				while (magIndex > 1)  				{  					uint mag = (uint)m_magnitude[--magIndex];  					bytes[--bytesIndex] = (byte)mag;  					bytes[--bytesIndex] = (byte)(mag >> 8);  					bytes[--bytesIndex] = (byte)(mag >> 16);  					bytes[--bytesIndex] = (byte)(mag >> 24);  				}    				uint lastMag = (uint)m_magnitude[0];  				while (lastMag > byte.MaxValue)  				{  					bytes[--bytesIndex] = (byte)lastMag;  					lastMag >>= 8;  				}    				bytes[--bytesIndex] = (byte)lastMag;  			}  			else // sign < 0  			{  				bool carry = true;    				while (magIndex > 1)  				{  					uint mag = ~((uint)m_magnitude[--magIndex]);    					if (carry)  					{  						carry = (++mag == uint.MinValue);  					}    					bytes[--bytesIndex] = (byte)mag;  					bytes[--bytesIndex] = (byte)(mag >> 8);  					bytes[--bytesIndex] = (byte)(mag >> 16);  					bytes[--bytesIndex] = (byte)(mag >> 24);  				}    				uint lastMag = (uint)m_magnitude[0];    				if (carry)  				{  					// Never wraps because magnitude[0] != 0  					--lastMag;  				}    				while (lastMag > byte.MaxValue)  				{  					bytes[--bytesIndex] = (byte)~lastMag;  					lastMag >>= 8;  				}    				bytes[--bytesIndex] = (byte)~lastMag;    				if (bytesIndex > 0)  				{  					bytes[--bytesIndex] = byte.MaxValue;  				}  			}
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,ToByteArray,The following statement contains a magic number: if (m_sign > 0)  			{  				while (magIndex > 1)  				{  					uint mag = (uint)m_magnitude[--magIndex];  					bytes[--bytesIndex] = (byte)mag;  					bytes[--bytesIndex] = (byte)(mag >> 8);  					bytes[--bytesIndex] = (byte)(mag >> 16);  					bytes[--bytesIndex] = (byte)(mag >> 24);  				}    				uint lastMag = (uint)m_magnitude[0];  				while (lastMag > byte.MaxValue)  				{  					bytes[--bytesIndex] = (byte)lastMag;  					lastMag >>= 8;  				}    				bytes[--bytesIndex] = (byte)lastMag;  			}  			else // sign < 0  			{  				bool carry = true;    				while (magIndex > 1)  				{  					uint mag = ~((uint)m_magnitude[--magIndex]);    					if (carry)  					{  						carry = (++mag == uint.MinValue);  					}    					bytes[--bytesIndex] = (byte)mag;  					bytes[--bytesIndex] = (byte)(mag >> 8);  					bytes[--bytesIndex] = (byte)(mag >> 16);  					bytes[--bytesIndex] = (byte)(mag >> 24);  				}    				uint lastMag = (uint)m_magnitude[0];    				if (carry)  				{  					// Never wraps because magnitude[0] != 0  					--lastMag;  				}    				while (lastMag > byte.MaxValue)  				{  					bytes[--bytesIndex] = (byte)~lastMag;  					lastMag >>= 8;  				}    				bytes[--bytesIndex] = (byte)~lastMag;    				if (bytesIndex > 0)  				{  					bytes[--bytesIndex] = byte.MaxValue;  				}  			}
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,ToByteArray,The following statement contains a magic number: if (m_sign > 0)  			{  				while (magIndex > 1)  				{  					uint mag = (uint)m_magnitude[--magIndex];  					bytes[--bytesIndex] = (byte)mag;  					bytes[--bytesIndex] = (byte)(mag >> 8);  					bytes[--bytesIndex] = (byte)(mag >> 16);  					bytes[--bytesIndex] = (byte)(mag >> 24);  				}    				uint lastMag = (uint)m_magnitude[0];  				while (lastMag > byte.MaxValue)  				{  					bytes[--bytesIndex] = (byte)lastMag;  					lastMag >>= 8;  				}    				bytes[--bytesIndex] = (byte)lastMag;  			}  			else // sign < 0  			{  				bool carry = true;    				while (magIndex > 1)  				{  					uint mag = ~((uint)m_magnitude[--magIndex]);    					if (carry)  					{  						carry = (++mag == uint.MinValue);  					}    					bytes[--bytesIndex] = (byte)mag;  					bytes[--bytesIndex] = (byte)(mag >> 8);  					bytes[--bytesIndex] = (byte)(mag >> 16);  					bytes[--bytesIndex] = (byte)(mag >> 24);  				}    				uint lastMag = (uint)m_magnitude[0];    				if (carry)  				{  					// Never wraps because magnitude[0] != 0  					--lastMag;  				}    				while (lastMag > byte.MaxValue)  				{  					bytes[--bytesIndex] = (byte)~lastMag;  					lastMag >>= 8;  				}    				bytes[--bytesIndex] = (byte)~lastMag;    				if (bytesIndex > 0)  				{  					bytes[--bytesIndex] = byte.MaxValue;  				}  			}
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,ToByteArray,The following statement contains a magic number: if (m_sign > 0)  			{  				while (magIndex > 1)  				{  					uint mag = (uint)m_magnitude[--magIndex];  					bytes[--bytesIndex] = (byte)mag;  					bytes[--bytesIndex] = (byte)(mag >> 8);  					bytes[--bytesIndex] = (byte)(mag >> 16);  					bytes[--bytesIndex] = (byte)(mag >> 24);  				}    				uint lastMag = (uint)m_magnitude[0];  				while (lastMag > byte.MaxValue)  				{  					bytes[--bytesIndex] = (byte)lastMag;  					lastMag >>= 8;  				}    				bytes[--bytesIndex] = (byte)lastMag;  			}  			else // sign < 0  			{  				bool carry = true;    				while (magIndex > 1)  				{  					uint mag = ~((uint)m_magnitude[--magIndex]);    					if (carry)  					{  						carry = (++mag == uint.MinValue);  					}    					bytes[--bytesIndex] = (byte)mag;  					bytes[--bytesIndex] = (byte)(mag >> 8);  					bytes[--bytesIndex] = (byte)(mag >> 16);  					bytes[--bytesIndex] = (byte)(mag >> 24);  				}    				uint lastMag = (uint)m_magnitude[0];    				if (carry)  				{  					// Never wraps because magnitude[0] != 0  					--lastMag;  				}    				while (lastMag > byte.MaxValue)  				{  					bytes[--bytesIndex] = (byte)~lastMag;  					lastMag >>= 8;  				}    				bytes[--bytesIndex] = (byte)~lastMag;    				if (bytesIndex > 0)  				{  					bytes[--bytesIndex] = byte.MaxValue;  				}  			}
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,ToString,The following statement contains a magic number: return ToString(10);
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,ToString,The following statement contains a magic number: switch (radix)  			{  				case 2:  				case 10:  				case 16:  					break;  				default:  					throw new FormatException("Only bases 2' 10' 16 are allowed");  			}
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,ToString,The following statement contains a magic number: switch (radix)  			{  				case 2:  				case 10:  				case 16:  					break;  				default:  					throw new FormatException("Only bases 2' 10' 16 are allowed");  			}
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,ToString,The following statement contains a magic number: switch (radix)  			{  				case 2:  				case 10:  				case 16:  					break;  				default:  					throw new FormatException("Only bases 2' 10' 16 are allowed");  			}
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,ToString,The following statement contains a magic number: if (radix == 16)  			{  				sb.Append(m_magnitude[0].ToString("x"));    				for (int i = 1; i < m_magnitude.Length; i++)  				{  					sb.Append(m_magnitude[i].ToString("x8"));  				}  			}  			else if (radix == 2)  			{  				sb.Append('1');    				for (int i = BitLength - 2; i >= 0; --i)  				{  					sb.Append(TestBit(i) ? '1' : '0');  				}  			}  			else  			{  				// This is algorithm 1a from chapter 4.4 in Seminumerical Algorithms' slow but it works  				Stack S = new Stack();  				NetBigInteger bs = ValueOf(radix);    				NetBigInteger u = Abs();  				NetBigInteger b;    				while (u.m_sign != 0)  				{  					b = u.Mod(bs);  					if (b.m_sign == 0)  					{  						S.Push("0");  					}  					else  					{  						// see how to interact with different bases  						S.Push(b.m_magnitude[0].ToString("d"));  					}  					u = u.Divide(bs);  				}    				// Then pop the stack  				while (S.Count != 0)  				{  					sb.Append((string)S.Pop());  				}  			}
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,ToString,The following statement contains a magic number: if (radix == 16)  			{  				sb.Append(m_magnitude[0].ToString("x"));    				for (int i = 1; i < m_magnitude.Length; i++)  				{  					sb.Append(m_magnitude[i].ToString("x8"));  				}  			}  			else if (radix == 2)  			{  				sb.Append('1');    				for (int i = BitLength - 2; i >= 0; --i)  				{  					sb.Append(TestBit(i) ? '1' : '0');  				}  			}  			else  			{  				// This is algorithm 1a from chapter 4.4 in Seminumerical Algorithms' slow but it works  				Stack S = new Stack();  				NetBigInteger bs = ValueOf(radix);    				NetBigInteger u = Abs();  				NetBigInteger b;    				while (u.m_sign != 0)  				{  					b = u.Mod(bs);  					if (b.m_sign == 0)  					{  						S.Push("0");  					}  					else  					{  						// see how to interact with different bases  						S.Push(b.m_magnitude[0].ToString("d"));  					}  					u = u.Divide(bs);  				}    				// Then pop the stack  				while (S.Count != 0)  				{  					sb.Append((string)S.Pop());  				}  			}
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,ToString,The following statement contains a magic number: if (radix == 16)  			{  				sb.Append(m_magnitude[0].ToString("x"));    				for (int i = 1; i < m_magnitude.Length; i++)  				{  					sb.Append(m_magnitude[i].ToString("x8"));  				}  			}  			else if (radix == 2)  			{  				sb.Append('1');    				for (int i = BitLength - 2; i >= 0; --i)  				{  					sb.Append(TestBit(i) ? '1' : '0');  				}  			}  			else  			{  				// This is algorithm 1a from chapter 4.4 in Seminumerical Algorithms' slow but it works  				Stack S = new Stack();  				NetBigInteger bs = ValueOf(radix);    				NetBigInteger u = Abs();  				NetBigInteger b;    				while (u.m_sign != 0)  				{  					b = u.Mod(bs);  					if (b.m_sign == 0)  					{  						S.Push("0");  					}  					else  					{  						// see how to interact with different bases  						S.Push(b.m_magnitude[0].ToString("d"));  					}  					u = u.Divide(bs);  				}    				// Then pop the stack  				while (S.Count != 0)  				{  					sb.Append((string)S.Pop());  				}  			}
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,createUValueOf,The following statement contains a magic number: int msw = (int)(value >> 32);
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,ValueOf,The following statement contains a magic number: switch (value)  			{  				case 0:  					return Zero;  				case 1:  					return One;  				case 2:  					return Two;  				case 3:  					return Three;  				case 10:  					return Ten;  			}
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,ValueOf,The following statement contains a magic number: switch (value)  			{  				case 0:  					return Zero;  				case 1:  					return One;  				case 2:  					return Two;  				case 3:  					return Three;  				case 10:  					return Ten;  			}
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,ValueOf,The following statement contains a magic number: switch (value)  			{  				case 0:  					return Zero;  				case 1:  					return One;  				case 2:  					return Two;  				case 3:  					return Three;  				case 10:  					return Ten;  			}
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,GetLowestSetBit,The following statement contains a magic number: int b = (word & 0x0000FFFF) == 0  				? (word & 0x00FF0000) == 0  					? 7  					: 15  				: (word & 0x000000FF) == 0  					? 23  					: 31;
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,GetLowestSetBit,The following statement contains a magic number: int b = (word & 0x0000FFFF) == 0  				? (word & 0x00FF0000) == 0  					? 7  					: 15  				: (word & 0x000000FF) == 0  					? 23  					: 31;
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,GetLowestSetBit,The following statement contains a magic number: int b = (word & 0x0000FFFF) == 0  				? (word & 0x00FF0000) == 0  					? 7  					: 15  				: (word & 0x000000FF) == 0  					? 23  					: 31;
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,GetLowestSetBit,The following statement contains a magic number: int b = (word & 0x0000FFFF) == 0  				? (word & 0x00FF0000) == 0  					? 7  					: 15  				: (word & 0x000000FF) == 0  					? 23  					: 31;
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,GetLowestSetBit,The following statement contains a magic number: return ((m_magnitude.Length - w) * 32 - (b + 1));
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,TestBit,The following statement contains a magic number: int wordNum = n / 32;
Magic Number,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,TestBit,The following statement contains a magic number: return ((word >> (n % 32)) & 1) > 0;
Magic Number,Lidgren.Network,NetBitVector,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitVector.cs,NetBitVector,The following statement contains a magic number: m_data = new int[(bitsCapacity + 31) / 32];
Magic Number,Lidgren.Network,NetBitVector,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitVector.cs,NetBitVector,The following statement contains a magic number: m_data = new int[(bitsCapacity + 31) / 32];
Magic Number,Lidgren.Network,NetBitVector,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitVector.cs,RotateDown,The following statement contains a magic number: for (int i = 0; i < lenMinusOne; i++)  				m_data[i] = ((m_data[i] >> 1) & ~(1 << 31)) | m_data[i + 1] << 31;
Magic Number,Lidgren.Network,NetBitVector,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitVector.cs,RotateDown,The following statement contains a magic number: for (int i = 0; i < lenMinusOne; i++)  				m_data[i] = ((m_data[i] >> 1) & ~(1 << 31)) | m_data[i + 1] << 31;
Magic Number,Lidgren.Network,NetBitVector,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitVector.cs,RotateDown,The following statement contains a magic number: int lastIndex = m_capacity - 1 - (32 * lenMinusOne);
Magic Number,Lidgren.Network,NetBitVector,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitVector.cs,GetFirstSetIndex,The following statement contains a magic number: return (idx * 32) + a;
Magic Number,Lidgren.Network,NetBitVector,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitVector.cs,Get,The following statement contains a magic number: return (m_data[bitIndex / 32] & (1 << (bitIndex % 32))) != 0;
Magic Number,Lidgren.Network,NetBitVector,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitVector.cs,Get,The following statement contains a magic number: return (m_data[bitIndex / 32] & (1 << (bitIndex % 32))) != 0;
Magic Number,Lidgren.Network,NetBitVector,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitVector.cs,Set,The following statement contains a magic number: int idx = bitIndex / 32;
Magic Number,Lidgren.Network,NetBitVector,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitVector.cs,Set,The following statement contains a magic number: if (value)  			{  				if ((m_data[idx] & (1 << (bitIndex % 32))) == 0)  					m_numBitsSet++;  				m_data[idx] |= (1 << (bitIndex % 32));  			}  			else  			{  				if ((m_data[idx] & (1 << (bitIndex % 32))) != 0)  					m_numBitsSet--;  				m_data[idx] &= (~(1 << (bitIndex % 32)));  			}
Magic Number,Lidgren.Network,NetBitVector,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitVector.cs,Set,The following statement contains a magic number: if (value)  			{  				if ((m_data[idx] & (1 << (bitIndex % 32))) == 0)  					m_numBitsSet++;  				m_data[idx] |= (1 << (bitIndex % 32));  			}  			else  			{  				if ((m_data[idx] & (1 << (bitIndex % 32))) != 0)  					m_numBitsSet--;  				m_data[idx] &= (~(1 << (bitIndex % 32)));  			}
Magic Number,Lidgren.Network,NetBitVector,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitVector.cs,Set,The following statement contains a magic number: if (value)  			{  				if ((m_data[idx] & (1 << (bitIndex % 32))) == 0)  					m_numBitsSet++;  				m_data[idx] |= (1 << (bitIndex % 32));  			}  			else  			{  				if ((m_data[idx] & (1 << (bitIndex % 32))) != 0)  					m_numBitsSet--;  				m_data[idx] &= (~(1 << (bitIndex % 32)));  			}
Magic Number,Lidgren.Network,NetBitVector,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitVector.cs,Set,The following statement contains a magic number: if (value)  			{  				if ((m_data[idx] & (1 << (bitIndex % 32))) == 0)  					m_numBitsSet++;  				m_data[idx] |= (1 << (bitIndex % 32));  			}  			else  			{  				if ((m_data[idx] & (1 << (bitIndex % 32))) != 0)  					m_numBitsSet--;  				m_data[idx] &= (~(1 << (bitIndex % 32)));  			}
Magic Number,Lidgren.Network,NetBitVector,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitVector.cs,ToString,The following statement contains a magic number: StringBuilder bdr = new StringBuilder(m_capacity + 2);
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,ReadByte,The following statement contains a magic number: NetException.Assert(((numberOfBits > 0) && (numberOfBits < 9))' "Read() can only read between 1 and 8 bits");
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,ReadByte,The following statement contains a magic number: int bytePtr = readBitOffset >> 3;
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,ReadByte,The following statement contains a magic number: int startReadAtIndex = readBitOffset - (bytePtr * 8);
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,ReadByte,The following statement contains a magic number: if (startReadAtIndex == 0 && numberOfBits == 8)  				return fromBuffer[bytePtr];
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,ReadByte,The following statement contains a magic number: int numberOfBitsInSecondByte = numberOfBits - (8 - startReadAtIndex);
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,ReadByte,The following statement contains a magic number: if (numberOfBitsInSecondByte < 1)  			{  				// we don't need to read from the second byte' but we DO need  				// to mask away unused bits higher than (left of) relevant bits  				return (byte)(returnValue & (255 >> (8 - numberOfBits)));  			}
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,ReadByte,The following statement contains a magic number: if (numberOfBitsInSecondByte < 1)  			{  				// we don't need to read from the second byte' but we DO need  				// to mask away unused bits higher than (left of) relevant bits  				return (byte)(returnValue & (255 >> (8 - numberOfBits)));  			}
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,ReadByte,The following statement contains a magic number: second &= (byte)(255 >> (8 - numberOfBitsInSecondByte));
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,ReadByte,The following statement contains a magic number: second &= (byte)(255 >> (8 - numberOfBitsInSecondByte));
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,ReadBytes,The following statement contains a magic number: int readPtr = readBitOffset >> 3;
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,ReadBytes,The following statement contains a magic number: int startReadAtIndex = readBitOffset - (readPtr * 8);
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,ReadBytes,The following statement contains a magic number: int secondPartLen = 8 - startReadAtIndex;
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,ReadBytes,The following statement contains a magic number: int secondMask = 255 >> secondPartLen;
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteByte,The following statement contains a magic number: NetException.Assert(((numberOfBits >= 0) && (numberOfBits <= 8))' "Must write between 0 and 8 bits!");
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteByte,The following statement contains a magic number: source = (byte)(source & (0xFF >> (8 - numberOfBits)));
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteByte,The following statement contains a magic number: int p = destBitOffset >> 3;
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteByte,The following statement contains a magic number: int bitsFree = 8 - bitsUsed;
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteByte,The following statement contains a magic number: if (bitsLeft >= 0)  			{  				int mask = (0xFF >> bitsFree) | (0xFF << (8 - bitsLeft));    				destination[p] = (byte)(  					// Mask out lower and upper bits  					(destination[p] & mask) |    					// Insert new bits  					(source << bitsUsed)  				);    				return;  			}
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteBytes,The following statement contains a magic number: int dstBytePtr = destBitOffset >> 3;
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteBytes,The following statement contains a magic number: int firstPartLen = (destBitOffset % 8);
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteBytes,The following statement contains a magic number: int lastPartLen = 8 - firstPartLen;
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteBytes,The following statement contains a magic number: for (int i = 0; i < numberOfBytes; i++)  			{  				byte src = source[sourceByteOffset + i];    				// write last part of this byte  				destination[dstBytePtr] &= (byte)(255 >> lastPartLen); // clear before writing  				destination[dstBytePtr] |= (byte)(src << firstPartLen); // write first half    				dstBytePtr++;    				// write first part of next byte  				destination[dstBytePtr] &= (byte)(255 << firstPartLen); // clear before writing  				destination[dstBytePtr] |= (byte)(src >> lastPartLen); // write second half  			}
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteBytes,The following statement contains a magic number: for (int i = 0; i < numberOfBytes; i++)  			{  				byte src = source[sourceByteOffset + i];    				// write last part of this byte  				destination[dstBytePtr] &= (byte)(255 >> lastPartLen); // clear before writing  				destination[dstBytePtr] |= (byte)(src << firstPartLen); // write first half    				dstBytePtr++;    				// write first part of next byte  				destination[dstBytePtr] &= (byte)(255 << firstPartLen); // clear before writing  				destination[dstBytePtr] |= (byte)(src >> lastPartLen); // write second half  			}
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,ReadUInt16,The following statement contains a magic number: Debug.Assert(((numberOfBits > 0) && (numberOfBits <= 16))' "ReadUInt16() can only read between 1 and 16 bits");
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,ReadUInt16,The following statement contains a magic number: if (numberOfBits <= 8)  			{  				returnValue = ReadByte(fromBuffer' numberOfBits' readBitOffset);  				return returnValue;  			}
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,ReadUInt16,The following statement contains a magic number: returnValue = ReadByte(fromBuffer' 8' readBitOffset);
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,ReadUInt16,The following statement contains a magic number: numberOfBits -= 8;
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,ReadUInt16,The following statement contains a magic number: readBitOffset += 8;
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,ReadUInt16,The following statement contains a magic number: if (numberOfBits <= 8)  			{  				returnValue |= (ushort)(ReadByte(fromBuffer' numberOfBits' readBitOffset) << 8);  			}
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,ReadUInt16,The following statement contains a magic number: if (numberOfBits <= 8)  			{  				returnValue |= (ushort)(ReadByte(fromBuffer' numberOfBits' readBitOffset) << 8);  			}
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,ReadUInt32,The following statement contains a magic number: NetException.Assert(((numberOfBits > 0) && (numberOfBits <= 32))' "ReadUInt32() can only read between 1 and 32 bits");
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,ReadUInt32,The following statement contains a magic number: if (numberOfBits <= 8)  			{  				returnValue = ReadByte(fromBuffer' numberOfBits' readBitOffset);  				return returnValue;  			}
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,ReadUInt32,The following statement contains a magic number: returnValue = ReadByte(fromBuffer' 8' readBitOffset);
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,ReadUInt32,The following statement contains a magic number: numberOfBits -= 8;
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,ReadUInt32,The following statement contains a magic number: readBitOffset += 8;
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,ReadUInt32,The following statement contains a magic number: if (numberOfBits <= 8)  			{  				returnValue |= (uint)(ReadByte(fromBuffer' numberOfBits' readBitOffset) << 8);  				return returnValue;  			}
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,ReadUInt32,The following statement contains a magic number: if (numberOfBits <= 8)  			{  				returnValue |= (uint)(ReadByte(fromBuffer' numberOfBits' readBitOffset) << 8);  				return returnValue;  			}
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,ReadUInt32,The following statement contains a magic number: returnValue |= (uint)(ReadByte(fromBuffer' 8' readBitOffset) << 8);
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,ReadUInt32,The following statement contains a magic number: returnValue |= (uint)(ReadByte(fromBuffer' 8' readBitOffset) << 8);
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,ReadUInt32,The following statement contains a magic number: numberOfBits -= 8;
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,ReadUInt32,The following statement contains a magic number: readBitOffset += 8;
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,ReadUInt32,The following statement contains a magic number: if (numberOfBits <= 8)  			{  				uint r = ReadByte(fromBuffer' numberOfBits' readBitOffset);  				r <<= 16;  				returnValue |= r;  				return returnValue;  			}
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,ReadUInt32,The following statement contains a magic number: if (numberOfBits <= 8)  			{  				uint r = ReadByte(fromBuffer' numberOfBits' readBitOffset);  				r <<= 16;  				returnValue |= r;  				return returnValue;  			}
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,ReadUInt32,The following statement contains a magic number: returnValue |= (uint)(ReadByte(fromBuffer' 8' readBitOffset) << 16);
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,ReadUInt32,The following statement contains a magic number: returnValue |= (uint)(ReadByte(fromBuffer' 8' readBitOffset) << 16);
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,ReadUInt32,The following statement contains a magic number: numberOfBits -= 8;
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,ReadUInt32,The following statement contains a magic number: readBitOffset += 8;
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,ReadUInt32,The following statement contains a magic number: returnValue |= (uint)(ReadByte(fromBuffer' numberOfBits' readBitOffset) << 24);
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteUInt16,The following statement contains a magic number: NetException.Assert((numberOfBits >= 0 && numberOfBits <= 16)' "numberOfBits must be between 0 and 16");
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteUInt16,The following statement contains a magic number: if (numberOfBits <= 8)  			{  				NetBitWriter.WriteByte((byte)source' numberOfBits' destination' destinationBitOffset);  				return;  			}
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteUInt16,The following statement contains a magic number: NetBitWriter.WriteByte((byte)source' 8' destination' destinationBitOffset);
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteUInt16,The following statement contains a magic number: numberOfBits -= 8;
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteUInt16,The following statement contains a magic number: if (numberOfBits > 0)  				NetBitWriter.WriteByte((byte)(source >> 8)' numberOfBits' destination' destinationBitOffset + 8);
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteUInt16,The following statement contains a magic number: if (numberOfBits > 0)  				NetBitWriter.WriteByte((byte)(source >> 8)' numberOfBits' destination' destinationBitOffset + 8);
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteUInt32,The following statement contains a magic number: if (numberOfBits <= 8)  			{  				NetBitWriter.WriteByte((byte)source' numberOfBits' destination' destinationBitOffset);  				return returnValue;  			}
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteUInt32,The following statement contains a magic number: NetBitWriter.WriteByte((byte)source' 8' destination' destinationBitOffset);
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteUInt32,The following statement contains a magic number: destinationBitOffset += 8;
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteUInt32,The following statement contains a magic number: numberOfBits -= 8;
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteUInt32,The following statement contains a magic number: if (numberOfBits <= 8)  			{  				NetBitWriter.WriteByte((byte)(source >> 8)' numberOfBits' destination' destinationBitOffset);  				return returnValue;  			}
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteUInt32,The following statement contains a magic number: if (numberOfBits <= 8)  			{  				NetBitWriter.WriteByte((byte)(source >> 8)' numberOfBits' destination' destinationBitOffset);  				return returnValue;  			}
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteUInt32,The following statement contains a magic number: NetBitWriter.WriteByte((byte)(source >> 8)' 8' destination' destinationBitOffset);
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteUInt32,The following statement contains a magic number: NetBitWriter.WriteByte((byte)(source >> 8)' 8' destination' destinationBitOffset);
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteUInt32,The following statement contains a magic number: destinationBitOffset += 8;
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteUInt32,The following statement contains a magic number: numberOfBits -= 8;
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteUInt32,The following statement contains a magic number: if (numberOfBits <= 8)  			{  				NetBitWriter.WriteByte((byte)(source >> 16)' numberOfBits' destination' destinationBitOffset);  				return returnValue;  			}
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteUInt32,The following statement contains a magic number: if (numberOfBits <= 8)  			{  				NetBitWriter.WriteByte((byte)(source >> 16)' numberOfBits' destination' destinationBitOffset);  				return returnValue;  			}
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteUInt32,The following statement contains a magic number: NetBitWriter.WriteByte((byte)(source >> 16)' 8' destination' destinationBitOffset);
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteUInt32,The following statement contains a magic number: NetBitWriter.WriteByte((byte)(source >> 16)' 8' destination' destinationBitOffset);
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteUInt32,The following statement contains a magic number: destinationBitOffset += 8;
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteUInt32,The following statement contains a magic number: numberOfBits -= 8;
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteUInt32,The following statement contains a magic number: NetBitWriter.WriteByte((byte)(source >> 24)' numberOfBits' destination' destinationBitOffset);
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteUInt64,The following statement contains a magic number: if (numberOfBits <= 8)  			{  				NetBitWriter.WriteByte((byte)source' numberOfBits' destination' destinationBitOffset);  				return returnValue;  			}
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteUInt64,The following statement contains a magic number: NetBitWriter.WriteByte((byte)source' 8' destination' destinationBitOffset);
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteUInt64,The following statement contains a magic number: destinationBitOffset += 8;
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteUInt64,The following statement contains a magic number: numberOfBits -= 8;
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteUInt64,The following statement contains a magic number: if (numberOfBits <= 8)  			{  				NetBitWriter.WriteByte((byte)(source >> 8)' numberOfBits' destination' destinationBitOffset);  				return returnValue;  			}
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteUInt64,The following statement contains a magic number: if (numberOfBits <= 8)  			{  				NetBitWriter.WriteByte((byte)(source >> 8)' numberOfBits' destination' destinationBitOffset);  				return returnValue;  			}
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteUInt64,The following statement contains a magic number: NetBitWriter.WriteByte((byte)(source >> 8)' 8' destination' destinationBitOffset);
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteUInt64,The following statement contains a magic number: NetBitWriter.WriteByte((byte)(source >> 8)' 8' destination' destinationBitOffset);
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteUInt64,The following statement contains a magic number: destinationBitOffset += 8;
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteUInt64,The following statement contains a magic number: numberOfBits -= 8;
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteUInt64,The following statement contains a magic number: if (numberOfBits <= 8)  			{  				NetBitWriter.WriteByte((byte)(source >> 16)' numberOfBits' destination' destinationBitOffset);  				return returnValue;  			}
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteUInt64,The following statement contains a magic number: if (numberOfBits <= 8)  			{  				NetBitWriter.WriteByte((byte)(source >> 16)' numberOfBits' destination' destinationBitOffset);  				return returnValue;  			}
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteUInt64,The following statement contains a magic number: NetBitWriter.WriteByte((byte)(source >> 16)' 8' destination' destinationBitOffset);
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteUInt64,The following statement contains a magic number: NetBitWriter.WriteByte((byte)(source >> 16)' 8' destination' destinationBitOffset);
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteUInt64,The following statement contains a magic number: destinationBitOffset += 8;
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteUInt64,The following statement contains a magic number: numberOfBits -= 8;
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteUInt64,The following statement contains a magic number: if (numberOfBits <= 8)  			{  				NetBitWriter.WriteByte((byte)(source >> 24)' numberOfBits' destination' destinationBitOffset);  				return returnValue;  			}
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteUInt64,The following statement contains a magic number: if (numberOfBits <= 8)  			{  				NetBitWriter.WriteByte((byte)(source >> 24)' numberOfBits' destination' destinationBitOffset);  				return returnValue;  			}
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteUInt64,The following statement contains a magic number: NetBitWriter.WriteByte((byte)(source >> 24)' 8' destination' destinationBitOffset);
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteUInt64,The following statement contains a magic number: NetBitWriter.WriteByte((byte)(source >> 24)' 8' destination' destinationBitOffset);
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteUInt64,The following statement contains a magic number: destinationBitOffset += 8;
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteUInt64,The following statement contains a magic number: numberOfBits -= 8;
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteUInt64,The following statement contains a magic number: if (numberOfBits <= 8)  			{  				NetBitWriter.WriteByte((byte)(source >> 32)' numberOfBits' destination' destinationBitOffset);  				return returnValue;  			}
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteUInt64,The following statement contains a magic number: if (numberOfBits <= 8)  			{  				NetBitWriter.WriteByte((byte)(source >> 32)' numberOfBits' destination' destinationBitOffset);  				return returnValue;  			}
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteUInt64,The following statement contains a magic number: NetBitWriter.WriteByte((byte)(source >> 32)' 8' destination' destinationBitOffset);
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteUInt64,The following statement contains a magic number: NetBitWriter.WriteByte((byte)(source >> 32)' 8' destination' destinationBitOffset);
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteUInt64,The following statement contains a magic number: destinationBitOffset += 8;
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteUInt64,The following statement contains a magic number: numberOfBits -= 8;
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteUInt64,The following statement contains a magic number: if (numberOfBits <= 8)  			{  				NetBitWriter.WriteByte((byte)(source >> 40)' numberOfBits' destination' destinationBitOffset);  				return returnValue;  			}
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteUInt64,The following statement contains a magic number: if (numberOfBits <= 8)  			{  				NetBitWriter.WriteByte((byte)(source >> 40)' numberOfBits' destination' destinationBitOffset);  				return returnValue;  			}
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteUInt64,The following statement contains a magic number: NetBitWriter.WriteByte((byte)(source >> 40)' 8' destination' destinationBitOffset);
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteUInt64,The following statement contains a magic number: NetBitWriter.WriteByte((byte)(source >> 40)' 8' destination' destinationBitOffset);
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteUInt64,The following statement contains a magic number: destinationBitOffset += 8;
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteUInt64,The following statement contains a magic number: numberOfBits -= 8;
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteUInt64,The following statement contains a magic number: if (numberOfBits <= 8)  			{  				NetBitWriter.WriteByte((byte)(source >> 48)' numberOfBits' destination' destinationBitOffset);  				return returnValue;  			}
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteUInt64,The following statement contains a magic number: if (numberOfBits <= 8)  			{  				NetBitWriter.WriteByte((byte)(source >> 48)' numberOfBits' destination' destinationBitOffset);  				return returnValue;  			}
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteUInt64,The following statement contains a magic number: NetBitWriter.WriteByte((byte)(source >> 48)' 8' destination' destinationBitOffset);
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteUInt64,The following statement contains a magic number: NetBitWriter.WriteByte((byte)(source >> 48)' 8' destination' destinationBitOffset);
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteUInt64,The following statement contains a magic number: destinationBitOffset += 8;
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteUInt64,The following statement contains a magic number: numberOfBits -= 8;
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteUInt64,The following statement contains a magic number: if (numberOfBits <= 8)  			{  				NetBitWriter.WriteByte((byte)(source >> 56)' numberOfBits' destination' destinationBitOffset);  				return returnValue;  			}
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteUInt64,The following statement contains a magic number: if (numberOfBits <= 8)  			{  				NetBitWriter.WriteByte((byte)(source >> 56)' numberOfBits' destination' destinationBitOffset);  				return returnValue;  			}
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteUInt64,The following statement contains a magic number: NetBitWriter.WriteByte((byte)(source >> 56)' 8' destination' destinationBitOffset);
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteUInt64,The following statement contains a magic number: NetBitWriter.WriteByte((byte)(source >> 56)' 8' destination' destinationBitOffset);
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteUInt64,The following statement contains a magic number: destinationBitOffset += 8;
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteUInt64,The following statement contains a magic number: numberOfBits -= 8;
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,WriteVariableUInt32,The following statement contains a magic number: while (num1 >= 0x80)  			{  				intoBuffer[offset + retval] = (byte)(num1 | 0x80);  				num1 = num1 >> 7;  				retval++;  			}
Magic Number,Lidgren.Network,NetBitWriter,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBitWriter.cs,ReadVariableUInt32,The following statement contains a magic number: while (true)  			{  				if (num2 == 0x23)  					throw new FormatException("Bad 7-bit encoded integer");    				byte num3 = buffer[offset++];  				num1 |= (num3 & 0x7f) << (num2 & 0x1f);  				num2 += 7;  				if ((num3 & 0x80) == 0)  					return (uint)num1;  			}
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,NetBuffer,The following statement contains a magic number: foreach (MethodInfo mi in methods)  			{  				if (mi.GetParameters().Length == 0 && mi.Name.StartsWith("Read"' StringComparison.InvariantCulture) && mi.Name.Substring(4) == mi.ReturnType.Name)  				{  					s_readMethods[mi.ReturnType] = mi;  				}  			}
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,PeekByte,The following statement contains a magic number: NetException.Assert(m_bitLength - m_readPosition >= 8' c_readOverflowError);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,PeekByte,The following statement contains a magic number: byte retval = NetBitWriter.ReadByte(m_data' 8' m_readPosition);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,PeekSByte,The following statement contains a magic number: NetException.Assert(m_bitLength - m_readPosition >= 8' c_readOverflowError);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,PeekSByte,The following statement contains a magic number: byte retval = NetBitWriter.ReadByte(m_data' 8' m_readPosition);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,PeekBytes,The following statement contains a magic number: NetException.Assert(m_bitLength - m_readPosition >= (numberOfBytes * 8)' c_readOverflowError);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,PeekBytes,The following statement contains a magic number: NetException.Assert(m_bitLength - m_readPosition >= (numberOfBytes * 8)' c_readOverflowError);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,PeekInt16,The following statement contains a magic number: NetException.Assert(m_bitLength - m_readPosition >= 16' c_readOverflowError);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,PeekInt16,The following statement contains a magic number: uint retval = NetBitWriter.ReadUInt16(m_data' 16' m_readPosition);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,PeekUInt16,The following statement contains a magic number: NetException.Assert(m_bitLength - m_readPosition >= 16' c_readOverflowError);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,PeekUInt16,The following statement contains a magic number: uint retval = NetBitWriter.ReadUInt16(m_data' 16' m_readPosition);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,PeekInt32,The following statement contains a magic number: NetException.Assert(m_bitLength - m_readPosition >= 32' c_readOverflowError);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,PeekInt32,The following statement contains a magic number: uint retval = NetBitWriter.ReadUInt32(m_data' 32' m_readPosition);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,PeekInt32,The following statement contains a magic number: NetException.Assert((numberOfBits > 0 && numberOfBits <= 32)' "ReadInt() can only read between 1 and 32 bits");
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,PeekInt32,The following statement contains a magic number: if (numberOfBits == 32)  				return (int)retval;
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,PeekInt32,The following statement contains a magic number: unchecked  			{  				uint mask = ((uint)-1) >> (33 - numberOfBits);  				uint tmp = (retval & mask) + 1;  				return -((int)tmp);  			}
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,PeekUInt32,The following statement contains a magic number: NetException.Assert(m_bitLength - m_readPosition >= 32' c_readOverflowError);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,PeekUInt32,The following statement contains a magic number: uint retval = NetBitWriter.ReadUInt32(m_data' 32' m_readPosition);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,PeekUInt32,The following statement contains a magic number: NetException.Assert((numberOfBits > 0 && numberOfBits <= 32)' "ReadUInt() can only read between 1 and 32 bits");
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,PeekUInt64,The following statement contains a magic number: NetException.Assert(m_bitLength - m_readPosition >= 64' c_readOverflowError);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,PeekUInt64,The following statement contains a magic number: ulong low = NetBitWriter.ReadUInt32(m_data' 32' m_readPosition);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,PeekUInt64,The following statement contains a magic number: ulong high = NetBitWriter.ReadUInt32(m_data' 32' m_readPosition + 32);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,PeekUInt64,The following statement contains a magic number: ulong high = NetBitWriter.ReadUInt32(m_data' 32' m_readPosition + 32);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,PeekUInt64,The following statement contains a magic number: ulong retval = low + (high << 32);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,PeekInt64,The following statement contains a magic number: NetException.Assert(m_bitLength - m_readPosition >= 64' c_readOverflowError);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,PeekUInt64,The following statement contains a magic number: NetException.Assert((numberOfBits > 0 && numberOfBits <= 64)' "ReadUInt() can only read between 1 and 64 bits");
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,PeekUInt64,The following statement contains a magic number: if (numberOfBits <= 32)  			{  				retval = (ulong)NetBitWriter.ReadUInt32(m_data' numberOfBits' m_readPosition);  			}  			else  			{  				retval = NetBitWriter.ReadUInt32(m_data' 32' m_readPosition);  				retval |= NetBitWriter.ReadUInt32(m_data' numberOfBits - 32' m_readPosition) << 32;  			}
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,PeekUInt64,The following statement contains a magic number: if (numberOfBits <= 32)  			{  				retval = (ulong)NetBitWriter.ReadUInt32(m_data' numberOfBits' m_readPosition);  			}  			else  			{  				retval = NetBitWriter.ReadUInt32(m_data' 32' m_readPosition);  				retval |= NetBitWriter.ReadUInt32(m_data' numberOfBits - 32' m_readPosition) << 32;  			}
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,PeekUInt64,The following statement contains a magic number: if (numberOfBits <= 32)  			{  				retval = (ulong)NetBitWriter.ReadUInt32(m_data' numberOfBits' m_readPosition);  			}  			else  			{  				retval = NetBitWriter.ReadUInt32(m_data' 32' m_readPosition);  				retval |= NetBitWriter.ReadUInt32(m_data' numberOfBits - 32' m_readPosition) << 32;  			}
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,PeekUInt64,The following statement contains a magic number: if (numberOfBits <= 32)  			{  				retval = (ulong)NetBitWriter.ReadUInt32(m_data' numberOfBits' m_readPosition);  			}  			else  			{  				retval = NetBitWriter.ReadUInt32(m_data' 32' m_readPosition);  				retval |= NetBitWriter.ReadUInt32(m_data' numberOfBits - 32' m_readPosition) << 32;  			}
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,PeekInt64,The following statement contains a magic number: NetException.Assert(((numberOfBits > 0) && (numberOfBits < 65))' "ReadInt64(bits) can only read between 1 and 64 bits");
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,PeekSingle,The following statement contains a magic number: NetException.Assert(m_bitLength - m_readPosition >= 32' c_readOverflowError);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,PeekSingle,The following statement contains a magic number: if ((m_readPosition & 7) == 0) // read directly  			{  				float retval = BitConverter.ToSingle(m_data' m_readPosition >> 3);  				return retval;  			}
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,PeekSingle,The following statement contains a magic number: if ((m_readPosition & 7) == 0) // read directly  			{  				float retval = BitConverter.ToSingle(m_data' m_readPosition >> 3);  				return retval;  			}
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,PeekSingle,The following statement contains a magic number: byte[] bytes = PeekBytes(4);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,PeekDouble,The following statement contains a magic number: NetException.Assert(m_bitLength - m_readPosition >= 64' c_readOverflowError);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,PeekDouble,The following statement contains a magic number: if ((m_readPosition & 7) == 0) // read directly  			{  				// read directly  				double retval = BitConverter.ToDouble(m_data' m_readPosition >> 3);  				return retval;  			}
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,PeekDouble,The following statement contains a magic number: if ((m_readPosition & 7) == 0) // read directly  			{  				// read directly  				double retval = BitConverter.ToDouble(m_data' m_readPosition >> 3);  				return retval;  			}
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,PeekDouble,The following statement contains a magic number: byte[] bytes = PeekBytes(8);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadByte,The following statement contains a magic number: NetException.Assert(m_bitLength - m_readPosition >= 8' c_readOverflowError);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadByte,The following statement contains a magic number: byte retval = NetBitWriter.ReadByte(m_data' 8' m_readPosition);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadByte,The following statement contains a magic number: m_readPosition += 8;
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadByte,The following statement contains a magic number: if (m_bitLength - m_readPosition < 8)  			{  				result = 0;  				return false;  			}
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadByte,The following statement contains a magic number: result = NetBitWriter.ReadByte(m_data' 8' m_readPosition);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadByte,The following statement contains a magic number: m_readPosition += 8;
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadSByte,The following statement contains a magic number: NetException.Assert(m_bitLength - m_readPosition >= 8' c_readOverflowError);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadSByte,The following statement contains a magic number: byte retval = NetBitWriter.ReadByte(m_data' 8' m_readPosition);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadSByte,The following statement contains a magic number: m_readPosition += 8;
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadByte,The following statement contains a magic number: NetException.Assert(numberOfBits > 0 && numberOfBits <= 8' "ReadByte(bits) can only read between 1 and 8 bits");
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadBytes,The following statement contains a magic number: NetException.Assert(m_bitLength - m_readPosition + 7 >= (numberOfBytes * 8)' c_readOverflowError);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadBytes,The following statement contains a magic number: NetException.Assert(m_bitLength - m_readPosition + 7 >= (numberOfBytes * 8)' c_readOverflowError);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadBytes,The following statement contains a magic number: m_readPosition += (8 * numberOfBytes);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadBytes,The following statement contains a magic number: if (m_bitLength - m_readPosition + 7 < (numberOfBytes * 8))  			{  				result = null;  				return false;  			}
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadBytes,The following statement contains a magic number: if (m_bitLength - m_readPosition + 7 < (numberOfBytes * 8))  			{  				result = null;  				return false;  			}
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadBytes,The following statement contains a magic number: m_readPosition += (8 * numberOfBytes);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadBytes,The following statement contains a magic number: NetException.Assert(m_bitLength - m_readPosition + 7 >= (numberOfBytes * 8)' c_readOverflowError);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadBytes,The following statement contains a magic number: NetException.Assert(m_bitLength - m_readPosition + 7 >= (numberOfBytes * 8)' c_readOverflowError);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadBytes,The following statement contains a magic number: m_readPosition += (8 * numberOfBytes);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadBits,The following statement contains a magic number: int numberOfWholeBytes = numberOfBits / 8;
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadBits,The following statement contains a magic number: int extraBits = numberOfBits - (numberOfWholeBytes * 8);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadBits,The following statement contains a magic number: m_readPosition += (8 * numberOfWholeBytes);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadInt16,The following statement contains a magic number: NetException.Assert(m_bitLength - m_readPosition >= 16' c_readOverflowError);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadInt16,The following statement contains a magic number: uint retval = NetBitWriter.ReadUInt16(m_data' 16' m_readPosition);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadInt16,The following statement contains a magic number: m_readPosition += 16;
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadUInt16,The following statement contains a magic number: NetException.Assert(m_bitLength - m_readPosition >= 16' c_readOverflowError);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadUInt16,The following statement contains a magic number: uint retval = NetBitWriter.ReadUInt16(m_data' 16' m_readPosition);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadUInt16,The following statement contains a magic number: m_readPosition += 16;
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadInt32,The following statement contains a magic number: NetException.Assert(m_bitLength - m_readPosition >= 32' c_readOverflowError);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadInt32,The following statement contains a magic number: uint retval = NetBitWriter.ReadUInt32(m_data' 32' m_readPosition);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadInt32,The following statement contains a magic number: m_readPosition += 32;
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadInt32,The following statement contains a magic number: if (m_bitLength - m_readPosition < 32)  			{  				result = 0;  				return false;  			}
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadInt32,The following statement contains a magic number: result = (Int32)NetBitWriter.ReadUInt32(m_data' 32' m_readPosition);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadInt32,The following statement contains a magic number: m_readPosition += 32;
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadInt32,The following statement contains a magic number: NetException.Assert(numberOfBits > 0 && numberOfBits <= 32' "ReadInt32(bits) can only read between 1 and 32 bits");
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadInt32,The following statement contains a magic number: if (numberOfBits == 32)  				return (int)retval;
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadInt32,The following statement contains a magic number: unchecked  			{  				uint mask = ((uint)-1) >> (33 - numberOfBits);  				uint tmp = (retval & mask) + 1;  				return -((int)tmp);  			}
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadUInt32,The following statement contains a magic number: NetException.Assert(m_bitLength - m_readPosition >= 32' c_readOverflowError);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadUInt32,The following statement contains a magic number: uint retval = NetBitWriter.ReadUInt32(m_data' 32' m_readPosition);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadUInt32,The following statement contains a magic number: m_readPosition += 32;
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadUInt32,The following statement contains a magic number: if (m_bitLength - m_readPosition < 32)  			{  				result = 0;  				return false;  			}
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadUInt32,The following statement contains a magic number: result = NetBitWriter.ReadUInt32(m_data' 32' m_readPosition);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadUInt32,The following statement contains a magic number: m_readPosition += 32;
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadUInt32,The following statement contains a magic number: NetException.Assert(numberOfBits > 0 && numberOfBits <= 32' "ReadUInt32(bits) can only read between 1 and 32 bits");
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadUInt64,The following statement contains a magic number: NetException.Assert(m_bitLength - m_readPosition >= 64' c_readOverflowError);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadUInt64,The following statement contains a magic number: ulong low = NetBitWriter.ReadUInt32(m_data' 32' m_readPosition);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadUInt64,The following statement contains a magic number: m_readPosition += 32;
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadUInt64,The following statement contains a magic number: ulong high = NetBitWriter.ReadUInt32(m_data' 32' m_readPosition);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadUInt64,The following statement contains a magic number: ulong retval = low + (high << 32);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadUInt64,The following statement contains a magic number: m_readPosition += 32;
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadInt64,The following statement contains a magic number: NetException.Assert(m_bitLength - m_readPosition >= 64' c_readOverflowError);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadUInt64,The following statement contains a magic number: NetException.Assert(numberOfBits > 0 && numberOfBits <= 64' "ReadUInt64(bits) can only read between 1 and 64 bits");
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadUInt64,The following statement contains a magic number: if (numberOfBits <= 32)  			{  				retval = (ulong)NetBitWriter.ReadUInt32(m_data' numberOfBits' m_readPosition);  			}  			else  			{  				retval = NetBitWriter.ReadUInt32(m_data' 32' m_readPosition);  				retval |= NetBitWriter.ReadUInt32(m_data' numberOfBits - 32' m_readPosition) << 32;  			}
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadUInt64,The following statement contains a magic number: if (numberOfBits <= 32)  			{  				retval = (ulong)NetBitWriter.ReadUInt32(m_data' numberOfBits' m_readPosition);  			}  			else  			{  				retval = NetBitWriter.ReadUInt32(m_data' 32' m_readPosition);  				retval |= NetBitWriter.ReadUInt32(m_data' numberOfBits - 32' m_readPosition) << 32;  			}
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadUInt64,The following statement contains a magic number: if (numberOfBits <= 32)  			{  				retval = (ulong)NetBitWriter.ReadUInt32(m_data' numberOfBits' m_readPosition);  			}  			else  			{  				retval = NetBitWriter.ReadUInt32(m_data' 32' m_readPosition);  				retval |= NetBitWriter.ReadUInt32(m_data' numberOfBits - 32' m_readPosition) << 32;  			}
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadUInt64,The following statement contains a magic number: if (numberOfBits <= 32)  			{  				retval = (ulong)NetBitWriter.ReadUInt32(m_data' numberOfBits' m_readPosition);  			}  			else  			{  				retval = NetBitWriter.ReadUInt32(m_data' 32' m_readPosition);  				retval |= NetBitWriter.ReadUInt32(m_data' numberOfBits - 32' m_readPosition) << 32;  			}
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadInt64,The following statement contains a magic number: NetException.Assert(((numberOfBits > 0) && (numberOfBits <= 64))' "ReadInt64(bits) can only read between 1 and 64 bits");
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadSingle,The following statement contains a magic number: NetException.Assert(m_bitLength - m_readPosition >= 32' c_readOverflowError);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadSingle,The following statement contains a magic number: if ((m_readPosition & 7) == 0) // read directly  			{  				float retval = BitConverter.ToSingle(m_data' m_readPosition >> 3);  				m_readPosition += 32;  				return retval;  			}
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadSingle,The following statement contains a magic number: if ((m_readPosition & 7) == 0) // read directly  			{  				float retval = BitConverter.ToSingle(m_data' m_readPosition >> 3);  				m_readPosition += 32;  				return retval;  			}
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadSingle,The following statement contains a magic number: if ((m_readPosition & 7) == 0) // read directly  			{  				float retval = BitConverter.ToSingle(m_data' m_readPosition >> 3);  				m_readPosition += 32;  				return retval;  			}
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadSingle,The following statement contains a magic number: byte[] bytes = ReadBytes(4);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadSingle,The following statement contains a magic number: if (m_bitLength - m_readPosition < 32)  			{  				result = 0.0f;  				return false;  			}
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadSingle,The following statement contains a magic number: if ((m_readPosition & 7) == 0) // read directly  			{  				result = BitConverter.ToSingle(m_data' m_readPosition >> 3);  				m_readPosition += 32;  				return true;  			}
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadSingle,The following statement contains a magic number: if ((m_readPosition & 7) == 0) // read directly  			{  				result = BitConverter.ToSingle(m_data' m_readPosition >> 3);  				m_readPosition += 32;  				return true;  			}
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadSingle,The following statement contains a magic number: if ((m_readPosition & 7) == 0) // read directly  			{  				result = BitConverter.ToSingle(m_data' m_readPosition >> 3);  				m_readPosition += 32;  				return true;  			}
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadSingle,The following statement contains a magic number: byte[] bytes = ReadBytes(4);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadDouble,The following statement contains a magic number: NetException.Assert(m_bitLength - m_readPosition >= 64' c_readOverflowError);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadDouble,The following statement contains a magic number: if ((m_readPosition & 7) == 0) // read directly  			{  				// read directly  				double retval = BitConverter.ToDouble(m_data' m_readPosition >> 3);  				m_readPosition += 64;  				return retval;  			}
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadDouble,The following statement contains a magic number: if ((m_readPosition & 7) == 0) // read directly  			{  				// read directly  				double retval = BitConverter.ToDouble(m_data' m_readPosition >> 3);  				m_readPosition += 64;  				return retval;  			}
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadDouble,The following statement contains a magic number: if ((m_readPosition & 7) == 0) // read directly  			{  				// read directly  				double retval = BitConverter.ToDouble(m_data' m_readPosition >> 3);  				m_readPosition += 64;  				return retval;  			}
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadDouble,The following statement contains a magic number: byte[] bytes = ReadBytes(8);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadVariableUInt32,The following statement contains a magic number: while (true)  			{  				byte num3 = this.ReadByte();  				num1 |= (num3 & 0x7f) << num2;  				num2 += 7;  				if ((num3 & 0x80) == 0)  					return (uint)num1;  			}
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadVariableUInt32,The following statement contains a magic number: while (true)  			{  				byte num3;  				if (ReadByte(out num3) == false)  				{  					result = 0;  					return false;  				}  				num1 |= (num3 & 0x7f) << num2;  				num2 += 7;  				if ((num3 & 0x80) == 0)  				{  					result = (uint)num1;  					return true;  				}  			}
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadVariableUInt64,The following statement contains a magic number: while (true)  			{  				//if (num2 == 0x23)  				//	throw new FormatException("Bad 7-bit encoded integer");    				byte num3 = this.ReadByte();  				num1 |= ((UInt64)num3 & 0x7f) << num2;  				num2 += 7;  				if ((num3 & 0x80) == 0)  					return num1;  			}
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadString,The following statement contains a magic number: NetException.Assert(m_bitLength - m_readPosition >= (byteLen * 8)' c_readOverflowError);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadString,The following statement contains a magic number: if ((m_readPosition & 7) == 0)  			{  				// read directly  				string retval = System.Text.Encoding.UTF8.GetString(m_data' m_readPosition >> 3' byteLen);  				m_readPosition += (8 * byteLen);  				return retval;  			}
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadString,The following statement contains a magic number: if ((m_readPosition & 7) == 0)  			{  				// read directly  				string retval = System.Text.Encoding.UTF8.GetString(m_data' m_readPosition >> 3' byteLen);  				m_readPosition += (8 * byteLen);  				return retval;  			}
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadString,The following statement contains a magic number: if ((m_readPosition & 7) == 0)  			{  				// read directly  				string retval = System.Text.Encoding.UTF8.GetString(m_data' m_readPosition >> 3' byteLen);  				m_readPosition += (8 * byteLen);  				return retval;  			}
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadString,The following statement contains a magic number: if (m_bitLength - m_readPosition < (byteLen * 8))  			{  				result = String.Empty;  				return false;  			}
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadString,The following statement contains a magic number: if ((m_readPosition & 7) == 0)  			{  				// read directly  				result = System.Text.Encoding.UTF8.GetString(m_data' m_readPosition >> 3' (int)byteLen);  				m_readPosition += (8 * (int)byteLen);  				return true;  			}
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadString,The following statement contains a magic number: if ((m_readPosition & 7) == 0)  			{  				// read directly  				result = System.Text.Encoding.UTF8.GetString(m_data' m_readPosition >> 3' (int)byteLen);  				m_readPosition += (8 * (int)byteLen);  				return true;  			}
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadString,The following statement contains a magic number: if ((m_readPosition & 7) == 0)  			{  				// read directly  				result = System.Text.Encoding.UTF8.GetString(m_data' m_readPosition >> 3' (int)byteLen);  				m_readPosition += (8 * (int)byteLen);  				return true;  			}
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,SkipPadBits,The following statement contains a magic number: m_readPosition = ((m_readPosition + 7) >> 3) * 8;
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,SkipPadBits,The following statement contains a magic number: m_readPosition = ((m_readPosition + 7) >> 3) * 8;
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,SkipPadBits,The following statement contains a magic number: m_readPosition = ((m_readPosition + 7) >> 3) * 8;
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadPadBits,The following statement contains a magic number: m_readPosition = ((m_readPosition + 7) >> 3) * 8;
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadPadBits,The following statement contains a magic number: m_readPosition = ((m_readPosition + 7) >> 3) * 8;
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,ReadPadBits,The following statement contains a magic number: m_readPosition = ((m_readPosition + 7) >> 3) * 8;
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,EnsureBufferSize,The following statement contains a magic number: int byteLen = ((numberOfBits + 7) >> 3);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,EnsureBufferSize,The following statement contains a magic number: int byteLen = ((numberOfBits + 7) >> 3);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,InternalEnsureBufferSize,The following statement contains a magic number: int byteLen = ((numberOfBits + 7) >> 3);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,InternalEnsureBufferSize,The following statement contains a magic number: int byteLen = ((numberOfBits + 7) >> 3);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,Write,The following statement contains a magic number: EnsureBufferSize(m_bitLength + 8);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,Write,The following statement contains a magic number: NetBitWriter.WriteByte(source' 8' m_data' m_bitLength);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,Write,The following statement contains a magic number: m_bitLength += 8;
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,Write,The following statement contains a magic number: EnsureBufferSize(m_bitLength + 8);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,Write,The following statement contains a magic number: NetBitWriter.WriteByte((byte)source' 8' m_data' m_bitLength);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,Write,The following statement contains a magic number: m_bitLength += 8;
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,Write,The following statement contains a magic number: NetException.Assert((numberOfBits > 0 && numberOfBits <= 8)' "Write(byte' numberOfBits) can only write between 1 and 8 bits");
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,Write,The following statement contains a magic number: int bits = source.Length * 8;
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,Write,The following statement contains a magic number: int bits = numberOfBytes * 8;
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,Write,The following statement contains a magic number: EnsureBufferSize(m_bitLength + 16);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,Write,The following statement contains a magic number: NetBitWriter.WriteUInt16(source' 16' m_data' m_bitLength);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,Write,The following statement contains a magic number: m_bitLength += 16;
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,Write,The following statement contains a magic number: NetException.Assert((numberOfBits > 0 && numberOfBits <= 16)' "Write(ushort' numberOfBits) can only write between 1 and 16 bits");
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,Write,The following statement contains a magic number: EnsureBufferSize(m_bitLength + 16);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,Write,The following statement contains a magic number: NetBitWriter.WriteUInt16((ushort)source' 16' m_data' m_bitLength);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,Write,The following statement contains a magic number: m_bitLength += 16;
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,Write,The following statement contains a magic number: EnsureBufferSize(m_bitLength + 32);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,Write,The following statement contains a magic number: NetBitWriter.WriteUInt32((UInt32)source' 32' m_data' m_bitLength);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,Write,The following statement contains a magic number: m_bitLength += 32;
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,Write,The following statement contains a magic number: EnsureBufferSize(m_bitLength + 32);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,Write,The following statement contains a magic number: NetBitWriter.WriteUInt32(source' 32' m_data' m_bitLength);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,Write,The following statement contains a magic number: m_bitLength += 32;
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,Write,The following statement contains a magic number: NetException.Assert((numberOfBits > 0 && numberOfBits <= 32)' "Write(uint' numberOfBits) can only write between 1 and 32 bits");
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,Write,The following statement contains a magic number: NetException.Assert((numberOfBits > 0 && numberOfBits <= 32)' "Write(int' numberOfBits) can only write between 1 and 32 bits");
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,Write,The following statement contains a magic number: if (numberOfBits != 32)  			{  				// make first bit sign  				int signBit = 1 << (numberOfBits - 1);  				if (source < 0)  					source = (-source - 1) | signBit;  				else  					source &= (~signBit);  			}
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,Write,The following statement contains a magic number: EnsureBufferSize(m_bitLength + 64);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,Write,The following statement contains a magic number: NetBitWriter.WriteUInt64(source' 64' m_data' m_bitLength);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,Write,The following statement contains a magic number: m_bitLength += 64;
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,Write,The following statement contains a magic number: EnsureBufferSize(m_bitLength + 64);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,Write,The following statement contains a magic number: NetBitWriter.WriteUInt64(usource' 64' m_data' m_bitLength);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,Write,The following statement contains a magic number: m_bitLength += 64;
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,WriteVariableUInt32,The following statement contains a magic number: while (num1 >= 0x80)  			{  				this.Write((byte)(num1 | 0x80));  				num1 = num1 >> 7;  				retval++;  			}
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,WriteVariableInt32,The following statement contains a magic number: uint zigzag = (uint)(value << 1) ^ (uint)(value >> 31);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,WriteVariableInt64,The following statement contains a magic number: ulong zigzag = (ulong)(value << 1) ^ (ulong)(value >> 63);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,WriteVariableUInt64,The following statement contains a magic number: while (num1 >= 0x80)  			{  				this.Write((byte)(num1 | 0x80));  				num1 = num1 >> 7;  				retval++;  			}
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,Write,The following statement contains a magic number: if (string.IsNullOrEmpty(source))  			{  				EnsureBufferSize(m_bitLength + 8);  				WriteVariableUInt32(0);  				return;  			}
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,Write,The following statement contains a magic number: EnsureBufferSize(m_bitLength + 8 + (bytes.Length * 8));
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,Write,The following statement contains a magic number: EnsureBufferSize(m_bitLength + 8 + (bytes.Length * 8));
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,WritePadBits,The following statement contains a magic number: m_bitLength = ((m_bitLength + 7) >> 3) * 8;
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,WritePadBits,The following statement contains a magic number: m_bitLength = ((m_bitLength + 7) >> 3) * 8;
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,WritePadBits,The following statement contains a magic number: m_bitLength = ((m_bitLength + 7) >> 3) * 8;
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,Write,The following statement contains a magic number: EnsureBufferSize(m_bitLength + (buffer.LengthBytes * 8));
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,Write,The following statement contains a magic number: int bitsInLastByte = (buffer.m_bitLength % 8);
Magic Number,Lidgren.Network,NetBuffer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBuffer.cs,Write,The following statement contains a magic number: if (bitsInLastByte != 0)  			{  				int excessBits = 8 - bitsInLastByte;  				m_bitLength -= excessBits;  			}
Magic Number,Lidgren.Network,NetConnection,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetConnection.cs,NetConnection,The following statement contains a magic number: m_queuedOutgoingAcks = new NetQueue<NetTuple<NetMessageType' int>>(4);
Magic Number,Lidgren.Network,NetConnection,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetConnection.cs,NetConnection,The following statement contains a magic number: m_queuedIncomingAcks = new NetQueue<NetTuple<NetMessageType' int>>(4);
Magic Number,Lidgren.Network,NetConnection,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetConnection.cs,SetStatus,The following statement contains a magic number: if (m_peerConfiguration.IsMessageTypeEnabled(NetIncomingMessageType.StatusChanged))  			{  				NetIncomingMessage info = m_peer.CreateIncomingMessage(NetIncomingMessageType.StatusChanged' 4 + reason.Length + (reason.Length > 126 ? 2 : 1));  				info.m_senderConnection = this;  				info.m_senderEndPoint = m_remoteEndPoint;  				info.Write((byte)m_status);  				info.Write(reason);  				m_peer.ReleaseMessage(info);  			}  			else  			{  				// app dont want those messages' update visible status immediately  				m_visibleStatus = m_status;  			}
Magic Number,Lidgren.Network,NetConnection,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetConnection.cs,SetStatus,The following statement contains a magic number: if (m_peerConfiguration.IsMessageTypeEnabled(NetIncomingMessageType.StatusChanged))  			{  				NetIncomingMessage info = m_peer.CreateIncomingMessage(NetIncomingMessageType.StatusChanged' 4 + reason.Length + (reason.Length > 126 ? 2 : 1));  				info.m_senderConnection = this;  				info.m_senderEndPoint = m_remoteEndPoint;  				info.Write((byte)m_status);  				info.Write(reason);  				m_peer.ReleaseMessage(info);  			}  			else  			{  				// app dont want those messages' update visible status immediately  				m_visibleStatus = m_status;  			}
Magic Number,Lidgren.Network,NetConnection,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetConnection.cs,SetStatus,The following statement contains a magic number: if (m_peerConfiguration.IsMessageTypeEnabled(NetIncomingMessageType.StatusChanged))  			{  				NetIncomingMessage info = m_peer.CreateIncomingMessage(NetIncomingMessageType.StatusChanged' 4 + reason.Length + (reason.Length > 126 ? 2 : 1));  				info.m_senderConnection = this;  				info.m_senderEndPoint = m_remoteEndPoint;  				info.Write((byte)m_status);  				info.Write(reason);  				m_peer.ReleaseMessage(info);  			}  			else  			{  				// app dont want those messages' update visible status immediately  				m_visibleStatus = m_status;  			}
Magic Number,Lidgren.Network,NetConnection,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetConnection.cs,Heartbeat,The following statement contains a magic number: if ((frameCounter % m_messageCoalesceFrames) == 0) // coalesce a few frames  			{  				//  				// send ack messages  				//  				while (m_queuedOutgoingAcks.Count > 0)  				{  					int acks = (mtu - (m_sendBufferWritePtr + 5)) / 3; // 3 bytes per actual ack  					if (acks > m_queuedOutgoingAcks.Count)  						acks = m_queuedOutgoingAcks.Count;    					NetException.Assert(acks > 0);    					m_sendBufferNumMessages++;    					// write acks header  					sendBuffer[m_sendBufferWritePtr++] = (byte)NetMessageType.Acknowledge;  					sendBuffer[m_sendBufferWritePtr++] = 0; // no sequence number  					sendBuffer[m_sendBufferWritePtr++] = 0; // no sequence number  					int len = (acks * 3) * 8; // bits  					sendBuffer[m_sendBufferWritePtr++] = (byte)len;  					sendBuffer[m_sendBufferWritePtr++] = (byte)(len >> 8);    					// write acks  					for (int i = 0; i < acks; i++)  					{  						NetTuple<NetMessageType' int> tuple;  						m_queuedOutgoingAcks.TryDequeue(out tuple);    						//m_peer.LogVerbose("Sending ack for " + tuple.Item1 + "#" + tuple.Item2);    						sendBuffer[m_sendBufferWritePtr++] = (byte)tuple.Item1;  						sendBuffer[m_sendBufferWritePtr++] = (byte)tuple.Item2;  						sendBuffer[m_sendBufferWritePtr++] = (byte)(tuple.Item2 >> 8);  					}    					if (m_queuedOutgoingAcks.Count > 0)  					{  						// send packet and go for another round of acks  						NetException.Assert(m_sendBufferWritePtr > 0 && m_sendBufferNumMessages > 0);  						m_peer.SendPacket(m_sendBufferWritePtr' m_remoteEndPoint' m_sendBufferNumMessages' out connectionReset);  						m_statistics.PacketSent(m_sendBufferWritePtr' 1);  						m_sendBufferWritePtr = 0;  						m_sendBufferNumMessages = 0;  					}  				}    				//  				// Parse incoming acks (may trigger resends)  				//  				NetTuple<NetMessageType' int> incAck;  				while (m_queuedIncomingAcks.TryDequeue(out incAck))  				{  					//m_peer.LogVerbose("Received ack for " + acktp + "#" + seqNr);  					NetSenderChannelBase chan = m_sendChannels[(int)incAck.Item1 - 1];  					if (chan == null)  						chan = CreateSenderChannel(incAck.Item1);  					chan.ReceiveAcknowledge(now' incAck.Item2);  				}  			}
Magic Number,Lidgren.Network,NetConnection,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetConnection.cs,Heartbeat,The following statement contains a magic number: if ((frameCounter % m_messageCoalesceFrames) == 0) // coalesce a few frames  			{  				//  				// send ack messages  				//  				while (m_queuedOutgoingAcks.Count > 0)  				{  					int acks = (mtu - (m_sendBufferWritePtr + 5)) / 3; // 3 bytes per actual ack  					if (acks > m_queuedOutgoingAcks.Count)  						acks = m_queuedOutgoingAcks.Count;    					NetException.Assert(acks > 0);    					m_sendBufferNumMessages++;    					// write acks header  					sendBuffer[m_sendBufferWritePtr++] = (byte)NetMessageType.Acknowledge;  					sendBuffer[m_sendBufferWritePtr++] = 0; // no sequence number  					sendBuffer[m_sendBufferWritePtr++] = 0; // no sequence number  					int len = (acks * 3) * 8; // bits  					sendBuffer[m_sendBufferWritePtr++] = (byte)len;  					sendBuffer[m_sendBufferWritePtr++] = (byte)(len >> 8);    					// write acks  					for (int i = 0; i < acks; i++)  					{  						NetTuple<NetMessageType' int> tuple;  						m_queuedOutgoingAcks.TryDequeue(out tuple);    						//m_peer.LogVerbose("Sending ack for " + tuple.Item1 + "#" + tuple.Item2);    						sendBuffer[m_sendBufferWritePtr++] = (byte)tuple.Item1;  						sendBuffer[m_sendBufferWritePtr++] = (byte)tuple.Item2;  						sendBuffer[m_sendBufferWritePtr++] = (byte)(tuple.Item2 >> 8);  					}    					if (m_queuedOutgoingAcks.Count > 0)  					{  						// send packet and go for another round of acks  						NetException.Assert(m_sendBufferWritePtr > 0 && m_sendBufferNumMessages > 0);  						m_peer.SendPacket(m_sendBufferWritePtr' m_remoteEndPoint' m_sendBufferNumMessages' out connectionReset);  						m_statistics.PacketSent(m_sendBufferWritePtr' 1);  						m_sendBufferWritePtr = 0;  						m_sendBufferNumMessages = 0;  					}  				}    				//  				// Parse incoming acks (may trigger resends)  				//  				NetTuple<NetMessageType' int> incAck;  				while (m_queuedIncomingAcks.TryDequeue(out incAck))  				{  					//m_peer.LogVerbose("Received ack for " + acktp + "#" + seqNr);  					NetSenderChannelBase chan = m_sendChannels[(int)incAck.Item1 - 1];  					if (chan == null)  						chan = CreateSenderChannel(incAck.Item1);  					chan.ReceiveAcknowledge(now' incAck.Item2);  				}  			}
Magic Number,Lidgren.Network,NetConnection,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetConnection.cs,Heartbeat,The following statement contains a magic number: if ((frameCounter % m_messageCoalesceFrames) == 0) // coalesce a few frames  			{  				//  				// send ack messages  				//  				while (m_queuedOutgoingAcks.Count > 0)  				{  					int acks = (mtu - (m_sendBufferWritePtr + 5)) / 3; // 3 bytes per actual ack  					if (acks > m_queuedOutgoingAcks.Count)  						acks = m_queuedOutgoingAcks.Count;    					NetException.Assert(acks > 0);    					m_sendBufferNumMessages++;    					// write acks header  					sendBuffer[m_sendBufferWritePtr++] = (byte)NetMessageType.Acknowledge;  					sendBuffer[m_sendBufferWritePtr++] = 0; // no sequence number  					sendBuffer[m_sendBufferWritePtr++] = 0; // no sequence number  					int len = (acks * 3) * 8; // bits  					sendBuffer[m_sendBufferWritePtr++] = (byte)len;  					sendBuffer[m_sendBufferWritePtr++] = (byte)(len >> 8);    					// write acks  					for (int i = 0; i < acks; i++)  					{  						NetTuple<NetMessageType' int> tuple;  						m_queuedOutgoingAcks.TryDequeue(out tuple);    						//m_peer.LogVerbose("Sending ack for " + tuple.Item1 + "#" + tuple.Item2);    						sendBuffer[m_sendBufferWritePtr++] = (byte)tuple.Item1;  						sendBuffer[m_sendBufferWritePtr++] = (byte)tuple.Item2;  						sendBuffer[m_sendBufferWritePtr++] = (byte)(tuple.Item2 >> 8);  					}    					if (m_queuedOutgoingAcks.Count > 0)  					{  						// send packet and go for another round of acks  						NetException.Assert(m_sendBufferWritePtr > 0 && m_sendBufferNumMessages > 0);  						m_peer.SendPacket(m_sendBufferWritePtr' m_remoteEndPoint' m_sendBufferNumMessages' out connectionReset);  						m_statistics.PacketSent(m_sendBufferWritePtr' 1);  						m_sendBufferWritePtr = 0;  						m_sendBufferNumMessages = 0;  					}  				}    				//  				// Parse incoming acks (may trigger resends)  				//  				NetTuple<NetMessageType' int> incAck;  				while (m_queuedIncomingAcks.TryDequeue(out incAck))  				{  					//m_peer.LogVerbose("Received ack for " + acktp + "#" + seqNr);  					NetSenderChannelBase chan = m_sendChannels[(int)incAck.Item1 - 1];  					if (chan == null)  						chan = CreateSenderChannel(incAck.Item1);  					chan.ReceiveAcknowledge(now' incAck.Item2);  				}  			}
Magic Number,Lidgren.Network,NetConnection,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetConnection.cs,Heartbeat,The following statement contains a magic number: if ((frameCounter % m_messageCoalesceFrames) == 0) // coalesce a few frames  			{  				//  				// send ack messages  				//  				while (m_queuedOutgoingAcks.Count > 0)  				{  					int acks = (mtu - (m_sendBufferWritePtr + 5)) / 3; // 3 bytes per actual ack  					if (acks > m_queuedOutgoingAcks.Count)  						acks = m_queuedOutgoingAcks.Count;    					NetException.Assert(acks > 0);    					m_sendBufferNumMessages++;    					// write acks header  					sendBuffer[m_sendBufferWritePtr++] = (byte)NetMessageType.Acknowledge;  					sendBuffer[m_sendBufferWritePtr++] = 0; // no sequence number  					sendBuffer[m_sendBufferWritePtr++] = 0; // no sequence number  					int len = (acks * 3) * 8; // bits  					sendBuffer[m_sendBufferWritePtr++] = (byte)len;  					sendBuffer[m_sendBufferWritePtr++] = (byte)(len >> 8);    					// write acks  					for (int i = 0; i < acks; i++)  					{  						NetTuple<NetMessageType' int> tuple;  						m_queuedOutgoingAcks.TryDequeue(out tuple);    						//m_peer.LogVerbose("Sending ack for " + tuple.Item1 + "#" + tuple.Item2);    						sendBuffer[m_sendBufferWritePtr++] = (byte)tuple.Item1;  						sendBuffer[m_sendBufferWritePtr++] = (byte)tuple.Item2;  						sendBuffer[m_sendBufferWritePtr++] = (byte)(tuple.Item2 >> 8);  					}    					if (m_queuedOutgoingAcks.Count > 0)  					{  						// send packet and go for another round of acks  						NetException.Assert(m_sendBufferWritePtr > 0 && m_sendBufferNumMessages > 0);  						m_peer.SendPacket(m_sendBufferWritePtr' m_remoteEndPoint' m_sendBufferNumMessages' out connectionReset);  						m_statistics.PacketSent(m_sendBufferWritePtr' 1);  						m_sendBufferWritePtr = 0;  						m_sendBufferNumMessages = 0;  					}  				}    				//  				// Parse incoming acks (may trigger resends)  				//  				NetTuple<NetMessageType' int> incAck;  				while (m_queuedIncomingAcks.TryDequeue(out incAck))  				{  					//m_peer.LogVerbose("Received ack for " + acktp + "#" + seqNr);  					NetSenderChannelBase chan = m_sendChannels[(int)incAck.Item1 - 1];  					if (chan == null)  						chan = CreateSenderChannel(incAck.Item1);  					chan.ReceiveAcknowledge(now' incAck.Item2);  				}  			}
Magic Number,Lidgren.Network,NetConnection,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetConnection.cs,Heartbeat,The following statement contains a magic number: if ((frameCounter % m_messageCoalesceFrames) == 0) // coalesce a few frames  			{  				//  				// send ack messages  				//  				while (m_queuedOutgoingAcks.Count > 0)  				{  					int acks = (mtu - (m_sendBufferWritePtr + 5)) / 3; // 3 bytes per actual ack  					if (acks > m_queuedOutgoingAcks.Count)  						acks = m_queuedOutgoingAcks.Count;    					NetException.Assert(acks > 0);    					m_sendBufferNumMessages++;    					// write acks header  					sendBuffer[m_sendBufferWritePtr++] = (byte)NetMessageType.Acknowledge;  					sendBuffer[m_sendBufferWritePtr++] = 0; // no sequence number  					sendBuffer[m_sendBufferWritePtr++] = 0; // no sequence number  					int len = (acks * 3) * 8; // bits  					sendBuffer[m_sendBufferWritePtr++] = (byte)len;  					sendBuffer[m_sendBufferWritePtr++] = (byte)(len >> 8);    					// write acks  					for (int i = 0; i < acks; i++)  					{  						NetTuple<NetMessageType' int> tuple;  						m_queuedOutgoingAcks.TryDequeue(out tuple);    						//m_peer.LogVerbose("Sending ack for " + tuple.Item1 + "#" + tuple.Item2);    						sendBuffer[m_sendBufferWritePtr++] = (byte)tuple.Item1;  						sendBuffer[m_sendBufferWritePtr++] = (byte)tuple.Item2;  						sendBuffer[m_sendBufferWritePtr++] = (byte)(tuple.Item2 >> 8);  					}    					if (m_queuedOutgoingAcks.Count > 0)  					{  						// send packet and go for another round of acks  						NetException.Assert(m_sendBufferWritePtr > 0 && m_sendBufferNumMessages > 0);  						m_peer.SendPacket(m_sendBufferWritePtr' m_remoteEndPoint' m_sendBufferNumMessages' out connectionReset);  						m_statistics.PacketSent(m_sendBufferWritePtr' 1);  						m_sendBufferWritePtr = 0;  						m_sendBufferNumMessages = 0;  					}  				}    				//  				// Parse incoming acks (may trigger resends)  				//  				NetTuple<NetMessageType' int> incAck;  				while (m_queuedIncomingAcks.TryDequeue(out incAck))  				{  					//m_peer.LogVerbose("Received ack for " + acktp + "#" + seqNr);  					NetSenderChannelBase chan = m_sendChannels[(int)incAck.Item1 - 1];  					if (chan == null)  						chan = CreateSenderChannel(incAck.Item1);  					chan.ReceiveAcknowledge(now' incAck.Item2);  				}  			}
Magic Number,Lidgren.Network,NetConnection,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetConnection.cs,Heartbeat,The following statement contains a magic number: if ((frameCounter % m_messageCoalesceFrames) == 0) // coalesce a few frames  			{  				//  				// send ack messages  				//  				while (m_queuedOutgoingAcks.Count > 0)  				{  					int acks = (mtu - (m_sendBufferWritePtr + 5)) / 3; // 3 bytes per actual ack  					if (acks > m_queuedOutgoingAcks.Count)  						acks = m_queuedOutgoingAcks.Count;    					NetException.Assert(acks > 0);    					m_sendBufferNumMessages++;    					// write acks header  					sendBuffer[m_sendBufferWritePtr++] = (byte)NetMessageType.Acknowledge;  					sendBuffer[m_sendBufferWritePtr++] = 0; // no sequence number  					sendBuffer[m_sendBufferWritePtr++] = 0; // no sequence number  					int len = (acks * 3) * 8; // bits  					sendBuffer[m_sendBufferWritePtr++] = (byte)len;  					sendBuffer[m_sendBufferWritePtr++] = (byte)(len >> 8);    					// write acks  					for (int i = 0; i < acks; i++)  					{  						NetTuple<NetMessageType' int> tuple;  						m_queuedOutgoingAcks.TryDequeue(out tuple);    						//m_peer.LogVerbose("Sending ack for " + tuple.Item1 + "#" + tuple.Item2);    						sendBuffer[m_sendBufferWritePtr++] = (byte)tuple.Item1;  						sendBuffer[m_sendBufferWritePtr++] = (byte)tuple.Item2;  						sendBuffer[m_sendBufferWritePtr++] = (byte)(tuple.Item2 >> 8);  					}    					if (m_queuedOutgoingAcks.Count > 0)  					{  						// send packet and go for another round of acks  						NetException.Assert(m_sendBufferWritePtr > 0 && m_sendBufferNumMessages > 0);  						m_peer.SendPacket(m_sendBufferWritePtr' m_remoteEndPoint' m_sendBufferNumMessages' out connectionReset);  						m_statistics.PacketSent(m_sendBufferWritePtr' 1);  						m_sendBufferWritePtr = 0;  						m_sendBufferNumMessages = 0;  					}  				}    				//  				// Parse incoming acks (may trigger resends)  				//  				NetTuple<NetMessageType' int> incAck;  				while (m_queuedIncomingAcks.TryDequeue(out incAck))  				{  					//m_peer.LogVerbose("Received ack for " + acktp + "#" + seqNr);  					NetSenderChannelBase chan = m_sendChannels[(int)incAck.Item1 - 1];  					if (chan == null)  						chan = CreateSenderChannel(incAck.Item1);  					chan.ReceiveAcknowledge(now' incAck.Item2);  				}  			}
Magic Number,Lidgren.Network,NetConnection,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetConnection.cs,ReceivedLibraryMessage,The following statement contains a magic number: switch (tp)  			{  				case NetMessageType.Disconnect:  					NetIncomingMessage msg = m_peer.SetupReadHelperMessage(ptr' payloadLength);  					ExecuteDisconnect(msg.ReadString()' false);  					break;  				case NetMessageType.Acknowledge:  					for (int i = 0; i < payloadLength; i+=3)  					{  						NetMessageType acktp = (NetMessageType)m_peer.m_receiveBuffer[ptr++]; // netmessagetype  						int seqNr = m_peer.m_receiveBuffer[ptr++];  						seqNr |= (m_peer.m_receiveBuffer[ptr++] << 8);    						// need to enqueue this and handle it in the netconnection heartbeat; so be able to send resends together with normal sends  						m_queuedIncomingAcks.Enqueue(new NetTuple<NetMessageType' int>(acktp' seqNr));  					}  					break;  				case NetMessageType.Ping:  					int pingNr = m_peer.m_receiveBuffer[ptr++];  					SendPong(pingNr);  					break;  				case NetMessageType.Pong:  					NetIncomingMessage pmsg = m_peer.SetupReadHelperMessage(ptr' payloadLength);  					int pongNr = pmsg.ReadByte();  					float remoteSendTime = pmsg.ReadSingle();  					ReceivedPong(now' pongNr' remoteSendTime);  					break;  				case NetMessageType.ExpandMTURequest:  					SendMTUSuccess(payloadLength);  					break;  				case NetMessageType.ExpandMTUSuccess:  					NetIncomingMessage emsg = m_peer.SetupReadHelperMessage(ptr' payloadLength);  					int size = emsg.ReadInt32();  					HandleExpandMTUSuccess(now' size);  					break;  				case NetMessageType.NatIntroduction:  					// Unusual situation where server is actually already known' but got a nat introduction - oh well' lets handle it as usual  					m_peer.HandleNatIntroduction(ptr);  					break;  				default:  					m_peer.LogWarning("Connection received unhandled library message: " + tp);  					break;  			}
Magic Number,Lidgren.Network,NetConnection,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetConnection.cs,ReceivedLibraryMessage,The following statement contains a magic number: switch (tp)  			{  				case NetMessageType.Disconnect:  					NetIncomingMessage msg = m_peer.SetupReadHelperMessage(ptr' payloadLength);  					ExecuteDisconnect(msg.ReadString()' false);  					break;  				case NetMessageType.Acknowledge:  					for (int i = 0; i < payloadLength; i+=3)  					{  						NetMessageType acktp = (NetMessageType)m_peer.m_receiveBuffer[ptr++]; // netmessagetype  						int seqNr = m_peer.m_receiveBuffer[ptr++];  						seqNr |= (m_peer.m_receiveBuffer[ptr++] << 8);    						// need to enqueue this and handle it in the netconnection heartbeat; so be able to send resends together with normal sends  						m_queuedIncomingAcks.Enqueue(new NetTuple<NetMessageType' int>(acktp' seqNr));  					}  					break;  				case NetMessageType.Ping:  					int pingNr = m_peer.m_receiveBuffer[ptr++];  					SendPong(pingNr);  					break;  				case NetMessageType.Pong:  					NetIncomingMessage pmsg = m_peer.SetupReadHelperMessage(ptr' payloadLength);  					int pongNr = pmsg.ReadByte();  					float remoteSendTime = pmsg.ReadSingle();  					ReceivedPong(now' pongNr' remoteSendTime);  					break;  				case NetMessageType.ExpandMTURequest:  					SendMTUSuccess(payloadLength);  					break;  				case NetMessageType.ExpandMTUSuccess:  					NetIncomingMessage emsg = m_peer.SetupReadHelperMessage(ptr' payloadLength);  					int size = emsg.ReadInt32();  					HandleExpandMTUSuccess(now' size);  					break;  				case NetMessageType.NatIntroduction:  					// Unusual situation where server is actually already known' but got a nat introduction - oh well' lets handle it as usual  					m_peer.HandleNatIntroduction(ptr);  					break;  				default:  					m_peer.LogWarning("Connection received unhandled library message: " + tp);  					break;  			}
Magic Number,Lidgren.Network,NetConnection,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetConnection.cs,SendConnect,The following statement contains a magic number: int preAllocate = 13 + m_peerConfiguration.AppIdentifier.Length;
Magic Number,Lidgren.Network,NetConnection,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetConnection.cs,SendConnectResponse,The following statement contains a magic number: NetOutgoingMessage om = m_peer.CreateMessage(m_peerConfiguration.AppIdentifier.Length + 13 + (m_localHailMessage == null ? 0 : m_localHailMessage.LengthBytes));
Magic Number,Lidgren.Network,NetConnection,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetConnection.cs,WriteLocalHail,The following statement contains a magic number: if (m_localHailMessage != null)  			{  				byte[] hi = m_localHailMessage.Data;  				if (hi != null && hi.Length >= m_localHailMessage.LengthBytes)  				{  					if (om.LengthBytes + m_localHailMessage.LengthBytes > m_peerConfiguration.m_maximumTransmissionUnit - 10)  						throw new NetException("Hail message too large; can maximally be " + (m_peerConfiguration.m_maximumTransmissionUnit - 10 - om.LengthBytes));  					om.Write(m_localHailMessage.Data' 0' m_localHailMessage.LengthBytes);  				}  			}
Magic Number,Lidgren.Network,NetConnection,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetConnection.cs,WriteLocalHail,The following statement contains a magic number: if (m_localHailMessage != null)  			{  				byte[] hi = m_localHailMessage.Data;  				if (hi != null && hi.Length >= m_localHailMessage.LengthBytes)  				{  					if (om.LengthBytes + m_localHailMessage.LengthBytes > m_peerConfiguration.m_maximumTransmissionUnit - 10)  						throw new NetException("Hail message too large; can maximally be " + (m_peerConfiguration.m_maximumTransmissionUnit - 10 - om.LengthBytes));  					om.Write(m_localHailMessage.Data' 0' m_localHailMessage.LengthBytes);  				}  			}
Magic Number,Lidgren.Network,NetConnection,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetConnection.cs,SendConnectionEstablished,The following statement contains a magic number: NetOutgoingMessage om = m_peer.CreateMessage(4);
Magic Number,Lidgren.Network,NetConnection,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetConnection.cs,ReceivedHandshake,The following statement contains a magic number: switch (tp)  			{  				case NetMessageType.Connect:  					if (m_status == NetConnectionStatus.ReceivedInitiation)  					{  						// Whee! Server full has already been checked  						bool ok = ValidateHandshakeData(ptr' payloadLength' out hail);  						if (ok)  						{  							if (hail != null)  							{  								m_remoteHailMessage = m_peer.CreateIncomingMessage(NetIncomingMessageType.Data' hail);  								m_remoteHailMessage.LengthBits = (hail.Length * 8);  							}  							else  							{  								m_remoteHailMessage = null;   							}    							if (m_peerConfiguration.IsMessageTypeEnabled(NetIncomingMessageType.ConnectionApproval))  							{  								// ok' let's not add connection just yet  								NetIncomingMessage appMsg = m_peer.CreateIncomingMessage(NetIncomingMessageType.ConnectionApproval' (m_remoteHailMessage == null ? 0 : m_remoteHailMessage.LengthBytes));  								appMsg.m_receiveTime = now;  								appMsg.m_senderConnection = this;  								appMsg.m_senderEndPoint = this.m_remoteEndPoint;  								if (m_remoteHailMessage != null)  									appMsg.Write(m_remoteHailMessage.m_data' 0' m_remoteHailMessage.LengthBytes);  								SetStatus(NetConnectionStatus.RespondedAwaitingApproval' "Awaiting approval");  								m_peer.ReleaseMessage(appMsg);  								return;  							}    							SendConnectResponse((float)now' true);  						}  						return;  					}  					if (m_status == NetConnectionStatus.RespondedAwaitingApproval)  					{  						m_peer.LogWarning("Ignoring multiple Connect() most likely due to a delayed Approval");  						return;  					}  					if (m_status == NetConnectionStatus.RespondedConnect)  					{  						// our ConnectResponse must have been lost  						SendConnectResponse((float)now' true);  						return;  					}  					m_peer.LogDebug("Unhandled Connect: " + tp + "' status is " + m_status + " length: " + payloadLength);  					break;  				case NetMessageType.ConnectResponse:  					switch (m_status)  					{  						case NetConnectionStatus.InitiatedConnect:  							// awesome  							bool ok = ValidateHandshakeData(ptr' payloadLength' out hail);  							if (ok)  							{  								if (hail != null)  								{  									m_remoteHailMessage = m_peer.CreateIncomingMessage(NetIncomingMessageType.Data' hail);  									m_remoteHailMessage.LengthBits = (hail.Length * 8);  								}  								else  								{  									m_remoteHailMessage = null;  								}    								m_peer.AcceptConnection(this);  								SendConnectionEstablished();  								return;  							}  							break;  						case NetConnectionStatus.RespondedConnect:  							// hello' wtf?  							break;  						case NetConnectionStatus.Disconnecting:  						case NetConnectionStatus.Disconnected:  						case NetConnectionStatus.ReceivedInitiation:  						case NetConnectionStatus.None:  							// wtf? anyway' bye!  							break;  						case NetConnectionStatus.Connected:  							// my ConnectionEstablished must have been lost' send another one  							SendConnectionEstablished();  							return;  					}  					break;  				case NetMessageType.ConnectionEstablished:  					switch (m_status)  					{  						case NetConnectionStatus.Connected:  							// ok...  							break;  						case NetConnectionStatus.Disconnected:  						case NetConnectionStatus.Disconnecting:  						case NetConnectionStatus.None:  							// too bad' almost made it  							break;  						case NetConnectionStatus.ReceivedInitiation:  							// uh' a little premature... ignore  							break;  						case NetConnectionStatus.InitiatedConnect:  							// weird' should have been RespondedConnect...  							break;  						case NetConnectionStatus.RespondedConnect:  							// awesome  				  							NetIncomingMessage msg = m_peer.SetupReadHelperMessage(ptr' payloadLength);  							InitializeRemoteTimeOffset(msg.ReadSingle());    							m_peer.AcceptConnection(this);  							InitializePing();  							SetStatus(NetConnectionStatus.Connected' "Connected to " + NetUtility.ToHexString(m_remoteUniqueIdentifier));  							return;  					}  					break;    				case NetMessageType.Disconnect:  					// ouch  					string reason = "Ouch";  					try  					{  						NetIncomingMessage inc = m_peer.SetupReadHelperMessage(ptr' payloadLength);  						reason = inc.ReadString();  					}  					catch  					{  					}  					ExecuteDisconnect(reason' false);  					break;    				case NetMessageType.Discovery:  					m_peer.HandleIncomingDiscoveryRequest(now' m_remoteEndPoint' ptr' payloadLength);  					return;    				case NetMessageType.DiscoveryResponse:  					m_peer.HandleIncomingDiscoveryResponse(now' m_remoteEndPoint' ptr' payloadLength);  					return;    				case NetMessageType.Ping:  					// silently ignore  					return;    				default:  					m_peer.LogDebug("Unhandled type during handshake: " + tp + " length: " + payloadLength);  					break;  			}
Magic Number,Lidgren.Network,NetConnection,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetConnection.cs,ReceivedHandshake,The following statement contains a magic number: switch (tp)  			{  				case NetMessageType.Connect:  					if (m_status == NetConnectionStatus.ReceivedInitiation)  					{  						// Whee! Server full has already been checked  						bool ok = ValidateHandshakeData(ptr' payloadLength' out hail);  						if (ok)  						{  							if (hail != null)  							{  								m_remoteHailMessage = m_peer.CreateIncomingMessage(NetIncomingMessageType.Data' hail);  								m_remoteHailMessage.LengthBits = (hail.Length * 8);  							}  							else  							{  								m_remoteHailMessage = null;   							}    							if (m_peerConfiguration.IsMessageTypeEnabled(NetIncomingMessageType.ConnectionApproval))  							{  								// ok' let's not add connection just yet  								NetIncomingMessage appMsg = m_peer.CreateIncomingMessage(NetIncomingMessageType.ConnectionApproval' (m_remoteHailMessage == null ? 0 : m_remoteHailMessage.LengthBytes));  								appMsg.m_receiveTime = now;  								appMsg.m_senderConnection = this;  								appMsg.m_senderEndPoint = this.m_remoteEndPoint;  								if (m_remoteHailMessage != null)  									appMsg.Write(m_remoteHailMessage.m_data' 0' m_remoteHailMessage.LengthBytes);  								SetStatus(NetConnectionStatus.RespondedAwaitingApproval' "Awaiting approval");  								m_peer.ReleaseMessage(appMsg);  								return;  							}    							SendConnectResponse((float)now' true);  						}  						return;  					}  					if (m_status == NetConnectionStatus.RespondedAwaitingApproval)  					{  						m_peer.LogWarning("Ignoring multiple Connect() most likely due to a delayed Approval");  						return;  					}  					if (m_status == NetConnectionStatus.RespondedConnect)  					{  						// our ConnectResponse must have been lost  						SendConnectResponse((float)now' true);  						return;  					}  					m_peer.LogDebug("Unhandled Connect: " + tp + "' status is " + m_status + " length: " + payloadLength);  					break;  				case NetMessageType.ConnectResponse:  					switch (m_status)  					{  						case NetConnectionStatus.InitiatedConnect:  							// awesome  							bool ok = ValidateHandshakeData(ptr' payloadLength' out hail);  							if (ok)  							{  								if (hail != null)  								{  									m_remoteHailMessage = m_peer.CreateIncomingMessage(NetIncomingMessageType.Data' hail);  									m_remoteHailMessage.LengthBits = (hail.Length * 8);  								}  								else  								{  									m_remoteHailMessage = null;  								}    								m_peer.AcceptConnection(this);  								SendConnectionEstablished();  								return;  							}  							break;  						case NetConnectionStatus.RespondedConnect:  							// hello' wtf?  							break;  						case NetConnectionStatus.Disconnecting:  						case NetConnectionStatus.Disconnected:  						case NetConnectionStatus.ReceivedInitiation:  						case NetConnectionStatus.None:  							// wtf? anyway' bye!  							break;  						case NetConnectionStatus.Connected:  							// my ConnectionEstablished must have been lost' send another one  							SendConnectionEstablished();  							return;  					}  					break;  				case NetMessageType.ConnectionEstablished:  					switch (m_status)  					{  						case NetConnectionStatus.Connected:  							// ok...  							break;  						case NetConnectionStatus.Disconnected:  						case NetConnectionStatus.Disconnecting:  						case NetConnectionStatus.None:  							// too bad' almost made it  							break;  						case NetConnectionStatus.ReceivedInitiation:  							// uh' a little premature... ignore  							break;  						case NetConnectionStatus.InitiatedConnect:  							// weird' should have been RespondedConnect...  							break;  						case NetConnectionStatus.RespondedConnect:  							// awesome  				  							NetIncomingMessage msg = m_peer.SetupReadHelperMessage(ptr' payloadLength);  							InitializeRemoteTimeOffset(msg.ReadSingle());    							m_peer.AcceptConnection(this);  							InitializePing();  							SetStatus(NetConnectionStatus.Connected' "Connected to " + NetUtility.ToHexString(m_remoteUniqueIdentifier));  							return;  					}  					break;    				case NetMessageType.Disconnect:  					// ouch  					string reason = "Ouch";  					try  					{  						NetIncomingMessage inc = m_peer.SetupReadHelperMessage(ptr' payloadLength);  						reason = inc.ReadString();  					}  					catch  					{  					}  					ExecuteDisconnect(reason' false);  					break;    				case NetMessageType.Discovery:  					m_peer.HandleIncomingDiscoveryRequest(now' m_remoteEndPoint' ptr' payloadLength);  					return;    				case NetMessageType.DiscoveryResponse:  					m_peer.HandleIncomingDiscoveryResponse(now' m_remoteEndPoint' ptr' payloadLength);  					return;    				case NetMessageType.Ping:  					// silently ignore  					return;    				default:  					m_peer.LogDebug("Unhandled type during handshake: " + tp + " length: " + payloadLength);  					break;  			}
Magic Number,Lidgren.Network,NetConnection,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetConnection.cs,InitializeRemoteTimeOffset,The following statement contains a magic number: m_remoteTimeOffset = (remoteSendTime + (m_averageRoundtripTime / 2.0)) - NetTime.Now;
Magic Number,Lidgren.Network,NetConnection,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetConnection.cs,SendPong,The following statement contains a magic number: NetOutgoingMessage om = m_peer.CreateMessage(5);
Magic Number,Lidgren.Network,NetConnection,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetConnection.cs,ReceivedPong,The following statement contains a magic number: double diff = (remoteSendTime + (rtt / 2.0)) - now;
Magic Number,Lidgren.Network,NetConnection,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetConnection.cs,ReceivedPong,The following statement contains a magic number: if (m_peer.m_configuration.IsMessageTypeEnabled(NetIncomingMessageType.ConnectionLatencyUpdated))  			{  				NetIncomingMessage update = m_peer.CreateIncomingMessage(NetIncomingMessageType.ConnectionLatencyUpdated' 4);  				update.m_senderConnection = this;  				update.m_senderEndPoint = this.m_remoteEndPoint;  				update.Write(rtt);  				m_peer.ReleaseMessage(update);  			}
Magic Number,Lidgren.Network,NetConnection,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetConnection.cs,InitExpandMTU,The following statement contains a magic number: m_largestSuccessfulMTU = 512;
Magic Number,Lidgren.Network,NetConnection,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetConnection.cs,MTUExpansionHeartbeat,The following statement contains a magic number: if (now > m_lastSentMTUAttemptTime + m_peerConfiguration.ExpandMTUFrequency)  			{  				m_mtuAttemptFails++;  				if (m_mtuAttemptFails == 3)  				{  					FinalizeMTU(m_currentMTU);  					return;  				}    				// timed out; ie. failed  				m_smallestFailedMTU = m_lastSentMTUAttemptSize;  				ExpandMTU(now);  			}
Magic Number,Lidgren.Network,NetConnection,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetConnection.cs,SendMTUSuccess,The following statement contains a magic number: NetOutgoingMessage om = m_peer.CreateMessage(4);
Magic Number,Lidgren.Network,NetFragmentationHelper,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetFragmentationHelper.cs,WriteHeader,The following statement contains a magic number: while (num1 >= 0x80)  			{  				destination[ptr++] = (byte)(num1 | 0x80);  				num1 = num1 >> 7;  			}
Magic Number,Lidgren.Network,NetFragmentationHelper,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetFragmentationHelper.cs,WriteHeader,The following statement contains a magic number: while (num2 >= 0x80)  			{  				destination[ptr++] = (byte)(num2 | 0x80);  				num2 = num2 >> 7;  			}
Magic Number,Lidgren.Network,NetFragmentationHelper,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetFragmentationHelper.cs,WriteHeader,The following statement contains a magic number: while (num3 >= 0x80)  			{  				destination[ptr++] = (byte)(num3 | 0x80);  				num3 = num3 >> 7;  			}
Magic Number,Lidgren.Network,NetFragmentationHelper,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetFragmentationHelper.cs,WriteHeader,The following statement contains a magic number: while (num4 >= 0x80)  			{  				destination[ptr++] = (byte)(num4 | 0x80);  				num4 = num4 >> 7;  			}
Magic Number,Lidgren.Network,NetFragmentationHelper,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetFragmentationHelper.cs,ReadHeader,The following statement contains a magic number: while (true)  			{  				byte num3 = buffer[ptr++];  				num1 |= (num3 & 0x7f) << (num2 & 0x1f);  				num2 += 7;  				if ((num3 & 0x80) == 0)  				{  					group = num1;  					break;  				}  			}
Magic Number,Lidgren.Network,NetFragmentationHelper,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetFragmentationHelper.cs,ReadHeader,The following statement contains a magic number: while (true)  			{  				byte num3 = buffer[ptr++];  				num1 |= (num3 & 0x7f) << (num2 & 0x1f);  				num2 += 7;  				if ((num3 & 0x80) == 0)  				{  					totalBits = num1;  					break;  				}  			}
Magic Number,Lidgren.Network,NetFragmentationHelper,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetFragmentationHelper.cs,ReadHeader,The following statement contains a magic number: while (true)  			{  				byte num3 = buffer[ptr++];  				num1 |= (num3 & 0x7f) << (num2 & 0x1f);  				num2 += 7;  				if ((num3 & 0x80) == 0)  				{  					chunkByteSize = num1;  					break;  				}  			}
Magic Number,Lidgren.Network,NetFragmentationHelper,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetFragmentationHelper.cs,ReadHeader,The following statement contains a magic number: while (true)  			{  				byte num3 = buffer[ptr++];  				num1 |= (num3 & 0x7f) << (num2 & 0x1f);  				num2 += 7;  				if ((num3 & 0x80) == 0)  				{  					chunkNumber = num1;  					break;  				}  			}
Magic Number,Lidgren.Network,NetFragmentationHelper,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetFragmentationHelper.cs,GetFragmentationHeaderSize,The following statement contains a magic number: int len = 4;
Magic Number,Lidgren.Network,NetFragmentationHelper,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetFragmentationHelper.cs,GetFragmentationHeaderSize,The following statement contains a magic number: while (num1 >= 0x80)  			{  				len++;  				num1 = num1 >> 7;  			}
Magic Number,Lidgren.Network,NetFragmentationHelper,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetFragmentationHelper.cs,GetFragmentationHeaderSize,The following statement contains a magic number: uint num2 = (uint)(totalBytes * 8);
Magic Number,Lidgren.Network,NetFragmentationHelper,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetFragmentationHelper.cs,GetFragmentationHeaderSize,The following statement contains a magic number: while (num2 >= 0x80)  			{  				len++;  				num2 = num2 >> 7;  			}
Magic Number,Lidgren.Network,NetFragmentationHelper,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetFragmentationHelper.cs,GetFragmentationHeaderSize,The following statement contains a magic number: while (num3 >= 0x80)  			{  				len++;  				num3 = num3 >> 7;  			}
Magic Number,Lidgren.Network,NetFragmentationHelper,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetFragmentationHelper.cs,GetFragmentationHeaderSize,The following statement contains a magic number: while (num4 >= 0x80)  			{  				len++;  				num4 = num4 >> 7;  			}
Magic Number,Lidgren.Network,NetFragmentationHelper,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetFragmentationHelper.cs,GetBestChunkSize,The following statement contains a magic number: int tryChunkSize = mtu - NetConstants.HeaderByteSize - 4;
Magic Number,Lidgren.Network,NetPeer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetNatIntroduction.cs,Introduce,The following statement contains a magic number: NetOutgoingMessage msg = CreateMessage(10 + token.Length + 1);
Magic Number,Lidgren.Network,NetPeer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetNatIntroduction.cs,Introduce,The following statement contains a magic number: msg = CreateMessage(10 + token.Length + 1);
Magic Number,Lidgren.Network,NetPeer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetNatIntroduction.cs,HandleNatIntroduction,The following statement contains a magic number: NetIncomingMessage tmp = SetupReadHelperMessage(ptr' 1000);
Magic Number,Lidgren.Network,NetPeer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetNatIntroduction.cs,HandleNatPunch,The following statement contains a magic number: NetIncomingMessage tmp = SetupReadHelperMessage(ptr' 1000);
Magic Number,Lidgren.Network,NetPeer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetNatIntroduction.cs,HandleNatPunch,The following statement contains a magic number: NetIncomingMessage punchSuccess = CreateIncomingMessage(NetIncomingMessageType.NatIntroductionSuccess' 10);
Magic Number,Lidgren.Network,NetPeer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetNatIntroduction.cs,NetPeer,The following statement contains a magic number: m_releasedIncomingMessages = new NetQueue<NetIncomingMessage>(4);
Magic Number,Lidgren.Network,NetPeer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetNatIntroduction.cs,NetPeer,The following statement contains a magic number: m_unsentUnconnectedMessages = new NetQueue<NetTuple<IPEndPoint' NetOutgoingMessage>>(2);
Magic Number,Lidgren.Network,NetPeer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetNatIntroduction.cs,Start,The following statement contains a magic number: Thread.Sleep(50);
Magic Number,Lidgren.Network,NetPeer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetNatIntroduction.cs,SendFragmentedMessage,The following statement contains a magic number: int bitsPerChunk = bytesPerChunk * 8;
Magic Number,Lidgren.Network,NetPeer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetNatIntroduction.cs,SendFragmentedMessage,The following statement contains a magic number: for (int i = 0; i < numChunks; i++)  			{  				NetOutgoingMessage chunk = CreateMessage(mtu);    				chunk.m_bitLength = (bitsLeft > bitsPerChunk ? bitsPerChunk : bitsLeft);  				chunk.m_data = msg.m_data;  				chunk.m_fragmentGroup = group;  				chunk.m_fragmentGroupTotalBits = totalBytes * 8;  				chunk.m_fragmentChunkByteSize = bytesPerChunk;  				chunk.m_fragmentChunkNumber = i;    				NetException.Assert(chunk.m_bitLength != 0);  				NetException.Assert(chunk.GetEncodedSize() < mtu);    				Interlocked.Add(ref chunk.m_recyclingCount' recipients.Count);    				foreach (NetConnection recipient in recipients)  					recipient.EnqueueMessage(chunk' method' sequenceChannel);    				bitsLeft -= bitsPerChunk;  			}
Magic Number,Lidgren.Network,NetPeer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetNatIntroduction.cs,InitializeNetwork,The following statement contains a magic number: lock (m_initializeLock)  			{  				m_configuration.Lock();    				if (m_status == NetPeerStatus.Running)  					return;    				if (m_configuration.m_enableUPnP)  					m_upnp = new NetUPnP(this);    				InitializePools();    				m_releasedIncomingMessages.Clear();  				m_unsentUnconnectedMessages.Clear();  				m_handshakes.Clear();    				// bind to socket  				IPEndPoint iep = null;    				iep = new IPEndPoint(m_configuration.LocalAddress' m_configuration.Port);  				EndPoint ep = (EndPoint)iep;    				m_socket = new Socket(iep.AddressFamily' SocketType.Dgram' ProtocolType.Udp);  				m_socket.ReceiveBufferSize = m_configuration.ReceiveBufferSize;  				m_socket.SendBufferSize = m_configuration.SendBufferSize;  				m_socket.Blocking = false;  				m_socket.Bind(ep);    				try  				{  					const uint IOC_IN = 0x80000000;  					const uint IOC_VENDOR = 0x18000000;  					uint SIO_UDP_CONNRESET = IOC_IN | IOC_VENDOR | 12;  					m_socket.IOControl((int)SIO_UDP_CONNRESET' new byte[] { Convert.ToByte(false) }' null);  				}  				catch  				{  					// ignore; SIO_UDP_CONNRESET not supported on this platform  				}    				IPEndPoint boundEp = m_socket.LocalEndPoint as IPEndPoint;  				LogDebug("Socket bound to " + boundEp + ": " + m_socket.IsBound);  				m_listenPort = boundEp.Port;    				m_receiveBuffer = new byte[m_configuration.ReceiveBufferSize];  				m_sendBuffer = new byte[m_configuration.SendBufferSize];  				m_readHelperMessage = new NetIncomingMessage(NetIncomingMessageType.Error);  				m_readHelperMessage.m_data = m_receiveBuffer;    				byte[] macBytes = new byte[8];  				NetRandom.Instance.NextBytes(macBytes);    #if IS_MAC_AVAILABLE  				try  				{  					System.Net.NetworkInformation.PhysicalAddress pa = NetUtility.GetMacAddress();  					if (pa != null)  					{  						macBytes = pa.GetAddressBytes();  						LogVerbose("Mac address is " + NetUtility.ToHexString(macBytes));  					}  					else  					{  						LogWarning("Failed to get Mac address");  					}  				}  				catch (NotSupportedException)  				{  					// not supported; lets just keep the random bytes set above  				}  #endif  				byte[] epBytes = BitConverter.GetBytes(boundEp.GetHashCode());  				byte[] combined = new byte[epBytes.Length + macBytes.Length];  				Array.Copy(epBytes' 0' combined' 0' epBytes.Length);  				Array.Copy(macBytes' 0' combined' epBytes.Length' macBytes.Length);  				m_uniqueIdentifier = BitConverter.ToInt64(SHA1.Create().ComputeHash(combined)' 0);    				m_status = NetPeerStatus.Running;  			}
Magic Number,Lidgren.Network,NetPeer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetNatIntroduction.cs,InitializeNetwork,The following statement contains a magic number: lock (m_initializeLock)  			{  				m_configuration.Lock();    				if (m_status == NetPeerStatus.Running)  					return;    				if (m_configuration.m_enableUPnP)  					m_upnp = new NetUPnP(this);    				InitializePools();    				m_releasedIncomingMessages.Clear();  				m_unsentUnconnectedMessages.Clear();  				m_handshakes.Clear();    				// bind to socket  				IPEndPoint iep = null;    				iep = new IPEndPoint(m_configuration.LocalAddress' m_configuration.Port);  				EndPoint ep = (EndPoint)iep;    				m_socket = new Socket(iep.AddressFamily' SocketType.Dgram' ProtocolType.Udp);  				m_socket.ReceiveBufferSize = m_configuration.ReceiveBufferSize;  				m_socket.SendBufferSize = m_configuration.SendBufferSize;  				m_socket.Blocking = false;  				m_socket.Bind(ep);    				try  				{  					const uint IOC_IN = 0x80000000;  					const uint IOC_VENDOR = 0x18000000;  					uint SIO_UDP_CONNRESET = IOC_IN | IOC_VENDOR | 12;  					m_socket.IOControl((int)SIO_UDP_CONNRESET' new byte[] { Convert.ToByte(false) }' null);  				}  				catch  				{  					// ignore; SIO_UDP_CONNRESET not supported on this platform  				}    				IPEndPoint boundEp = m_socket.LocalEndPoint as IPEndPoint;  				LogDebug("Socket bound to " + boundEp + ": " + m_socket.IsBound);  				m_listenPort = boundEp.Port;    				m_receiveBuffer = new byte[m_configuration.ReceiveBufferSize];  				m_sendBuffer = new byte[m_configuration.SendBufferSize];  				m_readHelperMessage = new NetIncomingMessage(NetIncomingMessageType.Error);  				m_readHelperMessage.m_data = m_receiveBuffer;    				byte[] macBytes = new byte[8];  				NetRandom.Instance.NextBytes(macBytes);    #if IS_MAC_AVAILABLE  				try  				{  					System.Net.NetworkInformation.PhysicalAddress pa = NetUtility.GetMacAddress();  					if (pa != null)  					{  						macBytes = pa.GetAddressBytes();  						LogVerbose("Mac address is " + NetUtility.ToHexString(macBytes));  					}  					else  					{  						LogWarning("Failed to get Mac address");  					}  				}  				catch (NotSupportedException)  				{  					// not supported; lets just keep the random bytes set above  				}  #endif  				byte[] epBytes = BitConverter.GetBytes(boundEp.GetHashCode());  				byte[] combined = new byte[epBytes.Length + macBytes.Length];  				Array.Copy(epBytes' 0' combined' 0' epBytes.Length);  				Array.Copy(macBytes' 0' combined' epBytes.Length' macBytes.Length);  				m_uniqueIdentifier = BitConverter.ToInt64(SHA1.Create().ComputeHash(combined)' 0);    				m_status = NetPeerStatus.Running;  			}
Magic Number,Lidgren.Network,NetPeer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetNatIntroduction.cs,ExecutePeerShutdown,The following statement contains a magic number: Thread.Sleep(10);
Magic Number,Lidgren.Network,NetPeer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetNatIntroduction.cs,ExecutePeerShutdown,The following statement contains a magic number: lock (m_initializeLock)  			{  				try  				{  					if (m_socket != null)  					{  						try  						{  							m_socket.Shutdown(SocketShutdown.Receive);  						}  						catch { }  						m_socket.Close(2); // 2 seconds timeout  					}  					if (m_messageReceivedEvent != null)  					{  						m_messageReceivedEvent.Set();  						m_messageReceivedEvent.Close();  						m_messageReceivedEvent = null;  					}  				}  				finally  				{  					m_socket = null;  					m_status = NetPeerStatus.NotRunning;  					LogDebug("Shutdown complete");  				}    				m_receiveBuffer = null;  				m_sendBuffer = null;  				m_unsentUnconnectedMessages.Clear();  				m_connections.Clear();  				m_connectionLookup.Clear();  				m_handshakes.Clear();  			}
Magic Number,Lidgren.Network,NetPeer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetNatIntroduction.cs,Heartbeat,The following statement contains a magic number: int maxCHBpS = 1250 - m_connections.Count;
Magic Number,Lidgren.Network,NetPeer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetNatIntroduction.cs,Heartbeat,The following statement contains a magic number: if (maxCHBpS < 250)  				maxCHBpS = 250;
Magic Number,Lidgren.Network,NetPeer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetNatIntroduction.cs,Heartbeat,The following statement contains a magic number: if (maxCHBpS < 250)  				maxCHBpS = 250;
Magic Number,Lidgren.Network,NetPeer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetNatIntroduction.cs,Heartbeat,The following statement contains a magic number: if (delta > (1.0 / (double)maxCHBpS) || delta < 0.0) // max connection heartbeats/second max  			{  				m_frameCounter++;  				m_lastHeartbeat = dnow;    				// do handshake heartbeats  				if ((m_frameCounter % 3) == 0)  				{  					foreach (var kvp in m_handshakes)  					{  						NetConnection conn = kvp.Value as NetConnection;    						conn.UnconnectedHeartbeat(now);  						if (conn.m_status == NetConnectionStatus.Connected || conn.m_status == NetConnectionStatus.Disconnected)  						{  #if DEBUG  							// sanity check  							if (conn.m_status == NetConnectionStatus.Disconnected && m_handshakes.ContainsKey(conn.RemoteEndPoint))  							{  								LogWarning("Sanity fail! Handshakes list contained disconnected connection!");  								m_handshakes.Remove(conn.RemoteEndPoint);  							}  #endif  							break; // collection has been modified  						}  					}  				}    #if DEBUG  				SendDelayedPackets();  #endif    				// update m_executeFlushSendQueue  				if (m_configuration.m_autoFlushSendQueue)  					m_executeFlushSendQueue = true;    				// do connection heartbeats  				lock (m_connections)  				{  					foreach (NetConnection conn in m_connections)  					{  						conn.Heartbeat(now' m_frameCounter);  						if (conn.m_status == NetConnectionStatus.Disconnected)  						{  							//  							// remove connection  							//  							m_connections.Remove(conn);  							m_connectionLookup.Remove(conn.RemoteEndPoint);  							break; // can't continue iteration here  						}  					}  				}  				m_executeFlushSendQueue = false;    				// send unsent unconnected messages  				NetTuple<IPEndPoint' NetOutgoingMessage> unsent;  				while (m_unsentUnconnectedMessages.TryDequeue(out unsent))  				{  					NetOutgoingMessage om = unsent.Item2;    					bool connReset;  					int len = om.Encode(m_sendBuffer' 0' 0);  					SendPacket(len' unsent.Item1' 1' out connReset);    					Interlocked.Decrement(ref om.m_recyclingCount);  					if (om.m_recyclingCount <= 0)  						Recycle(om);  				}  			}
Magic Number,Lidgren.Network,NetPeer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetNatIntroduction.cs,Heartbeat,The following statement contains a magic number: if (!m_socket.Poll(1000' SelectMode.SelectRead)) // wait up to 1 ms for data to arrive  				return;
Magic Number,Lidgren.Network,NetPeer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetNatIntroduction.cs,Heartbeat,The following statement contains a magic number: do  			{  				int bytesReceived = 0;  				try  				{  					bytesReceived = m_socket.ReceiveFrom(m_receiveBuffer' 0' m_receiveBuffer.Length' SocketFlags.None' ref m_senderRemote);  				}  				catch (SocketException sx)  				{  					if (sx.SocketErrorCode == SocketError.ConnectionReset)  					{  						// connection reset by peer' aka connection forcibly closed aka "ICMP port unreachable"   						// we should shut down the connection; but m_senderRemote seemingly cannot be trusted' so which connection should we shut down?!  						// So' what to do?  						LogWarning("ConnectionReset");  						return;  					}    					LogWarning(sx.ToString());  					return;  				}    				if (bytesReceived < NetConstants.HeaderByteSize)  					return;    				//LogVerbose("Received " + bytesReceived + " bytes");    				IPEndPoint ipsender = (IPEndPoint)m_senderRemote;    				if (m_upnp != null && now < m_upnp.m_discoveryResponseDeadline)  				{  					// is this an UPnP response?  					try  					{  						string resp = System.Text.Encoding.ASCII.GetString(m_receiveBuffer' 0' bytesReceived);  						if (resp.Contains("upnp:rootdevice") || resp.Contains("UPnP/1.0"))  						{  							resp = resp.Substring(resp.ToLower().IndexOf("location:") + 9);  							resp = resp.Substring(0' resp.IndexOf("\r")).Trim();  							m_upnp.ExtractServiceUrl(resp);  							return;  						}  					}  					catch { }  				}    				NetConnection sender = null;  				m_connectionLookup.TryGetValue(ipsender' out sender);    				//  				// parse packet into messages  				//  				int numMessages = 0;  				int ptr = 0;  				while ((bytesReceived - ptr) >= NetConstants.HeaderByteSize)  				{  					// decode header  					//  8 bits - NetMessageType  					//  1 bit  - Fragment?  					// 15 bits - Sequence number  					// 16 bits - Payload length in bits    					numMessages++;    					NetMessageType tp = (NetMessageType)m_receiveBuffer[ptr++];    					byte low = m_receiveBuffer[ptr++];  					byte high = m_receiveBuffer[ptr++];    					bool isFragment = ((low & 1) == 1);  					ushort sequenceNumber = (ushort)((low >> 1) | (((int)high) << 7));    					ushort payloadBitLength = (ushort)(m_receiveBuffer[ptr++] | (m_receiveBuffer[ptr++] << 8));  					int payloadByteLength = NetUtility.BytesToHoldBits(payloadBitLength);    					if (bytesReceived - ptr < payloadByteLength)  					{  						LogWarning("Malformed packet; stated payload length " + payloadByteLength + "' remaining bytes " + (bytesReceived - ptr));  						return;  					}    					try  					{  						NetException.Assert(tp < NetMessageType.Unused1 || tp > NetMessageType.Unused29);    						if (tp >= NetMessageType.LibraryError)  						{  							if (sender != null)  								sender.ReceivedLibraryMessage(tp' ptr' payloadByteLength);  							else  								ReceivedUnconnectedLibraryMessage(dnow' ipsender' tp' ptr' payloadByteLength);  						}  						else  						{  							if (sender == null && !m_configuration.IsMessageTypeEnabled(NetIncomingMessageType.UnconnectedData))  								return; // dropping unconnected message since it's not enabled    							NetIncomingMessage msg = CreateIncomingMessage(NetIncomingMessageType.Data' payloadByteLength);  							msg.m_isFragment = isFragment;  							msg.m_receiveTime = dnow;  							msg.m_sequenceNumber = sequenceNumber;  							msg.m_receivedMessageType = tp;  							msg.m_senderConnection = sender;  							msg.m_senderEndPoint = ipsender;  							msg.m_bitLength = payloadBitLength;  							Buffer.BlockCopy(m_receiveBuffer' ptr' msg.m_data' 0' payloadByteLength);  							if (sender != null)  							{  								if (tp == NetMessageType.Unconnected)  								{  									// We're connected; but we can still send unconnected messages to this peer  									msg.m_incomingMessageType = NetIncomingMessageType.UnconnectedData;  									ReleaseMessage(msg);  								}  								else  								{  									// connected application (non-library) message  									sender.ReceivedMessage(msg);  								}  							}  							else  							{  								// at this point we know the message type is enabled  								// unconnected application (non-library) message  								msg.m_incomingMessageType = NetIncomingMessageType.UnconnectedData;  								ReleaseMessage(msg);  							}  						}  					}  					catch (Exception ex)  					{  						LogError("Packet parsing error: " + ex.Message + " from " + ipsender);  					}  					ptr += payloadByteLength;  				}    				m_statistics.PacketReceived(bytesReceived' numMessages);  				if (sender != null)  					sender.m_statistics.PacketReceived(bytesReceived' numMessages);    			} while (m_socket.Available > 0);
Magic Number,Lidgren.Network,NetPeer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetNatIntroduction.cs,Heartbeat,The following statement contains a magic number: do  			{  				int bytesReceived = 0;  				try  				{  					bytesReceived = m_socket.ReceiveFrom(m_receiveBuffer' 0' m_receiveBuffer.Length' SocketFlags.None' ref m_senderRemote);  				}  				catch (SocketException sx)  				{  					if (sx.SocketErrorCode == SocketError.ConnectionReset)  					{  						// connection reset by peer' aka connection forcibly closed aka "ICMP port unreachable"   						// we should shut down the connection; but m_senderRemote seemingly cannot be trusted' so which connection should we shut down?!  						// So' what to do?  						LogWarning("ConnectionReset");  						return;  					}    					LogWarning(sx.ToString());  					return;  				}    				if (bytesReceived < NetConstants.HeaderByteSize)  					return;    				//LogVerbose("Received " + bytesReceived + " bytes");    				IPEndPoint ipsender = (IPEndPoint)m_senderRemote;    				if (m_upnp != null && now < m_upnp.m_discoveryResponseDeadline)  				{  					// is this an UPnP response?  					try  					{  						string resp = System.Text.Encoding.ASCII.GetString(m_receiveBuffer' 0' bytesReceived);  						if (resp.Contains("upnp:rootdevice") || resp.Contains("UPnP/1.0"))  						{  							resp = resp.Substring(resp.ToLower().IndexOf("location:") + 9);  							resp = resp.Substring(0' resp.IndexOf("\r")).Trim();  							m_upnp.ExtractServiceUrl(resp);  							return;  						}  					}  					catch { }  				}    				NetConnection sender = null;  				m_connectionLookup.TryGetValue(ipsender' out sender);    				//  				// parse packet into messages  				//  				int numMessages = 0;  				int ptr = 0;  				while ((bytesReceived - ptr) >= NetConstants.HeaderByteSize)  				{  					// decode header  					//  8 bits - NetMessageType  					//  1 bit  - Fragment?  					// 15 bits - Sequence number  					// 16 bits - Payload length in bits    					numMessages++;    					NetMessageType tp = (NetMessageType)m_receiveBuffer[ptr++];    					byte low = m_receiveBuffer[ptr++];  					byte high = m_receiveBuffer[ptr++];    					bool isFragment = ((low & 1) == 1);  					ushort sequenceNumber = (ushort)((low >> 1) | (((int)high) << 7));    					ushort payloadBitLength = (ushort)(m_receiveBuffer[ptr++] | (m_receiveBuffer[ptr++] << 8));  					int payloadByteLength = NetUtility.BytesToHoldBits(payloadBitLength);    					if (bytesReceived - ptr < payloadByteLength)  					{  						LogWarning("Malformed packet; stated payload length " + payloadByteLength + "' remaining bytes " + (bytesReceived - ptr));  						return;  					}    					try  					{  						NetException.Assert(tp < NetMessageType.Unused1 || tp > NetMessageType.Unused29);    						if (tp >= NetMessageType.LibraryError)  						{  							if (sender != null)  								sender.ReceivedLibraryMessage(tp' ptr' payloadByteLength);  							else  								ReceivedUnconnectedLibraryMessage(dnow' ipsender' tp' ptr' payloadByteLength);  						}  						else  						{  							if (sender == null && !m_configuration.IsMessageTypeEnabled(NetIncomingMessageType.UnconnectedData))  								return; // dropping unconnected message since it's not enabled    							NetIncomingMessage msg = CreateIncomingMessage(NetIncomingMessageType.Data' payloadByteLength);  							msg.m_isFragment = isFragment;  							msg.m_receiveTime = dnow;  							msg.m_sequenceNumber = sequenceNumber;  							msg.m_receivedMessageType = tp;  							msg.m_senderConnection = sender;  							msg.m_senderEndPoint = ipsender;  							msg.m_bitLength = payloadBitLength;  							Buffer.BlockCopy(m_receiveBuffer' ptr' msg.m_data' 0' payloadByteLength);  							if (sender != null)  							{  								if (tp == NetMessageType.Unconnected)  								{  									// We're connected; but we can still send unconnected messages to this peer  									msg.m_incomingMessageType = NetIncomingMessageType.UnconnectedData;  									ReleaseMessage(msg);  								}  								else  								{  									// connected application (non-library) message  									sender.ReceivedMessage(msg);  								}  							}  							else  							{  								// at this point we know the message type is enabled  								// unconnected application (non-library) message  								msg.m_incomingMessageType = NetIncomingMessageType.UnconnectedData;  								ReleaseMessage(msg);  							}  						}  					}  					catch (Exception ex)  					{  						LogError("Packet parsing error: " + ex.Message + " from " + ipsender);  					}  					ptr += payloadByteLength;  				}    				m_statistics.PacketReceived(bytesReceived' numMessages);  				if (sender != null)  					sender.m_statistics.PacketReceived(bytesReceived' numMessages);    			} while (m_socket.Available > 0);
Magic Number,Lidgren.Network,NetPeer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetNatIntroduction.cs,Heartbeat,The following statement contains a magic number: do  			{  				int bytesReceived = 0;  				try  				{  					bytesReceived = m_socket.ReceiveFrom(m_receiveBuffer' 0' m_receiveBuffer.Length' SocketFlags.None' ref m_senderRemote);  				}  				catch (SocketException sx)  				{  					if (sx.SocketErrorCode == SocketError.ConnectionReset)  					{  						// connection reset by peer' aka connection forcibly closed aka "ICMP port unreachable"   						// we should shut down the connection; but m_senderRemote seemingly cannot be trusted' so which connection should we shut down?!  						// So' what to do?  						LogWarning("ConnectionReset");  						return;  					}    					LogWarning(sx.ToString());  					return;  				}    				if (bytesReceived < NetConstants.HeaderByteSize)  					return;    				//LogVerbose("Received " + bytesReceived + " bytes");    				IPEndPoint ipsender = (IPEndPoint)m_senderRemote;    				if (m_upnp != null && now < m_upnp.m_discoveryResponseDeadline)  				{  					// is this an UPnP response?  					try  					{  						string resp = System.Text.Encoding.ASCII.GetString(m_receiveBuffer' 0' bytesReceived);  						if (resp.Contains("upnp:rootdevice") || resp.Contains("UPnP/1.0"))  						{  							resp = resp.Substring(resp.ToLower().IndexOf("location:") + 9);  							resp = resp.Substring(0' resp.IndexOf("\r")).Trim();  							m_upnp.ExtractServiceUrl(resp);  							return;  						}  					}  					catch { }  				}    				NetConnection sender = null;  				m_connectionLookup.TryGetValue(ipsender' out sender);    				//  				// parse packet into messages  				//  				int numMessages = 0;  				int ptr = 0;  				while ((bytesReceived - ptr) >= NetConstants.HeaderByteSize)  				{  					// decode header  					//  8 bits - NetMessageType  					//  1 bit  - Fragment?  					// 15 bits - Sequence number  					// 16 bits - Payload length in bits    					numMessages++;    					NetMessageType tp = (NetMessageType)m_receiveBuffer[ptr++];    					byte low = m_receiveBuffer[ptr++];  					byte high = m_receiveBuffer[ptr++];    					bool isFragment = ((low & 1) == 1);  					ushort sequenceNumber = (ushort)((low >> 1) | (((int)high) << 7));    					ushort payloadBitLength = (ushort)(m_receiveBuffer[ptr++] | (m_receiveBuffer[ptr++] << 8));  					int payloadByteLength = NetUtility.BytesToHoldBits(payloadBitLength);    					if (bytesReceived - ptr < payloadByteLength)  					{  						LogWarning("Malformed packet; stated payload length " + payloadByteLength + "' remaining bytes " + (bytesReceived - ptr));  						return;  					}    					try  					{  						NetException.Assert(tp < NetMessageType.Unused1 || tp > NetMessageType.Unused29);    						if (tp >= NetMessageType.LibraryError)  						{  							if (sender != null)  								sender.ReceivedLibraryMessage(tp' ptr' payloadByteLength);  							else  								ReceivedUnconnectedLibraryMessage(dnow' ipsender' tp' ptr' payloadByteLength);  						}  						else  						{  							if (sender == null && !m_configuration.IsMessageTypeEnabled(NetIncomingMessageType.UnconnectedData))  								return; // dropping unconnected message since it's not enabled    							NetIncomingMessage msg = CreateIncomingMessage(NetIncomingMessageType.Data' payloadByteLength);  							msg.m_isFragment = isFragment;  							msg.m_receiveTime = dnow;  							msg.m_sequenceNumber = sequenceNumber;  							msg.m_receivedMessageType = tp;  							msg.m_senderConnection = sender;  							msg.m_senderEndPoint = ipsender;  							msg.m_bitLength = payloadBitLength;  							Buffer.BlockCopy(m_receiveBuffer' ptr' msg.m_data' 0' payloadByteLength);  							if (sender != null)  							{  								if (tp == NetMessageType.Unconnected)  								{  									// We're connected; but we can still send unconnected messages to this peer  									msg.m_incomingMessageType = NetIncomingMessageType.UnconnectedData;  									ReleaseMessage(msg);  								}  								else  								{  									// connected application (non-library) message  									sender.ReceivedMessage(msg);  								}  							}  							else  							{  								// at this point we know the message type is enabled  								// unconnected application (non-library) message  								msg.m_incomingMessageType = NetIncomingMessageType.UnconnectedData;  								ReleaseMessage(msg);  							}  						}  					}  					catch (Exception ex)  					{  						LogError("Packet parsing error: " + ex.Message + " from " + ipsender);  					}  					ptr += payloadByteLength;  				}    				m_statistics.PacketReceived(bytesReceived' numMessages);  				if (sender != null)  					sender.m_statistics.PacketReceived(bytesReceived' numMessages);    			} while (m_socket.Available > 0);
Magic Number,Lidgren.Network,NetPeer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetNatIntroduction.cs,HandleIncomingDiscoveryRequest,The following statement contains a magic number: if (m_configuration.IsMessageTypeEnabled(NetIncomingMessageType.DiscoveryRequest))  			{  				NetIncomingMessage dm = CreateIncomingMessage(NetIncomingMessageType.DiscoveryRequest' payloadByteLength);  				if (payloadByteLength > 0)  					Buffer.BlockCopy(m_receiveBuffer' ptr' dm.m_data' 0' payloadByteLength);  				dm.m_receiveTime = now;  				dm.m_bitLength = payloadByteLength * 8;  				dm.m_senderEndPoint = senderEndPoint;  				ReleaseMessage(dm);  			}
Magic Number,Lidgren.Network,NetPeer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetNatIntroduction.cs,HandleIncomingDiscoveryResponse,The following statement contains a magic number: if (m_configuration.IsMessageTypeEnabled(NetIncomingMessageType.DiscoveryResponse))  			{  				NetIncomingMessage dr = CreateIncomingMessage(NetIncomingMessageType.DiscoveryResponse' payloadByteLength);  				if (payloadByteLength > 0)  					Buffer.BlockCopy(m_receiveBuffer' ptr' dr.m_data' 0' payloadByteLength);  				dr.m_receiveTime = now;  				dr.m_bitLength = payloadByteLength * 8;  				dr.m_senderEndPoint = senderEndPoint;  				ReleaseMessage(dr);  			}
Magic Number,Lidgren.Network,NetPeer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetNatIntroduction.cs,SetupReadHelperMessage,The following statement contains a magic number: m_readHelperMessage.m_bitLength = (ptr + payloadLength) * 8;
Magic Number,Lidgren.Network,NetPeer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetNatIntroduction.cs,SetupReadHelperMessage,The following statement contains a magic number: m_readHelperMessage.m_readPosition = (ptr * 8);
Magic Number,Lidgren.Network,NetPeer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetNatIntroduction.cs,InitializePools,The following statement contains a magic number: if (m_configuration.UseMessageRecycling)  			{  				m_storagePool = new List<byte[]>(16);  				m_outgoingMessagesPool = new NetQueue<NetOutgoingMessage>(4);  				m_incomingMessagesPool = new NetQueue<NetIncomingMessage>(4);  			}  			else  			{  				m_storagePool = null;  				m_outgoingMessagesPool = null;  				m_incomingMessagesPool = null;  			}
Magic Number,Lidgren.Network,NetPeer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetNatIntroduction.cs,InitializePools,The following statement contains a magic number: if (m_configuration.UseMessageRecycling)  			{  				m_storagePool = new List<byte[]>(16);  				m_outgoingMessagesPool = new NetQueue<NetOutgoingMessage>(4);  				m_incomingMessagesPool = new NetQueue<NetIncomingMessage>(4);  			}  			else  			{  				m_storagePool = null;  				m_outgoingMessagesPool = null;  				m_incomingMessagesPool = null;  			}
Magic Number,Lidgren.Network,NetPeer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetNatIntroduction.cs,InitializePools,The following statement contains a magic number: if (m_configuration.UseMessageRecycling)  			{  				m_storagePool = new List<byte[]>(16);  				m_outgoingMessagesPool = new NetQueue<NetOutgoingMessage>(4);  				m_incomingMessagesPool = new NetQueue<NetIncomingMessage>(4);  			}  			else  			{  				m_storagePool = null;  				m_outgoingMessagesPool = null;  				m_incomingMessagesPool = null;  			}
Magic Number,Lidgren.Network,NetPeer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetNatIntroduction.cs,CreateMessage,The following statement contains a magic number: NetOutgoingMessage om = CreateMessage(2 + bytes.Length);
Magic Number,Lidgren.Network,NetPeer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetNatIntroduction.cs,CreateIncomingMessage,The following statement contains a magic number: retval = CreateIncomingMessage(tp' numBytes + (numBytes > 127 ? 2 : 1));
Magic Number,Lidgren.Network,NetPeer,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetNatIntroduction.cs,CreateIncomingMessage,The following statement contains a magic number: retval = CreateIncomingMessage(tp' numBytes + (numBytes > 127 ? 2 : 1));
Magic Number,Lidgren.Network,NetOutgoingMessage,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetOutgoingMessage.cs,Encode,The following statement contains a magic number: intoBuffer[ptr++] = (byte)(sequenceNumber >> 7);
Magic Number,Lidgren.Network,NetOutgoingMessage,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetOutgoingMessage.cs,Encode,The following statement contains a magic number: if (m_fragmentGroup == 0)  			{  				intoBuffer[ptr++] = (byte)m_bitLength;  				intoBuffer[ptr++] = (byte)(m_bitLength >> 8);    				int byteLen = NetUtility.BytesToHoldBits(m_bitLength);  				if (byteLen > 0)  				{  					Buffer.BlockCopy(m_data' 0' intoBuffer' ptr' byteLen);  					ptr += byteLen;  				}  			}  			else  			{  				int wasPtr = ptr;  				intoBuffer[ptr++] = (byte)m_bitLength;  				intoBuffer[ptr++] = (byte)(m_bitLength >> 8);    				//  				// write fragmentation header  				//  				ptr = NetFragmentationHelper.WriteHeader(intoBuffer' ptr' m_fragmentGroup' m_fragmentGroupTotalBits' m_fragmentChunkByteSize' m_fragmentChunkNumber);  				int hdrLen = ptr - wasPtr - 2;    				// update length  				int realBitLength = m_bitLength + (hdrLen * 8);  				intoBuffer[wasPtr] = (byte)realBitLength;  				intoBuffer[wasPtr + 1] = (byte)(realBitLength >> 8);    				int byteLen = NetUtility.BytesToHoldBits(m_bitLength);  				if (byteLen > 0)  				{  					Buffer.BlockCopy(m_data' (int)(m_fragmentChunkNumber * m_fragmentChunkByteSize)' intoBuffer' ptr' byteLen);  					ptr += byteLen;  				}  			}
Magic Number,Lidgren.Network,NetOutgoingMessage,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetOutgoingMessage.cs,Encode,The following statement contains a magic number: if (m_fragmentGroup == 0)  			{  				intoBuffer[ptr++] = (byte)m_bitLength;  				intoBuffer[ptr++] = (byte)(m_bitLength >> 8);    				int byteLen = NetUtility.BytesToHoldBits(m_bitLength);  				if (byteLen > 0)  				{  					Buffer.BlockCopy(m_data' 0' intoBuffer' ptr' byteLen);  					ptr += byteLen;  				}  			}  			else  			{  				int wasPtr = ptr;  				intoBuffer[ptr++] = (byte)m_bitLength;  				intoBuffer[ptr++] = (byte)(m_bitLength >> 8);    				//  				// write fragmentation header  				//  				ptr = NetFragmentationHelper.WriteHeader(intoBuffer' ptr' m_fragmentGroup' m_fragmentGroupTotalBits' m_fragmentChunkByteSize' m_fragmentChunkNumber);  				int hdrLen = ptr - wasPtr - 2;    				// update length  				int realBitLength = m_bitLength + (hdrLen * 8);  				intoBuffer[wasPtr] = (byte)realBitLength;  				intoBuffer[wasPtr + 1] = (byte)(realBitLength >> 8);    				int byteLen = NetUtility.BytesToHoldBits(m_bitLength);  				if (byteLen > 0)  				{  					Buffer.BlockCopy(m_data' (int)(m_fragmentChunkNumber * m_fragmentChunkByteSize)' intoBuffer' ptr' byteLen);  					ptr += byteLen;  				}  			}
Magic Number,Lidgren.Network,NetOutgoingMessage,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetOutgoingMessage.cs,Encode,The following statement contains a magic number: if (m_fragmentGroup == 0)  			{  				intoBuffer[ptr++] = (byte)m_bitLength;  				intoBuffer[ptr++] = (byte)(m_bitLength >> 8);    				int byteLen = NetUtility.BytesToHoldBits(m_bitLength);  				if (byteLen > 0)  				{  					Buffer.BlockCopy(m_data' 0' intoBuffer' ptr' byteLen);  					ptr += byteLen;  				}  			}  			else  			{  				int wasPtr = ptr;  				intoBuffer[ptr++] = (byte)m_bitLength;  				intoBuffer[ptr++] = (byte)(m_bitLength >> 8);    				//  				// write fragmentation header  				//  				ptr = NetFragmentationHelper.WriteHeader(intoBuffer' ptr' m_fragmentGroup' m_fragmentGroupTotalBits' m_fragmentChunkByteSize' m_fragmentChunkNumber);  				int hdrLen = ptr - wasPtr - 2;    				// update length  				int realBitLength = m_bitLength + (hdrLen * 8);  				intoBuffer[wasPtr] = (byte)realBitLength;  				intoBuffer[wasPtr + 1] = (byte)(realBitLength >> 8);    				int byteLen = NetUtility.BytesToHoldBits(m_bitLength);  				if (byteLen > 0)  				{  					Buffer.BlockCopy(m_data' (int)(m_fragmentChunkNumber * m_fragmentChunkByteSize)' intoBuffer' ptr' byteLen);  					ptr += byteLen;  				}  			}
Magic Number,Lidgren.Network,NetOutgoingMessage,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetOutgoingMessage.cs,Encode,The following statement contains a magic number: if (m_fragmentGroup == 0)  			{  				intoBuffer[ptr++] = (byte)m_bitLength;  				intoBuffer[ptr++] = (byte)(m_bitLength >> 8);    				int byteLen = NetUtility.BytesToHoldBits(m_bitLength);  				if (byteLen > 0)  				{  					Buffer.BlockCopy(m_data' 0' intoBuffer' ptr' byteLen);  					ptr += byteLen;  				}  			}  			else  			{  				int wasPtr = ptr;  				intoBuffer[ptr++] = (byte)m_bitLength;  				intoBuffer[ptr++] = (byte)(m_bitLength >> 8);    				//  				// write fragmentation header  				//  				ptr = NetFragmentationHelper.WriteHeader(intoBuffer' ptr' m_fragmentGroup' m_fragmentGroupTotalBits' m_fragmentChunkByteSize' m_fragmentChunkNumber);  				int hdrLen = ptr - wasPtr - 2;    				// update length  				int realBitLength = m_bitLength + (hdrLen * 8);  				intoBuffer[wasPtr] = (byte)realBitLength;  				intoBuffer[wasPtr + 1] = (byte)(realBitLength >> 8);    				int byteLen = NetUtility.BytesToHoldBits(m_bitLength);  				if (byteLen > 0)  				{  					Buffer.BlockCopy(m_data' (int)(m_fragmentChunkNumber * m_fragmentChunkByteSize)' intoBuffer' ptr' byteLen);  					ptr += byteLen;  				}  			}
Magic Number,Lidgren.Network,NetOutgoingMessage,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetOutgoingMessage.cs,Encode,The following statement contains a magic number: if (m_fragmentGroup == 0)  			{  				intoBuffer[ptr++] = (byte)m_bitLength;  				intoBuffer[ptr++] = (byte)(m_bitLength >> 8);    				int byteLen = NetUtility.BytesToHoldBits(m_bitLength);  				if (byteLen > 0)  				{  					Buffer.BlockCopy(m_data' 0' intoBuffer' ptr' byteLen);  					ptr += byteLen;  				}  			}  			else  			{  				int wasPtr = ptr;  				intoBuffer[ptr++] = (byte)m_bitLength;  				intoBuffer[ptr++] = (byte)(m_bitLength >> 8);    				//  				// write fragmentation header  				//  				ptr = NetFragmentationHelper.WriteHeader(intoBuffer' ptr' m_fragmentGroup' m_fragmentGroupTotalBits' m_fragmentChunkByteSize' m_fragmentChunkNumber);  				int hdrLen = ptr - wasPtr - 2;    				// update length  				int realBitLength = m_bitLength + (hdrLen * 8);  				intoBuffer[wasPtr] = (byte)realBitLength;  				intoBuffer[wasPtr + 1] = (byte)(realBitLength >> 8);    				int byteLen = NetUtility.BytesToHoldBits(m_bitLength);  				if (byteLen > 0)  				{  					Buffer.BlockCopy(m_data' (int)(m_fragmentChunkNumber * m_fragmentChunkByteSize)' intoBuffer' ptr' byteLen);  					ptr += byteLen;  				}  			}
Magic Number,Lidgren.Network,NetOutgoingMessage,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetOutgoingMessage.cs,GetEncodedSize,The following statement contains a magic number: if (m_fragmentGroup != 0)  				retval += NetFragmentationHelper.GetFragmentationHeaderSize(m_fragmentGroup' m_fragmentGroupTotalBits / 8' m_fragmentChunkByteSize' m_fragmentChunkNumber);
Magic Number,Lidgren.Network,NetPeerConfiguration,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetPeerConfiguration.cs,NetPeerConfiguration,The following statement contains a magic number: m_receiveBufferSize = 131071;
Magic Number,Lidgren.Network,NetPeerConfiguration,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetPeerConfiguration.cs,NetPeerConfiguration,The following statement contains a magic number: m_sendBufferSize = 131071;
Magic Number,Lidgren.Network,NetPeerConfiguration,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetPeerConfiguration.cs,NetPeerConfiguration,The following statement contains a magic number: m_maximumConnections = 32;
Magic Number,Lidgren.Network,NetPeerConfiguration,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetPeerConfiguration.cs,NetPeerConfiguration,The following statement contains a magic number: m_defaultOutgoingMessageCapacity = 16;
Magic Number,Lidgren.Network,NetPeerConfiguration,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetPeerConfiguration.cs,NetPeerConfiguration,The following statement contains a magic number: m_maximumHandshakeAttempts = 5;
Magic Number,Lidgren.Network,NetPeerConfiguration,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetPeerConfiguration.cs,NetPeerConfiguration,The following statement contains a magic number: m_maximumTransmissionUnit = 1408;
Magic Number,Lidgren.Network,NetPeerConfiguration,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetPeerConfiguration.cs,NetPeerConfiguration,The following statement contains a magic number: m_expandMTUFailAttempts = 5;
Magic Number,Lidgren.Network,NetQueue<T>,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetQueue.cs,Enqueue,The following statement contains a magic number: try  			{  				if (m_size == m_items.Length)  					SetCapacity(m_items.Length + 8);    				int slot = (m_head + m_size) % m_items.Length;  				m_items[slot] = item;  				m_size++;  			}  			finally  			{  				m_lock.ExitWriteLock();  			}
Magic Number,Lidgren.Network,NetQueue<T>,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetQueue.cs,Enqueue,The following statement contains a magic number: try  			{  				foreach (var item in items)  				{  					if (m_size == m_items.Length)  						SetCapacity(m_items.Length + 8); // @TODO move this out of loop    					int slot = (m_head + m_size) % m_items.Length;  					m_items[slot] = item;  					m_size++;  				}  			}  			finally  			{  				m_lock.ExitWriteLock();  			}
Magic Number,Lidgren.Network,NetQueue<T>,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetQueue.cs,EnqueueFirst,The following statement contains a magic number: try  			{  				if (m_size >= m_items.Length)  					SetCapacity(m_items.Length + 8);    				m_head--;  				if (m_head < 0)  					m_head = m_items.Length - 1;  				m_items[m_head] = item;  				m_size++;  			}  			finally  			{  				m_lock.ExitWriteLock();  			}
Magic Number,Lidgren.Network,NetRandom,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetRandom.cs,Next,The following statement contains a magic number: uint t = (x ^ (x << 11));
Magic Number,Lidgren.Network,NetRandom,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetRandom.cs,Next,The following statement contains a magic number: w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));
Magic Number,Lidgren.Network,NetRandom,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetRandom.cs,Next,The following statement contains a magic number: w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));
Magic Number,Lidgren.Network,NetRandom,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetRandom.cs,Next,The following statement contains a magic number: uint t = (x ^ (x << 11));
Magic Number,Lidgren.Network,NetRandom,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetRandom.cs,Next,The following statement contains a magic number: return (int)((REAL_UNIT_INT * (int)(0x7FFFFFFF & (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8))))) * upperBound);
Magic Number,Lidgren.Network,NetRandom,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetRandom.cs,Next,The following statement contains a magic number: return (int)((REAL_UNIT_INT * (int)(0x7FFFFFFF & (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8))))) * upperBound);
Magic Number,Lidgren.Network,NetRandom,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetRandom.cs,Next,The following statement contains a magic number: uint t = (x ^ (x << 11));
Magic Number,Lidgren.Network,NetRandom,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetRandom.cs,Next,The following statement contains a magic number: if (range < 0)  			{	// If range is <0 then an overflow has occured and must resort to using long integer arithmetic instead (slower).  				// We also must use all 32 bits of precision' instead of the normal 31' which again is slower.	  				return lowerBound + (int)((REAL_UNIT_UINT * (double)(w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)))) * (double)((long)upperBound - (long)lowerBound));  			}
Magic Number,Lidgren.Network,NetRandom,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetRandom.cs,Next,The following statement contains a magic number: if (range < 0)  			{	// If range is <0 then an overflow has occured and must resort to using long integer arithmetic instead (slower).  				// We also must use all 32 bits of precision' instead of the normal 31' which again is slower.	  				return lowerBound + (int)((REAL_UNIT_UINT * (double)(w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)))) * (double)((long)upperBound - (long)lowerBound));  			}
Magic Number,Lidgren.Network,NetRandom,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetRandom.cs,Next,The following statement contains a magic number: return lowerBound + (int)((REAL_UNIT_INT * (double)(int)(0x7FFFFFFF & (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8))))) * (double)range);
Magic Number,Lidgren.Network,NetRandom,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetRandom.cs,Next,The following statement contains a magic number: return lowerBound + (int)((REAL_UNIT_INT * (double)(int)(0x7FFFFFFF & (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8))))) * (double)range);
Magic Number,Lidgren.Network,NetRandom,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetRandom.cs,NextDouble,The following statement contains a magic number: uint t = (x ^ (x << 11));
Magic Number,Lidgren.Network,NetRandom,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetRandom.cs,NextDouble,The following statement contains a magic number: return (REAL_UNIT_INT * (int)(0x7FFFFFFF & (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)))));
Magic Number,Lidgren.Network,NetRandom,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetRandom.cs,NextDouble,The following statement contains a magic number: return (REAL_UNIT_INT * (int)(0x7FFFFFFF & (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)))));
Magic Number,Lidgren.Network,NetRandom,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetRandom.cs,NextBytes,The following statement contains a magic number: for (int bound = buffer.Length - 3; i < bound; )  			{  				// Generate 4 bytes.   				// Increased performance is achieved by generating 4 random bytes per loop.  				// Also note that no mask needs to be applied to zero out the higher order bytes before  				// casting because the cast ignores thos bytes. Thanks to Stefan Troschtz for pointing this out.  				t = (x ^ (x << 11));  				x = y; y = z; z = w;  				w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));    				buffer[i++] = (byte)w;  				buffer[i++] = (byte)(w >> 8);  				buffer[i++] = (byte)(w >> 16);  				buffer[i++] = (byte)(w >> 24);  			}
Magic Number,Lidgren.Network,NetRandom,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetRandom.cs,NextBytes,The following statement contains a magic number: for (int bound = buffer.Length - 3; i < bound; )  			{  				// Generate 4 bytes.   				// Increased performance is achieved by generating 4 random bytes per loop.  				// Also note that no mask needs to be applied to zero out the higher order bytes before  				// casting because the cast ignores thos bytes. Thanks to Stefan Troschtz for pointing this out.  				t = (x ^ (x << 11));  				x = y; y = z; z = w;  				w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));    				buffer[i++] = (byte)w;  				buffer[i++] = (byte)(w >> 8);  				buffer[i++] = (byte)(w >> 16);  				buffer[i++] = (byte)(w >> 24);  			}
Magic Number,Lidgren.Network,NetRandom,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetRandom.cs,NextBytes,The following statement contains a magic number: for (int bound = buffer.Length - 3; i < bound; )  			{  				// Generate 4 bytes.   				// Increased performance is achieved by generating 4 random bytes per loop.  				// Also note that no mask needs to be applied to zero out the higher order bytes before  				// casting because the cast ignores thos bytes. Thanks to Stefan Troschtz for pointing this out.  				t = (x ^ (x << 11));  				x = y; y = z; z = w;  				w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));    				buffer[i++] = (byte)w;  				buffer[i++] = (byte)(w >> 8);  				buffer[i++] = (byte)(w >> 16);  				buffer[i++] = (byte)(w >> 24);  			}
Magic Number,Lidgren.Network,NetRandom,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetRandom.cs,NextBytes,The following statement contains a magic number: for (int bound = buffer.Length - 3; i < bound; )  			{  				// Generate 4 bytes.   				// Increased performance is achieved by generating 4 random bytes per loop.  				// Also note that no mask needs to be applied to zero out the higher order bytes before  				// casting because the cast ignores thos bytes. Thanks to Stefan Troschtz for pointing this out.  				t = (x ^ (x << 11));  				x = y; y = z; z = w;  				w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));    				buffer[i++] = (byte)w;  				buffer[i++] = (byte)(w >> 8);  				buffer[i++] = (byte)(w >> 16);  				buffer[i++] = (byte)(w >> 24);  			}
Magic Number,Lidgren.Network,NetRandom,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetRandom.cs,NextBytes,The following statement contains a magic number: for (int bound = buffer.Length - 3; i < bound; )  			{  				// Generate 4 bytes.   				// Increased performance is achieved by generating 4 random bytes per loop.  				// Also note that no mask needs to be applied to zero out the higher order bytes before  				// casting because the cast ignores thos bytes. Thanks to Stefan Troschtz for pointing this out.  				t = (x ^ (x << 11));  				x = y; y = z; z = w;  				w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));    				buffer[i++] = (byte)w;  				buffer[i++] = (byte)(w >> 8);  				buffer[i++] = (byte)(w >> 16);  				buffer[i++] = (byte)(w >> 24);  			}
Magic Number,Lidgren.Network,NetRandom,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetRandom.cs,NextBytes,The following statement contains a magic number: for (int bound = buffer.Length - 3; i < bound; )  			{  				// Generate 4 bytes.   				// Increased performance is achieved by generating 4 random bytes per loop.  				// Also note that no mask needs to be applied to zero out the higher order bytes before  				// casting because the cast ignores thos bytes. Thanks to Stefan Troschtz for pointing this out.  				t = (x ^ (x << 11));  				x = y; y = z; z = w;  				w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));    				buffer[i++] = (byte)w;  				buffer[i++] = (byte)(w >> 8);  				buffer[i++] = (byte)(w >> 16);  				buffer[i++] = (byte)(w >> 24);  			}
Magic Number,Lidgren.Network,NetRandom,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetRandom.cs,NextBytes,The following statement contains a magic number: for (int bound = buffer.Length - 3; i < bound; )  			{  				// Generate 4 bytes.   				// Increased performance is achieved by generating 4 random bytes per loop.  				// Also note that no mask needs to be applied to zero out the higher order bytes before  				// casting because the cast ignores thos bytes. Thanks to Stefan Troschtz for pointing this out.  				t = (x ^ (x << 11));  				x = y; y = z; z = w;  				w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));    				buffer[i++] = (byte)w;  				buffer[i++] = (byte)(w >> 8);  				buffer[i++] = (byte)(w >> 16);  				buffer[i++] = (byte)(w >> 24);  			}
Magic Number,Lidgren.Network,NetRandom,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetRandom.cs,NextBytes,The following statement contains a magic number: if (i < buffer.Length)  			{  				// Generate 4 bytes.  				t = (x ^ (x << 11));  				x = y; y = z; z = w;  				w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));    				buffer[i++] = (byte)w;  				if (i < buffer.Length)  				{  					buffer[i++] = (byte)(w >> 8);  					if (i < buffer.Length)  					{  						buffer[i++] = (byte)(w >> 16);  						if (i < buffer.Length)  						{  							buffer[i] = (byte)(w >> 24);  						}  					}  				}  			}
Magic Number,Lidgren.Network,NetRandom,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetRandom.cs,NextBytes,The following statement contains a magic number: if (i < buffer.Length)  			{  				// Generate 4 bytes.  				t = (x ^ (x << 11));  				x = y; y = z; z = w;  				w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));    				buffer[i++] = (byte)w;  				if (i < buffer.Length)  				{  					buffer[i++] = (byte)(w >> 8);  					if (i < buffer.Length)  					{  						buffer[i++] = (byte)(w >> 16);  						if (i < buffer.Length)  						{  							buffer[i] = (byte)(w >> 24);  						}  					}  				}  			}
Magic Number,Lidgren.Network,NetRandom,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetRandom.cs,NextBytes,The following statement contains a magic number: if (i < buffer.Length)  			{  				// Generate 4 bytes.  				t = (x ^ (x << 11));  				x = y; y = z; z = w;  				w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));    				buffer[i++] = (byte)w;  				if (i < buffer.Length)  				{  					buffer[i++] = (byte)(w >> 8);  					if (i < buffer.Length)  					{  						buffer[i++] = (byte)(w >> 16);  						if (i < buffer.Length)  						{  							buffer[i] = (byte)(w >> 24);  						}  					}  				}  			}
Magic Number,Lidgren.Network,NetRandom,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetRandom.cs,NextBytes,The following statement contains a magic number: if (i < buffer.Length)  			{  				// Generate 4 bytes.  				t = (x ^ (x << 11));  				x = y; y = z; z = w;  				w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));    				buffer[i++] = (byte)w;  				if (i < buffer.Length)  				{  					buffer[i++] = (byte)(w >> 8);  					if (i < buffer.Length)  					{  						buffer[i++] = (byte)(w >> 16);  						if (i < buffer.Length)  						{  							buffer[i] = (byte)(w >> 24);  						}  					}  				}  			}
Magic Number,Lidgren.Network,NetRandom,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetRandom.cs,NextBytes,The following statement contains a magic number: if (i < buffer.Length)  			{  				// Generate 4 bytes.  				t = (x ^ (x << 11));  				x = y; y = z; z = w;  				w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));    				buffer[i++] = (byte)w;  				if (i < buffer.Length)  				{  					buffer[i++] = (byte)(w >> 8);  					if (i < buffer.Length)  					{  						buffer[i++] = (byte)(w >> 16);  						if (i < buffer.Length)  						{  							buffer[i] = (byte)(w >> 24);  						}  					}  				}  			}
Magic Number,Lidgren.Network,NetRandom,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetRandom.cs,NextBytes,The following statement contains a magic number: if (i < buffer.Length)  			{  				// Generate 4 bytes.  				t = (x ^ (x << 11));  				x = y; y = z; z = w;  				w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));    				buffer[i++] = (byte)w;  				if (i < buffer.Length)  				{  					buffer[i++] = (byte)(w >> 8);  					if (i < buffer.Length)  					{  						buffer[i++] = (byte)(w >> 16);  						if (i < buffer.Length)  						{  							buffer[i] = (byte)(w >> 24);  						}  					}  				}  			}
Magic Number,Lidgren.Network,NetRandom,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetRandom.cs,NextUInt,The following statement contains a magic number: uint t = (x ^ (x << 11));
Magic Number,Lidgren.Network,NetRandom,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetRandom.cs,NextUInt,The following statement contains a magic number: return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));
Magic Number,Lidgren.Network,NetRandom,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetRandom.cs,NextUInt,The following statement contains a magic number: return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));
Magic Number,Lidgren.Network,NetRandom,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetRandom.cs,NextInt,The following statement contains a magic number: uint t = (x ^ (x << 11));
Magic Number,Lidgren.Network,NetRandom,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetRandom.cs,NextInt,The following statement contains a magic number: return (int)(0x7FFFFFFF & (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8))));
Magic Number,Lidgren.Network,NetRandom,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetRandom.cs,NextInt,The following statement contains a magic number: return (int)(0x7FFFFFFF & (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8))));
Magic Number,Lidgren.Network,NetRandom,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetRandom.cs,NextBool,The following statement contains a magic number: if (bitMask == 1)  			{  				// Generate 32 more bits.  				uint t = (x ^ (x << 11));  				x = y; y = z; z = w;  				bitBuffer = w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));    				// Reset the bitMask that tells us which bit to read next.  				bitMask = 0x80000000;  				return (bitBuffer & bitMask) == 0;  			}
Magic Number,Lidgren.Network,NetRandom,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetRandom.cs,NextBool,The following statement contains a magic number: if (bitMask == 1)  			{  				// Generate 32 more bits.  				uint t = (x ^ (x << 11));  				x = y; y = z; z = w;  				bitBuffer = w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));    				// Reset the bitMask that tells us which bit to read next.  				bitMask = 0x80000000;  				return (bitBuffer & bitMask) == 0;  			}
Magic Number,Lidgren.Network,NetRandom,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetRandom.cs,NextBool,The following statement contains a magic number: if (bitMask == 1)  			{  				// Generate 32 more bits.  				uint t = (x ^ (x << 11));  				x = y; y = z; z = w;  				bitBuffer = w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));    				// Reset the bitMask that tells us which bit to read next.  				bitMask = 0x80000000;  				return (bitBuffer & bitMask) == 0;  			}
Magic Number,Lidgren.Network,NetReliableSenderChannel,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetReliableSenderChannel.cs,NetReliableSenderChannel,The following statement contains a magic number: m_queuedSends = new NetQueue<NetOutgoingMessage>(8);
Magic Number,Lidgren.Network,NetSRP,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetSRP.cs,ComputeMultiplier,The following statement contains a magic number: return new NetBigInteger(NetUtility.ToHexString(ccHashed)' 16);
Magic Number,Lidgren.Network,NetSRP,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetSRP.cs,CreateRandomSalt,The following statement contains a magic number: byte[] retval = new byte[16];
Magic Number,Lidgren.Network,NetSRP,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetSRP.cs,CreateRandomEphemeral,The following statement contains a magic number: byte[] retval = new byte[32];
Magic Number,Lidgren.Network,NetSRP,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetSRP.cs,ComputePrivateKey,The following statement contains a magic number: return new NetBigInteger(NetUtility.ToHexString(sha.ComputeHash(total))' 16).ToByteArrayUnsigned();
Magic Number,Lidgren.Network,NetSRP,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetSRP.cs,ComputeServerVerifier,The following statement contains a magic number: NetBigInteger x = new NetBigInteger(NetUtility.ToHexString(privateKey)' 16);
Magic Number,Lidgren.Network,NetSRP,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetSRP.cs,ComputeClientEphemeral,The following statement contains a magic number: NetBigInteger a = new NetBigInteger(NetUtility.ToHexString(clientPrivateEphemeral)' 16);
Magic Number,Lidgren.Network,NetSRP,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetSRP.cs,ComputeServerEphemeral,The following statement contains a magic number: var b = new NetBigInteger(NetUtility.ToHexString(serverPrivateEphemeral)' 16);
Magic Number,Lidgren.Network,NetSRP,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetSRP.cs,ComputeServerEphemeral,The following statement contains a magic number: var v = new NetBigInteger(NetUtility.ToHexString(verifier)' 16);
Magic Number,Lidgren.Network,NetSRP,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetSRP.cs,ComputeU,The following statement contains a magic number: int len = 66;
Magic Number,Lidgren.Network,NetSRP,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetSRP.cs,ComputeU,The following statement contains a magic number: return new NetBigInteger(NetUtility.ToHexString(ccHashed)' 16).ToByteArrayUnsigned();
Magic Number,Lidgren.Network,NetSRP,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetSRP.cs,ComputeServerSessionValue,The following statement contains a magic number: var A = new NetBigInteger(NetUtility.ToHexString(clientPublicEphemeral)' 16);
Magic Number,Lidgren.Network,NetSRP,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetSRP.cs,ComputeServerSessionValue,The following statement contains a magic number: var v = new NetBigInteger(NetUtility.ToHexString(verifier)' 16);
Magic Number,Lidgren.Network,NetSRP,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetSRP.cs,ComputeServerSessionValue,The following statement contains a magic number: var u = new NetBigInteger(NetUtility.ToHexString(udata)' 16);
Magic Number,Lidgren.Network,NetSRP,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetSRP.cs,ComputeServerSessionValue,The following statement contains a magic number: var b = new NetBigInteger(NetUtility.ToHexString(serverPrivateEphemeral)' 16);
Magic Number,Lidgren.Network,NetSRP,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetSRP.cs,ComputeClientSessionValue,The following statement contains a magic number: var B = new NetBigInteger(NetUtility.ToHexString(serverPublicEphemeral)' 16);
Magic Number,Lidgren.Network,NetSRP,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetSRP.cs,ComputeClientSessionValue,The following statement contains a magic number: var x = new NetBigInteger(NetUtility.ToHexString(xdata)' 16);
Magic Number,Lidgren.Network,NetSRP,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetSRP.cs,ComputeClientSessionValue,The following statement contains a magic number: var u = new NetBigInteger(NetUtility.ToHexString(udata)' 16);
Magic Number,Lidgren.Network,NetSRP,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetSRP.cs,ComputeClientSessionValue,The following statement contains a magic number: var a = new NetBigInteger(NetUtility.ToHexString(clientPrivateEphemeral)' 16);
Magic Number,Lidgren.Network,NetSRP,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetSRP.cs,CreateEncryption,The following statement contains a magic number: var key = new byte[16];
Magic Number,Lidgren.Network,NetSRP,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetSRP.cs,CreateEncryption,The following statement contains a magic number: for(int i=0;i<16;i++)  			{  				key[i] = hash[i];  				for (int j = 1; j < hash.Length / 16; j++)  					key[i] ^= hash[i + (j * 16)];  			}
Magic Number,Lidgren.Network,NetSRP,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetSRP.cs,CreateEncryption,The following statement contains a magic number: for(int i=0;i<16;i++)  			{  				key[i] = hash[i];  				for (int j = 1; j < hash.Length / 16; j++)  					key[i] ^= hash[i + (j * 16)];  			}
Magic Number,Lidgren.Network,NetSRP,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetSRP.cs,CreateEncryption,The following statement contains a magic number: for(int i=0;i<16;i++)  			{  				key[i] = hash[i];  				for (int j = 1; j < hash.Length / 16; j++)  					key[i] ^= hash[i + (j * 16)];  			}
Magic Number,Lidgren.Network,NetTime,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetTime.cs,ToReadable,The following statement contains a magic number: if (seconds > 60)  				return TimeSpan.FromSeconds(seconds).ToString();
Magic Number,Lidgren.Network,NetTime,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetTime.cs,ToReadable,The following statement contains a magic number: return (seconds * 1000.0).ToString("N2") + " ms";
Magic Number,Lidgren.Network,NetUnreliableSenderChannel,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetUnreliableSenderChannel.cs,NetUnreliableSenderChannel,The following statement contains a magic number: m_queuedSends = new NetQueue<NetOutgoingMessage>(8);
Magic Number,Lidgren.Network,NetUPnP,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetUPnP.cs,Discover,The following statement contains a magic number: peer.RawSend(arr' 0' arr.Length' new IPEndPoint(IPAddress.Broadcast' 1900));
Magic Number,Lidgren.Network,NetUPnP,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetUPnP.cs,ForwardPort,The following statement contains a magic number: try  			{  				XmlDocument xdoc = SOAPRequest(m_serviceUrl'  					"<u:AddPortMapping xmlns:u=\"urn:schemas-upnp-org:service:" + m_serviceName + ":1\">" +  					"<NewRemoteHost></NewRemoteHost>" +  					"<NewExternalPort>" + port.ToString() + "</NewExternalPort>" +  					"<NewProtocol>" + ProtocolType.Udp.ToString().ToUpper() + "</NewProtocol>" +  					"<NewInternalPort>" + port.ToString() + "</NewInternalPort>" +  					"<NewInternalClient>" + client.ToString() + "</NewInternalClient>" +  					"<NewEnabled>1</NewEnabled>" +  					"<NewPortMappingDescription>" + description + "</NewPortMappingDescription>" +  					"<NewLeaseDuration>0</NewLeaseDuration>" +  					"</u:AddPortMapping>"'  					"AddPortMapping");    				m_peer.LogDebug("Sent UPnP port forward request");  				System.Threading.Thread.Sleep(50);  			}  			catch (Exception ex)  			{  				m_peer.LogWarning("UPnP port forward failed: " + ex.Message);  				return false;  			}
Magic Number,Lidgren.Network,NetUtility,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetUtility.cs,ToHexString,The following statement contains a magic number: char[] c = new char[data.Length * 2];
Magic Number,Lidgren.Network,NetUtility,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetUtility.cs,ToHexString,The following statement contains a magic number: for (int i = 0; i < data.Length; ++i)  			{  				b = ((byte)(data[i] >> 4));  				c[i * 2] = (char)(b > 9 ? b + 0x37 : b + 0x30);  				b = ((byte)(data[i] & 0xF));  				c[i * 2 + 1] = (char)(b > 9 ? b + 0x37 : b + 0x30);  			}
Magic Number,Lidgren.Network,NetUtility,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetUtility.cs,ToHexString,The following statement contains a magic number: for (int i = 0; i < data.Length; ++i)  			{  				b = ((byte)(data[i] >> 4));  				c[i * 2] = (char)(b > 9 ? b + 0x37 : b + 0x30);  				b = ((byte)(data[i] & 0xF));  				c[i * 2 + 1] = (char)(b > 9 ? b + 0x37 : b + 0x30);  			}
Magic Number,Lidgren.Network,NetUtility,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetUtility.cs,ToHexString,The following statement contains a magic number: for (int i = 0; i < data.Length; ++i)  			{  				b = ((byte)(data[i] >> 4));  				c[i * 2] = (char)(b > 9 ? b + 0x37 : b + 0x30);  				b = ((byte)(data[i] & 0xF));  				c[i * 2 + 1] = (char)(b > 9 ? b + 0x37 : b + 0x30);  			}
Magic Number,Lidgren.Network,NetUtility,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetUtility.cs,ToHexString,The following statement contains a magic number: for (int i = 0; i < data.Length; ++i)  			{  				b = ((byte)(data[i] >> 4));  				c[i * 2] = (char)(b > 9 ? b + 0x37 : b + 0x30);  				b = ((byte)(data[i] & 0xF));  				c[i * 2 + 1] = (char)(b > 9 ? b + 0x37 : b + 0x30);  			}
Magic Number,Lidgren.Network,NetUtility,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetUtility.cs,ToHexString,The following statement contains a magic number: for (int i = 0; i < data.Length; ++i)  			{  				b = ((byte)(data[i] >> 4));  				c[i * 2] = (char)(b > 9 ? b + 0x37 : b + 0x30);  				b = ((byte)(data[i] & 0xF));  				c[i * 2 + 1] = (char)(b > 9 ? b + 0x37 : b + 0x30);  			}
Magic Number,Lidgren.Network,NetUtility,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetUtility.cs,GetBroadcastAddress,The following statement contains a magic number: try  			{  				NetworkInterface ni = GetNetworkInterface();  				if (ni == null)  				{  					return null;  				}  	  				IPInterfaceProperties properties = ni.GetIPProperties();  				foreach (UnicastIPAddressInformation unicastAddress in properties.UnicastAddresses)  				{  					if (unicastAddress != null && unicastAddress.Address != null && unicastAddress.Address.AddressFamily == AddressFamily.InterNetwork)  					{  						var mask = unicastAddress.IPv4Mask;  						byte[] ipAdressBytes = unicastAddress.Address.GetAddressBytes();  				        byte[] subnetMaskBytes = mask.GetAddressBytes();  				  				        if (ipAdressBytes.Length != subnetMaskBytes.Length)  				            throw new ArgumentException("Lengths of IP address and subnet mask do not match.");  				  				        byte[] broadcastAddress = new byte[ipAdressBytes.Length];  				        for (int i = 0; i < broadcastAddress.Length; i++)  				        {  				            broadcastAddress[i] = (byte)(ipAdressBytes[i] | (subnetMaskBytes[i] ^ 255));  				        }  				        return new IPAddress(broadcastAddress);				  					}  				}  			}  			catch // Catch any errors   			{  			    return IPAddress.Broadcast;  			}
Magic Number,Lidgren.Network,NetUtility,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetUtility.cs,BytesToHoldBits,The following statement contains a magic number: return (numBits + 7) / 8;
Magic Number,Lidgren.Network,NetUtility,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetUtility.cs,BytesToHoldBits,The following statement contains a magic number: return (numBits + 7) / 8;
Magic Number,Lidgren.Network,NetUtility,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetUtility.cs,SwapByteOrder,The following statement contains a magic number: return  				((value & 0xff000000) >> 24) |  				((value & 0x00ff0000) >> 8) |  				((value & 0x0000ff00) << 8) |  				((value & 0x000000ff) << 24);
Magic Number,Lidgren.Network,NetUtility,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetUtility.cs,SwapByteOrder,The following statement contains a magic number: return  				((value & 0xff000000) >> 24) |  				((value & 0x00ff0000) >> 8) |  				((value & 0x0000ff00) << 8) |  				((value & 0x000000ff) << 24);
Magic Number,Lidgren.Network,NetUtility,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetUtility.cs,SwapByteOrder,The following statement contains a magic number: return  				((value & 0xff000000) >> 24) |  				((value & 0x00ff0000) >> 8) |  				((value & 0x0000ff00) << 8) |  				((value & 0x000000ff) << 24);
Magic Number,Lidgren.Network,NetUtility,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetUtility.cs,SwapByteOrder,The following statement contains a magic number: return  				((value & 0xff000000) >> 24) |  				((value & 0x00ff0000) >> 8) |  				((value & 0x0000ff00) << 8) |  				((value & 0x000000ff) << 24);
Magic Number,Lidgren.Network,NetUtility,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetUtility.cs,SwapByteOrder,The following statement contains a magic number: return  				((value & 0xff00000000000000L) >> 56) |  				((value & 0x00ff000000000000L) >> 40) |  				((value & 0x0000ff0000000000L) >> 24) |  				((value & 0x000000ff00000000L) >> 8) |  				((value & 0x00000000ff000000L) << 8) |  				((value & 0x0000000000ff0000L) << 24) |  				((value & 0x000000000000ff00L) << 40) |  				((value & 0x00000000000000ffL) << 56);
Magic Number,Lidgren.Network,NetUtility,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetUtility.cs,SwapByteOrder,The following statement contains a magic number: return  				((value & 0xff00000000000000L) >> 56) |  				((value & 0x00ff000000000000L) >> 40) |  				((value & 0x0000ff0000000000L) >> 24) |  				((value & 0x000000ff00000000L) >> 8) |  				((value & 0x00000000ff000000L) << 8) |  				((value & 0x0000000000ff0000L) << 24) |  				((value & 0x000000000000ff00L) << 40) |  				((value & 0x00000000000000ffL) << 56);
Magic Number,Lidgren.Network,NetUtility,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetUtility.cs,SwapByteOrder,The following statement contains a magic number: return  				((value & 0xff00000000000000L) >> 56) |  				((value & 0x00ff000000000000L) >> 40) |  				((value & 0x0000ff0000000000L) >> 24) |  				((value & 0x000000ff00000000L) >> 8) |  				((value & 0x00000000ff000000L) << 8) |  				((value & 0x0000000000ff0000L) << 24) |  				((value & 0x000000000000ff00L) << 40) |  				((value & 0x00000000000000ffL) << 56);
Magic Number,Lidgren.Network,NetUtility,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetUtility.cs,SwapByteOrder,The following statement contains a magic number: return  				((value & 0xff00000000000000L) >> 56) |  				((value & 0x00ff000000000000L) >> 40) |  				((value & 0x0000ff0000000000L) >> 24) |  				((value & 0x000000ff00000000L) >> 8) |  				((value & 0x00000000ff000000L) << 8) |  				((value & 0x0000000000ff0000L) << 24) |  				((value & 0x000000000000ff00L) << 40) |  				((value & 0x00000000000000ffL) << 56);
Magic Number,Lidgren.Network,NetUtility,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetUtility.cs,SwapByteOrder,The following statement contains a magic number: return  				((value & 0xff00000000000000L) >> 56) |  				((value & 0x00ff000000000000L) >> 40) |  				((value & 0x0000ff0000000000L) >> 24) |  				((value & 0x000000ff00000000L) >> 8) |  				((value & 0x00000000ff000000L) << 8) |  				((value & 0x0000000000ff0000L) << 24) |  				((value & 0x000000000000ff00L) << 40) |  				((value & 0x00000000000000ffL) << 56);
Magic Number,Lidgren.Network,NetUtility,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetUtility.cs,SwapByteOrder,The following statement contains a magic number: return  				((value & 0xff00000000000000L) >> 56) |  				((value & 0x00ff000000000000L) >> 40) |  				((value & 0x0000ff0000000000L) >> 24) |  				((value & 0x000000ff00000000L) >> 8) |  				((value & 0x00000000ff000000L) << 8) |  				((value & 0x0000000000ff0000L) << 24) |  				((value & 0x000000000000ff00L) << 40) |  				((value & 0x00000000000000ffL) << 56);
Magic Number,Lidgren.Network,NetUtility,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetUtility.cs,SwapByteOrder,The following statement contains a magic number: return  				((value & 0xff00000000000000L) >> 56) |  				((value & 0x00ff000000000000L) >> 40) |  				((value & 0x0000ff0000000000L) >> 24) |  				((value & 0x000000ff00000000L) >> 8) |  				((value & 0x00000000ff000000L) << 8) |  				((value & 0x0000000000ff0000L) << 24) |  				((value & 0x000000000000ff00L) << 40) |  				((value & 0x00000000000000ffL) << 56);
Magic Number,Lidgren.Network,NetUtility,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetUtility.cs,SwapByteOrder,The following statement contains a magic number: return  				((value & 0xff00000000000000L) >> 56) |  				((value & 0x00ff000000000000L) >> 40) |  				((value & 0x0000ff0000000000L) >> 24) |  				((value & 0x000000ff00000000L) >> 8) |  				((value & 0x00000000ff000000L) << 8) |  				((value & 0x0000000000ff0000L) << 24) |  				((value & 0x000000000000ff00L) << 40) |  				((value & 0x00000000000000ffL) << 56);
Magic Number,Lidgren.Network,NetUtility,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetUtility.cs,ToByteArray,The following statement contains a magic number: byte[] retval = new byte[hexString.Length / 2];
Magic Number,Lidgren.Network,NetUtility,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetUtility.cs,ToByteArray,The following statement contains a magic number: for (int i = 0; i < hexString.Length; i += 2)  				retval[i / 2] = Convert.ToByte(hexString.Substring(i' 2)' 16);
Magic Number,Lidgren.Network,NetUtility,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetUtility.cs,ToByteArray,The following statement contains a magic number: for (int i = 0; i < hexString.Length; i += 2)  				retval[i / 2] = Convert.ToByte(hexString.Substring(i' 2)' 16);
Magic Number,Lidgren.Network,NetUtility,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetUtility.cs,ToByteArray,The following statement contains a magic number: for (int i = 0; i < hexString.Length; i += 2)  				retval[i / 2] = Convert.ToByte(hexString.Substring(i' 2)' 16);
Magic Number,Lidgren.Network,NetUtility,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetUtility.cs,ToByteArray,The following statement contains a magic number: for (int i = 0; i < hexString.Length; i += 2)  				retval[i / 2] = Convert.ToByte(hexString.Substring(i' 2)' 16);
Magic Number,Lidgren.Network,NetUtility,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetUtility.cs,ToHumanReadable,The following statement contains a magic number: if (bytes < 4000) // 1-4 kb is printed in bytes  				return bytes + " bytes";
Magic Number,Lidgren.Network,NetUtility,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetUtility.cs,ToHumanReadable,The following statement contains a magic number: if (bytes < 1000 * 1000) // 4-999 kb is printed in kb  				return Math.Round(((double)bytes / 1000.0)' 2) + " kilobytes";
Magic Number,Lidgren.Network,NetUtility,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetUtility.cs,ToHumanReadable,The following statement contains a magic number: if (bytes < 1000 * 1000) // 4-999 kb is printed in kb  				return Math.Round(((double)bytes / 1000.0)' 2) + " kilobytes";
Magic Number,Lidgren.Network,NetUtility,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetUtility.cs,ToHumanReadable,The following statement contains a magic number: if (bytes < 1000 * 1000) // 4-999 kb is printed in kb  				return Math.Round(((double)bytes / 1000.0)' 2) + " kilobytes";
Magic Number,Lidgren.Network,NetUtility,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetUtility.cs,ToHumanReadable,The following statement contains a magic number: if (bytes < 1000 * 1000) // 4-999 kb is printed in kb  				return Math.Round(((double)bytes / 1000.0)' 2) + " kilobytes";
Magic Number,Lidgren.Network,NetUtility,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetUtility.cs,ToHumanReadable,The following statement contains a magic number: return Math.Round(((double)bytes / (1000.0 * 1000.0))' 2) + " megabytes";
Magic Number,Lidgren.Network,NetUtility,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetUtility.cs,ToHumanReadable,The following statement contains a magic number: return Math.Round(((double)bytes / (1000.0 * 1000.0))' 2) + " megabytes";
Magic Number,Lidgren.Network,NetUtility,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetUtility.cs,ToHumanReadable,The following statement contains a magic number: return Math.Round(((double)bytes / (1000.0 * 1000.0))' 2) + " megabytes";
Magic Number,Lidgren.Network,NetUtility,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetUtility.cs,RelativeSequenceNumber,The following statement contains a magic number: return (nr - expected + NetConstants.NumSequenceNumbers + (NetConstants.NumSequenceNumbers / 2)) % NetConstants.NumSequenceNumbers - (NetConstants.NumSequenceNumbers / 2);
Magic Number,Lidgren.Network,NetUtility,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetUtility.cs,RelativeSequenceNumber,The following statement contains a magic number: return (nr - expected + NetConstants.NumSequenceNumbers + (NetConstants.NumSequenceNumbers / 2)) % NetConstants.NumSequenceNumbers - (NetConstants.NumSequenceNumbers / 2);
Magic Number,Lidgren.Network,NetUtility,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetUtility.cs,SortMembersList,The following statement contains a magic number: while (h * 3 + 1 <= list.Length)  				h = 3 * h + 1;
Magic Number,Lidgren.Network,NetUtility,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetUtility.cs,SortMembersList,The following statement contains a magic number: while (h * 3 + 1 <= list.Length)  				h = 3 * h + 1;
Magic Number,Lidgren.Network,NetUtility,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetUtility.cs,SortMembersList,The following statement contains a magic number: while (h > 0)  			{  				for (int i = h - 1; i < list.Length; i++)  				{  					tmp = list[i];  					j = i;  					while (true)  					{  						if (j >= h)  						{  							if (string.Compare(list[j - h].Name' tmp.Name' StringComparison.InvariantCulture) > 0)  							{  								list[j] = list[j - h];  								j -= h;  							}  							else  								break;  						}  						else  							break;  					}    					list[j] = tmp;  				}  				h /= 3;  			}
Magic Number,Lidgren.Network,NetUtility,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetUtility.cs,MakeCommaDelimitedList,The following statement contains a magic number: StringBuilder bdr = new StringBuilder(cnt * 5);
Missing Default,Lidgren.Network,NetBigInteger,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetBigInteger.cs,ValueOf,The following switch statement is missing a default case: switch (value)  			{  				case 0:  					return Zero;  				case 1:  					return One;  				case 2:  					return Two;  				case 3:  					return Three;  				case 10:  					return Ten;  			}
Missing Default,Lidgren.Network,NetConnection,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetConnection.cs,ReceivedHandshake,The following switch statement is missing a default case: switch (m_status)  					{  						case NetConnectionStatus.InitiatedConnect:  							// awesome  							bool ok = ValidateHandshakeData(ptr' payloadLength' out hail);  							if (ok)  							{  								if (hail != null)  								{  									m_remoteHailMessage = m_peer.CreateIncomingMessage(NetIncomingMessageType.Data' hail);  									m_remoteHailMessage.LengthBits = (hail.Length * 8);  								}  								else  								{  									m_remoteHailMessage = null;  								}    								m_peer.AcceptConnection(this);  								SendConnectionEstablished();  								return;  							}  							break;  						case NetConnectionStatus.RespondedConnect:  							// hello' wtf?  							break;  						case NetConnectionStatus.Disconnecting:  						case NetConnectionStatus.Disconnected:  						case NetConnectionStatus.ReceivedInitiation:  						case NetConnectionStatus.None:  							// wtf? anyway' bye!  							break;  						case NetConnectionStatus.Connected:  							// my ConnectionEstablished must have been lost' send another one  							SendConnectionEstablished();  							return;  					}
Missing Default,Lidgren.Network,NetConnection,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetConnection.cs,ReceivedHandshake,The following switch statement is missing a default case: switch (m_status)  					{  						case NetConnectionStatus.Connected:  							// ok...  							break;  						case NetConnectionStatus.Disconnected:  						case NetConnectionStatus.Disconnecting:  						case NetConnectionStatus.None:  							// too bad' almost made it  							break;  						case NetConnectionStatus.ReceivedInitiation:  							// uh' a little premature... ignore  							break;  						case NetConnectionStatus.InitiatedConnect:  							// weird' should have been RespondedConnect...  							break;  						case NetConnectionStatus.RespondedConnect:  							// awesome  				  							NetIncomingMessage msg = m_peer.SetupReadHelperMessage(ptr' payloadLength);  							InitializeRemoteTimeOffset(msg.ReadSingle());    							m_peer.AcceptConnection(this);  							InitializePing();  							SetStatus(NetConnectionStatus.Connected' "Connected to " + NetUtility.ToHexString(m_remoteUniqueIdentifier));  							return;  					}
Missing Default,Lidgren.Network,NetUPnP,C:\repos\Nirklav_TCPChat\Lidgren.Network\NetUPnP.cs,CheckAvailability,The following switch statement is missing a default case: switch (m_status)  			{  				case UPnPStatus.NotAvailable:  					return false;  				case UPnPStatus.Available:  					return true;  				case UPnPStatus.Discovering:  					if (m_discoveryComplete.WaitOne(c_discoveryTimeOutMillis))  						return true;  					if (NetTime.Now > m_discoveryResponseDeadline)  						m_status = UPnPStatus.NotAvailable;  					return false;  			}
