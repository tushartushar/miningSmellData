Implementation smell,Namespace,Class,File,Method,Description
Long Method,ActiveUp.Net.Security.OpenPGP.Packets,Signature,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.Signature.cs,Parse,The method has 157 lines of code.
Complex Method,ActiveUp.Net.Security.OpenPGP.Packets,Signature,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.Signature.cs,Parse,Cyclomatic complexity of the method is 9
Long Identifier,ActiveUp.Net.Security.OpenPGP,Constants,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Constants.cs,,The length of the parameter ELGAMAL_ENCRYPT_ONLY_PUBLIC_KEY_MPI_COUNT is 41.
Long Identifier,ActiveUp.Net.Security.OpenPGP,Constants,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Constants.cs,,The length of the parameter ELGAMAL_ENCRYPT_ONLY_SECRET_KEY_MPI_COUNT is 41.
Long Statement,ActiveUp.Net.Security.OpenPGP,Constants,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Constants.cs,GetPublicMPICount,The length of the statement  "            else if (pkAlgorithm.Equals(PublicKeyAlgorithm.ElGamalEncryptOnly)) return Constants.ELGAMAL_ENCRYPT_ONLY_PUBLIC_KEY_MPI_COUNT; " is 127.
Long Statement,ActiveUp.Net.Security.OpenPGP,Constants,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Constants.cs,GetSecretMPICount,The length of the statement  "            else if (pkAlgorithm.Equals(PublicKeyAlgorithm.ElGamalEncryptOnly)) return Constants.ELGAMAL_ENCRYPT_ONLY_SECRET_KEY_MPI_COUNT; " is 127.
Long Statement,ActiveUp.Net.Security.OpenPGP,Constants,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Constants.cs,GetCipherBlockSize,The length of the statement  "            //else if (skAlgorithm.Equals(PublicKeyAlgorithm.ElGamalEncryptOnly)) return Constants.ELGAMAL_ENCRYPT_ONLY_PUBLIC_KEY_MPI_COUNT; " is 129.
Long Statement,ActiveUp.Net.Security.OpenPGP,Parser,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Parser.cs,DispatchPacket,The length of the statement  "            pack = System.Activator.CreateInstance("ActiveUp.Mail"' "ActiveUp.Net.Security.OpenPGP.Packets." + packet.Type.ToString()).Unwrap(); " is 132.
Long Statement,ActiveUp.Net.Security.OpenPGP,Parser,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Parser.cs,GetNextPacket,The length of the statement  "                packet = (Packet)(System.Activator.CreateInstance("ActiveUp.Mail"' "ActiveUp.Net.Security.OpenPGP.Packets."+type.ToString()).Unwrap()); " is 135.
Long Statement,ActiveUp.Net.Security.OpenPGP,Parser,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Parser.cs,GetNextPacket,The length of the statement  "                packet = (Packet)(System.Activator.CreateInstance(Type.GetType("ActiveUp.Net.Security.OpenPGP.Packets."+type.ToString()))); " is 123.
Long Statement,ActiveUp.Net.Security.OpenPGP,Parser,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Parser.cs,GetNextPacket,The length of the statement  "                packet = (Packet)(System.Activator.CreateInstance("ActiveUp.Mail"' "ActiveUp.Net.Security.OpenPGP.Packets." + type.ToString()).Unwrap()); " is 137.
Long Statement,ActiveUp.Net.Security.OpenPGP,Parser,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Parser.cs,GetNextPacket,The length of the statement  "                packet = (Packet)(System.Activator.CreateInstance(Type.GetType("ActiveUp.Net.Security.OpenPGP.Packets." + type.ToString()))); " is 125.
Long Statement,ActiveUp.Net.Security.OpenPGP.Packets,Signature,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.Signature.cs,Parse,The length of the statement  "                if (!next.Equals(5)) throw new InvalidPacketSyntaxException("Invalid syntax for a version 3 signature packet. Second byte is not 5."); " is 134.
Long Statement,ActiveUp.Net.Security.OpenPGP.Packets,Signature,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.Signature.cs,Parse,The length of the statement  "                        if ((spacket.Value[0] & (byte)KeyFlag.Authentication) == (int)KeyFlag.Authentication) sig.KeyFlags.Add(KeyFlag.Authentication); " is 127.
Long Statement,ActiveUp.Net.Security.OpenPGP.Packets,Signature,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.Signature.cs,Parse,The length of the statement  "                        if ((spacket.Value[0] & (byte)KeyFlag.CertifiesOtherKeys) == (int)KeyFlag.CertifiesOtherKeys) sig.KeyFlags.Add(KeyFlag.CertifiesOtherKeys); " is 139.
Long Statement,ActiveUp.Net.Security.OpenPGP.Packets,Signature,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.Signature.cs,Parse,The length of the statement  "                        if ((spacket.Value[0] & (byte)KeyFlag.EncryptsCommunications) == (int)KeyFlag.EncryptsCommunications) sig.KeyFlags.Add(KeyFlag.EncryptsCommunications); " is 151.
Long Statement,ActiveUp.Net.Security.OpenPGP.Packets,Signature,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.Signature.cs,Parse,The length of the statement  "                        if ((spacket.Value[0] & (byte)KeyFlag.EncryptsStorage) == (int)KeyFlag.EncryptsStorage) sig.KeyFlags.Add(KeyFlag.EncryptsStorage); " is 130.
Long Statement,ActiveUp.Net.Security.OpenPGP.Packets,Signature,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.Signature.cs,Parse,The length of the statement  "                        if ((spacket.Value[0] & (byte)Feature.ModificationDetection) == (int)Feature.ModificationDetection) sig.Features.Add(Feature.ModificationDetection); " is 148.
Long Statement,ActiveUp.Net.Security.OpenPGP.Packets,Signature,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.Signature.cs,Parse,The length of the statement  "                        if ((spacket.Value[0] & (byte)KeyServerPreference.NoModify) == (int)KeyServerPreference.NoModify) sig.KeyServerPreferences.Add(KeyServerPreference.NoModify); " is 157.
Long Statement,ActiveUp.Net.Security.OpenPGP.Packets,Signature,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.Signature.cs,Parse,The length of the statement  "                        if ((spacket.Value[0] & (byte)Reason.KeyCompromised) == (int)Reason.KeyCompromised) sig.ReasonForRevocation.Reason = Reason.KeyCompromised; " is 139.
Long Statement,ActiveUp.Net.Security.OpenPGP.Packets,Signature,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.Signature.cs,Parse,The length of the statement  "                        else if ((spacket.Value[0] & (byte)Reason.KeyRetired) == (int)Reason.KeyRetired) sig.ReasonForRevocation.Reason = Reason.KeyRetired; " is 132.
Long Statement,ActiveUp.Net.Security.OpenPGP.Packets,Signature,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.Signature.cs,Parse,The length of the statement  "                        else if ((spacket.Value[0] & (byte)Reason.KeySuperceded) == (int)Reason.KeySuperceded) sig.ReasonForRevocation.Reason = Reason.KeySuperceded; " is 141.
Long Statement,ActiveUp.Net.Security.OpenPGP.Packets,Signature,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.Signature.cs,Parse,The length of the statement  "                        else if ((spacket.Value[0] & (byte)Reason.NoneSpecified) == (int)Reason.NoneSpecified) sig.ReasonForRevocation.Reason = Reason.NoneSpecified; " is 141.
Long Statement,ActiveUp.Net.Security.OpenPGP.Packets,Signature,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.Signature.cs,Parse,The length of the statement  "                        else if ((spacket.Value[0] & (byte)Reason.UserIDNoLongerValid) == (int)Reason.UserIDNoLongerValid) sig.ReasonForRevocation.Reason = Reason.UserIDNoLongerValid; " is 159.
Long Statement,ActiveUp.Net.Security.OpenPGP.Packets,Signature,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.Signature.cs,Parse,The length of the statement  "                        for (int i = 0; i < spacket.Value.Length; i++) sig.PreferredCompressionAlgorithms.Add((CompressionAlgorithm)spacket.Value[i]); " is 126.
Long Statement,ActiveUp.Net.Security.OpenPGP.Packets,Signature,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.Signature.cs,Parse,The length of the statement  "                        for (int i = 0; i < spacket.Value.Length; i++) sig.PreferredSymmetricAlgorithms.Add((SymmetricKeyAlgorithm)spacket.Value[i]); " is 125.
Magic Number,ActiveUp.Net.Security.OpenPGP,Parser,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Parser.cs,GetNextPacket,The following statement contains a magic number: if (format.Equals(PacketFormat.Old))              {                  PacketType type = (PacketType)((firstbyte & 60) >> 2);    #if !PocketPC                  packet = (Packet)(System.Activator.CreateInstance("ActiveUp.Mail"' "ActiveUp.Net.Security.OpenPGP.Packets."+type.ToString()).Unwrap());  #else                  packet = (Packet)(System.Activator.CreateInstance(Type.GetType("ActiveUp.Net.Security.OpenPGP.Packets."+type.ToString())));  #endif                    //ActiveUp.Net.Mail.Logger.AddEntry("Packet : "+packet.ToString());                    packet.Format = format;                  packet.Type = type;                    byte lengthType = (byte)(firstbyte & 3);                  byte next = (byte)stream.ReadByte();                  if (lengthType == 0)                   {                      packet.BodyLength = next;                      packet.TotalLength = packet.BodyLength + 2;                  }                  else if (lengthType == 1)                  {                      byte nextnext = (byte)stream.ReadByte();                      packet.BodyLength = (next << 8) + nextnext;                      packet.TotalLength = packet.BodyLength + 3;                  }                  else if (lengthType == 2)                  {                      // A VERIFIER !                      byte nextnext = (byte)stream.ReadByte();                      byte nextnextnext = (byte)stream.ReadByte();                      byte nextnextnextnext = (byte)stream.ReadByte();                      packet.BodyLength = (next << 24) + (nextnext << 16) + (nextnextnext << 8) + nextnextnextnext;                      packet.TotalLength = packet.BodyLength + 5;                  }                  else if (lengthType == 3) packet.TotalLength = packet.BodyLength + 1;                  else throw new InvalidPacketSyntaxException("Invalid old format packet length type : "+lengthType.ToString());                  outstream.Write(stream.ToArray()' (int)stream.Position' packet.BodyLength);                  stream.Position += packet.BodyLength;              }
Magic Number,ActiveUp.Net.Security.OpenPGP,Parser,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Parser.cs,GetNextPacket,The following statement contains a magic number: if (format.Equals(PacketFormat.Old))              {                  PacketType type = (PacketType)((firstbyte & 60) >> 2);    #if !PocketPC                  packet = (Packet)(System.Activator.CreateInstance("ActiveUp.Mail"' "ActiveUp.Net.Security.OpenPGP.Packets."+type.ToString()).Unwrap());  #else                  packet = (Packet)(System.Activator.CreateInstance(Type.GetType("ActiveUp.Net.Security.OpenPGP.Packets."+type.ToString())));  #endif                    //ActiveUp.Net.Mail.Logger.AddEntry("Packet : "+packet.ToString());                    packet.Format = format;                  packet.Type = type;                    byte lengthType = (byte)(firstbyte & 3);                  byte next = (byte)stream.ReadByte();                  if (lengthType == 0)                   {                      packet.BodyLength = next;                      packet.TotalLength = packet.BodyLength + 2;                  }                  else if (lengthType == 1)                  {                      byte nextnext = (byte)stream.ReadByte();                      packet.BodyLength = (next << 8) + nextnext;                      packet.TotalLength = packet.BodyLength + 3;                  }                  else if (lengthType == 2)                  {                      // A VERIFIER !                      byte nextnext = (byte)stream.ReadByte();                      byte nextnextnext = (byte)stream.ReadByte();                      byte nextnextnextnext = (byte)stream.ReadByte();                      packet.BodyLength = (next << 24) + (nextnext << 16) + (nextnextnext << 8) + nextnextnextnext;                      packet.TotalLength = packet.BodyLength + 5;                  }                  else if (lengthType == 3) packet.TotalLength = packet.BodyLength + 1;                  else throw new InvalidPacketSyntaxException("Invalid old format packet length type : "+lengthType.ToString());                  outstream.Write(stream.ToArray()' (int)stream.Position' packet.BodyLength);                  stream.Position += packet.BodyLength;              }
Magic Number,ActiveUp.Net.Security.OpenPGP,Parser,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Parser.cs,GetNextPacket,The following statement contains a magic number: if (format.Equals(PacketFormat.Old))              {                  PacketType type = (PacketType)((firstbyte & 60) >> 2);    #if !PocketPC                  packet = (Packet)(System.Activator.CreateInstance("ActiveUp.Mail"' "ActiveUp.Net.Security.OpenPGP.Packets."+type.ToString()).Unwrap());  #else                  packet = (Packet)(System.Activator.CreateInstance(Type.GetType("ActiveUp.Net.Security.OpenPGP.Packets."+type.ToString())));  #endif                    //ActiveUp.Net.Mail.Logger.AddEntry("Packet : "+packet.ToString());                    packet.Format = format;                  packet.Type = type;                    byte lengthType = (byte)(firstbyte & 3);                  byte next = (byte)stream.ReadByte();                  if (lengthType == 0)                   {                      packet.BodyLength = next;                      packet.TotalLength = packet.BodyLength + 2;                  }                  else if (lengthType == 1)                  {                      byte nextnext = (byte)stream.ReadByte();                      packet.BodyLength = (next << 8) + nextnext;                      packet.TotalLength = packet.BodyLength + 3;                  }                  else if (lengthType == 2)                  {                      // A VERIFIER !                      byte nextnext = (byte)stream.ReadByte();                      byte nextnextnext = (byte)stream.ReadByte();                      byte nextnextnextnext = (byte)stream.ReadByte();                      packet.BodyLength = (next << 24) + (nextnext << 16) + (nextnextnext << 8) + nextnextnextnext;                      packet.TotalLength = packet.BodyLength + 5;                  }                  else if (lengthType == 3) packet.TotalLength = packet.BodyLength + 1;                  else throw new InvalidPacketSyntaxException("Invalid old format packet length type : "+lengthType.ToString());                  outstream.Write(stream.ToArray()' (int)stream.Position' packet.BodyLength);                  stream.Position += packet.BodyLength;              }
Magic Number,ActiveUp.Net.Security.OpenPGP,Parser,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Parser.cs,GetNextPacket,The following statement contains a magic number: if (format.Equals(PacketFormat.Old))              {                  PacketType type = (PacketType)((firstbyte & 60) >> 2);    #if !PocketPC                  packet = (Packet)(System.Activator.CreateInstance("ActiveUp.Mail"' "ActiveUp.Net.Security.OpenPGP.Packets."+type.ToString()).Unwrap());  #else                  packet = (Packet)(System.Activator.CreateInstance(Type.GetType("ActiveUp.Net.Security.OpenPGP.Packets."+type.ToString())));  #endif                    //ActiveUp.Net.Mail.Logger.AddEntry("Packet : "+packet.ToString());                    packet.Format = format;                  packet.Type = type;                    byte lengthType = (byte)(firstbyte & 3);                  byte next = (byte)stream.ReadByte();                  if (lengthType == 0)                   {                      packet.BodyLength = next;                      packet.TotalLength = packet.BodyLength + 2;                  }                  else if (lengthType == 1)                  {                      byte nextnext = (byte)stream.ReadByte();                      packet.BodyLength = (next << 8) + nextnext;                      packet.TotalLength = packet.BodyLength + 3;                  }                  else if (lengthType == 2)                  {                      // A VERIFIER !                      byte nextnext = (byte)stream.ReadByte();                      byte nextnextnext = (byte)stream.ReadByte();                      byte nextnextnextnext = (byte)stream.ReadByte();                      packet.BodyLength = (next << 24) + (nextnext << 16) + (nextnextnext << 8) + nextnextnextnext;                      packet.TotalLength = packet.BodyLength + 5;                  }                  else if (lengthType == 3) packet.TotalLength = packet.BodyLength + 1;                  else throw new InvalidPacketSyntaxException("Invalid old format packet length type : "+lengthType.ToString());                  outstream.Write(stream.ToArray()' (int)stream.Position' packet.BodyLength);                  stream.Position += packet.BodyLength;              }
Magic Number,ActiveUp.Net.Security.OpenPGP,Parser,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Parser.cs,GetNextPacket,The following statement contains a magic number: if (format.Equals(PacketFormat.Old))              {                  PacketType type = (PacketType)((firstbyte & 60) >> 2);    #if !PocketPC                  packet = (Packet)(System.Activator.CreateInstance("ActiveUp.Mail"' "ActiveUp.Net.Security.OpenPGP.Packets."+type.ToString()).Unwrap());  #else                  packet = (Packet)(System.Activator.CreateInstance(Type.GetType("ActiveUp.Net.Security.OpenPGP.Packets."+type.ToString())));  #endif                    //ActiveUp.Net.Mail.Logger.AddEntry("Packet : "+packet.ToString());                    packet.Format = format;                  packet.Type = type;                    byte lengthType = (byte)(firstbyte & 3);                  byte next = (byte)stream.ReadByte();                  if (lengthType == 0)                   {                      packet.BodyLength = next;                      packet.TotalLength = packet.BodyLength + 2;                  }                  else if (lengthType == 1)                  {                      byte nextnext = (byte)stream.ReadByte();                      packet.BodyLength = (next << 8) + nextnext;                      packet.TotalLength = packet.BodyLength + 3;                  }                  else if (lengthType == 2)                  {                      // A VERIFIER !                      byte nextnext = (byte)stream.ReadByte();                      byte nextnextnext = (byte)stream.ReadByte();                      byte nextnextnextnext = (byte)stream.ReadByte();                      packet.BodyLength = (next << 24) + (nextnext << 16) + (nextnextnext << 8) + nextnextnextnext;                      packet.TotalLength = packet.BodyLength + 5;                  }                  else if (lengthType == 3) packet.TotalLength = packet.BodyLength + 1;                  else throw new InvalidPacketSyntaxException("Invalid old format packet length type : "+lengthType.ToString());                  outstream.Write(stream.ToArray()' (int)stream.Position' packet.BodyLength);                  stream.Position += packet.BodyLength;              }
Magic Number,ActiveUp.Net.Security.OpenPGP,Parser,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Parser.cs,GetNextPacket,The following statement contains a magic number: if (format.Equals(PacketFormat.Old))              {                  PacketType type = (PacketType)((firstbyte & 60) >> 2);    #if !PocketPC                  packet = (Packet)(System.Activator.CreateInstance("ActiveUp.Mail"' "ActiveUp.Net.Security.OpenPGP.Packets."+type.ToString()).Unwrap());  #else                  packet = (Packet)(System.Activator.CreateInstance(Type.GetType("ActiveUp.Net.Security.OpenPGP.Packets."+type.ToString())));  #endif                    //ActiveUp.Net.Mail.Logger.AddEntry("Packet : "+packet.ToString());                    packet.Format = format;                  packet.Type = type;                    byte lengthType = (byte)(firstbyte & 3);                  byte next = (byte)stream.ReadByte();                  if (lengthType == 0)                   {                      packet.BodyLength = next;                      packet.TotalLength = packet.BodyLength + 2;                  }                  else if (lengthType == 1)                  {                      byte nextnext = (byte)stream.ReadByte();                      packet.BodyLength = (next << 8) + nextnext;                      packet.TotalLength = packet.BodyLength + 3;                  }                  else if (lengthType == 2)                  {                      // A VERIFIER !                      byte nextnext = (byte)stream.ReadByte();                      byte nextnextnext = (byte)stream.ReadByte();                      byte nextnextnextnext = (byte)stream.ReadByte();                      packet.BodyLength = (next << 24) + (nextnext << 16) + (nextnextnext << 8) + nextnextnextnext;                      packet.TotalLength = packet.BodyLength + 5;                  }                  else if (lengthType == 3) packet.TotalLength = packet.BodyLength + 1;                  else throw new InvalidPacketSyntaxException("Invalid old format packet length type : "+lengthType.ToString());                  outstream.Write(stream.ToArray()' (int)stream.Position' packet.BodyLength);                  stream.Position += packet.BodyLength;              }
Magic Number,ActiveUp.Net.Security.OpenPGP,Parser,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Parser.cs,GetNextPacket,The following statement contains a magic number: if (format.Equals(PacketFormat.Old))              {                  PacketType type = (PacketType)((firstbyte & 60) >> 2);    #if !PocketPC                  packet = (Packet)(System.Activator.CreateInstance("ActiveUp.Mail"' "ActiveUp.Net.Security.OpenPGP.Packets."+type.ToString()).Unwrap());  #else                  packet = (Packet)(System.Activator.CreateInstance(Type.GetType("ActiveUp.Net.Security.OpenPGP.Packets."+type.ToString())));  #endif                    //ActiveUp.Net.Mail.Logger.AddEntry("Packet : "+packet.ToString());                    packet.Format = format;                  packet.Type = type;                    byte lengthType = (byte)(firstbyte & 3);                  byte next = (byte)stream.ReadByte();                  if (lengthType == 0)                   {                      packet.BodyLength = next;                      packet.TotalLength = packet.BodyLength + 2;                  }                  else if (lengthType == 1)                  {                      byte nextnext = (byte)stream.ReadByte();                      packet.BodyLength = (next << 8) + nextnext;                      packet.TotalLength = packet.BodyLength + 3;                  }                  else if (lengthType == 2)                  {                      // A VERIFIER !                      byte nextnext = (byte)stream.ReadByte();                      byte nextnextnext = (byte)stream.ReadByte();                      byte nextnextnextnext = (byte)stream.ReadByte();                      packet.BodyLength = (next << 24) + (nextnext << 16) + (nextnextnext << 8) + nextnextnextnext;                      packet.TotalLength = packet.BodyLength + 5;                  }                  else if (lengthType == 3) packet.TotalLength = packet.BodyLength + 1;                  else throw new InvalidPacketSyntaxException("Invalid old format packet length type : "+lengthType.ToString());                  outstream.Write(stream.ToArray()' (int)stream.Position' packet.BodyLength);                  stream.Position += packet.BodyLength;              }
Magic Number,ActiveUp.Net.Security.OpenPGP,Parser,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Parser.cs,GetNextPacket,The following statement contains a magic number: if (format.Equals(PacketFormat.Old))              {                  PacketType type = (PacketType)((firstbyte & 60) >> 2);    #if !PocketPC                  packet = (Packet)(System.Activator.CreateInstance("ActiveUp.Mail"' "ActiveUp.Net.Security.OpenPGP.Packets."+type.ToString()).Unwrap());  #else                  packet = (Packet)(System.Activator.CreateInstance(Type.GetType("ActiveUp.Net.Security.OpenPGP.Packets."+type.ToString())));  #endif                    //ActiveUp.Net.Mail.Logger.AddEntry("Packet : "+packet.ToString());                    packet.Format = format;                  packet.Type = type;                    byte lengthType = (byte)(firstbyte & 3);                  byte next = (byte)stream.ReadByte();                  if (lengthType == 0)                   {                      packet.BodyLength = next;                      packet.TotalLength = packet.BodyLength + 2;                  }                  else if (lengthType == 1)                  {                      byte nextnext = (byte)stream.ReadByte();                      packet.BodyLength = (next << 8) + nextnext;                      packet.TotalLength = packet.BodyLength + 3;                  }                  else if (lengthType == 2)                  {                      // A VERIFIER !                      byte nextnext = (byte)stream.ReadByte();                      byte nextnextnext = (byte)stream.ReadByte();                      byte nextnextnextnext = (byte)stream.ReadByte();                      packet.BodyLength = (next << 24) + (nextnext << 16) + (nextnextnext << 8) + nextnextnextnext;                      packet.TotalLength = packet.BodyLength + 5;                  }                  else if (lengthType == 3) packet.TotalLength = packet.BodyLength + 1;                  else throw new InvalidPacketSyntaxException("Invalid old format packet length type : "+lengthType.ToString());                  outstream.Write(stream.ToArray()' (int)stream.Position' packet.BodyLength);                  stream.Position += packet.BodyLength;              }
Magic Number,ActiveUp.Net.Security.OpenPGP,Parser,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Parser.cs,GetNextPacket,The following statement contains a magic number: if (format.Equals(PacketFormat.Old))              {                  PacketType type = (PacketType)((firstbyte & 60) >> 2);    #if !PocketPC                  packet = (Packet)(System.Activator.CreateInstance("ActiveUp.Mail"' "ActiveUp.Net.Security.OpenPGP.Packets."+type.ToString()).Unwrap());  #else                  packet = (Packet)(System.Activator.CreateInstance(Type.GetType("ActiveUp.Net.Security.OpenPGP.Packets."+type.ToString())));  #endif                    //ActiveUp.Net.Mail.Logger.AddEntry("Packet : "+packet.ToString());                    packet.Format = format;                  packet.Type = type;                    byte lengthType = (byte)(firstbyte & 3);                  byte next = (byte)stream.ReadByte();                  if (lengthType == 0)                   {                      packet.BodyLength = next;                      packet.TotalLength = packet.BodyLength + 2;                  }                  else if (lengthType == 1)                  {                      byte nextnext = (byte)stream.ReadByte();                      packet.BodyLength = (next << 8) + nextnext;                      packet.TotalLength = packet.BodyLength + 3;                  }                  else if (lengthType == 2)                  {                      // A VERIFIER !                      byte nextnext = (byte)stream.ReadByte();                      byte nextnextnext = (byte)stream.ReadByte();                      byte nextnextnextnext = (byte)stream.ReadByte();                      packet.BodyLength = (next << 24) + (nextnext << 16) + (nextnextnext << 8) + nextnextnextnext;                      packet.TotalLength = packet.BodyLength + 5;                  }                  else if (lengthType == 3) packet.TotalLength = packet.BodyLength + 1;                  else throw new InvalidPacketSyntaxException("Invalid old format packet length type : "+lengthType.ToString());                  outstream.Write(stream.ToArray()' (int)stream.Position' packet.BodyLength);                  stream.Position += packet.BodyLength;              }
Magic Number,ActiveUp.Net.Security.OpenPGP,Parser,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Parser.cs,GetNextPacket,The following statement contains a magic number: if (format.Equals(PacketFormat.Old))              {                  PacketType type = (PacketType)((firstbyte & 60) >> 2);    #if !PocketPC                  packet = (Packet)(System.Activator.CreateInstance("ActiveUp.Mail"' "ActiveUp.Net.Security.OpenPGP.Packets."+type.ToString()).Unwrap());  #else                  packet = (Packet)(System.Activator.CreateInstance(Type.GetType("ActiveUp.Net.Security.OpenPGP.Packets."+type.ToString())));  #endif                    //ActiveUp.Net.Mail.Logger.AddEntry("Packet : "+packet.ToString());                    packet.Format = format;                  packet.Type = type;                    byte lengthType = (byte)(firstbyte & 3);                  byte next = (byte)stream.ReadByte();                  if (lengthType == 0)                   {                      packet.BodyLength = next;                      packet.TotalLength = packet.BodyLength + 2;                  }                  else if (lengthType == 1)                  {                      byte nextnext = (byte)stream.ReadByte();                      packet.BodyLength = (next << 8) + nextnext;                      packet.TotalLength = packet.BodyLength + 3;                  }                  else if (lengthType == 2)                  {                      // A VERIFIER !                      byte nextnext = (byte)stream.ReadByte();                      byte nextnextnext = (byte)stream.ReadByte();                      byte nextnextnextnext = (byte)stream.ReadByte();                      packet.BodyLength = (next << 24) + (nextnext << 16) + (nextnextnext << 8) + nextnextnextnext;                      packet.TotalLength = packet.BodyLength + 5;                  }                  else if (lengthType == 3) packet.TotalLength = packet.BodyLength + 1;                  else throw new InvalidPacketSyntaxException("Invalid old format packet length type : "+lengthType.ToString());                  outstream.Write(stream.ToArray()' (int)stream.Position' packet.BodyLength);                  stream.Position += packet.BodyLength;              }
Magic Number,ActiveUp.Net.Security.OpenPGP,Parser,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Parser.cs,GetNextPacket,The following statement contains a magic number: if (format.Equals(PacketFormat.Old))              {                  PacketType type = (PacketType)((firstbyte & 60) >> 2);    #if !PocketPC                  packet = (Packet)(System.Activator.CreateInstance("ActiveUp.Mail"' "ActiveUp.Net.Security.OpenPGP.Packets."+type.ToString()).Unwrap());  #else                  packet = (Packet)(System.Activator.CreateInstance(Type.GetType("ActiveUp.Net.Security.OpenPGP.Packets."+type.ToString())));  #endif                    //ActiveUp.Net.Mail.Logger.AddEntry("Packet : "+packet.ToString());                    packet.Format = format;                  packet.Type = type;                    byte lengthType = (byte)(firstbyte & 3);                  byte next = (byte)stream.ReadByte();                  if (lengthType == 0)                   {                      packet.BodyLength = next;                      packet.TotalLength = packet.BodyLength + 2;                  }                  else if (lengthType == 1)                  {                      byte nextnext = (byte)stream.ReadByte();                      packet.BodyLength = (next << 8) + nextnext;                      packet.TotalLength = packet.BodyLength + 3;                  }                  else if (lengthType == 2)                  {                      // A VERIFIER !                      byte nextnext = (byte)stream.ReadByte();                      byte nextnextnext = (byte)stream.ReadByte();                      byte nextnextnextnext = (byte)stream.ReadByte();                      packet.BodyLength = (next << 24) + (nextnext << 16) + (nextnextnext << 8) + nextnextnextnext;                      packet.TotalLength = packet.BodyLength + 5;                  }                  else if (lengthType == 3) packet.TotalLength = packet.BodyLength + 1;                  else throw new InvalidPacketSyntaxException("Invalid old format packet length type : "+lengthType.ToString());                  outstream.Write(stream.ToArray()' (int)stream.Position' packet.BodyLength);                  stream.Position += packet.BodyLength;              }
Magic Number,ActiveUp.Net.Security.OpenPGP,Parser,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Parser.cs,GetNextPacket,The following statement contains a magic number: if (format.Equals(PacketFormat.Old))              {                  PacketType type = (PacketType)((firstbyte & 60) >> 2);    #if !PocketPC                  packet = (Packet)(System.Activator.CreateInstance("ActiveUp.Mail"' "ActiveUp.Net.Security.OpenPGP.Packets."+type.ToString()).Unwrap());  #else                  packet = (Packet)(System.Activator.CreateInstance(Type.GetType("ActiveUp.Net.Security.OpenPGP.Packets."+type.ToString())));  #endif                    //ActiveUp.Net.Mail.Logger.AddEntry("Packet : "+packet.ToString());                    packet.Format = format;                  packet.Type = type;                    byte lengthType = (byte)(firstbyte & 3);                  byte next = (byte)stream.ReadByte();                  if (lengthType == 0)                   {                      packet.BodyLength = next;                      packet.TotalLength = packet.BodyLength + 2;                  }                  else if (lengthType == 1)                  {                      byte nextnext = (byte)stream.ReadByte();                      packet.BodyLength = (next << 8) + nextnext;                      packet.TotalLength = packet.BodyLength + 3;                  }                  else if (lengthType == 2)                  {                      // A VERIFIER !                      byte nextnext = (byte)stream.ReadByte();                      byte nextnextnext = (byte)stream.ReadByte();                      byte nextnextnextnext = (byte)stream.ReadByte();                      packet.BodyLength = (next << 24) + (nextnext << 16) + (nextnextnext << 8) + nextnextnextnext;                      packet.TotalLength = packet.BodyLength + 5;                  }                  else if (lengthType == 3) packet.TotalLength = packet.BodyLength + 1;                  else throw new InvalidPacketSyntaxException("Invalid old format packet length type : "+lengthType.ToString());                  outstream.Write(stream.ToArray()' (int)stream.Position' packet.BodyLength);                  stream.Position += packet.BodyLength;              }
Magic Number,ActiveUp.Net.Security.OpenPGP,Parser,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Parser.cs,GetNextPacket,The following statement contains a magic number: if (format.Equals(PacketFormat.New))              {                  PacketType type = (PacketType)(firstbyte & 63);                                    #if !PocketPC                  packet = (Packet)(System.Activator.CreateInstance("ActiveUp.Mail"' "ActiveUp.Net.Security.OpenPGP.Packets." + type.ToString()).Unwrap());                  #else                  packet = (Packet)(System.Activator.CreateInstance(Type.GetType("ActiveUp.Net.Security.OpenPGP.Packets." + type.ToString())));                  #endif                                    packet.Format = format;                  packet.Type = type;                    AddNextPacketNewFormat(ref packet' ref stream' ref outstream);              }
Magic Number,ActiveUp.Net.Security.OpenPGP,Parser,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Parser.cs,AddNextPacketNewFormat,The following statement contains a magic number: if (next < 192)              {                  length = next;                  packet.BodyLength += next;                  packet.TotalLength += packet.BodyLength + 2;              }              else if (next > 191 && next < 223)              {                  byte nextnext = (byte)stream.ReadByte();                  length = ((next - 192) << 8) + nextnext + 192;                  packet.BodyLength += length;                  packet.TotalLength += packet.BodyLength + 3;              }              else if (next == 255)              {                  int nextnext = stream.ReadByte();                  int nextnextnext = stream.ReadByte();                  int nextnextnextnext = stream.ReadByte();                  int nextnextnextnextnext = stream.ReadByte();                  length = (nextnext << 24) | (nextnextnext << 16) | (nextnextnextnext << 8) | nextnextnextnextnext;                  packet.BodyLength += length;                  packet.TotalLength += packet.BodyLength + 6;              }              else if (next > 223 && next < 255)              {                  int partlength = (1 << (next & 31));                  packet.BodyLength += partlength;                  packet.TotalLength += partlength + 1;                  outstream.Write(stream.ToArray()' (int)stream.Position' partlength);                  stream.Position += partlength;                  AddNextPacketNewFormat(ref packet' ref stream' ref outstream);                  return;              }
Magic Number,ActiveUp.Net.Security.OpenPGP,Parser,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Parser.cs,AddNextPacketNewFormat,The following statement contains a magic number: if (next < 192)              {                  length = next;                  packet.BodyLength += next;                  packet.TotalLength += packet.BodyLength + 2;              }              else if (next > 191 && next < 223)              {                  byte nextnext = (byte)stream.ReadByte();                  length = ((next - 192) << 8) + nextnext + 192;                  packet.BodyLength += length;                  packet.TotalLength += packet.BodyLength + 3;              }              else if (next == 255)              {                  int nextnext = stream.ReadByte();                  int nextnextnext = stream.ReadByte();                  int nextnextnextnext = stream.ReadByte();                  int nextnextnextnextnext = stream.ReadByte();                  length = (nextnext << 24) | (nextnextnext << 16) | (nextnextnextnext << 8) | nextnextnextnextnext;                  packet.BodyLength += length;                  packet.TotalLength += packet.BodyLength + 6;              }              else if (next > 223 && next < 255)              {                  int partlength = (1 << (next & 31));                  packet.BodyLength += partlength;                  packet.TotalLength += partlength + 1;                  outstream.Write(stream.ToArray()' (int)stream.Position' partlength);                  stream.Position += partlength;                  AddNextPacketNewFormat(ref packet' ref stream' ref outstream);                  return;              }
Magic Number,ActiveUp.Net.Security.OpenPGP,Parser,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Parser.cs,AddNextPacketNewFormat,The following statement contains a magic number: if (next < 192)              {                  length = next;                  packet.BodyLength += next;                  packet.TotalLength += packet.BodyLength + 2;              }              else if (next > 191 && next < 223)              {                  byte nextnext = (byte)stream.ReadByte();                  length = ((next - 192) << 8) + nextnext + 192;                  packet.BodyLength += length;                  packet.TotalLength += packet.BodyLength + 3;              }              else if (next == 255)              {                  int nextnext = stream.ReadByte();                  int nextnextnext = stream.ReadByte();                  int nextnextnextnext = stream.ReadByte();                  int nextnextnextnextnext = stream.ReadByte();                  length = (nextnext << 24) | (nextnextnext << 16) | (nextnextnextnext << 8) | nextnextnextnextnext;                  packet.BodyLength += length;                  packet.TotalLength += packet.BodyLength + 6;              }              else if (next > 223 && next < 255)              {                  int partlength = (1 << (next & 31));                  packet.BodyLength += partlength;                  packet.TotalLength += partlength + 1;                  outstream.Write(stream.ToArray()' (int)stream.Position' partlength);                  stream.Position += partlength;                  AddNextPacketNewFormat(ref packet' ref stream' ref outstream);                  return;              }
Magic Number,ActiveUp.Net.Security.OpenPGP,Parser,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Parser.cs,AddNextPacketNewFormat,The following statement contains a magic number: if (next < 192)              {                  length = next;                  packet.BodyLength += next;                  packet.TotalLength += packet.BodyLength + 2;              }              else if (next > 191 && next < 223)              {                  byte nextnext = (byte)stream.ReadByte();                  length = ((next - 192) << 8) + nextnext + 192;                  packet.BodyLength += length;                  packet.TotalLength += packet.BodyLength + 3;              }              else if (next == 255)              {                  int nextnext = stream.ReadByte();                  int nextnextnext = stream.ReadByte();                  int nextnextnextnext = stream.ReadByte();                  int nextnextnextnextnext = stream.ReadByte();                  length = (nextnext << 24) | (nextnextnext << 16) | (nextnextnextnext << 8) | nextnextnextnextnext;                  packet.BodyLength += length;                  packet.TotalLength += packet.BodyLength + 6;              }              else if (next > 223 && next < 255)              {                  int partlength = (1 << (next & 31));                  packet.BodyLength += partlength;                  packet.TotalLength += partlength + 1;                  outstream.Write(stream.ToArray()' (int)stream.Position' partlength);                  stream.Position += partlength;                  AddNextPacketNewFormat(ref packet' ref stream' ref outstream);                  return;              }
Magic Number,ActiveUp.Net.Security.OpenPGP,Parser,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Parser.cs,AddNextPacketNewFormat,The following statement contains a magic number: if (next < 192)              {                  length = next;                  packet.BodyLength += next;                  packet.TotalLength += packet.BodyLength + 2;              }              else if (next > 191 && next < 223)              {                  byte nextnext = (byte)stream.ReadByte();                  length = ((next - 192) << 8) + nextnext + 192;                  packet.BodyLength += length;                  packet.TotalLength += packet.BodyLength + 3;              }              else if (next == 255)              {                  int nextnext = stream.ReadByte();                  int nextnextnext = stream.ReadByte();                  int nextnextnextnext = stream.ReadByte();                  int nextnextnextnextnext = stream.ReadByte();                  length = (nextnext << 24) | (nextnextnext << 16) | (nextnextnextnext << 8) | nextnextnextnextnext;                  packet.BodyLength += length;                  packet.TotalLength += packet.BodyLength + 6;              }              else if (next > 223 && next < 255)              {                  int partlength = (1 << (next & 31));                  packet.BodyLength += partlength;                  packet.TotalLength += partlength + 1;                  outstream.Write(stream.ToArray()' (int)stream.Position' partlength);                  stream.Position += partlength;                  AddNextPacketNewFormat(ref packet' ref stream' ref outstream);                  return;              }
Magic Number,ActiveUp.Net.Security.OpenPGP,Parser,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Parser.cs,AddNextPacketNewFormat,The following statement contains a magic number: if (next < 192)              {                  length = next;                  packet.BodyLength += next;                  packet.TotalLength += packet.BodyLength + 2;              }              else if (next > 191 && next < 223)              {                  byte nextnext = (byte)stream.ReadByte();                  length = ((next - 192) << 8) + nextnext + 192;                  packet.BodyLength += length;                  packet.TotalLength += packet.BodyLength + 3;              }              else if (next == 255)              {                  int nextnext = stream.ReadByte();                  int nextnextnext = stream.ReadByte();                  int nextnextnextnext = stream.ReadByte();                  int nextnextnextnextnext = stream.ReadByte();                  length = (nextnext << 24) | (nextnextnext << 16) | (nextnextnextnext << 8) | nextnextnextnextnext;                  packet.BodyLength += length;                  packet.TotalLength += packet.BodyLength + 6;              }              else if (next > 223 && next < 255)              {                  int partlength = (1 << (next & 31));                  packet.BodyLength += partlength;                  packet.TotalLength += partlength + 1;                  outstream.Write(stream.ToArray()' (int)stream.Position' partlength);                  stream.Position += partlength;                  AddNextPacketNewFormat(ref packet' ref stream' ref outstream);                  return;              }
Magic Number,ActiveUp.Net.Security.OpenPGP,Parser,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Parser.cs,AddNextPacketNewFormat,The following statement contains a magic number: if (next < 192)              {                  length = next;                  packet.BodyLength += next;                  packet.TotalLength += packet.BodyLength + 2;              }              else if (next > 191 && next < 223)              {                  byte nextnext = (byte)stream.ReadByte();                  length = ((next - 192) << 8) + nextnext + 192;                  packet.BodyLength += length;                  packet.TotalLength += packet.BodyLength + 3;              }              else if (next == 255)              {                  int nextnext = stream.ReadByte();                  int nextnextnext = stream.ReadByte();                  int nextnextnextnext = stream.ReadByte();                  int nextnextnextnextnext = stream.ReadByte();                  length = (nextnext << 24) | (nextnextnext << 16) | (nextnextnextnext << 8) | nextnextnextnextnext;                  packet.BodyLength += length;                  packet.TotalLength += packet.BodyLength + 6;              }              else if (next > 223 && next < 255)              {                  int partlength = (1 << (next & 31));                  packet.BodyLength += partlength;                  packet.TotalLength += partlength + 1;                  outstream.Write(stream.ToArray()' (int)stream.Position' partlength);                  stream.Position += partlength;                  AddNextPacketNewFormat(ref packet' ref stream' ref outstream);                  return;              }
Magic Number,ActiveUp.Net.Security.OpenPGP,Parser,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Parser.cs,AddNextPacketNewFormat,The following statement contains a magic number: if (next < 192)              {                  length = next;                  packet.BodyLength += next;                  packet.TotalLength += packet.BodyLength + 2;              }              else if (next > 191 && next < 223)              {                  byte nextnext = (byte)stream.ReadByte();                  length = ((next - 192) << 8) + nextnext + 192;                  packet.BodyLength += length;                  packet.TotalLength += packet.BodyLength + 3;              }              else if (next == 255)              {                  int nextnext = stream.ReadByte();                  int nextnextnext = stream.ReadByte();                  int nextnextnextnext = stream.ReadByte();                  int nextnextnextnextnext = stream.ReadByte();                  length = (nextnext << 24) | (nextnextnext << 16) | (nextnextnextnext << 8) | nextnextnextnextnext;                  packet.BodyLength += length;                  packet.TotalLength += packet.BodyLength + 6;              }              else if (next > 223 && next < 255)              {                  int partlength = (1 << (next & 31));                  packet.BodyLength += partlength;                  packet.TotalLength += partlength + 1;                  outstream.Write(stream.ToArray()' (int)stream.Position' partlength);                  stream.Position += partlength;                  AddNextPacketNewFormat(ref packet' ref stream' ref outstream);                  return;              }
Magic Number,ActiveUp.Net.Security.OpenPGP,Parser,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Parser.cs,AddNextPacketNewFormat,The following statement contains a magic number: if (next < 192)              {                  length = next;                  packet.BodyLength += next;                  packet.TotalLength += packet.BodyLength + 2;              }              else if (next > 191 && next < 223)              {                  byte nextnext = (byte)stream.ReadByte();                  length = ((next - 192) << 8) + nextnext + 192;                  packet.BodyLength += length;                  packet.TotalLength += packet.BodyLength + 3;              }              else if (next == 255)              {                  int nextnext = stream.ReadByte();                  int nextnextnext = stream.ReadByte();                  int nextnextnextnext = stream.ReadByte();                  int nextnextnextnextnext = stream.ReadByte();                  length = (nextnext << 24) | (nextnextnext << 16) | (nextnextnextnext << 8) | nextnextnextnextnext;                  packet.BodyLength += length;                  packet.TotalLength += packet.BodyLength + 6;              }              else if (next > 223 && next < 255)              {                  int partlength = (1 << (next & 31));                  packet.BodyLength += partlength;                  packet.TotalLength += partlength + 1;                  outstream.Write(stream.ToArray()' (int)stream.Position' partlength);                  stream.Position += partlength;                  AddNextPacketNewFormat(ref packet' ref stream' ref outstream);                  return;              }
Magic Number,ActiveUp.Net.Security.OpenPGP,Parser,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Parser.cs,AddNextPacketNewFormat,The following statement contains a magic number: if (next < 192)              {                  length = next;                  packet.BodyLength += next;                  packet.TotalLength += packet.BodyLength + 2;              }              else if (next > 191 && next < 223)              {                  byte nextnext = (byte)stream.ReadByte();                  length = ((next - 192) << 8) + nextnext + 192;                  packet.BodyLength += length;                  packet.TotalLength += packet.BodyLength + 3;              }              else if (next == 255)              {                  int nextnext = stream.ReadByte();                  int nextnextnext = stream.ReadByte();                  int nextnextnextnext = stream.ReadByte();                  int nextnextnextnextnext = stream.ReadByte();                  length = (nextnext << 24) | (nextnextnext << 16) | (nextnextnextnext << 8) | nextnextnextnextnext;                  packet.BodyLength += length;                  packet.TotalLength += packet.BodyLength + 6;              }              else if (next > 223 && next < 255)              {                  int partlength = (1 << (next & 31));                  packet.BodyLength += partlength;                  packet.TotalLength += partlength + 1;                  outstream.Write(stream.ToArray()' (int)stream.Position' partlength);                  stream.Position += partlength;                  AddNextPacketNewFormat(ref packet' ref stream' ref outstream);                  return;              }
Magic Number,ActiveUp.Net.Security.OpenPGP,Parser,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Parser.cs,AddNextPacketNewFormat,The following statement contains a magic number: if (next < 192)              {                  length = next;                  packet.BodyLength += next;                  packet.TotalLength += packet.BodyLength + 2;              }              else if (next > 191 && next < 223)              {                  byte nextnext = (byte)stream.ReadByte();                  length = ((next - 192) << 8) + nextnext + 192;                  packet.BodyLength += length;                  packet.TotalLength += packet.BodyLength + 3;              }              else if (next == 255)              {                  int nextnext = stream.ReadByte();                  int nextnextnext = stream.ReadByte();                  int nextnextnextnext = stream.ReadByte();                  int nextnextnextnextnext = stream.ReadByte();                  length = (nextnext << 24) | (nextnextnext << 16) | (nextnextnextnext << 8) | nextnextnextnextnext;                  packet.BodyLength += length;                  packet.TotalLength += packet.BodyLength + 6;              }              else if (next > 223 && next < 255)              {                  int partlength = (1 << (next & 31));                  packet.BodyLength += partlength;                  packet.TotalLength += partlength + 1;                  outstream.Write(stream.ToArray()' (int)stream.Position' partlength);                  stream.Position += partlength;                  AddNextPacketNewFormat(ref packet' ref stream' ref outstream);                  return;              }
Magic Number,ActiveUp.Net.Security.OpenPGP,Parser,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Parser.cs,AddNextPacketNewFormat,The following statement contains a magic number: if (next < 192)              {                  length = next;                  packet.BodyLength += next;                  packet.TotalLength += packet.BodyLength + 2;              }              else if (next > 191 && next < 223)              {                  byte nextnext = (byte)stream.ReadByte();                  length = ((next - 192) << 8) + nextnext + 192;                  packet.BodyLength += length;                  packet.TotalLength += packet.BodyLength + 3;              }              else if (next == 255)              {                  int nextnext = stream.ReadByte();                  int nextnextnext = stream.ReadByte();                  int nextnextnextnext = stream.ReadByte();                  int nextnextnextnextnext = stream.ReadByte();                  length = (nextnext << 24) | (nextnextnext << 16) | (nextnextnextnext << 8) | nextnextnextnextnext;                  packet.BodyLength += length;                  packet.TotalLength += packet.BodyLength + 6;              }              else if (next > 223 && next < 255)              {                  int partlength = (1 << (next & 31));                  packet.BodyLength += partlength;                  packet.TotalLength += partlength + 1;                  outstream.Write(stream.ToArray()' (int)stream.Position' partlength);                  stream.Position += partlength;                  AddNextPacketNewFormat(ref packet' ref stream' ref outstream);                  return;              }
Magic Number,ActiveUp.Net.Security.OpenPGP,Parser,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Parser.cs,AddNextPacketNewFormat,The following statement contains a magic number: if (next < 192)              {                  length = next;                  packet.BodyLength += next;                  packet.TotalLength += packet.BodyLength + 2;              }              else if (next > 191 && next < 223)              {                  byte nextnext = (byte)stream.ReadByte();                  length = ((next - 192) << 8) + nextnext + 192;                  packet.BodyLength += length;                  packet.TotalLength += packet.BodyLength + 3;              }              else if (next == 255)              {                  int nextnext = stream.ReadByte();                  int nextnextnext = stream.ReadByte();                  int nextnextnextnext = stream.ReadByte();                  int nextnextnextnextnext = stream.ReadByte();                  length = (nextnext << 24) | (nextnextnext << 16) | (nextnextnextnext << 8) | nextnextnextnextnext;                  packet.BodyLength += length;                  packet.TotalLength += packet.BodyLength + 6;              }              else if (next > 223 && next < 255)              {                  int partlength = (1 << (next & 31));                  packet.BodyLength += partlength;                  packet.TotalLength += partlength + 1;                  outstream.Write(stream.ToArray()' (int)stream.Position' partlength);                  stream.Position += partlength;                  AddNextPacketNewFormat(ref packet' ref stream' ref outstream);                  return;              }
Magic Number,ActiveUp.Net.Security.OpenPGP,Parser,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Parser.cs,AddNextPacketNewFormat,The following statement contains a magic number: if (next < 192)              {                  length = next;                  packet.BodyLength += next;                  packet.TotalLength += packet.BodyLength + 2;              }              else if (next > 191 && next < 223)              {                  byte nextnext = (byte)stream.ReadByte();                  length = ((next - 192) << 8) + nextnext + 192;                  packet.BodyLength += length;                  packet.TotalLength += packet.BodyLength + 3;              }              else if (next == 255)              {                  int nextnext = stream.ReadByte();                  int nextnextnext = stream.ReadByte();                  int nextnextnextnext = stream.ReadByte();                  int nextnextnextnextnext = stream.ReadByte();                  length = (nextnext << 24) | (nextnextnext << 16) | (nextnextnextnext << 8) | nextnextnextnextnext;                  packet.BodyLength += length;                  packet.TotalLength += packet.BodyLength + 6;              }              else if (next > 223 && next < 255)              {                  int partlength = (1 << (next & 31));                  packet.BodyLength += partlength;                  packet.TotalLength += partlength + 1;                  outstream.Write(stream.ToArray()' (int)stream.Position' partlength);                  stream.Position += partlength;                  AddNextPacketNewFormat(ref packet' ref stream' ref outstream);                  return;              }
Magic Number,ActiveUp.Net.Security.OpenPGP,Parser,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Parser.cs,AddNextPacketNewFormat,The following statement contains a magic number: if (next < 192)              {                  length = next;                  packet.BodyLength += next;                  packet.TotalLength += packet.BodyLength + 2;              }              else if (next > 191 && next < 223)              {                  byte nextnext = (byte)stream.ReadByte();                  length = ((next - 192) << 8) + nextnext + 192;                  packet.BodyLength += length;                  packet.TotalLength += packet.BodyLength + 3;              }              else if (next == 255)              {                  int nextnext = stream.ReadByte();                  int nextnextnext = stream.ReadByte();                  int nextnextnextnext = stream.ReadByte();                  int nextnextnextnextnext = stream.ReadByte();                  length = (nextnext << 24) | (nextnextnext << 16) | (nextnextnextnext << 8) | nextnextnextnextnext;                  packet.BodyLength += length;                  packet.TotalLength += packet.BodyLength + 6;              }              else if (next > 223 && next < 255)              {                  int partlength = (1 << (next & 31));                  packet.BodyLength += partlength;                  packet.TotalLength += partlength + 1;                  outstream.Write(stream.ToArray()' (int)stream.Position' partlength);                  stream.Position += partlength;                  AddNextPacketNewFormat(ref packet' ref stream' ref outstream);                  return;              }
Magic Number,ActiveUp.Net.Security.OpenPGP,Parser,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Parser.cs,AddNextPacketNewFormat,The following statement contains a magic number: if (next < 192)              {                  length = next;                  packet.BodyLength += next;                  packet.TotalLength += packet.BodyLength + 2;              }              else if (next > 191 && next < 223)              {                  byte nextnext = (byte)stream.ReadByte();                  length = ((next - 192) << 8) + nextnext + 192;                  packet.BodyLength += length;                  packet.TotalLength += packet.BodyLength + 3;              }              else if (next == 255)              {                  int nextnext = stream.ReadByte();                  int nextnextnext = stream.ReadByte();                  int nextnextnextnext = stream.ReadByte();                  int nextnextnextnextnext = stream.ReadByte();                  length = (nextnext << 24) | (nextnextnext << 16) | (nextnextnextnext << 8) | nextnextnextnextnext;                  packet.BodyLength += length;                  packet.TotalLength += packet.BodyLength + 6;              }              else if (next > 223 && next < 255)              {                  int partlength = (1 << (next & 31));                  packet.BodyLength += partlength;                  packet.TotalLength += partlength + 1;                  outstream.Write(stream.ToArray()' (int)stream.Position' partlength);                  stream.Position += partlength;                  AddNextPacketNewFormat(ref packet' ref stream' ref outstream);                  return;              }
Magic Number,ActiveUp.Net.Security.OpenPGP,Parser,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Parser.cs,ToBitString,The following statement contains a magic number: output += ((input & 128) == 128) ? "1" : "0";
Magic Number,ActiveUp.Net.Security.OpenPGP,Parser,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Parser.cs,ToBitString,The following statement contains a magic number: output += ((input & 128) == 128) ? "1" : "0";
Magic Number,ActiveUp.Net.Security.OpenPGP,Parser,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Parser.cs,ToBitString,The following statement contains a magic number: output += ((input & 64) == 64) ? "1" : "0";
Magic Number,ActiveUp.Net.Security.OpenPGP,Parser,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Parser.cs,ToBitString,The following statement contains a magic number: output += ((input & 64) == 64) ? "1" : "0";
Magic Number,ActiveUp.Net.Security.OpenPGP,Parser,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Parser.cs,ToBitString,The following statement contains a magic number: output += ((input & 32) == 32) ? "1" : "0";
Magic Number,ActiveUp.Net.Security.OpenPGP,Parser,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Parser.cs,ToBitString,The following statement contains a magic number: output += ((input & 32) == 32) ? "1" : "0";
Magic Number,ActiveUp.Net.Security.OpenPGP,Parser,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Parser.cs,ToBitString,The following statement contains a magic number: output += ((input & 16) == 16) ? "1" : "0";
Magic Number,ActiveUp.Net.Security.OpenPGP,Parser,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Parser.cs,ToBitString,The following statement contains a magic number: output += ((input & 16) == 16) ? "1" : "0";
Magic Number,ActiveUp.Net.Security.OpenPGP,Parser,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Parser.cs,ToBitString,The following statement contains a magic number: output += ((input & 8) == 8) ? "1" : "0";
Magic Number,ActiveUp.Net.Security.OpenPGP,Parser,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Parser.cs,ToBitString,The following statement contains a magic number: output += ((input & 8) == 8) ? "1" : "0";
Magic Number,ActiveUp.Net.Security.OpenPGP,Parser,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Parser.cs,ToBitString,The following statement contains a magic number: output += ((input & 4) == 4) ? "1" : "0";
Magic Number,ActiveUp.Net.Security.OpenPGP,Parser,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Parser.cs,ToBitString,The following statement contains a magic number: output += ((input & 4) == 4) ? "1" : "0";
Magic Number,ActiveUp.Net.Security.OpenPGP,Parser,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Parser.cs,ToBitString,The following statement contains a magic number: output += ((input & 2) == 2) ? "1" : "0";
Magic Number,ActiveUp.Net.Security.OpenPGP,Parser,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Parser.cs,ToBitString,The following statement contains a magic number: output += ((input & 2) == 2) ? "1" : "0";
Magic Number,ActiveUp.Net.OpenPGP,Converter,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Converter.cs,ToByteArray,The following statement contains a magic number: byte a = (byte)(input >> 24);
Magic Number,ActiveUp.Net.OpenPGP,Converter,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Converter.cs,ToByteArray,The following statement contains a magic number: byte b = (byte)((input & 16711680) >> 16);
Magic Number,ActiveUp.Net.OpenPGP,Converter,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Converter.cs,ToByteArray,The following statement contains a magic number: byte b = (byte)((input & 16711680) >> 16);
Magic Number,ActiveUp.Net.OpenPGP,Converter,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Converter.cs,ToByteArray,The following statement contains a magic number: byte c = (byte)((input & 65280) >> 8);
Magic Number,ActiveUp.Net.OpenPGP,Converter,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Converter.cs,ToByteArray,The following statement contains a magic number: byte c = (byte)((input & 65280) >> 8);
Magic Number,ActiveUp.Net.OpenPGP,Converter,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Converter.cs,ToByteArray,The following statement contains a magic number: byte d = (byte)(input & 255);
Magic Number,ActiveUp.Net.OpenPGP,Converter,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Converter.cs,ToULong,The following statement contains a magic number: ulong l = (((ulong)input[0]) << 56)                  + (((ulong)input[1]) << 48)                  + (((ulong)input[2]) << 40)                  + (((ulong)input[3]) << 32)                  + (((ulong)input[4]) << 24)                  + (((ulong)input[5]) << 16)                  + (((ulong)input[6]) << 8)                  + ((ulong)input[7]);
Magic Number,ActiveUp.Net.OpenPGP,Converter,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Converter.cs,ToULong,The following statement contains a magic number: ulong l = (((ulong)input[0]) << 56)                  + (((ulong)input[1]) << 48)                  + (((ulong)input[2]) << 40)                  + (((ulong)input[3]) << 32)                  + (((ulong)input[4]) << 24)                  + (((ulong)input[5]) << 16)                  + (((ulong)input[6]) << 8)                  + ((ulong)input[7]);
Magic Number,ActiveUp.Net.OpenPGP,Converter,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Converter.cs,ToULong,The following statement contains a magic number: ulong l = (((ulong)input[0]) << 56)                  + (((ulong)input[1]) << 48)                  + (((ulong)input[2]) << 40)                  + (((ulong)input[3]) << 32)                  + (((ulong)input[4]) << 24)                  + (((ulong)input[5]) << 16)                  + (((ulong)input[6]) << 8)                  + ((ulong)input[7]);
Magic Number,ActiveUp.Net.OpenPGP,Converter,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Converter.cs,ToULong,The following statement contains a magic number: ulong l = (((ulong)input[0]) << 56)                  + (((ulong)input[1]) << 48)                  + (((ulong)input[2]) << 40)                  + (((ulong)input[3]) << 32)                  + (((ulong)input[4]) << 24)                  + (((ulong)input[5]) << 16)                  + (((ulong)input[6]) << 8)                  + ((ulong)input[7]);
Magic Number,ActiveUp.Net.OpenPGP,Converter,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Converter.cs,ToULong,The following statement contains a magic number: ulong l = (((ulong)input[0]) << 56)                  + (((ulong)input[1]) << 48)                  + (((ulong)input[2]) << 40)                  + (((ulong)input[3]) << 32)                  + (((ulong)input[4]) << 24)                  + (((ulong)input[5]) << 16)                  + (((ulong)input[6]) << 8)                  + ((ulong)input[7]);
Magic Number,ActiveUp.Net.OpenPGP,Converter,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Converter.cs,ToULong,The following statement contains a magic number: ulong l = (((ulong)input[0]) << 56)                  + (((ulong)input[1]) << 48)                  + (((ulong)input[2]) << 40)                  + (((ulong)input[3]) << 32)                  + (((ulong)input[4]) << 24)                  + (((ulong)input[5]) << 16)                  + (((ulong)input[6]) << 8)                  + ((ulong)input[7]);
Magic Number,ActiveUp.Net.OpenPGP,Converter,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Converter.cs,ToULong,The following statement contains a magic number: ulong l = (((ulong)input[0]) << 56)                  + (((ulong)input[1]) << 48)                  + (((ulong)input[2]) << 40)                  + (((ulong)input[3]) << 32)                  + (((ulong)input[4]) << 24)                  + (((ulong)input[5]) << 16)                  + (((ulong)input[6]) << 8)                  + ((ulong)input[7]);
Magic Number,ActiveUp.Net.OpenPGP,Converter,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Converter.cs,ToULong,The following statement contains a magic number: ulong l = (((ulong)input[0]) << 56)                  + (((ulong)input[1]) << 48)                  + (((ulong)input[2]) << 40)                  + (((ulong)input[3]) << 32)                  + (((ulong)input[4]) << 24)                  + (((ulong)input[5]) << 16)                  + (((ulong)input[6]) << 8)                  + ((ulong)input[7]);
Magic Number,ActiveUp.Net.OpenPGP,Converter,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Converter.cs,ToULong,The following statement contains a magic number: ulong l = (((ulong)input[0]) << 56)                  + (((ulong)input[1]) << 48)                  + (((ulong)input[2]) << 40)                  + (((ulong)input[3]) << 32)                  + (((ulong)input[4]) << 24)                  + (((ulong)input[5]) << 16)                  + (((ulong)input[6]) << 8)                  + ((ulong)input[7]);
Magic Number,ActiveUp.Net.OpenPGP,Converter,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Converter.cs,ToULong,The following statement contains a magic number: ulong l = (((ulong)input[0]) << 56)                  + (((ulong)input[1]) << 48)                  + (((ulong)input[2]) << 40)                  + (((ulong)input[3]) << 32)                  + (((ulong)input[4]) << 24)                  + (((ulong)input[5]) << 16)                  + (((ulong)input[6]) << 8)                  + ((ulong)input[7]);
Magic Number,ActiveUp.Net.OpenPGP,Converter,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Converter.cs,ToULong,The following statement contains a magic number: ulong l = (((ulong)input[0]) << 56)                  + (((ulong)input[1]) << 48)                  + (((ulong)input[2]) << 40)                  + (((ulong)input[3]) << 32)                  + (((ulong)input[4]) << 24)                  + (((ulong)input[5]) << 16)                  + (((ulong)input[6]) << 8)                  + ((ulong)input[7]);
Magic Number,ActiveUp.Net.OpenPGP,Converter,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Converter.cs,ToULong,The following statement contains a magic number: ulong l = (((ulong)input[0]) << 56)                  + (((ulong)input[1]) << 48)                  + (((ulong)input[2]) << 40)                  + (((ulong)input[3]) << 32)                  + (((ulong)input[4]) << 24)                  + (((ulong)input[5]) << 16)                  + (((ulong)input[6]) << 8)                  + ((ulong)input[7]);
Magic Number,ActiveUp.Net.OpenPGP,Converter,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Converter.cs,ToULong,The following statement contains a magic number: ulong l = (((ulong)input[0]) << 56)                  + (((ulong)input[1]) << 48)                  + (((ulong)input[2]) << 40)                  + (((ulong)input[3]) << 32)                  + (((ulong)input[4]) << 24)                  + (((ulong)input[5]) << 16)                  + (((ulong)input[6]) << 8)                  + ((ulong)input[7]);
Magic Number,ActiveUp.Net.OpenPGP,Converter,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Converter.cs,ToShort,The following statement contains a magic number: short l = (short)((((short)input[0]) << 8) + (short)input[1]);
Magic Number,ActiveUp.Net.OpenPGP,Converter,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Converter.cs,ToInt,The following statement contains a magic number: int l = (((int)input[0]) << 24)                  + (((int)input[1]) << 16)                  + (((int)input[2]) << 8)                  + (int)input[3];
Magic Number,ActiveUp.Net.OpenPGP,Converter,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Converter.cs,ToInt,The following statement contains a magic number: int l = (((int)input[0]) << 24)                  + (((int)input[1]) << 16)                  + (((int)input[2]) << 8)                  + (int)input[3];
Magic Number,ActiveUp.Net.OpenPGP,Converter,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Converter.cs,ToInt,The following statement contains a magic number: int l = (((int)input[0]) << 24)                  + (((int)input[1]) << 16)                  + (((int)input[2]) << 8)                  + (int)input[3];
Magic Number,ActiveUp.Net.OpenPGP,Converter,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Converter.cs,ToInt,The following statement contains a magic number: int l = (((int)input[0]) << 24)                  + (((int)input[1]) << 16)                  + (((int)input[2]) << 8)                  + (int)input[3];
Magic Number,ActiveUp.Net.OpenPGP,Converter,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Converter.cs,ToInt,The following statement contains a magic number: int l = (((int)input[0]) << 24)                  + (((int)input[1]) << 16)                  + (((int)input[2]) << 8)                  + (int)input[3];
Magic Number,ActiveUp.Net.OpenPGP,Converter,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Converter.cs,ToLong,The following statement contains a magic number: long l = ((long)input[0] << 56)                  | ((long)input[1] << 48)                  | ((long)input[2] << 40)                  | ((long)input[3] << 32)                  | ((long)input[4] << 24)                  | ((long)input[5] << 16)                  | ((long)input[6] << 8)                  | (long)input[7];
Magic Number,ActiveUp.Net.OpenPGP,Converter,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Converter.cs,ToLong,The following statement contains a magic number: long l = ((long)input[0] << 56)                  | ((long)input[1] << 48)                  | ((long)input[2] << 40)                  | ((long)input[3] << 32)                  | ((long)input[4] << 24)                  | ((long)input[5] << 16)                  | ((long)input[6] << 8)                  | (long)input[7];
Magic Number,ActiveUp.Net.OpenPGP,Converter,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Converter.cs,ToLong,The following statement contains a magic number: long l = ((long)input[0] << 56)                  | ((long)input[1] << 48)                  | ((long)input[2] << 40)                  | ((long)input[3] << 32)                  | ((long)input[4] << 24)                  | ((long)input[5] << 16)                  | ((long)input[6] << 8)                  | (long)input[7];
Magic Number,ActiveUp.Net.OpenPGP,Converter,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Converter.cs,ToLong,The following statement contains a magic number: long l = ((long)input[0] << 56)                  | ((long)input[1] << 48)                  | ((long)input[2] << 40)                  | ((long)input[3] << 32)                  | ((long)input[4] << 24)                  | ((long)input[5] << 16)                  | ((long)input[6] << 8)                  | (long)input[7];
Magic Number,ActiveUp.Net.OpenPGP,Converter,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Converter.cs,ToLong,The following statement contains a magic number: long l = ((long)input[0] << 56)                  | ((long)input[1] << 48)                  | ((long)input[2] << 40)                  | ((long)input[3] << 32)                  | ((long)input[4] << 24)                  | ((long)input[5] << 16)                  | ((long)input[6] << 8)                  | (long)input[7];
Magic Number,ActiveUp.Net.OpenPGP,Converter,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Converter.cs,ToLong,The following statement contains a magic number: long l = ((long)input[0] << 56)                  | ((long)input[1] << 48)                  | ((long)input[2] << 40)                  | ((long)input[3] << 32)                  | ((long)input[4] << 24)                  | ((long)input[5] << 16)                  | ((long)input[6] << 8)                  | (long)input[7];
Magic Number,ActiveUp.Net.OpenPGP,Converter,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Converter.cs,ToLong,The following statement contains a magic number: long l = ((long)input[0] << 56)                  | ((long)input[1] << 48)                  | ((long)input[2] << 40)                  | ((long)input[3] << 32)                  | ((long)input[4] << 24)                  | ((long)input[5] << 16)                  | ((long)input[6] << 8)                  | (long)input[7];
Magic Number,ActiveUp.Net.OpenPGP,Converter,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Converter.cs,ToLong,The following statement contains a magic number: long l = ((long)input[0] << 56)                  | ((long)input[1] << 48)                  | ((long)input[2] << 40)                  | ((long)input[3] << 32)                  | ((long)input[4] << 24)                  | ((long)input[5] << 16)                  | ((long)input[6] << 8)                  | (long)input[7];
Magic Number,ActiveUp.Net.OpenPGP,Converter,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Converter.cs,ToLong,The following statement contains a magic number: long l = ((long)input[0] << 56)                  | ((long)input[1] << 48)                  | ((long)input[2] << 40)                  | ((long)input[3] << 32)                  | ((long)input[4] << 24)                  | ((long)input[5] << 16)                  | ((long)input[6] << 8)                  | (long)input[7];
Magic Number,ActiveUp.Net.OpenPGP,Converter,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Converter.cs,ToLong,The following statement contains a magic number: long l = ((long)input[0] << 56)                  | ((long)input[1] << 48)                  | ((long)input[2] << 40)                  | ((long)input[3] << 32)                  | ((long)input[4] << 24)                  | ((long)input[5] << 16)                  | ((long)input[6] << 8)                  | (long)input[7];
Magic Number,ActiveUp.Net.OpenPGP,Converter,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Converter.cs,ToLong,The following statement contains a magic number: long l = ((long)input[0] << 56)                  | ((long)input[1] << 48)                  | ((long)input[2] << 40)                  | ((long)input[3] << 32)                  | ((long)input[4] << 24)                  | ((long)input[5] << 16)                  | ((long)input[6] << 8)                  | (long)input[7];
Magic Number,ActiveUp.Net.OpenPGP,Converter,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Converter.cs,ToLong,The following statement contains a magic number: long l = ((long)input[0] << 56)                  | ((long)input[1] << 48)                  | ((long)input[2] << 40)                  | ((long)input[3] << 32)                  | ((long)input[4] << 24)                  | ((long)input[5] << 16)                  | ((long)input[6] << 8)                  | (long)input[7];
Magic Number,ActiveUp.Net.OpenPGP,Converter,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Converter.cs,ToLong,The following statement contains a magic number: long l = ((long)input[0] << 56)                  | ((long)input[1] << 48)                  | ((long)input[2] << 40)                  | ((long)input[3] << 32)                  | ((long)input[4] << 24)                  | ((long)input[5] << 16)                  | ((long)input[6] << 8)                  | (long)input[7];
Magic Number,ActiveUp.Net.OpenPGP,Converter,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Converter.cs,UnixTimeStampToDateTime,The following statement contains a magic number: return new DateTime(1970' 1' 1).AddSeconds(timeStamp);
Magic Number,ActiveUp.Net.Security.OpenPGP.Packets,PublicKey,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.PublicKey.cs,Parse,The following statement contains a magic number: byte[] creation = new byte[4];
Magic Number,ActiveUp.Net.Security.OpenPGP.Packets,PublicKey,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.PublicKey.cs,Parse,The following statement contains a magic number: ms.Read(creation' 0' 4);
Magic Number,ActiveUp.Net.Security.OpenPGP.Packets,PublicKey,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.PublicKey.cs,Parse,The following statement contains a magic number: if (pk.VersionNumber.Equals(3))              {                  byte[] validity = new byte[2];                  ms.Read(validity' 0' 2);                  pk.Validity = (int)Converter.ToShort(validity);              }
Magic Number,ActiveUp.Net.Security.OpenPGP.Packets,PublicKey,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.PublicKey.cs,Parse,The following statement contains a magic number: if (pk.VersionNumber.Equals(3))              {                  byte[] validity = new byte[2];                  ms.Read(validity' 0' 2);                  pk.Validity = (int)Converter.ToShort(validity);              }
Magic Number,ActiveUp.Net.Security.OpenPGP.Packets,PublicKey,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.PublicKey.cs,Parse,The following statement contains a magic number: if (pk.VersionNumber.Equals(3))              {                  byte[] validity = new byte[2];                  ms.Read(validity' 0' 2);                  pk.Validity = (int)Converter.ToShort(validity);              }
Magic Number,ActiveUp.Net.Security.OpenPGP.Packets,PublicKey,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.PublicKey.cs,Parse,The following statement contains a magic number: while (ms.Position < ms.Length && pk.MPIs.Count < mpiMaxCount)              {                  byte first = (byte)ms.ReadByte();                  byte second = (byte)ms.ReadByte();                  short length = (short)((Converter.ToShort(new byte[2] { first' second }) + 7) / 8);                  byte[] mpi = new byte[(int)length];                  ms.Read(mpi' 0' length);                  pk.MPIs.Add(mpi);              }
Magic Number,ActiveUp.Net.Security.OpenPGP.Packets,PublicKey,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.PublicKey.cs,Parse,The following statement contains a magic number: while (ms.Position < ms.Length && pk.MPIs.Count < mpiMaxCount)              {                  byte first = (byte)ms.ReadByte();                  byte second = (byte)ms.ReadByte();                  short length = (short)((Converter.ToShort(new byte[2] { first' second }) + 7) / 8);                  byte[] mpi = new byte[(int)length];                  ms.Read(mpi' 0' length);                  pk.MPIs.Add(mpi);              }
Magic Number,ActiveUp.Net.Security.OpenPGP.Packets,PublicKey,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.PublicKey.cs,Parse,The following statement contains a magic number: while (ms.Position < ms.Length && pk.MPIs.Count < mpiMaxCount)              {                  byte first = (byte)ms.ReadByte();                  byte second = (byte)ms.ReadByte();                  short length = (short)((Converter.ToShort(new byte[2] { first' second }) + 7) / 8);                  byte[] mpi = new byte[(int)length];                  ms.Read(mpi' 0' length);                  pk.MPIs.Add(mpi);              }
Magic Number,ActiveUp.Net.Security.OpenPGP.Packets,PublicKeyEncryptedSessionKey,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.PublicKeyEncryptedSessionKey.cs,Parse,The following statement contains a magic number: byte[] keyID = new byte[8];
Magic Number,ActiveUp.Net.Security.OpenPGP.Packets,PublicKeyEncryptedSessionKey,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.PublicKeyEncryptedSessionKey.cs,Parse,The following statement contains a magic number: Array.Copy(content' 1' keyID' 0' 8);
Magic Number,ActiveUp.Net.Security.OpenPGP.Packets,PublicKeyEncryptedSessionKey,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.PublicKeyEncryptedSessionKey.cs,Parse,The following statement contains a magic number: pkesk.PublicKeyAlgorithm = (PublicKeyAlgorithm)content[9];
Magic Number,ActiveUp.Net.Security.OpenPGP.Packets,SecretKey,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.SecretKey.cs,Parse,The following statement contains a magic number: if (s2kUsage == 255 || s2kUsage == 254)              {                  // We'll be using String to key...but with which algorithm ?                  sk.SymmetricKeyAlgorithm = (SymmetricKeyAlgorithm)ms.ReadByte();                  // And which type of S2K ?                  sk.StringToKeySpecifierType = (StringToKeySpecifierType)ms.ReadByte();                  sk.InitialVector = new byte[Constants.GetCipherBlockSize(sk.SymmetricKeyAlgorithm)];                  ms.Read(sk.InitialVector' 0' sk.InitialVector.Length);                                }              else if (s2kUsage == 0)              {                }              else              {                  sk.SymmetricKeyAlgorithm = (SymmetricKeyAlgorithm)s2kUsage;                  sk.InitialVector = new byte[Constants.GetCipherBlockSize(sk.SymmetricKeyAlgorithm)];                  ms.Read(sk.InitialVector' 0' sk.InitialVector.Length);              }
Magic Number,ActiveUp.Net.Security.OpenPGP.Packets,SecretKey,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.SecretKey.cs,Parse,The following statement contains a magic number: if (s2kUsage == 255 || s2kUsage == 254)              {                  // We'll be using String to key...but with which algorithm ?                  sk.SymmetricKeyAlgorithm = (SymmetricKeyAlgorithm)ms.ReadByte();                  // And which type of S2K ?                  sk.StringToKeySpecifierType = (StringToKeySpecifierType)ms.ReadByte();                  sk.InitialVector = new byte[Constants.GetCipherBlockSize(sk.SymmetricKeyAlgorithm)];                  ms.Read(sk.InitialVector' 0' sk.InitialVector.Length);                                }              else if (s2kUsage == 0)              {                }              else              {                  sk.SymmetricKeyAlgorithm = (SymmetricKeyAlgorithm)s2kUsage;                  sk.InitialVector = new byte[Constants.GetCipherBlockSize(sk.SymmetricKeyAlgorithm)];                  ms.Read(sk.InitialVector' 0' sk.InitialVector.Length);              }
Magic Number,ActiveUp.Net.Security.OpenPGP.Packets,SecretKey,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.SecretKey.cs,Parse,The following statement contains a magic number: while (ms.Position < ms.Length && sk.MPIs.Count < mpiMaxCount)              {                  byte first = (byte)ms.ReadByte();                  byte second = (byte)ms.ReadByte();                  short length = (short)((Converter.ToShort(new byte[2] { first' second }) + 7) / 8);                  byte[] mpi = new byte[(int)length];                  ms.Read(mpi' 0' length);                  sk.MPIs.Add(mpi);              }
Magic Number,ActiveUp.Net.Security.OpenPGP.Packets,SecretKey,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.SecretKey.cs,Parse,The following statement contains a magic number: while (ms.Position < ms.Length && sk.MPIs.Count < mpiMaxCount)              {                  byte first = (byte)ms.ReadByte();                  byte second = (byte)ms.ReadByte();                  short length = (short)((Converter.ToShort(new byte[2] { first' second }) + 7) / 8);                  byte[] mpi = new byte[(int)length];                  ms.Read(mpi' 0' length);                  sk.MPIs.Add(mpi);              }
Magic Number,ActiveUp.Net.Security.OpenPGP.Packets,SecretKey,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.SecretKey.cs,Parse,The following statement contains a magic number: while (ms.Position < ms.Length && sk.MPIs.Count < mpiMaxCount)              {                  byte first = (byte)ms.ReadByte();                  byte second = (byte)ms.ReadByte();                  short length = (short)((Converter.ToShort(new byte[2] { first' second }) + 7) / 8);                  byte[] mpi = new byte[(int)length];                  ms.Read(mpi' 0' length);                  sk.MPIs.Add(mpi);              }
Magic Number,ActiveUp.Net.Security.OpenPGP.Packets,SecretKey,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.SecretKey.cs,Parse,The following statement contains a magic number: sk.CheckSum = new byte[2];
Magic Number,ActiveUp.Net.Security.OpenPGP.Packets,SecretKey,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.SecretKey.cs,Parse,The following statement contains a magic number: ms.Read(sk.CheckSum' 0' 2);
Magic Number,ActiveUp.Net.Security.OpenPGP.Packets,Signature,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.Signature.cs,Parse,The following statement contains a magic number: if (sig.VersionNumber.Equals(3))              {                  if (!next.Equals(5)) throw new InvalidPacketSyntaxException("Invalid syntax for a version 3 signature packet. Second byte is not 5.");                  else                  {                      sig.Type = (SignatureType)ms.ReadByte();                        byte[] creation = new byte[4];                      ms.Read(creation' 0' 4);                      sig.CreationTime = Converter.UnixTimeStampToDateTime(Converter.ToInt(creation));                        byte[] keyID = new byte[8];                      ms.Read(keyID' 0' 8);                      sig.IssuerKeyID = Converter.ToULong(keyID);                  }              }              else              {                  // Vιrifier tout avec une signature V4 !                  sig.Type = (SignatureType)next;              }
Magic Number,ActiveUp.Net.Security.OpenPGP.Packets,Signature,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.Signature.cs,Parse,The following statement contains a magic number: if (sig.VersionNumber.Equals(3))              {                  if (!next.Equals(5)) throw new InvalidPacketSyntaxException("Invalid syntax for a version 3 signature packet. Second byte is not 5.");                  else                  {                      sig.Type = (SignatureType)ms.ReadByte();                        byte[] creation = new byte[4];                      ms.Read(creation' 0' 4);                      sig.CreationTime = Converter.UnixTimeStampToDateTime(Converter.ToInt(creation));                        byte[] keyID = new byte[8];                      ms.Read(keyID' 0' 8);                      sig.IssuerKeyID = Converter.ToULong(keyID);                  }              }              else              {                  // Vιrifier tout avec une signature V4 !                  sig.Type = (SignatureType)next;              }
Magic Number,ActiveUp.Net.Security.OpenPGP.Packets,Signature,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.Signature.cs,Parse,The following statement contains a magic number: if (sig.VersionNumber.Equals(3))              {                  if (!next.Equals(5)) throw new InvalidPacketSyntaxException("Invalid syntax for a version 3 signature packet. Second byte is not 5.");                  else                  {                      sig.Type = (SignatureType)ms.ReadByte();                        byte[] creation = new byte[4];                      ms.Read(creation' 0' 4);                      sig.CreationTime = Converter.UnixTimeStampToDateTime(Converter.ToInt(creation));                        byte[] keyID = new byte[8];                      ms.Read(keyID' 0' 8);                      sig.IssuerKeyID = Converter.ToULong(keyID);                  }              }              else              {                  // Vιrifier tout avec une signature V4 !                  sig.Type = (SignatureType)next;              }
Magic Number,ActiveUp.Net.Security.OpenPGP.Packets,Signature,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.Signature.cs,Parse,The following statement contains a magic number: if (sig.VersionNumber.Equals(3))              {                  if (!next.Equals(5)) throw new InvalidPacketSyntaxException("Invalid syntax for a version 3 signature packet. Second byte is not 5.");                  else                  {                      sig.Type = (SignatureType)ms.ReadByte();                        byte[] creation = new byte[4];                      ms.Read(creation' 0' 4);                      sig.CreationTime = Converter.UnixTimeStampToDateTime(Converter.ToInt(creation));                        byte[] keyID = new byte[8];                      ms.Read(keyID' 0' 8);                      sig.IssuerKeyID = Converter.ToULong(keyID);                  }              }              else              {                  // Vιrifier tout avec une signature V4 !                  sig.Type = (SignatureType)next;              }
Magic Number,ActiveUp.Net.Security.OpenPGP.Packets,Signature,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.Signature.cs,Parse,The following statement contains a magic number: if (sig.VersionNumber.Equals(3))              {                  if (!next.Equals(5)) throw new InvalidPacketSyntaxException("Invalid syntax for a version 3 signature packet. Second byte is not 5.");                  else                  {                      sig.Type = (SignatureType)ms.ReadByte();                        byte[] creation = new byte[4];                      ms.Read(creation' 0' 4);                      sig.CreationTime = Converter.UnixTimeStampToDateTime(Converter.ToInt(creation));                        byte[] keyID = new byte[8];                      ms.Read(keyID' 0' 8);                      sig.IssuerKeyID = Converter.ToULong(keyID);                  }              }              else              {                  // Vιrifier tout avec une signature V4 !                  sig.Type = (SignatureType)next;              }
Magic Number,ActiveUp.Net.Security.OpenPGP.Packets,Signature,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.Signature.cs,Parse,The following statement contains a magic number: if (sig.VersionNumber.Equals(3))              {                  if (!next.Equals(5)) throw new InvalidPacketSyntaxException("Invalid syntax for a version 3 signature packet. Second byte is not 5.");                  else                  {                      sig.Type = (SignatureType)ms.ReadByte();                        byte[] creation = new byte[4];                      ms.Read(creation' 0' 4);                      sig.CreationTime = Converter.UnixTimeStampToDateTime(Converter.ToInt(creation));                        byte[] keyID = new byte[8];                      ms.Read(keyID' 0' 8);                      sig.IssuerKeyID = Converter.ToULong(keyID);                  }              }              else              {                  // Vιrifier tout avec une signature V4 !                  sig.Type = (SignatureType)next;              }
Magic Number,ActiveUp.Net.Security.OpenPGP.Packets,Signature,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.Signature.cs,Parse,The following statement contains a magic number: if (sig.VersionNumber.Equals(4))              {                  // Hashed subpackets                  byte[] hashedsublengthbytes = new byte[2];                  ms.Read(hashedsublengthbytes' 0' 2);                  short hashedsublength = Converter.ToShort(hashedsublengthbytes);                  while (ms.Position < 5 + hashedsublength)                      sig.HashedSubPackets.Add(GetNextSignatureSubPacket(ref ms));                    // Unhashed subpackets                  byte[] unhashedsublengthbytes = new byte[2];                  ms.Read(unhashedsublengthbytes' 0' 2);                  short unhashedsublength = Converter.ToShort(unhashedsublengthbytes);                  while (ms.Position < hashedsublength + unhashedsublength)                      sig.UnHashedSubPackets.Add(GetNextSignatureSubPacket(ref ms));                    // Fill properties                  List<SignatureSubPacket> allSubPackets = new List<SignatureSubPacket>();                  allSubPackets.AddRange(sig.HashedSubPackets);                  allSubPackets.AddRange(sig.UnHashedSubPackets);                  foreach (SignatureSubPacket spacket in allSubPackets)                  {                      if (spacket.Type.Equals(SignatureSubPacketType.CreationTime))                          sig.CreationTime = Converter.UnixTimeStampToDateTime(Converter.ToInt(spacket.Value));                      else if (spacket.Type.Equals(SignatureSubPacketType.KeyExpirationTime))                          sig.KeyExpiration = Converter.UnixTimeStampToDateTime(Converter.ToInt(spacket.Value));                      else if (spacket.Type.Equals(SignatureSubPacketType.ExpirationTime))                          sig.SignatureExpiration = Converter.UnixTimeStampToDateTime(Converter.ToInt(spacket.Value));                      else if (spacket.Type.Equals(SignatureSubPacketType.ExportableCertification))                          sig.IsExportableCertification = (spacket.Value[0] == 1);                      else if (spacket.Type.Equals(SignatureSubPacketType.Revocable))                          sig.IsRevocable = (spacket.Value[0] == 1);                      else if (spacket.Type.Equals(SignatureSubPacketType.TrustSignature))                      {                          sig.Trust.Level = (TrustLevel)spacket.Value[0];                          sig.Trust.Amount = spacket.Value[1];                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.RegularExpression))                          sig.RegularExpression = spacket.Value;                      else if (spacket.Type.Equals(SignatureSubPacketType.RevocationKey))                      {                          if ((spacket.Value[0] & 128) != 128) throw new InvalidPacketSyntaxException("First bit of revocation key class is 0");                          sig.RevocationKey.Class = (RevocationKeyClass)(spacket.Value[0] & 64);                          sig.RevocationKey.HashAlgorithm = (HashAlgorithm)spacket.Value[1];                          Array.Copy(spacket.Value' 2' sig.RevocationKey.FingerPrint' 0' 20);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.NotationData))                      {                          Notation n = new Notation();                          n.IsHumanReadable = ((spacket.Value[0] & 128) == 128);                          byte[] nameLength = new byte[2];                          Array.Copy(spacket.Value' 4' nameLength' 0' 2);                          Array.Copy(spacket.Value' 6' n.Name' 0' Converter.ToInt(nameLength));                          byte[] valueLength = new byte[2];                          Array.Copy(spacket.Value' 6 + Converter.ToInt(nameLength)' valueLength' 0' 2);                          Array.Copy(spacket.Value' 6 + Converter.ToInt(nameLength) + 2' n.Value' 0' Converter.ToInt(valueLength));                          sig.Notations.Add(n);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.PolicyURL))                          sig.PolicyURL = Encoding.ASCII.GetString(spacket.Value'0'spacket.Value.Length);                      else if (spacket.Type.Equals(SignatureSubPacketType.SignerUserID))                          sig.SignerUserID = Encoding.ASCII.GetString(spacket.Value'0'spacket.Value.Length);                      else if (spacket.Type.Equals(SignatureSubPacketType.SignatureTarget))                      {                          sig.TargetSignatureInfo.PublicKeyAlgorithm = (PublicKeyAlgorithm)spacket.Value[0];                          sig.TargetSignatureInfo.HashAlgorithm = (HashAlgorithm)spacket.Value[1];                          Array.Copy(spacket.Value' 2' sig.TargetSignatureInfo.Hash' 0' spacket.Value.Length - 2);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.EmbeddedSignature))                      {                          Packet embedded = new Packet();                          embedded.RawData = spacket.Value;                          sig.EmbeddedSignature = Signature.Parse(embedded);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.IssuerKeyID))                          sig.IssuerKeyID = Converter.ToULong(spacket.Value);                      else if (spacket.Type.Equals(SignatureSubPacketType.PrimaryUserID))                          sig.IsPrimaryUserID = (spacket.Value[0] == 1);                      else if (spacket.Type.Equals(SignatureSubPacketType.KeyFlags))                      {                          if ((spacket.Value[0] & (byte)KeyFlag.Authentication) == (int)KeyFlag.Authentication) sig.KeyFlags.Add(KeyFlag.Authentication);                          if ((spacket.Value[0] & (byte)KeyFlag.CertifiesOtherKeys) == (int)KeyFlag.CertifiesOtherKeys) sig.KeyFlags.Add(KeyFlag.CertifiesOtherKeys);                          if ((spacket.Value[0] & (byte)KeyFlag.EncryptsCommunications) == (int)KeyFlag.EncryptsCommunications) sig.KeyFlags.Add(KeyFlag.EncryptsCommunications);                          if ((spacket.Value[0] & (byte)KeyFlag.EncryptsStorage) == (int)KeyFlag.EncryptsStorage) sig.KeyFlags.Add(KeyFlag.EncryptsStorage);                          if ((spacket.Value[0] & (byte)KeyFlag.GroupKey) == (int)KeyFlag.GroupKey) sig.KeyFlags.Add(KeyFlag.GroupKey);                          if ((spacket.Value[0] & (byte)KeyFlag.SignsData) == (int)KeyFlag.SignsData) sig.KeyFlags.Add(KeyFlag.SignsData);                          if ((spacket.Value[0] & (byte)KeyFlag.SplitKey) == (int)KeyFlag.SplitKey) sig.KeyFlags.Add(KeyFlag.SplitKey);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.Features))                      {                          if ((spacket.Value[0] & (byte)Feature.ModificationDetection) == (int)Feature.ModificationDetection) sig.Features.Add(Feature.ModificationDetection);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.KeyServerPreferences))                      {                          if ((spacket.Value[0] & (byte)KeyServerPreference.NoModify) == (int)KeyServerPreference.NoModify) sig.KeyServerPreferences.Add(KeyServerPreference.NoModify);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.ReasonForRevocation))                      {                          if ((spacket.Value[0] & (byte)Reason.KeyCompromised) == (int)Reason.KeyCompromised) sig.ReasonForRevocation.Reason = Reason.KeyCompromised;                          else if ((spacket.Value[0] & (byte)Reason.KeyRetired) == (int)Reason.KeyRetired) sig.ReasonForRevocation.Reason = Reason.KeyRetired;                          else if ((spacket.Value[0] & (byte)Reason.KeySuperceded) == (int)Reason.KeySuperceded) sig.ReasonForRevocation.Reason = Reason.KeySuperceded;                          else if ((spacket.Value[0] & (byte)Reason.NoneSpecified) == (int)Reason.NoneSpecified) sig.ReasonForRevocation.Reason = Reason.NoneSpecified;                          else if ((spacket.Value[0] & (byte)Reason.UserIDNoLongerValid) == (int)Reason.UserIDNoLongerValid) sig.ReasonForRevocation.Reason = Reason.UserIDNoLongerValid;                          byte[] comment = new byte[spacket.Value.Length - 1];                          Array.Copy(spacket.Value' 1' comment' 0' comment.Length);                          sig.ReasonForRevocation.Comment = Encoding.UTF8.GetString(comment'0'comment.Length);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.PreferredCompressionAlgorithms))                          for (int i = 0; i < spacket.Value.Length; i++) sig.PreferredCompressionAlgorithms.Add((CompressionAlgorithm)spacket.Value[i]);                      else if (spacket.Type.Equals(SignatureSubPacketType.PreferredHashAlgorithms))                          for (int i = 0; i < spacket.Value.Length; i++) sig.PreferredHashAlgorithms.Add((HashAlgorithm)spacket.Value[i]);                      else if (spacket.Type.Equals(SignatureSubPacketType.PreferredSymmetricAlgorithms))                          for (int i = 0; i < spacket.Value.Length; i++) sig.PreferredSymmetricAlgorithms.Add((SymmetricKeyAlgorithm)spacket.Value[i]);                  }              }
Magic Number,ActiveUp.Net.Security.OpenPGP.Packets,Signature,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.Signature.cs,Parse,The following statement contains a magic number: if (sig.VersionNumber.Equals(4))              {                  // Hashed subpackets                  byte[] hashedsublengthbytes = new byte[2];                  ms.Read(hashedsublengthbytes' 0' 2);                  short hashedsublength = Converter.ToShort(hashedsublengthbytes);                  while (ms.Position < 5 + hashedsublength)                      sig.HashedSubPackets.Add(GetNextSignatureSubPacket(ref ms));                    // Unhashed subpackets                  byte[] unhashedsublengthbytes = new byte[2];                  ms.Read(unhashedsublengthbytes' 0' 2);                  short unhashedsublength = Converter.ToShort(unhashedsublengthbytes);                  while (ms.Position < hashedsublength + unhashedsublength)                      sig.UnHashedSubPackets.Add(GetNextSignatureSubPacket(ref ms));                    // Fill properties                  List<SignatureSubPacket> allSubPackets = new List<SignatureSubPacket>();                  allSubPackets.AddRange(sig.HashedSubPackets);                  allSubPackets.AddRange(sig.UnHashedSubPackets);                  foreach (SignatureSubPacket spacket in allSubPackets)                  {                      if (spacket.Type.Equals(SignatureSubPacketType.CreationTime))                          sig.CreationTime = Converter.UnixTimeStampToDateTime(Converter.ToInt(spacket.Value));                      else if (spacket.Type.Equals(SignatureSubPacketType.KeyExpirationTime))                          sig.KeyExpiration = Converter.UnixTimeStampToDateTime(Converter.ToInt(spacket.Value));                      else if (spacket.Type.Equals(SignatureSubPacketType.ExpirationTime))                          sig.SignatureExpiration = Converter.UnixTimeStampToDateTime(Converter.ToInt(spacket.Value));                      else if (spacket.Type.Equals(SignatureSubPacketType.ExportableCertification))                          sig.IsExportableCertification = (spacket.Value[0] == 1);                      else if (spacket.Type.Equals(SignatureSubPacketType.Revocable))                          sig.IsRevocable = (spacket.Value[0] == 1);                      else if (spacket.Type.Equals(SignatureSubPacketType.TrustSignature))                      {                          sig.Trust.Level = (TrustLevel)spacket.Value[0];                          sig.Trust.Amount = spacket.Value[1];                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.RegularExpression))                          sig.RegularExpression = spacket.Value;                      else if (spacket.Type.Equals(SignatureSubPacketType.RevocationKey))                      {                          if ((spacket.Value[0] & 128) != 128) throw new InvalidPacketSyntaxException("First bit of revocation key class is 0");                          sig.RevocationKey.Class = (RevocationKeyClass)(spacket.Value[0] & 64);                          sig.RevocationKey.HashAlgorithm = (HashAlgorithm)spacket.Value[1];                          Array.Copy(spacket.Value' 2' sig.RevocationKey.FingerPrint' 0' 20);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.NotationData))                      {                          Notation n = new Notation();                          n.IsHumanReadable = ((spacket.Value[0] & 128) == 128);                          byte[] nameLength = new byte[2];                          Array.Copy(spacket.Value' 4' nameLength' 0' 2);                          Array.Copy(spacket.Value' 6' n.Name' 0' Converter.ToInt(nameLength));                          byte[] valueLength = new byte[2];                          Array.Copy(spacket.Value' 6 + Converter.ToInt(nameLength)' valueLength' 0' 2);                          Array.Copy(spacket.Value' 6 + Converter.ToInt(nameLength) + 2' n.Value' 0' Converter.ToInt(valueLength));                          sig.Notations.Add(n);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.PolicyURL))                          sig.PolicyURL = Encoding.ASCII.GetString(spacket.Value'0'spacket.Value.Length);                      else if (spacket.Type.Equals(SignatureSubPacketType.SignerUserID))                          sig.SignerUserID = Encoding.ASCII.GetString(spacket.Value'0'spacket.Value.Length);                      else if (spacket.Type.Equals(SignatureSubPacketType.SignatureTarget))                      {                          sig.TargetSignatureInfo.PublicKeyAlgorithm = (PublicKeyAlgorithm)spacket.Value[0];                          sig.TargetSignatureInfo.HashAlgorithm = (HashAlgorithm)spacket.Value[1];                          Array.Copy(spacket.Value' 2' sig.TargetSignatureInfo.Hash' 0' spacket.Value.Length - 2);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.EmbeddedSignature))                      {                          Packet embedded = new Packet();                          embedded.RawData = spacket.Value;                          sig.EmbeddedSignature = Signature.Parse(embedded);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.IssuerKeyID))                          sig.IssuerKeyID = Converter.ToULong(spacket.Value);                      else if (spacket.Type.Equals(SignatureSubPacketType.PrimaryUserID))                          sig.IsPrimaryUserID = (spacket.Value[0] == 1);                      else if (spacket.Type.Equals(SignatureSubPacketType.KeyFlags))                      {                          if ((spacket.Value[0] & (byte)KeyFlag.Authentication) == (int)KeyFlag.Authentication) sig.KeyFlags.Add(KeyFlag.Authentication);                          if ((spacket.Value[0] & (byte)KeyFlag.CertifiesOtherKeys) == (int)KeyFlag.CertifiesOtherKeys) sig.KeyFlags.Add(KeyFlag.CertifiesOtherKeys);                          if ((spacket.Value[0] & (byte)KeyFlag.EncryptsCommunications) == (int)KeyFlag.EncryptsCommunications) sig.KeyFlags.Add(KeyFlag.EncryptsCommunications);                          if ((spacket.Value[0] & (byte)KeyFlag.EncryptsStorage) == (int)KeyFlag.EncryptsStorage) sig.KeyFlags.Add(KeyFlag.EncryptsStorage);                          if ((spacket.Value[0] & (byte)KeyFlag.GroupKey) == (int)KeyFlag.GroupKey) sig.KeyFlags.Add(KeyFlag.GroupKey);                          if ((spacket.Value[0] & (byte)KeyFlag.SignsData) == (int)KeyFlag.SignsData) sig.KeyFlags.Add(KeyFlag.SignsData);                          if ((spacket.Value[0] & (byte)KeyFlag.SplitKey) == (int)KeyFlag.SplitKey) sig.KeyFlags.Add(KeyFlag.SplitKey);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.Features))                      {                          if ((spacket.Value[0] & (byte)Feature.ModificationDetection) == (int)Feature.ModificationDetection) sig.Features.Add(Feature.ModificationDetection);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.KeyServerPreferences))                      {                          if ((spacket.Value[0] & (byte)KeyServerPreference.NoModify) == (int)KeyServerPreference.NoModify) sig.KeyServerPreferences.Add(KeyServerPreference.NoModify);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.ReasonForRevocation))                      {                          if ((spacket.Value[0] & (byte)Reason.KeyCompromised) == (int)Reason.KeyCompromised) sig.ReasonForRevocation.Reason = Reason.KeyCompromised;                          else if ((spacket.Value[0] & (byte)Reason.KeyRetired) == (int)Reason.KeyRetired) sig.ReasonForRevocation.Reason = Reason.KeyRetired;                          else if ((spacket.Value[0] & (byte)Reason.KeySuperceded) == (int)Reason.KeySuperceded) sig.ReasonForRevocation.Reason = Reason.KeySuperceded;                          else if ((spacket.Value[0] & (byte)Reason.NoneSpecified) == (int)Reason.NoneSpecified) sig.ReasonForRevocation.Reason = Reason.NoneSpecified;                          else if ((spacket.Value[0] & (byte)Reason.UserIDNoLongerValid) == (int)Reason.UserIDNoLongerValid) sig.ReasonForRevocation.Reason = Reason.UserIDNoLongerValid;                          byte[] comment = new byte[spacket.Value.Length - 1];                          Array.Copy(spacket.Value' 1' comment' 0' comment.Length);                          sig.ReasonForRevocation.Comment = Encoding.UTF8.GetString(comment'0'comment.Length);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.PreferredCompressionAlgorithms))                          for (int i = 0; i < spacket.Value.Length; i++) sig.PreferredCompressionAlgorithms.Add((CompressionAlgorithm)spacket.Value[i]);                      else if (spacket.Type.Equals(SignatureSubPacketType.PreferredHashAlgorithms))                          for (int i = 0; i < spacket.Value.Length; i++) sig.PreferredHashAlgorithms.Add((HashAlgorithm)spacket.Value[i]);                      else if (spacket.Type.Equals(SignatureSubPacketType.PreferredSymmetricAlgorithms))                          for (int i = 0; i < spacket.Value.Length; i++) sig.PreferredSymmetricAlgorithms.Add((SymmetricKeyAlgorithm)spacket.Value[i]);                  }              }
Magic Number,ActiveUp.Net.Security.OpenPGP.Packets,Signature,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.Signature.cs,Parse,The following statement contains a magic number: if (sig.VersionNumber.Equals(4))              {                  // Hashed subpackets                  byte[] hashedsublengthbytes = new byte[2];                  ms.Read(hashedsublengthbytes' 0' 2);                  short hashedsublength = Converter.ToShort(hashedsublengthbytes);                  while (ms.Position < 5 + hashedsublength)                      sig.HashedSubPackets.Add(GetNextSignatureSubPacket(ref ms));                    // Unhashed subpackets                  byte[] unhashedsublengthbytes = new byte[2];                  ms.Read(unhashedsublengthbytes' 0' 2);                  short unhashedsublength = Converter.ToShort(unhashedsublengthbytes);                  while (ms.Position < hashedsublength + unhashedsublength)                      sig.UnHashedSubPackets.Add(GetNextSignatureSubPacket(ref ms));                    // Fill properties                  List<SignatureSubPacket> allSubPackets = new List<SignatureSubPacket>();                  allSubPackets.AddRange(sig.HashedSubPackets);                  allSubPackets.AddRange(sig.UnHashedSubPackets);                  foreach (SignatureSubPacket spacket in allSubPackets)                  {                      if (spacket.Type.Equals(SignatureSubPacketType.CreationTime))                          sig.CreationTime = Converter.UnixTimeStampToDateTime(Converter.ToInt(spacket.Value));                      else if (spacket.Type.Equals(SignatureSubPacketType.KeyExpirationTime))                          sig.KeyExpiration = Converter.UnixTimeStampToDateTime(Converter.ToInt(spacket.Value));                      else if (spacket.Type.Equals(SignatureSubPacketType.ExpirationTime))                          sig.SignatureExpiration = Converter.UnixTimeStampToDateTime(Converter.ToInt(spacket.Value));                      else if (spacket.Type.Equals(SignatureSubPacketType.ExportableCertification))                          sig.IsExportableCertification = (spacket.Value[0] == 1);                      else if (spacket.Type.Equals(SignatureSubPacketType.Revocable))                          sig.IsRevocable = (spacket.Value[0] == 1);                      else if (spacket.Type.Equals(SignatureSubPacketType.TrustSignature))                      {                          sig.Trust.Level = (TrustLevel)spacket.Value[0];                          sig.Trust.Amount = spacket.Value[1];                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.RegularExpression))                          sig.RegularExpression = spacket.Value;                      else if (spacket.Type.Equals(SignatureSubPacketType.RevocationKey))                      {                          if ((spacket.Value[0] & 128) != 128) throw new InvalidPacketSyntaxException("First bit of revocation key class is 0");                          sig.RevocationKey.Class = (RevocationKeyClass)(spacket.Value[0] & 64);                          sig.RevocationKey.HashAlgorithm = (HashAlgorithm)spacket.Value[1];                          Array.Copy(spacket.Value' 2' sig.RevocationKey.FingerPrint' 0' 20);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.NotationData))                      {                          Notation n = new Notation();                          n.IsHumanReadable = ((spacket.Value[0] & 128) == 128);                          byte[] nameLength = new byte[2];                          Array.Copy(spacket.Value' 4' nameLength' 0' 2);                          Array.Copy(spacket.Value' 6' n.Name' 0' Converter.ToInt(nameLength));                          byte[] valueLength = new byte[2];                          Array.Copy(spacket.Value' 6 + Converter.ToInt(nameLength)' valueLength' 0' 2);                          Array.Copy(spacket.Value' 6 + Converter.ToInt(nameLength) + 2' n.Value' 0' Converter.ToInt(valueLength));                          sig.Notations.Add(n);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.PolicyURL))                          sig.PolicyURL = Encoding.ASCII.GetString(spacket.Value'0'spacket.Value.Length);                      else if (spacket.Type.Equals(SignatureSubPacketType.SignerUserID))                          sig.SignerUserID = Encoding.ASCII.GetString(spacket.Value'0'spacket.Value.Length);                      else if (spacket.Type.Equals(SignatureSubPacketType.SignatureTarget))                      {                          sig.TargetSignatureInfo.PublicKeyAlgorithm = (PublicKeyAlgorithm)spacket.Value[0];                          sig.TargetSignatureInfo.HashAlgorithm = (HashAlgorithm)spacket.Value[1];                          Array.Copy(spacket.Value' 2' sig.TargetSignatureInfo.Hash' 0' spacket.Value.Length - 2);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.EmbeddedSignature))                      {                          Packet embedded = new Packet();                          embedded.RawData = spacket.Value;                          sig.EmbeddedSignature = Signature.Parse(embedded);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.IssuerKeyID))                          sig.IssuerKeyID = Converter.ToULong(spacket.Value);                      else if (spacket.Type.Equals(SignatureSubPacketType.PrimaryUserID))                          sig.IsPrimaryUserID = (spacket.Value[0] == 1);                      else if (spacket.Type.Equals(SignatureSubPacketType.KeyFlags))                      {                          if ((spacket.Value[0] & (byte)KeyFlag.Authentication) == (int)KeyFlag.Authentication) sig.KeyFlags.Add(KeyFlag.Authentication);                          if ((spacket.Value[0] & (byte)KeyFlag.CertifiesOtherKeys) == (int)KeyFlag.CertifiesOtherKeys) sig.KeyFlags.Add(KeyFlag.CertifiesOtherKeys);                          if ((spacket.Value[0] & (byte)KeyFlag.EncryptsCommunications) == (int)KeyFlag.EncryptsCommunications) sig.KeyFlags.Add(KeyFlag.EncryptsCommunications);                          if ((spacket.Value[0] & (byte)KeyFlag.EncryptsStorage) == (int)KeyFlag.EncryptsStorage) sig.KeyFlags.Add(KeyFlag.EncryptsStorage);                          if ((spacket.Value[0] & (byte)KeyFlag.GroupKey) == (int)KeyFlag.GroupKey) sig.KeyFlags.Add(KeyFlag.GroupKey);                          if ((spacket.Value[0] & (byte)KeyFlag.SignsData) == (int)KeyFlag.SignsData) sig.KeyFlags.Add(KeyFlag.SignsData);                          if ((spacket.Value[0] & (byte)KeyFlag.SplitKey) == (int)KeyFlag.SplitKey) sig.KeyFlags.Add(KeyFlag.SplitKey);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.Features))                      {                          if ((spacket.Value[0] & (byte)Feature.ModificationDetection) == (int)Feature.ModificationDetection) sig.Features.Add(Feature.ModificationDetection);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.KeyServerPreferences))                      {                          if ((spacket.Value[0] & (byte)KeyServerPreference.NoModify) == (int)KeyServerPreference.NoModify) sig.KeyServerPreferences.Add(KeyServerPreference.NoModify);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.ReasonForRevocation))                      {                          if ((spacket.Value[0] & (byte)Reason.KeyCompromised) == (int)Reason.KeyCompromised) sig.ReasonForRevocation.Reason = Reason.KeyCompromised;                          else if ((spacket.Value[0] & (byte)Reason.KeyRetired) == (int)Reason.KeyRetired) sig.ReasonForRevocation.Reason = Reason.KeyRetired;                          else if ((spacket.Value[0] & (byte)Reason.KeySuperceded) == (int)Reason.KeySuperceded) sig.ReasonForRevocation.Reason = Reason.KeySuperceded;                          else if ((spacket.Value[0] & (byte)Reason.NoneSpecified) == (int)Reason.NoneSpecified) sig.ReasonForRevocation.Reason = Reason.NoneSpecified;                          else if ((spacket.Value[0] & (byte)Reason.UserIDNoLongerValid) == (int)Reason.UserIDNoLongerValid) sig.ReasonForRevocation.Reason = Reason.UserIDNoLongerValid;                          byte[] comment = new byte[spacket.Value.Length - 1];                          Array.Copy(spacket.Value' 1' comment' 0' comment.Length);                          sig.ReasonForRevocation.Comment = Encoding.UTF8.GetString(comment'0'comment.Length);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.PreferredCompressionAlgorithms))                          for (int i = 0; i < spacket.Value.Length; i++) sig.PreferredCompressionAlgorithms.Add((CompressionAlgorithm)spacket.Value[i]);                      else if (spacket.Type.Equals(SignatureSubPacketType.PreferredHashAlgorithms))                          for (int i = 0; i < spacket.Value.Length; i++) sig.PreferredHashAlgorithms.Add((HashAlgorithm)spacket.Value[i]);                      else if (spacket.Type.Equals(SignatureSubPacketType.PreferredSymmetricAlgorithms))                          for (int i = 0; i < spacket.Value.Length; i++) sig.PreferredSymmetricAlgorithms.Add((SymmetricKeyAlgorithm)spacket.Value[i]);                  }              }
Magic Number,ActiveUp.Net.Security.OpenPGP.Packets,Signature,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.Signature.cs,Parse,The following statement contains a magic number: if (sig.VersionNumber.Equals(4))              {                  // Hashed subpackets                  byte[] hashedsublengthbytes = new byte[2];                  ms.Read(hashedsublengthbytes' 0' 2);                  short hashedsublength = Converter.ToShort(hashedsublengthbytes);                  while (ms.Position < 5 + hashedsublength)                      sig.HashedSubPackets.Add(GetNextSignatureSubPacket(ref ms));                    // Unhashed subpackets                  byte[] unhashedsublengthbytes = new byte[2];                  ms.Read(unhashedsublengthbytes' 0' 2);                  short unhashedsublength = Converter.ToShort(unhashedsublengthbytes);                  while (ms.Position < hashedsublength + unhashedsublength)                      sig.UnHashedSubPackets.Add(GetNextSignatureSubPacket(ref ms));                    // Fill properties                  List<SignatureSubPacket> allSubPackets = new List<SignatureSubPacket>();                  allSubPackets.AddRange(sig.HashedSubPackets);                  allSubPackets.AddRange(sig.UnHashedSubPackets);                  foreach (SignatureSubPacket spacket in allSubPackets)                  {                      if (spacket.Type.Equals(SignatureSubPacketType.CreationTime))                          sig.CreationTime = Converter.UnixTimeStampToDateTime(Converter.ToInt(spacket.Value));                      else if (spacket.Type.Equals(SignatureSubPacketType.KeyExpirationTime))                          sig.KeyExpiration = Converter.UnixTimeStampToDateTime(Converter.ToInt(spacket.Value));                      else if (spacket.Type.Equals(SignatureSubPacketType.ExpirationTime))                          sig.SignatureExpiration = Converter.UnixTimeStampToDateTime(Converter.ToInt(spacket.Value));                      else if (spacket.Type.Equals(SignatureSubPacketType.ExportableCertification))                          sig.IsExportableCertification = (spacket.Value[0] == 1);                      else if (spacket.Type.Equals(SignatureSubPacketType.Revocable))                          sig.IsRevocable = (spacket.Value[0] == 1);                      else if (spacket.Type.Equals(SignatureSubPacketType.TrustSignature))                      {                          sig.Trust.Level = (TrustLevel)spacket.Value[0];                          sig.Trust.Amount = spacket.Value[1];                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.RegularExpression))                          sig.RegularExpression = spacket.Value;                      else if (spacket.Type.Equals(SignatureSubPacketType.RevocationKey))                      {                          if ((spacket.Value[0] & 128) != 128) throw new InvalidPacketSyntaxException("First bit of revocation key class is 0");                          sig.RevocationKey.Class = (RevocationKeyClass)(spacket.Value[0] & 64);                          sig.RevocationKey.HashAlgorithm = (HashAlgorithm)spacket.Value[1];                          Array.Copy(spacket.Value' 2' sig.RevocationKey.FingerPrint' 0' 20);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.NotationData))                      {                          Notation n = new Notation();                          n.IsHumanReadable = ((spacket.Value[0] & 128) == 128);                          byte[] nameLength = new byte[2];                          Array.Copy(spacket.Value' 4' nameLength' 0' 2);                          Array.Copy(spacket.Value' 6' n.Name' 0' Converter.ToInt(nameLength));                          byte[] valueLength = new byte[2];                          Array.Copy(spacket.Value' 6 + Converter.ToInt(nameLength)' valueLength' 0' 2);                          Array.Copy(spacket.Value' 6 + Converter.ToInt(nameLength) + 2' n.Value' 0' Converter.ToInt(valueLength));                          sig.Notations.Add(n);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.PolicyURL))                          sig.PolicyURL = Encoding.ASCII.GetString(spacket.Value'0'spacket.Value.Length);                      else if (spacket.Type.Equals(SignatureSubPacketType.SignerUserID))                          sig.SignerUserID = Encoding.ASCII.GetString(spacket.Value'0'spacket.Value.Length);                      else if (spacket.Type.Equals(SignatureSubPacketType.SignatureTarget))                      {                          sig.TargetSignatureInfo.PublicKeyAlgorithm = (PublicKeyAlgorithm)spacket.Value[0];                          sig.TargetSignatureInfo.HashAlgorithm = (HashAlgorithm)spacket.Value[1];                          Array.Copy(spacket.Value' 2' sig.TargetSignatureInfo.Hash' 0' spacket.Value.Length - 2);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.EmbeddedSignature))                      {                          Packet embedded = new Packet();                          embedded.RawData = spacket.Value;                          sig.EmbeddedSignature = Signature.Parse(embedded);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.IssuerKeyID))                          sig.IssuerKeyID = Converter.ToULong(spacket.Value);                      else if (spacket.Type.Equals(SignatureSubPacketType.PrimaryUserID))                          sig.IsPrimaryUserID = (spacket.Value[0] == 1);                      else if (spacket.Type.Equals(SignatureSubPacketType.KeyFlags))                      {                          if ((spacket.Value[0] & (byte)KeyFlag.Authentication) == (int)KeyFlag.Authentication) sig.KeyFlags.Add(KeyFlag.Authentication);                          if ((spacket.Value[0] & (byte)KeyFlag.CertifiesOtherKeys) == (int)KeyFlag.CertifiesOtherKeys) sig.KeyFlags.Add(KeyFlag.CertifiesOtherKeys);                          if ((spacket.Value[0] & (byte)KeyFlag.EncryptsCommunications) == (int)KeyFlag.EncryptsCommunications) sig.KeyFlags.Add(KeyFlag.EncryptsCommunications);                          if ((spacket.Value[0] & (byte)KeyFlag.EncryptsStorage) == (int)KeyFlag.EncryptsStorage) sig.KeyFlags.Add(KeyFlag.EncryptsStorage);                          if ((spacket.Value[0] & (byte)KeyFlag.GroupKey) == (int)KeyFlag.GroupKey) sig.KeyFlags.Add(KeyFlag.GroupKey);                          if ((spacket.Value[0] & (byte)KeyFlag.SignsData) == (int)KeyFlag.SignsData) sig.KeyFlags.Add(KeyFlag.SignsData);                          if ((spacket.Value[0] & (byte)KeyFlag.SplitKey) == (int)KeyFlag.SplitKey) sig.KeyFlags.Add(KeyFlag.SplitKey);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.Features))                      {                          if ((spacket.Value[0] & (byte)Feature.ModificationDetection) == (int)Feature.ModificationDetection) sig.Features.Add(Feature.ModificationDetection);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.KeyServerPreferences))                      {                          if ((spacket.Value[0] & (byte)KeyServerPreference.NoModify) == (int)KeyServerPreference.NoModify) sig.KeyServerPreferences.Add(KeyServerPreference.NoModify);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.ReasonForRevocation))                      {                          if ((spacket.Value[0] & (byte)Reason.KeyCompromised) == (int)Reason.KeyCompromised) sig.ReasonForRevocation.Reason = Reason.KeyCompromised;                          else if ((spacket.Value[0] & (byte)Reason.KeyRetired) == (int)Reason.KeyRetired) sig.ReasonForRevocation.Reason = Reason.KeyRetired;                          else if ((spacket.Value[0] & (byte)Reason.KeySuperceded) == (int)Reason.KeySuperceded) sig.ReasonForRevocation.Reason = Reason.KeySuperceded;                          else if ((spacket.Value[0] & (byte)Reason.NoneSpecified) == (int)Reason.NoneSpecified) sig.ReasonForRevocation.Reason = Reason.NoneSpecified;                          else if ((spacket.Value[0] & (byte)Reason.UserIDNoLongerValid) == (int)Reason.UserIDNoLongerValid) sig.ReasonForRevocation.Reason = Reason.UserIDNoLongerValid;                          byte[] comment = new byte[spacket.Value.Length - 1];                          Array.Copy(spacket.Value' 1' comment' 0' comment.Length);                          sig.ReasonForRevocation.Comment = Encoding.UTF8.GetString(comment'0'comment.Length);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.PreferredCompressionAlgorithms))                          for (int i = 0; i < spacket.Value.Length; i++) sig.PreferredCompressionAlgorithms.Add((CompressionAlgorithm)spacket.Value[i]);                      else if (spacket.Type.Equals(SignatureSubPacketType.PreferredHashAlgorithms))                          for (int i = 0; i < spacket.Value.Length; i++) sig.PreferredHashAlgorithms.Add((HashAlgorithm)spacket.Value[i]);                      else if (spacket.Type.Equals(SignatureSubPacketType.PreferredSymmetricAlgorithms))                          for (int i = 0; i < spacket.Value.Length; i++) sig.PreferredSymmetricAlgorithms.Add((SymmetricKeyAlgorithm)spacket.Value[i]);                  }              }
Magic Number,ActiveUp.Net.Security.OpenPGP.Packets,Signature,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.Signature.cs,Parse,The following statement contains a magic number: if (sig.VersionNumber.Equals(4))              {                  // Hashed subpackets                  byte[] hashedsublengthbytes = new byte[2];                  ms.Read(hashedsublengthbytes' 0' 2);                  short hashedsublength = Converter.ToShort(hashedsublengthbytes);                  while (ms.Position < 5 + hashedsublength)                      sig.HashedSubPackets.Add(GetNextSignatureSubPacket(ref ms));                    // Unhashed subpackets                  byte[] unhashedsublengthbytes = new byte[2];                  ms.Read(unhashedsublengthbytes' 0' 2);                  short unhashedsublength = Converter.ToShort(unhashedsublengthbytes);                  while (ms.Position < hashedsublength + unhashedsublength)                      sig.UnHashedSubPackets.Add(GetNextSignatureSubPacket(ref ms));                    // Fill properties                  List<SignatureSubPacket> allSubPackets = new List<SignatureSubPacket>();                  allSubPackets.AddRange(sig.HashedSubPackets);                  allSubPackets.AddRange(sig.UnHashedSubPackets);                  foreach (SignatureSubPacket spacket in allSubPackets)                  {                      if (spacket.Type.Equals(SignatureSubPacketType.CreationTime))                          sig.CreationTime = Converter.UnixTimeStampToDateTime(Converter.ToInt(spacket.Value));                      else if (spacket.Type.Equals(SignatureSubPacketType.KeyExpirationTime))                          sig.KeyExpiration = Converter.UnixTimeStampToDateTime(Converter.ToInt(spacket.Value));                      else if (spacket.Type.Equals(SignatureSubPacketType.ExpirationTime))                          sig.SignatureExpiration = Converter.UnixTimeStampToDateTime(Converter.ToInt(spacket.Value));                      else if (spacket.Type.Equals(SignatureSubPacketType.ExportableCertification))                          sig.IsExportableCertification = (spacket.Value[0] == 1);                      else if (spacket.Type.Equals(SignatureSubPacketType.Revocable))                          sig.IsRevocable = (spacket.Value[0] == 1);                      else if (spacket.Type.Equals(SignatureSubPacketType.TrustSignature))                      {                          sig.Trust.Level = (TrustLevel)spacket.Value[0];                          sig.Trust.Amount = spacket.Value[1];                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.RegularExpression))                          sig.RegularExpression = spacket.Value;                      else if (spacket.Type.Equals(SignatureSubPacketType.RevocationKey))                      {                          if ((spacket.Value[0] & 128) != 128) throw new InvalidPacketSyntaxException("First bit of revocation key class is 0");                          sig.RevocationKey.Class = (RevocationKeyClass)(spacket.Value[0] & 64);                          sig.RevocationKey.HashAlgorithm = (HashAlgorithm)spacket.Value[1];                          Array.Copy(spacket.Value' 2' sig.RevocationKey.FingerPrint' 0' 20);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.NotationData))                      {                          Notation n = new Notation();                          n.IsHumanReadable = ((spacket.Value[0] & 128) == 128);                          byte[] nameLength = new byte[2];                          Array.Copy(spacket.Value' 4' nameLength' 0' 2);                          Array.Copy(spacket.Value' 6' n.Name' 0' Converter.ToInt(nameLength));                          byte[] valueLength = new byte[2];                          Array.Copy(spacket.Value' 6 + Converter.ToInt(nameLength)' valueLength' 0' 2);                          Array.Copy(spacket.Value' 6 + Converter.ToInt(nameLength) + 2' n.Value' 0' Converter.ToInt(valueLength));                          sig.Notations.Add(n);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.PolicyURL))                          sig.PolicyURL = Encoding.ASCII.GetString(spacket.Value'0'spacket.Value.Length);                      else if (spacket.Type.Equals(SignatureSubPacketType.SignerUserID))                          sig.SignerUserID = Encoding.ASCII.GetString(spacket.Value'0'spacket.Value.Length);                      else if (spacket.Type.Equals(SignatureSubPacketType.SignatureTarget))                      {                          sig.TargetSignatureInfo.PublicKeyAlgorithm = (PublicKeyAlgorithm)spacket.Value[0];                          sig.TargetSignatureInfo.HashAlgorithm = (HashAlgorithm)spacket.Value[1];                          Array.Copy(spacket.Value' 2' sig.TargetSignatureInfo.Hash' 0' spacket.Value.Length - 2);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.EmbeddedSignature))                      {                          Packet embedded = new Packet();                          embedded.RawData = spacket.Value;                          sig.EmbeddedSignature = Signature.Parse(embedded);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.IssuerKeyID))                          sig.IssuerKeyID = Converter.ToULong(spacket.Value);                      else if (spacket.Type.Equals(SignatureSubPacketType.PrimaryUserID))                          sig.IsPrimaryUserID = (spacket.Value[0] == 1);                      else if (spacket.Type.Equals(SignatureSubPacketType.KeyFlags))                      {                          if ((spacket.Value[0] & (byte)KeyFlag.Authentication) == (int)KeyFlag.Authentication) sig.KeyFlags.Add(KeyFlag.Authentication);                          if ((spacket.Value[0] & (byte)KeyFlag.CertifiesOtherKeys) == (int)KeyFlag.CertifiesOtherKeys) sig.KeyFlags.Add(KeyFlag.CertifiesOtherKeys);                          if ((spacket.Value[0] & (byte)KeyFlag.EncryptsCommunications) == (int)KeyFlag.EncryptsCommunications) sig.KeyFlags.Add(KeyFlag.EncryptsCommunications);                          if ((spacket.Value[0] & (byte)KeyFlag.EncryptsStorage) == (int)KeyFlag.EncryptsStorage) sig.KeyFlags.Add(KeyFlag.EncryptsStorage);                          if ((spacket.Value[0] & (byte)KeyFlag.GroupKey) == (int)KeyFlag.GroupKey) sig.KeyFlags.Add(KeyFlag.GroupKey);                          if ((spacket.Value[0] & (byte)KeyFlag.SignsData) == (int)KeyFlag.SignsData) sig.KeyFlags.Add(KeyFlag.SignsData);                          if ((spacket.Value[0] & (byte)KeyFlag.SplitKey) == (int)KeyFlag.SplitKey) sig.KeyFlags.Add(KeyFlag.SplitKey);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.Features))                      {                          if ((spacket.Value[0] & (byte)Feature.ModificationDetection) == (int)Feature.ModificationDetection) sig.Features.Add(Feature.ModificationDetection);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.KeyServerPreferences))                      {                          if ((spacket.Value[0] & (byte)KeyServerPreference.NoModify) == (int)KeyServerPreference.NoModify) sig.KeyServerPreferences.Add(KeyServerPreference.NoModify);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.ReasonForRevocation))                      {                          if ((spacket.Value[0] & (byte)Reason.KeyCompromised) == (int)Reason.KeyCompromised) sig.ReasonForRevocation.Reason = Reason.KeyCompromised;                          else if ((spacket.Value[0] & (byte)Reason.KeyRetired) == (int)Reason.KeyRetired) sig.ReasonForRevocation.Reason = Reason.KeyRetired;                          else if ((spacket.Value[0] & (byte)Reason.KeySuperceded) == (int)Reason.KeySuperceded) sig.ReasonForRevocation.Reason = Reason.KeySuperceded;                          else if ((spacket.Value[0] & (byte)Reason.NoneSpecified) == (int)Reason.NoneSpecified) sig.ReasonForRevocation.Reason = Reason.NoneSpecified;                          else if ((spacket.Value[0] & (byte)Reason.UserIDNoLongerValid) == (int)Reason.UserIDNoLongerValid) sig.ReasonForRevocation.Reason = Reason.UserIDNoLongerValid;                          byte[] comment = new byte[spacket.Value.Length - 1];                          Array.Copy(spacket.Value' 1' comment' 0' comment.Length);                          sig.ReasonForRevocation.Comment = Encoding.UTF8.GetString(comment'0'comment.Length);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.PreferredCompressionAlgorithms))                          for (int i = 0; i < spacket.Value.Length; i++) sig.PreferredCompressionAlgorithms.Add((CompressionAlgorithm)spacket.Value[i]);                      else if (spacket.Type.Equals(SignatureSubPacketType.PreferredHashAlgorithms))                          for (int i = 0; i < spacket.Value.Length; i++) sig.PreferredHashAlgorithms.Add((HashAlgorithm)spacket.Value[i]);                      else if (spacket.Type.Equals(SignatureSubPacketType.PreferredSymmetricAlgorithms))                          for (int i = 0; i < spacket.Value.Length; i++) sig.PreferredSymmetricAlgorithms.Add((SymmetricKeyAlgorithm)spacket.Value[i]);                  }              }
Magic Number,ActiveUp.Net.Security.OpenPGP.Packets,Signature,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.Signature.cs,Parse,The following statement contains a magic number: if (sig.VersionNumber.Equals(4))              {                  // Hashed subpackets                  byte[] hashedsublengthbytes = new byte[2];                  ms.Read(hashedsublengthbytes' 0' 2);                  short hashedsublength = Converter.ToShort(hashedsublengthbytes);                  while (ms.Position < 5 + hashedsublength)                      sig.HashedSubPackets.Add(GetNextSignatureSubPacket(ref ms));                    // Unhashed subpackets                  byte[] unhashedsublengthbytes = new byte[2];                  ms.Read(unhashedsublengthbytes' 0' 2);                  short unhashedsublength = Converter.ToShort(unhashedsublengthbytes);                  while (ms.Position < hashedsublength + unhashedsublength)                      sig.UnHashedSubPackets.Add(GetNextSignatureSubPacket(ref ms));                    // Fill properties                  List<SignatureSubPacket> allSubPackets = new List<SignatureSubPacket>();                  allSubPackets.AddRange(sig.HashedSubPackets);                  allSubPackets.AddRange(sig.UnHashedSubPackets);                  foreach (SignatureSubPacket spacket in allSubPackets)                  {                      if (spacket.Type.Equals(SignatureSubPacketType.CreationTime))                          sig.CreationTime = Converter.UnixTimeStampToDateTime(Converter.ToInt(spacket.Value));                      else if (spacket.Type.Equals(SignatureSubPacketType.KeyExpirationTime))                          sig.KeyExpiration = Converter.UnixTimeStampToDateTime(Converter.ToInt(spacket.Value));                      else if (spacket.Type.Equals(SignatureSubPacketType.ExpirationTime))                          sig.SignatureExpiration = Converter.UnixTimeStampToDateTime(Converter.ToInt(spacket.Value));                      else if (spacket.Type.Equals(SignatureSubPacketType.ExportableCertification))                          sig.IsExportableCertification = (spacket.Value[0] == 1);                      else if (spacket.Type.Equals(SignatureSubPacketType.Revocable))                          sig.IsRevocable = (spacket.Value[0] == 1);                      else if (spacket.Type.Equals(SignatureSubPacketType.TrustSignature))                      {                          sig.Trust.Level = (TrustLevel)spacket.Value[0];                          sig.Trust.Amount = spacket.Value[1];                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.RegularExpression))                          sig.RegularExpression = spacket.Value;                      else if (spacket.Type.Equals(SignatureSubPacketType.RevocationKey))                      {                          if ((spacket.Value[0] & 128) != 128) throw new InvalidPacketSyntaxException("First bit of revocation key class is 0");                          sig.RevocationKey.Class = (RevocationKeyClass)(spacket.Value[0] & 64);                          sig.RevocationKey.HashAlgorithm = (HashAlgorithm)spacket.Value[1];                          Array.Copy(spacket.Value' 2' sig.RevocationKey.FingerPrint' 0' 20);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.NotationData))                      {                          Notation n = new Notation();                          n.IsHumanReadable = ((spacket.Value[0] & 128) == 128);                          byte[] nameLength = new byte[2];                          Array.Copy(spacket.Value' 4' nameLength' 0' 2);                          Array.Copy(spacket.Value' 6' n.Name' 0' Converter.ToInt(nameLength));                          byte[] valueLength = new byte[2];                          Array.Copy(spacket.Value' 6 + Converter.ToInt(nameLength)' valueLength' 0' 2);                          Array.Copy(spacket.Value' 6 + Converter.ToInt(nameLength) + 2' n.Value' 0' Converter.ToInt(valueLength));                          sig.Notations.Add(n);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.PolicyURL))                          sig.PolicyURL = Encoding.ASCII.GetString(spacket.Value'0'spacket.Value.Length);                      else if (spacket.Type.Equals(SignatureSubPacketType.SignerUserID))                          sig.SignerUserID = Encoding.ASCII.GetString(spacket.Value'0'spacket.Value.Length);                      else if (spacket.Type.Equals(SignatureSubPacketType.SignatureTarget))                      {                          sig.TargetSignatureInfo.PublicKeyAlgorithm = (PublicKeyAlgorithm)spacket.Value[0];                          sig.TargetSignatureInfo.HashAlgorithm = (HashAlgorithm)spacket.Value[1];                          Array.Copy(spacket.Value' 2' sig.TargetSignatureInfo.Hash' 0' spacket.Value.Length - 2);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.EmbeddedSignature))                      {                          Packet embedded = new Packet();                          embedded.RawData = spacket.Value;                          sig.EmbeddedSignature = Signature.Parse(embedded);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.IssuerKeyID))                          sig.IssuerKeyID = Converter.ToULong(spacket.Value);                      else if (spacket.Type.Equals(SignatureSubPacketType.PrimaryUserID))                          sig.IsPrimaryUserID = (spacket.Value[0] == 1);                      else if (spacket.Type.Equals(SignatureSubPacketType.KeyFlags))                      {                          if ((spacket.Value[0] & (byte)KeyFlag.Authentication) == (int)KeyFlag.Authentication) sig.KeyFlags.Add(KeyFlag.Authentication);                          if ((spacket.Value[0] & (byte)KeyFlag.CertifiesOtherKeys) == (int)KeyFlag.CertifiesOtherKeys) sig.KeyFlags.Add(KeyFlag.CertifiesOtherKeys);                          if ((spacket.Value[0] & (byte)KeyFlag.EncryptsCommunications) == (int)KeyFlag.EncryptsCommunications) sig.KeyFlags.Add(KeyFlag.EncryptsCommunications);                          if ((spacket.Value[0] & (byte)KeyFlag.EncryptsStorage) == (int)KeyFlag.EncryptsStorage) sig.KeyFlags.Add(KeyFlag.EncryptsStorage);                          if ((spacket.Value[0] & (byte)KeyFlag.GroupKey) == (int)KeyFlag.GroupKey) sig.KeyFlags.Add(KeyFlag.GroupKey);                          if ((spacket.Value[0] & (byte)KeyFlag.SignsData) == (int)KeyFlag.SignsData) sig.KeyFlags.Add(KeyFlag.SignsData);                          if ((spacket.Value[0] & (byte)KeyFlag.SplitKey) == (int)KeyFlag.SplitKey) sig.KeyFlags.Add(KeyFlag.SplitKey);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.Features))                      {                          if ((spacket.Value[0] & (byte)Feature.ModificationDetection) == (int)Feature.ModificationDetection) sig.Features.Add(Feature.ModificationDetection);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.KeyServerPreferences))                      {                          if ((spacket.Value[0] & (byte)KeyServerPreference.NoModify) == (int)KeyServerPreference.NoModify) sig.KeyServerPreferences.Add(KeyServerPreference.NoModify);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.ReasonForRevocation))                      {                          if ((spacket.Value[0] & (byte)Reason.KeyCompromised) == (int)Reason.KeyCompromised) sig.ReasonForRevocation.Reason = Reason.KeyCompromised;                          else if ((spacket.Value[0] & (byte)Reason.KeyRetired) == (int)Reason.KeyRetired) sig.ReasonForRevocation.Reason = Reason.KeyRetired;                          else if ((spacket.Value[0] & (byte)Reason.KeySuperceded) == (int)Reason.KeySuperceded) sig.ReasonForRevocation.Reason = Reason.KeySuperceded;                          else if ((spacket.Value[0] & (byte)Reason.NoneSpecified) == (int)Reason.NoneSpecified) sig.ReasonForRevocation.Reason = Reason.NoneSpecified;                          else if ((spacket.Value[0] & (byte)Reason.UserIDNoLongerValid) == (int)Reason.UserIDNoLongerValid) sig.ReasonForRevocation.Reason = Reason.UserIDNoLongerValid;                          byte[] comment = new byte[spacket.Value.Length - 1];                          Array.Copy(spacket.Value' 1' comment' 0' comment.Length);                          sig.ReasonForRevocation.Comment = Encoding.UTF8.GetString(comment'0'comment.Length);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.PreferredCompressionAlgorithms))                          for (int i = 0; i < spacket.Value.Length; i++) sig.PreferredCompressionAlgorithms.Add((CompressionAlgorithm)spacket.Value[i]);                      else if (spacket.Type.Equals(SignatureSubPacketType.PreferredHashAlgorithms))                          for (int i = 0; i < spacket.Value.Length; i++) sig.PreferredHashAlgorithms.Add((HashAlgorithm)spacket.Value[i]);                      else if (spacket.Type.Equals(SignatureSubPacketType.PreferredSymmetricAlgorithms))                          for (int i = 0; i < spacket.Value.Length; i++) sig.PreferredSymmetricAlgorithms.Add((SymmetricKeyAlgorithm)spacket.Value[i]);                  }              }
Magic Number,ActiveUp.Net.Security.OpenPGP.Packets,Signature,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.Signature.cs,Parse,The following statement contains a magic number: if (sig.VersionNumber.Equals(4))              {                  // Hashed subpackets                  byte[] hashedsublengthbytes = new byte[2];                  ms.Read(hashedsublengthbytes' 0' 2);                  short hashedsublength = Converter.ToShort(hashedsublengthbytes);                  while (ms.Position < 5 + hashedsublength)                      sig.HashedSubPackets.Add(GetNextSignatureSubPacket(ref ms));                    // Unhashed subpackets                  byte[] unhashedsublengthbytes = new byte[2];                  ms.Read(unhashedsublengthbytes' 0' 2);                  short unhashedsublength = Converter.ToShort(unhashedsublengthbytes);                  while (ms.Position < hashedsublength + unhashedsublength)                      sig.UnHashedSubPackets.Add(GetNextSignatureSubPacket(ref ms));                    // Fill properties                  List<SignatureSubPacket> allSubPackets = new List<SignatureSubPacket>();                  allSubPackets.AddRange(sig.HashedSubPackets);                  allSubPackets.AddRange(sig.UnHashedSubPackets);                  foreach (SignatureSubPacket spacket in allSubPackets)                  {                      if (spacket.Type.Equals(SignatureSubPacketType.CreationTime))                          sig.CreationTime = Converter.UnixTimeStampToDateTime(Converter.ToInt(spacket.Value));                      else if (spacket.Type.Equals(SignatureSubPacketType.KeyExpirationTime))                          sig.KeyExpiration = Converter.UnixTimeStampToDateTime(Converter.ToInt(spacket.Value));                      else if (spacket.Type.Equals(SignatureSubPacketType.ExpirationTime))                          sig.SignatureExpiration = Converter.UnixTimeStampToDateTime(Converter.ToInt(spacket.Value));                      else if (spacket.Type.Equals(SignatureSubPacketType.ExportableCertification))                          sig.IsExportableCertification = (spacket.Value[0] == 1);                      else if (spacket.Type.Equals(SignatureSubPacketType.Revocable))                          sig.IsRevocable = (spacket.Value[0] == 1);                      else if (spacket.Type.Equals(SignatureSubPacketType.TrustSignature))                      {                          sig.Trust.Level = (TrustLevel)spacket.Value[0];                          sig.Trust.Amount = spacket.Value[1];                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.RegularExpression))                          sig.RegularExpression = spacket.Value;                      else if (spacket.Type.Equals(SignatureSubPacketType.RevocationKey))                      {                          if ((spacket.Value[0] & 128) != 128) throw new InvalidPacketSyntaxException("First bit of revocation key class is 0");                          sig.RevocationKey.Class = (RevocationKeyClass)(spacket.Value[0] & 64);                          sig.RevocationKey.HashAlgorithm = (HashAlgorithm)spacket.Value[1];                          Array.Copy(spacket.Value' 2' sig.RevocationKey.FingerPrint' 0' 20);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.NotationData))                      {                          Notation n = new Notation();                          n.IsHumanReadable = ((spacket.Value[0] & 128) == 128);                          byte[] nameLength = new byte[2];                          Array.Copy(spacket.Value' 4' nameLength' 0' 2);                          Array.Copy(spacket.Value' 6' n.Name' 0' Converter.ToInt(nameLength));                          byte[] valueLength = new byte[2];                          Array.Copy(spacket.Value' 6 + Converter.ToInt(nameLength)' valueLength' 0' 2);                          Array.Copy(spacket.Value' 6 + Converter.ToInt(nameLength) + 2' n.Value' 0' Converter.ToInt(valueLength));                          sig.Notations.Add(n);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.PolicyURL))                          sig.PolicyURL = Encoding.ASCII.GetString(spacket.Value'0'spacket.Value.Length);                      else if (spacket.Type.Equals(SignatureSubPacketType.SignerUserID))                          sig.SignerUserID = Encoding.ASCII.GetString(spacket.Value'0'spacket.Value.Length);                      else if (spacket.Type.Equals(SignatureSubPacketType.SignatureTarget))                      {                          sig.TargetSignatureInfo.PublicKeyAlgorithm = (PublicKeyAlgorithm)spacket.Value[0];                          sig.TargetSignatureInfo.HashAlgorithm = (HashAlgorithm)spacket.Value[1];                          Array.Copy(spacket.Value' 2' sig.TargetSignatureInfo.Hash' 0' spacket.Value.Length - 2);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.EmbeddedSignature))                      {                          Packet embedded = new Packet();                          embedded.RawData = spacket.Value;                          sig.EmbeddedSignature = Signature.Parse(embedded);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.IssuerKeyID))                          sig.IssuerKeyID = Converter.ToULong(spacket.Value);                      else if (spacket.Type.Equals(SignatureSubPacketType.PrimaryUserID))                          sig.IsPrimaryUserID = (spacket.Value[0] == 1);                      else if (spacket.Type.Equals(SignatureSubPacketType.KeyFlags))                      {                          if ((spacket.Value[0] & (byte)KeyFlag.Authentication) == (int)KeyFlag.Authentication) sig.KeyFlags.Add(KeyFlag.Authentication);                          if ((spacket.Value[0] & (byte)KeyFlag.CertifiesOtherKeys) == (int)KeyFlag.CertifiesOtherKeys) sig.KeyFlags.Add(KeyFlag.CertifiesOtherKeys);                          if ((spacket.Value[0] & (byte)KeyFlag.EncryptsCommunications) == (int)KeyFlag.EncryptsCommunications) sig.KeyFlags.Add(KeyFlag.EncryptsCommunications);                          if ((spacket.Value[0] & (byte)KeyFlag.EncryptsStorage) == (int)KeyFlag.EncryptsStorage) sig.KeyFlags.Add(KeyFlag.EncryptsStorage);                          if ((spacket.Value[0] & (byte)KeyFlag.GroupKey) == (int)KeyFlag.GroupKey) sig.KeyFlags.Add(KeyFlag.GroupKey);                          if ((spacket.Value[0] & (byte)KeyFlag.SignsData) == (int)KeyFlag.SignsData) sig.KeyFlags.Add(KeyFlag.SignsData);                          if ((spacket.Value[0] & (byte)KeyFlag.SplitKey) == (int)KeyFlag.SplitKey) sig.KeyFlags.Add(KeyFlag.SplitKey);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.Features))                      {                          if ((spacket.Value[0] & (byte)Feature.ModificationDetection) == (int)Feature.ModificationDetection) sig.Features.Add(Feature.ModificationDetection);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.KeyServerPreferences))                      {                          if ((spacket.Value[0] & (byte)KeyServerPreference.NoModify) == (int)KeyServerPreference.NoModify) sig.KeyServerPreferences.Add(KeyServerPreference.NoModify);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.ReasonForRevocation))                      {                          if ((spacket.Value[0] & (byte)Reason.KeyCompromised) == (int)Reason.KeyCompromised) sig.ReasonForRevocation.Reason = Reason.KeyCompromised;                          else if ((spacket.Value[0] & (byte)Reason.KeyRetired) == (int)Reason.KeyRetired) sig.ReasonForRevocation.Reason = Reason.KeyRetired;                          else if ((spacket.Value[0] & (byte)Reason.KeySuperceded) == (int)Reason.KeySuperceded) sig.ReasonForRevocation.Reason = Reason.KeySuperceded;                          else if ((spacket.Value[0] & (byte)Reason.NoneSpecified) == (int)Reason.NoneSpecified) sig.ReasonForRevocation.Reason = Reason.NoneSpecified;                          else if ((spacket.Value[0] & (byte)Reason.UserIDNoLongerValid) == (int)Reason.UserIDNoLongerValid) sig.ReasonForRevocation.Reason = Reason.UserIDNoLongerValid;                          byte[] comment = new byte[spacket.Value.Length - 1];                          Array.Copy(spacket.Value' 1' comment' 0' comment.Length);                          sig.ReasonForRevocation.Comment = Encoding.UTF8.GetString(comment'0'comment.Length);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.PreferredCompressionAlgorithms))                          for (int i = 0; i < spacket.Value.Length; i++) sig.PreferredCompressionAlgorithms.Add((CompressionAlgorithm)spacket.Value[i]);                      else if (spacket.Type.Equals(SignatureSubPacketType.PreferredHashAlgorithms))                          for (int i = 0; i < spacket.Value.Length; i++) sig.PreferredHashAlgorithms.Add((HashAlgorithm)spacket.Value[i]);                      else if (spacket.Type.Equals(SignatureSubPacketType.PreferredSymmetricAlgorithms))                          for (int i = 0; i < spacket.Value.Length; i++) sig.PreferredSymmetricAlgorithms.Add((SymmetricKeyAlgorithm)spacket.Value[i]);                  }              }
Magic Number,ActiveUp.Net.Security.OpenPGP.Packets,Signature,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.Signature.cs,Parse,The following statement contains a magic number: if (sig.VersionNumber.Equals(4))              {                  // Hashed subpackets                  byte[] hashedsublengthbytes = new byte[2];                  ms.Read(hashedsublengthbytes' 0' 2);                  short hashedsublength = Converter.ToShort(hashedsublengthbytes);                  while (ms.Position < 5 + hashedsublength)                      sig.HashedSubPackets.Add(GetNextSignatureSubPacket(ref ms));                    // Unhashed subpackets                  byte[] unhashedsublengthbytes = new byte[2];                  ms.Read(unhashedsublengthbytes' 0' 2);                  short unhashedsublength = Converter.ToShort(unhashedsublengthbytes);                  while (ms.Position < hashedsublength + unhashedsublength)                      sig.UnHashedSubPackets.Add(GetNextSignatureSubPacket(ref ms));                    // Fill properties                  List<SignatureSubPacket> allSubPackets = new List<SignatureSubPacket>();                  allSubPackets.AddRange(sig.HashedSubPackets);                  allSubPackets.AddRange(sig.UnHashedSubPackets);                  foreach (SignatureSubPacket spacket in allSubPackets)                  {                      if (spacket.Type.Equals(SignatureSubPacketType.CreationTime))                          sig.CreationTime = Converter.UnixTimeStampToDateTime(Converter.ToInt(spacket.Value));                      else if (spacket.Type.Equals(SignatureSubPacketType.KeyExpirationTime))                          sig.KeyExpiration = Converter.UnixTimeStampToDateTime(Converter.ToInt(spacket.Value));                      else if (spacket.Type.Equals(SignatureSubPacketType.ExpirationTime))                          sig.SignatureExpiration = Converter.UnixTimeStampToDateTime(Converter.ToInt(spacket.Value));                      else if (spacket.Type.Equals(SignatureSubPacketType.ExportableCertification))                          sig.IsExportableCertification = (spacket.Value[0] == 1);                      else if (spacket.Type.Equals(SignatureSubPacketType.Revocable))                          sig.IsRevocable = (spacket.Value[0] == 1);                      else if (spacket.Type.Equals(SignatureSubPacketType.TrustSignature))                      {                          sig.Trust.Level = (TrustLevel)spacket.Value[0];                          sig.Trust.Amount = spacket.Value[1];                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.RegularExpression))                          sig.RegularExpression = spacket.Value;                      else if (spacket.Type.Equals(SignatureSubPacketType.RevocationKey))                      {                          if ((spacket.Value[0] & 128) != 128) throw new InvalidPacketSyntaxException("First bit of revocation key class is 0");                          sig.RevocationKey.Class = (RevocationKeyClass)(spacket.Value[0] & 64);                          sig.RevocationKey.HashAlgorithm = (HashAlgorithm)spacket.Value[1];                          Array.Copy(spacket.Value' 2' sig.RevocationKey.FingerPrint' 0' 20);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.NotationData))                      {                          Notation n = new Notation();                          n.IsHumanReadable = ((spacket.Value[0] & 128) == 128);                          byte[] nameLength = new byte[2];                          Array.Copy(spacket.Value' 4' nameLength' 0' 2);                          Array.Copy(spacket.Value' 6' n.Name' 0' Converter.ToInt(nameLength));                          byte[] valueLength = new byte[2];                          Array.Copy(spacket.Value' 6 + Converter.ToInt(nameLength)' valueLength' 0' 2);                          Array.Copy(spacket.Value' 6 + Converter.ToInt(nameLength) + 2' n.Value' 0' Converter.ToInt(valueLength));                          sig.Notations.Add(n);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.PolicyURL))                          sig.PolicyURL = Encoding.ASCII.GetString(spacket.Value'0'spacket.Value.Length);                      else if (spacket.Type.Equals(SignatureSubPacketType.SignerUserID))                          sig.SignerUserID = Encoding.ASCII.GetString(spacket.Value'0'spacket.Value.Length);                      else if (spacket.Type.Equals(SignatureSubPacketType.SignatureTarget))                      {                          sig.TargetSignatureInfo.PublicKeyAlgorithm = (PublicKeyAlgorithm)spacket.Value[0];                          sig.TargetSignatureInfo.HashAlgorithm = (HashAlgorithm)spacket.Value[1];                          Array.Copy(spacket.Value' 2' sig.TargetSignatureInfo.Hash' 0' spacket.Value.Length - 2);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.EmbeddedSignature))                      {                          Packet embedded = new Packet();                          embedded.RawData = spacket.Value;                          sig.EmbeddedSignature = Signature.Parse(embedded);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.IssuerKeyID))                          sig.IssuerKeyID = Converter.ToULong(spacket.Value);                      else if (spacket.Type.Equals(SignatureSubPacketType.PrimaryUserID))                          sig.IsPrimaryUserID = (spacket.Value[0] == 1);                      else if (spacket.Type.Equals(SignatureSubPacketType.KeyFlags))                      {                          if ((spacket.Value[0] & (byte)KeyFlag.Authentication) == (int)KeyFlag.Authentication) sig.KeyFlags.Add(KeyFlag.Authentication);                          if ((spacket.Value[0] & (byte)KeyFlag.CertifiesOtherKeys) == (int)KeyFlag.CertifiesOtherKeys) sig.KeyFlags.Add(KeyFlag.CertifiesOtherKeys);                          if ((spacket.Value[0] & (byte)KeyFlag.EncryptsCommunications) == (int)KeyFlag.EncryptsCommunications) sig.KeyFlags.Add(KeyFlag.EncryptsCommunications);                          if ((spacket.Value[0] & (byte)KeyFlag.EncryptsStorage) == (int)KeyFlag.EncryptsStorage) sig.KeyFlags.Add(KeyFlag.EncryptsStorage);                          if ((spacket.Value[0] & (byte)KeyFlag.GroupKey) == (int)KeyFlag.GroupKey) sig.KeyFlags.Add(KeyFlag.GroupKey);                          if ((spacket.Value[0] & (byte)KeyFlag.SignsData) == (int)KeyFlag.SignsData) sig.KeyFlags.Add(KeyFlag.SignsData);                          if ((spacket.Value[0] & (byte)KeyFlag.SplitKey) == (int)KeyFlag.SplitKey) sig.KeyFlags.Add(KeyFlag.SplitKey);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.Features))                      {                          if ((spacket.Value[0] & (byte)Feature.ModificationDetection) == (int)Feature.ModificationDetection) sig.Features.Add(Feature.ModificationDetection);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.KeyServerPreferences))                      {                          if ((spacket.Value[0] & (byte)KeyServerPreference.NoModify) == (int)KeyServerPreference.NoModify) sig.KeyServerPreferences.Add(KeyServerPreference.NoModify);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.ReasonForRevocation))                      {                          if ((spacket.Value[0] & (byte)Reason.KeyCompromised) == (int)Reason.KeyCompromised) sig.ReasonForRevocation.Reason = Reason.KeyCompromised;                          else if ((spacket.Value[0] & (byte)Reason.KeyRetired) == (int)Reason.KeyRetired) sig.ReasonForRevocation.Reason = Reason.KeyRetired;                          else if ((spacket.Value[0] & (byte)Reason.KeySuperceded) == (int)Reason.KeySuperceded) sig.ReasonForRevocation.Reason = Reason.KeySuperceded;                          else if ((spacket.Value[0] & (byte)Reason.NoneSpecified) == (int)Reason.NoneSpecified) sig.ReasonForRevocation.Reason = Reason.NoneSpecified;                          else if ((spacket.Value[0] & (byte)Reason.UserIDNoLongerValid) == (int)Reason.UserIDNoLongerValid) sig.ReasonForRevocation.Reason = Reason.UserIDNoLongerValid;                          byte[] comment = new byte[spacket.Value.Length - 1];                          Array.Copy(spacket.Value' 1' comment' 0' comment.Length);                          sig.ReasonForRevocation.Comment = Encoding.UTF8.GetString(comment'0'comment.Length);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.PreferredCompressionAlgorithms))                          for (int i = 0; i < spacket.Value.Length; i++) sig.PreferredCompressionAlgorithms.Add((CompressionAlgorithm)spacket.Value[i]);                      else if (spacket.Type.Equals(SignatureSubPacketType.PreferredHashAlgorithms))                          for (int i = 0; i < spacket.Value.Length; i++) sig.PreferredHashAlgorithms.Add((HashAlgorithm)spacket.Value[i]);                      else if (spacket.Type.Equals(SignatureSubPacketType.PreferredSymmetricAlgorithms))                          for (int i = 0; i < spacket.Value.Length; i++) sig.PreferredSymmetricAlgorithms.Add((SymmetricKeyAlgorithm)spacket.Value[i]);                  }              }
Magic Number,ActiveUp.Net.Security.OpenPGP.Packets,Signature,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.Signature.cs,Parse,The following statement contains a magic number: if (sig.VersionNumber.Equals(4))              {                  // Hashed subpackets                  byte[] hashedsublengthbytes = new byte[2];                  ms.Read(hashedsublengthbytes' 0' 2);                  short hashedsublength = Converter.ToShort(hashedsublengthbytes);                  while (ms.Position < 5 + hashedsublength)                      sig.HashedSubPackets.Add(GetNextSignatureSubPacket(ref ms));                    // Unhashed subpackets                  byte[] unhashedsublengthbytes = new byte[2];                  ms.Read(unhashedsublengthbytes' 0' 2);                  short unhashedsublength = Converter.ToShort(unhashedsublengthbytes);                  while (ms.Position < hashedsublength + unhashedsublength)                      sig.UnHashedSubPackets.Add(GetNextSignatureSubPacket(ref ms));                    // Fill properties                  List<SignatureSubPacket> allSubPackets = new List<SignatureSubPacket>();                  allSubPackets.AddRange(sig.HashedSubPackets);                  allSubPackets.AddRange(sig.UnHashedSubPackets);                  foreach (SignatureSubPacket spacket in allSubPackets)                  {                      if (spacket.Type.Equals(SignatureSubPacketType.CreationTime))                          sig.CreationTime = Converter.UnixTimeStampToDateTime(Converter.ToInt(spacket.Value));                      else if (spacket.Type.Equals(SignatureSubPacketType.KeyExpirationTime))                          sig.KeyExpiration = Converter.UnixTimeStampToDateTime(Converter.ToInt(spacket.Value));                      else if (spacket.Type.Equals(SignatureSubPacketType.ExpirationTime))                          sig.SignatureExpiration = Converter.UnixTimeStampToDateTime(Converter.ToInt(spacket.Value));                      else if (spacket.Type.Equals(SignatureSubPacketType.ExportableCertification))                          sig.IsExportableCertification = (spacket.Value[0] == 1);                      else if (spacket.Type.Equals(SignatureSubPacketType.Revocable))                          sig.IsRevocable = (spacket.Value[0] == 1);                      else if (spacket.Type.Equals(SignatureSubPacketType.TrustSignature))                      {                          sig.Trust.Level = (TrustLevel)spacket.Value[0];                          sig.Trust.Amount = spacket.Value[1];                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.RegularExpression))                          sig.RegularExpression = spacket.Value;                      else if (spacket.Type.Equals(SignatureSubPacketType.RevocationKey))                      {                          if ((spacket.Value[0] & 128) != 128) throw new InvalidPacketSyntaxException("First bit of revocation key class is 0");                          sig.RevocationKey.Class = (RevocationKeyClass)(spacket.Value[0] & 64);                          sig.RevocationKey.HashAlgorithm = (HashAlgorithm)spacket.Value[1];                          Array.Copy(spacket.Value' 2' sig.RevocationKey.FingerPrint' 0' 20);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.NotationData))                      {                          Notation n = new Notation();                          n.IsHumanReadable = ((spacket.Value[0] & 128) == 128);                          byte[] nameLength = new byte[2];                          Array.Copy(spacket.Value' 4' nameLength' 0' 2);                          Array.Copy(spacket.Value' 6' n.Name' 0' Converter.ToInt(nameLength));                          byte[] valueLength = new byte[2];                          Array.Copy(spacket.Value' 6 + Converter.ToInt(nameLength)' valueLength' 0' 2);                          Array.Copy(spacket.Value' 6 + Converter.ToInt(nameLength) + 2' n.Value' 0' Converter.ToInt(valueLength));                          sig.Notations.Add(n);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.PolicyURL))                          sig.PolicyURL = Encoding.ASCII.GetString(spacket.Value'0'spacket.Value.Length);                      else if (spacket.Type.Equals(SignatureSubPacketType.SignerUserID))                          sig.SignerUserID = Encoding.ASCII.GetString(spacket.Value'0'spacket.Value.Length);                      else if (spacket.Type.Equals(SignatureSubPacketType.SignatureTarget))                      {                          sig.TargetSignatureInfo.PublicKeyAlgorithm = (PublicKeyAlgorithm)spacket.Value[0];                          sig.TargetSignatureInfo.HashAlgorithm = (HashAlgorithm)spacket.Value[1];                          Array.Copy(spacket.Value' 2' sig.TargetSignatureInfo.Hash' 0' spacket.Value.Length - 2);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.EmbeddedSignature))                      {                          Packet embedded = new Packet();                          embedded.RawData = spacket.Value;                          sig.EmbeddedSignature = Signature.Parse(embedded);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.IssuerKeyID))                          sig.IssuerKeyID = Converter.ToULong(spacket.Value);                      else if (spacket.Type.Equals(SignatureSubPacketType.PrimaryUserID))                          sig.IsPrimaryUserID = (spacket.Value[0] == 1);                      else if (spacket.Type.Equals(SignatureSubPacketType.KeyFlags))                      {                          if ((spacket.Value[0] & (byte)KeyFlag.Authentication) == (int)KeyFlag.Authentication) sig.KeyFlags.Add(KeyFlag.Authentication);                          if ((spacket.Value[0] & (byte)KeyFlag.CertifiesOtherKeys) == (int)KeyFlag.CertifiesOtherKeys) sig.KeyFlags.Add(KeyFlag.CertifiesOtherKeys);                          if ((spacket.Value[0] & (byte)KeyFlag.EncryptsCommunications) == (int)KeyFlag.EncryptsCommunications) sig.KeyFlags.Add(KeyFlag.EncryptsCommunications);                          if ((spacket.Value[0] & (byte)KeyFlag.EncryptsStorage) == (int)KeyFlag.EncryptsStorage) sig.KeyFlags.Add(KeyFlag.EncryptsStorage);                          if ((spacket.Value[0] & (byte)KeyFlag.GroupKey) == (int)KeyFlag.GroupKey) sig.KeyFlags.Add(KeyFlag.GroupKey);                          if ((spacket.Value[0] & (byte)KeyFlag.SignsData) == (int)KeyFlag.SignsData) sig.KeyFlags.Add(KeyFlag.SignsData);                          if ((spacket.Value[0] & (byte)KeyFlag.SplitKey) == (int)KeyFlag.SplitKey) sig.KeyFlags.Add(KeyFlag.SplitKey);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.Features))                      {                          if ((spacket.Value[0] & (byte)Feature.ModificationDetection) == (int)Feature.ModificationDetection) sig.Features.Add(Feature.ModificationDetection);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.KeyServerPreferences))                      {                          if ((spacket.Value[0] & (byte)KeyServerPreference.NoModify) == (int)KeyServerPreference.NoModify) sig.KeyServerPreferences.Add(KeyServerPreference.NoModify);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.ReasonForRevocation))                      {                          if ((spacket.Value[0] & (byte)Reason.KeyCompromised) == (int)Reason.KeyCompromised) sig.ReasonForRevocation.Reason = Reason.KeyCompromised;                          else if ((spacket.Value[0] & (byte)Reason.KeyRetired) == (int)Reason.KeyRetired) sig.ReasonForRevocation.Reason = Reason.KeyRetired;                          else if ((spacket.Value[0] & (byte)Reason.KeySuperceded) == (int)Reason.KeySuperceded) sig.ReasonForRevocation.Reason = Reason.KeySuperceded;                          else if ((spacket.Value[0] & (byte)Reason.NoneSpecified) == (int)Reason.NoneSpecified) sig.ReasonForRevocation.Reason = Reason.NoneSpecified;                          else if ((spacket.Value[0] & (byte)Reason.UserIDNoLongerValid) == (int)Reason.UserIDNoLongerValid) sig.ReasonForRevocation.Reason = Reason.UserIDNoLongerValid;                          byte[] comment = new byte[spacket.Value.Length - 1];                          Array.Copy(spacket.Value' 1' comment' 0' comment.Length);                          sig.ReasonForRevocation.Comment = Encoding.UTF8.GetString(comment'0'comment.Length);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.PreferredCompressionAlgorithms))                          for (int i = 0; i < spacket.Value.Length; i++) sig.PreferredCompressionAlgorithms.Add((CompressionAlgorithm)spacket.Value[i]);                      else if (spacket.Type.Equals(SignatureSubPacketType.PreferredHashAlgorithms))                          for (int i = 0; i < spacket.Value.Length; i++) sig.PreferredHashAlgorithms.Add((HashAlgorithm)spacket.Value[i]);                      else if (spacket.Type.Equals(SignatureSubPacketType.PreferredSymmetricAlgorithms))                          for (int i = 0; i < spacket.Value.Length; i++) sig.PreferredSymmetricAlgorithms.Add((SymmetricKeyAlgorithm)spacket.Value[i]);                  }              }
Magic Number,ActiveUp.Net.Security.OpenPGP.Packets,Signature,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.Signature.cs,Parse,The following statement contains a magic number: if (sig.VersionNumber.Equals(4))              {                  // Hashed subpackets                  byte[] hashedsublengthbytes = new byte[2];                  ms.Read(hashedsublengthbytes' 0' 2);                  short hashedsublength = Converter.ToShort(hashedsublengthbytes);                  while (ms.Position < 5 + hashedsublength)                      sig.HashedSubPackets.Add(GetNextSignatureSubPacket(ref ms));                    // Unhashed subpackets                  byte[] unhashedsublengthbytes = new byte[2];                  ms.Read(unhashedsublengthbytes' 0' 2);                  short unhashedsublength = Converter.ToShort(unhashedsublengthbytes);                  while (ms.Position < hashedsublength + unhashedsublength)                      sig.UnHashedSubPackets.Add(GetNextSignatureSubPacket(ref ms));                    // Fill properties                  List<SignatureSubPacket> allSubPackets = new List<SignatureSubPacket>();                  allSubPackets.AddRange(sig.HashedSubPackets);                  allSubPackets.AddRange(sig.UnHashedSubPackets);                  foreach (SignatureSubPacket spacket in allSubPackets)                  {                      if (spacket.Type.Equals(SignatureSubPacketType.CreationTime))                          sig.CreationTime = Converter.UnixTimeStampToDateTime(Converter.ToInt(spacket.Value));                      else if (spacket.Type.Equals(SignatureSubPacketType.KeyExpirationTime))                          sig.KeyExpiration = Converter.UnixTimeStampToDateTime(Converter.ToInt(spacket.Value));                      else if (spacket.Type.Equals(SignatureSubPacketType.ExpirationTime))                          sig.SignatureExpiration = Converter.UnixTimeStampToDateTime(Converter.ToInt(spacket.Value));                      else if (spacket.Type.Equals(SignatureSubPacketType.ExportableCertification))                          sig.IsExportableCertification = (spacket.Value[0] == 1);                      else if (spacket.Type.Equals(SignatureSubPacketType.Revocable))                          sig.IsRevocable = (spacket.Value[0] == 1);                      else if (spacket.Type.Equals(SignatureSubPacketType.TrustSignature))                      {                          sig.Trust.Level = (TrustLevel)spacket.Value[0];                          sig.Trust.Amount = spacket.Value[1];                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.RegularExpression))                          sig.RegularExpression = spacket.Value;                      else if (spacket.Type.Equals(SignatureSubPacketType.RevocationKey))                      {                          if ((spacket.Value[0] & 128) != 128) throw new InvalidPacketSyntaxException("First bit of revocation key class is 0");                          sig.RevocationKey.Class = (RevocationKeyClass)(spacket.Value[0] & 64);                          sig.RevocationKey.HashAlgorithm = (HashAlgorithm)spacket.Value[1];                          Array.Copy(spacket.Value' 2' sig.RevocationKey.FingerPrint' 0' 20);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.NotationData))                      {                          Notation n = new Notation();                          n.IsHumanReadable = ((spacket.Value[0] & 128) == 128);                          byte[] nameLength = new byte[2];                          Array.Copy(spacket.Value' 4' nameLength' 0' 2);                          Array.Copy(spacket.Value' 6' n.Name' 0' Converter.ToInt(nameLength));                          byte[] valueLength = new byte[2];                          Array.Copy(spacket.Value' 6 + Converter.ToInt(nameLength)' valueLength' 0' 2);                          Array.Copy(spacket.Value' 6 + Converter.ToInt(nameLength) + 2' n.Value' 0' Converter.ToInt(valueLength));                          sig.Notations.Add(n);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.PolicyURL))                          sig.PolicyURL = Encoding.ASCII.GetString(spacket.Value'0'spacket.Value.Length);                      else if (spacket.Type.Equals(SignatureSubPacketType.SignerUserID))                          sig.SignerUserID = Encoding.ASCII.GetString(spacket.Value'0'spacket.Value.Length);                      else if (spacket.Type.Equals(SignatureSubPacketType.SignatureTarget))                      {                          sig.TargetSignatureInfo.PublicKeyAlgorithm = (PublicKeyAlgorithm)spacket.Value[0];                          sig.TargetSignatureInfo.HashAlgorithm = (HashAlgorithm)spacket.Value[1];                          Array.Copy(spacket.Value' 2' sig.TargetSignatureInfo.Hash' 0' spacket.Value.Length - 2);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.EmbeddedSignature))                      {                          Packet embedded = new Packet();                          embedded.RawData = spacket.Value;                          sig.EmbeddedSignature = Signature.Parse(embedded);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.IssuerKeyID))                          sig.IssuerKeyID = Converter.ToULong(spacket.Value);                      else if (spacket.Type.Equals(SignatureSubPacketType.PrimaryUserID))                          sig.IsPrimaryUserID = (spacket.Value[0] == 1);                      else if (spacket.Type.Equals(SignatureSubPacketType.KeyFlags))                      {                          if ((spacket.Value[0] & (byte)KeyFlag.Authentication) == (int)KeyFlag.Authentication) sig.KeyFlags.Add(KeyFlag.Authentication);                          if ((spacket.Value[0] & (byte)KeyFlag.CertifiesOtherKeys) == (int)KeyFlag.CertifiesOtherKeys) sig.KeyFlags.Add(KeyFlag.CertifiesOtherKeys);                          if ((spacket.Value[0] & (byte)KeyFlag.EncryptsCommunications) == (int)KeyFlag.EncryptsCommunications) sig.KeyFlags.Add(KeyFlag.EncryptsCommunications);                          if ((spacket.Value[0] & (byte)KeyFlag.EncryptsStorage) == (int)KeyFlag.EncryptsStorage) sig.KeyFlags.Add(KeyFlag.EncryptsStorage);                          if ((spacket.Value[0] & (byte)KeyFlag.GroupKey) == (int)KeyFlag.GroupKey) sig.KeyFlags.Add(KeyFlag.GroupKey);                          if ((spacket.Value[0] & (byte)KeyFlag.SignsData) == (int)KeyFlag.SignsData) sig.KeyFlags.Add(KeyFlag.SignsData);                          if ((spacket.Value[0] & (byte)KeyFlag.SplitKey) == (int)KeyFlag.SplitKey) sig.KeyFlags.Add(KeyFlag.SplitKey);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.Features))                      {                          if ((spacket.Value[0] & (byte)Feature.ModificationDetection) == (int)Feature.ModificationDetection) sig.Features.Add(Feature.ModificationDetection);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.KeyServerPreferences))                      {                          if ((spacket.Value[0] & (byte)KeyServerPreference.NoModify) == (int)KeyServerPreference.NoModify) sig.KeyServerPreferences.Add(KeyServerPreference.NoModify);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.ReasonForRevocation))                      {                          if ((spacket.Value[0] & (byte)Reason.KeyCompromised) == (int)Reason.KeyCompromised) sig.ReasonForRevocation.Reason = Reason.KeyCompromised;                          else if ((spacket.Value[0] & (byte)Reason.KeyRetired) == (int)Reason.KeyRetired) sig.ReasonForRevocation.Reason = Reason.KeyRetired;                          else if ((spacket.Value[0] & (byte)Reason.KeySuperceded) == (int)Reason.KeySuperceded) sig.ReasonForRevocation.Reason = Reason.KeySuperceded;                          else if ((spacket.Value[0] & (byte)Reason.NoneSpecified) == (int)Reason.NoneSpecified) sig.ReasonForRevocation.Reason = Reason.NoneSpecified;                          else if ((spacket.Value[0] & (byte)Reason.UserIDNoLongerValid) == (int)Reason.UserIDNoLongerValid) sig.ReasonForRevocation.Reason = Reason.UserIDNoLongerValid;                          byte[] comment = new byte[spacket.Value.Length - 1];                          Array.Copy(spacket.Value' 1' comment' 0' comment.Length);                          sig.ReasonForRevocation.Comment = Encoding.UTF8.GetString(comment'0'comment.Length);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.PreferredCompressionAlgorithms))                          for (int i = 0; i < spacket.Value.Length; i++) sig.PreferredCompressionAlgorithms.Add((CompressionAlgorithm)spacket.Value[i]);                      else if (spacket.Type.Equals(SignatureSubPacketType.PreferredHashAlgorithms))                          for (int i = 0; i < spacket.Value.Length; i++) sig.PreferredHashAlgorithms.Add((HashAlgorithm)spacket.Value[i]);                      else if (spacket.Type.Equals(SignatureSubPacketType.PreferredSymmetricAlgorithms))                          for (int i = 0; i < spacket.Value.Length; i++) sig.PreferredSymmetricAlgorithms.Add((SymmetricKeyAlgorithm)spacket.Value[i]);                  }              }
Magic Number,ActiveUp.Net.Security.OpenPGP.Packets,Signature,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.Signature.cs,Parse,The following statement contains a magic number: if (sig.VersionNumber.Equals(4))              {                  // Hashed subpackets                  byte[] hashedsublengthbytes = new byte[2];                  ms.Read(hashedsublengthbytes' 0' 2);                  short hashedsublength = Converter.ToShort(hashedsublengthbytes);                  while (ms.Position < 5 + hashedsublength)                      sig.HashedSubPackets.Add(GetNextSignatureSubPacket(ref ms));                    // Unhashed subpackets                  byte[] unhashedsublengthbytes = new byte[2];                  ms.Read(unhashedsublengthbytes' 0' 2);                  short unhashedsublength = Converter.ToShort(unhashedsublengthbytes);                  while (ms.Position < hashedsublength + unhashedsublength)                      sig.UnHashedSubPackets.Add(GetNextSignatureSubPacket(ref ms));                    // Fill properties                  List<SignatureSubPacket> allSubPackets = new List<SignatureSubPacket>();                  allSubPackets.AddRange(sig.HashedSubPackets);                  allSubPackets.AddRange(sig.UnHashedSubPackets);                  foreach (SignatureSubPacket spacket in allSubPackets)                  {                      if (spacket.Type.Equals(SignatureSubPacketType.CreationTime))                          sig.CreationTime = Converter.UnixTimeStampToDateTime(Converter.ToInt(spacket.Value));                      else if (spacket.Type.Equals(SignatureSubPacketType.KeyExpirationTime))                          sig.KeyExpiration = Converter.UnixTimeStampToDateTime(Converter.ToInt(spacket.Value));                      else if (spacket.Type.Equals(SignatureSubPacketType.ExpirationTime))                          sig.SignatureExpiration = Converter.UnixTimeStampToDateTime(Converter.ToInt(spacket.Value));                      else if (spacket.Type.Equals(SignatureSubPacketType.ExportableCertification))                          sig.IsExportableCertification = (spacket.Value[0] == 1);                      else if (spacket.Type.Equals(SignatureSubPacketType.Revocable))                          sig.IsRevocable = (spacket.Value[0] == 1);                      else if (spacket.Type.Equals(SignatureSubPacketType.TrustSignature))                      {                          sig.Trust.Level = (TrustLevel)spacket.Value[0];                          sig.Trust.Amount = spacket.Value[1];                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.RegularExpression))                          sig.RegularExpression = spacket.Value;                      else if (spacket.Type.Equals(SignatureSubPacketType.RevocationKey))                      {                          if ((spacket.Value[0] & 128) != 128) throw new InvalidPacketSyntaxException("First bit of revocation key class is 0");                          sig.RevocationKey.Class = (RevocationKeyClass)(spacket.Value[0] & 64);                          sig.RevocationKey.HashAlgorithm = (HashAlgorithm)spacket.Value[1];                          Array.Copy(spacket.Value' 2' sig.RevocationKey.FingerPrint' 0' 20);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.NotationData))                      {                          Notation n = new Notation();                          n.IsHumanReadable = ((spacket.Value[0] & 128) == 128);                          byte[] nameLength = new byte[2];                          Array.Copy(spacket.Value' 4' nameLength' 0' 2);                          Array.Copy(spacket.Value' 6' n.Name' 0' Converter.ToInt(nameLength));                          byte[] valueLength = new byte[2];                          Array.Copy(spacket.Value' 6 + Converter.ToInt(nameLength)' valueLength' 0' 2);                          Array.Copy(spacket.Value' 6 + Converter.ToInt(nameLength) + 2' n.Value' 0' Converter.ToInt(valueLength));                          sig.Notations.Add(n);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.PolicyURL))                          sig.PolicyURL = Encoding.ASCII.GetString(spacket.Value'0'spacket.Value.Length);                      else if (spacket.Type.Equals(SignatureSubPacketType.SignerUserID))                          sig.SignerUserID = Encoding.ASCII.GetString(spacket.Value'0'spacket.Value.Length);                      else if (spacket.Type.Equals(SignatureSubPacketType.SignatureTarget))                      {                          sig.TargetSignatureInfo.PublicKeyAlgorithm = (PublicKeyAlgorithm)spacket.Value[0];                          sig.TargetSignatureInfo.HashAlgorithm = (HashAlgorithm)spacket.Value[1];                          Array.Copy(spacket.Value' 2' sig.TargetSignatureInfo.Hash' 0' spacket.Value.Length - 2);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.EmbeddedSignature))                      {                          Packet embedded = new Packet();                          embedded.RawData = spacket.Value;                          sig.EmbeddedSignature = Signature.Parse(embedded);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.IssuerKeyID))                          sig.IssuerKeyID = Converter.ToULong(spacket.Value);                      else if (spacket.Type.Equals(SignatureSubPacketType.PrimaryUserID))                          sig.IsPrimaryUserID = (spacket.Value[0] == 1);                      else if (spacket.Type.Equals(SignatureSubPacketType.KeyFlags))                      {                          if ((spacket.Value[0] & (byte)KeyFlag.Authentication) == (int)KeyFlag.Authentication) sig.KeyFlags.Add(KeyFlag.Authentication);                          if ((spacket.Value[0] & (byte)KeyFlag.CertifiesOtherKeys) == (int)KeyFlag.CertifiesOtherKeys) sig.KeyFlags.Add(KeyFlag.CertifiesOtherKeys);                          if ((spacket.Value[0] & (byte)KeyFlag.EncryptsCommunications) == (int)KeyFlag.EncryptsCommunications) sig.KeyFlags.Add(KeyFlag.EncryptsCommunications);                          if ((spacket.Value[0] & (byte)KeyFlag.EncryptsStorage) == (int)KeyFlag.EncryptsStorage) sig.KeyFlags.Add(KeyFlag.EncryptsStorage);                          if ((spacket.Value[0] & (byte)KeyFlag.GroupKey) == (int)KeyFlag.GroupKey) sig.KeyFlags.Add(KeyFlag.GroupKey);                          if ((spacket.Value[0] & (byte)KeyFlag.SignsData) == (int)KeyFlag.SignsData) sig.KeyFlags.Add(KeyFlag.SignsData);                          if ((spacket.Value[0] & (byte)KeyFlag.SplitKey) == (int)KeyFlag.SplitKey) sig.KeyFlags.Add(KeyFlag.SplitKey);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.Features))                      {                          if ((spacket.Value[0] & (byte)Feature.ModificationDetection) == (int)Feature.ModificationDetection) sig.Features.Add(Feature.ModificationDetection);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.KeyServerPreferences))                      {                          if ((spacket.Value[0] & (byte)KeyServerPreference.NoModify) == (int)KeyServerPreference.NoModify) sig.KeyServerPreferences.Add(KeyServerPreference.NoModify);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.ReasonForRevocation))                      {                          if ((spacket.Value[0] & (byte)Reason.KeyCompromised) == (int)Reason.KeyCompromised) sig.ReasonForRevocation.Reason = Reason.KeyCompromised;                          else if ((spacket.Value[0] & (byte)Reason.KeyRetired) == (int)Reason.KeyRetired) sig.ReasonForRevocation.Reason = Reason.KeyRetired;                          else if ((spacket.Value[0] & (byte)Reason.KeySuperceded) == (int)Reason.KeySuperceded) sig.ReasonForRevocation.Reason = Reason.KeySuperceded;                          else if ((spacket.Value[0] & (byte)Reason.NoneSpecified) == (int)Reason.NoneSpecified) sig.ReasonForRevocation.Reason = Reason.NoneSpecified;                          else if ((spacket.Value[0] & (byte)Reason.UserIDNoLongerValid) == (int)Reason.UserIDNoLongerValid) sig.ReasonForRevocation.Reason = Reason.UserIDNoLongerValid;                          byte[] comment = new byte[spacket.Value.Length - 1];                          Array.Copy(spacket.Value' 1' comment' 0' comment.Length);                          sig.ReasonForRevocation.Comment = Encoding.UTF8.GetString(comment'0'comment.Length);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.PreferredCompressionAlgorithms))                          for (int i = 0; i < spacket.Value.Length; i++) sig.PreferredCompressionAlgorithms.Add((CompressionAlgorithm)spacket.Value[i]);                      else if (spacket.Type.Equals(SignatureSubPacketType.PreferredHashAlgorithms))                          for (int i = 0; i < spacket.Value.Length; i++) sig.PreferredHashAlgorithms.Add((HashAlgorithm)spacket.Value[i]);                      else if (spacket.Type.Equals(SignatureSubPacketType.PreferredSymmetricAlgorithms))                          for (int i = 0; i < spacket.Value.Length; i++) sig.PreferredSymmetricAlgorithms.Add((SymmetricKeyAlgorithm)spacket.Value[i]);                  }              }
Magic Number,ActiveUp.Net.Security.OpenPGP.Packets,Signature,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.Signature.cs,Parse,The following statement contains a magic number: if (sig.VersionNumber.Equals(4))              {                  // Hashed subpackets                  byte[] hashedsublengthbytes = new byte[2];                  ms.Read(hashedsublengthbytes' 0' 2);                  short hashedsublength = Converter.ToShort(hashedsublengthbytes);                  while (ms.Position < 5 + hashedsublength)                      sig.HashedSubPackets.Add(GetNextSignatureSubPacket(ref ms));                    // Unhashed subpackets                  byte[] unhashedsublengthbytes = new byte[2];                  ms.Read(unhashedsublengthbytes' 0' 2);                  short unhashedsublength = Converter.ToShort(unhashedsublengthbytes);                  while (ms.Position < hashedsublength + unhashedsublength)                      sig.UnHashedSubPackets.Add(GetNextSignatureSubPacket(ref ms));                    // Fill properties                  List<SignatureSubPacket> allSubPackets = new List<SignatureSubPacket>();                  allSubPackets.AddRange(sig.HashedSubPackets);                  allSubPackets.AddRange(sig.UnHashedSubPackets);                  foreach (SignatureSubPacket spacket in allSubPackets)                  {                      if (spacket.Type.Equals(SignatureSubPacketType.CreationTime))                          sig.CreationTime = Converter.UnixTimeStampToDateTime(Converter.ToInt(spacket.Value));                      else if (spacket.Type.Equals(SignatureSubPacketType.KeyExpirationTime))                          sig.KeyExpiration = Converter.UnixTimeStampToDateTime(Converter.ToInt(spacket.Value));                      else if (spacket.Type.Equals(SignatureSubPacketType.ExpirationTime))                          sig.SignatureExpiration = Converter.UnixTimeStampToDateTime(Converter.ToInt(spacket.Value));                      else if (spacket.Type.Equals(SignatureSubPacketType.ExportableCertification))                          sig.IsExportableCertification = (spacket.Value[0] == 1);                      else if (spacket.Type.Equals(SignatureSubPacketType.Revocable))                          sig.IsRevocable = (spacket.Value[0] == 1);                      else if (spacket.Type.Equals(SignatureSubPacketType.TrustSignature))                      {                          sig.Trust.Level = (TrustLevel)spacket.Value[0];                          sig.Trust.Amount = spacket.Value[1];                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.RegularExpression))                          sig.RegularExpression = spacket.Value;                      else if (spacket.Type.Equals(SignatureSubPacketType.RevocationKey))                      {                          if ((spacket.Value[0] & 128) != 128) throw new InvalidPacketSyntaxException("First bit of revocation key class is 0");                          sig.RevocationKey.Class = (RevocationKeyClass)(spacket.Value[0] & 64);                          sig.RevocationKey.HashAlgorithm = (HashAlgorithm)spacket.Value[1];                          Array.Copy(spacket.Value' 2' sig.RevocationKey.FingerPrint' 0' 20);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.NotationData))                      {                          Notation n = new Notation();                          n.IsHumanReadable = ((spacket.Value[0] & 128) == 128);                          byte[] nameLength = new byte[2];                          Array.Copy(spacket.Value' 4' nameLength' 0' 2);                          Array.Copy(spacket.Value' 6' n.Name' 0' Converter.ToInt(nameLength));                          byte[] valueLength = new byte[2];                          Array.Copy(spacket.Value' 6 + Converter.ToInt(nameLength)' valueLength' 0' 2);                          Array.Copy(spacket.Value' 6 + Converter.ToInt(nameLength) + 2' n.Value' 0' Converter.ToInt(valueLength));                          sig.Notations.Add(n);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.PolicyURL))                          sig.PolicyURL = Encoding.ASCII.GetString(spacket.Value'0'spacket.Value.Length);                      else if (spacket.Type.Equals(SignatureSubPacketType.SignerUserID))                          sig.SignerUserID = Encoding.ASCII.GetString(spacket.Value'0'spacket.Value.Length);                      else if (spacket.Type.Equals(SignatureSubPacketType.SignatureTarget))                      {                          sig.TargetSignatureInfo.PublicKeyAlgorithm = (PublicKeyAlgorithm)spacket.Value[0];                          sig.TargetSignatureInfo.HashAlgorithm = (HashAlgorithm)spacket.Value[1];                          Array.Copy(spacket.Value' 2' sig.TargetSignatureInfo.Hash' 0' spacket.Value.Length - 2);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.EmbeddedSignature))                      {                          Packet embedded = new Packet();                          embedded.RawData = spacket.Value;                          sig.EmbeddedSignature = Signature.Parse(embedded);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.IssuerKeyID))                          sig.IssuerKeyID = Converter.ToULong(spacket.Value);                      else if (spacket.Type.Equals(SignatureSubPacketType.PrimaryUserID))                          sig.IsPrimaryUserID = (spacket.Value[0] == 1);                      else if (spacket.Type.Equals(SignatureSubPacketType.KeyFlags))                      {                          if ((spacket.Value[0] & (byte)KeyFlag.Authentication) == (int)KeyFlag.Authentication) sig.KeyFlags.Add(KeyFlag.Authentication);                          if ((spacket.Value[0] & (byte)KeyFlag.CertifiesOtherKeys) == (int)KeyFlag.CertifiesOtherKeys) sig.KeyFlags.Add(KeyFlag.CertifiesOtherKeys);                          if ((spacket.Value[0] & (byte)KeyFlag.EncryptsCommunications) == (int)KeyFlag.EncryptsCommunications) sig.KeyFlags.Add(KeyFlag.EncryptsCommunications);                          if ((spacket.Value[0] & (byte)KeyFlag.EncryptsStorage) == (int)KeyFlag.EncryptsStorage) sig.KeyFlags.Add(KeyFlag.EncryptsStorage);                          if ((spacket.Value[0] & (byte)KeyFlag.GroupKey) == (int)KeyFlag.GroupKey) sig.KeyFlags.Add(KeyFlag.GroupKey);                          if ((spacket.Value[0] & (byte)KeyFlag.SignsData) == (int)KeyFlag.SignsData) sig.KeyFlags.Add(KeyFlag.SignsData);                          if ((spacket.Value[0] & (byte)KeyFlag.SplitKey) == (int)KeyFlag.SplitKey) sig.KeyFlags.Add(KeyFlag.SplitKey);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.Features))                      {                          if ((spacket.Value[0] & (byte)Feature.ModificationDetection) == (int)Feature.ModificationDetection) sig.Features.Add(Feature.ModificationDetection);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.KeyServerPreferences))                      {                          if ((spacket.Value[0] & (byte)KeyServerPreference.NoModify) == (int)KeyServerPreference.NoModify) sig.KeyServerPreferences.Add(KeyServerPreference.NoModify);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.ReasonForRevocation))                      {                          if ((spacket.Value[0] & (byte)Reason.KeyCompromised) == (int)Reason.KeyCompromised) sig.ReasonForRevocation.Reason = Reason.KeyCompromised;                          else if ((spacket.Value[0] & (byte)Reason.KeyRetired) == (int)Reason.KeyRetired) sig.ReasonForRevocation.Reason = Reason.KeyRetired;                          else if ((spacket.Value[0] & (byte)Reason.KeySuperceded) == (int)Reason.KeySuperceded) sig.ReasonForRevocation.Reason = Reason.KeySuperceded;                          else if ((spacket.Value[0] & (byte)Reason.NoneSpecified) == (int)Reason.NoneSpecified) sig.ReasonForRevocation.Reason = Reason.NoneSpecified;                          else if ((spacket.Value[0] & (byte)Reason.UserIDNoLongerValid) == (int)Reason.UserIDNoLongerValid) sig.ReasonForRevocation.Reason = Reason.UserIDNoLongerValid;                          byte[] comment = new byte[spacket.Value.Length - 1];                          Array.Copy(spacket.Value' 1' comment' 0' comment.Length);                          sig.ReasonForRevocation.Comment = Encoding.UTF8.GetString(comment'0'comment.Length);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.PreferredCompressionAlgorithms))                          for (int i = 0; i < spacket.Value.Length; i++) sig.PreferredCompressionAlgorithms.Add((CompressionAlgorithm)spacket.Value[i]);                      else if (spacket.Type.Equals(SignatureSubPacketType.PreferredHashAlgorithms))                          for (int i = 0; i < spacket.Value.Length; i++) sig.PreferredHashAlgorithms.Add((HashAlgorithm)spacket.Value[i]);                      else if (spacket.Type.Equals(SignatureSubPacketType.PreferredSymmetricAlgorithms))                          for (int i = 0; i < spacket.Value.Length; i++) sig.PreferredSymmetricAlgorithms.Add((SymmetricKeyAlgorithm)spacket.Value[i]);                  }              }
Magic Number,ActiveUp.Net.Security.OpenPGP.Packets,Signature,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.Signature.cs,Parse,The following statement contains a magic number: if (sig.VersionNumber.Equals(4))              {                  // Hashed subpackets                  byte[] hashedsublengthbytes = new byte[2];                  ms.Read(hashedsublengthbytes' 0' 2);                  short hashedsublength = Converter.ToShort(hashedsublengthbytes);                  while (ms.Position < 5 + hashedsublength)                      sig.HashedSubPackets.Add(GetNextSignatureSubPacket(ref ms));                    // Unhashed subpackets                  byte[] unhashedsublengthbytes = new byte[2];                  ms.Read(unhashedsublengthbytes' 0' 2);                  short unhashedsublength = Converter.ToShort(unhashedsublengthbytes);                  while (ms.Position < hashedsublength + unhashedsublength)                      sig.UnHashedSubPackets.Add(GetNextSignatureSubPacket(ref ms));                    // Fill properties                  List<SignatureSubPacket> allSubPackets = new List<SignatureSubPacket>();                  allSubPackets.AddRange(sig.HashedSubPackets);                  allSubPackets.AddRange(sig.UnHashedSubPackets);                  foreach (SignatureSubPacket spacket in allSubPackets)                  {                      if (spacket.Type.Equals(SignatureSubPacketType.CreationTime))                          sig.CreationTime = Converter.UnixTimeStampToDateTime(Converter.ToInt(spacket.Value));                      else if (spacket.Type.Equals(SignatureSubPacketType.KeyExpirationTime))                          sig.KeyExpiration = Converter.UnixTimeStampToDateTime(Converter.ToInt(spacket.Value));                      else if (spacket.Type.Equals(SignatureSubPacketType.ExpirationTime))                          sig.SignatureExpiration = Converter.UnixTimeStampToDateTime(Converter.ToInt(spacket.Value));                      else if (spacket.Type.Equals(SignatureSubPacketType.ExportableCertification))                          sig.IsExportableCertification = (spacket.Value[0] == 1);                      else if (spacket.Type.Equals(SignatureSubPacketType.Revocable))                          sig.IsRevocable = (spacket.Value[0] == 1);                      else if (spacket.Type.Equals(SignatureSubPacketType.TrustSignature))                      {                          sig.Trust.Level = (TrustLevel)spacket.Value[0];                          sig.Trust.Amount = spacket.Value[1];                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.RegularExpression))                          sig.RegularExpression = spacket.Value;                      else if (spacket.Type.Equals(SignatureSubPacketType.RevocationKey))                      {                          if ((spacket.Value[0] & 128) != 128) throw new InvalidPacketSyntaxException("First bit of revocation key class is 0");                          sig.RevocationKey.Class = (RevocationKeyClass)(spacket.Value[0] & 64);                          sig.RevocationKey.HashAlgorithm = (HashAlgorithm)spacket.Value[1];                          Array.Copy(spacket.Value' 2' sig.RevocationKey.FingerPrint' 0' 20);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.NotationData))                      {                          Notation n = new Notation();                          n.IsHumanReadable = ((spacket.Value[0] & 128) == 128);                          byte[] nameLength = new byte[2];                          Array.Copy(spacket.Value' 4' nameLength' 0' 2);                          Array.Copy(spacket.Value' 6' n.Name' 0' Converter.ToInt(nameLength));                          byte[] valueLength = new byte[2];                          Array.Copy(spacket.Value' 6 + Converter.ToInt(nameLength)' valueLength' 0' 2);                          Array.Copy(spacket.Value' 6 + Converter.ToInt(nameLength) + 2' n.Value' 0' Converter.ToInt(valueLength));                          sig.Notations.Add(n);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.PolicyURL))                          sig.PolicyURL = Encoding.ASCII.GetString(spacket.Value'0'spacket.Value.Length);                      else if (spacket.Type.Equals(SignatureSubPacketType.SignerUserID))                          sig.SignerUserID = Encoding.ASCII.GetString(spacket.Value'0'spacket.Value.Length);                      else if (spacket.Type.Equals(SignatureSubPacketType.SignatureTarget))                      {                          sig.TargetSignatureInfo.PublicKeyAlgorithm = (PublicKeyAlgorithm)spacket.Value[0];                          sig.TargetSignatureInfo.HashAlgorithm = (HashAlgorithm)spacket.Value[1];                          Array.Copy(spacket.Value' 2' sig.TargetSignatureInfo.Hash' 0' spacket.Value.Length - 2);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.EmbeddedSignature))                      {                          Packet embedded = new Packet();                          embedded.RawData = spacket.Value;                          sig.EmbeddedSignature = Signature.Parse(embedded);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.IssuerKeyID))                          sig.IssuerKeyID = Converter.ToULong(spacket.Value);                      else if (spacket.Type.Equals(SignatureSubPacketType.PrimaryUserID))                          sig.IsPrimaryUserID = (spacket.Value[0] == 1);                      else if (spacket.Type.Equals(SignatureSubPacketType.KeyFlags))                      {                          if ((spacket.Value[0] & (byte)KeyFlag.Authentication) == (int)KeyFlag.Authentication) sig.KeyFlags.Add(KeyFlag.Authentication);                          if ((spacket.Value[0] & (byte)KeyFlag.CertifiesOtherKeys) == (int)KeyFlag.CertifiesOtherKeys) sig.KeyFlags.Add(KeyFlag.CertifiesOtherKeys);                          if ((spacket.Value[0] & (byte)KeyFlag.EncryptsCommunications) == (int)KeyFlag.EncryptsCommunications) sig.KeyFlags.Add(KeyFlag.EncryptsCommunications);                          if ((spacket.Value[0] & (byte)KeyFlag.EncryptsStorage) == (int)KeyFlag.EncryptsStorage) sig.KeyFlags.Add(KeyFlag.EncryptsStorage);                          if ((spacket.Value[0] & (byte)KeyFlag.GroupKey) == (int)KeyFlag.GroupKey) sig.KeyFlags.Add(KeyFlag.GroupKey);                          if ((spacket.Value[0] & (byte)KeyFlag.SignsData) == (int)KeyFlag.SignsData) sig.KeyFlags.Add(KeyFlag.SignsData);                          if ((spacket.Value[0] & (byte)KeyFlag.SplitKey) == (int)KeyFlag.SplitKey) sig.KeyFlags.Add(KeyFlag.SplitKey);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.Features))                      {                          if ((spacket.Value[0] & (byte)Feature.ModificationDetection) == (int)Feature.ModificationDetection) sig.Features.Add(Feature.ModificationDetection);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.KeyServerPreferences))                      {                          if ((spacket.Value[0] & (byte)KeyServerPreference.NoModify) == (int)KeyServerPreference.NoModify) sig.KeyServerPreferences.Add(KeyServerPreference.NoModify);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.ReasonForRevocation))                      {                          if ((spacket.Value[0] & (byte)Reason.KeyCompromised) == (int)Reason.KeyCompromised) sig.ReasonForRevocation.Reason = Reason.KeyCompromised;                          else if ((spacket.Value[0] & (byte)Reason.KeyRetired) == (int)Reason.KeyRetired) sig.ReasonForRevocation.Reason = Reason.KeyRetired;                          else if ((spacket.Value[0] & (byte)Reason.KeySuperceded) == (int)Reason.KeySuperceded) sig.ReasonForRevocation.Reason = Reason.KeySuperceded;                          else if ((spacket.Value[0] & (byte)Reason.NoneSpecified) == (int)Reason.NoneSpecified) sig.ReasonForRevocation.Reason = Reason.NoneSpecified;                          else if ((spacket.Value[0] & (byte)Reason.UserIDNoLongerValid) == (int)Reason.UserIDNoLongerValid) sig.ReasonForRevocation.Reason = Reason.UserIDNoLongerValid;                          byte[] comment = new byte[spacket.Value.Length - 1];                          Array.Copy(spacket.Value' 1' comment' 0' comment.Length);                          sig.ReasonForRevocation.Comment = Encoding.UTF8.GetString(comment'0'comment.Length);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.PreferredCompressionAlgorithms))                          for (int i = 0; i < spacket.Value.Length; i++) sig.PreferredCompressionAlgorithms.Add((CompressionAlgorithm)spacket.Value[i]);                      else if (spacket.Type.Equals(SignatureSubPacketType.PreferredHashAlgorithms))                          for (int i = 0; i < spacket.Value.Length; i++) sig.PreferredHashAlgorithms.Add((HashAlgorithm)spacket.Value[i]);                      else if (spacket.Type.Equals(SignatureSubPacketType.PreferredSymmetricAlgorithms))                          for (int i = 0; i < spacket.Value.Length; i++) sig.PreferredSymmetricAlgorithms.Add((SymmetricKeyAlgorithm)spacket.Value[i]);                  }              }
Magic Number,ActiveUp.Net.Security.OpenPGP.Packets,Signature,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.Signature.cs,Parse,The following statement contains a magic number: if (sig.VersionNumber.Equals(4))              {                  // Hashed subpackets                  byte[] hashedsublengthbytes = new byte[2];                  ms.Read(hashedsublengthbytes' 0' 2);                  short hashedsublength = Converter.ToShort(hashedsublengthbytes);                  while (ms.Position < 5 + hashedsublength)                      sig.HashedSubPackets.Add(GetNextSignatureSubPacket(ref ms));                    // Unhashed subpackets                  byte[] unhashedsublengthbytes = new byte[2];                  ms.Read(unhashedsublengthbytes' 0' 2);                  short unhashedsublength = Converter.ToShort(unhashedsublengthbytes);                  while (ms.Position < hashedsublength + unhashedsublength)                      sig.UnHashedSubPackets.Add(GetNextSignatureSubPacket(ref ms));                    // Fill properties                  List<SignatureSubPacket> allSubPackets = new List<SignatureSubPacket>();                  allSubPackets.AddRange(sig.HashedSubPackets);                  allSubPackets.AddRange(sig.UnHashedSubPackets);                  foreach (SignatureSubPacket spacket in allSubPackets)                  {                      if (spacket.Type.Equals(SignatureSubPacketType.CreationTime))                          sig.CreationTime = Converter.UnixTimeStampToDateTime(Converter.ToInt(spacket.Value));                      else if (spacket.Type.Equals(SignatureSubPacketType.KeyExpirationTime))                          sig.KeyExpiration = Converter.UnixTimeStampToDateTime(Converter.ToInt(spacket.Value));                      else if (spacket.Type.Equals(SignatureSubPacketType.ExpirationTime))                          sig.SignatureExpiration = Converter.UnixTimeStampToDateTime(Converter.ToInt(spacket.Value));                      else if (spacket.Type.Equals(SignatureSubPacketType.ExportableCertification))                          sig.IsExportableCertification = (spacket.Value[0] == 1);                      else if (spacket.Type.Equals(SignatureSubPacketType.Revocable))                          sig.IsRevocable = (spacket.Value[0] == 1);                      else if (spacket.Type.Equals(SignatureSubPacketType.TrustSignature))                      {                          sig.Trust.Level = (TrustLevel)spacket.Value[0];                          sig.Trust.Amount = spacket.Value[1];                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.RegularExpression))                          sig.RegularExpression = spacket.Value;                      else if (spacket.Type.Equals(SignatureSubPacketType.RevocationKey))                      {                          if ((spacket.Value[0] & 128) != 128) throw new InvalidPacketSyntaxException("First bit of revocation key class is 0");                          sig.RevocationKey.Class = (RevocationKeyClass)(spacket.Value[0] & 64);                          sig.RevocationKey.HashAlgorithm = (HashAlgorithm)spacket.Value[1];                          Array.Copy(spacket.Value' 2' sig.RevocationKey.FingerPrint' 0' 20);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.NotationData))                      {                          Notation n = new Notation();                          n.IsHumanReadable = ((spacket.Value[0] & 128) == 128);                          byte[] nameLength = new byte[2];                          Array.Copy(spacket.Value' 4' nameLength' 0' 2);                          Array.Copy(spacket.Value' 6' n.Name' 0' Converter.ToInt(nameLength));                          byte[] valueLength = new byte[2];                          Array.Copy(spacket.Value' 6 + Converter.ToInt(nameLength)' valueLength' 0' 2);                          Array.Copy(spacket.Value' 6 + Converter.ToInt(nameLength) + 2' n.Value' 0' Converter.ToInt(valueLength));                          sig.Notations.Add(n);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.PolicyURL))                          sig.PolicyURL = Encoding.ASCII.GetString(spacket.Value'0'spacket.Value.Length);                      else if (spacket.Type.Equals(SignatureSubPacketType.SignerUserID))                          sig.SignerUserID = Encoding.ASCII.GetString(spacket.Value'0'spacket.Value.Length);                      else if (spacket.Type.Equals(SignatureSubPacketType.SignatureTarget))                      {                          sig.TargetSignatureInfo.PublicKeyAlgorithm = (PublicKeyAlgorithm)spacket.Value[0];                          sig.TargetSignatureInfo.HashAlgorithm = (HashAlgorithm)spacket.Value[1];                          Array.Copy(spacket.Value' 2' sig.TargetSignatureInfo.Hash' 0' spacket.Value.Length - 2);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.EmbeddedSignature))                      {                          Packet embedded = new Packet();                          embedded.RawData = spacket.Value;                          sig.EmbeddedSignature = Signature.Parse(embedded);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.IssuerKeyID))                          sig.IssuerKeyID = Converter.ToULong(spacket.Value);                      else if (spacket.Type.Equals(SignatureSubPacketType.PrimaryUserID))                          sig.IsPrimaryUserID = (spacket.Value[0] == 1);                      else if (spacket.Type.Equals(SignatureSubPacketType.KeyFlags))                      {                          if ((spacket.Value[0] & (byte)KeyFlag.Authentication) == (int)KeyFlag.Authentication) sig.KeyFlags.Add(KeyFlag.Authentication);                          if ((spacket.Value[0] & (byte)KeyFlag.CertifiesOtherKeys) == (int)KeyFlag.CertifiesOtherKeys) sig.KeyFlags.Add(KeyFlag.CertifiesOtherKeys);                          if ((spacket.Value[0] & (byte)KeyFlag.EncryptsCommunications) == (int)KeyFlag.EncryptsCommunications) sig.KeyFlags.Add(KeyFlag.EncryptsCommunications);                          if ((spacket.Value[0] & (byte)KeyFlag.EncryptsStorage) == (int)KeyFlag.EncryptsStorage) sig.KeyFlags.Add(KeyFlag.EncryptsStorage);                          if ((spacket.Value[0] & (byte)KeyFlag.GroupKey) == (int)KeyFlag.GroupKey) sig.KeyFlags.Add(KeyFlag.GroupKey);                          if ((spacket.Value[0] & (byte)KeyFlag.SignsData) == (int)KeyFlag.SignsData) sig.KeyFlags.Add(KeyFlag.SignsData);                          if ((spacket.Value[0] & (byte)KeyFlag.SplitKey) == (int)KeyFlag.SplitKey) sig.KeyFlags.Add(KeyFlag.SplitKey);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.Features))                      {                          if ((spacket.Value[0] & (byte)Feature.ModificationDetection) == (int)Feature.ModificationDetection) sig.Features.Add(Feature.ModificationDetection);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.KeyServerPreferences))                      {                          if ((spacket.Value[0] & (byte)KeyServerPreference.NoModify) == (int)KeyServerPreference.NoModify) sig.KeyServerPreferences.Add(KeyServerPreference.NoModify);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.ReasonForRevocation))                      {                          if ((spacket.Value[0] & (byte)Reason.KeyCompromised) == (int)Reason.KeyCompromised) sig.ReasonForRevocation.Reason = Reason.KeyCompromised;                          else if ((spacket.Value[0] & (byte)Reason.KeyRetired) == (int)Reason.KeyRetired) sig.ReasonForRevocation.Reason = Reason.KeyRetired;                          else if ((spacket.Value[0] & (byte)Reason.KeySuperceded) == (int)Reason.KeySuperceded) sig.ReasonForRevocation.Reason = Reason.KeySuperceded;                          else if ((spacket.Value[0] & (byte)Reason.NoneSpecified) == (int)Reason.NoneSpecified) sig.ReasonForRevocation.Reason = Reason.NoneSpecified;                          else if ((spacket.Value[0] & (byte)Reason.UserIDNoLongerValid) == (int)Reason.UserIDNoLongerValid) sig.ReasonForRevocation.Reason = Reason.UserIDNoLongerValid;                          byte[] comment = new byte[spacket.Value.Length - 1];                          Array.Copy(spacket.Value' 1' comment' 0' comment.Length);                          sig.ReasonForRevocation.Comment = Encoding.UTF8.GetString(comment'0'comment.Length);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.PreferredCompressionAlgorithms))                          for (int i = 0; i < spacket.Value.Length; i++) sig.PreferredCompressionAlgorithms.Add((CompressionAlgorithm)spacket.Value[i]);                      else if (spacket.Type.Equals(SignatureSubPacketType.PreferredHashAlgorithms))                          for (int i = 0; i < spacket.Value.Length; i++) sig.PreferredHashAlgorithms.Add((HashAlgorithm)spacket.Value[i]);                      else if (spacket.Type.Equals(SignatureSubPacketType.PreferredSymmetricAlgorithms))                          for (int i = 0; i < spacket.Value.Length; i++) sig.PreferredSymmetricAlgorithms.Add((SymmetricKeyAlgorithm)spacket.Value[i]);                  }              }
Magic Number,ActiveUp.Net.Security.OpenPGP.Packets,Signature,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.Signature.cs,Parse,The following statement contains a magic number: if (sig.VersionNumber.Equals(4))              {                  // Hashed subpackets                  byte[] hashedsublengthbytes = new byte[2];                  ms.Read(hashedsublengthbytes' 0' 2);                  short hashedsublength = Converter.ToShort(hashedsublengthbytes);                  while (ms.Position < 5 + hashedsublength)                      sig.HashedSubPackets.Add(GetNextSignatureSubPacket(ref ms));                    // Unhashed subpackets                  byte[] unhashedsublengthbytes = new byte[2];                  ms.Read(unhashedsublengthbytes' 0' 2);                  short unhashedsublength = Converter.ToShort(unhashedsublengthbytes);                  while (ms.Position < hashedsublength + unhashedsublength)                      sig.UnHashedSubPackets.Add(GetNextSignatureSubPacket(ref ms));                    // Fill properties                  List<SignatureSubPacket> allSubPackets = new List<SignatureSubPacket>();                  allSubPackets.AddRange(sig.HashedSubPackets);                  allSubPackets.AddRange(sig.UnHashedSubPackets);                  foreach (SignatureSubPacket spacket in allSubPackets)                  {                      if (spacket.Type.Equals(SignatureSubPacketType.CreationTime))                          sig.CreationTime = Converter.UnixTimeStampToDateTime(Converter.ToInt(spacket.Value));                      else if (spacket.Type.Equals(SignatureSubPacketType.KeyExpirationTime))                          sig.KeyExpiration = Converter.UnixTimeStampToDateTime(Converter.ToInt(spacket.Value));                      else if (spacket.Type.Equals(SignatureSubPacketType.ExpirationTime))                          sig.SignatureExpiration = Converter.UnixTimeStampToDateTime(Converter.ToInt(spacket.Value));                      else if (spacket.Type.Equals(SignatureSubPacketType.ExportableCertification))                          sig.IsExportableCertification = (spacket.Value[0] == 1);                      else if (spacket.Type.Equals(SignatureSubPacketType.Revocable))                          sig.IsRevocable = (spacket.Value[0] == 1);                      else if (spacket.Type.Equals(SignatureSubPacketType.TrustSignature))                      {                          sig.Trust.Level = (TrustLevel)spacket.Value[0];                          sig.Trust.Amount = spacket.Value[1];                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.RegularExpression))                          sig.RegularExpression = spacket.Value;                      else if (spacket.Type.Equals(SignatureSubPacketType.RevocationKey))                      {                          if ((spacket.Value[0] & 128) != 128) throw new InvalidPacketSyntaxException("First bit of revocation key class is 0");                          sig.RevocationKey.Class = (RevocationKeyClass)(spacket.Value[0] & 64);                          sig.RevocationKey.HashAlgorithm = (HashAlgorithm)spacket.Value[1];                          Array.Copy(spacket.Value' 2' sig.RevocationKey.FingerPrint' 0' 20);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.NotationData))                      {                          Notation n = new Notation();                          n.IsHumanReadable = ((spacket.Value[0] & 128) == 128);                          byte[] nameLength = new byte[2];                          Array.Copy(spacket.Value' 4' nameLength' 0' 2);                          Array.Copy(spacket.Value' 6' n.Name' 0' Converter.ToInt(nameLength));                          byte[] valueLength = new byte[2];                          Array.Copy(spacket.Value' 6 + Converter.ToInt(nameLength)' valueLength' 0' 2);                          Array.Copy(spacket.Value' 6 + Converter.ToInt(nameLength) + 2' n.Value' 0' Converter.ToInt(valueLength));                          sig.Notations.Add(n);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.PolicyURL))                          sig.PolicyURL = Encoding.ASCII.GetString(spacket.Value'0'spacket.Value.Length);                      else if (spacket.Type.Equals(SignatureSubPacketType.SignerUserID))                          sig.SignerUserID = Encoding.ASCII.GetString(spacket.Value'0'spacket.Value.Length);                      else if (spacket.Type.Equals(SignatureSubPacketType.SignatureTarget))                      {                          sig.TargetSignatureInfo.PublicKeyAlgorithm = (PublicKeyAlgorithm)spacket.Value[0];                          sig.TargetSignatureInfo.HashAlgorithm = (HashAlgorithm)spacket.Value[1];                          Array.Copy(spacket.Value' 2' sig.TargetSignatureInfo.Hash' 0' spacket.Value.Length - 2);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.EmbeddedSignature))                      {                          Packet embedded = new Packet();                          embedded.RawData = spacket.Value;                          sig.EmbeddedSignature = Signature.Parse(embedded);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.IssuerKeyID))                          sig.IssuerKeyID = Converter.ToULong(spacket.Value);                      else if (spacket.Type.Equals(SignatureSubPacketType.PrimaryUserID))                          sig.IsPrimaryUserID = (spacket.Value[0] == 1);                      else if (spacket.Type.Equals(SignatureSubPacketType.KeyFlags))                      {                          if ((spacket.Value[0] & (byte)KeyFlag.Authentication) == (int)KeyFlag.Authentication) sig.KeyFlags.Add(KeyFlag.Authentication);                          if ((spacket.Value[0] & (byte)KeyFlag.CertifiesOtherKeys) == (int)KeyFlag.CertifiesOtherKeys) sig.KeyFlags.Add(KeyFlag.CertifiesOtherKeys);                          if ((spacket.Value[0] & (byte)KeyFlag.EncryptsCommunications) == (int)KeyFlag.EncryptsCommunications) sig.KeyFlags.Add(KeyFlag.EncryptsCommunications);                          if ((spacket.Value[0] & (byte)KeyFlag.EncryptsStorage) == (int)KeyFlag.EncryptsStorage) sig.KeyFlags.Add(KeyFlag.EncryptsStorage);                          if ((spacket.Value[0] & (byte)KeyFlag.GroupKey) == (int)KeyFlag.GroupKey) sig.KeyFlags.Add(KeyFlag.GroupKey);                          if ((spacket.Value[0] & (byte)KeyFlag.SignsData) == (int)KeyFlag.SignsData) sig.KeyFlags.Add(KeyFlag.SignsData);                          if ((spacket.Value[0] & (byte)KeyFlag.SplitKey) == (int)KeyFlag.SplitKey) sig.KeyFlags.Add(KeyFlag.SplitKey);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.Features))                      {                          if ((spacket.Value[0] & (byte)Feature.ModificationDetection) == (int)Feature.ModificationDetection) sig.Features.Add(Feature.ModificationDetection);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.KeyServerPreferences))                      {                          if ((spacket.Value[0] & (byte)KeyServerPreference.NoModify) == (int)KeyServerPreference.NoModify) sig.KeyServerPreferences.Add(KeyServerPreference.NoModify);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.ReasonForRevocation))                      {                          if ((spacket.Value[0] & (byte)Reason.KeyCompromised) == (int)Reason.KeyCompromised) sig.ReasonForRevocation.Reason = Reason.KeyCompromised;                          else if ((spacket.Value[0] & (byte)Reason.KeyRetired) == (int)Reason.KeyRetired) sig.ReasonForRevocation.Reason = Reason.KeyRetired;                          else if ((spacket.Value[0] & (byte)Reason.KeySuperceded) == (int)Reason.KeySuperceded) sig.ReasonForRevocation.Reason = Reason.KeySuperceded;                          else if ((spacket.Value[0] & (byte)Reason.NoneSpecified) == (int)Reason.NoneSpecified) sig.ReasonForRevocation.Reason = Reason.NoneSpecified;                          else if ((spacket.Value[0] & (byte)Reason.UserIDNoLongerValid) == (int)Reason.UserIDNoLongerValid) sig.ReasonForRevocation.Reason = Reason.UserIDNoLongerValid;                          byte[] comment = new byte[spacket.Value.Length - 1];                          Array.Copy(spacket.Value' 1' comment' 0' comment.Length);                          sig.ReasonForRevocation.Comment = Encoding.UTF8.GetString(comment'0'comment.Length);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.PreferredCompressionAlgorithms))                          for (int i = 0; i < spacket.Value.Length; i++) sig.PreferredCompressionAlgorithms.Add((CompressionAlgorithm)spacket.Value[i]);                      else if (spacket.Type.Equals(SignatureSubPacketType.PreferredHashAlgorithms))                          for (int i = 0; i < spacket.Value.Length; i++) sig.PreferredHashAlgorithms.Add((HashAlgorithm)spacket.Value[i]);                      else if (spacket.Type.Equals(SignatureSubPacketType.PreferredSymmetricAlgorithms))                          for (int i = 0; i < spacket.Value.Length; i++) sig.PreferredSymmetricAlgorithms.Add((SymmetricKeyAlgorithm)spacket.Value[i]);                  }              }
Magic Number,ActiveUp.Net.Security.OpenPGP.Packets,Signature,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.Signature.cs,Parse,The following statement contains a magic number: if (sig.VersionNumber.Equals(4))              {                  // Hashed subpackets                  byte[] hashedsublengthbytes = new byte[2];                  ms.Read(hashedsublengthbytes' 0' 2);                  short hashedsublength = Converter.ToShort(hashedsublengthbytes);                  while (ms.Position < 5 + hashedsublength)                      sig.HashedSubPackets.Add(GetNextSignatureSubPacket(ref ms));                    // Unhashed subpackets                  byte[] unhashedsublengthbytes = new byte[2];                  ms.Read(unhashedsublengthbytes' 0' 2);                  short unhashedsublength = Converter.ToShort(unhashedsublengthbytes);                  while (ms.Position < hashedsublength + unhashedsublength)                      sig.UnHashedSubPackets.Add(GetNextSignatureSubPacket(ref ms));                    // Fill properties                  List<SignatureSubPacket> allSubPackets = new List<SignatureSubPacket>();                  allSubPackets.AddRange(sig.HashedSubPackets);                  allSubPackets.AddRange(sig.UnHashedSubPackets);                  foreach (SignatureSubPacket spacket in allSubPackets)                  {                      if (spacket.Type.Equals(SignatureSubPacketType.CreationTime))                          sig.CreationTime = Converter.UnixTimeStampToDateTime(Converter.ToInt(spacket.Value));                      else if (spacket.Type.Equals(SignatureSubPacketType.KeyExpirationTime))                          sig.KeyExpiration = Converter.UnixTimeStampToDateTime(Converter.ToInt(spacket.Value));                      else if (spacket.Type.Equals(SignatureSubPacketType.ExpirationTime))                          sig.SignatureExpiration = Converter.UnixTimeStampToDateTime(Converter.ToInt(spacket.Value));                      else if (spacket.Type.Equals(SignatureSubPacketType.ExportableCertification))                          sig.IsExportableCertification = (spacket.Value[0] == 1);                      else if (spacket.Type.Equals(SignatureSubPacketType.Revocable))                          sig.IsRevocable = (spacket.Value[0] == 1);                      else if (spacket.Type.Equals(SignatureSubPacketType.TrustSignature))                      {                          sig.Trust.Level = (TrustLevel)spacket.Value[0];                          sig.Trust.Amount = spacket.Value[1];                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.RegularExpression))                          sig.RegularExpression = spacket.Value;                      else if (spacket.Type.Equals(SignatureSubPacketType.RevocationKey))                      {                          if ((spacket.Value[0] & 128) != 128) throw new InvalidPacketSyntaxException("First bit of revocation key class is 0");                          sig.RevocationKey.Class = (RevocationKeyClass)(spacket.Value[0] & 64);                          sig.RevocationKey.HashAlgorithm = (HashAlgorithm)spacket.Value[1];                          Array.Copy(spacket.Value' 2' sig.RevocationKey.FingerPrint' 0' 20);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.NotationData))                      {                          Notation n = new Notation();                          n.IsHumanReadable = ((spacket.Value[0] & 128) == 128);                          byte[] nameLength = new byte[2];                          Array.Copy(spacket.Value' 4' nameLength' 0' 2);                          Array.Copy(spacket.Value' 6' n.Name' 0' Converter.ToInt(nameLength));                          byte[] valueLength = new byte[2];                          Array.Copy(spacket.Value' 6 + Converter.ToInt(nameLength)' valueLength' 0' 2);                          Array.Copy(spacket.Value' 6 + Converter.ToInt(nameLength) + 2' n.Value' 0' Converter.ToInt(valueLength));                          sig.Notations.Add(n);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.PolicyURL))                          sig.PolicyURL = Encoding.ASCII.GetString(spacket.Value'0'spacket.Value.Length);                      else if (spacket.Type.Equals(SignatureSubPacketType.SignerUserID))                          sig.SignerUserID = Encoding.ASCII.GetString(spacket.Value'0'spacket.Value.Length);                      else if (spacket.Type.Equals(SignatureSubPacketType.SignatureTarget))                      {                          sig.TargetSignatureInfo.PublicKeyAlgorithm = (PublicKeyAlgorithm)spacket.Value[0];                          sig.TargetSignatureInfo.HashAlgorithm = (HashAlgorithm)spacket.Value[1];                          Array.Copy(spacket.Value' 2' sig.TargetSignatureInfo.Hash' 0' spacket.Value.Length - 2);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.EmbeddedSignature))                      {                          Packet embedded = new Packet();                          embedded.RawData = spacket.Value;                          sig.EmbeddedSignature = Signature.Parse(embedded);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.IssuerKeyID))                          sig.IssuerKeyID = Converter.ToULong(spacket.Value);                      else if (spacket.Type.Equals(SignatureSubPacketType.PrimaryUserID))                          sig.IsPrimaryUserID = (spacket.Value[0] == 1);                      else if (spacket.Type.Equals(SignatureSubPacketType.KeyFlags))                      {                          if ((spacket.Value[0] & (byte)KeyFlag.Authentication) == (int)KeyFlag.Authentication) sig.KeyFlags.Add(KeyFlag.Authentication);                          if ((spacket.Value[0] & (byte)KeyFlag.CertifiesOtherKeys) == (int)KeyFlag.CertifiesOtherKeys) sig.KeyFlags.Add(KeyFlag.CertifiesOtherKeys);                          if ((spacket.Value[0] & (byte)KeyFlag.EncryptsCommunications) == (int)KeyFlag.EncryptsCommunications) sig.KeyFlags.Add(KeyFlag.EncryptsCommunications);                          if ((spacket.Value[0] & (byte)KeyFlag.EncryptsStorage) == (int)KeyFlag.EncryptsStorage) sig.KeyFlags.Add(KeyFlag.EncryptsStorage);                          if ((spacket.Value[0] & (byte)KeyFlag.GroupKey) == (int)KeyFlag.GroupKey) sig.KeyFlags.Add(KeyFlag.GroupKey);                          if ((spacket.Value[0] & (byte)KeyFlag.SignsData) == (int)KeyFlag.SignsData) sig.KeyFlags.Add(KeyFlag.SignsData);                          if ((spacket.Value[0] & (byte)KeyFlag.SplitKey) == (int)KeyFlag.SplitKey) sig.KeyFlags.Add(KeyFlag.SplitKey);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.Features))                      {                          if ((spacket.Value[0] & (byte)Feature.ModificationDetection) == (int)Feature.ModificationDetection) sig.Features.Add(Feature.ModificationDetection);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.KeyServerPreferences))                      {                          if ((spacket.Value[0] & (byte)KeyServerPreference.NoModify) == (int)KeyServerPreference.NoModify) sig.KeyServerPreferences.Add(KeyServerPreference.NoModify);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.ReasonForRevocation))                      {                          if ((spacket.Value[0] & (byte)Reason.KeyCompromised) == (int)Reason.KeyCompromised) sig.ReasonForRevocation.Reason = Reason.KeyCompromised;                          else if ((spacket.Value[0] & (byte)Reason.KeyRetired) == (int)Reason.KeyRetired) sig.ReasonForRevocation.Reason = Reason.KeyRetired;                          else if ((spacket.Value[0] & (byte)Reason.KeySuperceded) == (int)Reason.KeySuperceded) sig.ReasonForRevocation.Reason = Reason.KeySuperceded;                          else if ((spacket.Value[0] & (byte)Reason.NoneSpecified) == (int)Reason.NoneSpecified) sig.ReasonForRevocation.Reason = Reason.NoneSpecified;                          else if ((spacket.Value[0] & (byte)Reason.UserIDNoLongerValid) == (int)Reason.UserIDNoLongerValid) sig.ReasonForRevocation.Reason = Reason.UserIDNoLongerValid;                          byte[] comment = new byte[spacket.Value.Length - 1];                          Array.Copy(spacket.Value' 1' comment' 0' comment.Length);                          sig.ReasonForRevocation.Comment = Encoding.UTF8.GetString(comment'0'comment.Length);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.PreferredCompressionAlgorithms))                          for (int i = 0; i < spacket.Value.Length; i++) sig.PreferredCompressionAlgorithms.Add((CompressionAlgorithm)spacket.Value[i]);                      else if (spacket.Type.Equals(SignatureSubPacketType.PreferredHashAlgorithms))                          for (int i = 0; i < spacket.Value.Length; i++) sig.PreferredHashAlgorithms.Add((HashAlgorithm)spacket.Value[i]);                      else if (spacket.Type.Equals(SignatureSubPacketType.PreferredSymmetricAlgorithms))                          for (int i = 0; i < spacket.Value.Length; i++) sig.PreferredSymmetricAlgorithms.Add((SymmetricKeyAlgorithm)spacket.Value[i]);                  }              }
Magic Number,ActiveUp.Net.Security.OpenPGP.Packets,Signature,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.Signature.cs,Parse,The following statement contains a magic number: if (sig.VersionNumber.Equals(4))              {                  // Hashed subpackets                  byte[] hashedsublengthbytes = new byte[2];                  ms.Read(hashedsublengthbytes' 0' 2);                  short hashedsublength = Converter.ToShort(hashedsublengthbytes);                  while (ms.Position < 5 + hashedsublength)                      sig.HashedSubPackets.Add(GetNextSignatureSubPacket(ref ms));                    // Unhashed subpackets                  byte[] unhashedsublengthbytes = new byte[2];                  ms.Read(unhashedsublengthbytes' 0' 2);                  short unhashedsublength = Converter.ToShort(unhashedsublengthbytes);                  while (ms.Position < hashedsublength + unhashedsublength)                      sig.UnHashedSubPackets.Add(GetNextSignatureSubPacket(ref ms));                    // Fill properties                  List<SignatureSubPacket> allSubPackets = new List<SignatureSubPacket>();                  allSubPackets.AddRange(sig.HashedSubPackets);                  allSubPackets.AddRange(sig.UnHashedSubPackets);                  foreach (SignatureSubPacket spacket in allSubPackets)                  {                      if (spacket.Type.Equals(SignatureSubPacketType.CreationTime))                          sig.CreationTime = Converter.UnixTimeStampToDateTime(Converter.ToInt(spacket.Value));                      else if (spacket.Type.Equals(SignatureSubPacketType.KeyExpirationTime))                          sig.KeyExpiration = Converter.UnixTimeStampToDateTime(Converter.ToInt(spacket.Value));                      else if (spacket.Type.Equals(SignatureSubPacketType.ExpirationTime))                          sig.SignatureExpiration = Converter.UnixTimeStampToDateTime(Converter.ToInt(spacket.Value));                      else if (spacket.Type.Equals(SignatureSubPacketType.ExportableCertification))                          sig.IsExportableCertification = (spacket.Value[0] == 1);                      else if (spacket.Type.Equals(SignatureSubPacketType.Revocable))                          sig.IsRevocable = (spacket.Value[0] == 1);                      else if (spacket.Type.Equals(SignatureSubPacketType.TrustSignature))                      {                          sig.Trust.Level = (TrustLevel)spacket.Value[0];                          sig.Trust.Amount = spacket.Value[1];                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.RegularExpression))                          sig.RegularExpression = spacket.Value;                      else if (spacket.Type.Equals(SignatureSubPacketType.RevocationKey))                      {                          if ((spacket.Value[0] & 128) != 128) throw new InvalidPacketSyntaxException("First bit of revocation key class is 0");                          sig.RevocationKey.Class = (RevocationKeyClass)(spacket.Value[0] & 64);                          sig.RevocationKey.HashAlgorithm = (HashAlgorithm)spacket.Value[1];                          Array.Copy(spacket.Value' 2' sig.RevocationKey.FingerPrint' 0' 20);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.NotationData))                      {                          Notation n = new Notation();                          n.IsHumanReadable = ((spacket.Value[0] & 128) == 128);                          byte[] nameLength = new byte[2];                          Array.Copy(spacket.Value' 4' nameLength' 0' 2);                          Array.Copy(spacket.Value' 6' n.Name' 0' Converter.ToInt(nameLength));                          byte[] valueLength = new byte[2];                          Array.Copy(spacket.Value' 6 + Converter.ToInt(nameLength)' valueLength' 0' 2);                          Array.Copy(spacket.Value' 6 + Converter.ToInt(nameLength) + 2' n.Value' 0' Converter.ToInt(valueLength));                          sig.Notations.Add(n);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.PolicyURL))                          sig.PolicyURL = Encoding.ASCII.GetString(spacket.Value'0'spacket.Value.Length);                      else if (spacket.Type.Equals(SignatureSubPacketType.SignerUserID))                          sig.SignerUserID = Encoding.ASCII.GetString(spacket.Value'0'spacket.Value.Length);                      else if (spacket.Type.Equals(SignatureSubPacketType.SignatureTarget))                      {                          sig.TargetSignatureInfo.PublicKeyAlgorithm = (PublicKeyAlgorithm)spacket.Value[0];                          sig.TargetSignatureInfo.HashAlgorithm = (HashAlgorithm)spacket.Value[1];                          Array.Copy(spacket.Value' 2' sig.TargetSignatureInfo.Hash' 0' spacket.Value.Length - 2);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.EmbeddedSignature))                      {                          Packet embedded = new Packet();                          embedded.RawData = spacket.Value;                          sig.EmbeddedSignature = Signature.Parse(embedded);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.IssuerKeyID))                          sig.IssuerKeyID = Converter.ToULong(spacket.Value);                      else if (spacket.Type.Equals(SignatureSubPacketType.PrimaryUserID))                          sig.IsPrimaryUserID = (spacket.Value[0] == 1);                      else if (spacket.Type.Equals(SignatureSubPacketType.KeyFlags))                      {                          if ((spacket.Value[0] & (byte)KeyFlag.Authentication) == (int)KeyFlag.Authentication) sig.KeyFlags.Add(KeyFlag.Authentication);                          if ((spacket.Value[0] & (byte)KeyFlag.CertifiesOtherKeys) == (int)KeyFlag.CertifiesOtherKeys) sig.KeyFlags.Add(KeyFlag.CertifiesOtherKeys);                          if ((spacket.Value[0] & (byte)KeyFlag.EncryptsCommunications) == (int)KeyFlag.EncryptsCommunications) sig.KeyFlags.Add(KeyFlag.EncryptsCommunications);                          if ((spacket.Value[0] & (byte)KeyFlag.EncryptsStorage) == (int)KeyFlag.EncryptsStorage) sig.KeyFlags.Add(KeyFlag.EncryptsStorage);                          if ((spacket.Value[0] & (byte)KeyFlag.GroupKey) == (int)KeyFlag.GroupKey) sig.KeyFlags.Add(KeyFlag.GroupKey);                          if ((spacket.Value[0] & (byte)KeyFlag.SignsData) == (int)KeyFlag.SignsData) sig.KeyFlags.Add(KeyFlag.SignsData);                          if ((spacket.Value[0] & (byte)KeyFlag.SplitKey) == (int)KeyFlag.SplitKey) sig.KeyFlags.Add(KeyFlag.SplitKey);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.Features))                      {                          if ((spacket.Value[0] & (byte)Feature.ModificationDetection) == (int)Feature.ModificationDetection) sig.Features.Add(Feature.ModificationDetection);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.KeyServerPreferences))                      {                          if ((spacket.Value[0] & (byte)KeyServerPreference.NoModify) == (int)KeyServerPreference.NoModify) sig.KeyServerPreferences.Add(KeyServerPreference.NoModify);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.ReasonForRevocation))                      {                          if ((spacket.Value[0] & (byte)Reason.KeyCompromised) == (int)Reason.KeyCompromised) sig.ReasonForRevocation.Reason = Reason.KeyCompromised;                          else if ((spacket.Value[0] & (byte)Reason.KeyRetired) == (int)Reason.KeyRetired) sig.ReasonForRevocation.Reason = Reason.KeyRetired;                          else if ((spacket.Value[0] & (byte)Reason.KeySuperceded) == (int)Reason.KeySuperceded) sig.ReasonForRevocation.Reason = Reason.KeySuperceded;                          else if ((spacket.Value[0] & (byte)Reason.NoneSpecified) == (int)Reason.NoneSpecified) sig.ReasonForRevocation.Reason = Reason.NoneSpecified;                          else if ((spacket.Value[0] & (byte)Reason.UserIDNoLongerValid) == (int)Reason.UserIDNoLongerValid) sig.ReasonForRevocation.Reason = Reason.UserIDNoLongerValid;                          byte[] comment = new byte[spacket.Value.Length - 1];                          Array.Copy(spacket.Value' 1' comment' 0' comment.Length);                          sig.ReasonForRevocation.Comment = Encoding.UTF8.GetString(comment'0'comment.Length);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.PreferredCompressionAlgorithms))                          for (int i = 0; i < spacket.Value.Length; i++) sig.PreferredCompressionAlgorithms.Add((CompressionAlgorithm)spacket.Value[i]);                      else if (spacket.Type.Equals(SignatureSubPacketType.PreferredHashAlgorithms))                          for (int i = 0; i < spacket.Value.Length; i++) sig.PreferredHashAlgorithms.Add((HashAlgorithm)spacket.Value[i]);                      else if (spacket.Type.Equals(SignatureSubPacketType.PreferredSymmetricAlgorithms))                          for (int i = 0; i < spacket.Value.Length; i++) sig.PreferredSymmetricAlgorithms.Add((SymmetricKeyAlgorithm)spacket.Value[i]);                  }              }
Magic Number,ActiveUp.Net.Security.OpenPGP.Packets,Signature,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.Signature.cs,Parse,The following statement contains a magic number: if (sig.VersionNumber.Equals(4))              {                  // Hashed subpackets                  byte[] hashedsublengthbytes = new byte[2];                  ms.Read(hashedsublengthbytes' 0' 2);                  short hashedsublength = Converter.ToShort(hashedsublengthbytes);                  while (ms.Position < 5 + hashedsublength)                      sig.HashedSubPackets.Add(GetNextSignatureSubPacket(ref ms));                    // Unhashed subpackets                  byte[] unhashedsublengthbytes = new byte[2];                  ms.Read(unhashedsublengthbytes' 0' 2);                  short unhashedsublength = Converter.ToShort(unhashedsublengthbytes);                  while (ms.Position < hashedsublength + unhashedsublength)                      sig.UnHashedSubPackets.Add(GetNextSignatureSubPacket(ref ms));                    // Fill properties                  List<SignatureSubPacket> allSubPackets = new List<SignatureSubPacket>();                  allSubPackets.AddRange(sig.HashedSubPackets);                  allSubPackets.AddRange(sig.UnHashedSubPackets);                  foreach (SignatureSubPacket spacket in allSubPackets)                  {                      if (spacket.Type.Equals(SignatureSubPacketType.CreationTime))                          sig.CreationTime = Converter.UnixTimeStampToDateTime(Converter.ToInt(spacket.Value));                      else if (spacket.Type.Equals(SignatureSubPacketType.KeyExpirationTime))                          sig.KeyExpiration = Converter.UnixTimeStampToDateTime(Converter.ToInt(spacket.Value));                      else if (spacket.Type.Equals(SignatureSubPacketType.ExpirationTime))                          sig.SignatureExpiration = Converter.UnixTimeStampToDateTime(Converter.ToInt(spacket.Value));                      else if (spacket.Type.Equals(SignatureSubPacketType.ExportableCertification))                          sig.IsExportableCertification = (spacket.Value[0] == 1);                      else if (spacket.Type.Equals(SignatureSubPacketType.Revocable))                          sig.IsRevocable = (spacket.Value[0] == 1);                      else if (spacket.Type.Equals(SignatureSubPacketType.TrustSignature))                      {                          sig.Trust.Level = (TrustLevel)spacket.Value[0];                          sig.Trust.Amount = spacket.Value[1];                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.RegularExpression))                          sig.RegularExpression = spacket.Value;                      else if (spacket.Type.Equals(SignatureSubPacketType.RevocationKey))                      {                          if ((spacket.Value[0] & 128) != 128) throw new InvalidPacketSyntaxException("First bit of revocation key class is 0");                          sig.RevocationKey.Class = (RevocationKeyClass)(spacket.Value[0] & 64);                          sig.RevocationKey.HashAlgorithm = (HashAlgorithm)spacket.Value[1];                          Array.Copy(spacket.Value' 2' sig.RevocationKey.FingerPrint' 0' 20);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.NotationData))                      {                          Notation n = new Notation();                          n.IsHumanReadable = ((spacket.Value[0] & 128) == 128);                          byte[] nameLength = new byte[2];                          Array.Copy(spacket.Value' 4' nameLength' 0' 2);                          Array.Copy(spacket.Value' 6' n.Name' 0' Converter.ToInt(nameLength));                          byte[] valueLength = new byte[2];                          Array.Copy(spacket.Value' 6 + Converter.ToInt(nameLength)' valueLength' 0' 2);                          Array.Copy(spacket.Value' 6 + Converter.ToInt(nameLength) + 2' n.Value' 0' Converter.ToInt(valueLength));                          sig.Notations.Add(n);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.PolicyURL))                          sig.PolicyURL = Encoding.ASCII.GetString(spacket.Value'0'spacket.Value.Length);                      else if (spacket.Type.Equals(SignatureSubPacketType.SignerUserID))                          sig.SignerUserID = Encoding.ASCII.GetString(spacket.Value'0'spacket.Value.Length);                      else if (spacket.Type.Equals(SignatureSubPacketType.SignatureTarget))                      {                          sig.TargetSignatureInfo.PublicKeyAlgorithm = (PublicKeyAlgorithm)spacket.Value[0];                          sig.TargetSignatureInfo.HashAlgorithm = (HashAlgorithm)spacket.Value[1];                          Array.Copy(spacket.Value' 2' sig.TargetSignatureInfo.Hash' 0' spacket.Value.Length - 2);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.EmbeddedSignature))                      {                          Packet embedded = new Packet();                          embedded.RawData = spacket.Value;                          sig.EmbeddedSignature = Signature.Parse(embedded);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.IssuerKeyID))                          sig.IssuerKeyID = Converter.ToULong(spacket.Value);                      else if (spacket.Type.Equals(SignatureSubPacketType.PrimaryUserID))                          sig.IsPrimaryUserID = (spacket.Value[0] == 1);                      else if (spacket.Type.Equals(SignatureSubPacketType.KeyFlags))                      {                          if ((spacket.Value[0] & (byte)KeyFlag.Authentication) == (int)KeyFlag.Authentication) sig.KeyFlags.Add(KeyFlag.Authentication);                          if ((spacket.Value[0] & (byte)KeyFlag.CertifiesOtherKeys) == (int)KeyFlag.CertifiesOtherKeys) sig.KeyFlags.Add(KeyFlag.CertifiesOtherKeys);                          if ((spacket.Value[0] & (byte)KeyFlag.EncryptsCommunications) == (int)KeyFlag.EncryptsCommunications) sig.KeyFlags.Add(KeyFlag.EncryptsCommunications);                          if ((spacket.Value[0] & (byte)KeyFlag.EncryptsStorage) == (int)KeyFlag.EncryptsStorage) sig.KeyFlags.Add(KeyFlag.EncryptsStorage);                          if ((spacket.Value[0] & (byte)KeyFlag.GroupKey) == (int)KeyFlag.GroupKey) sig.KeyFlags.Add(KeyFlag.GroupKey);                          if ((spacket.Value[0] & (byte)KeyFlag.SignsData) == (int)KeyFlag.SignsData) sig.KeyFlags.Add(KeyFlag.SignsData);                          if ((spacket.Value[0] & (byte)KeyFlag.SplitKey) == (int)KeyFlag.SplitKey) sig.KeyFlags.Add(KeyFlag.SplitKey);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.Features))                      {                          if ((spacket.Value[0] & (byte)Feature.ModificationDetection) == (int)Feature.ModificationDetection) sig.Features.Add(Feature.ModificationDetection);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.KeyServerPreferences))                      {                          if ((spacket.Value[0] & (byte)KeyServerPreference.NoModify) == (int)KeyServerPreference.NoModify) sig.KeyServerPreferences.Add(KeyServerPreference.NoModify);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.ReasonForRevocation))                      {                          if ((spacket.Value[0] & (byte)Reason.KeyCompromised) == (int)Reason.KeyCompromised) sig.ReasonForRevocation.Reason = Reason.KeyCompromised;                          else if ((spacket.Value[0] & (byte)Reason.KeyRetired) == (int)Reason.KeyRetired) sig.ReasonForRevocation.Reason = Reason.KeyRetired;                          else if ((spacket.Value[0] & (byte)Reason.KeySuperceded) == (int)Reason.KeySuperceded) sig.ReasonForRevocation.Reason = Reason.KeySuperceded;                          else if ((spacket.Value[0] & (byte)Reason.NoneSpecified) == (int)Reason.NoneSpecified) sig.ReasonForRevocation.Reason = Reason.NoneSpecified;                          else if ((spacket.Value[0] & (byte)Reason.UserIDNoLongerValid) == (int)Reason.UserIDNoLongerValid) sig.ReasonForRevocation.Reason = Reason.UserIDNoLongerValid;                          byte[] comment = new byte[spacket.Value.Length - 1];                          Array.Copy(spacket.Value' 1' comment' 0' comment.Length);                          sig.ReasonForRevocation.Comment = Encoding.UTF8.GetString(comment'0'comment.Length);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.PreferredCompressionAlgorithms))                          for (int i = 0; i < spacket.Value.Length; i++) sig.PreferredCompressionAlgorithms.Add((CompressionAlgorithm)spacket.Value[i]);                      else if (spacket.Type.Equals(SignatureSubPacketType.PreferredHashAlgorithms))                          for (int i = 0; i < spacket.Value.Length; i++) sig.PreferredHashAlgorithms.Add((HashAlgorithm)spacket.Value[i]);                      else if (spacket.Type.Equals(SignatureSubPacketType.PreferredSymmetricAlgorithms))                          for (int i = 0; i < spacket.Value.Length; i++) sig.PreferredSymmetricAlgorithms.Add((SymmetricKeyAlgorithm)spacket.Value[i]);                  }              }
Magic Number,ActiveUp.Net.Security.OpenPGP.Packets,Signature,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.Signature.cs,Parse,The following statement contains a magic number: if (sig.VersionNumber.Equals(4))              {                  // Hashed subpackets                  byte[] hashedsublengthbytes = new byte[2];                  ms.Read(hashedsublengthbytes' 0' 2);                  short hashedsublength = Converter.ToShort(hashedsublengthbytes);                  while (ms.Position < 5 + hashedsublength)                      sig.HashedSubPackets.Add(GetNextSignatureSubPacket(ref ms));                    // Unhashed subpackets                  byte[] unhashedsublengthbytes = new byte[2];                  ms.Read(unhashedsublengthbytes' 0' 2);                  short unhashedsublength = Converter.ToShort(unhashedsublengthbytes);                  while (ms.Position < hashedsublength + unhashedsublength)                      sig.UnHashedSubPackets.Add(GetNextSignatureSubPacket(ref ms));                    // Fill properties                  List<SignatureSubPacket> allSubPackets = new List<SignatureSubPacket>();                  allSubPackets.AddRange(sig.HashedSubPackets);                  allSubPackets.AddRange(sig.UnHashedSubPackets);                  foreach (SignatureSubPacket spacket in allSubPackets)                  {                      if (spacket.Type.Equals(SignatureSubPacketType.CreationTime))                          sig.CreationTime = Converter.UnixTimeStampToDateTime(Converter.ToInt(spacket.Value));                      else if (spacket.Type.Equals(SignatureSubPacketType.KeyExpirationTime))                          sig.KeyExpiration = Converter.UnixTimeStampToDateTime(Converter.ToInt(spacket.Value));                      else if (spacket.Type.Equals(SignatureSubPacketType.ExpirationTime))                          sig.SignatureExpiration = Converter.UnixTimeStampToDateTime(Converter.ToInt(spacket.Value));                      else if (spacket.Type.Equals(SignatureSubPacketType.ExportableCertification))                          sig.IsExportableCertification = (spacket.Value[0] == 1);                      else if (spacket.Type.Equals(SignatureSubPacketType.Revocable))                          sig.IsRevocable = (spacket.Value[0] == 1);                      else if (spacket.Type.Equals(SignatureSubPacketType.TrustSignature))                      {                          sig.Trust.Level = (TrustLevel)spacket.Value[0];                          sig.Trust.Amount = spacket.Value[1];                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.RegularExpression))                          sig.RegularExpression = spacket.Value;                      else if (spacket.Type.Equals(SignatureSubPacketType.RevocationKey))                      {                          if ((spacket.Value[0] & 128) != 128) throw new InvalidPacketSyntaxException("First bit of revocation key class is 0");                          sig.RevocationKey.Class = (RevocationKeyClass)(spacket.Value[0] & 64);                          sig.RevocationKey.HashAlgorithm = (HashAlgorithm)spacket.Value[1];                          Array.Copy(spacket.Value' 2' sig.RevocationKey.FingerPrint' 0' 20);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.NotationData))                      {                          Notation n = new Notation();                          n.IsHumanReadable = ((spacket.Value[0] & 128) == 128);                          byte[] nameLength = new byte[2];                          Array.Copy(spacket.Value' 4' nameLength' 0' 2);                          Array.Copy(spacket.Value' 6' n.Name' 0' Converter.ToInt(nameLength));                          byte[] valueLength = new byte[2];                          Array.Copy(spacket.Value' 6 + Converter.ToInt(nameLength)' valueLength' 0' 2);                          Array.Copy(spacket.Value' 6 + Converter.ToInt(nameLength) + 2' n.Value' 0' Converter.ToInt(valueLength));                          sig.Notations.Add(n);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.PolicyURL))                          sig.PolicyURL = Encoding.ASCII.GetString(spacket.Value'0'spacket.Value.Length);                      else if (spacket.Type.Equals(SignatureSubPacketType.SignerUserID))                          sig.SignerUserID = Encoding.ASCII.GetString(spacket.Value'0'spacket.Value.Length);                      else if (spacket.Type.Equals(SignatureSubPacketType.SignatureTarget))                      {                          sig.TargetSignatureInfo.PublicKeyAlgorithm = (PublicKeyAlgorithm)spacket.Value[0];                          sig.TargetSignatureInfo.HashAlgorithm = (HashAlgorithm)spacket.Value[1];                          Array.Copy(spacket.Value' 2' sig.TargetSignatureInfo.Hash' 0' spacket.Value.Length - 2);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.EmbeddedSignature))                      {                          Packet embedded = new Packet();                          embedded.RawData = spacket.Value;                          sig.EmbeddedSignature = Signature.Parse(embedded);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.IssuerKeyID))                          sig.IssuerKeyID = Converter.ToULong(spacket.Value);                      else if (spacket.Type.Equals(SignatureSubPacketType.PrimaryUserID))                          sig.IsPrimaryUserID = (spacket.Value[0] == 1);                      else if (spacket.Type.Equals(SignatureSubPacketType.KeyFlags))                      {                          if ((spacket.Value[0] & (byte)KeyFlag.Authentication) == (int)KeyFlag.Authentication) sig.KeyFlags.Add(KeyFlag.Authentication);                          if ((spacket.Value[0] & (byte)KeyFlag.CertifiesOtherKeys) == (int)KeyFlag.CertifiesOtherKeys) sig.KeyFlags.Add(KeyFlag.CertifiesOtherKeys);                          if ((spacket.Value[0] & (byte)KeyFlag.EncryptsCommunications) == (int)KeyFlag.EncryptsCommunications) sig.KeyFlags.Add(KeyFlag.EncryptsCommunications);                          if ((spacket.Value[0] & (byte)KeyFlag.EncryptsStorage) == (int)KeyFlag.EncryptsStorage) sig.KeyFlags.Add(KeyFlag.EncryptsStorage);                          if ((spacket.Value[0] & (byte)KeyFlag.GroupKey) == (int)KeyFlag.GroupKey) sig.KeyFlags.Add(KeyFlag.GroupKey);                          if ((spacket.Value[0] & (byte)KeyFlag.SignsData) == (int)KeyFlag.SignsData) sig.KeyFlags.Add(KeyFlag.SignsData);                          if ((spacket.Value[0] & (byte)KeyFlag.SplitKey) == (int)KeyFlag.SplitKey) sig.KeyFlags.Add(KeyFlag.SplitKey);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.Features))                      {                          if ((spacket.Value[0] & (byte)Feature.ModificationDetection) == (int)Feature.ModificationDetection) sig.Features.Add(Feature.ModificationDetection);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.KeyServerPreferences))                      {                          if ((spacket.Value[0] & (byte)KeyServerPreference.NoModify) == (int)KeyServerPreference.NoModify) sig.KeyServerPreferences.Add(KeyServerPreference.NoModify);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.ReasonForRevocation))                      {                          if ((spacket.Value[0] & (byte)Reason.KeyCompromised) == (int)Reason.KeyCompromised) sig.ReasonForRevocation.Reason = Reason.KeyCompromised;                          else if ((spacket.Value[0] & (byte)Reason.KeyRetired) == (int)Reason.KeyRetired) sig.ReasonForRevocation.Reason = Reason.KeyRetired;                          else if ((spacket.Value[0] & (byte)Reason.KeySuperceded) == (int)Reason.KeySuperceded) sig.ReasonForRevocation.Reason = Reason.KeySuperceded;                          else if ((spacket.Value[0] & (byte)Reason.NoneSpecified) == (int)Reason.NoneSpecified) sig.ReasonForRevocation.Reason = Reason.NoneSpecified;                          else if ((spacket.Value[0] & (byte)Reason.UserIDNoLongerValid) == (int)Reason.UserIDNoLongerValid) sig.ReasonForRevocation.Reason = Reason.UserIDNoLongerValid;                          byte[] comment = new byte[spacket.Value.Length - 1];                          Array.Copy(spacket.Value' 1' comment' 0' comment.Length);                          sig.ReasonForRevocation.Comment = Encoding.UTF8.GetString(comment'0'comment.Length);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.PreferredCompressionAlgorithms))                          for (int i = 0; i < spacket.Value.Length; i++) sig.PreferredCompressionAlgorithms.Add((CompressionAlgorithm)spacket.Value[i]);                      else if (spacket.Type.Equals(SignatureSubPacketType.PreferredHashAlgorithms))                          for (int i = 0; i < spacket.Value.Length; i++) sig.PreferredHashAlgorithms.Add((HashAlgorithm)spacket.Value[i]);                      else if (spacket.Type.Equals(SignatureSubPacketType.PreferredSymmetricAlgorithms))                          for (int i = 0; i < spacket.Value.Length; i++) sig.PreferredSymmetricAlgorithms.Add((SymmetricKeyAlgorithm)spacket.Value[i]);                  }              }
Magic Number,ActiveUp.Net.Security.OpenPGP.Packets,Signature,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.Signature.cs,Parse,The following statement contains a magic number: if (sig.VersionNumber.Equals(4))              {                  // Hashed subpackets                  byte[] hashedsublengthbytes = new byte[2];                  ms.Read(hashedsublengthbytes' 0' 2);                  short hashedsublength = Converter.ToShort(hashedsublengthbytes);                  while (ms.Position < 5 + hashedsublength)                      sig.HashedSubPackets.Add(GetNextSignatureSubPacket(ref ms));                    // Unhashed subpackets                  byte[] unhashedsublengthbytes = new byte[2];                  ms.Read(unhashedsublengthbytes' 0' 2);                  short unhashedsublength = Converter.ToShort(unhashedsublengthbytes);                  while (ms.Position < hashedsublength + unhashedsublength)                      sig.UnHashedSubPackets.Add(GetNextSignatureSubPacket(ref ms));                    // Fill properties                  List<SignatureSubPacket> allSubPackets = new List<SignatureSubPacket>();                  allSubPackets.AddRange(sig.HashedSubPackets);                  allSubPackets.AddRange(sig.UnHashedSubPackets);                  foreach (SignatureSubPacket spacket in allSubPackets)                  {                      if (spacket.Type.Equals(SignatureSubPacketType.CreationTime))                          sig.CreationTime = Converter.UnixTimeStampToDateTime(Converter.ToInt(spacket.Value));                      else if (spacket.Type.Equals(SignatureSubPacketType.KeyExpirationTime))                          sig.KeyExpiration = Converter.UnixTimeStampToDateTime(Converter.ToInt(spacket.Value));                      else if (spacket.Type.Equals(SignatureSubPacketType.ExpirationTime))                          sig.SignatureExpiration = Converter.UnixTimeStampToDateTime(Converter.ToInt(spacket.Value));                      else if (spacket.Type.Equals(SignatureSubPacketType.ExportableCertification))                          sig.IsExportableCertification = (spacket.Value[0] == 1);                      else if (spacket.Type.Equals(SignatureSubPacketType.Revocable))                          sig.IsRevocable = (spacket.Value[0] == 1);                      else if (spacket.Type.Equals(SignatureSubPacketType.TrustSignature))                      {                          sig.Trust.Level = (TrustLevel)spacket.Value[0];                          sig.Trust.Amount = spacket.Value[1];                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.RegularExpression))                          sig.RegularExpression = spacket.Value;                      else if (spacket.Type.Equals(SignatureSubPacketType.RevocationKey))                      {                          if ((spacket.Value[0] & 128) != 128) throw new InvalidPacketSyntaxException("First bit of revocation key class is 0");                          sig.RevocationKey.Class = (RevocationKeyClass)(spacket.Value[0] & 64);                          sig.RevocationKey.HashAlgorithm = (HashAlgorithm)spacket.Value[1];                          Array.Copy(spacket.Value' 2' sig.RevocationKey.FingerPrint' 0' 20);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.NotationData))                      {                          Notation n = new Notation();                          n.IsHumanReadable = ((spacket.Value[0] & 128) == 128);                          byte[] nameLength = new byte[2];                          Array.Copy(spacket.Value' 4' nameLength' 0' 2);                          Array.Copy(spacket.Value' 6' n.Name' 0' Converter.ToInt(nameLength));                          byte[] valueLength = new byte[2];                          Array.Copy(spacket.Value' 6 + Converter.ToInt(nameLength)' valueLength' 0' 2);                          Array.Copy(spacket.Value' 6 + Converter.ToInt(nameLength) + 2' n.Value' 0' Converter.ToInt(valueLength));                          sig.Notations.Add(n);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.PolicyURL))                          sig.PolicyURL = Encoding.ASCII.GetString(spacket.Value'0'spacket.Value.Length);                      else if (spacket.Type.Equals(SignatureSubPacketType.SignerUserID))                          sig.SignerUserID = Encoding.ASCII.GetString(spacket.Value'0'spacket.Value.Length);                      else if (spacket.Type.Equals(SignatureSubPacketType.SignatureTarget))                      {                          sig.TargetSignatureInfo.PublicKeyAlgorithm = (PublicKeyAlgorithm)spacket.Value[0];                          sig.TargetSignatureInfo.HashAlgorithm = (HashAlgorithm)spacket.Value[1];                          Array.Copy(spacket.Value' 2' sig.TargetSignatureInfo.Hash' 0' spacket.Value.Length - 2);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.EmbeddedSignature))                      {                          Packet embedded = new Packet();                          embedded.RawData = spacket.Value;                          sig.EmbeddedSignature = Signature.Parse(embedded);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.IssuerKeyID))                          sig.IssuerKeyID = Converter.ToULong(spacket.Value);                      else if (spacket.Type.Equals(SignatureSubPacketType.PrimaryUserID))                          sig.IsPrimaryUserID = (spacket.Value[0] == 1);                      else if (spacket.Type.Equals(SignatureSubPacketType.KeyFlags))                      {                          if ((spacket.Value[0] & (byte)KeyFlag.Authentication) == (int)KeyFlag.Authentication) sig.KeyFlags.Add(KeyFlag.Authentication);                          if ((spacket.Value[0] & (byte)KeyFlag.CertifiesOtherKeys) == (int)KeyFlag.CertifiesOtherKeys) sig.KeyFlags.Add(KeyFlag.CertifiesOtherKeys);                          if ((spacket.Value[0] & (byte)KeyFlag.EncryptsCommunications) == (int)KeyFlag.EncryptsCommunications) sig.KeyFlags.Add(KeyFlag.EncryptsCommunications);                          if ((spacket.Value[0] & (byte)KeyFlag.EncryptsStorage) == (int)KeyFlag.EncryptsStorage) sig.KeyFlags.Add(KeyFlag.EncryptsStorage);                          if ((spacket.Value[0] & (byte)KeyFlag.GroupKey) == (int)KeyFlag.GroupKey) sig.KeyFlags.Add(KeyFlag.GroupKey);                          if ((spacket.Value[0] & (byte)KeyFlag.SignsData) == (int)KeyFlag.SignsData) sig.KeyFlags.Add(KeyFlag.SignsData);                          if ((spacket.Value[0] & (byte)KeyFlag.SplitKey) == (int)KeyFlag.SplitKey) sig.KeyFlags.Add(KeyFlag.SplitKey);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.Features))                      {                          if ((spacket.Value[0] & (byte)Feature.ModificationDetection) == (int)Feature.ModificationDetection) sig.Features.Add(Feature.ModificationDetection);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.KeyServerPreferences))                      {                          if ((spacket.Value[0] & (byte)KeyServerPreference.NoModify) == (int)KeyServerPreference.NoModify) sig.KeyServerPreferences.Add(KeyServerPreference.NoModify);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.ReasonForRevocation))                      {                          if ((spacket.Value[0] & (byte)Reason.KeyCompromised) == (int)Reason.KeyCompromised) sig.ReasonForRevocation.Reason = Reason.KeyCompromised;                          else if ((spacket.Value[0] & (byte)Reason.KeyRetired) == (int)Reason.KeyRetired) sig.ReasonForRevocation.Reason = Reason.KeyRetired;                          else if ((spacket.Value[0] & (byte)Reason.KeySuperceded) == (int)Reason.KeySuperceded) sig.ReasonForRevocation.Reason = Reason.KeySuperceded;                          else if ((spacket.Value[0] & (byte)Reason.NoneSpecified) == (int)Reason.NoneSpecified) sig.ReasonForRevocation.Reason = Reason.NoneSpecified;                          else if ((spacket.Value[0] & (byte)Reason.UserIDNoLongerValid) == (int)Reason.UserIDNoLongerValid) sig.ReasonForRevocation.Reason = Reason.UserIDNoLongerValid;                          byte[] comment = new byte[spacket.Value.Length - 1];                          Array.Copy(spacket.Value' 1' comment' 0' comment.Length);                          sig.ReasonForRevocation.Comment = Encoding.UTF8.GetString(comment'0'comment.Length);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.PreferredCompressionAlgorithms))                          for (int i = 0; i < spacket.Value.Length; i++) sig.PreferredCompressionAlgorithms.Add((CompressionAlgorithm)spacket.Value[i]);                      else if (spacket.Type.Equals(SignatureSubPacketType.PreferredHashAlgorithms))                          for (int i = 0; i < spacket.Value.Length; i++) sig.PreferredHashAlgorithms.Add((HashAlgorithm)spacket.Value[i]);                      else if (spacket.Type.Equals(SignatureSubPacketType.PreferredSymmetricAlgorithms))                          for (int i = 0; i < spacket.Value.Length; i++) sig.PreferredSymmetricAlgorithms.Add((SymmetricKeyAlgorithm)spacket.Value[i]);                  }              }
Magic Number,ActiveUp.Net.Security.OpenPGP.Packets,Signature,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.Signature.cs,Parse,The following statement contains a magic number: if (sig.VersionNumber.Equals(4))              {                  // Hashed subpackets                  byte[] hashedsublengthbytes = new byte[2];                  ms.Read(hashedsublengthbytes' 0' 2);                  short hashedsublength = Converter.ToShort(hashedsublengthbytes);                  while (ms.Position < 5 + hashedsublength)                      sig.HashedSubPackets.Add(GetNextSignatureSubPacket(ref ms));                    // Unhashed subpackets                  byte[] unhashedsublengthbytes = new byte[2];                  ms.Read(unhashedsublengthbytes' 0' 2);                  short unhashedsublength = Converter.ToShort(unhashedsublengthbytes);                  while (ms.Position < hashedsublength + unhashedsublength)                      sig.UnHashedSubPackets.Add(GetNextSignatureSubPacket(ref ms));                    // Fill properties                  List<SignatureSubPacket> allSubPackets = new List<SignatureSubPacket>();                  allSubPackets.AddRange(sig.HashedSubPackets);                  allSubPackets.AddRange(sig.UnHashedSubPackets);                  foreach (SignatureSubPacket spacket in allSubPackets)                  {                      if (spacket.Type.Equals(SignatureSubPacketType.CreationTime))                          sig.CreationTime = Converter.UnixTimeStampToDateTime(Converter.ToInt(spacket.Value));                      else if (spacket.Type.Equals(SignatureSubPacketType.KeyExpirationTime))                          sig.KeyExpiration = Converter.UnixTimeStampToDateTime(Converter.ToInt(spacket.Value));                      else if (spacket.Type.Equals(SignatureSubPacketType.ExpirationTime))                          sig.SignatureExpiration = Converter.UnixTimeStampToDateTime(Converter.ToInt(spacket.Value));                      else if (spacket.Type.Equals(SignatureSubPacketType.ExportableCertification))                          sig.IsExportableCertification = (spacket.Value[0] == 1);                      else if (spacket.Type.Equals(SignatureSubPacketType.Revocable))                          sig.IsRevocable = (spacket.Value[0] == 1);                      else if (spacket.Type.Equals(SignatureSubPacketType.TrustSignature))                      {                          sig.Trust.Level = (TrustLevel)spacket.Value[0];                          sig.Trust.Amount = spacket.Value[1];                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.RegularExpression))                          sig.RegularExpression = spacket.Value;                      else if (spacket.Type.Equals(SignatureSubPacketType.RevocationKey))                      {                          if ((spacket.Value[0] & 128) != 128) throw new InvalidPacketSyntaxException("First bit of revocation key class is 0");                          sig.RevocationKey.Class = (RevocationKeyClass)(spacket.Value[0] & 64);                          sig.RevocationKey.HashAlgorithm = (HashAlgorithm)spacket.Value[1];                          Array.Copy(spacket.Value' 2' sig.RevocationKey.FingerPrint' 0' 20);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.NotationData))                      {                          Notation n = new Notation();                          n.IsHumanReadable = ((spacket.Value[0] & 128) == 128);                          byte[] nameLength = new byte[2];                          Array.Copy(spacket.Value' 4' nameLength' 0' 2);                          Array.Copy(spacket.Value' 6' n.Name' 0' Converter.ToInt(nameLength));                          byte[] valueLength = new byte[2];                          Array.Copy(spacket.Value' 6 + Converter.ToInt(nameLength)' valueLength' 0' 2);                          Array.Copy(spacket.Value' 6 + Converter.ToInt(nameLength) + 2' n.Value' 0' Converter.ToInt(valueLength));                          sig.Notations.Add(n);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.PolicyURL))                          sig.PolicyURL = Encoding.ASCII.GetString(spacket.Value'0'spacket.Value.Length);                      else if (spacket.Type.Equals(SignatureSubPacketType.SignerUserID))                          sig.SignerUserID = Encoding.ASCII.GetString(spacket.Value'0'spacket.Value.Length);                      else if (spacket.Type.Equals(SignatureSubPacketType.SignatureTarget))                      {                          sig.TargetSignatureInfo.PublicKeyAlgorithm = (PublicKeyAlgorithm)spacket.Value[0];                          sig.TargetSignatureInfo.HashAlgorithm = (HashAlgorithm)spacket.Value[1];                          Array.Copy(spacket.Value' 2' sig.TargetSignatureInfo.Hash' 0' spacket.Value.Length - 2);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.EmbeddedSignature))                      {                          Packet embedded = new Packet();                          embedded.RawData = spacket.Value;                          sig.EmbeddedSignature = Signature.Parse(embedded);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.IssuerKeyID))                          sig.IssuerKeyID = Converter.ToULong(spacket.Value);                      else if (spacket.Type.Equals(SignatureSubPacketType.PrimaryUserID))                          sig.IsPrimaryUserID = (spacket.Value[0] == 1);                      else if (spacket.Type.Equals(SignatureSubPacketType.KeyFlags))                      {                          if ((spacket.Value[0] & (byte)KeyFlag.Authentication) == (int)KeyFlag.Authentication) sig.KeyFlags.Add(KeyFlag.Authentication);                          if ((spacket.Value[0] & (byte)KeyFlag.CertifiesOtherKeys) == (int)KeyFlag.CertifiesOtherKeys) sig.KeyFlags.Add(KeyFlag.CertifiesOtherKeys);                          if ((spacket.Value[0] & (byte)KeyFlag.EncryptsCommunications) == (int)KeyFlag.EncryptsCommunications) sig.KeyFlags.Add(KeyFlag.EncryptsCommunications);                          if ((spacket.Value[0] & (byte)KeyFlag.EncryptsStorage) == (int)KeyFlag.EncryptsStorage) sig.KeyFlags.Add(KeyFlag.EncryptsStorage);                          if ((spacket.Value[0] & (byte)KeyFlag.GroupKey) == (int)KeyFlag.GroupKey) sig.KeyFlags.Add(KeyFlag.GroupKey);                          if ((spacket.Value[0] & (byte)KeyFlag.SignsData) == (int)KeyFlag.SignsData) sig.KeyFlags.Add(KeyFlag.SignsData);                          if ((spacket.Value[0] & (byte)KeyFlag.SplitKey) == (int)KeyFlag.SplitKey) sig.KeyFlags.Add(KeyFlag.SplitKey);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.Features))                      {                          if ((spacket.Value[0] & (byte)Feature.ModificationDetection) == (int)Feature.ModificationDetection) sig.Features.Add(Feature.ModificationDetection);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.KeyServerPreferences))                      {                          if ((spacket.Value[0] & (byte)KeyServerPreference.NoModify) == (int)KeyServerPreference.NoModify) sig.KeyServerPreferences.Add(KeyServerPreference.NoModify);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.ReasonForRevocation))                      {                          if ((spacket.Value[0] & (byte)Reason.KeyCompromised) == (int)Reason.KeyCompromised) sig.ReasonForRevocation.Reason = Reason.KeyCompromised;                          else if ((spacket.Value[0] & (byte)Reason.KeyRetired) == (int)Reason.KeyRetired) sig.ReasonForRevocation.Reason = Reason.KeyRetired;                          else if ((spacket.Value[0] & (byte)Reason.KeySuperceded) == (int)Reason.KeySuperceded) sig.ReasonForRevocation.Reason = Reason.KeySuperceded;                          else if ((spacket.Value[0] & (byte)Reason.NoneSpecified) == (int)Reason.NoneSpecified) sig.ReasonForRevocation.Reason = Reason.NoneSpecified;                          else if ((spacket.Value[0] & (byte)Reason.UserIDNoLongerValid) == (int)Reason.UserIDNoLongerValid) sig.ReasonForRevocation.Reason = Reason.UserIDNoLongerValid;                          byte[] comment = new byte[spacket.Value.Length - 1];                          Array.Copy(spacket.Value' 1' comment' 0' comment.Length);                          sig.ReasonForRevocation.Comment = Encoding.UTF8.GetString(comment'0'comment.Length);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.PreferredCompressionAlgorithms))                          for (int i = 0; i < spacket.Value.Length; i++) sig.PreferredCompressionAlgorithms.Add((CompressionAlgorithm)spacket.Value[i]);                      else if (spacket.Type.Equals(SignatureSubPacketType.PreferredHashAlgorithms))                          for (int i = 0; i < spacket.Value.Length; i++) sig.PreferredHashAlgorithms.Add((HashAlgorithm)spacket.Value[i]);                      else if (spacket.Type.Equals(SignatureSubPacketType.PreferredSymmetricAlgorithms))                          for (int i = 0; i < spacket.Value.Length; i++) sig.PreferredSymmetricAlgorithms.Add((SymmetricKeyAlgorithm)spacket.Value[i]);                  }              }
Magic Number,ActiveUp.Net.Security.OpenPGP.Packets,Signature,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.Signature.cs,Parse,The following statement contains a magic number: if (sig.VersionNumber.Equals(4))              {                  // Hashed subpackets                  byte[] hashedsublengthbytes = new byte[2];                  ms.Read(hashedsublengthbytes' 0' 2);                  short hashedsublength = Converter.ToShort(hashedsublengthbytes);                  while (ms.Position < 5 + hashedsublength)                      sig.HashedSubPackets.Add(GetNextSignatureSubPacket(ref ms));                    // Unhashed subpackets                  byte[] unhashedsublengthbytes = new byte[2];                  ms.Read(unhashedsublengthbytes' 0' 2);                  short unhashedsublength = Converter.ToShort(unhashedsublengthbytes);                  while (ms.Position < hashedsublength + unhashedsublength)                      sig.UnHashedSubPackets.Add(GetNextSignatureSubPacket(ref ms));                    // Fill properties                  List<SignatureSubPacket> allSubPackets = new List<SignatureSubPacket>();                  allSubPackets.AddRange(sig.HashedSubPackets);                  allSubPackets.AddRange(sig.UnHashedSubPackets);                  foreach (SignatureSubPacket spacket in allSubPackets)                  {                      if (spacket.Type.Equals(SignatureSubPacketType.CreationTime))                          sig.CreationTime = Converter.UnixTimeStampToDateTime(Converter.ToInt(spacket.Value));                      else if (spacket.Type.Equals(SignatureSubPacketType.KeyExpirationTime))                          sig.KeyExpiration = Converter.UnixTimeStampToDateTime(Converter.ToInt(spacket.Value));                      else if (spacket.Type.Equals(SignatureSubPacketType.ExpirationTime))                          sig.SignatureExpiration = Converter.UnixTimeStampToDateTime(Converter.ToInt(spacket.Value));                      else if (spacket.Type.Equals(SignatureSubPacketType.ExportableCertification))                          sig.IsExportableCertification = (spacket.Value[0] == 1);                      else if (spacket.Type.Equals(SignatureSubPacketType.Revocable))                          sig.IsRevocable = (spacket.Value[0] == 1);                      else if (spacket.Type.Equals(SignatureSubPacketType.TrustSignature))                      {                          sig.Trust.Level = (TrustLevel)spacket.Value[0];                          sig.Trust.Amount = spacket.Value[1];                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.RegularExpression))                          sig.RegularExpression = spacket.Value;                      else if (spacket.Type.Equals(SignatureSubPacketType.RevocationKey))                      {                          if ((spacket.Value[0] & 128) != 128) throw new InvalidPacketSyntaxException("First bit of revocation key class is 0");                          sig.RevocationKey.Class = (RevocationKeyClass)(spacket.Value[0] & 64);                          sig.RevocationKey.HashAlgorithm = (HashAlgorithm)spacket.Value[1];                          Array.Copy(spacket.Value' 2' sig.RevocationKey.FingerPrint' 0' 20);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.NotationData))                      {                          Notation n = new Notation();                          n.IsHumanReadable = ((spacket.Value[0] & 128) == 128);                          byte[] nameLength = new byte[2];                          Array.Copy(spacket.Value' 4' nameLength' 0' 2);                          Array.Copy(spacket.Value' 6' n.Name' 0' Converter.ToInt(nameLength));                          byte[] valueLength = new byte[2];                          Array.Copy(spacket.Value' 6 + Converter.ToInt(nameLength)' valueLength' 0' 2);                          Array.Copy(spacket.Value' 6 + Converter.ToInt(nameLength) + 2' n.Value' 0' Converter.ToInt(valueLength));                          sig.Notations.Add(n);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.PolicyURL))                          sig.PolicyURL = Encoding.ASCII.GetString(spacket.Value'0'spacket.Value.Length);                      else if (spacket.Type.Equals(SignatureSubPacketType.SignerUserID))                          sig.SignerUserID = Encoding.ASCII.GetString(spacket.Value'0'spacket.Value.Length);                      else if (spacket.Type.Equals(SignatureSubPacketType.SignatureTarget))                      {                          sig.TargetSignatureInfo.PublicKeyAlgorithm = (PublicKeyAlgorithm)spacket.Value[0];                          sig.TargetSignatureInfo.HashAlgorithm = (HashAlgorithm)spacket.Value[1];                          Array.Copy(spacket.Value' 2' sig.TargetSignatureInfo.Hash' 0' spacket.Value.Length - 2);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.EmbeddedSignature))                      {                          Packet embedded = new Packet();                          embedded.RawData = spacket.Value;                          sig.EmbeddedSignature = Signature.Parse(embedded);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.IssuerKeyID))                          sig.IssuerKeyID = Converter.ToULong(spacket.Value);                      else if (spacket.Type.Equals(SignatureSubPacketType.PrimaryUserID))                          sig.IsPrimaryUserID = (spacket.Value[0] == 1);                      else if (spacket.Type.Equals(SignatureSubPacketType.KeyFlags))                      {                          if ((spacket.Value[0] & (byte)KeyFlag.Authentication) == (int)KeyFlag.Authentication) sig.KeyFlags.Add(KeyFlag.Authentication);                          if ((spacket.Value[0] & (byte)KeyFlag.CertifiesOtherKeys) == (int)KeyFlag.CertifiesOtherKeys) sig.KeyFlags.Add(KeyFlag.CertifiesOtherKeys);                          if ((spacket.Value[0] & (byte)KeyFlag.EncryptsCommunications) == (int)KeyFlag.EncryptsCommunications) sig.KeyFlags.Add(KeyFlag.EncryptsCommunications);                          if ((spacket.Value[0] & (byte)KeyFlag.EncryptsStorage) == (int)KeyFlag.EncryptsStorage) sig.KeyFlags.Add(KeyFlag.EncryptsStorage);                          if ((spacket.Value[0] & (byte)KeyFlag.GroupKey) == (int)KeyFlag.GroupKey) sig.KeyFlags.Add(KeyFlag.GroupKey);                          if ((spacket.Value[0] & (byte)KeyFlag.SignsData) == (int)KeyFlag.SignsData) sig.KeyFlags.Add(KeyFlag.SignsData);                          if ((spacket.Value[0] & (byte)KeyFlag.SplitKey) == (int)KeyFlag.SplitKey) sig.KeyFlags.Add(KeyFlag.SplitKey);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.Features))                      {                          if ((spacket.Value[0] & (byte)Feature.ModificationDetection) == (int)Feature.ModificationDetection) sig.Features.Add(Feature.ModificationDetection);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.KeyServerPreferences))                      {                          if ((spacket.Value[0] & (byte)KeyServerPreference.NoModify) == (int)KeyServerPreference.NoModify) sig.KeyServerPreferences.Add(KeyServerPreference.NoModify);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.ReasonForRevocation))                      {                          if ((spacket.Value[0] & (byte)Reason.KeyCompromised) == (int)Reason.KeyCompromised) sig.ReasonForRevocation.Reason = Reason.KeyCompromised;                          else if ((spacket.Value[0] & (byte)Reason.KeyRetired) == (int)Reason.KeyRetired) sig.ReasonForRevocation.Reason = Reason.KeyRetired;                          else if ((spacket.Value[0] & (byte)Reason.KeySuperceded) == (int)Reason.KeySuperceded) sig.ReasonForRevocation.Reason = Reason.KeySuperceded;                          else if ((spacket.Value[0] & (byte)Reason.NoneSpecified) == (int)Reason.NoneSpecified) sig.ReasonForRevocation.Reason = Reason.NoneSpecified;                          else if ((spacket.Value[0] & (byte)Reason.UserIDNoLongerValid) == (int)Reason.UserIDNoLongerValid) sig.ReasonForRevocation.Reason = Reason.UserIDNoLongerValid;                          byte[] comment = new byte[spacket.Value.Length - 1];                          Array.Copy(spacket.Value' 1' comment' 0' comment.Length);                          sig.ReasonForRevocation.Comment = Encoding.UTF8.GetString(comment'0'comment.Length);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.PreferredCompressionAlgorithms))                          for (int i = 0; i < spacket.Value.Length; i++) sig.PreferredCompressionAlgorithms.Add((CompressionAlgorithm)spacket.Value[i]);                      else if (spacket.Type.Equals(SignatureSubPacketType.PreferredHashAlgorithms))                          for (int i = 0; i < spacket.Value.Length; i++) sig.PreferredHashAlgorithms.Add((HashAlgorithm)spacket.Value[i]);                      else if (spacket.Type.Equals(SignatureSubPacketType.PreferredSymmetricAlgorithms))                          for (int i = 0; i < spacket.Value.Length; i++) sig.PreferredSymmetricAlgorithms.Add((SymmetricKeyAlgorithm)spacket.Value[i]);                  }              }
Magic Number,ActiveUp.Net.Security.OpenPGP.Packets,Signature,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.Signature.cs,Parse,The following statement contains a magic number: if (sig.VersionNumber.Equals(4))              {                  // Hashed subpackets                  byte[] hashedsublengthbytes = new byte[2];                  ms.Read(hashedsublengthbytes' 0' 2);                  short hashedsublength = Converter.ToShort(hashedsublengthbytes);                  while (ms.Position < 5 + hashedsublength)                      sig.HashedSubPackets.Add(GetNextSignatureSubPacket(ref ms));                    // Unhashed subpackets                  byte[] unhashedsublengthbytes = new byte[2];                  ms.Read(unhashedsublengthbytes' 0' 2);                  short unhashedsublength = Converter.ToShort(unhashedsublengthbytes);                  while (ms.Position < hashedsublength + unhashedsublength)                      sig.UnHashedSubPackets.Add(GetNextSignatureSubPacket(ref ms));                    // Fill properties                  List<SignatureSubPacket> allSubPackets = new List<SignatureSubPacket>();                  allSubPackets.AddRange(sig.HashedSubPackets);                  allSubPackets.AddRange(sig.UnHashedSubPackets);                  foreach (SignatureSubPacket spacket in allSubPackets)                  {                      if (spacket.Type.Equals(SignatureSubPacketType.CreationTime))                          sig.CreationTime = Converter.UnixTimeStampToDateTime(Converter.ToInt(spacket.Value));                      else if (spacket.Type.Equals(SignatureSubPacketType.KeyExpirationTime))                          sig.KeyExpiration = Converter.UnixTimeStampToDateTime(Converter.ToInt(spacket.Value));                      else if (spacket.Type.Equals(SignatureSubPacketType.ExpirationTime))                          sig.SignatureExpiration = Converter.UnixTimeStampToDateTime(Converter.ToInt(spacket.Value));                      else if (spacket.Type.Equals(SignatureSubPacketType.ExportableCertification))                          sig.IsExportableCertification = (spacket.Value[0] == 1);                      else if (spacket.Type.Equals(SignatureSubPacketType.Revocable))                          sig.IsRevocable = (spacket.Value[0] == 1);                      else if (spacket.Type.Equals(SignatureSubPacketType.TrustSignature))                      {                          sig.Trust.Level = (TrustLevel)spacket.Value[0];                          sig.Trust.Amount = spacket.Value[1];                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.RegularExpression))                          sig.RegularExpression = spacket.Value;                      else if (spacket.Type.Equals(SignatureSubPacketType.RevocationKey))                      {                          if ((spacket.Value[0] & 128) != 128) throw new InvalidPacketSyntaxException("First bit of revocation key class is 0");                          sig.RevocationKey.Class = (RevocationKeyClass)(spacket.Value[0] & 64);                          sig.RevocationKey.HashAlgorithm = (HashAlgorithm)spacket.Value[1];                          Array.Copy(spacket.Value' 2' sig.RevocationKey.FingerPrint' 0' 20);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.NotationData))                      {                          Notation n = new Notation();                          n.IsHumanReadable = ((spacket.Value[0] & 128) == 128);                          byte[] nameLength = new byte[2];                          Array.Copy(spacket.Value' 4' nameLength' 0' 2);                          Array.Copy(spacket.Value' 6' n.Name' 0' Converter.ToInt(nameLength));                          byte[] valueLength = new byte[2];                          Array.Copy(spacket.Value' 6 + Converter.ToInt(nameLength)' valueLength' 0' 2);                          Array.Copy(spacket.Value' 6 + Converter.ToInt(nameLength) + 2' n.Value' 0' Converter.ToInt(valueLength));                          sig.Notations.Add(n);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.PolicyURL))                          sig.PolicyURL = Encoding.ASCII.GetString(spacket.Value'0'spacket.Value.Length);                      else if (spacket.Type.Equals(SignatureSubPacketType.SignerUserID))                          sig.SignerUserID = Encoding.ASCII.GetString(spacket.Value'0'spacket.Value.Length);                      else if (spacket.Type.Equals(SignatureSubPacketType.SignatureTarget))                      {                          sig.TargetSignatureInfo.PublicKeyAlgorithm = (PublicKeyAlgorithm)spacket.Value[0];                          sig.TargetSignatureInfo.HashAlgorithm = (HashAlgorithm)spacket.Value[1];                          Array.Copy(spacket.Value' 2' sig.TargetSignatureInfo.Hash' 0' spacket.Value.Length - 2);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.EmbeddedSignature))                      {                          Packet embedded = new Packet();                          embedded.RawData = spacket.Value;                          sig.EmbeddedSignature = Signature.Parse(embedded);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.IssuerKeyID))                          sig.IssuerKeyID = Converter.ToULong(spacket.Value);                      else if (spacket.Type.Equals(SignatureSubPacketType.PrimaryUserID))                          sig.IsPrimaryUserID = (spacket.Value[0] == 1);                      else if (spacket.Type.Equals(SignatureSubPacketType.KeyFlags))                      {                          if ((spacket.Value[0] & (byte)KeyFlag.Authentication) == (int)KeyFlag.Authentication) sig.KeyFlags.Add(KeyFlag.Authentication);                          if ((spacket.Value[0] & (byte)KeyFlag.CertifiesOtherKeys) == (int)KeyFlag.CertifiesOtherKeys) sig.KeyFlags.Add(KeyFlag.CertifiesOtherKeys);                          if ((spacket.Value[0] & (byte)KeyFlag.EncryptsCommunications) == (int)KeyFlag.EncryptsCommunications) sig.KeyFlags.Add(KeyFlag.EncryptsCommunications);                          if ((spacket.Value[0] & (byte)KeyFlag.EncryptsStorage) == (int)KeyFlag.EncryptsStorage) sig.KeyFlags.Add(KeyFlag.EncryptsStorage);                          if ((spacket.Value[0] & (byte)KeyFlag.GroupKey) == (int)KeyFlag.GroupKey) sig.KeyFlags.Add(KeyFlag.GroupKey);                          if ((spacket.Value[0] & (byte)KeyFlag.SignsData) == (int)KeyFlag.SignsData) sig.KeyFlags.Add(KeyFlag.SignsData);                          if ((spacket.Value[0] & (byte)KeyFlag.SplitKey) == (int)KeyFlag.SplitKey) sig.KeyFlags.Add(KeyFlag.SplitKey);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.Features))                      {                          if ((spacket.Value[0] & (byte)Feature.ModificationDetection) == (int)Feature.ModificationDetection) sig.Features.Add(Feature.ModificationDetection);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.KeyServerPreferences))                      {                          if ((spacket.Value[0] & (byte)KeyServerPreference.NoModify) == (int)KeyServerPreference.NoModify) sig.KeyServerPreferences.Add(KeyServerPreference.NoModify);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.ReasonForRevocation))                      {                          if ((spacket.Value[0] & (byte)Reason.KeyCompromised) == (int)Reason.KeyCompromised) sig.ReasonForRevocation.Reason = Reason.KeyCompromised;                          else if ((spacket.Value[0] & (byte)Reason.KeyRetired) == (int)Reason.KeyRetired) sig.ReasonForRevocation.Reason = Reason.KeyRetired;                          else if ((spacket.Value[0] & (byte)Reason.KeySuperceded) == (int)Reason.KeySuperceded) sig.ReasonForRevocation.Reason = Reason.KeySuperceded;                          else if ((spacket.Value[0] & (byte)Reason.NoneSpecified) == (int)Reason.NoneSpecified) sig.ReasonForRevocation.Reason = Reason.NoneSpecified;                          else if ((spacket.Value[0] & (byte)Reason.UserIDNoLongerValid) == (int)Reason.UserIDNoLongerValid) sig.ReasonForRevocation.Reason = Reason.UserIDNoLongerValid;                          byte[] comment = new byte[spacket.Value.Length - 1];                          Array.Copy(spacket.Value' 1' comment' 0' comment.Length);                          sig.ReasonForRevocation.Comment = Encoding.UTF8.GetString(comment'0'comment.Length);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.PreferredCompressionAlgorithms))                          for (int i = 0; i < spacket.Value.Length; i++) sig.PreferredCompressionAlgorithms.Add((CompressionAlgorithm)spacket.Value[i]);                      else if (spacket.Type.Equals(SignatureSubPacketType.PreferredHashAlgorithms))                          for (int i = 0; i < spacket.Value.Length; i++) sig.PreferredHashAlgorithms.Add((HashAlgorithm)spacket.Value[i]);                      else if (spacket.Type.Equals(SignatureSubPacketType.PreferredSymmetricAlgorithms))                          for (int i = 0; i < spacket.Value.Length; i++) sig.PreferredSymmetricAlgorithms.Add((SymmetricKeyAlgorithm)spacket.Value[i]);                  }              }
Magic Number,ActiveUp.Net.Security.OpenPGP.Packets,Signature,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.Signature.cs,Parse,The following statement contains a magic number: if (sig.VersionNumber.Equals(4))              {                  // Hashed subpackets                  byte[] hashedsublengthbytes = new byte[2];                  ms.Read(hashedsublengthbytes' 0' 2);                  short hashedsublength = Converter.ToShort(hashedsublengthbytes);                  while (ms.Position < 5 + hashedsublength)                      sig.HashedSubPackets.Add(GetNextSignatureSubPacket(ref ms));                    // Unhashed subpackets                  byte[] unhashedsublengthbytes = new byte[2];                  ms.Read(unhashedsublengthbytes' 0' 2);                  short unhashedsublength = Converter.ToShort(unhashedsublengthbytes);                  while (ms.Position < hashedsublength + unhashedsublength)                      sig.UnHashedSubPackets.Add(GetNextSignatureSubPacket(ref ms));                    // Fill properties                  List<SignatureSubPacket> allSubPackets = new List<SignatureSubPacket>();                  allSubPackets.AddRange(sig.HashedSubPackets);                  allSubPackets.AddRange(sig.UnHashedSubPackets);                  foreach (SignatureSubPacket spacket in allSubPackets)                  {                      if (spacket.Type.Equals(SignatureSubPacketType.CreationTime))                          sig.CreationTime = Converter.UnixTimeStampToDateTime(Converter.ToInt(spacket.Value));                      else if (spacket.Type.Equals(SignatureSubPacketType.KeyExpirationTime))                          sig.KeyExpiration = Converter.UnixTimeStampToDateTime(Converter.ToInt(spacket.Value));                      else if (spacket.Type.Equals(SignatureSubPacketType.ExpirationTime))                          sig.SignatureExpiration = Converter.UnixTimeStampToDateTime(Converter.ToInt(spacket.Value));                      else if (spacket.Type.Equals(SignatureSubPacketType.ExportableCertification))                          sig.IsExportableCertification = (spacket.Value[0] == 1);                      else if (spacket.Type.Equals(SignatureSubPacketType.Revocable))                          sig.IsRevocable = (spacket.Value[0] == 1);                      else if (spacket.Type.Equals(SignatureSubPacketType.TrustSignature))                      {                          sig.Trust.Level = (TrustLevel)spacket.Value[0];                          sig.Trust.Amount = spacket.Value[1];                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.RegularExpression))                          sig.RegularExpression = spacket.Value;                      else if (spacket.Type.Equals(SignatureSubPacketType.RevocationKey))                      {                          if ((spacket.Value[0] & 128) != 128) throw new InvalidPacketSyntaxException("First bit of revocation key class is 0");                          sig.RevocationKey.Class = (RevocationKeyClass)(spacket.Value[0] & 64);                          sig.RevocationKey.HashAlgorithm = (HashAlgorithm)spacket.Value[1];                          Array.Copy(spacket.Value' 2' sig.RevocationKey.FingerPrint' 0' 20);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.NotationData))                      {                          Notation n = new Notation();                          n.IsHumanReadable = ((spacket.Value[0] & 128) == 128);                          byte[] nameLength = new byte[2];                          Array.Copy(spacket.Value' 4' nameLength' 0' 2);                          Array.Copy(spacket.Value' 6' n.Name' 0' Converter.ToInt(nameLength));                          byte[] valueLength = new byte[2];                          Array.Copy(spacket.Value' 6 + Converter.ToInt(nameLength)' valueLength' 0' 2);                          Array.Copy(spacket.Value' 6 + Converter.ToInt(nameLength) + 2' n.Value' 0' Converter.ToInt(valueLength));                          sig.Notations.Add(n);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.PolicyURL))                          sig.PolicyURL = Encoding.ASCII.GetString(spacket.Value'0'spacket.Value.Length);                      else if (spacket.Type.Equals(SignatureSubPacketType.SignerUserID))                          sig.SignerUserID = Encoding.ASCII.GetString(spacket.Value'0'spacket.Value.Length);                      else if (spacket.Type.Equals(SignatureSubPacketType.SignatureTarget))                      {                          sig.TargetSignatureInfo.PublicKeyAlgorithm = (PublicKeyAlgorithm)spacket.Value[0];                          sig.TargetSignatureInfo.HashAlgorithm = (HashAlgorithm)spacket.Value[1];                          Array.Copy(spacket.Value' 2' sig.TargetSignatureInfo.Hash' 0' spacket.Value.Length - 2);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.EmbeddedSignature))                      {                          Packet embedded = new Packet();                          embedded.RawData = spacket.Value;                          sig.EmbeddedSignature = Signature.Parse(embedded);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.IssuerKeyID))                          sig.IssuerKeyID = Converter.ToULong(spacket.Value);                      else if (spacket.Type.Equals(SignatureSubPacketType.PrimaryUserID))                          sig.IsPrimaryUserID = (spacket.Value[0] == 1);                      else if (spacket.Type.Equals(SignatureSubPacketType.KeyFlags))                      {                          if ((spacket.Value[0] & (byte)KeyFlag.Authentication) == (int)KeyFlag.Authentication) sig.KeyFlags.Add(KeyFlag.Authentication);                          if ((spacket.Value[0] & (byte)KeyFlag.CertifiesOtherKeys) == (int)KeyFlag.CertifiesOtherKeys) sig.KeyFlags.Add(KeyFlag.CertifiesOtherKeys);                          if ((spacket.Value[0] & (byte)KeyFlag.EncryptsCommunications) == (int)KeyFlag.EncryptsCommunications) sig.KeyFlags.Add(KeyFlag.EncryptsCommunications);                          if ((spacket.Value[0] & (byte)KeyFlag.EncryptsStorage) == (int)KeyFlag.EncryptsStorage) sig.KeyFlags.Add(KeyFlag.EncryptsStorage);                          if ((spacket.Value[0] & (byte)KeyFlag.GroupKey) == (int)KeyFlag.GroupKey) sig.KeyFlags.Add(KeyFlag.GroupKey);                          if ((spacket.Value[0] & (byte)KeyFlag.SignsData) == (int)KeyFlag.SignsData) sig.KeyFlags.Add(KeyFlag.SignsData);                          if ((spacket.Value[0] & (byte)KeyFlag.SplitKey) == (int)KeyFlag.SplitKey) sig.KeyFlags.Add(KeyFlag.SplitKey);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.Features))                      {                          if ((spacket.Value[0] & (byte)Feature.ModificationDetection) == (int)Feature.ModificationDetection) sig.Features.Add(Feature.ModificationDetection);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.KeyServerPreferences))                      {                          if ((spacket.Value[0] & (byte)KeyServerPreference.NoModify) == (int)KeyServerPreference.NoModify) sig.KeyServerPreferences.Add(KeyServerPreference.NoModify);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.ReasonForRevocation))                      {                          if ((spacket.Value[0] & (byte)Reason.KeyCompromised) == (int)Reason.KeyCompromised) sig.ReasonForRevocation.Reason = Reason.KeyCompromised;                          else if ((spacket.Value[0] & (byte)Reason.KeyRetired) == (int)Reason.KeyRetired) sig.ReasonForRevocation.Reason = Reason.KeyRetired;                          else if ((spacket.Value[0] & (byte)Reason.KeySuperceded) == (int)Reason.KeySuperceded) sig.ReasonForRevocation.Reason = Reason.KeySuperceded;                          else if ((spacket.Value[0] & (byte)Reason.NoneSpecified) == (int)Reason.NoneSpecified) sig.ReasonForRevocation.Reason = Reason.NoneSpecified;                          else if ((spacket.Value[0] & (byte)Reason.UserIDNoLongerValid) == (int)Reason.UserIDNoLongerValid) sig.ReasonForRevocation.Reason = Reason.UserIDNoLongerValid;                          byte[] comment = new byte[spacket.Value.Length - 1];                          Array.Copy(spacket.Value' 1' comment' 0' comment.Length);                          sig.ReasonForRevocation.Comment = Encoding.UTF8.GetString(comment'0'comment.Length);                      }                      else if (spacket.Type.Equals(SignatureSubPacketType.PreferredCompressionAlgorithms))                          for (int i = 0; i < spacket.Value.Length; i++) sig.PreferredCompressionAlgorithms.Add((CompressionAlgorithm)spacket.Value[i]);                      else if (spacket.Type.Equals(SignatureSubPacketType.PreferredHashAlgorithms))                          for (int i = 0; i < spacket.Value.Length; i++) sig.PreferredHashAlgorithms.Add((HashAlgorithm)spacket.Value[i]);                      else if (spacket.Type.Equals(SignatureSubPacketType.PreferredSymmetricAlgorithms))                          for (int i = 0; i < spacket.Value.Length; i++) sig.PreferredSymmetricAlgorithms.Add((SymmetricKeyAlgorithm)spacket.Value[i]);                  }              }
Magic Number,ActiveUp.Net.Security.OpenPGP.Packets,Signature,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.Signature.cs,Parse,The following statement contains a magic number: sig.QuickCheck = new byte[2];
Magic Number,ActiveUp.Net.Security.OpenPGP.Packets,Signature,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.Signature.cs,Parse,The following statement contains a magic number: ms.Read(sig.QuickCheck' 0' 2);
Magic Number,ActiveUp.Net.Security.OpenPGP.Packets,Signature,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.Signature.cs,Parse,The following statement contains a magic number: while (ms.Position < ms.Length)              {                  byte first = (byte)ms.ReadByte();                  byte second = (byte)ms.ReadByte();                  short length = (short)((Converter.ToShort(new byte[2] { first' second }) + 7) / 8);                  byte[] mpi = new byte[(int)length];                  ms.Read(mpi' 0' length);                  sig.MPIs.Add(mpi);              }
Magic Number,ActiveUp.Net.Security.OpenPGP.Packets,Signature,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.Signature.cs,Parse,The following statement contains a magic number: while (ms.Position < ms.Length)              {                  byte first = (byte)ms.ReadByte();                  byte second = (byte)ms.ReadByte();                  short length = (short)((Converter.ToShort(new byte[2] { first' second }) + 7) / 8);                  byte[] mpi = new byte[(int)length];                  ms.Read(mpi' 0' length);                  sig.MPIs.Add(mpi);              }
Magic Number,ActiveUp.Net.Security.OpenPGP.Packets,Signature,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.Signature.cs,Parse,The following statement contains a magic number: while (ms.Position < ms.Length)              {                  byte first = (byte)ms.ReadByte();                  byte second = (byte)ms.ReadByte();                  short length = (short)((Converter.ToShort(new byte[2] { first' second }) + 7) / 8);                  byte[] mpi = new byte[(int)length];                  ms.Read(mpi' 0' length);                  sig.MPIs.Add(mpi);              }
Magic Number,ActiveUp.Net.Security.OpenPGP.Packets,Signature,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.Signature.cs,GetNextSignatureSubPacket,The following statement contains a magic number: if (next < 192) subpacket.TypeAndBodyLength = next;              else if (next > 191 && next < 223)              {                  byte nextnext = (byte)instream.ReadByte();                  subpacket.TypeAndBodyLength = ((next - 192) << 8) + nextnext + 192;              }              else if (next == 255)              {                  int nextnext = instream.ReadByte();                  int nextnextnext = instream.ReadByte();                  int nextnextnextnext = instream.ReadByte();                  int nextnextnextnextnext = instream.ReadByte();                  subpacket.TypeAndBodyLength = (nextnext << 24) | (nextnextnext << 16) | (nextnextnextnext << 8) | nextnextnextnextnext;              }
Magic Number,ActiveUp.Net.Security.OpenPGP.Packets,Signature,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.Signature.cs,GetNextSignatureSubPacket,The following statement contains a magic number: if (next < 192) subpacket.TypeAndBodyLength = next;              else if (next > 191 && next < 223)              {                  byte nextnext = (byte)instream.ReadByte();                  subpacket.TypeAndBodyLength = ((next - 192) << 8) + nextnext + 192;              }              else if (next == 255)              {                  int nextnext = instream.ReadByte();                  int nextnextnext = instream.ReadByte();                  int nextnextnextnext = instream.ReadByte();                  int nextnextnextnextnext = instream.ReadByte();                  subpacket.TypeAndBodyLength = (nextnext << 24) | (nextnextnext << 16) | (nextnextnextnext << 8) | nextnextnextnextnext;              }
Magic Number,ActiveUp.Net.Security.OpenPGP.Packets,Signature,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.Signature.cs,GetNextSignatureSubPacket,The following statement contains a magic number: if (next < 192) subpacket.TypeAndBodyLength = next;              else if (next > 191 && next < 223)              {                  byte nextnext = (byte)instream.ReadByte();                  subpacket.TypeAndBodyLength = ((next - 192) << 8) + nextnext + 192;              }              else if (next == 255)              {                  int nextnext = instream.ReadByte();                  int nextnextnext = instream.ReadByte();                  int nextnextnextnext = instream.ReadByte();                  int nextnextnextnextnext = instream.ReadByte();                  subpacket.TypeAndBodyLength = (nextnext << 24) | (nextnextnext << 16) | (nextnextnextnext << 8) | nextnextnextnextnext;              }
Magic Number,ActiveUp.Net.Security.OpenPGP.Packets,Signature,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.Signature.cs,GetNextSignatureSubPacket,The following statement contains a magic number: if (next < 192) subpacket.TypeAndBodyLength = next;              else if (next > 191 && next < 223)              {                  byte nextnext = (byte)instream.ReadByte();                  subpacket.TypeAndBodyLength = ((next - 192) << 8) + nextnext + 192;              }              else if (next == 255)              {                  int nextnext = instream.ReadByte();                  int nextnextnext = instream.ReadByte();                  int nextnextnextnext = instream.ReadByte();                  int nextnextnextnextnext = instream.ReadByte();                  subpacket.TypeAndBodyLength = (nextnext << 24) | (nextnextnext << 16) | (nextnextnextnext << 8) | nextnextnextnextnext;              }
Magic Number,ActiveUp.Net.Security.OpenPGP.Packets,Signature,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.Signature.cs,GetNextSignatureSubPacket,The following statement contains a magic number: if (next < 192) subpacket.TypeAndBodyLength = next;              else if (next > 191 && next < 223)              {                  byte nextnext = (byte)instream.ReadByte();                  subpacket.TypeAndBodyLength = ((next - 192) << 8) + nextnext + 192;              }              else if (next == 255)              {                  int nextnext = instream.ReadByte();                  int nextnextnext = instream.ReadByte();                  int nextnextnextnext = instream.ReadByte();                  int nextnextnextnextnext = instream.ReadByte();                  subpacket.TypeAndBodyLength = (nextnext << 24) | (nextnextnext << 16) | (nextnextnextnext << 8) | nextnextnextnextnext;              }
Magic Number,ActiveUp.Net.Security.OpenPGP.Packets,Signature,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.Signature.cs,GetNextSignatureSubPacket,The following statement contains a magic number: if (next < 192) subpacket.TypeAndBodyLength = next;              else if (next > 191 && next < 223)              {                  byte nextnext = (byte)instream.ReadByte();                  subpacket.TypeAndBodyLength = ((next - 192) << 8) + nextnext + 192;              }              else if (next == 255)              {                  int nextnext = instream.ReadByte();                  int nextnextnext = instream.ReadByte();                  int nextnextnextnext = instream.ReadByte();                  int nextnextnextnextnext = instream.ReadByte();                  subpacket.TypeAndBodyLength = (nextnext << 24) | (nextnextnext << 16) | (nextnextnextnext << 8) | nextnextnextnextnext;              }
Magic Number,ActiveUp.Net.Security.OpenPGP.Packets,Signature,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.Signature.cs,GetNextSignatureSubPacket,The following statement contains a magic number: if (next < 192) subpacket.TypeAndBodyLength = next;              else if (next > 191 && next < 223)              {                  byte nextnext = (byte)instream.ReadByte();                  subpacket.TypeAndBodyLength = ((next - 192) << 8) + nextnext + 192;              }              else if (next == 255)              {                  int nextnext = instream.ReadByte();                  int nextnextnext = instream.ReadByte();                  int nextnextnextnext = instream.ReadByte();                  int nextnextnextnextnext = instream.ReadByte();                  subpacket.TypeAndBodyLength = (nextnext << 24) | (nextnextnext << 16) | (nextnextnextnext << 8) | nextnextnextnextnext;              }
Magic Number,ActiveUp.Net.Security.OpenPGP.Packets,Signature,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.Signature.cs,GetNextSignatureSubPacket,The following statement contains a magic number: if (next < 192) subpacket.TypeAndBodyLength = next;              else if (next > 191 && next < 223)              {                  byte nextnext = (byte)instream.ReadByte();                  subpacket.TypeAndBodyLength = ((next - 192) << 8) + nextnext + 192;              }              else if (next == 255)              {                  int nextnext = instream.ReadByte();                  int nextnextnext = instream.ReadByte();                  int nextnextnextnext = instream.ReadByte();                  int nextnextnextnextnext = instream.ReadByte();                  subpacket.TypeAndBodyLength = (nextnext << 24) | (nextnextnext << 16) | (nextnextnextnext << 8) | nextnextnextnextnext;              }
Magic Number,ActiveUp.Net.Security.OpenPGP.Packets,Signature,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.Signature.cs,GetNextSignatureSubPacket,The following statement contains a magic number: if (next < 192) subpacket.TypeAndBodyLength = next;              else if (next > 191 && next < 223)              {                  byte nextnext = (byte)instream.ReadByte();                  subpacket.TypeAndBodyLength = ((next - 192) << 8) + nextnext + 192;              }              else if (next == 255)              {                  int nextnext = instream.ReadByte();                  int nextnextnext = instream.ReadByte();                  int nextnextnextnext = instream.ReadByte();                  int nextnextnextnextnext = instream.ReadByte();                  subpacket.TypeAndBodyLength = (nextnext << 24) | (nextnextnext << 16) | (nextnextnextnext << 8) | nextnextnextnextnext;              }
Magic Number,ActiveUp.Net.Security.OpenPGP.Packets,Signature,C:\repos\slavat_MailSystem.NET\Class Library\ActiveUp.Net.OpenPGP\OpenPGP.Packets.Signature.cs,GetNextSignatureSubPacket,The following statement contains a magic number: if (next < 192) subpacket.TypeAndBodyLength = next;              else if (next > 191 && next < 223)              {                  byte nextnext = (byte)instream.ReadByte();                  subpacket.TypeAndBodyLength = ((next - 192) << 8) + nextnext + 192;              }              else if (next == 255)              {                  int nextnext = instream.ReadByte();                  int nextnextnext = instream.ReadByte();                  int nextnextnextnext = instream.ReadByte();                  int nextnextnextnextnext = instream.ReadByte();                  subpacket.TypeAndBodyLength = (nextnext << 24) | (nextnextnext << 16) | (nextnextnextnext << 8) | nextnextnextnextnext;              }
