Implementation smell,Namespace,Class,File,Method,Description
Long Method,NetMQ,NetMQPoller,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\NetMQPoller.cs,RunPoller,The method has 107 lines of code.
Long Method,NetMQ,NetMQSelector,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\NetMQSelector.cs,Select,The method has 112 lines of code.
Long Method,NetMQ.Core,Options,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Options.cs,SetSocketOption,The method has 102 lines of code.
Long Method,NetMQ.Core,SocketBase,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\SocketBase.cs,Bind,The method has 100 lines of code.
Long Method,NetMQ.Core,SocketBase,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\SocketBase.cs,Connect,The method has 127 lines of code.
Long Method,NetMQ.Core.Patterns.Utils,MultiTrie,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Utils\MultiTrie.cs,RemoveHelper,The method has 104 lines of code.
Long Method,NetMQ.Core.Transports,StreamEngine,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\StreamEngine.cs,HandleHandshake,The method has 212 lines of code.
Complex Method,NetMQ,Shim,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\NetMQBeacon.cs,Configure,Cyclomatic complexity of the method is 8
Complex Method,NetMQ,NetMQException,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\NetMQException.cs,Create,Cyclomatic complexity of the method is 9
Complex Method,NetMQ,NetMQPoller,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\NetMQPoller.cs,RunPoller,Cyclomatic complexity of the method is 22
Complex Method,NetMQ,NetMQSelector,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\NetMQSelector.cs,Select,Cyclomatic complexity of the method is 26
Complex Method,NetMQ.Core,Ctx,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Ctx.cs,Terminate,Cyclomatic complexity of the method is 8
Complex Method,NetMQ.Core,ErrorHelper,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\ErrorHelper.cs,ToErrorCode,Cyclomatic complexity of the method is 21
Complex Method,NetMQ.Core,Options,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Options.cs,SetSocketOption,Cyclomatic complexity of the method is 32
Complex Method,NetMQ.Core,Options,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Options.cs,GetSocketOption,Cyclomatic complexity of the method is 28
Complex Method,NetMQ.Core,Pipe,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Pipe.cs,Terminate,Cyclomatic complexity of the method is 8
Complex Method,NetMQ.Core,SessionBase,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\SessionBase.cs,Create,Cyclomatic complexity of the method is 14
Complex Method,NetMQ.Core,SocketBase,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\SocketBase.cs,Create,Cyclomatic complexity of the method is 14
Complex Method,NetMQ.Core,SocketBase,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\SocketBase.cs,Bind,Cyclomatic complexity of the method is 8
Complex Method,NetMQ.Core,SocketBase,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\SocketBase.cs,Connect,Cyclomatic complexity of the method is 9
Complex Method,NetMQ.Core,SocketBase,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\SocketBase.cs,TrySend,Cyclomatic complexity of the method is 9
Complex Method,NetMQ.Core,SocketBase,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\SocketBase.cs,TryRecv,Cyclomatic complexity of the method is 10
Complex Method,NetMQ.Core,SocketBase,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\SocketBase.cs,GetTypeString,Cyclomatic complexity of the method is 11
Complex Method,NetMQ.Core,ZObject,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\ZObject.cs,ProcessCommand,Cyclomatic complexity of the method is 17
Complex Method,NetMQ.Core.Patterns,Peer,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Peer.cs,XSend,Cyclomatic complexity of the method is 9
Complex Method,NetMQ.Core.Patterns,Rep,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Rep.cs,XRecv,Cyclomatic complexity of the method is 10
Complex Method,NetMQ.Core.Patterns,Req,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Req.cs,XRecv,Cyclomatic complexity of the method is 9
Complex Method,NetMQ.Core.Patterns,Router,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Router.cs,XSend,Cyclomatic complexity of the method is 13
Complex Method,NetMQ.Core.Patterns,Router,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Router.cs,XRecv,Cyclomatic complexity of the method is 10
Complex Method,NetMQ.Core.Patterns,Stream,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Stream.cs,XSend,Cyclomatic complexity of the method is 8
Complex Method,NetMQ.Core.Patterns,XPub,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Patterns\XPub.cs,XSetSocketOption,Cyclomatic complexity of the method is 15
Complex Method,NetMQ.Core.Patterns.Utils,Distribution,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Utils\Distribution.cs,Distribute,Cyclomatic complexity of the method is 8
Complex Method,NetMQ.Core.Patterns.Utils,LoadBalancer,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Utils\LoadBalancer.cs,Send,Cyclomatic complexity of the method is 8
Complex Method,NetMQ.Core.Patterns.Utils,MultiTrie,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Utils\MultiTrie.cs,AddHelper,Cyclomatic complexity of the method is 10
Complex Method,NetMQ.Core.Patterns.Utils,MultiTrie,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Utils\MultiTrie.cs,RemoveHelper,Cyclomatic complexity of the method is 14
Complex Method,NetMQ.Core.Patterns.Utils,MultiTrie,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Utils\MultiTrie.cs,RemoveHelper,Cyclomatic complexity of the method is 17
Complex Method,NetMQ.Core.Patterns.Utils,MultiTrie,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Utils\MultiTrie.cs,Match,Cyclomatic complexity of the method is 10
Complex Method,NetMQ.Core.Patterns.Utils,Trie,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Utils\Trie.cs,Add,Cyclomatic complexity of the method is 9
Complex Method,NetMQ.Core.Patterns.Utils,Trie,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Utils\Trie.cs,Remove,Cyclomatic complexity of the method is 16
Complex Method,NetMQ.Core.Transports,DecoderBase,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\DecoderBase.cs,ProcessBuffer,Cyclomatic complexity of the method is 11
Complex Method,NetMQ.Core.Transports,EncoderBase,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\EncoderBase.cs,GetData,Cyclomatic complexity of the method is 8
Complex Method,NetMQ.Core.Transports,StreamEngine,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\StreamEngine.cs,Handle,Cyclomatic complexity of the method is 13
Complex Method,NetMQ.Core.Transports,StreamEngine,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\StreamEngine.cs,HandleHandshake,Cyclomatic complexity of the method is 26
Complex Method,NetMQ.Core.Transports,StreamEngine,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\StreamEngine.cs,ProcessInput,Cyclomatic complexity of the method is 9
Complex Method,NetMQ.Core.Transports.Pgm,PgmAddress,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\Pgm\PgmAddress.cs,Resolve,Cyclomatic complexity of the method is 8
Complex Method,NetMQ.Core.Transports.Tcp,TcpAddress,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\Tcp\TcpAddress.cs,Resolve,Cyclomatic complexity of the method is 8
Complex Method,NetMQ.Core.Utils,Poller,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Utils\Poller.cs,Loop,Cyclomatic complexity of the method is 10
Complex Method,NetMQ.Core.Utils,Proactor,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Utils\Proactor.cs,Loop,Cyclomatic complexity of the method is 9
Complex Method,NetMQ.Core.Utils,StringLib,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Utils\StringLib.cs,AsString,Cyclomatic complexity of the method is 16
Complex Method,NetMQ.Monitoring,NetMQMonitor,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Monitoring\NetMQMonitor.cs,Handle,Cyclomatic complexity of the method is 11
Long Parameter List,NetMQ,OutgoingSocketExtensions,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\OutgoingSocketExtensions.cs,TrySendFrame,The method has 5 parameters. Parameters: socket' timeout' data' length' more
Long Parameter List,NetMQ,Proxy,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Proxy.cs,Proxy,The method has 5 parameters. Parameters: frontend' backend' controlIn' controlOut' poller
Long Parameter List,NetMQ,ReceivingSocketExtensions,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\ReceivingSocketExtensions.cs,TryReceiveFrameString,The method has 5 parameters. Parameters: socket' timeout' encoding' frameString' more
Long Parameter List,NetMQ,ReceivingSocketExtensions,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\ReceivingSocketExtensions.cs,TryReceiveMultipartStrings,The method has 5 parameters. Parameters: socket' timeout' encoding' frames' expectedFrameCount
Long Parameter List,NetMQ.Core,Pipe,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Pipe.cs,Pipe,The method has 7 parameters. Parameters: parent' inboundPipe' outboundPipe' inHighWatermark' outHighWatermark' predefinedLowWatermark' delay
Long Parameter List,NetMQ.Core,SessionBase,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\SessionBase.cs,Create,The method has 5 parameters. Parameters: ioThread' connect' socket' options' addr
Long Parameter List,NetMQ.Core,SessionBase,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\SessionBase.cs,SessionBase,The method has 5 parameters. Parameters: ioThread' connect' socket' options' addr
Long Parameter List,NetMQ.Core.Patterns,DealerSession,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Dealer.cs,DealerSession,The method has 5 parameters. Parameters: ioThread' connect' socket' options' addr
Long Parameter List,NetMQ.Core.Patterns,PairSession,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Pair.cs,PairSession,The method has 5 parameters. Parameters: ioThread' connect' socket' options' addr
Long Parameter List,NetMQ.Core.Patterns,PeerSession,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Peer.cs,PeerSession,The method has 5 parameters. Parameters: ioThread' connect' socket' options' addr
Long Parameter List,NetMQ.Core.Patterns,PubSession,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Pub.cs,PubSession,The method has 5 parameters. Parameters: ioThread' connect' socket' options' addr
Long Parameter List,NetMQ.Core.Patterns,PullSession,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Pull.cs,PullSession,The method has 5 parameters. Parameters: ioThread' connect' socket' options' addr
Long Parameter List,NetMQ.Core.Patterns,PushSession,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Push.cs,PushSession,The method has 5 parameters. Parameters: ioThread' connect' socket' options' addr
Long Parameter List,NetMQ.Core.Patterns,RepSession,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Rep.cs,RepSession,The method has 5 parameters. Parameters: ioThread' connect' socket' options' addr
Long Parameter List,NetMQ.Core.Patterns,ReqSession,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Req.cs,ReqSession,The method has 5 parameters. Parameters: ioThread' connect' socket' options' addr
Long Parameter List,NetMQ.Core.Patterns,RouterSession,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Router.cs,RouterSession,The method has 5 parameters. Parameters: ioThread' connect' socket' options' addr
Long Parameter List,NetMQ.Core.Patterns,StreamSession,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Stream.cs,StreamSession,The method has 5 parameters. Parameters: ioThread' connect' socket' options' addr
Long Parameter List,NetMQ.Core.Patterns,SubSession,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Sub.cs,SubSession,The method has 5 parameters. Parameters: ioThread' connect' socket' options' addr
Long Parameter List,NetMQ.Core.Patterns,XPubSession,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Patterns\XPub.cs,XPubSession,The method has 5 parameters. Parameters: ioThread' connect' socket' options' addr
Long Parameter List,NetMQ.Core.Patterns,XSubSession,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Patterns\XSub.cs,XSubSession,The method has 5 parameters. Parameters: ioThread' connect' socket' options' addr
Long Parameter List,NetMQ.Core.Patterns.Utils,MultiTrie,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Utils\MultiTrie.cs,RemoveHelper,The method has 6 parameters. Parameters: pipe' buffer' bufferSize' maxBufferSize' func' arg
Long Parameter List,NetMQ.Core.Patterns.Utils,MultiTrie,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Utils\MultiTrie.cs,Match,The method has 5 parameters. Parameters: data' offset' size' func' arg
Long Parameter List,NetMQ.Core.Patterns.Utils,Trie,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Utils\Trie.cs,ApplyHelper,The method has 5 parameters. Parameters: buffer' bufferSize' maxBufferSize' func' arg
Long Parameter List,NetMQ.Core.Transports.Ipc,IpcConnector,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\Ipc\IpcConnector.cs,IpcConnector,The method has 5 parameters. Parameters: ioThread' session' options' addr' wait
Long Parameter List,NetMQ.Core.Transports.Tcp,TcpConnector,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\Tcp\TcpConnector.cs,TcpConnector,The method has 5 parameters. Parameters: ioThread' session' options' addr' delayedStart
Long Parameter List,NetMQ.Sockets,RequestSocket,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Sockets\RequestSocket.cs,RequestResponseMultipartMessageWithRetry,The method has 5 parameters. Parameters: address' requestMessage' numTries' requestTimeout' progressPublisher
Long Parameter List,NetMQ.Sockets,RequestSocket,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Sockets\RequestSocket.cs,RequestResponseStringWithRetry,The method has 5 parameters. Parameters: address' requestString' numTries' requestTimeout' progressPublisher
Long Statement,NetMQ,Msg,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Msg.cs,RemoveReferences,The length of the statement  "                // TODO shouldn't we set the type to uninitialised' or call clear' here? the object has a null refCount' but other methods may try to use it " is 140.
Long Statement,NetMQ,Msg,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Msg.cs,TrimPrefix,The length of the statement  "            if (count > Size || count < 0) throw new ArgumentOutOfRangeException(nameof(count)' "Count should be between 0 and size"); " is 122.
Long Statement,NetMQ,Shim,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\NetMQBeacon.cs,SendUdpFrame,The length of the statement  "                    // due to network change which causes crash (if no try/catch and keep trying to send to incorrect/not available address. " is 120.
Long Statement,NetMQ,NetMQPoller,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\NetMQPoller.cs,RunPoller,The length of the statement  "                        //      Solution should be different' but sleep is more natural here than in selector (timers are not selector concern). " is 120.
Long Statement,NetMQ,NetMQPoller,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\NetMQPoller.cs,RebuildPollset,The length of the statement  "            // put a corresponding SelectItem into the m_pollSet array and a reference to the socket itself into the m_pollact array. " is 121.
Long Statement,NetMQ,NetMQPoller,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\NetMQPoller.cs,Dispose,The length of the statement  "            if (Interlocked.CompareExchange(ref m_disposeState' (int)DisposeState.Disposing' (int)DisposeState.Undisposed) != (int)DisposeState.Undisposed) " is 143.
Long Statement,NetMQ,NetMQPoller,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\NetMQPoller.cs,Dispose,The length of the statement  "                    throw new NetMQException($"Invalid state detected: {nameof(NetMQPoller)} contains a disposed {nameof(NetMQSocket)}. Sockets must be either removed before being disposed' or disposed after the poller is disposed."); " is 214.
Long Statement,NetMQ,NetMQSelector,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\NetMQSelector.cs,Select,The length of the statement  "                    string xMsg = $"In Selector.Select' Socket.Select({textOfListRead}' {textOfListWrite}' {textOfListError}' {currentTimeoutMicroSeconds}) threw a SocketException: {x.Message}"; " is 174.
Long Statement,NetMQ,ReceivingSocketExtensions,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\ReceivingSocketExtensions.cs,TryReceiveFrameString,The length of the statement  "            return socket.TryReceiveFrameString(TimeSpan.Zero' SendReceiveConstants.DefaultEncoding' out frameString' out bool more); " is 121.
Long Statement,NetMQ,ReceivingSocketExtensions,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\ReceivingSocketExtensions.cs,TryReceiveMultipartStrings,The length of the statement  "            return TryReceiveMultipartStrings(socket' timeout' SendReceiveConstants.DefaultEncoding' ref frames' expectedFrameCount); " is 121.
Long Statement,NetMQ,ReceivingSocketExtensions,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\ReceivingSocketExtensions.cs,TryReceiveSignal,The length of the statement  "            // TODO use clock to enforce timeout across multiple loop iterations — if invalid messages are received regularly' the method may not return once the timeout elapses " is 165.
Long Statement,NetMQ.Core,Address,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Address.cs,ToString,The length of the statement  "            return null; //TODO: REVIEW - Although not explicitly prohibited' returning null from ToString seems sketchy; return string.Empty? " is 130.
Long Statement,NetMQ.Core,Options,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Options.cs,SetSocketOption,The length of the statement  "                        throw new InvalidException($"In Options.SetSocketOption(Identity' {optionValue?.ToString() ?? "null"}) optionValue must be a string or byte-array."); " is 149.
Long Statement,NetMQ.Core,Options,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Options.cs,SetSocketOption,The length of the statement  "                        throw new InvalidException($"In Options.SetSocketOption(Identity') optionValue yielded a byte-array of length {val.Length}' should be 1..255."); " is 144.
Long Statement,NetMQ.Core,Options,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Options.cs,SetSocketOption,The length of the statement  "                        throw new InvalidException($"Options.SetSocketOption(ReconnectIvlMax' {reconnectIvlMax}) optionValue must be non-negative."); " is 125.
Long Statement,NetMQ.Core,Options,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Options.cs,SetSocketOption,The length of the statement  "                        throw new InvalidException($"Options.SetSocketOption(TcpKeepalive' {tcpKeepalive}) optionValue is neither -1' 0' nor 1."); " is 122.
Long Statement,NetMQ.Core.Patterns,ReqSession,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Req.cs,PushMsg,The length of the statement  "                // TODO the flags checks here don't check specific bits -- should they use HasMore instead? does this work with shared Msg objects? " is 131.
Long Statement,NetMQ.Core.Patterns,Sub,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Sub.cs,XSetSocketOption,The length of the statement  "                throw new InvalidException($"In Sub.XSetSocketOption({option}'{optionValue?.ToString() ?? "null"})' optionValue must be either a string or a byte-array."); " is 155.
Long Statement,NetMQ.Core.Patterns,XPub,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Patterns\XPub.cs,XSetSocketOption,The length of the statement  "                            throw new InvalidException($"In XPub.XSetSocketOption(Identity' {optionValue?.ToString() ?? "null"}) optionValue must be a string or byte-array."); " is 147.
Long Statement,NetMQ.Core.Patterns,XPub,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Patterns\XPub.cs,XSetSocketOption,The length of the statement  "                            throw new InvalidException($"In XPub.XSetSocketOption(Identity') optionValue yielded a byte-array of length {val.Length}' should be 1..255."); " is 142.
Long Statement,NetMQ.Core.Patterns.Utils,MultiTrie,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Utils\MultiTrie.cs,AddHelper,The length of the statement  "                    m_count = (m_minCharacter < currentCharacter ? currentCharacter - m_minCharacter : m_minCharacter - currentCharacter) + 1; " is 122.
Long Statement,NetMQ.Core.Patterns.Utils,Trie,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Utils\Trie.cs,Add,The length of the statement  "                    m_count = (short)((m_minCharacter < currentCharacter ? currentCharacter - m_minCharacter : m_minCharacter - currentCharacter) + 1); " is 131.
Long Statement,NetMQ.Core.Transports.Pgm,PgmAddress,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\Pgm\PgmAddress.cs,Resolve,The length of the statement  "                    throw new InvalidException($"In PgmAddress.Resolve({name}'{ip4Only})' portStr ({portStr}) must denote a valid nonzero integer."); " is 129.
Long Statement,NetMQ.Core.Transports.Pgm,PgmSocket,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\Pgm\PgmSocket.cs,Init,The length of the statement  "                string xMsg = $"SocketException with SocketErrorCode={x.SocketErrorCode}' Message={x.Message}' in PgmSocket.Init' within AsyncSocket.Create(AddressFamily.InterNetwork' SocketType.Rdm' PGM_PROTOCOL_TYPE)' {this}"; " is 212.
Long Statement,NetMQ.Core.Transports.Pgm,PgmSocket,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\Pgm\PgmSocket.cs,Init,The length of the statement  "                // If running on Microsoft Windows' suggest to the developer that he may need to install MSMQ in order to get PGM socket support. " is 129.
Long Statement,NetMQ.Core.Transports.Pgm,PgmSocket,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\Pgm\PgmSocket.cs,Init,The length of the statement  "                    Debug.WriteLine("For Microsoft Windows' you may want to check to see whether you have installed MSMQ on this host' to get PGM socket support."); " is 144.
Long Statement,NetMQ.Core.Transports.Pgm,PgmSocket,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\Pgm\PgmSocket.cs,InitOptions,The length of the statement  "            if (m_options.ReceiveBuffer > 0 && (m_pgmSocketType == PgmSocketType.Receiver || m_pgmSocketType == PgmSocketType.Listener)) " is 124.
Long Statement,NetMQ.Core.Transports.Pgm,PgmSocket,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\Pgm\PgmSocket.cs,InitOptions,The length of the statement  "                // instead of using the struct _RM_SEND_WINDOW we are using byte array of size 12 (the size of the original struct and the size of three ints) " is 142.
Long Statement,NetMQ.Core.Transports.Pgm,PgmSocket,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\Pgm\PgmSocket.cs,InitOptions,The length of the statement  "                // we are not setting the size in bytes because it get filled automatically' if we want to set it we would just uncomment the following lines " is 141.
Long Statement,NetMQ.Core.Transports.Tcp,TcpAddress,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\Tcp\TcpAddress.cs,Resolve,The length of the statement  "                    : availableAddresses.FirstOrDefault(ip => ip.AddressFamily == AddressFamily.InterNetwork || ip.AddressFamily == AddressFamily.InterNetworkV6); " is 142.
Long Statement,NetMQ.Core.Utils,Opcode,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Utils\OpCode.cs,IsARMArchitecture,The length of the statement  "            Assembly currentAssembly = Assembly.Load("Mono.Posix' Version=2.0.0.0' Culture=neutral' PublicKeyToken=0738eb9f132ed756"); " is 122.
Long Statement,NetMQ.Core.Utils,Poller,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Utils\Poller.cs,RemoveHandle,The length of the statement  "            // If the socket was removed before being added there is no reason to mark retired' so just cancelling the socket and removing from add list. " is 141.
Long Statement,NetMQ.Core.Utils,SocketUtility,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Utils\SocketUtility.cs,Select,The length of the statement  "            // .NET 3.5 has a bug' such that -1 is not blocking the select call - therefore we use here instead the maximum integer value. " is 126.
Long Statement,NetMQ.Monitoring,NetMQMonitor,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Monitoring\NetMQMonitor.cs,Handle,The length of the statement  "                    InvokeEvent(Connected' new NetMQMonitorSocketEventArgs(this' monitorEvent.Addr' (AsyncSocket)monitorEvent.Arg' SocketEvents.Connected)); " is 136.
Long Statement,NetMQ.Monitoring,NetMQMonitor,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Monitoring\NetMQMonitor.cs,Handle,The length of the statement  "                    InvokeEvent(ConnectDelayed' new NetMQMonitorErrorEventArgs(this' monitorEvent.Addr' (ErrorCode)monitorEvent.Arg' SocketEvents.ConnectDelayed)); " is 143.
Long Statement,NetMQ.Monitoring,NetMQMonitor,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Monitoring\NetMQMonitor.cs,Handle,The length of the statement  "                    InvokeEvent(ConnectRetried' new NetMQMonitorIntervalEventArgs(this' monitorEvent.Addr' (int)monitorEvent.Arg' SocketEvents.ConnectRetried)); " is 140.
Long Statement,NetMQ.Monitoring,NetMQMonitor,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Monitoring\NetMQMonitor.cs,Handle,The length of the statement  "                    InvokeEvent(Listening' new NetMQMonitorSocketEventArgs(this' monitorEvent.Addr' (AsyncSocket)monitorEvent.Arg' SocketEvents.Listening)); " is 136.
Long Statement,NetMQ.Monitoring,NetMQMonitor,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Monitoring\NetMQMonitor.cs,Handle,The length of the statement  "                    InvokeEvent(BindFailed' new NetMQMonitorErrorEventArgs(this' monitorEvent.Addr' (ErrorCode)monitorEvent.Arg' SocketEvents.BindFailed)); " is 135.
Long Statement,NetMQ.Monitoring,NetMQMonitor,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Monitoring\NetMQMonitor.cs,Handle,The length of the statement  "                    InvokeEvent(Accepted' new NetMQMonitorSocketEventArgs(this' monitorEvent.Addr' (AsyncSocket)monitorEvent.Arg' SocketEvents.Accepted)); " is 134.
Long Statement,NetMQ.Monitoring,NetMQMonitor,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Monitoring\NetMQMonitor.cs,Handle,The length of the statement  "                    InvokeEvent(AcceptFailed' new NetMQMonitorErrorEventArgs(this' monitorEvent.Addr' (ErrorCode)monitorEvent.Arg' SocketEvents.AcceptFailed)); " is 139.
Long Statement,NetMQ.Monitoring,NetMQMonitor,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Monitoring\NetMQMonitor.cs,Handle,The length of the statement  "                    InvokeEvent(Closed' new NetMQMonitorSocketEventArgs(this' monitorEvent.Addr' (AsyncSocket)monitorEvent.Arg' SocketEvents.Closed)); " is 130.
Long Statement,NetMQ.Monitoring,NetMQMonitor,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Monitoring\NetMQMonitor.cs,Handle,The length of the statement  "                    InvokeEvent(CloseFailed' new NetMQMonitorErrorEventArgs(this' monitorEvent.Addr' (ErrorCode)monitorEvent.Arg' SocketEvents.CloseFailed)); " is 137.
Long Statement,NetMQ.Monitoring,NetMQMonitor,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Monitoring\NetMQMonitor.cs,Handle,The length of the statement  "                    InvokeEvent(Disconnected' new NetMQMonitorSocketEventArgs(this' monitorEvent.Addr' (AsyncSocket)monitorEvent.Arg' SocketEvents.Disconnected)); " is 142.
Long Statement,NetMQ.Monitoring,NetMQMonitor,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Monitoring\NetMQMonitor.cs,Stop,The length of the statement  "                throw new InvalidOperationException("Monitor attached to a poller' please detach from poller and don't use the stop method"); " is 125.
Complex Conditional,NetMQ.Core,SessionBase,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\SessionBase.cs,Detached,The conditional expression  "m_pipe != null && m_options.DelayAttachOnConnect                  && m_addr.Protocol != Address.PgmProtocol && m_addr.Protocol != Address.EpgmProtocol &&                   m_options.SocketType != ZmqSocketType.Peer"  is complex.
Complex Conditional,NetMQ.Core.Patterns,XPub,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Patterns\XPub.cs,XReadActivated,The conditional expression  "!msgMore && !isBroadcast && size > 0 && (sub[0] == 0 || sub[0] == 1)"  is complex.
Complex Conditional,NetMQ.Core.Patterns,XPub,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Patterns\XPub.cs,XReadActivated,The conditional expression  "!msgMore && m_broadcastEnabled && size > 0 && sub[0] == 2"  is complex.
Complex Conditional,NetMQ.Core.Patterns,XPub,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Patterns\XPub.cs,XRecv,The conditional expression  "!m_moreIn && m_manual && (msg[0] == 0 || msg[0] == 1)"  is complex.
Complex Conditional,NetMQ.Core.Transports,StreamEngine,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\StreamEngine.cs,EndWrite,The conditional expression  "bytesTransferred == 0 ||                  socketError == SocketError.NetworkDown ||                  socketError == SocketError.NetworkReset ||                  socketError == SocketError.HostUnreachable ||                  socketError == SocketError.ConnectionAborted ||                  socketError == SocketError.TimedOut ||                  socketError == SocketError.ConnectionReset ||                  socketError == SocketError.AccessDenied"  is complex.
Complex Conditional,NetMQ.Core.Transports,StreamEngine,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\StreamEngine.cs,EndRead,The conditional expression  "bytesTransferred == 0 ||                  socketError == SocketError.NetworkDown ||                  socketError == SocketError.NetworkReset ||                  socketError == SocketError.HostUnreachable ||                  socketError == SocketError.ConnectionAborted ||                  socketError == SocketError.TimedOut ||                  socketError == SocketError.ConnectionReset ||                  socketError == SocketError.AccessDenied"  is complex.
Empty Catch Block,NetMQ,NetMQActor,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\NetMQActor.cs,NetMQActor,The method has an empty catch block.
Empty Catch Block,NetMQ,NetMQActor,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\NetMQActor.cs,RunShim,The method has an empty catch block.
Empty Catch Block,NetMQ.Core,SocketBase,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\SocketBase.cs,InEvent,The method has an empty catch block.
Empty Catch Block,NetMQ.Core.Transports,StreamEngine,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\StreamEngine.cs,Destroy,The method has an empty catch block.
Empty Catch Block,NetMQ.Core.Transports.Pgm,PgmSession,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\Pgm\PgmSession.cs,Destroy,The method has an empty catch block.
Empty Catch Block,NetMQ.Core.Transports.Pgm,PgmSocket,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\Pgm\PgmSocket.cs,InitOptions,The method has an empty catch block.
Empty Catch Block,NetMQ.Core.Transports.Tcp,TcpConnector,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\Tcp\TcpConnector.cs,StartConnecting,The method has an empty catch block.
Empty Catch Block,NetMQ.Core.Transports.Tcp,TcpConnector,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\Tcp\TcpConnector.cs,OutCompleted,The method has an empty catch block.
Empty Catch Block,NetMQ.Core.Transports.Tcp,TcpListener,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\Tcp\TcpListener.cs,SetAddress,The method has an empty catch block.
Empty Catch Block,NetMQ.Core.Utils,Poller,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Utils\Poller.cs,Destroy,The method has an empty catch block.
Empty Catch Block,NetMQ.Core.Utils,Poller,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Utils\Poller.cs,Loop,The method has an empty catch block.
Empty Catch Block,NetMQ.Core.Utils,Poller,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Utils\Poller.cs,Loop,The method has an empty catch block.
Empty Catch Block,NetMQ.Core.Utils,Proactor,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Utils\Proactor.cs,Destroy,The method has an empty catch block.
Empty Catch Block,NetMQ.Core.Utils,Proactor,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Utils\Proactor.cs,Loop,The method has an empty catch block.
Empty Catch Block,NetMQ.Core.Utils,Signaler,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Utils\Signaler.cs,Close,The method has an empty catch block.
Empty Catch Block,NetMQ.Core.Utils,Signaler,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Utils\Signaler.cs,Close,The method has an empty catch block.
Empty Catch Block,NetMQ.Core.Utils,Signaler,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Utils\Signaler.cs,Close,The method has an empty catch block.
Empty Catch Block,NetMQ.Monitoring,NetMQMonitor,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Monitoring\NetMQMonitor.cs,InternalClose,The method has an empty catch block.
Magic Number,NetMQ,InterfaceCollection,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\InterfaceCollection.cs,InterfaceCollection,The following statement contains a magic number: broadcastBytes[2] |= (byte)~mask[2];
Magic Number,NetMQ,InterfaceCollection,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\InterfaceCollection.cs,InterfaceCollection,The following statement contains a magic number: broadcastBytes[2] |= (byte)~mask[2];
Magic Number,NetMQ,InterfaceCollection,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\InterfaceCollection.cs,InterfaceCollection,The following statement contains a magic number: broadcastBytes[3] |= (byte)~mask[3];
Magic Number,NetMQ,InterfaceCollection,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\InterfaceCollection.cs,InterfaceCollection,The following statement contains a magic number: broadcastBytes[3] |= (byte)~mask[3];
Magic Number,NetMQ,NetMQActor,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\NetMQActor.cs,NetMQActor,The following statement contains a magic number: actorName = $"NetMQActor-{random.Next(0' 10000)}-{random.Next(0' 10000)}";
Magic Number,NetMQ,NetMQActor,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\NetMQActor.cs,NetMQActor,The following statement contains a magic number: actorName = $"NetMQActor-{random.Next(0' 10000)}-{random.Next(0' 10000)}";
Magic Number,NetMQ,NetMQFrame,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\NetMQFrame.cs,GetHashCode,The following statement contains a magic number: m_hash = (31*m_hash) ^ b;
Magic Number,NetMQ,NetMQQueue<T>,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\NetMQQueue.cs,NetMQQueue,The following statement contains a magic number: PairSocket.CreateSocketPair(out m_writer'                                          out m_reader'                                          writer => writer.Options.SendHighWatermark = capacity / 2'                                          reader => reader.Options.ReceiveHighWatermark = capacity / 2);
Magic Number,NetMQ,NetMQQueue<T>,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\NetMQQueue.cs,NetMQQueue,The following statement contains a magic number: PairSocket.CreateSocketPair(out m_writer'                                          out m_reader'                                          writer => writer.Options.SendHighWatermark = capacity / 2'                                          reader => reader.Options.ReceiveHighWatermark = capacity / 2);
Magic Number,NetMQ,NetworkOrderBitsConverter,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,ToInt16,The following statement contains a magic number: var i = buffer[0] << 8 |                      buffer[1];
Magic Number,NetMQ,NetworkOrderBitsConverter,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,GetBytes,The following statement contains a magic number: var buffer = new byte[2];
Magic Number,NetMQ,NetworkOrderBitsConverter,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,PutInt16,The following statement contains a magic number: buffer[0] = (byte)(value >> 8);
Magic Number,NetMQ,NetworkOrderBitsConverter,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,ToInt32,The following statement contains a magic number: return                   buffer[0] << 24 |                  buffer[1] << 16 |                   buffer[2] <<  8 |                   buffer[3];
Magic Number,NetMQ,NetworkOrderBitsConverter,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,ToInt32,The following statement contains a magic number: return                   buffer[0] << 24 |                  buffer[1] << 16 |                   buffer[2] <<  8 |                   buffer[3];
Magic Number,NetMQ,NetworkOrderBitsConverter,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,ToInt32,The following statement contains a magic number: return                   buffer[0] << 24 |                  buffer[1] << 16 |                   buffer[2] <<  8 |                   buffer[3];
Magic Number,NetMQ,NetworkOrderBitsConverter,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,ToInt32,The following statement contains a magic number: return                   buffer[0] << 24 |                  buffer[1] << 16 |                   buffer[2] <<  8 |                   buffer[3];
Magic Number,NetMQ,NetworkOrderBitsConverter,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,ToInt32,The following statement contains a magic number: return                   buffer[0] << 24 |                  buffer[1] << 16 |                   buffer[2] <<  8 |                   buffer[3];
Magic Number,NetMQ,NetworkOrderBitsConverter,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,GetBytes,The following statement contains a magic number: var buffer = new byte[4];
Magic Number,NetMQ,NetworkOrderBitsConverter,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,PutInt32,The following statement contains a magic number: buffer[0] = (byte)(value >> 24);
Magic Number,NetMQ,NetworkOrderBitsConverter,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,PutInt32,The following statement contains a magic number: buffer[1] = (byte)(value >> 16);
Magic Number,NetMQ,NetworkOrderBitsConverter,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,PutInt32,The following statement contains a magic number: buffer[2] = (byte)(value >>  8);
Magic Number,NetMQ,NetworkOrderBitsConverter,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,PutInt32,The following statement contains a magic number: buffer[2] = (byte)(value >>  8);
Magic Number,NetMQ,NetworkOrderBitsConverter,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,PutInt32,The following statement contains a magic number: buffer[3] = (byte) value;
Magic Number,NetMQ,NetworkOrderBitsConverter,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,ToInt64,The following statement contains a magic number: return                  (long)buffer[0] << 56 |                  (long)buffer[1] << 48 |                  (long)buffer[2] << 40 |                  (long)buffer[3] << 32 |                  (long)buffer[4] << 24 |                  (long)buffer[5] << 16 |                  (long)buffer[6] <<  8 |                  (long)buffer[7];
Magic Number,NetMQ,NetworkOrderBitsConverter,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,ToInt64,The following statement contains a magic number: return                  (long)buffer[0] << 56 |                  (long)buffer[1] << 48 |                  (long)buffer[2] << 40 |                  (long)buffer[3] << 32 |                  (long)buffer[4] << 24 |                  (long)buffer[5] << 16 |                  (long)buffer[6] <<  8 |                  (long)buffer[7];
Magic Number,NetMQ,NetworkOrderBitsConverter,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,ToInt64,The following statement contains a magic number: return                  (long)buffer[0] << 56 |                  (long)buffer[1] << 48 |                  (long)buffer[2] << 40 |                  (long)buffer[3] << 32 |                  (long)buffer[4] << 24 |                  (long)buffer[5] << 16 |                  (long)buffer[6] <<  8 |                  (long)buffer[7];
Magic Number,NetMQ,NetworkOrderBitsConverter,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,ToInt64,The following statement contains a magic number: return                  (long)buffer[0] << 56 |                  (long)buffer[1] << 48 |                  (long)buffer[2] << 40 |                  (long)buffer[3] << 32 |                  (long)buffer[4] << 24 |                  (long)buffer[5] << 16 |                  (long)buffer[6] <<  8 |                  (long)buffer[7];
Magic Number,NetMQ,NetworkOrderBitsConverter,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,ToInt64,The following statement contains a magic number: return                  (long)buffer[0] << 56 |                  (long)buffer[1] << 48 |                  (long)buffer[2] << 40 |                  (long)buffer[3] << 32 |                  (long)buffer[4] << 24 |                  (long)buffer[5] << 16 |                  (long)buffer[6] <<  8 |                  (long)buffer[7];
Magic Number,NetMQ,NetworkOrderBitsConverter,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,ToInt64,The following statement contains a magic number: return                  (long)buffer[0] << 56 |                  (long)buffer[1] << 48 |                  (long)buffer[2] << 40 |                  (long)buffer[3] << 32 |                  (long)buffer[4] << 24 |                  (long)buffer[5] << 16 |                  (long)buffer[6] <<  8 |                  (long)buffer[7];
Magic Number,NetMQ,NetworkOrderBitsConverter,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,ToInt64,The following statement contains a magic number: return                  (long)buffer[0] << 56 |                  (long)buffer[1] << 48 |                  (long)buffer[2] << 40 |                  (long)buffer[3] << 32 |                  (long)buffer[4] << 24 |                  (long)buffer[5] << 16 |                  (long)buffer[6] <<  8 |                  (long)buffer[7];
Magic Number,NetMQ,NetworkOrderBitsConverter,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,ToInt64,The following statement contains a magic number: return                  (long)buffer[0] << 56 |                  (long)buffer[1] << 48 |                  (long)buffer[2] << 40 |                  (long)buffer[3] << 32 |                  (long)buffer[4] << 24 |                  (long)buffer[5] << 16 |                  (long)buffer[6] <<  8 |                  (long)buffer[7];
Magic Number,NetMQ,NetworkOrderBitsConverter,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,ToInt64,The following statement contains a magic number: return                  (long)buffer[0] << 56 |                  (long)buffer[1] << 48 |                  (long)buffer[2] << 40 |                  (long)buffer[3] << 32 |                  (long)buffer[4] << 24 |                  (long)buffer[5] << 16 |                  (long)buffer[6] <<  8 |                  (long)buffer[7];
Magic Number,NetMQ,NetworkOrderBitsConverter,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,ToInt64,The following statement contains a magic number: return                  (long)buffer[0] << 56 |                  (long)buffer[1] << 48 |                  (long)buffer[2] << 40 |                  (long)buffer[3] << 32 |                  (long)buffer[4] << 24 |                  (long)buffer[5] << 16 |                  (long)buffer[6] <<  8 |                  (long)buffer[7];
Magic Number,NetMQ,NetworkOrderBitsConverter,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,ToInt64,The following statement contains a magic number: return                  (long)buffer[0] << 56 |                  (long)buffer[1] << 48 |                  (long)buffer[2] << 40 |                  (long)buffer[3] << 32 |                  (long)buffer[4] << 24 |                  (long)buffer[5] << 16 |                  (long)buffer[6] <<  8 |                  (long)buffer[7];
Magic Number,NetMQ,NetworkOrderBitsConverter,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,ToInt64,The following statement contains a magic number: return                  (long)buffer[0] << 56 |                  (long)buffer[1] << 48 |                  (long)buffer[2] << 40 |                  (long)buffer[3] << 32 |                  (long)buffer[4] << 24 |                  (long)buffer[5] << 16 |                  (long)buffer[6] <<  8 |                  (long)buffer[7];
Magic Number,NetMQ,NetworkOrderBitsConverter,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,ToInt64,The following statement contains a magic number: return                  (long)buffer[0] << 56 |                  (long)buffer[1] << 48 |                  (long)buffer[2] << 40 |                  (long)buffer[3] << 32 |                  (long)buffer[4] << 24 |                  (long)buffer[5] << 16 |                  (long)buffer[6] <<  8 |                  (long)buffer[7];
Magic Number,NetMQ,NetworkOrderBitsConverter,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,GetBytes,The following statement contains a magic number: var buffer = new byte[8];
Magic Number,NetMQ,NetworkOrderBitsConverter,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,PutInt64,The following statement contains a magic number: buffer[0] = (byte)(value >> 56);
Magic Number,NetMQ,NetworkOrderBitsConverter,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,PutInt64,The following statement contains a magic number: buffer[1] = (byte)(value >> 48);
Magic Number,NetMQ,NetworkOrderBitsConverter,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,PutInt64,The following statement contains a magic number: buffer[2] = (byte)(value >> 40);
Magic Number,NetMQ,NetworkOrderBitsConverter,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,PutInt64,The following statement contains a magic number: buffer[2] = (byte)(value >> 40);
Magic Number,NetMQ,NetworkOrderBitsConverter,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,PutInt64,The following statement contains a magic number: buffer[3] = (byte)(value >> 32);
Magic Number,NetMQ,NetworkOrderBitsConverter,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,PutInt64,The following statement contains a magic number: buffer[3] = (byte)(value >> 32);
Magic Number,NetMQ,NetworkOrderBitsConverter,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,PutInt64,The following statement contains a magic number: buffer[4] = (byte)(value >> 24);
Magic Number,NetMQ,NetworkOrderBitsConverter,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,PutInt64,The following statement contains a magic number: buffer[4] = (byte)(value >> 24);
Magic Number,NetMQ,NetworkOrderBitsConverter,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,PutInt64,The following statement contains a magic number: buffer[5] = (byte)(value >> 16);
Magic Number,NetMQ,NetworkOrderBitsConverter,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,PutInt64,The following statement contains a magic number: buffer[5] = (byte)(value >> 16);
Magic Number,NetMQ,NetworkOrderBitsConverter,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,PutInt64,The following statement contains a magic number: buffer[6] = (byte)(value >> 8);
Magic Number,NetMQ,NetworkOrderBitsConverter,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,PutInt64,The following statement contains a magic number: buffer[6] = (byte)(value >> 8);
Magic Number,NetMQ,NetworkOrderBitsConverter,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,PutInt64,The following statement contains a magic number: buffer[7] = (byte) value;
Magic Number,NetMQ,OutgoingSocketExtensions,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\OutgoingSocketExtensions.cs,Signal,The following statement contains a magic number: msg.InitPool(8);
Magic Number,NetMQ,OutgoingSocketExtensions,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\OutgoingSocketExtensions.cs,TrySignal,The following statement contains a magic number: msg.InitPool(8);
Magic Number,NetMQ,ReceivingSocketExtensions,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\ReceivingSocketExtensions.cs,ReceiveSignal,The following statement contains a magic number: isMultiFrame || msg.Size != 8
Magic Number,NetMQ,ReceivingSocketExtensions,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\ReceivingSocketExtensions.cs,ReceiveSignal,The following statement contains a magic number: return (signalValue & 255) == 0;
Magic Number,NetMQ,ReceivingSocketExtensions,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\ReceivingSocketExtensions.cs,TryReceiveSignal,The following statement contains a magic number: isMultiFrame || msg.Size != 8
Magic Number,NetMQ,ReceivingSocketExtensions,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\ReceivingSocketExtensions.cs,TryReceiveSignal,The following statement contains a magic number: signal = (signalValue & 255) == 0;
Magic Number,NetMQ,RoutingKey,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\RoutingKey.cs,GetHashCode,The following statement contains a magic number: int remainder = bytes.Length & 3;
Magic Number,NetMQ,RoutingKey,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\RoutingKey.cs,GetHashCode,The following statement contains a magic number: var k = (uint)(bytes[i] | bytes[i + 1] << 8 | bytes[i + 2] << 16 | bytes[i + 3] << 24);
Magic Number,NetMQ,RoutingKey,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\RoutingKey.cs,GetHashCode,The following statement contains a magic number: var k = (uint)(bytes[i] | bytes[i + 1] << 8 | bytes[i + 2] << 16 | bytes[i + 3] << 24);
Magic Number,NetMQ,RoutingKey,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\RoutingKey.cs,GetHashCode,The following statement contains a magic number: var k = (uint)(bytes[i] | bytes[i + 1] << 8 | bytes[i + 2] << 16 | bytes[i + 3] << 24);
Magic Number,NetMQ,RoutingKey,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\RoutingKey.cs,GetHashCode,The following statement contains a magic number: var k = (uint)(bytes[i] | bytes[i + 1] << 8 | bytes[i + 2] << 16 | bytes[i + 3] << 24);
Magic Number,NetMQ,RoutingKey,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\RoutingKey.cs,GetHashCode,The following statement contains a magic number: var k = (uint)(bytes[i] | bytes[i + 1] << 8 | bytes[i + 2] << 16 | bytes[i + 3] << 24);
Magic Number,NetMQ,RoutingKey,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\RoutingKey.cs,GetHashCode,The following statement contains a magic number: k = (k << 15) | (k >> (32 - 15));
Magic Number,NetMQ,RoutingKey,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\RoutingKey.cs,GetHashCode,The following statement contains a magic number: k = (k << 15) | (k >> (32 - 15));
Magic Number,NetMQ,RoutingKey,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\RoutingKey.cs,GetHashCode,The following statement contains a magic number: k = (k << 15) | (k >> (32 - 15));
Magic Number,NetMQ,RoutingKey,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\RoutingKey.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 13) | (hash >> (32 - 13));
Magic Number,NetMQ,RoutingKey,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\RoutingKey.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 13) | (hash >> (32 - 13));
Magic Number,NetMQ,RoutingKey,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\RoutingKey.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 13) | (hash >> (32 - 13));
Magic Number,NetMQ,RoutingKey,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\RoutingKey.cs,GetHashCode,The following statement contains a magic number: hash = (hash * 5) + 0xe6546b64;
Magic Number,NetMQ,RoutingKey,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\RoutingKey.cs,GetHashCode,The following statement contains a magic number: switch (remainder)                      {                          case 3:                              k ^= (uint)bytes[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)bytes[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= bytes[alignedLength];                              break;                      }
Magic Number,NetMQ,RoutingKey,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\RoutingKey.cs,GetHashCode,The following statement contains a magic number: switch (remainder)                      {                          case 3:                              k ^= (uint)bytes[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)bytes[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= bytes[alignedLength];                              break;                      }
Magic Number,NetMQ,RoutingKey,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\RoutingKey.cs,GetHashCode,The following statement contains a magic number: switch (remainder)                      {                          case 3:                              k ^= (uint)bytes[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)bytes[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= bytes[alignedLength];                              break;                      }
Magic Number,NetMQ,RoutingKey,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\RoutingKey.cs,GetHashCode,The following statement contains a magic number: switch (remainder)                      {                          case 3:                              k ^= (uint)bytes[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)bytes[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= bytes[alignedLength];                              break;                      }
Magic Number,NetMQ,RoutingKey,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\RoutingKey.cs,GetHashCode,The following statement contains a magic number: switch (remainder)                      {                          case 3:                              k ^= (uint)bytes[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)bytes[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= bytes[alignedLength];                              break;                      }
Magic Number,NetMQ,RoutingKey,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\RoutingKey.cs,GetHashCode,The following statement contains a magic number: switch (remainder)                      {                          case 3:                              k ^= (uint)bytes[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)bytes[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= bytes[alignedLength];                              break;                      }
Magic Number,NetMQ,RoutingKey,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\RoutingKey.cs,GetHashCode,The following statement contains a magic number: k = (k << 15) | (k >> (32 - 15));
Magic Number,NetMQ,RoutingKey,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\RoutingKey.cs,GetHashCode,The following statement contains a magic number: k = (k << 15) | (k >> (32 - 15));
Magic Number,NetMQ,RoutingKey,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\RoutingKey.cs,GetHashCode,The following statement contains a magic number: k = (k << 15) | (k >> (32 - 15));
Magic Number,NetMQ,RoutingKey,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\RoutingKey.cs,GetHashCode,The following statement contains a magic number: hash ^= hash >> 16;
Magic Number,NetMQ,RoutingKey,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\RoutingKey.cs,GetHashCode,The following statement contains a magic number: hash ^= hash >> 13;
Magic Number,NetMQ,RoutingKey,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\RoutingKey.cs,GetHashCode,The following statement contains a magic number: hash ^= hash >> 16;
Magic Number,NetMQ.Core,Ctx,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Ctx.cs,CreateSocket,The following statement contains a magic number: m_slotCount = mazmq + ios + 2;
Magic Number,NetMQ.Core,Ctx,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Ctx.cs,CreateSocket,The following statement contains a magic number: i != ios + 2
Magic Number,NetMQ.Core,Ctx,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Ctx.cs,CreateSocket,The following statement contains a magic number: i >= ios + 2
Magic Number,NetMQ.Core,MonitorEvent,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\MonitorEvent.cs,MonitorEvent,The following statement contains a magic number: s_sizeOfIntPtr = 8;
Magic Number,NetMQ.Core,MonitorEvent,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\MonitorEvent.cs,MonitorEvent,The following statement contains a magic number: s_sizeOfIntPtr > 4
Magic Number,NetMQ.Core,MonitorEvent,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\MonitorEvent.cs,Write,The following statement contains a magic number: int size = 4 + 1 + (m_addr?.Length ?? 0) + 1;
Magic Number,NetMQ.Core,MonitorEvent,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\MonitorEvent.cs,Write,The following statement contains a magic number: size += 4;
Magic Number,NetMQ.Core,MonitorEvent,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\MonitorEvent.cs,Write,The following statement contains a magic number: pos += 4;
Magic Number,NetMQ.Core,MonitorEvent,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\MonitorEvent.cs,Read,The following statement contains a magic number: pos += 4;
Magic Number,NetMQ.Core,Options,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Options.cs,Options,The following statement contains a magic number: Backlog = 100;
Magic Number,NetMQ.Core,Options,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Options.cs,Options,The following statement contains a magic number: Rate = 100;
Magic Number,NetMQ.Core,Options,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Options.cs,Options,The following statement contains a magic number: ReceiveHighWatermark = 1000;
Magic Number,NetMQ.Core,Options,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Options.cs,Options,The following statement contains a magic number: ReconnectIvl = 100;
Magic Number,NetMQ.Core,Options,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Options.cs,Options,The following statement contains a magic number: RecoveryIvl = 10000;
Magic Number,NetMQ.Core,Options,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Options.cs,Options,The following statement contains a magic number: SendHighWatermark = 1000;
Magic Number,NetMQ.Core,Options,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Options.cs,SetSocketOption,The following statement contains a magic number: switch (option)              {                  case ZmqSocketOption.SendHighWatermark:                      SendHighWatermark = (int)optionValue;                      break;                    case ZmqSocketOption.ReceiveHighWatermark:                      ReceiveHighWatermark = (int)optionValue;                      break;                    case ZmqSocketOption.SendLowWatermark:                      SendLowWatermark = (int)optionValue;                      break;                    case ZmqSocketOption.ReceiveLowWatermark:                      ReceiveLowWatermark = (int)optionValue;                      break;                    case ZmqSocketOption.Affinity:                      Affinity = (long)optionValue;                      break;                    case ZmqSocketOption.Identity:                      byte[] val;                        if (optionValue is string)                          val = Encoding.ASCII.GetBytes((string)optionValue);                      else if (optionValue is byte[])                          val = (byte[])optionValue;                      else                          throw new InvalidException($"In Options.SetSocketOption(Identity' {optionValue?.ToString() ?? "null"}) optionValue must be a string or byte-array.");                        if (val.Length == 0 || val.Length > 255)                          throw new InvalidException($"In Options.SetSocketOption(Identity') optionValue yielded a byte-array of length {val.Length}' should be 1..255.");                      Identity = new byte[val.Length];                      val.CopyTo(Identity' 0);                      IdentitySize = (byte)Identity.Length;                      break;                    case ZmqSocketOption.Rate:                      Rate = (int)optionValue;                      break;                    case ZmqSocketOption.RecoveryIvl:                      RecoveryIvl = (int)optionValue;                      break;                    case ZmqSocketOption.SendBuffer:                      SendBuffer = (int)optionValue;                      break;                    case ZmqSocketOption.ReceiveBuffer:                      ReceiveBuffer = (int)optionValue;                      break;                    case ZmqSocketOption.Linger:                      Linger = (int)optionValue;                      break;                    case ZmqSocketOption.ReconnectIvl:                      var reconnectIvl = (int)optionValue;                      if (reconnectIvl < -1)                          throw new InvalidException($"Options.SetSocketOption(ReconnectIvl' {reconnectIvl}) optionValue must be >= -1.");                      ReconnectIvl = reconnectIvl;                      break;                    case ZmqSocketOption.ReconnectIvlMax:                      var reconnectIvlMax = (int)optionValue;                      if (reconnectIvlMax < 0)                          throw new InvalidException($"Options.SetSocketOption(ReconnectIvlMax' {reconnectIvlMax}) optionValue must be non-negative.");                      ReconnectIvlMax = reconnectIvlMax;                      break;                    case ZmqSocketOption.Backlog:                      Backlog = (int)optionValue;                      break;                    case ZmqSocketOption.MaxMessageSize:                      MaxMessageSize = (long)optionValue;                      break;                    case ZmqSocketOption.MulticastHops:                      MulticastHops = (int)optionValue;                      break;                    case ZmqSocketOption.SendTimeout:                      SendTimeout = (int)optionValue;                      break;                    case ZmqSocketOption.IPv4Only:                      IPv4Only = (bool)optionValue;                      break;                    case ZmqSocketOption.TcpKeepalive:                      var tcpKeepalive = (int)optionValue;                      if (tcpKeepalive != -1 && tcpKeepalive != 0 && tcpKeepalive != 1)                          throw new InvalidException($"Options.SetSocketOption(TcpKeepalive' {tcpKeepalive}) optionValue is neither -1' 0' nor 1.");                      TcpKeepalive = tcpKeepalive;                      break;                    case ZmqSocketOption.DelayAttachOnConnect:                      DelayAttachOnConnect = (bool)optionValue;                      break;                    case ZmqSocketOption.TcpKeepaliveIdle:                      TcpKeepaliveIdle = (int)optionValue;                      break;                    case ZmqSocketOption.TcpKeepaliveIntvl:                      TcpKeepaliveIntvl = (int)optionValue;                      break;                    case ZmqSocketOption.Endian:                      Endian = (Endianness)optionValue;                      break;                    case ZmqSocketOption.DisableTimeWait:                      DisableTimeWait = (bool)optionValue;                      break;                    case ZmqSocketOption.PgmMaxTransportServiceDataUnitLength:                      PgmMaxTransportServiceDataUnitLength = (int)optionValue;                      break;                    default:                      throw new InvalidException("Options.SetSocketOption called with invalid ZmqSocketOption of " + option);              }
Magic Number,NetMQ.Core,Pipe,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Pipe.cs,ComputeLowWatermark,The following statement contains a magic number: int result = (highWatermark > Config.MaxWatermarkDelta*2)                  ? highWatermark - Config.MaxWatermarkDelta                  : (highWatermark + 1)/2;
Magic Number,NetMQ.Core,Pipe,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Pipe.cs,ComputeLowWatermark,The following statement contains a magic number: int result = (highWatermark > Config.MaxWatermarkDelta*2)                  ? highWatermark - Config.MaxWatermarkDelta                  : (highWatermark + 1)/2;
Magic Number,NetMQ.Core.Patterns,Router,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Router.cs,IdentifyPeer,The following statement contains a magic number: identity = new byte[5];
Magic Number,NetMQ.Core.Patterns,Router,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Router.cs,IdentifyPeer,The following statement contains a magic number: Buffer.BlockCopy(result' 0' identity' 1' 4);
Magic Number,NetMQ.Core.Patterns,Stream,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Stream.cs,IdentifyPeer,The following statement contains a magic number: var identity = new byte[5];
Magic Number,NetMQ.Core.Patterns,Stream,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Stream.cs,IdentifyPeer,The following statement contains a magic number: Buffer.BlockCopy(result' 0' identity' 1' 4);
Magic Number,NetMQ.Core.Patterns,XPub,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Patterns\XPub.cs,XSetSocketOption,The following statement contains a magic number: switch (option)              {                  case ZmqSocketOption.XpubVerbose:                  {                      m_verbose = (bool)optionValue;                      return true;                  }                  case ZmqSocketOption.XPublisherManual:                  {                      m_manual = (bool)optionValue;                      return true;                  }                  case ZmqSocketOption.XPublisherBroadcast:                  {                      m_broadcastEnabled = (bool)optionValue;                      return true;                  }                  case ZmqSocketOption.Identity:                  {                      if (m_manual && m_lastPipe != null)                      {                          byte[] val;                            if (optionValue is string)                              val = Encoding.ASCII.GetBytes((string)optionValue);                          else if (optionValue is byte[])                              val = (byte[])optionValue;                          else                              throw new InvalidException($"In XPub.XSetSocketOption(Identity' {optionValue?.ToString() ?? "null"}) optionValue must be a string or byte-array.");                          if (val.Length == 0 || val.Length > 255)                              throw new InvalidException($"In XPub.XSetSocketOption(Identity') optionValue yielded a byte-array of length {val.Length}' should be 1..255.");                            m_lastPipe.Identity = val;                          m_options.Identity = val;                      }                      return true;                  }                    case ZmqSocketOption.Subscribe:                  {                      if (m_manual && m_lastPipe != null)                      {                          var subscription = optionValue as byte[] ?? Encoding.ASCII.GetBytes((string)optionValue);                          m_subscriptions.Add(subscription' 0' subscription.Length' m_lastPipe);                          m_lastPipe = null;                          return true;                      }                      break;                  }                  case ZmqSocketOption.Unsubscribe:                  {                      if (m_manual && m_lastPipe != null)                      {                          var subscription = optionValue as byte[] ?? Encoding.ASCII.GetBytes((string)optionValue);                          m_subscriptions.Remove(subscription' 0' subscription.Length' m_lastPipe);                          m_lastPipe = null;                          return true;                      }                      break;                  }                  case ZmqSocketOption.XPublisherWelcomeMessage:                  {                      m_welcomeMessage.Close();                        if (optionValue != null)                      {                          var bytes = optionValue as byte[];                          if (bytes == null)                              throw new InvalidException($"In XPub.XSetSocketOption({option}'{optionValue})' optionValue must be a byte-array.");                          var welcomeBytes = new byte[bytes.Length];                          bytes.CopyTo(welcomeBytes' 0);                          m_welcomeMessage.InitGC(welcomeBytes' welcomeBytes.Length);                      }                      else                      {                          m_welcomeMessage.InitEmpty();                      }                        return true;                  }              }
Magic Number,NetMQ.Core.Patterns,XPub,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Patterns\XPub.cs,XRecv,The following statement contains a magic number: !m_moreIn && m_broadcastEnabled && msg[0] == 2
Magic Number,NetMQ.Core.Patterns.Utils,MultiTrie,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Utils\MultiTrie.cs,RemoveHelper,The following statement contains a magic number: maxBufferSize = bufferSize + 256;
Magic Number,NetMQ.Core.Patterns.Utils,Trie,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Utils\Trie.cs,ApplyHelper,The following statement contains a magic number: maxBufferSize = bufferSize + 256;
Magic Number,NetMQ.Core.Transports,ByteArraySegment,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,PutLong,The following statement contains a magic number: m_innerBuffer[i + Offset] = (byte)(((value) >> 56) & 0xff);
Magic Number,NetMQ.Core.Transports,ByteArraySegment,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,PutLong,The following statement contains a magic number: m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 48) & 0xff);
Magic Number,NetMQ.Core.Transports,ByteArraySegment,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,PutLong,The following statement contains a magic number: m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 40) & 0xff);
Magic Number,NetMQ.Core.Transports,ByteArraySegment,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,PutLong,The following statement contains a magic number: m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 40) & 0xff);
Magic Number,NetMQ.Core.Transports,ByteArraySegment,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,PutLong,The following statement contains a magic number: m_innerBuffer[i + Offset + 3] = (byte)(((value) >> 32) & 0xff);
Magic Number,NetMQ.Core.Transports,ByteArraySegment,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,PutLong,The following statement contains a magic number: m_innerBuffer[i + Offset + 3] = (byte)(((value) >> 32) & 0xff);
Magic Number,NetMQ.Core.Transports,ByteArraySegment,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,PutLong,The following statement contains a magic number: m_innerBuffer[i + Offset + 4] = (byte)(((value) >> 24) & 0xff);
Magic Number,NetMQ.Core.Transports,ByteArraySegment,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,PutLong,The following statement contains a magic number: m_innerBuffer[i + Offset + 4] = (byte)(((value) >> 24) & 0xff);
Magic Number,NetMQ.Core.Transports,ByteArraySegment,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,PutLong,The following statement contains a magic number: m_innerBuffer[i + Offset + 5] = (byte)(((value) >> 16) & 0xff);
Magic Number,NetMQ.Core.Transports,ByteArraySegment,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,PutLong,The following statement contains a magic number: m_innerBuffer[i + Offset + 5] = (byte)(((value) >> 16) & 0xff);
Magic Number,NetMQ.Core.Transports,ByteArraySegment,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,PutLong,The following statement contains a magic number: m_innerBuffer[i + Offset + 6] = (byte)(((value) >> 8) & 0xff);
Magic Number,NetMQ.Core.Transports,ByteArraySegment,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,PutLong,The following statement contains a magic number: m_innerBuffer[i + Offset + 6] = (byte)(((value) >> 8) & 0xff);
Magic Number,NetMQ.Core.Transports,ByteArraySegment,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,PutLong,The following statement contains a magic number: m_innerBuffer[i + Offset + 7] = (byte)(value & 0xff);
Magic Number,NetMQ.Core.Transports,ByteArraySegment,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,PutUnsignedShort,The following statement contains a magic number: m_innerBuffer[i + Offset] = (byte)(((value) >> 8) & 0xff);
Magic Number,NetMQ.Core.Transports,ByteArraySegment,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,PutInteger,The following statement contains a magic number: m_innerBuffer[i + Offset] = (byte)(((value) >> 24) & 0xff);
Magic Number,NetMQ.Core.Transports,ByteArraySegment,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,PutInteger,The following statement contains a magic number: m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 16) & 0xff);
Magic Number,NetMQ.Core.Transports,ByteArraySegment,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,PutInteger,The following statement contains a magic number: m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 8) & 0xff);
Magic Number,NetMQ.Core.Transports,ByteArraySegment,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,PutInteger,The following statement contains a magic number: m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 8) & 0xff);
Magic Number,NetMQ.Core.Transports,ByteArraySegment,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,PutInteger,The following statement contains a magic number: m_innerBuffer[i + Offset + 3] = (byte)(value & 0xff);
Magic Number,NetMQ.Core.Transports,ByteArraySegment,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetLong,The following statement contains a magic number: return                      (((long)m_innerBuffer[i + Offset]) << 56) |                      (((long)m_innerBuffer[i + Offset + 1]) << 48) |                      (((long)m_innerBuffer[i + Offset + 2]) << 40) |                      (((long)m_innerBuffer[i + Offset + 3]) << 32) |                      (((long)m_innerBuffer[i + Offset + 4]) << 24) |                      (((long)m_innerBuffer[i + Offset + 5]) << 16) |                      (((long)m_innerBuffer[i + Offset + 6]) << 8) |                      ((long)m_innerBuffer[i + Offset + 7]);
Magic Number,NetMQ.Core.Transports,ByteArraySegment,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetLong,The following statement contains a magic number: return                      (((long)m_innerBuffer[i + Offset]) << 56) |                      (((long)m_innerBuffer[i + Offset + 1]) << 48) |                      (((long)m_innerBuffer[i + Offset + 2]) << 40) |                      (((long)m_innerBuffer[i + Offset + 3]) << 32) |                      (((long)m_innerBuffer[i + Offset + 4]) << 24) |                      (((long)m_innerBuffer[i + Offset + 5]) << 16) |                      (((long)m_innerBuffer[i + Offset + 6]) << 8) |                      ((long)m_innerBuffer[i + Offset + 7]);
Magic Number,NetMQ.Core.Transports,ByteArraySegment,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetLong,The following statement contains a magic number: return                      (((long)m_innerBuffer[i + Offset]) << 56) |                      (((long)m_innerBuffer[i + Offset + 1]) << 48) |                      (((long)m_innerBuffer[i + Offset + 2]) << 40) |                      (((long)m_innerBuffer[i + Offset + 3]) << 32) |                      (((long)m_innerBuffer[i + Offset + 4]) << 24) |                      (((long)m_innerBuffer[i + Offset + 5]) << 16) |                      (((long)m_innerBuffer[i + Offset + 6]) << 8) |                      ((long)m_innerBuffer[i + Offset + 7]);
Magic Number,NetMQ.Core.Transports,ByteArraySegment,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetLong,The following statement contains a magic number: return                      (((long)m_innerBuffer[i + Offset]) << 56) |                      (((long)m_innerBuffer[i + Offset + 1]) << 48) |                      (((long)m_innerBuffer[i + Offset + 2]) << 40) |                      (((long)m_innerBuffer[i + Offset + 3]) << 32) |                      (((long)m_innerBuffer[i + Offset + 4]) << 24) |                      (((long)m_innerBuffer[i + Offset + 5]) << 16) |                      (((long)m_innerBuffer[i + Offset + 6]) << 8) |                      ((long)m_innerBuffer[i + Offset + 7]);
Magic Number,NetMQ.Core.Transports,ByteArraySegment,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetLong,The following statement contains a magic number: return                      (((long)m_innerBuffer[i + Offset]) << 56) |                      (((long)m_innerBuffer[i + Offset + 1]) << 48) |                      (((long)m_innerBuffer[i + Offset + 2]) << 40) |                      (((long)m_innerBuffer[i + Offset + 3]) << 32) |                      (((long)m_innerBuffer[i + Offset + 4]) << 24) |                      (((long)m_innerBuffer[i + Offset + 5]) << 16) |                      (((long)m_innerBuffer[i + Offset + 6]) << 8) |                      ((long)m_innerBuffer[i + Offset + 7]);
Magic Number,NetMQ.Core.Transports,ByteArraySegment,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetLong,The following statement contains a magic number: return                      (((long)m_innerBuffer[i + Offset]) << 56) |                      (((long)m_innerBuffer[i + Offset + 1]) << 48) |                      (((long)m_innerBuffer[i + Offset + 2]) << 40) |                      (((long)m_innerBuffer[i + Offset + 3]) << 32) |                      (((long)m_innerBuffer[i + Offset + 4]) << 24) |                      (((long)m_innerBuffer[i + Offset + 5]) << 16) |                      (((long)m_innerBuffer[i + Offset + 6]) << 8) |                      ((long)m_innerBuffer[i + Offset + 7]);
Magic Number,NetMQ.Core.Transports,ByteArraySegment,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetLong,The following statement contains a magic number: return                      (((long)m_innerBuffer[i + Offset]) << 56) |                      (((long)m_innerBuffer[i + Offset + 1]) << 48) |                      (((long)m_innerBuffer[i + Offset + 2]) << 40) |                      (((long)m_innerBuffer[i + Offset + 3]) << 32) |                      (((long)m_innerBuffer[i + Offset + 4]) << 24) |                      (((long)m_innerBuffer[i + Offset + 5]) << 16) |                      (((long)m_innerBuffer[i + Offset + 6]) << 8) |                      ((long)m_innerBuffer[i + Offset + 7]);
Magic Number,NetMQ.Core.Transports,ByteArraySegment,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetLong,The following statement contains a magic number: return                      (((long)m_innerBuffer[i + Offset]) << 56) |                      (((long)m_innerBuffer[i + Offset + 1]) << 48) |                      (((long)m_innerBuffer[i + Offset + 2]) << 40) |                      (((long)m_innerBuffer[i + Offset + 3]) << 32) |                      (((long)m_innerBuffer[i + Offset + 4]) << 24) |                      (((long)m_innerBuffer[i + Offset + 5]) << 16) |                      (((long)m_innerBuffer[i + Offset + 6]) << 8) |                      ((long)m_innerBuffer[i + Offset + 7]);
Magic Number,NetMQ.Core.Transports,ByteArraySegment,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetLong,The following statement contains a magic number: return                      (((long)m_innerBuffer[i + Offset]) << 56) |                      (((long)m_innerBuffer[i + Offset + 1]) << 48) |                      (((long)m_innerBuffer[i + Offset + 2]) << 40) |                      (((long)m_innerBuffer[i + Offset + 3]) << 32) |                      (((long)m_innerBuffer[i + Offset + 4]) << 24) |                      (((long)m_innerBuffer[i + Offset + 5]) << 16) |                      (((long)m_innerBuffer[i + Offset + 6]) << 8) |                      ((long)m_innerBuffer[i + Offset + 7]);
Magic Number,NetMQ.Core.Transports,ByteArraySegment,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetLong,The following statement contains a magic number: return                      (((long)m_innerBuffer[i + Offset]) << 56) |                      (((long)m_innerBuffer[i + Offset + 1]) << 48) |                      (((long)m_innerBuffer[i + Offset + 2]) << 40) |                      (((long)m_innerBuffer[i + Offset + 3]) << 32) |                      (((long)m_innerBuffer[i + Offset + 4]) << 24) |                      (((long)m_innerBuffer[i + Offset + 5]) << 16) |                      (((long)m_innerBuffer[i + Offset + 6]) << 8) |                      ((long)m_innerBuffer[i + Offset + 7]);
Magic Number,NetMQ.Core.Transports,ByteArraySegment,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetLong,The following statement contains a magic number: return                      (((long)m_innerBuffer[i + Offset]) << 56) |                      (((long)m_innerBuffer[i + Offset + 1]) << 48) |                      (((long)m_innerBuffer[i + Offset + 2]) << 40) |                      (((long)m_innerBuffer[i + Offset + 3]) << 32) |                      (((long)m_innerBuffer[i + Offset + 4]) << 24) |                      (((long)m_innerBuffer[i + Offset + 5]) << 16) |                      (((long)m_innerBuffer[i + Offset + 6]) << 8) |                      ((long)m_innerBuffer[i + Offset + 7]);
Magic Number,NetMQ.Core.Transports,ByteArraySegment,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetLong,The following statement contains a magic number: return                      (((long)m_innerBuffer[i + Offset]) << 56) |                      (((long)m_innerBuffer[i + Offset + 1]) << 48) |                      (((long)m_innerBuffer[i + Offset + 2]) << 40) |                      (((long)m_innerBuffer[i + Offset + 3]) << 32) |                      (((long)m_innerBuffer[i + Offset + 4]) << 24) |                      (((long)m_innerBuffer[i + Offset + 5]) << 16) |                      (((long)m_innerBuffer[i + Offset + 6]) << 8) |                      ((long)m_innerBuffer[i + Offset + 7]);
Magic Number,NetMQ.Core.Transports,ByteArraySegment,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetLong,The following statement contains a magic number: return                      (((long)m_innerBuffer[i + Offset]) << 56) |                      (((long)m_innerBuffer[i + Offset + 1]) << 48) |                      (((long)m_innerBuffer[i + Offset + 2]) << 40) |                      (((long)m_innerBuffer[i + Offset + 3]) << 32) |                      (((long)m_innerBuffer[i + Offset + 4]) << 24) |                      (((long)m_innerBuffer[i + Offset + 5]) << 16) |                      (((long)m_innerBuffer[i + Offset + 6]) << 8) |                      ((long)m_innerBuffer[i + Offset + 7]);
Magic Number,NetMQ.Core.Transports,ByteArraySegment,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetUnsignedLong,The following statement contains a magic number: return                      (((ulong)m_innerBuffer[i + Offset]) << 56) |                      (((ulong)m_innerBuffer[i + Offset + 1]) << 48) |                      (((ulong)m_innerBuffer[i + Offset + 2]) << 40) |                      (((ulong)m_innerBuffer[i + Offset + 3]) << 32) |                      (((ulong)m_innerBuffer[i + Offset + 4]) << 24) |                      (((ulong)m_innerBuffer[i + Offset + 5]) << 16) |                      (((ulong)m_innerBuffer[i + Offset + 6]) << 8) |                      ((ulong)m_innerBuffer[i + Offset + 7]);
Magic Number,NetMQ.Core.Transports,ByteArraySegment,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetUnsignedLong,The following statement contains a magic number: return                      (((ulong)m_innerBuffer[i + Offset]) << 56) |                      (((ulong)m_innerBuffer[i + Offset + 1]) << 48) |                      (((ulong)m_innerBuffer[i + Offset + 2]) << 40) |                      (((ulong)m_innerBuffer[i + Offset + 3]) << 32) |                      (((ulong)m_innerBuffer[i + Offset + 4]) << 24) |                      (((ulong)m_innerBuffer[i + Offset + 5]) << 16) |                      (((ulong)m_innerBuffer[i + Offset + 6]) << 8) |                      ((ulong)m_innerBuffer[i + Offset + 7]);
Magic Number,NetMQ.Core.Transports,ByteArraySegment,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetUnsignedLong,The following statement contains a magic number: return                      (((ulong)m_innerBuffer[i + Offset]) << 56) |                      (((ulong)m_innerBuffer[i + Offset + 1]) << 48) |                      (((ulong)m_innerBuffer[i + Offset + 2]) << 40) |                      (((ulong)m_innerBuffer[i + Offset + 3]) << 32) |                      (((ulong)m_innerBuffer[i + Offset + 4]) << 24) |                      (((ulong)m_innerBuffer[i + Offset + 5]) << 16) |                      (((ulong)m_innerBuffer[i + Offset + 6]) << 8) |                      ((ulong)m_innerBuffer[i + Offset + 7]);
Magic Number,NetMQ.Core.Transports,ByteArraySegment,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetUnsignedLong,The following statement contains a magic number: return                      (((ulong)m_innerBuffer[i + Offset]) << 56) |                      (((ulong)m_innerBuffer[i + Offset + 1]) << 48) |                      (((ulong)m_innerBuffer[i + Offset + 2]) << 40) |                      (((ulong)m_innerBuffer[i + Offset + 3]) << 32) |                      (((ulong)m_innerBuffer[i + Offset + 4]) << 24) |                      (((ulong)m_innerBuffer[i + Offset + 5]) << 16) |                      (((ulong)m_innerBuffer[i + Offset + 6]) << 8) |                      ((ulong)m_innerBuffer[i + Offset + 7]);
Magic Number,NetMQ.Core.Transports,ByteArraySegment,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetUnsignedLong,The following statement contains a magic number: return                      (((ulong)m_innerBuffer[i + Offset]) << 56) |                      (((ulong)m_innerBuffer[i + Offset + 1]) << 48) |                      (((ulong)m_innerBuffer[i + Offset + 2]) << 40) |                      (((ulong)m_innerBuffer[i + Offset + 3]) << 32) |                      (((ulong)m_innerBuffer[i + Offset + 4]) << 24) |                      (((ulong)m_innerBuffer[i + Offset + 5]) << 16) |                      (((ulong)m_innerBuffer[i + Offset + 6]) << 8) |                      ((ulong)m_innerBuffer[i + Offset + 7]);
Magic Number,NetMQ.Core.Transports,ByteArraySegment,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetUnsignedLong,The following statement contains a magic number: return                      (((ulong)m_innerBuffer[i + Offset]) << 56) |                      (((ulong)m_innerBuffer[i + Offset + 1]) << 48) |                      (((ulong)m_innerBuffer[i + Offset + 2]) << 40) |                      (((ulong)m_innerBuffer[i + Offset + 3]) << 32) |                      (((ulong)m_innerBuffer[i + Offset + 4]) << 24) |                      (((ulong)m_innerBuffer[i + Offset + 5]) << 16) |                      (((ulong)m_innerBuffer[i + Offset + 6]) << 8) |                      ((ulong)m_innerBuffer[i + Offset + 7]);
Magic Number,NetMQ.Core.Transports,ByteArraySegment,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetUnsignedLong,The following statement contains a magic number: return                      (((ulong)m_innerBuffer[i + Offset]) << 56) |                      (((ulong)m_innerBuffer[i + Offset + 1]) << 48) |                      (((ulong)m_innerBuffer[i + Offset + 2]) << 40) |                      (((ulong)m_innerBuffer[i + Offset + 3]) << 32) |                      (((ulong)m_innerBuffer[i + Offset + 4]) << 24) |                      (((ulong)m_innerBuffer[i + Offset + 5]) << 16) |                      (((ulong)m_innerBuffer[i + Offset + 6]) << 8) |                      ((ulong)m_innerBuffer[i + Offset + 7]);
Magic Number,NetMQ.Core.Transports,ByteArraySegment,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetUnsignedLong,The following statement contains a magic number: return                      (((ulong)m_innerBuffer[i + Offset]) << 56) |                      (((ulong)m_innerBuffer[i + Offset + 1]) << 48) |                      (((ulong)m_innerBuffer[i + Offset + 2]) << 40) |                      (((ulong)m_innerBuffer[i + Offset + 3]) << 32) |                      (((ulong)m_innerBuffer[i + Offset + 4]) << 24) |                      (((ulong)m_innerBuffer[i + Offset + 5]) << 16) |                      (((ulong)m_innerBuffer[i + Offset + 6]) << 8) |                      ((ulong)m_innerBuffer[i + Offset + 7]);
Magic Number,NetMQ.Core.Transports,ByteArraySegment,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetUnsignedLong,The following statement contains a magic number: return                      (((ulong)m_innerBuffer[i + Offset]) << 56) |                      (((ulong)m_innerBuffer[i + Offset + 1]) << 48) |                      (((ulong)m_innerBuffer[i + Offset + 2]) << 40) |                      (((ulong)m_innerBuffer[i + Offset + 3]) << 32) |                      (((ulong)m_innerBuffer[i + Offset + 4]) << 24) |                      (((ulong)m_innerBuffer[i + Offset + 5]) << 16) |                      (((ulong)m_innerBuffer[i + Offset + 6]) << 8) |                      ((ulong)m_innerBuffer[i + Offset + 7]);
Magic Number,NetMQ.Core.Transports,ByteArraySegment,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetUnsignedLong,The following statement contains a magic number: return                      (((ulong)m_innerBuffer[i + Offset]) << 56) |                      (((ulong)m_innerBuffer[i + Offset + 1]) << 48) |                      (((ulong)m_innerBuffer[i + Offset + 2]) << 40) |                      (((ulong)m_innerBuffer[i + Offset + 3]) << 32) |                      (((ulong)m_innerBuffer[i + Offset + 4]) << 24) |                      (((ulong)m_innerBuffer[i + Offset + 5]) << 16) |                      (((ulong)m_innerBuffer[i + Offset + 6]) << 8) |                      ((ulong)m_innerBuffer[i + Offset + 7]);
Magic Number,NetMQ.Core.Transports,ByteArraySegment,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetUnsignedLong,The following statement contains a magic number: return                      (((ulong)m_innerBuffer[i + Offset]) << 56) |                      (((ulong)m_innerBuffer[i + Offset + 1]) << 48) |                      (((ulong)m_innerBuffer[i + Offset + 2]) << 40) |                      (((ulong)m_innerBuffer[i + Offset + 3]) << 32) |                      (((ulong)m_innerBuffer[i + Offset + 4]) << 24) |                      (((ulong)m_innerBuffer[i + Offset + 5]) << 16) |                      (((ulong)m_innerBuffer[i + Offset + 6]) << 8) |                      ((ulong)m_innerBuffer[i + Offset + 7]);
Magic Number,NetMQ.Core.Transports,ByteArraySegment,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetUnsignedLong,The following statement contains a magic number: return                      (((ulong)m_innerBuffer[i + Offset]) << 56) |                      (((ulong)m_innerBuffer[i + Offset + 1]) << 48) |                      (((ulong)m_innerBuffer[i + Offset + 2]) << 40) |                      (((ulong)m_innerBuffer[i + Offset + 3]) << 32) |                      (((ulong)m_innerBuffer[i + Offset + 4]) << 24) |                      (((ulong)m_innerBuffer[i + Offset + 5]) << 16) |                      (((ulong)m_innerBuffer[i + Offset + 6]) << 8) |                      ((ulong)m_innerBuffer[i + Offset + 7]);
Magic Number,NetMQ.Core.Transports,ByteArraySegment,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetUnsignedLong,The following statement contains a magic number: return                      (((ulong)m_innerBuffer[i + Offset]) << 56) |                      (((ulong)m_innerBuffer[i + Offset + 1]) << 48) |                      (((ulong)m_innerBuffer[i + Offset + 2]) << 40) |                      (((ulong)m_innerBuffer[i + Offset + 3]) << 32) |                      (((ulong)m_innerBuffer[i + Offset + 4]) << 24) |                      (((ulong)m_innerBuffer[i + Offset + 5]) << 16) |                      (((ulong)m_innerBuffer[i + Offset + 6]) << 8) |                      ((ulong)m_innerBuffer[i + Offset + 7]);
Magic Number,NetMQ.Core.Transports,ByteArraySegment,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetInteger,The following statement contains a magic number: return                       ((m_innerBuffer[i + Offset]) << 24) |                       ((m_innerBuffer[i + Offset + 1]) << 16) |                       ((m_innerBuffer[i + Offset + 2]) << 8) |                       (m_innerBuffer[i + Offset + 3]);
Magic Number,NetMQ.Core.Transports,ByteArraySegment,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetInteger,The following statement contains a magic number: return                       ((m_innerBuffer[i + Offset]) << 24) |                       ((m_innerBuffer[i + Offset + 1]) << 16) |                       ((m_innerBuffer[i + Offset + 2]) << 8) |                       (m_innerBuffer[i + Offset + 3]);
Magic Number,NetMQ.Core.Transports,ByteArraySegment,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetInteger,The following statement contains a magic number: return                       ((m_innerBuffer[i + Offset]) << 24) |                       ((m_innerBuffer[i + Offset + 1]) << 16) |                       ((m_innerBuffer[i + Offset + 2]) << 8) |                       (m_innerBuffer[i + Offset + 3]);
Magic Number,NetMQ.Core.Transports,ByteArraySegment,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetInteger,The following statement contains a magic number: return                       ((m_innerBuffer[i + Offset]) << 24) |                       ((m_innerBuffer[i + Offset + 1]) << 16) |                       ((m_innerBuffer[i + Offset + 2]) << 8) |                       (m_innerBuffer[i + Offset + 3]);
Magic Number,NetMQ.Core.Transports,ByteArraySegment,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetInteger,The following statement contains a magic number: return                       ((m_innerBuffer[i + Offset]) << 24) |                       ((m_innerBuffer[i + Offset + 1]) << 16) |                       ((m_innerBuffer[i + Offset + 2]) << 8) |                       (m_innerBuffer[i + Offset + 3]);
Magic Number,NetMQ.Core.Transports,ByteArraySegment,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetUnsignedShort,The following statement contains a magic number: return (ushort)(((m_innerBuffer[i + Offset]) << 8) |                       (m_innerBuffer[i + Offset + 1]));
Magic Number,NetMQ.Core.Transports,ByteArraySegment,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetHashCode,The following statement contains a magic number: int value = m_innerBuffer.GetHashCode()*27;
Magic Number,NetMQ.Core.Transports,StreamEngine,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\StreamEngine.cs,HandleHandshake,The following statement contains a magic number: switch (m_handshakeState)              {                  case HandshakeState.Closed:                      switch (action)                      {                          case Action.Start:                              // Send the 'length' and 'flags' fields of the identity message.                              // The 'length' field is encoded in the long format.                                m_greetingOutputBuffer[m_outsize++] = 0xff;                              m_greetingOutputBuffer.PutLong(m_options.Endian' (long)m_options.IdentitySize + 1' 1);                              m_outsize += 8;                              m_greetingOutputBuffer[m_outsize++] = 0x7f;                                m_outpos = new ByteArraySegment(m_greetingOutputBuffer);                                m_handshakeState = HandshakeState.SendingGreeting;                                BeginWrite(m_outpos' m_outsize);                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  case HandshakeState.SendingGreeting:                      switch (action)                      {                          case Action.OutCompleted:                              bytesSent = EndWrite(socketError' bytesTransferred);                                if (bytesSent == -1)                              {                                  Error();                              }                              else                              {                                  m_outpos.AdvanceOffset(bytesSent);                                  m_outsize -= bytesSent;                                    if (m_outsize > 0)                                  {                                      BeginWrite(m_outpos' m_outsize);                                  }                                  else                                  {                                      m_greetingBytesRead = 0;                                        var greetingSegment = new ByteArraySegment(m_greeting' m_greetingBytesRead);                                        m_handshakeState = HandshakeState.ReceivingGreeting;                                        BeginRead(greetingSegment' PreambleSize);                                  }                              }                              break;                          case Action.ActivateIn:                          case Action.ActivateOut:                              // nothing to do                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  case HandshakeState.ReceivingGreeting:                      switch (action)                      {                          case Action.InCompleted:                              bytesReceived = EndRead(socketError' bytesTransferred);                                if (bytesReceived == -1)                              {                                  Error();                              }                              else                              {                                  m_greetingBytesRead += bytesReceived;                                    // check if it is an unversioned protocol                                  if (m_greeting[0] != 0xff || (m_greetingBytesRead == 10 && (m_greeting[9] & 0x01) == 0))                                  {                                      m_encoder = new V1Encoder(Config.OutBatchSize' m_options.Endian);                                      m_encoder.SetMsgSource(m_session);                                        m_decoder = new V1Decoder(Config.InBatchSize' m_options.MaxMessageSize' m_options.Endian);                                      m_decoder.SetMsgSink(m_session);                                        // We have already sent the message header.                                      // Since there is no way to tell the encoder to                                      // skip the message header' we simply throw that                                      // header data away.                                      int headerSize = m_options.IdentitySize + 1 >= 255 ? 10 : 2;                                      var tmp = new byte[10];                                      var bufferp = new ByteArraySegment(tmp);                                        int bufferSize = headerSize;                                        m_encoder.GetData(ref bufferp' ref bufferSize);                                        Debug.Assert(bufferSize == headerSize);                                        // Make sure the decoder sees the data we have already received.                                      m_inpos = new ByteArraySegment(m_greeting);                                      m_insize = m_greetingBytesRead;                                        // To allow for interoperability with peers that do not forward                                      // their subscriptions' we inject a phony subscription                                      // message into the incoming message stream. To put this                                      // message right after the identity message' we temporarily                                      // divert the message stream from session to ourselves.                                      if (m_options.SocketType == ZmqSocketType.Pub || m_options.SocketType == ZmqSocketType.Xpub)                                          m_decoder.SetMsgSink(this);                                        // handshake is done                                      Activate();                                  }                                  else if (m_greetingBytesRead < 10)                                  {                                      var greetingSegment = new ByteArraySegment(m_greeting' m_greetingBytesRead);                                      BeginRead(greetingSegment' PreambleSize - m_greetingBytesRead);                                  }                                  else                                  {                                      // The peer is using versioned protocol.                                      // Send the rest of the greeting.                                      m_outpos[m_outsize++] = 1; // Protocol version                                      m_outpos[m_outsize++] = (byte)m_options.SocketType;                                        m_handshakeState = HandshakeState.SendingRestOfGreeting;                                        BeginWrite(m_outpos' m_outsize);                                  }                              }                              break;                          case Action.ActivateIn:                          case Action.ActivateOut:                              // nothing to do                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  case HandshakeState.SendingRestOfGreeting:                      switch (action)                      {                          case Action.OutCompleted:                              bytesSent = EndWrite(socketError' bytesTransferred);                                if (bytesSent == -1)                              {                                  Error();                              }                              else                              {                                  m_outpos.AdvanceOffset(bytesSent);                                  m_outsize -= bytesSent;                                    if (m_outsize > 0)                                  {                                      BeginWrite(m_outpos' m_outsize);                                  }                                  else                                  {                                      var greetingSegment = new ByteArraySegment(m_greeting' m_greetingBytesRead);                                        m_handshakeState = HandshakeState.ReceivingRestOfGreeting;                                      BeginRead(greetingSegment' GreetingSize - m_greetingBytesRead);                                  }                              }                              break;                          case Action.ActivateIn:                          case Action.ActivateOut:                              // nothing to do                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  case HandshakeState.ReceivingRestOfGreeting:                      switch (action)                      {                          case Action.InCompleted:                              bytesReceived = EndRead(socketError' bytesTransferred);                                if (bytesReceived == -1)                              {                                  Error();                              }                              else                              {                                  m_greetingBytesRead += bytesReceived;                                    if (m_greetingBytesRead < GreetingSize)                                  {                                      var greetingSegment = new ByteArraySegment(m_greeting' m_greetingBytesRead);                                      BeginRead(greetingSegment' GreetingSize - m_greetingBytesRead);                                  }                                  else                                  {                                      if (m_greeting[VersionPos] == 0)                                      {                                          // ZMTP/1.0 framing.                                          m_encoder = new V1Encoder(Config.OutBatchSize' m_options.Endian);                                          m_encoder.SetMsgSource(m_session);                                            m_decoder = new V1Decoder(Config.InBatchSize' m_options.MaxMessageSize' m_options.Endian);                                          m_decoder.SetMsgSink(m_session);                                      }                                      else                                      {                                          // v1 framing protocol.                                          m_encoder = new V2Encoder(Config.OutBatchSize' m_session' m_options.Endian);                                          m_decoder = new V2Decoder(Config.InBatchSize' m_options.MaxMessageSize' m_session' m_options.Endian);                                      }                                        // handshake is done                                      Activate();                                  }                              }                              break;                          case Action.ActivateIn:                          case Action.ActivateOut:                              // nothing to do                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  default:                      Debug.Assert(false);                      break;              }
Magic Number,NetMQ.Core.Transports,StreamEngine,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\StreamEngine.cs,HandleHandshake,The following statement contains a magic number: switch (m_handshakeState)              {                  case HandshakeState.Closed:                      switch (action)                      {                          case Action.Start:                              // Send the 'length' and 'flags' fields of the identity message.                              // The 'length' field is encoded in the long format.                                m_greetingOutputBuffer[m_outsize++] = 0xff;                              m_greetingOutputBuffer.PutLong(m_options.Endian' (long)m_options.IdentitySize + 1' 1);                              m_outsize += 8;                              m_greetingOutputBuffer[m_outsize++] = 0x7f;                                m_outpos = new ByteArraySegment(m_greetingOutputBuffer);                                m_handshakeState = HandshakeState.SendingGreeting;                                BeginWrite(m_outpos' m_outsize);                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  case HandshakeState.SendingGreeting:                      switch (action)                      {                          case Action.OutCompleted:                              bytesSent = EndWrite(socketError' bytesTransferred);                                if (bytesSent == -1)                              {                                  Error();                              }                              else                              {                                  m_outpos.AdvanceOffset(bytesSent);                                  m_outsize -= bytesSent;                                    if (m_outsize > 0)                                  {                                      BeginWrite(m_outpos' m_outsize);                                  }                                  else                                  {                                      m_greetingBytesRead = 0;                                        var greetingSegment = new ByteArraySegment(m_greeting' m_greetingBytesRead);                                        m_handshakeState = HandshakeState.ReceivingGreeting;                                        BeginRead(greetingSegment' PreambleSize);                                  }                              }                              break;                          case Action.ActivateIn:                          case Action.ActivateOut:                              // nothing to do                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  case HandshakeState.ReceivingGreeting:                      switch (action)                      {                          case Action.InCompleted:                              bytesReceived = EndRead(socketError' bytesTransferred);                                if (bytesReceived == -1)                              {                                  Error();                              }                              else                              {                                  m_greetingBytesRead += bytesReceived;                                    // check if it is an unversioned protocol                                  if (m_greeting[0] != 0xff || (m_greetingBytesRead == 10 && (m_greeting[9] & 0x01) == 0))                                  {                                      m_encoder = new V1Encoder(Config.OutBatchSize' m_options.Endian);                                      m_encoder.SetMsgSource(m_session);                                        m_decoder = new V1Decoder(Config.InBatchSize' m_options.MaxMessageSize' m_options.Endian);                                      m_decoder.SetMsgSink(m_session);                                        // We have already sent the message header.                                      // Since there is no way to tell the encoder to                                      // skip the message header' we simply throw that                                      // header data away.                                      int headerSize = m_options.IdentitySize + 1 >= 255 ? 10 : 2;                                      var tmp = new byte[10];                                      var bufferp = new ByteArraySegment(tmp);                                        int bufferSize = headerSize;                                        m_encoder.GetData(ref bufferp' ref bufferSize);                                        Debug.Assert(bufferSize == headerSize);                                        // Make sure the decoder sees the data we have already received.                                      m_inpos = new ByteArraySegment(m_greeting);                                      m_insize = m_greetingBytesRead;                                        // To allow for interoperability with peers that do not forward                                      // their subscriptions' we inject a phony subscription                                      // message into the incoming message stream. To put this                                      // message right after the identity message' we temporarily                                      // divert the message stream from session to ourselves.                                      if (m_options.SocketType == ZmqSocketType.Pub || m_options.SocketType == ZmqSocketType.Xpub)                                          m_decoder.SetMsgSink(this);                                        // handshake is done                                      Activate();                                  }                                  else if (m_greetingBytesRead < 10)                                  {                                      var greetingSegment = new ByteArraySegment(m_greeting' m_greetingBytesRead);                                      BeginRead(greetingSegment' PreambleSize - m_greetingBytesRead);                                  }                                  else                                  {                                      // The peer is using versioned protocol.                                      // Send the rest of the greeting.                                      m_outpos[m_outsize++] = 1; // Protocol version                                      m_outpos[m_outsize++] = (byte)m_options.SocketType;                                        m_handshakeState = HandshakeState.SendingRestOfGreeting;                                        BeginWrite(m_outpos' m_outsize);                                  }                              }                              break;                          case Action.ActivateIn:                          case Action.ActivateOut:                              // nothing to do                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  case HandshakeState.SendingRestOfGreeting:                      switch (action)                      {                          case Action.OutCompleted:                              bytesSent = EndWrite(socketError' bytesTransferred);                                if (bytesSent == -1)                              {                                  Error();                              }                              else                              {                                  m_outpos.AdvanceOffset(bytesSent);                                  m_outsize -= bytesSent;                                    if (m_outsize > 0)                                  {                                      BeginWrite(m_outpos' m_outsize);                                  }                                  else                                  {                                      var greetingSegment = new ByteArraySegment(m_greeting' m_greetingBytesRead);                                        m_handshakeState = HandshakeState.ReceivingRestOfGreeting;                                      BeginRead(greetingSegment' GreetingSize - m_greetingBytesRead);                                  }                              }                              break;                          case Action.ActivateIn:                          case Action.ActivateOut:                              // nothing to do                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  case HandshakeState.ReceivingRestOfGreeting:                      switch (action)                      {                          case Action.InCompleted:                              bytesReceived = EndRead(socketError' bytesTransferred);                                if (bytesReceived == -1)                              {                                  Error();                              }                              else                              {                                  m_greetingBytesRead += bytesReceived;                                    if (m_greetingBytesRead < GreetingSize)                                  {                                      var greetingSegment = new ByteArraySegment(m_greeting' m_greetingBytesRead);                                      BeginRead(greetingSegment' GreetingSize - m_greetingBytesRead);                                  }                                  else                                  {                                      if (m_greeting[VersionPos] == 0)                                      {                                          // ZMTP/1.0 framing.                                          m_encoder = new V1Encoder(Config.OutBatchSize' m_options.Endian);                                          m_encoder.SetMsgSource(m_session);                                            m_decoder = new V1Decoder(Config.InBatchSize' m_options.MaxMessageSize' m_options.Endian);                                          m_decoder.SetMsgSink(m_session);                                      }                                      else                                      {                                          // v1 framing protocol.                                          m_encoder = new V2Encoder(Config.OutBatchSize' m_session' m_options.Endian);                                          m_decoder = new V2Decoder(Config.InBatchSize' m_options.MaxMessageSize' m_session' m_options.Endian);                                      }                                        // handshake is done                                      Activate();                                  }                              }                              break;                          case Action.ActivateIn:                          case Action.ActivateOut:                              // nothing to do                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  default:                      Debug.Assert(false);                      break;              }
Magic Number,NetMQ.Core.Transports,StreamEngine,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\StreamEngine.cs,HandleHandshake,The following statement contains a magic number: switch (m_handshakeState)              {                  case HandshakeState.Closed:                      switch (action)                      {                          case Action.Start:                              // Send the 'length' and 'flags' fields of the identity message.                              // The 'length' field is encoded in the long format.                                m_greetingOutputBuffer[m_outsize++] = 0xff;                              m_greetingOutputBuffer.PutLong(m_options.Endian' (long)m_options.IdentitySize + 1' 1);                              m_outsize += 8;                              m_greetingOutputBuffer[m_outsize++] = 0x7f;                                m_outpos = new ByteArraySegment(m_greetingOutputBuffer);                                m_handshakeState = HandshakeState.SendingGreeting;                                BeginWrite(m_outpos' m_outsize);                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  case HandshakeState.SendingGreeting:                      switch (action)                      {                          case Action.OutCompleted:                              bytesSent = EndWrite(socketError' bytesTransferred);                                if (bytesSent == -1)                              {                                  Error();                              }                              else                              {                                  m_outpos.AdvanceOffset(bytesSent);                                  m_outsize -= bytesSent;                                    if (m_outsize > 0)                                  {                                      BeginWrite(m_outpos' m_outsize);                                  }                                  else                                  {                                      m_greetingBytesRead = 0;                                        var greetingSegment = new ByteArraySegment(m_greeting' m_greetingBytesRead);                                        m_handshakeState = HandshakeState.ReceivingGreeting;                                        BeginRead(greetingSegment' PreambleSize);                                  }                              }                              break;                          case Action.ActivateIn:                          case Action.ActivateOut:                              // nothing to do                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  case HandshakeState.ReceivingGreeting:                      switch (action)                      {                          case Action.InCompleted:                              bytesReceived = EndRead(socketError' bytesTransferred);                                if (bytesReceived == -1)                              {                                  Error();                              }                              else                              {                                  m_greetingBytesRead += bytesReceived;                                    // check if it is an unversioned protocol                                  if (m_greeting[0] != 0xff || (m_greetingBytesRead == 10 && (m_greeting[9] & 0x01) == 0))                                  {                                      m_encoder = new V1Encoder(Config.OutBatchSize' m_options.Endian);                                      m_encoder.SetMsgSource(m_session);                                        m_decoder = new V1Decoder(Config.InBatchSize' m_options.MaxMessageSize' m_options.Endian);                                      m_decoder.SetMsgSink(m_session);                                        // We have already sent the message header.                                      // Since there is no way to tell the encoder to                                      // skip the message header' we simply throw that                                      // header data away.                                      int headerSize = m_options.IdentitySize + 1 >= 255 ? 10 : 2;                                      var tmp = new byte[10];                                      var bufferp = new ByteArraySegment(tmp);                                        int bufferSize = headerSize;                                        m_encoder.GetData(ref bufferp' ref bufferSize);                                        Debug.Assert(bufferSize == headerSize);                                        // Make sure the decoder sees the data we have already received.                                      m_inpos = new ByteArraySegment(m_greeting);                                      m_insize = m_greetingBytesRead;                                        // To allow for interoperability with peers that do not forward                                      // their subscriptions' we inject a phony subscription                                      // message into the incoming message stream. To put this                                      // message right after the identity message' we temporarily                                      // divert the message stream from session to ourselves.                                      if (m_options.SocketType == ZmqSocketType.Pub || m_options.SocketType == ZmqSocketType.Xpub)                                          m_decoder.SetMsgSink(this);                                        // handshake is done                                      Activate();                                  }                                  else if (m_greetingBytesRead < 10)                                  {                                      var greetingSegment = new ByteArraySegment(m_greeting' m_greetingBytesRead);                                      BeginRead(greetingSegment' PreambleSize - m_greetingBytesRead);                                  }                                  else                                  {                                      // The peer is using versioned protocol.                                      // Send the rest of the greeting.                                      m_outpos[m_outsize++] = 1; // Protocol version                                      m_outpos[m_outsize++] = (byte)m_options.SocketType;                                        m_handshakeState = HandshakeState.SendingRestOfGreeting;                                        BeginWrite(m_outpos' m_outsize);                                  }                              }                              break;                          case Action.ActivateIn:                          case Action.ActivateOut:                              // nothing to do                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  case HandshakeState.SendingRestOfGreeting:                      switch (action)                      {                          case Action.OutCompleted:                              bytesSent = EndWrite(socketError' bytesTransferred);                                if (bytesSent == -1)                              {                                  Error();                              }                              else                              {                                  m_outpos.AdvanceOffset(bytesSent);                                  m_outsize -= bytesSent;                                    if (m_outsize > 0)                                  {                                      BeginWrite(m_outpos' m_outsize);                                  }                                  else                                  {                                      var greetingSegment = new ByteArraySegment(m_greeting' m_greetingBytesRead);                                        m_handshakeState = HandshakeState.ReceivingRestOfGreeting;                                      BeginRead(greetingSegment' GreetingSize - m_greetingBytesRead);                                  }                              }                              break;                          case Action.ActivateIn:                          case Action.ActivateOut:                              // nothing to do                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  case HandshakeState.ReceivingRestOfGreeting:                      switch (action)                      {                          case Action.InCompleted:                              bytesReceived = EndRead(socketError' bytesTransferred);                                if (bytesReceived == -1)                              {                                  Error();                              }                              else                              {                                  m_greetingBytesRead += bytesReceived;                                    if (m_greetingBytesRead < GreetingSize)                                  {                                      var greetingSegment = new ByteArraySegment(m_greeting' m_greetingBytesRead);                                      BeginRead(greetingSegment' GreetingSize - m_greetingBytesRead);                                  }                                  else                                  {                                      if (m_greeting[VersionPos] == 0)                                      {                                          // ZMTP/1.0 framing.                                          m_encoder = new V1Encoder(Config.OutBatchSize' m_options.Endian);                                          m_encoder.SetMsgSource(m_session);                                            m_decoder = new V1Decoder(Config.InBatchSize' m_options.MaxMessageSize' m_options.Endian);                                          m_decoder.SetMsgSink(m_session);                                      }                                      else                                      {                                          // v1 framing protocol.                                          m_encoder = new V2Encoder(Config.OutBatchSize' m_session' m_options.Endian);                                          m_decoder = new V2Decoder(Config.InBatchSize' m_options.MaxMessageSize' m_session' m_options.Endian);                                      }                                        // handshake is done                                      Activate();                                  }                              }                              break;                          case Action.ActivateIn:                          case Action.ActivateOut:                              // nothing to do                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  default:                      Debug.Assert(false);                      break;              }
Magic Number,NetMQ.Core.Transports,StreamEngine,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\StreamEngine.cs,HandleHandshake,The following statement contains a magic number: switch (m_handshakeState)              {                  case HandshakeState.Closed:                      switch (action)                      {                          case Action.Start:                              // Send the 'length' and 'flags' fields of the identity message.                              // The 'length' field is encoded in the long format.                                m_greetingOutputBuffer[m_outsize++] = 0xff;                              m_greetingOutputBuffer.PutLong(m_options.Endian' (long)m_options.IdentitySize + 1' 1);                              m_outsize += 8;                              m_greetingOutputBuffer[m_outsize++] = 0x7f;                                m_outpos = new ByteArraySegment(m_greetingOutputBuffer);                                m_handshakeState = HandshakeState.SendingGreeting;                                BeginWrite(m_outpos' m_outsize);                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  case HandshakeState.SendingGreeting:                      switch (action)                      {                          case Action.OutCompleted:                              bytesSent = EndWrite(socketError' bytesTransferred);                                if (bytesSent == -1)                              {                                  Error();                              }                              else                              {                                  m_outpos.AdvanceOffset(bytesSent);                                  m_outsize -= bytesSent;                                    if (m_outsize > 0)                                  {                                      BeginWrite(m_outpos' m_outsize);                                  }                                  else                                  {                                      m_greetingBytesRead = 0;                                        var greetingSegment = new ByteArraySegment(m_greeting' m_greetingBytesRead);                                        m_handshakeState = HandshakeState.ReceivingGreeting;                                        BeginRead(greetingSegment' PreambleSize);                                  }                              }                              break;                          case Action.ActivateIn:                          case Action.ActivateOut:                              // nothing to do                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  case HandshakeState.ReceivingGreeting:                      switch (action)                      {                          case Action.InCompleted:                              bytesReceived = EndRead(socketError' bytesTransferred);                                if (bytesReceived == -1)                              {                                  Error();                              }                              else                              {                                  m_greetingBytesRead += bytesReceived;                                    // check if it is an unversioned protocol                                  if (m_greeting[0] != 0xff || (m_greetingBytesRead == 10 && (m_greeting[9] & 0x01) == 0))                                  {                                      m_encoder = new V1Encoder(Config.OutBatchSize' m_options.Endian);                                      m_encoder.SetMsgSource(m_session);                                        m_decoder = new V1Decoder(Config.InBatchSize' m_options.MaxMessageSize' m_options.Endian);                                      m_decoder.SetMsgSink(m_session);                                        // We have already sent the message header.                                      // Since there is no way to tell the encoder to                                      // skip the message header' we simply throw that                                      // header data away.                                      int headerSize = m_options.IdentitySize + 1 >= 255 ? 10 : 2;                                      var tmp = new byte[10];                                      var bufferp = new ByteArraySegment(tmp);                                        int bufferSize = headerSize;                                        m_encoder.GetData(ref bufferp' ref bufferSize);                                        Debug.Assert(bufferSize == headerSize);                                        // Make sure the decoder sees the data we have already received.                                      m_inpos = new ByteArraySegment(m_greeting);                                      m_insize = m_greetingBytesRead;                                        // To allow for interoperability with peers that do not forward                                      // their subscriptions' we inject a phony subscription                                      // message into the incoming message stream. To put this                                      // message right after the identity message' we temporarily                                      // divert the message stream from session to ourselves.                                      if (m_options.SocketType == ZmqSocketType.Pub || m_options.SocketType == ZmqSocketType.Xpub)                                          m_decoder.SetMsgSink(this);                                        // handshake is done                                      Activate();                                  }                                  else if (m_greetingBytesRead < 10)                                  {                                      var greetingSegment = new ByteArraySegment(m_greeting' m_greetingBytesRead);                                      BeginRead(greetingSegment' PreambleSize - m_greetingBytesRead);                                  }                                  else                                  {                                      // The peer is using versioned protocol.                                      // Send the rest of the greeting.                                      m_outpos[m_outsize++] = 1; // Protocol version                                      m_outpos[m_outsize++] = (byte)m_options.SocketType;                                        m_handshakeState = HandshakeState.SendingRestOfGreeting;                                        BeginWrite(m_outpos' m_outsize);                                  }                              }                              break;                          case Action.ActivateIn:                          case Action.ActivateOut:                              // nothing to do                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  case HandshakeState.SendingRestOfGreeting:                      switch (action)                      {                          case Action.OutCompleted:                              bytesSent = EndWrite(socketError' bytesTransferred);                                if (bytesSent == -1)                              {                                  Error();                              }                              else                              {                                  m_outpos.AdvanceOffset(bytesSent);                                  m_outsize -= bytesSent;                                    if (m_outsize > 0)                                  {                                      BeginWrite(m_outpos' m_outsize);                                  }                                  else                                  {                                      var greetingSegment = new ByteArraySegment(m_greeting' m_greetingBytesRead);                                        m_handshakeState = HandshakeState.ReceivingRestOfGreeting;                                      BeginRead(greetingSegment' GreetingSize - m_greetingBytesRead);                                  }                              }                              break;                          case Action.ActivateIn:                          case Action.ActivateOut:                              // nothing to do                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  case HandshakeState.ReceivingRestOfGreeting:                      switch (action)                      {                          case Action.InCompleted:                              bytesReceived = EndRead(socketError' bytesTransferred);                                if (bytesReceived == -1)                              {                                  Error();                              }                              else                              {                                  m_greetingBytesRead += bytesReceived;                                    if (m_greetingBytesRead < GreetingSize)                                  {                                      var greetingSegment = new ByteArraySegment(m_greeting' m_greetingBytesRead);                                      BeginRead(greetingSegment' GreetingSize - m_greetingBytesRead);                                  }                                  else                                  {                                      if (m_greeting[VersionPos] == 0)                                      {                                          // ZMTP/1.0 framing.                                          m_encoder = new V1Encoder(Config.OutBatchSize' m_options.Endian);                                          m_encoder.SetMsgSource(m_session);                                            m_decoder = new V1Decoder(Config.InBatchSize' m_options.MaxMessageSize' m_options.Endian);                                          m_decoder.SetMsgSink(m_session);                                      }                                      else                                      {                                          // v1 framing protocol.                                          m_encoder = new V2Encoder(Config.OutBatchSize' m_session' m_options.Endian);                                          m_decoder = new V2Decoder(Config.InBatchSize' m_options.MaxMessageSize' m_session' m_options.Endian);                                      }                                        // handshake is done                                      Activate();                                  }                              }                              break;                          case Action.ActivateIn:                          case Action.ActivateOut:                              // nothing to do                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  default:                      Debug.Assert(false);                      break;              }
Magic Number,NetMQ.Core.Transports,StreamEngine,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\StreamEngine.cs,HandleHandshake,The following statement contains a magic number: switch (m_handshakeState)              {                  case HandshakeState.Closed:                      switch (action)                      {                          case Action.Start:                              // Send the 'length' and 'flags' fields of the identity message.                              // The 'length' field is encoded in the long format.                                m_greetingOutputBuffer[m_outsize++] = 0xff;                              m_greetingOutputBuffer.PutLong(m_options.Endian' (long)m_options.IdentitySize + 1' 1);                              m_outsize += 8;                              m_greetingOutputBuffer[m_outsize++] = 0x7f;                                m_outpos = new ByteArraySegment(m_greetingOutputBuffer);                                m_handshakeState = HandshakeState.SendingGreeting;                                BeginWrite(m_outpos' m_outsize);                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  case HandshakeState.SendingGreeting:                      switch (action)                      {                          case Action.OutCompleted:                              bytesSent = EndWrite(socketError' bytesTransferred);                                if (bytesSent == -1)                              {                                  Error();                              }                              else                              {                                  m_outpos.AdvanceOffset(bytesSent);                                  m_outsize -= bytesSent;                                    if (m_outsize > 0)                                  {                                      BeginWrite(m_outpos' m_outsize);                                  }                                  else                                  {                                      m_greetingBytesRead = 0;                                        var greetingSegment = new ByteArraySegment(m_greeting' m_greetingBytesRead);                                        m_handshakeState = HandshakeState.ReceivingGreeting;                                        BeginRead(greetingSegment' PreambleSize);                                  }                              }                              break;                          case Action.ActivateIn:                          case Action.ActivateOut:                              // nothing to do                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  case HandshakeState.ReceivingGreeting:                      switch (action)                      {                          case Action.InCompleted:                              bytesReceived = EndRead(socketError' bytesTransferred);                                if (bytesReceived == -1)                              {                                  Error();                              }                              else                              {                                  m_greetingBytesRead += bytesReceived;                                    // check if it is an unversioned protocol                                  if (m_greeting[0] != 0xff || (m_greetingBytesRead == 10 && (m_greeting[9] & 0x01) == 0))                                  {                                      m_encoder = new V1Encoder(Config.OutBatchSize' m_options.Endian);                                      m_encoder.SetMsgSource(m_session);                                        m_decoder = new V1Decoder(Config.InBatchSize' m_options.MaxMessageSize' m_options.Endian);                                      m_decoder.SetMsgSink(m_session);                                        // We have already sent the message header.                                      // Since there is no way to tell the encoder to                                      // skip the message header' we simply throw that                                      // header data away.                                      int headerSize = m_options.IdentitySize + 1 >= 255 ? 10 : 2;                                      var tmp = new byte[10];                                      var bufferp = new ByteArraySegment(tmp);                                        int bufferSize = headerSize;                                        m_encoder.GetData(ref bufferp' ref bufferSize);                                        Debug.Assert(bufferSize == headerSize);                                        // Make sure the decoder sees the data we have already received.                                      m_inpos = new ByteArraySegment(m_greeting);                                      m_insize = m_greetingBytesRead;                                        // To allow for interoperability with peers that do not forward                                      // their subscriptions' we inject a phony subscription                                      // message into the incoming message stream. To put this                                      // message right after the identity message' we temporarily                                      // divert the message stream from session to ourselves.                                      if (m_options.SocketType == ZmqSocketType.Pub || m_options.SocketType == ZmqSocketType.Xpub)                                          m_decoder.SetMsgSink(this);                                        // handshake is done                                      Activate();                                  }                                  else if (m_greetingBytesRead < 10)                                  {                                      var greetingSegment = new ByteArraySegment(m_greeting' m_greetingBytesRead);                                      BeginRead(greetingSegment' PreambleSize - m_greetingBytesRead);                                  }                                  else                                  {                                      // The peer is using versioned protocol.                                      // Send the rest of the greeting.                                      m_outpos[m_outsize++] = 1; // Protocol version                                      m_outpos[m_outsize++] = (byte)m_options.SocketType;                                        m_handshakeState = HandshakeState.SendingRestOfGreeting;                                        BeginWrite(m_outpos' m_outsize);                                  }                              }                              break;                          case Action.ActivateIn:                          case Action.ActivateOut:                              // nothing to do                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  case HandshakeState.SendingRestOfGreeting:                      switch (action)                      {                          case Action.OutCompleted:                              bytesSent = EndWrite(socketError' bytesTransferred);                                if (bytesSent == -1)                              {                                  Error();                              }                              else                              {                                  m_outpos.AdvanceOffset(bytesSent);                                  m_outsize -= bytesSent;                                    if (m_outsize > 0)                                  {                                      BeginWrite(m_outpos' m_outsize);                                  }                                  else                                  {                                      var greetingSegment = new ByteArraySegment(m_greeting' m_greetingBytesRead);                                        m_handshakeState = HandshakeState.ReceivingRestOfGreeting;                                      BeginRead(greetingSegment' GreetingSize - m_greetingBytesRead);                                  }                              }                              break;                          case Action.ActivateIn:                          case Action.ActivateOut:                              // nothing to do                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  case HandshakeState.ReceivingRestOfGreeting:                      switch (action)                      {                          case Action.InCompleted:                              bytesReceived = EndRead(socketError' bytesTransferred);                                if (bytesReceived == -1)                              {                                  Error();                              }                              else                              {                                  m_greetingBytesRead += bytesReceived;                                    if (m_greetingBytesRead < GreetingSize)                                  {                                      var greetingSegment = new ByteArraySegment(m_greeting' m_greetingBytesRead);                                      BeginRead(greetingSegment' GreetingSize - m_greetingBytesRead);                                  }                                  else                                  {                                      if (m_greeting[VersionPos] == 0)                                      {                                          // ZMTP/1.0 framing.                                          m_encoder = new V1Encoder(Config.OutBatchSize' m_options.Endian);                                          m_encoder.SetMsgSource(m_session);                                            m_decoder = new V1Decoder(Config.InBatchSize' m_options.MaxMessageSize' m_options.Endian);                                          m_decoder.SetMsgSink(m_session);                                      }                                      else                                      {                                          // v1 framing protocol.                                          m_encoder = new V2Encoder(Config.OutBatchSize' m_session' m_options.Endian);                                          m_decoder = new V2Decoder(Config.InBatchSize' m_options.MaxMessageSize' m_session' m_options.Endian);                                      }                                        // handshake is done                                      Activate();                                  }                              }                              break;                          case Action.ActivateIn:                          case Action.ActivateOut:                              // nothing to do                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  default:                      Debug.Assert(false);                      break;              }
Magic Number,NetMQ.Core.Transports,StreamEngine,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\StreamEngine.cs,HandleHandshake,The following statement contains a magic number: switch (m_handshakeState)              {                  case HandshakeState.Closed:                      switch (action)                      {                          case Action.Start:                              // Send the 'length' and 'flags' fields of the identity message.                              // The 'length' field is encoded in the long format.                                m_greetingOutputBuffer[m_outsize++] = 0xff;                              m_greetingOutputBuffer.PutLong(m_options.Endian' (long)m_options.IdentitySize + 1' 1);                              m_outsize += 8;                              m_greetingOutputBuffer[m_outsize++] = 0x7f;                                m_outpos = new ByteArraySegment(m_greetingOutputBuffer);                                m_handshakeState = HandshakeState.SendingGreeting;                                BeginWrite(m_outpos' m_outsize);                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  case HandshakeState.SendingGreeting:                      switch (action)                      {                          case Action.OutCompleted:                              bytesSent = EndWrite(socketError' bytesTransferred);                                if (bytesSent == -1)                              {                                  Error();                              }                              else                              {                                  m_outpos.AdvanceOffset(bytesSent);                                  m_outsize -= bytesSent;                                    if (m_outsize > 0)                                  {                                      BeginWrite(m_outpos' m_outsize);                                  }                                  else                                  {                                      m_greetingBytesRead = 0;                                        var greetingSegment = new ByteArraySegment(m_greeting' m_greetingBytesRead);                                        m_handshakeState = HandshakeState.ReceivingGreeting;                                        BeginRead(greetingSegment' PreambleSize);                                  }                              }                              break;                          case Action.ActivateIn:                          case Action.ActivateOut:                              // nothing to do                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  case HandshakeState.ReceivingGreeting:                      switch (action)                      {                          case Action.InCompleted:                              bytesReceived = EndRead(socketError' bytesTransferred);                                if (bytesReceived == -1)                              {                                  Error();                              }                              else                              {                                  m_greetingBytesRead += bytesReceived;                                    // check if it is an unversioned protocol                                  if (m_greeting[0] != 0xff || (m_greetingBytesRead == 10 && (m_greeting[9] & 0x01) == 0))                                  {                                      m_encoder = new V1Encoder(Config.OutBatchSize' m_options.Endian);                                      m_encoder.SetMsgSource(m_session);                                        m_decoder = new V1Decoder(Config.InBatchSize' m_options.MaxMessageSize' m_options.Endian);                                      m_decoder.SetMsgSink(m_session);                                        // We have already sent the message header.                                      // Since there is no way to tell the encoder to                                      // skip the message header' we simply throw that                                      // header data away.                                      int headerSize = m_options.IdentitySize + 1 >= 255 ? 10 : 2;                                      var tmp = new byte[10];                                      var bufferp = new ByteArraySegment(tmp);                                        int bufferSize = headerSize;                                        m_encoder.GetData(ref bufferp' ref bufferSize);                                        Debug.Assert(bufferSize == headerSize);                                        // Make sure the decoder sees the data we have already received.                                      m_inpos = new ByteArraySegment(m_greeting);                                      m_insize = m_greetingBytesRead;                                        // To allow for interoperability with peers that do not forward                                      // their subscriptions' we inject a phony subscription                                      // message into the incoming message stream. To put this                                      // message right after the identity message' we temporarily                                      // divert the message stream from session to ourselves.                                      if (m_options.SocketType == ZmqSocketType.Pub || m_options.SocketType == ZmqSocketType.Xpub)                                          m_decoder.SetMsgSink(this);                                        // handshake is done                                      Activate();                                  }                                  else if (m_greetingBytesRead < 10)                                  {                                      var greetingSegment = new ByteArraySegment(m_greeting' m_greetingBytesRead);                                      BeginRead(greetingSegment' PreambleSize - m_greetingBytesRead);                                  }                                  else                                  {                                      // The peer is using versioned protocol.                                      // Send the rest of the greeting.                                      m_outpos[m_outsize++] = 1; // Protocol version                                      m_outpos[m_outsize++] = (byte)m_options.SocketType;                                        m_handshakeState = HandshakeState.SendingRestOfGreeting;                                        BeginWrite(m_outpos' m_outsize);                                  }                              }                              break;                          case Action.ActivateIn:                          case Action.ActivateOut:                              // nothing to do                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  case HandshakeState.SendingRestOfGreeting:                      switch (action)                      {                          case Action.OutCompleted:                              bytesSent = EndWrite(socketError' bytesTransferred);                                if (bytesSent == -1)                              {                                  Error();                              }                              else                              {                                  m_outpos.AdvanceOffset(bytesSent);                                  m_outsize -= bytesSent;                                    if (m_outsize > 0)                                  {                                      BeginWrite(m_outpos' m_outsize);                                  }                                  else                                  {                                      var greetingSegment = new ByteArraySegment(m_greeting' m_greetingBytesRead);                                        m_handshakeState = HandshakeState.ReceivingRestOfGreeting;                                      BeginRead(greetingSegment' GreetingSize - m_greetingBytesRead);                                  }                              }                              break;                          case Action.ActivateIn:                          case Action.ActivateOut:                              // nothing to do                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  case HandshakeState.ReceivingRestOfGreeting:                      switch (action)                      {                          case Action.InCompleted:                              bytesReceived = EndRead(socketError' bytesTransferred);                                if (bytesReceived == -1)                              {                                  Error();                              }                              else                              {                                  m_greetingBytesRead += bytesReceived;                                    if (m_greetingBytesRead < GreetingSize)                                  {                                      var greetingSegment = new ByteArraySegment(m_greeting' m_greetingBytesRead);                                      BeginRead(greetingSegment' GreetingSize - m_greetingBytesRead);                                  }                                  else                                  {                                      if (m_greeting[VersionPos] == 0)                                      {                                          // ZMTP/1.0 framing.                                          m_encoder = new V1Encoder(Config.OutBatchSize' m_options.Endian);                                          m_encoder.SetMsgSource(m_session);                                            m_decoder = new V1Decoder(Config.InBatchSize' m_options.MaxMessageSize' m_options.Endian);                                          m_decoder.SetMsgSink(m_session);                                      }                                      else                                      {                                          // v1 framing protocol.                                          m_encoder = new V2Encoder(Config.OutBatchSize' m_session' m_options.Endian);                                          m_decoder = new V2Decoder(Config.InBatchSize' m_options.MaxMessageSize' m_session' m_options.Endian);                                      }                                        // handshake is done                                      Activate();                                  }                              }                              break;                          case Action.ActivateIn:                          case Action.ActivateOut:                              // nothing to do                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  default:                      Debug.Assert(false);                      break;              }
Magic Number,NetMQ.Core.Transports,StreamEngine,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\StreamEngine.cs,HandleHandshake,The following statement contains a magic number: switch (m_handshakeState)              {                  case HandshakeState.Closed:                      switch (action)                      {                          case Action.Start:                              // Send the 'length' and 'flags' fields of the identity message.                              // The 'length' field is encoded in the long format.                                m_greetingOutputBuffer[m_outsize++] = 0xff;                              m_greetingOutputBuffer.PutLong(m_options.Endian' (long)m_options.IdentitySize + 1' 1);                              m_outsize += 8;                              m_greetingOutputBuffer[m_outsize++] = 0x7f;                                m_outpos = new ByteArraySegment(m_greetingOutputBuffer);                                m_handshakeState = HandshakeState.SendingGreeting;                                BeginWrite(m_outpos' m_outsize);                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  case HandshakeState.SendingGreeting:                      switch (action)                      {                          case Action.OutCompleted:                              bytesSent = EndWrite(socketError' bytesTransferred);                                if (bytesSent == -1)                              {                                  Error();                              }                              else                              {                                  m_outpos.AdvanceOffset(bytesSent);                                  m_outsize -= bytesSent;                                    if (m_outsize > 0)                                  {                                      BeginWrite(m_outpos' m_outsize);                                  }                                  else                                  {                                      m_greetingBytesRead = 0;                                        var greetingSegment = new ByteArraySegment(m_greeting' m_greetingBytesRead);                                        m_handshakeState = HandshakeState.ReceivingGreeting;                                        BeginRead(greetingSegment' PreambleSize);                                  }                              }                              break;                          case Action.ActivateIn:                          case Action.ActivateOut:                              // nothing to do                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  case HandshakeState.ReceivingGreeting:                      switch (action)                      {                          case Action.InCompleted:                              bytesReceived = EndRead(socketError' bytesTransferred);                                if (bytesReceived == -1)                              {                                  Error();                              }                              else                              {                                  m_greetingBytesRead += bytesReceived;                                    // check if it is an unversioned protocol                                  if (m_greeting[0] != 0xff || (m_greetingBytesRead == 10 && (m_greeting[9] & 0x01) == 0))                                  {                                      m_encoder = new V1Encoder(Config.OutBatchSize' m_options.Endian);                                      m_encoder.SetMsgSource(m_session);                                        m_decoder = new V1Decoder(Config.InBatchSize' m_options.MaxMessageSize' m_options.Endian);                                      m_decoder.SetMsgSink(m_session);                                        // We have already sent the message header.                                      // Since there is no way to tell the encoder to                                      // skip the message header' we simply throw that                                      // header data away.                                      int headerSize = m_options.IdentitySize + 1 >= 255 ? 10 : 2;                                      var tmp = new byte[10];                                      var bufferp = new ByteArraySegment(tmp);                                        int bufferSize = headerSize;                                        m_encoder.GetData(ref bufferp' ref bufferSize);                                        Debug.Assert(bufferSize == headerSize);                                        // Make sure the decoder sees the data we have already received.                                      m_inpos = new ByteArraySegment(m_greeting);                                      m_insize = m_greetingBytesRead;                                        // To allow for interoperability with peers that do not forward                                      // their subscriptions' we inject a phony subscription                                      // message into the incoming message stream. To put this                                      // message right after the identity message' we temporarily                                      // divert the message stream from session to ourselves.                                      if (m_options.SocketType == ZmqSocketType.Pub || m_options.SocketType == ZmqSocketType.Xpub)                                          m_decoder.SetMsgSink(this);                                        // handshake is done                                      Activate();                                  }                                  else if (m_greetingBytesRead < 10)                                  {                                      var greetingSegment = new ByteArraySegment(m_greeting' m_greetingBytesRead);                                      BeginRead(greetingSegment' PreambleSize - m_greetingBytesRead);                                  }                                  else                                  {                                      // The peer is using versioned protocol.                                      // Send the rest of the greeting.                                      m_outpos[m_outsize++] = 1; // Protocol version                                      m_outpos[m_outsize++] = (byte)m_options.SocketType;                                        m_handshakeState = HandshakeState.SendingRestOfGreeting;                                        BeginWrite(m_outpos' m_outsize);                                  }                              }                              break;                          case Action.ActivateIn:                          case Action.ActivateOut:                              // nothing to do                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  case HandshakeState.SendingRestOfGreeting:                      switch (action)                      {                          case Action.OutCompleted:                              bytesSent = EndWrite(socketError' bytesTransferred);                                if (bytesSent == -1)                              {                                  Error();                              }                              else                              {                                  m_outpos.AdvanceOffset(bytesSent);                                  m_outsize -= bytesSent;                                    if (m_outsize > 0)                                  {                                      BeginWrite(m_outpos' m_outsize);                                  }                                  else                                  {                                      var greetingSegment = new ByteArraySegment(m_greeting' m_greetingBytesRead);                                        m_handshakeState = HandshakeState.ReceivingRestOfGreeting;                                      BeginRead(greetingSegment' GreetingSize - m_greetingBytesRead);                                  }                              }                              break;                          case Action.ActivateIn:                          case Action.ActivateOut:                              // nothing to do                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  case HandshakeState.ReceivingRestOfGreeting:                      switch (action)                      {                          case Action.InCompleted:                              bytesReceived = EndRead(socketError' bytesTransferred);                                if (bytesReceived == -1)                              {                                  Error();                              }                              else                              {                                  m_greetingBytesRead += bytesReceived;                                    if (m_greetingBytesRead < GreetingSize)                                  {                                      var greetingSegment = new ByteArraySegment(m_greeting' m_greetingBytesRead);                                      BeginRead(greetingSegment' GreetingSize - m_greetingBytesRead);                                  }                                  else                                  {                                      if (m_greeting[VersionPos] == 0)                                      {                                          // ZMTP/1.0 framing.                                          m_encoder = new V1Encoder(Config.OutBatchSize' m_options.Endian);                                          m_encoder.SetMsgSource(m_session);                                            m_decoder = new V1Decoder(Config.InBatchSize' m_options.MaxMessageSize' m_options.Endian);                                          m_decoder.SetMsgSink(m_session);                                      }                                      else                                      {                                          // v1 framing protocol.                                          m_encoder = new V2Encoder(Config.OutBatchSize' m_session' m_options.Endian);                                          m_decoder = new V2Decoder(Config.InBatchSize' m_options.MaxMessageSize' m_session' m_options.Endian);                                      }                                        // handshake is done                                      Activate();                                  }                              }                              break;                          case Action.ActivateIn:                          case Action.ActivateOut:                              // nothing to do                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  default:                      Debug.Assert(false);                      break;              }
Magic Number,NetMQ.Core.Transports,StreamEngine,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\StreamEngine.cs,HandleHandshake,The following statement contains a magic number: switch (m_handshakeState)              {                  case HandshakeState.Closed:                      switch (action)                      {                          case Action.Start:                              // Send the 'length' and 'flags' fields of the identity message.                              // The 'length' field is encoded in the long format.                                m_greetingOutputBuffer[m_outsize++] = 0xff;                              m_greetingOutputBuffer.PutLong(m_options.Endian' (long)m_options.IdentitySize + 1' 1);                              m_outsize += 8;                              m_greetingOutputBuffer[m_outsize++] = 0x7f;                                m_outpos = new ByteArraySegment(m_greetingOutputBuffer);                                m_handshakeState = HandshakeState.SendingGreeting;                                BeginWrite(m_outpos' m_outsize);                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  case HandshakeState.SendingGreeting:                      switch (action)                      {                          case Action.OutCompleted:                              bytesSent = EndWrite(socketError' bytesTransferred);                                if (bytesSent == -1)                              {                                  Error();                              }                              else                              {                                  m_outpos.AdvanceOffset(bytesSent);                                  m_outsize -= bytesSent;                                    if (m_outsize > 0)                                  {                                      BeginWrite(m_outpos' m_outsize);                                  }                                  else                                  {                                      m_greetingBytesRead = 0;                                        var greetingSegment = new ByteArraySegment(m_greeting' m_greetingBytesRead);                                        m_handshakeState = HandshakeState.ReceivingGreeting;                                        BeginRead(greetingSegment' PreambleSize);                                  }                              }                              break;                          case Action.ActivateIn:                          case Action.ActivateOut:                              // nothing to do                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  case HandshakeState.ReceivingGreeting:                      switch (action)                      {                          case Action.InCompleted:                              bytesReceived = EndRead(socketError' bytesTransferred);                                if (bytesReceived == -1)                              {                                  Error();                              }                              else                              {                                  m_greetingBytesRead += bytesReceived;                                    // check if it is an unversioned protocol                                  if (m_greeting[0] != 0xff || (m_greetingBytesRead == 10 && (m_greeting[9] & 0x01) == 0))                                  {                                      m_encoder = new V1Encoder(Config.OutBatchSize' m_options.Endian);                                      m_encoder.SetMsgSource(m_session);                                        m_decoder = new V1Decoder(Config.InBatchSize' m_options.MaxMessageSize' m_options.Endian);                                      m_decoder.SetMsgSink(m_session);                                        // We have already sent the message header.                                      // Since there is no way to tell the encoder to                                      // skip the message header' we simply throw that                                      // header data away.                                      int headerSize = m_options.IdentitySize + 1 >= 255 ? 10 : 2;                                      var tmp = new byte[10];                                      var bufferp = new ByteArraySegment(tmp);                                        int bufferSize = headerSize;                                        m_encoder.GetData(ref bufferp' ref bufferSize);                                        Debug.Assert(bufferSize == headerSize);                                        // Make sure the decoder sees the data we have already received.                                      m_inpos = new ByteArraySegment(m_greeting);                                      m_insize = m_greetingBytesRead;                                        // To allow for interoperability with peers that do not forward                                      // their subscriptions' we inject a phony subscription                                      // message into the incoming message stream. To put this                                      // message right after the identity message' we temporarily                                      // divert the message stream from session to ourselves.                                      if (m_options.SocketType == ZmqSocketType.Pub || m_options.SocketType == ZmqSocketType.Xpub)                                          m_decoder.SetMsgSink(this);                                        // handshake is done                                      Activate();                                  }                                  else if (m_greetingBytesRead < 10)                                  {                                      var greetingSegment = new ByteArraySegment(m_greeting' m_greetingBytesRead);                                      BeginRead(greetingSegment' PreambleSize - m_greetingBytesRead);                                  }                                  else                                  {                                      // The peer is using versioned protocol.                                      // Send the rest of the greeting.                                      m_outpos[m_outsize++] = 1; // Protocol version                                      m_outpos[m_outsize++] = (byte)m_options.SocketType;                                        m_handshakeState = HandshakeState.SendingRestOfGreeting;                                        BeginWrite(m_outpos' m_outsize);                                  }                              }                              break;                          case Action.ActivateIn:                          case Action.ActivateOut:                              // nothing to do                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  case HandshakeState.SendingRestOfGreeting:                      switch (action)                      {                          case Action.OutCompleted:                              bytesSent = EndWrite(socketError' bytesTransferred);                                if (bytesSent == -1)                              {                                  Error();                              }                              else                              {                                  m_outpos.AdvanceOffset(bytesSent);                                  m_outsize -= bytesSent;                                    if (m_outsize > 0)                                  {                                      BeginWrite(m_outpos' m_outsize);                                  }                                  else                                  {                                      var greetingSegment = new ByteArraySegment(m_greeting' m_greetingBytesRead);                                        m_handshakeState = HandshakeState.ReceivingRestOfGreeting;                                      BeginRead(greetingSegment' GreetingSize - m_greetingBytesRead);                                  }                              }                              break;                          case Action.ActivateIn:                          case Action.ActivateOut:                              // nothing to do                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  case HandshakeState.ReceivingRestOfGreeting:                      switch (action)                      {                          case Action.InCompleted:                              bytesReceived = EndRead(socketError' bytesTransferred);                                if (bytesReceived == -1)                              {                                  Error();                              }                              else                              {                                  m_greetingBytesRead += bytesReceived;                                    if (m_greetingBytesRead < GreetingSize)                                  {                                      var greetingSegment = new ByteArraySegment(m_greeting' m_greetingBytesRead);                                      BeginRead(greetingSegment' GreetingSize - m_greetingBytesRead);                                  }                                  else                                  {                                      if (m_greeting[VersionPos] == 0)                                      {                                          // ZMTP/1.0 framing.                                          m_encoder = new V1Encoder(Config.OutBatchSize' m_options.Endian);                                          m_encoder.SetMsgSource(m_session);                                            m_decoder = new V1Decoder(Config.InBatchSize' m_options.MaxMessageSize' m_options.Endian);                                          m_decoder.SetMsgSink(m_session);                                      }                                      else                                      {                                          // v1 framing protocol.                                          m_encoder = new V2Encoder(Config.OutBatchSize' m_session' m_options.Endian);                                          m_decoder = new V2Decoder(Config.InBatchSize' m_options.MaxMessageSize' m_session' m_options.Endian);                                      }                                        // handshake is done                                      Activate();                                  }                              }                              break;                          case Action.ActivateIn:                          case Action.ActivateOut:                              // nothing to do                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  default:                      Debug.Assert(false);                      break;              }
Magic Number,NetMQ.Core.Transports,V1Decoder,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\V1Decoder.cs,V1Decoder,The following statement contains a magic number: m_tmpbuf = new ByteArraySegment(new byte[8]);
Magic Number,NetMQ.Core.Transports,V1Decoder,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\V1Decoder.cs,OneByteSizeReady,The following statement contains a magic number: NextStep(m_tmpbuf' 8' EightByteSizeReadyState);
Magic Number,NetMQ.Core.Transports,V1Encoder,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\V1Encoder.cs,MessageReady,The following statement contains a magic number: NextStep(m_tmpbuf' 2' SizeReadyState' false);
Magic Number,NetMQ.Core.Transports,V1Encoder,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\V1Encoder.cs,MessageReady,The following statement contains a magic number: size < 255
Magic Number,NetMQ.Core.Transports,V2Decoder,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\V2Decoder.cs,V2Decoder,The following statement contains a magic number: m_tmpbuf = new byte[8];
Magic Number,NetMQ.Core.Transports,V2Decoder,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\V2Decoder.cs,FlagsReady,The following statement contains a magic number: NextStep(m_tmpbuf' 8' EightByteSizeReadyState);
Magic Number,NetMQ.Core.Transports,V2Encoder,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\V2Encoder.cs,MessageReady,The following statement contains a magic number: m_inProgress.Size > 255
Magic Number,NetMQ.Core.Transports,V2Encoder,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\V2Encoder.cs,MessageReady,The following statement contains a magic number: NextStep(m_tmpbuf' 9' SizeReadyState' false);
Magic Number,NetMQ.Core.Transports,V2Encoder,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\V2Encoder.cs,MessageReady,The following statement contains a magic number: size > 255
Magic Number,NetMQ.Core.Transports.Ipc,IpcAddress,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\Ipc\IpcAddress.cs,Resolve,The following statement contains a magic number: hash = hash%55536;
Magic Number,NetMQ.Core.Transports.Ipc,IpcAddress,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\Ipc\IpcAddress.cs,Resolve,The following statement contains a magic number: hash += 10000;
Magic Number,NetMQ.Core.Transports.Pgm,PgmAddress,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\Pgm\PgmAddress.cs,Resolve,The following statement contains a magic number: addrStr = addrStr.Substring(1' addrStr.Length - 2);
Magic Number,NetMQ.Core.Transports.Pgm,PgmAddress,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\Pgm\PgmAddress.cs,Resolve,The following statement contains a magic number: addrStr.Length >= 2 && addrStr[0] == '[' && addrStr[addrStr.Length - 1] == ']'
Magic Number,NetMQ.Core.Transports.Pgm,PgmSender,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\Pgm\PgmSender.cs,GetNewReconnectIvl,The following statement contains a magic number: m_currentReconnectIvl = m_currentReconnectIvl * 2;
Magic Number,NetMQ.Core.Transports.Tcp,TcpAddress,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\Tcp\TcpAddress.cs,Resolve,The following statement contains a magic number: addrStr = addrStr.Substring(1' addrStr.Length - 2);
Magic Number,NetMQ.Core.Transports.Tcp,TcpAddress,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\Tcp\TcpAddress.cs,Resolve,The following statement contains a magic number: addrStr.Length >= 2 && addrStr[0] == '[' && addrStr[addrStr.Length - 1] == ']'
Magic Number,NetMQ.Core.Transports.Tcp,TcpConnector,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\Tcp\TcpConnector.cs,GetNewReconnectIvl,The following statement contains a magic number: m_currentReconnectIvl = m_currentReconnectIvl * 2;
Magic Number,NetMQ.Core.Transports.Tcp,TcpListener,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\Tcp\TcpListener.cs,InCompleted,The following statement contains a magic number: switch (socketError)              {                  case SocketError.Success:                  {                      // TODO: check TcpFilters                      var acceptedSocket = m_handle.GetAcceptedSocket();                            acceptedSocket.NoDelay = true;                        if (m_options.TcpKeepalive != -1)                      {                          acceptedSocket.SetSocketOption(SocketOptionLevel.Socket' SocketOptionName.KeepAlive' m_options.TcpKeepalive);                            if (m_options.TcpKeepaliveIdle != -1 && m_options.TcpKeepaliveIntvl != -1)                          {                              var bytes = new ByteArraySegment(new byte[12]);                                Endianness endian = BitConverter.IsLittleEndian ? Endianness.Little : Endianness.Big;                                bytes.PutInteger(endian' m_options.TcpKeepalive' 0);                              bytes.PutInteger(endian' m_options.TcpKeepaliveIdle' 4);                              bytes.PutInteger(endian' m_options.TcpKeepaliveIntvl' 8);                                acceptedSocket.IOControl(IOControlCode.KeepAliveValues' (byte[])bytes' null);                          }                      }                        // Create the engine object for this connection.                      var engine = new StreamEngine(acceptedSocket' m_options' m_endpoint);                        // Choose I/O thread to run connector in. Given that we are already                      // running in an I/O thread' there must be at least one available.                      IOThread ioThread = ChooseIOThread(m_options.Affinity);                        // Create and launch a session object.                      // TODO: send null in address parameter' is unneeded in this case                      SessionBase session = SessionBase.Create(ioThread' false' m_socket' m_options' new Address(m_handle.LocalEndPoint));                      session.IncSeqnum();                      LaunchChild(session);                        SendAttach(session' engine' false);                        m_socket.EventAccepted(m_endpoint' acceptedSocket);                        Accept();                      break;                  }                  case SocketError.ConnectionReset:                  case SocketError.NoBufferSpaceAvailable:                  case SocketError.TooManyOpenSockets:                  {                      m_socket.EventAcceptFailed(m_endpoint' socketError.ToErrorCode());                        Accept();                      break;                  }                  default:                  {                      NetMQException exception = NetMQException.Create(socketError);                        m_socket.EventAcceptFailed(m_endpoint' exception.ErrorCode);                      throw exception;                  }              }
Magic Number,NetMQ.Core.Transports.Tcp,TcpListener,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\Tcp\TcpListener.cs,InCompleted,The following statement contains a magic number: switch (socketError)              {                  case SocketError.Success:                  {                      // TODO: check TcpFilters                      var acceptedSocket = m_handle.GetAcceptedSocket();                            acceptedSocket.NoDelay = true;                        if (m_options.TcpKeepalive != -1)                      {                          acceptedSocket.SetSocketOption(SocketOptionLevel.Socket' SocketOptionName.KeepAlive' m_options.TcpKeepalive);                            if (m_options.TcpKeepaliveIdle != -1 && m_options.TcpKeepaliveIntvl != -1)                          {                              var bytes = new ByteArraySegment(new byte[12]);                                Endianness endian = BitConverter.IsLittleEndian ? Endianness.Little : Endianness.Big;                                bytes.PutInteger(endian' m_options.TcpKeepalive' 0);                              bytes.PutInteger(endian' m_options.TcpKeepaliveIdle' 4);                              bytes.PutInteger(endian' m_options.TcpKeepaliveIntvl' 8);                                acceptedSocket.IOControl(IOControlCode.KeepAliveValues' (byte[])bytes' null);                          }                      }                        // Create the engine object for this connection.                      var engine = new StreamEngine(acceptedSocket' m_options' m_endpoint);                        // Choose I/O thread to run connector in. Given that we are already                      // running in an I/O thread' there must be at least one available.                      IOThread ioThread = ChooseIOThread(m_options.Affinity);                        // Create and launch a session object.                      // TODO: send null in address parameter' is unneeded in this case                      SessionBase session = SessionBase.Create(ioThread' false' m_socket' m_options' new Address(m_handle.LocalEndPoint));                      session.IncSeqnum();                      LaunchChild(session);                        SendAttach(session' engine' false);                        m_socket.EventAccepted(m_endpoint' acceptedSocket);                        Accept();                      break;                  }                  case SocketError.ConnectionReset:                  case SocketError.NoBufferSpaceAvailable:                  case SocketError.TooManyOpenSockets:                  {                      m_socket.EventAcceptFailed(m_endpoint' socketError.ToErrorCode());                        Accept();                      break;                  }                  default:                  {                      NetMQException exception = NetMQException.Create(socketError);                        m_socket.EventAcceptFailed(m_endpoint' exception.ErrorCode);                      throw exception;                  }              }
Magic Number,NetMQ.Core.Transports.Tcp,TcpListener,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\Tcp\TcpListener.cs,InCompleted,The following statement contains a magic number: switch (socketError)              {                  case SocketError.Success:                  {                      // TODO: check TcpFilters                      var acceptedSocket = m_handle.GetAcceptedSocket();                            acceptedSocket.NoDelay = true;                        if (m_options.TcpKeepalive != -1)                      {                          acceptedSocket.SetSocketOption(SocketOptionLevel.Socket' SocketOptionName.KeepAlive' m_options.TcpKeepalive);                            if (m_options.TcpKeepaliveIdle != -1 && m_options.TcpKeepaliveIntvl != -1)                          {                              var bytes = new ByteArraySegment(new byte[12]);                                Endianness endian = BitConverter.IsLittleEndian ? Endianness.Little : Endianness.Big;                                bytes.PutInteger(endian' m_options.TcpKeepalive' 0);                              bytes.PutInteger(endian' m_options.TcpKeepaliveIdle' 4);                              bytes.PutInteger(endian' m_options.TcpKeepaliveIntvl' 8);                                acceptedSocket.IOControl(IOControlCode.KeepAliveValues' (byte[])bytes' null);                          }                      }                        // Create the engine object for this connection.                      var engine = new StreamEngine(acceptedSocket' m_options' m_endpoint);                        // Choose I/O thread to run connector in. Given that we are already                      // running in an I/O thread' there must be at least one available.                      IOThread ioThread = ChooseIOThread(m_options.Affinity);                        // Create and launch a session object.                      // TODO: send null in address parameter' is unneeded in this case                      SessionBase session = SessionBase.Create(ioThread' false' m_socket' m_options' new Address(m_handle.LocalEndPoint));                      session.IncSeqnum();                      LaunchChild(session);                        SendAttach(session' engine' false);                        m_socket.EventAccepted(m_endpoint' acceptedSocket);                        Accept();                      break;                  }                  case SocketError.ConnectionReset:                  case SocketError.NoBufferSpaceAvailable:                  case SocketError.TooManyOpenSockets:                  {                      m_socket.EventAcceptFailed(m_endpoint' socketError.ToErrorCode());                        Accept();                      break;                  }                  default:                  {                      NetMQException exception = NetMQException.Create(socketError);                        m_socket.EventAcceptFailed(m_endpoint' exception.ErrorCode);                      throw exception;                  }              }
Magic Number,NetMQ.Core.Utils,ByteArrayEqualityComparer,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Utils\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: int remainder = data.Length & 3;
Magic Number,NetMQ.Core.Utils,ByteArrayEqualityComparer,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Utils\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: var k = (uint)(data[i] | data[i + 1] << 8 | data[i + 2] << 16 | data[i + 3] << 24);
Magic Number,NetMQ.Core.Utils,ByteArrayEqualityComparer,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Utils\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: var k = (uint)(data[i] | data[i + 1] << 8 | data[i + 2] << 16 | data[i + 3] << 24);
Magic Number,NetMQ.Core.Utils,ByteArrayEqualityComparer,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Utils\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: var k = (uint)(data[i] | data[i + 1] << 8 | data[i + 2] << 16 | data[i + 3] << 24);
Magic Number,NetMQ.Core.Utils,ByteArrayEqualityComparer,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Utils\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: var k = (uint)(data[i] | data[i + 1] << 8 | data[i + 2] << 16 | data[i + 3] << 24);
Magic Number,NetMQ.Core.Utils,ByteArrayEqualityComparer,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Utils\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: var k = (uint)(data[i] | data[i + 1] << 8 | data[i + 2] << 16 | data[i + 3] << 24);
Magic Number,NetMQ.Core.Utils,ByteArrayEqualityComparer,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Utils\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: k = (k << 15) | (k >> (32 - 15));
Magic Number,NetMQ.Core.Utils,ByteArrayEqualityComparer,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Utils\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: k = (k << 15) | (k >> (32 - 15));
Magic Number,NetMQ.Core.Utils,ByteArrayEqualityComparer,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Utils\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: k = (k << 15) | (k >> (32 - 15));
Magic Number,NetMQ.Core.Utils,ByteArrayEqualityComparer,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Utils\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 13) | (hash >> (32 - 13));
Magic Number,NetMQ.Core.Utils,ByteArrayEqualityComparer,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Utils\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 13) | (hash >> (32 - 13));
Magic Number,NetMQ.Core.Utils,ByteArrayEqualityComparer,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Utils\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 13) | (hash >> (32 - 13));
Magic Number,NetMQ.Core.Utils,ByteArrayEqualityComparer,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Utils\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: hash = hash * 5 + 0xe6546b64;
Magic Number,NetMQ.Core.Utils,ByteArrayEqualityComparer,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Utils\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: switch (remainder)                      {                          case 3:                              k ^= (uint)data[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)data[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= data[alignedLength];                              break;                      }
Magic Number,NetMQ.Core.Utils,ByteArrayEqualityComparer,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Utils\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: switch (remainder)                      {                          case 3:                              k ^= (uint)data[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)data[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= data[alignedLength];                              break;                      }
Magic Number,NetMQ.Core.Utils,ByteArrayEqualityComparer,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Utils\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: switch (remainder)                      {                          case 3:                              k ^= (uint)data[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)data[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= data[alignedLength];                              break;                      }
Magic Number,NetMQ.Core.Utils,ByteArrayEqualityComparer,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Utils\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: switch (remainder)                      {                          case 3:                              k ^= (uint)data[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)data[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= data[alignedLength];                              break;                      }
Magic Number,NetMQ.Core.Utils,ByteArrayEqualityComparer,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Utils\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: switch (remainder)                      {                          case 3:                              k ^= (uint)data[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)data[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= data[alignedLength];                              break;                      }
Magic Number,NetMQ.Core.Utils,ByteArrayEqualityComparer,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Utils\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: switch (remainder)                      {                          case 3:                              k ^= (uint)data[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)data[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= data[alignedLength];                              break;                      }
Magic Number,NetMQ.Core.Utils,ByteArrayEqualityComparer,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Utils\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: k = (k << 15) | (k >> (32 - 15));
Magic Number,NetMQ.Core.Utils,ByteArrayEqualityComparer,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Utils\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: k = (k << 15) | (k >> (32 - 15));
Magic Number,NetMQ.Core.Utils,ByteArrayEqualityComparer,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Utils\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: k = (k << 15) | (k >> (32 - 15));
Magic Number,NetMQ.Core.Utils,ByteArrayEqualityComparer,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Utils\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: hash ^= hash >> 16;
Magic Number,NetMQ.Core.Utils,ByteArrayEqualityComparer,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Utils\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: hash ^= hash >> 13;
Magic Number,NetMQ.Core.Utils,ByteArrayEqualityComparer,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Utils\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: hash ^= hash >> 16;
Magic Number,NetMQ.Core.Utils,Clock,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Utils\Clock.cs,Clock,The following statement contains a magic number: Environment.OSVersion.Platform == PlatformID.Win32NT ||                      Environment.OSVersion.Platform == PlatformID.Unix ||                      Environment.OSVersion.Platform == (PlatformID)128
Magic Number,NetMQ.Core.Utils,Clock,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Utils\Clock.cs,NowUs,The following statement contains a magic number: double ticksPerMicrosecond = ticksPerSecond / 1000000.0;
Magic Number,NetMQ.Core.Utils,Clock,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Utils\Clock.cs,NowMs,The following statement contains a magic number: return NowUs() / 1000;
Magic Number,NetMQ.Core.Utils,Clock,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Utils\Clock.cs,NowMs,The following statement contains a magic number: tsc - s_lastTsc <= Config.ClockPrecision / 2 && tsc >= s_lastTsc
Magic Number,NetMQ.Core.Utils,Clock,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Utils\Clock.cs,NowMs,The following statement contains a magic number: s_lastTime = NowUs() / 1000;
Magic Number,NetMQ.Core.Utils,Opcode,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Utils\OpCode.cs,Open,The following statement contains a magic number: byte[] rdtscCode = IntPtr.Size == 4 ? RDTSC_32 : RDTSC_64;
Magic Number,NetMQ.Core.Utils,Opcode,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Utils\OpCode.cs,Open,The following statement contains a magic number: (p == 4) || (p == 128)
Magic Number,NetMQ.Core.Utils,Opcode,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Utils\OpCode.cs,Open,The following statement contains a magic number: (p == 4) || (p == 128)
Magic Number,NetMQ.Core.Utils,Opcode,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Utils\OpCode.cs,Close,The following statement contains a magic number: (p == 4) || (p == 128)
Magic Number,NetMQ.Core.Utils,Opcode,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Utils\OpCode.cs,Close,The following statement contains a magic number: (p == 4) || (p == 128)
Magic Number,NetMQ.Core.Utils,Poller,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Utils\Poller.cs,Loop,The following statement contains a magic number: timeout = timeout != 0 ? timeout * 1000 : -1;
Magic Number,NetMQ.Core.Utils,Signaler,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Utils\Signaler.cs,WaitEvent,The following statement contains a magic number: int timeoutInMicroSeconds = (timeout >= 0)                  ? timeout * 1000                  : Timeout.Infinite;
Magic Number,NetMQ.Core.Utils,YQueue<T>,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Utils\YQueue.cs,YQueue,The following statement contains a magic number: chunkSize < 2
Magic Number,NetMQ.Monitoring,NetMQMonitor,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Monitoring\NetMQMonitor.cs,NetMQMonitor,The following statement contains a magic number: Timeout = TimeSpan.FromSeconds(0.5);
Magic Number,NetMQ.Monitoring,NetMQMonitor,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Monitoring\NetMQMonitor.cs,NetMQMonitor,The following statement contains a magic number: Timeout = TimeSpan.FromSeconds(0.5);
Duplicate Code,NetMQ.Core.Transports,StreamEngine,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\StreamEngine.cs,HandleHandshake,The method contains a code clone-set at the following line numbers (starting from the method definition): ((31' 50)' (150' 169))
Missing Default,NetMQ,RoutingKey,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\RoutingKey.cs,GetHashCode,The following switch statement is missing a default case: switch (remainder)                      {                          case 3:                              k ^= (uint)bytes[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)bytes[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= bytes[alignedLength];                              break;                      }
Missing Default,NetMQ.Core,Address,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Address.cs,ToString,The following switch statement is missing a default case: switch (Protocol)                  {                      case TcpProtocol: return Resolved.ToString();                      case IpcProtocol: return Resolved.ToString();                      case PgmProtocol: return Resolved.ToString();                  }
Missing Default,NetMQ.Core,SessionBase,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\SessionBase.cs,StartConnecting,The following switch statement is missing a default case: switch (m_addr.Protocol)              {                  case Address.TcpProtocol:                  {                      LaunchChild(new TcpConnector(ioThread' this' m_options' m_addr' wait));                      return;                  }                  case Address.IpcProtocol:                  {                      LaunchChild(new IpcConnector(ioThread' this' m_options' m_addr' wait));                      return;                  }                  case Address.PgmProtocol:                  case Address.EpgmProtocol:                  {                      var pgmSender = new PgmSender(m_ioThread' m_options' m_addr' wait);                      pgmSender.Init((PgmAddress)m_addr.Resolved);                      SendAttach(this' pgmSender);                      return;                  }              }
Missing Default,NetMQ.Core,SocketBase,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\SocketBase.cs,Bind,The following switch statement is missing a default case: switch (protocol)              {                  case Address.InProcProtocol:                      {                          var endpoint = new Ctx.Endpoint(this' m_options);                          bool addressRegistered = RegisterEndpoint(addr' endpoint);                            if (!addressRegistered)                              throw new AddressAlreadyInUseException($"Cannot bind address ( {addr} ) - already in use.");                            m_options.LastEndpoint = addr;                          return;                      }                  case Address.PgmProtocol:                  case Address.EpgmProtocol:                      {                          if (m_options.SocketType == ZmqSocketType.Pub || m_options.SocketType == ZmqSocketType.Xpub)                          {                              // For convenience's sake' bind can be used interchangeable with                              // connect for PGM and EPGM transports.                              Connect(addr);                              return;                          }                          break;                      }              }
Missing Default,NetMQ.Core,SocketBase,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\SocketBase.cs,Connect,The following switch statement is missing a default case: switch (protocol)              {                  case Address.TcpProtocol:                      {                          paddr.Resolved = (new TcpAddress());                          paddr.Resolved.Resolve(address' m_options.IPv4Only);                          break;                      }                  case Address.IpcProtocol:                      {                          paddr.Resolved = (new IpcAddress());                          paddr.Resolved.Resolve(address' true);                          break;                      }                  case Address.PgmProtocol:                  case Address.EpgmProtocol:                      {                          if (m_options.SocketType == ZmqSocketType.Sub || m_options.SocketType == ZmqSocketType.Xsub)                          {                              Bind(addr);                              return;                          }                          paddr.Resolved = new PgmAddress();                          paddr.Resolved.Resolve(address' m_options.IPv4Only);                          break;                      }              }
Missing Default,NetMQ.Core.Patterns,ReqSession,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Req.cs,PushMsg,The following switch statement is missing a default case: switch (m_state)                  {                      case State.Bottom:                          if (msg.Flags == MsgFlags.More && msg.Size == 0)                          {                              m_state = State.Body;                              return base.PushMsg(ref msg);                          }                          break;                      case State.Body:                          if (msg.Flags == MsgFlags.More)                              return base.PushMsg(ref msg);                          if (msg.Flags == MsgFlags.None)                          {                              m_state = State.Bottom;                              return base.PushMsg(ref msg);                          }                          break;                      case State.Identity:                          if (msg.Flags == MsgFlags.None)                          {                              m_state = State.Bottom;                              return base.PushMsg(ref msg);                          }                          break;                  }
Missing Default,NetMQ.Core.Patterns,Router,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Router.cs,XSetSocketOption,The following switch statement is missing a default case: switch (option)              {                  case ZmqSocketOption.RouterRawSocket:                      m_rawSocket = (bool)optval;                      if (m_rawSocket)                      {                          m_options.RecvIdentity = false;                          m_options.RawSocket = true;                      }                      return true;                  case ZmqSocketOption.RouterMandatory:                      m_mandatory = (bool)optval;                      return true;                  case ZmqSocketOption.RouterHandover:                      m_handover = (bool)optval;                      return true;              }
Missing Default,NetMQ.Core.Patterns,XPub,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Patterns\XPub.cs,XSetSocketOption,The following switch statement is missing a default case: switch (option)              {                  case ZmqSocketOption.XpubVerbose:                  {                      m_verbose = (bool)optionValue;                      return true;                  }                  case ZmqSocketOption.XPublisherManual:                  {                      m_manual = (bool)optionValue;                      return true;                  }                  case ZmqSocketOption.XPublisherBroadcast:                  {                      m_broadcastEnabled = (bool)optionValue;                      return true;                  }                  case ZmqSocketOption.Identity:                  {                      if (m_manual && m_lastPipe != null)                      {                          byte[] val;                            if (optionValue is string)                              val = Encoding.ASCII.GetBytes((string)optionValue);                          else if (optionValue is byte[])                              val = (byte[])optionValue;                          else                              throw new InvalidException($"In XPub.XSetSocketOption(Identity' {optionValue?.ToString() ?? "null"}) optionValue must be a string or byte-array.");                          if (val.Length == 0 || val.Length > 255)                              throw new InvalidException($"In XPub.XSetSocketOption(Identity') optionValue yielded a byte-array of length {val.Length}' should be 1..255.");                            m_lastPipe.Identity = val;                          m_options.Identity = val;                      }                      return true;                  }                    case ZmqSocketOption.Subscribe:                  {                      if (m_manual && m_lastPipe != null)                      {                          var subscription = optionValue as byte[] ?? Encoding.ASCII.GetBytes((string)optionValue);                          m_subscriptions.Add(subscription' 0' subscription.Length' m_lastPipe);                          m_lastPipe = null;                          return true;                      }                      break;                  }                  case ZmqSocketOption.Unsubscribe:                  {                      if (m_manual && m_lastPipe != null)                      {                          var subscription = optionValue as byte[] ?? Encoding.ASCII.GetBytes((string)optionValue);                          m_subscriptions.Remove(subscription' 0' subscription.Length' m_lastPipe);                          m_lastPipe = null;                          return true;                      }                      break;                  }                  case ZmqSocketOption.XPublisherWelcomeMessage:                  {                      m_welcomeMessage.Close();                        if (optionValue != null)                      {                          var bytes = optionValue as byte[];                          if (bytes == null)                              throw new InvalidException($"In XPub.XSetSocketOption({option}'{optionValue})' optionValue must be a byte-array.");                          var welcomeBytes = new byte[bytes.Length];                          bytes.CopyTo(welcomeBytes' 0);                          m_welcomeMessage.InitGC(welcomeBytes' welcomeBytes.Length);                      }                      else                      {                          m_welcomeMessage.InitEmpty();                      }                        return true;                  }              }
Missing Default,NetMQ.Core.Transports,StreamEngine,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\StreamEngine.cs,Handle,The following switch statement is missing a default case: switch (action)                      {                          case Action.Start:                              if (m_options.RawSocket)                              {                                  m_encoder = new RawEncoder(Config.OutBatchSize' m_session' m_options.Endian);                                  m_decoder = new RawDecoder(Config.InBatchSize' m_options.MaxMessageSize' m_session' m_options.Endian);                                    Activate();                              }                              else                              {                                  m_state = State.Handshaking;                                  m_handshakeState = HandshakeState.Closed;                                  HandleHandshake(action' socketError' bytesTransferred);                              }                                break;                      }
Missing Default,NetMQ.Core.Transports,StreamEngine,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Transports\StreamEngine.cs,Handle,The following switch statement is missing a default case: switch (action)                      {                          case Action.ActivateIn:                              // There was an input error but the engine could not                              // be terminated (due to the stalled decoder).                              // Flush the pending message and terminate the engine now.                              m_decoder.ProcessBuffer(m_inpos' 0);                              Debug.Assert(!m_decoder.Stalled());                              m_session.Flush();                              Error();                              break;                          case Action.ActivateOut:                              break;                      }
Missing Default,NetMQ.Core.Utils,ByteArrayEqualityComparer,D:\research\architectureSmells\repos\zeromq_netmq\src\NetMQ\Core\Utils\ByteArrayEqualityComparer.cs,GetHashCode,The following switch statement is missing a default case: switch (remainder)                      {                          case 3:                              k ^= (uint)data[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)data[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= data[alignedLength];                              break;                      }
