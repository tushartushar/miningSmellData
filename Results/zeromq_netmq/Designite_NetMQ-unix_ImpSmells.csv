Implementation smell,Namespace,Class,File,Method,Description
Long Method,NetMQ,NetMQPoller,C:\repos\zeromq_netmq\src\NetMQ\NetMQPoller.cs,Run,The method has 133 lines of code.
Long Method,NetMQ,NetMQSelector,C:\repos\zeromq_netmq\src\NetMQ\NetMQSelector.cs,Select,The method has 112 lines of code.
Long Method,NetMQ.Core,Options,C:\repos\zeromq_netmq\src\NetMQ\Core\Options.cs,SetSocketOption,The method has 102 lines of code.
Long Method,NetMQ.Core,SocketBase,C:\repos\zeromq_netmq\src\NetMQ\Core\SocketBase.cs,Bind,The method has 100 lines of code.
Long Method,NetMQ.Core,SocketBase,C:\repos\zeromq_netmq\src\NetMQ\Core\SocketBase.cs,Connect,The method has 127 lines of code.
Long Method,NetMQ.Core.Patterns.Utils,MultiTrie,C:\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Utils\MultiTrie.cs,RemoveHelper,The method has 104 lines of code.
Long Method,NetMQ.Core.Transports,StreamEngine,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\StreamEngine.cs,HandleHandshake,The method has 212 lines of code.
Complex Method,NetMQ,NetMQPoller,C:\repos\zeromq_netmq\src\NetMQ\NetMQPoller.cs,Run,Cyclomatic complexity of the method is 20
Complex Method,NetMQ,NetMQSelector,C:\repos\zeromq_netmq\src\NetMQ\NetMQSelector.cs,Select,Cyclomatic complexity of the method is 19
Complex Method,NetMQ.Core,SocketBase,C:\repos\zeromq_netmq\src\NetMQ\Core\SocketBase.cs,TrySend,Cyclomatic complexity of the method is 9
Complex Method,NetMQ.Core,SocketBase,C:\repos\zeromq_netmq\src\NetMQ\Core\SocketBase.cs,TryRecv,Cyclomatic complexity of the method is 10
Complex Method,NetMQ.Core.Patterns,Peer,C:\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Peer.cs,XSend,Cyclomatic complexity of the method is 9
Complex Method,NetMQ.Core.Patterns,Rep,C:\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Rep.cs,XRecv,Cyclomatic complexity of the method is 10
Complex Method,NetMQ.Core.Patterns,Req,C:\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Req.cs,XRecv,Cyclomatic complexity of the method is 9
Complex Method,NetMQ.Core.Patterns,Router,C:\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Router.cs,XSend,Cyclomatic complexity of the method is 11
Complex Method,NetMQ.Core.Patterns,Router,C:\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Router.cs,XRecv,Cyclomatic complexity of the method is 10
Complex Method,NetMQ.Core.Patterns,Stream,C:\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Stream.cs,XSend,Cyclomatic complexity of the method is 8
Complex Method,NetMQ.Core.Patterns.Utils,Distribution,C:\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Utils\Distribution.cs,Distribute,Cyclomatic complexity of the method is 8
Complex Method,NetMQ.Core.Patterns.Utils,LoadBalancer,C:\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Utils\LoadBalancer.cs,Send,Cyclomatic complexity of the method is 8
Complex Method,NetMQ.Core.Patterns.Utils,MultiTrie,C:\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Utils\MultiTrie.cs,RemoveHelper,Cyclomatic complexity of the method is 10
Complex Method,NetMQ.Core.Patterns.Utils,MultiTrie,C:\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Utils\MultiTrie.cs,RemoveHelper,Cyclomatic complexity of the method is 8
Complex Method,NetMQ.Core.Patterns.Utils,MultiTrie,C:\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Utils\MultiTrie.cs,Match,Cyclomatic complexity of the method is 10
Complex Method,NetMQ.Core.Transports,DecoderBase,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\DecoderBase.cs,ProcessBuffer,Cyclomatic complexity of the method is 11
Complex Method,NetMQ.Core.Transports,EncoderBase,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\EncoderBase.cs,GetData,Cyclomatic complexity of the method is 8
Complex Method,NetMQ.Core.Utils,Poller,C:\repos\zeromq_netmq\src\NetMQ\Core\Utils\Poller.cs,Loop,Cyclomatic complexity of the method is 9
Long Parameter List,NetMQ,OutgoingSocketExtensions,C:\repos\zeromq_netmq\src\NetMQ\OutgoingSocketExtensions.cs,TrySendFrame,The method has 5 parameters. Parameters: socket' timeout' data' length' more
Long Parameter List,NetMQ,Proxy,C:\repos\zeromq_netmq\src\NetMQ\Proxy.cs,Proxy,The method has 5 parameters. Parameters: frontend' backend' controlIn' controlOut' poller
Long Parameter List,NetMQ,ReceivingSocketExtensions,C:\repos\zeromq_netmq\src\NetMQ\ReceivingSocketExtensions.cs,TryReceiveFrameString,The method has 5 parameters. Parameters: socket' timeout' encoding' frameString' more
Long Parameter List,NetMQ,ReceivingSocketExtensions,C:\repos\zeromq_netmq\src\NetMQ\ReceivingSocketExtensions.cs,TryReceiveMultipartStrings,The method has 5 parameters. Parameters: socket' timeout' encoding' frames' expectedFrameCount
Long Parameter List,NetMQ.Core,Pipe,C:\repos\zeromq_netmq\src\NetMQ\Core\Pipe.cs,Pipe,The method has 7 parameters. Parameters: parent' inboundPipe' outboundPipe' inHighWatermark' outHighWatermark' predefinedLowWatermark' delay
Long Parameter List,NetMQ.Core,SessionBase,C:\repos\zeromq_netmq\src\NetMQ\Core\SessionBase.cs,Create,The method has 5 parameters. Parameters: ioThread' connect' socket' options' addr
Long Parameter List,NetMQ.Core,SessionBase,C:\repos\zeromq_netmq\src\NetMQ\Core\SessionBase.cs,SessionBase,The method has 5 parameters. Parameters: ioThread' connect' socket' options' addr
Long Parameter List,NetMQ.Core.Patterns,DealerSession,C:\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Dealer.cs,DealerSession,The method has 5 parameters. Parameters: ioThread' connect' socket' options' addr
Long Parameter List,NetMQ.Core.Patterns,PairSession,C:\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Pair.cs,PairSession,The method has 5 parameters. Parameters: ioThread' connect' socket' options' addr
Long Parameter List,NetMQ.Core.Patterns,PeerSession,C:\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Peer.cs,PeerSession,The method has 5 parameters. Parameters: ioThread' connect' socket' options' addr
Long Parameter List,NetMQ.Core.Patterns,PubSession,C:\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Pub.cs,PubSession,The method has 5 parameters. Parameters: ioThread' connect' socket' options' addr
Long Parameter List,NetMQ.Core.Patterns,PullSession,C:\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Pull.cs,PullSession,The method has 5 parameters. Parameters: ioThread' connect' socket' options' addr
Long Parameter List,NetMQ.Core.Patterns,PushSession,C:\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Push.cs,PushSession,The method has 5 parameters. Parameters: ioThread' connect' socket' options' addr
Long Parameter List,NetMQ.Core.Patterns,RepSession,C:\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Rep.cs,RepSession,The method has 5 parameters. Parameters: ioThread' connect' socket' options' addr
Long Parameter List,NetMQ.Core.Patterns,ReqSession,C:\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Req.cs,ReqSession,The method has 5 parameters. Parameters: ioThread' connect' socket' options' addr
Long Parameter List,NetMQ.Core.Patterns,RouterSession,C:\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Router.cs,RouterSession,The method has 5 parameters. Parameters: ioThread' connect' socket' options' addr
Long Parameter List,NetMQ.Core.Patterns,StreamSession,C:\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Stream.cs,StreamSession,The method has 5 parameters. Parameters: ioThread' connect' socket' options' addr
Long Parameter List,NetMQ.Core.Patterns,SubSession,C:\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Sub.cs,SubSession,The method has 5 parameters. Parameters: ioThread' connect' socket' options' addr
Long Parameter List,NetMQ.Core.Patterns,XPubSession,C:\repos\zeromq_netmq\src\NetMQ\Core\Patterns\XPub.cs,XPubSession,The method has 5 parameters. Parameters: ioThread' connect' socket' options' addr
Long Parameter List,NetMQ.Core.Patterns,XSubSession,C:\repos\zeromq_netmq\src\NetMQ\Core\Patterns\XSub.cs,XSubSession,The method has 5 parameters. Parameters: ioThread' connect' socket' options' addr
Long Parameter List,NetMQ.Core.Patterns.Utils,MultiTrie,C:\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Utils\MultiTrie.cs,RemoveHelper,The method has 6 parameters. Parameters: pipe' buffer' bufferSize' maxBufferSize' func' arg
Long Parameter List,NetMQ.Core.Patterns.Utils,MultiTrie,C:\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Utils\MultiTrie.cs,Match,The method has 5 parameters. Parameters: data' offset' size' func' arg
Long Parameter List,NetMQ.Core.Patterns.Utils,Trie,C:\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Utils\Trie.cs,ApplyHelper,The method has 5 parameters. Parameters: buffer' bufferSize' maxBufferSize' func' arg
Long Parameter List,NetMQ.Core.Transports.Ipc,IpcConnector,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\Ipc\IpcConnector.cs,IpcConnector,The method has 5 parameters. Parameters: ioThread' session' options' addr' wait
Long Parameter List,NetMQ.Core.Transports.Tcp,TcpConnector,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\Tcp\TcpConnector.cs,TcpConnector,The method has 5 parameters. Parameters: ioThread' session' options' addr' delayedStart
Long Parameter List,NetMQ.Sockets,RequestSocket,C:\repos\zeromq_netmq\src\NetMQ\Sockets\RequestSocket.cs,RequestResponseMultipartMessageWithRetry,The method has 5 parameters. Parameters: address' requestMessage' numTries' requestTimeout' progressPublisher
Long Parameter List,NetMQ.Sockets,RequestSocket,C:\repos\zeromq_netmq\src\NetMQ\Sockets\RequestSocket.cs,RequestResponseStringWithRetry,The method has 5 parameters. Parameters: address' requestString' numTries' requestTimeout' progressPublisher
Long Statement,NetMQ,Msg,C:\repos\zeromq_netmq\src\NetMQ\Msg.cs,RemoveReferences,The length of the statement  "                // TODO shouldn't we set the type to uninitialised' or call clear' here? the object has a null refCount' but other methods may try to use it " is 140.
Long Statement,NetMQ,Msg,C:\repos\zeromq_netmq\src\NetMQ\Msg.cs,TrimPrefix,The length of the statement  "            if (count > Size || count < 0) throw new ArgumentOutOfRangeException(nameof(count)' "Count should be between 0 and size"); " is 122.
Long Statement,NetMQ,Shim,C:\repos\zeromq_netmq\src\NetMQ\NetMQBeacon.cs,SendUdpFrame,The length of the statement  "                    // due to network change which causes crash (if no try/catch and keep trying to send to incorrect/not available address. " is 120.
Long Statement,NetMQ,NetMQPoller,C:\repos\zeromq_netmq\src\NetMQ\NetMQPoller.cs,Run,The length of the statement  "                        //      Solution should be different' but sleep is more natural here than in selector (timers are not selector concern). " is 120.
Long Statement,NetMQ,NetMQPoller,C:\repos\zeromq_netmq\src\NetMQ\NetMQPoller.cs,RebuildPollset,The length of the statement  "            // put a corresponding SelectItem into the m_pollSet array and a reference to the socket itself into the m_pollact array. " is 121.
Long Statement,NetMQ,NetMQPoller,C:\repos\zeromq_netmq\src\NetMQ\NetMQPoller.cs,Dispose,The length of the statement  "            if (Interlocked.CompareExchange(ref m_disposeState' (int)DisposeState.Disposing' (int)DisposeState.Undisposed) != (int)DisposeState.Undisposed) " is 143.
Long Statement,NetMQ,NetMQPoller,C:\repos\zeromq_netmq\src\NetMQ\NetMQPoller.cs,Dispose,The length of the statement  "                    throw new NetMQException($"Invalid state detected: {nameof(NetMQPoller)} contains a disposed {nameof(NetMQSocket)}. Sockets must be either removed before being disposed' or disposed after the poller is disposed."); " is 214.
Long Statement,NetMQ,NetMQSelector,C:\repos\zeromq_netmq\src\NetMQ\NetMQSelector.cs,Select,The length of the statement  "                    string xMsg = $"In Selector.Select' Socket.Select({textOfListRead}' {textOfListWrite}' {textOfListError}' {currentTimeoutMicroSeconds}) threw a SocketException: {x.Message}"; " is 174.
Long Statement,NetMQ,ReceivingSocketExtensions,C:\repos\zeromq_netmq\src\NetMQ\ReceivingSocketExtensions.cs,TryReceiveFrameString,The length of the statement  "            return socket.TryReceiveFrameString(TimeSpan.Zero' SendReceiveConstants.DefaultEncoding' out frameString' out bool more); " is 121.
Long Statement,NetMQ,ReceivingSocketExtensions,C:\repos\zeromq_netmq\src\NetMQ\ReceivingSocketExtensions.cs,TryReceiveMultipartStrings,The length of the statement  "            return TryReceiveMultipartStrings(socket' timeout' SendReceiveConstants.DefaultEncoding' ref frames' expectedFrameCount); " is 121.
Long Statement,NetMQ,ReceivingSocketExtensions,C:\repos\zeromq_netmq\src\NetMQ\ReceivingSocketExtensions.cs,TryReceiveSignal,The length of the statement  "            // TODO use clock to enforce timeout across multiple loop iterations â€” if invalid messages are received regularly' the method may not return once the timeout elapses " is 165.
Long Statement,NetMQ.Core,Address,C:\repos\zeromq_netmq\src\NetMQ\Core\Address.cs,ToString,The length of the statement  "            return null; //TODO: REVIEW - Although not explicitly prohibited' returning null from ToString seems sketchy; return string.Empty? " is 130.
Long Statement,NetMQ.Core,Options,C:\repos\zeromq_netmq\src\NetMQ\Core\Options.cs,SetSocketOption,The length of the statement  "                        throw new InvalidException($"In Options.SetSocketOption(Identity' {optionValue?.ToString() ?? "null"}) optionValue must be a string or byte-array."); " is 149.
Long Statement,NetMQ.Core,Options,C:\repos\zeromq_netmq\src\NetMQ\Core\Options.cs,SetSocketOption,The length of the statement  "                        throw new InvalidException($"In Options.SetSocketOption(Identity') optionValue yielded a byte-array of length {val.Length}' should be 1..255."); " is 144.
Long Statement,NetMQ.Core,Options,C:\repos\zeromq_netmq\src\NetMQ\Core\Options.cs,SetSocketOption,The length of the statement  "                        throw new InvalidException($"Options.SetSocketOption(ReconnectIvlMax' {reconnectIvlMax}) optionValue must be non-negative."); " is 125.
Long Statement,NetMQ.Core,Options,C:\repos\zeromq_netmq\src\NetMQ\Core\Options.cs,SetSocketOption,The length of the statement  "                        throw new InvalidException($"Options.SetSocketOption(TcpKeepalive' {tcpKeepalive}) optionValue is neither -1' 0' nor 1."); " is 122.
Long Statement,NetMQ.Core.Patterns,ReqSession,C:\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Req.cs,PushMsg,The length of the statement  "                // TODO the flags checks here don't check specific bits -- should they use HasMore instead? does this work with shared Msg objects? " is 131.
Long Statement,NetMQ.Core.Patterns,Sub,C:\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Sub.cs,XSetSocketOption,The length of the statement  "                throw new InvalidException($"In Sub.XSetSocketOption({option}'{optionValue?.ToString() ?? "null"})' optionValue must be either a string or a byte-array."); " is 155.
Long Statement,NetMQ.Core.Patterns,XPub,C:\repos\zeromq_netmq\src\NetMQ\Core\Patterns\XPub.cs,XSetSocketOption,The length of the statement  "                            throw new InvalidException($"In XPub.XSetSocketOption(Identity' {optionValue?.ToString() ?? "null"}) optionValue must be a string or byte-array."); " is 147.
Long Statement,NetMQ.Core.Patterns,XPub,C:\repos\zeromq_netmq\src\NetMQ\Core\Patterns\XPub.cs,XSetSocketOption,The length of the statement  "                            throw new InvalidException($"In XPub.XSetSocketOption(Identity') optionValue yielded a byte-array of length {val.Length}' should be 1..255."); " is 142.
Long Statement,NetMQ.Core.Patterns.Utils,MultiTrie,C:\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Utils\MultiTrie.cs,AddHelper,The length of the statement  "                    m_count = (m_minCharacter < currentCharacter ? currentCharacter - m_minCharacter : m_minCharacter - currentCharacter) + 1; " is 122.
Long Statement,NetMQ.Core.Patterns.Utils,Trie,C:\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Utils\Trie.cs,Add,The length of the statement  "                    m_count = (short)((m_minCharacter < currentCharacter ? currentCharacter - m_minCharacter : m_minCharacter - currentCharacter) + 1); " is 131.
Long Statement,NetMQ.Core.Transports.Pgm,PgmAddress,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\Pgm\PgmAddress.cs,Resolve,The length of the statement  "                    throw new InvalidException($"In PgmAddress.Resolve({name}'{ip4Only})' portStr ({portStr}) must denote a valid nonzero integer."); " is 129.
Long Statement,NetMQ.Core.Transports.Pgm,PgmSocket,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\Pgm\PgmSocket.cs,Init,The length of the statement  "                string xMsg = $"SocketException with SocketErrorCode={x.SocketErrorCode}' Message={x.Message}' in PgmSocket.Init' within AsyncSocket.Create(AddressFamily.InterNetwork' SocketType.Rdm' PGM_PROTOCOL_TYPE)' {this}"; " is 212.
Long Statement,NetMQ.Core.Transports.Pgm,PgmSocket,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\Pgm\PgmSocket.cs,Init,The length of the statement  "                // If running on Microsoft Windows' suggest to the developer that he may need to install MSMQ in order to get PGM socket support. " is 129.
Long Statement,NetMQ.Core.Transports.Pgm,PgmSocket,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\Pgm\PgmSocket.cs,Init,The length of the statement  "                    Debug.WriteLine("For Microsoft Windows' you may want to check to see whether you have installed MSMQ on this host' to get PGM socket support."); " is 144.
Long Statement,NetMQ.Core.Transports.Pgm,PgmSocket,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\Pgm\PgmSocket.cs,InitOptions,The length of the statement  "            if (m_options.ReceiveBuffer > 0 && (m_pgmSocketType == PgmSocketType.Receiver || m_pgmSocketType == PgmSocketType.Listener)) " is 124.
Long Statement,NetMQ.Core.Transports.Pgm,PgmSocket,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\Pgm\PgmSocket.cs,InitOptions,The length of the statement  "                // instead of using the struct _RM_SEND_WINDOW we are using byte array of size 12 (the size of the original struct and the size of three ints) " is 142.
Long Statement,NetMQ.Core.Transports.Pgm,PgmSocket,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\Pgm\PgmSocket.cs,InitOptions,The length of the statement  "                // we are not setting the size in bytes because it get filled automatically' if we want to set it we would just uncomment the following lines " is 141.
Long Statement,NetMQ.Core.Transports.Tcp,TcpAddress,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\Tcp\TcpAddress.cs,Resolve,The length of the statement  "                    : availableAddresses.FirstOrDefault(ip => ip.AddressFamily == AddressFamily.InterNetwork || ip.AddressFamily == AddressFamily.InterNetworkV6); " is 142.
Long Statement,NetMQ.Core.Utils,Opcode,C:\repos\zeromq_netmq\src\NetMQ\Core\Utils\OpCode.cs,IsARMArchitecture,The length of the statement  "            Assembly currentAssembly = Assembly.Load("Mono.Posix' Version=2.0.0.0' Culture=neutral' PublicKeyToken=0738eb9f132ed756"); " is 122.
Long Statement,NetMQ.Core.Utils,Poller,C:\repos\zeromq_netmq\src\NetMQ\Core\Utils\Poller.cs,RemoveHandle,The length of the statement  "            // If the socket was removed before being added there is no reason to mark retired' so just cancelling the socket and removing from add list. " is 141.
Long Statement,NetMQ.Core.Utils,SocketUtility,C:\repos\zeromq_netmq\src\NetMQ\Core\Utils\SocketUtility.cs,Select,The length of the statement  "            // .NET 3.5 has a bug' such that -1 is not blocking the select call - therefore we use here instead the maximum integer value. " is 126.
Long Statement,NetMQ.Monitoring,NetMQMonitor,C:\repos\zeromq_netmq\src\NetMQ\Monitoring\NetMQMonitor.cs,Handle,The length of the statement  "                    InvokeEvent(Connected' new NetMQMonitorSocketEventArgs(this' monitorEvent.Addr' (AsyncSocket)monitorEvent.Arg' SocketEvents.Connected)); " is 136.
Long Statement,NetMQ.Monitoring,NetMQMonitor,C:\repos\zeromq_netmq\src\NetMQ\Monitoring\NetMQMonitor.cs,Handle,The length of the statement  "                    InvokeEvent(ConnectDelayed' new NetMQMonitorErrorEventArgs(this' monitorEvent.Addr' (ErrorCode)monitorEvent.Arg' SocketEvents.ConnectDelayed)); " is 143.
Long Statement,NetMQ.Monitoring,NetMQMonitor,C:\repos\zeromq_netmq\src\NetMQ\Monitoring\NetMQMonitor.cs,Handle,The length of the statement  "                    InvokeEvent(ConnectRetried' new NetMQMonitorIntervalEventArgs(this' monitorEvent.Addr' (int)monitorEvent.Arg' SocketEvents.ConnectRetried)); " is 140.
Long Statement,NetMQ.Monitoring,NetMQMonitor,C:\repos\zeromq_netmq\src\NetMQ\Monitoring\NetMQMonitor.cs,Handle,The length of the statement  "                    InvokeEvent(Listening' new NetMQMonitorSocketEventArgs(this' monitorEvent.Addr' (AsyncSocket)monitorEvent.Arg' SocketEvents.Listening)); " is 136.
Long Statement,NetMQ.Monitoring,NetMQMonitor,C:\repos\zeromq_netmq\src\NetMQ\Monitoring\NetMQMonitor.cs,Handle,The length of the statement  "                    InvokeEvent(BindFailed' new NetMQMonitorErrorEventArgs(this' monitorEvent.Addr' (ErrorCode)monitorEvent.Arg' SocketEvents.BindFailed)); " is 135.
Long Statement,NetMQ.Monitoring,NetMQMonitor,C:\repos\zeromq_netmq\src\NetMQ\Monitoring\NetMQMonitor.cs,Handle,The length of the statement  "                    InvokeEvent(Accepted' new NetMQMonitorSocketEventArgs(this' monitorEvent.Addr' (AsyncSocket)monitorEvent.Arg' SocketEvents.Accepted)); " is 134.
Long Statement,NetMQ.Monitoring,NetMQMonitor,C:\repos\zeromq_netmq\src\NetMQ\Monitoring\NetMQMonitor.cs,Handle,The length of the statement  "                    InvokeEvent(AcceptFailed' new NetMQMonitorErrorEventArgs(this' monitorEvent.Addr' (ErrorCode)monitorEvent.Arg' SocketEvents.AcceptFailed)); " is 139.
Long Statement,NetMQ.Monitoring,NetMQMonitor,C:\repos\zeromq_netmq\src\NetMQ\Monitoring\NetMQMonitor.cs,Handle,The length of the statement  "                    InvokeEvent(Closed' new NetMQMonitorSocketEventArgs(this' monitorEvent.Addr' (AsyncSocket)monitorEvent.Arg' SocketEvents.Closed)); " is 130.
Long Statement,NetMQ.Monitoring,NetMQMonitor,C:\repos\zeromq_netmq\src\NetMQ\Monitoring\NetMQMonitor.cs,Handle,The length of the statement  "                    InvokeEvent(CloseFailed' new NetMQMonitorErrorEventArgs(this' monitorEvent.Addr' (ErrorCode)monitorEvent.Arg' SocketEvents.CloseFailed)); " is 137.
Long Statement,NetMQ.Monitoring,NetMQMonitor,C:\repos\zeromq_netmq\src\NetMQ\Monitoring\NetMQMonitor.cs,Handle,The length of the statement  "                    InvokeEvent(Disconnected' new NetMQMonitorSocketEventArgs(this' monitorEvent.Addr' (AsyncSocket)monitorEvent.Arg' SocketEvents.Disconnected)); " is 142.
Long Statement,NetMQ.Monitoring,NetMQMonitor,C:\repos\zeromq_netmq\src\NetMQ\Monitoring\NetMQMonitor.cs,Stop,The length of the statement  "                throw new InvalidOperationException("Monitor attached to a poller' please detach from poller and don't use the stop method"); " is 125.
Complex Conditional,NetMQ.Core,SessionBase,C:\repos\zeromq_netmq\src\NetMQ\Core\SessionBase.cs,Detached,The conditional expression  "m_pipe != null && m_options.DelayAttachOnConnect                  && m_addr.Protocol != Address.PgmProtocol && m_addr.Protocol != Address.EpgmProtocol &&                   m_options.SocketType != ZmqSocketType.Peer"  is complex.
Complex Conditional,NetMQ.Core.Patterns,XPub,C:\repos\zeromq_netmq\src\NetMQ\Core\Patterns\XPub.cs,XReadActivated,The conditional expression  "!msgMore && !isBroadcast && size > 0 && (sub[0] == 0 || sub[0] == 1)"  is complex.
Complex Conditional,NetMQ.Core.Patterns,XPub,C:\repos\zeromq_netmq\src\NetMQ\Core\Patterns\XPub.cs,XReadActivated,The conditional expression  "!msgMore && m_broadcastEnabled && size > 0 && sub[0] == 2"  is complex.
Complex Conditional,NetMQ.Core.Patterns,XPub,C:\repos\zeromq_netmq\src\NetMQ\Core\Patterns\XPub.cs,XRecv,The conditional expression  "!m_moreIn && m_manual && (msg[0] == 0 || msg[0] == 1)"  is complex.
Complex Conditional,NetMQ.Core.Transports,StreamEngine,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\StreamEngine.cs,EndWrite,The conditional expression  "bytesTransferred == 0 ||                  socketError == SocketError.NetworkDown ||                  socketError == SocketError.NetworkReset ||                  socketError == SocketError.HostUnreachable ||                  socketError == SocketError.ConnectionAborted ||                  socketError == SocketError.TimedOut ||                  socketError == SocketError.ConnectionReset ||                  socketError == SocketError.AccessDenied"  is complex.
Complex Conditional,NetMQ.Core.Transports,StreamEngine,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\StreamEngine.cs,EndRead,The conditional expression  "bytesTransferred == 0 ||                  socketError == SocketError.NetworkDown ||                  socketError == SocketError.NetworkReset ||                  socketError == SocketError.HostUnreachable ||                  socketError == SocketError.ConnectionAborted ||                  socketError == SocketError.TimedOut ||                  socketError == SocketError.ConnectionReset ||                  socketError == SocketError.AccessDenied"  is complex.
Complex Conditional,NetMQ.Core.Transports.Tcp,TcpConnector,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\Tcp\TcpConnector.cs,OutCompleted,The conditional expression  "socketError == SocketError.ConnectionRefused || socketError == SocketError.TimedOut ||                      socketError == SocketError.ConnectionAborted ||                      socketError == SocketError.HostUnreachable || socketError == SocketError.NetworkUnreachable ||                      socketError == SocketError.NetworkDown || socketError == SocketError.AccessDenied ||                      socketError == SocketError.OperationAborted"  is complex.
Empty Catch Block,NetMQ,NetMQActor,C:\repos\zeromq_netmq\src\NetMQ\NetMQActor.cs,NetMQActor,The method has an empty catch block.
Empty Catch Block,NetMQ,NetMQActor,C:\repos\zeromq_netmq\src\NetMQ\NetMQActor.cs,RunShim,The method has an empty catch block.
Empty Catch Block,NetMQ.Core,SocketBase,C:\repos\zeromq_netmq\src\NetMQ\Core\SocketBase.cs,InEvent,The method has an empty catch block.
Empty Catch Block,NetMQ.Core.Transports,StreamEngine,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\StreamEngine.cs,Destroy,The method has an empty catch block.
Empty Catch Block,NetMQ.Core.Transports.Pgm,PgmSession,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\Pgm\PgmSession.cs,Destroy,The method has an empty catch block.
Empty Catch Block,NetMQ.Core.Transports.Pgm,PgmSocket,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\Pgm\PgmSocket.cs,InitOptions,The method has an empty catch block.
Empty Catch Block,NetMQ.Core.Transports.Tcp,TcpConnector,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\Tcp\TcpConnector.cs,StartConnecting,The method has an empty catch block.
Empty Catch Block,NetMQ.Core.Transports.Tcp,TcpListener,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\Tcp\TcpListener.cs,SetAddress,The method has an empty catch block.
Empty Catch Block,NetMQ.Core.Utils,Poller,C:\repos\zeromq_netmq\src\NetMQ\Core\Utils\Poller.cs,Destroy,The method has an empty catch block.
Empty Catch Block,NetMQ.Core.Utils,Poller,C:\repos\zeromq_netmq\src\NetMQ\Core\Utils\Poller.cs,Loop,The method has an empty catch block.
Empty Catch Block,NetMQ.Core.Utils,Poller,C:\repos\zeromq_netmq\src\NetMQ\Core\Utils\Poller.cs,Loop,The method has an empty catch block.
Empty Catch Block,NetMQ.Core.Utils,Proactor,C:\repos\zeromq_netmq\src\NetMQ\Core\Utils\Proactor.cs,Destroy,The method has an empty catch block.
Empty Catch Block,NetMQ.Core.Utils,Proactor,C:\repos\zeromq_netmq\src\NetMQ\Core\Utils\Proactor.cs,Loop,The method has an empty catch block.
Empty Catch Block,NetMQ.Core.Utils,Signaler,C:\repos\zeromq_netmq\src\NetMQ\Core\Utils\Signaler.cs,Close,The method has an empty catch block.
Empty Catch Block,NetMQ.Core.Utils,Signaler,C:\repos\zeromq_netmq\src\NetMQ\Core\Utils\Signaler.cs,Close,The method has an empty catch block.
Empty Catch Block,NetMQ.Core.Utils,Signaler,C:\repos\zeromq_netmq\src\NetMQ\Core\Utils\Signaler.cs,Close,The method has an empty catch block.
Empty Catch Block,NetMQ.Monitoring,NetMQMonitor,C:\repos\zeromq_netmq\src\NetMQ\Monitoring\NetMQMonitor.cs,InternalClose,The method has an empty catch block.
Magic Number,NetMQ,InterfaceCollection,C:\repos\zeromq_netmq\src\NetMQ\InterfaceCollection.cs,InterfaceCollection,The following statement contains a magic number: foreach (var address in addresses)              {                  byte[] broadcastBytes = address.Address.GetAddressBytes();                  byte[] mask = address.IPv4Mask.GetAddressBytes();                    broadcastBytes[0] |= (byte)~mask[0];                  broadcastBytes[1] |= (byte)~mask[1];                  broadcastBytes[2] |= (byte)~mask[2];                  broadcastBytes[3] |= (byte)~mask[3];                    var broadcastAddress = new IPAddress(broadcastBytes);                    m_interfaceItems.Add(new InterfaceItem(address.Address' broadcastAddress));              }
Magic Number,NetMQ,InterfaceCollection,C:\repos\zeromq_netmq\src\NetMQ\InterfaceCollection.cs,InterfaceCollection,The following statement contains a magic number: foreach (var address in addresses)              {                  byte[] broadcastBytes = address.Address.GetAddressBytes();                  byte[] mask = address.IPv4Mask.GetAddressBytes();                    broadcastBytes[0] |= (byte)~mask[0];                  broadcastBytes[1] |= (byte)~mask[1];                  broadcastBytes[2] |= (byte)~mask[2];                  broadcastBytes[3] |= (byte)~mask[3];                    var broadcastAddress = new IPAddress(broadcastBytes);                    m_interfaceItems.Add(new InterfaceItem(address.Address' broadcastAddress));              }
Magic Number,NetMQ,InterfaceCollection,C:\repos\zeromq_netmq\src\NetMQ\InterfaceCollection.cs,InterfaceCollection,The following statement contains a magic number: foreach (var address in addresses)              {                  byte[] broadcastBytes = address.Address.GetAddressBytes();                  byte[] mask = address.IPv4Mask.GetAddressBytes();                    broadcastBytes[0] |= (byte)~mask[0];                  broadcastBytes[1] |= (byte)~mask[1];                  broadcastBytes[2] |= (byte)~mask[2];                  broadcastBytes[3] |= (byte)~mask[3];                    var broadcastAddress = new IPAddress(broadcastBytes);                    m_interfaceItems.Add(new InterfaceItem(address.Address' broadcastAddress));              }
Magic Number,NetMQ,InterfaceCollection,C:\repos\zeromq_netmq\src\NetMQ\InterfaceCollection.cs,InterfaceCollection,The following statement contains a magic number: foreach (var address in addresses)              {                  byte[] broadcastBytes = address.Address.GetAddressBytes();                  byte[] mask = address.IPv4Mask.GetAddressBytes();                    broadcastBytes[0] |= (byte)~mask[0];                  broadcastBytes[1] |= (byte)~mask[1];                  broadcastBytes[2] |= (byte)~mask[2];                  broadcastBytes[3] |= (byte)~mask[3];                    var broadcastAddress = new IPAddress(broadcastBytes);                    m_interfaceItems.Add(new InterfaceItem(address.Address' broadcastAddress));              }
Magic Number,NetMQ,Msg,C:\repos\zeromq_netmq\src\NetMQ\Msg.cs,Copy,The following statement contains a magic number: if (src.MsgType == MsgType.Pool)              {                  // One reference is added to shared messages. Non-shared messages                  // are turned into shared messages and reference count is set to 2.                  if (IsShared)                  {                      src.m_refCount.Increase(1);                  }                  else                  {                      src.Flags |= MsgFlags.Shared;                      src.m_refCount.Set(2);                  }              }
Magic Number,NetMQ,NetMQActor,C:\repos\zeromq_netmq\src\NetMQ\NetMQActor.cs,NetMQActor,The following statement contains a magic number: while (true)              {                  try                  {                      actorName = $"NetMQActor-{random.Next(0' 10000)}-{random.Next(0' 10000)}";                      endPoint = $"inproc://{actorName}";                      m_self.Bind(endPoint);                      break;                  }                  catch (AddressAlreadyInUseException)                  {                      // Loop around and try another random address                  }              }
Magic Number,NetMQ,NetMQActor,C:\repos\zeromq_netmq\src\NetMQ\NetMQActor.cs,NetMQActor,The following statement contains a magic number: while (true)              {                  try                  {                      actorName = $"NetMQActor-{random.Next(0' 10000)}-{random.Next(0' 10000)}";                      endPoint = $"inproc://{actorName}";                      m_self.Bind(endPoint);                      break;                  }                  catch (AddressAlreadyInUseException)                  {                      // Loop around and try another random address                  }              }
Magic Number,NetMQ,NetMQFrame,C:\repos\zeromq_netmq\src\NetMQ\NetMQFrame.cs,GetHashCode,The following statement contains a magic number: if (m_hash == 0)              {                  foreach (var b in Buffer)                  {                      m_hash = (31*m_hash) ^ b;                  }              }
Magic Number,NetMQ,NetMQQueue<T>,C:\repos\zeromq_netmq\src\NetMQ\NetMQQueue.cs,NetMQQueue,The following statement contains a magic number: m_writer.Options.SendHighWatermark = m_reader.Options.ReceiveHighWatermark = capacity / 2;
Magic Number,NetMQ,NetMQSelector,C:\repos\zeromq_netmq\src\NetMQ\NetMQSelector.cs,Select,The following statement contains a magic number: while (true)              {                  long currentTimeoutMicroSeconds;                    if (firstPass)                  {                      currentTimeoutMicroSeconds = 0;                  }                  else if (timeout < 0)                  {                      // Consider everything below 0 to be infinite                      currentTimeoutMicroSeconds = -1;                  }                  else                  {                      currentTimeoutMicroSeconds = (timeout - stopwatch.ElapsedMilliseconds) * 1000;                        if (currentTimeoutMicroSeconds < 0)                      {                          currentTimeoutMicroSeconds = 0;                      }                      else if (currentTimeoutMicroSeconds > int.MaxValue)                      {                          currentTimeoutMicroSeconds = int.MaxValue;                      }                  }                    m_checkRead.Clear();                  m_checkWrite.Clear();                  m_checkError.Clear();                    for (int i = 0; i < itemsCount; i++)                  {                      var pollItem = items[i];                        if (pollItem.Socket != null)                      {                          if (pollItem.Event != PollEvents.None && pollItem.Socket.SocketHandle.Handle.Connected)                              m_checkRead.Add(pollItem.Socket.SocketHandle.Handle);                      }                      else                      {                          if (pollItem.Event.HasIn())                              m_checkRead.Add(pollItem.FileDescriptor);                            if (pollItem.Event.HasOut())                              m_checkWrite.Add(pollItem.FileDescriptor);                      }                  }                    try                  {                      SocketUtility.Select(m_checkRead' m_checkWrite' m_checkError' (int)currentTimeoutMicroSeconds);                  }                  catch (SocketException x)                  {  #if DEBUG                      string textOfListRead = StringLib.AsString(m_checkRead);                      string textOfListWrite = StringLib.AsString(m_checkWrite);                      string textOfListError = StringLib.AsString(m_checkError);                      string xMsg = $"In Selector.Select' Socket.Select({textOfListRead}' {textOfListWrite}' {textOfListError}' {currentTimeoutMicroSeconds}) threw a SocketException: {x.Message}";                      Debug.WriteLine(xMsg);                      throw new FaultException(innerException: x' message: xMsg);  #else                      throw new FaultException(innerException: x' message: "Within SocketUtility.Select");  #endif                  }                    for (int i = 0; i < itemsCount; i++)                  {                      var selectItem = items[i];                        selectItem.ResultEvent = PollEvents.None;                        if (selectItem.Socket != null)                      {                          var events = (PollEvents)selectItem.Socket.GetSocketOption(ZmqSocketOption.Events);                            if (selectItem.Event.HasIn() && events.HasIn())                              selectItem.ResultEvent |= PollEvents.PollIn;                            if (selectItem.Event.HasOut() && events.HasOut())                              selectItem.ResultEvent |= PollEvents.PollOut;                      }                      else                      {                          if (m_checkRead.Contains(selectItem.FileDescriptor))                              selectItem.ResultEvent |= PollEvents.PollIn;                            if (m_checkWrite.Contains(selectItem.FileDescriptor))                              selectItem.ResultEvent |= PollEvents.PollOut;                      }                        if (selectItem.ResultEvent != PollEvents.None)                          numberOfEvents++;                  }                    if (timeout == 0)                      break;                    if (numberOfEvents > 0)                      break;                    if (timeout < 0)                  {                      if (firstPass)                          firstPass = false;                        continue;                  }                    if (firstPass)                  {                      stopwatch = Stopwatch.StartNew();                      firstPass = false;                      continue;                  }                    // Check also equality as it might frequently occur on 1000Hz clock                  if (stopwatch.ElapsedMilliseconds >= timeout)                      break;              }
Magic Number,NetMQ,NetworkOrderBitsConverter,C:\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,ToInt16,The following statement contains a magic number: var i = buffer[0] << 8 |                      buffer[1];
Magic Number,NetMQ,NetworkOrderBitsConverter,C:\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,GetBytes,The following statement contains a magic number: var buffer = new byte[2];
Magic Number,NetMQ,NetworkOrderBitsConverter,C:\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,PutInt16,The following statement contains a magic number: buffer[0] = (byte)(value >> 8);
Magic Number,NetMQ,NetworkOrderBitsConverter,C:\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,ToInt32,The following statement contains a magic number: return                   buffer[0] << 24 |                  buffer[1] << 16 |                   buffer[2] <<  8 |                   buffer[3];
Magic Number,NetMQ,NetworkOrderBitsConverter,C:\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,ToInt32,The following statement contains a magic number: return                   buffer[0] << 24 |                  buffer[1] << 16 |                   buffer[2] <<  8 |                   buffer[3];
Magic Number,NetMQ,NetworkOrderBitsConverter,C:\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,ToInt32,The following statement contains a magic number: return                   buffer[0] << 24 |                  buffer[1] << 16 |                   buffer[2] <<  8 |                   buffer[3];
Magic Number,NetMQ,NetworkOrderBitsConverter,C:\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,ToInt32,The following statement contains a magic number: return                   buffer[0] << 24 |                  buffer[1] << 16 |                   buffer[2] <<  8 |                   buffer[3];
Magic Number,NetMQ,NetworkOrderBitsConverter,C:\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,ToInt32,The following statement contains a magic number: return                   buffer[0] << 24 |                  buffer[1] << 16 |                   buffer[2] <<  8 |                   buffer[3];
Magic Number,NetMQ,NetworkOrderBitsConverter,C:\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,GetBytes,The following statement contains a magic number: var buffer = new byte[4];
Magic Number,NetMQ,NetworkOrderBitsConverter,C:\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,PutInt32,The following statement contains a magic number: buffer[0] = (byte)(value >> 24);
Magic Number,NetMQ,NetworkOrderBitsConverter,C:\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,PutInt32,The following statement contains a magic number: buffer[1] = (byte)(value >> 16);
Magic Number,NetMQ,NetworkOrderBitsConverter,C:\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,PutInt32,The following statement contains a magic number: buffer[2] = (byte)(value >>  8);
Magic Number,NetMQ,NetworkOrderBitsConverter,C:\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,PutInt32,The following statement contains a magic number: buffer[2] = (byte)(value >>  8);
Magic Number,NetMQ,NetworkOrderBitsConverter,C:\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,PutInt32,The following statement contains a magic number: buffer[3] = (byte) value;
Magic Number,NetMQ,NetworkOrderBitsConverter,C:\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,ToInt64,The following statement contains a magic number: return                  (long)buffer[0] << 56 |                  (long)buffer[1] << 48 |                  (long)buffer[2] << 40 |                  (long)buffer[3] << 32 |                  (long)buffer[4] << 24 |                  (long)buffer[5] << 16 |                  (long)buffer[6] <<  8 |                  (long)buffer[7];
Magic Number,NetMQ,NetworkOrderBitsConverter,C:\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,ToInt64,The following statement contains a magic number: return                  (long)buffer[0] << 56 |                  (long)buffer[1] << 48 |                  (long)buffer[2] << 40 |                  (long)buffer[3] << 32 |                  (long)buffer[4] << 24 |                  (long)buffer[5] << 16 |                  (long)buffer[6] <<  8 |                  (long)buffer[7];
Magic Number,NetMQ,NetworkOrderBitsConverter,C:\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,ToInt64,The following statement contains a magic number: return                  (long)buffer[0] << 56 |                  (long)buffer[1] << 48 |                  (long)buffer[2] << 40 |                  (long)buffer[3] << 32 |                  (long)buffer[4] << 24 |                  (long)buffer[5] << 16 |                  (long)buffer[6] <<  8 |                  (long)buffer[7];
Magic Number,NetMQ,NetworkOrderBitsConverter,C:\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,ToInt64,The following statement contains a magic number: return                  (long)buffer[0] << 56 |                  (long)buffer[1] << 48 |                  (long)buffer[2] << 40 |                  (long)buffer[3] << 32 |                  (long)buffer[4] << 24 |                  (long)buffer[5] << 16 |                  (long)buffer[6] <<  8 |                  (long)buffer[7];
Magic Number,NetMQ,NetworkOrderBitsConverter,C:\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,ToInt64,The following statement contains a magic number: return                  (long)buffer[0] << 56 |                  (long)buffer[1] << 48 |                  (long)buffer[2] << 40 |                  (long)buffer[3] << 32 |                  (long)buffer[4] << 24 |                  (long)buffer[5] << 16 |                  (long)buffer[6] <<  8 |                  (long)buffer[7];
Magic Number,NetMQ,NetworkOrderBitsConverter,C:\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,ToInt64,The following statement contains a magic number: return                  (long)buffer[0] << 56 |                  (long)buffer[1] << 48 |                  (long)buffer[2] << 40 |                  (long)buffer[3] << 32 |                  (long)buffer[4] << 24 |                  (long)buffer[5] << 16 |                  (long)buffer[6] <<  8 |                  (long)buffer[7];
Magic Number,NetMQ,NetworkOrderBitsConverter,C:\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,ToInt64,The following statement contains a magic number: return                  (long)buffer[0] << 56 |                  (long)buffer[1] << 48 |                  (long)buffer[2] << 40 |                  (long)buffer[3] << 32 |                  (long)buffer[4] << 24 |                  (long)buffer[5] << 16 |                  (long)buffer[6] <<  8 |                  (long)buffer[7];
Magic Number,NetMQ,NetworkOrderBitsConverter,C:\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,ToInt64,The following statement contains a magic number: return                  (long)buffer[0] << 56 |                  (long)buffer[1] << 48 |                  (long)buffer[2] << 40 |                  (long)buffer[3] << 32 |                  (long)buffer[4] << 24 |                  (long)buffer[5] << 16 |                  (long)buffer[6] <<  8 |                  (long)buffer[7];
Magic Number,NetMQ,NetworkOrderBitsConverter,C:\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,ToInt64,The following statement contains a magic number: return                  (long)buffer[0] << 56 |                  (long)buffer[1] << 48 |                  (long)buffer[2] << 40 |                  (long)buffer[3] << 32 |                  (long)buffer[4] << 24 |                  (long)buffer[5] << 16 |                  (long)buffer[6] <<  8 |                  (long)buffer[7];
Magic Number,NetMQ,NetworkOrderBitsConverter,C:\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,ToInt64,The following statement contains a magic number: return                  (long)buffer[0] << 56 |                  (long)buffer[1] << 48 |                  (long)buffer[2] << 40 |                  (long)buffer[3] << 32 |                  (long)buffer[4] << 24 |                  (long)buffer[5] << 16 |                  (long)buffer[6] <<  8 |                  (long)buffer[7];
Magic Number,NetMQ,NetworkOrderBitsConverter,C:\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,ToInt64,The following statement contains a magic number: return                  (long)buffer[0] << 56 |                  (long)buffer[1] << 48 |                  (long)buffer[2] << 40 |                  (long)buffer[3] << 32 |                  (long)buffer[4] << 24 |                  (long)buffer[5] << 16 |                  (long)buffer[6] <<  8 |                  (long)buffer[7];
Magic Number,NetMQ,NetworkOrderBitsConverter,C:\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,ToInt64,The following statement contains a magic number: return                  (long)buffer[0] << 56 |                  (long)buffer[1] << 48 |                  (long)buffer[2] << 40 |                  (long)buffer[3] << 32 |                  (long)buffer[4] << 24 |                  (long)buffer[5] << 16 |                  (long)buffer[6] <<  8 |                  (long)buffer[7];
Magic Number,NetMQ,NetworkOrderBitsConverter,C:\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,ToInt64,The following statement contains a magic number: return                  (long)buffer[0] << 56 |                  (long)buffer[1] << 48 |                  (long)buffer[2] << 40 |                  (long)buffer[3] << 32 |                  (long)buffer[4] << 24 |                  (long)buffer[5] << 16 |                  (long)buffer[6] <<  8 |                  (long)buffer[7];
Magic Number,NetMQ,NetworkOrderBitsConverter,C:\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,GetBytes,The following statement contains a magic number: var buffer = new byte[8];
Magic Number,NetMQ,NetworkOrderBitsConverter,C:\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,PutInt64,The following statement contains a magic number: buffer[0] = (byte)(value >> 56);
Magic Number,NetMQ,NetworkOrderBitsConverter,C:\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,PutInt64,The following statement contains a magic number: buffer[1] = (byte)(value >> 48);
Magic Number,NetMQ,NetworkOrderBitsConverter,C:\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,PutInt64,The following statement contains a magic number: buffer[2] = (byte)(value >> 40);
Magic Number,NetMQ,NetworkOrderBitsConverter,C:\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,PutInt64,The following statement contains a magic number: buffer[2] = (byte)(value >> 40);
Magic Number,NetMQ,NetworkOrderBitsConverter,C:\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,PutInt64,The following statement contains a magic number: buffer[3] = (byte)(value >> 32);
Magic Number,NetMQ,NetworkOrderBitsConverter,C:\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,PutInt64,The following statement contains a magic number: buffer[3] = (byte)(value >> 32);
Magic Number,NetMQ,NetworkOrderBitsConverter,C:\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,PutInt64,The following statement contains a magic number: buffer[4] = (byte)(value >> 24);
Magic Number,NetMQ,NetworkOrderBitsConverter,C:\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,PutInt64,The following statement contains a magic number: buffer[4] = (byte)(value >> 24);
Magic Number,NetMQ,NetworkOrderBitsConverter,C:\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,PutInt64,The following statement contains a magic number: buffer[5] = (byte)(value >> 16);
Magic Number,NetMQ,NetworkOrderBitsConverter,C:\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,PutInt64,The following statement contains a magic number: buffer[5] = (byte)(value >> 16);
Magic Number,NetMQ,NetworkOrderBitsConverter,C:\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,PutInt64,The following statement contains a magic number: buffer[6] = (byte)(value >> 8);
Magic Number,NetMQ,NetworkOrderBitsConverter,C:\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,PutInt64,The following statement contains a magic number: buffer[6] = (byte)(value >> 8);
Magic Number,NetMQ,NetworkOrderBitsConverter,C:\repos\zeromq_netmq\src\NetMQ\NetworkOrderBitsConverter.cs,PutInt64,The following statement contains a magic number: buffer[7] = (byte) value;
Magic Number,NetMQ,OutgoingSocketExtensions,C:\repos\zeromq_netmq\src\NetMQ\OutgoingSocketExtensions.cs,Signal,The following statement contains a magic number: msg.InitPool(8);
Magic Number,NetMQ,OutgoingSocketExtensions,C:\repos\zeromq_netmq\src\NetMQ\OutgoingSocketExtensions.cs,TrySignal,The following statement contains a magic number: msg.InitPool(8);
Magic Number,NetMQ,ReceivingSocketExtensions,C:\repos\zeromq_netmq\src\NetMQ\ReceivingSocketExtensions.cs,ReceiveSignal,The following statement contains a magic number: while (true)              {                  socket.Receive(ref msg);                    var isMultiFrame = msg.HasMore;                  while (msg.HasMore)                  {                      socket.Receive(ref msg);                  }                    if (isMultiFrame || msg.Size != 8)                      continue;                    var signalValue = NetworkOrderBitsConverter.ToInt64(msg.Data);                    if ((signalValue & 0x7FFFFFFFFFFFFF00L) == 0x7766554433221100L)                  {                      msg.Close();                      return (signalValue & 255) == 0;                  }              }
Magic Number,NetMQ,ReceivingSocketExtensions,C:\repos\zeromq_netmq\src\NetMQ\ReceivingSocketExtensions.cs,ReceiveSignal,The following statement contains a magic number: while (true)              {                  socket.Receive(ref msg);                    var isMultiFrame = msg.HasMore;                  while (msg.HasMore)                  {                      socket.Receive(ref msg);                  }                    if (isMultiFrame || msg.Size != 8)                      continue;                    var signalValue = NetworkOrderBitsConverter.ToInt64(msg.Data);                    if ((signalValue & 0x7FFFFFFFFFFFFF00L) == 0x7766554433221100L)                  {                      msg.Close();                      return (signalValue & 255) == 0;                  }              }
Magic Number,NetMQ,ReceivingSocketExtensions,C:\repos\zeromq_netmq\src\NetMQ\ReceivingSocketExtensions.cs,TryReceiveSignal,The following statement contains a magic number: while (true)              {                  if (!socket.TryReceive(ref msg' timeout))                  {                      signal = false;                      msg.Close();                      return false;                  }                    var isMultiFrame = msg.HasMore;                  while (msg.HasMore)                  {                      socket.Receive(ref msg);                  }                    if (isMultiFrame || msg.Size != 8)                      continue;                    var signalValue = NetworkOrderBitsConverter.ToInt64(msg.Data);                    if ((signalValue & 0x7FFFFFFFFFFFFF00L) == 0x7766554433221100L)                  {                      signal = (signalValue & 255) == 0;                      msg.Close();                      return true;                  }              }
Magic Number,NetMQ,ReceivingSocketExtensions,C:\repos\zeromq_netmq\src\NetMQ\ReceivingSocketExtensions.cs,TryReceiveSignal,The following statement contains a magic number: while (true)              {                  if (!socket.TryReceive(ref msg' timeout))                  {                      signal = false;                      msg.Close();                      return false;                  }                    var isMultiFrame = msg.HasMore;                  while (msg.HasMore)                  {                      socket.Receive(ref msg);                  }                    if (isMultiFrame || msg.Size != 8)                      continue;                    var signalValue = NetworkOrderBitsConverter.ToInt64(msg.Data);                    if ((signalValue & 0x7FFFFFFFFFFFFF00L) == 0x7766554433221100L)                  {                      signal = (signalValue & 255) == 0;                      msg.Close();                      return true;                  }              }
Magic Number,NetMQ.Core,Ctx,C:\repos\zeromq_netmq\src\NetMQ\Core\Ctx.cs,CreateSocket,The following statement contains a magic number: lock (m_slotSync)              {                  if (m_starting)                  {                      m_starting = false;                      // Initialise the array of mailboxes. Additional three slots are for                      // zmq_term thread and reaper thread.                        int ios;                      int mazmq;                        lock (m_optSync)                      {                          mazmq = m_maxSockets;                          ios = m_ioThreadCount;                      }                      m_slotCount = mazmq + ios + 2;                      m_slots = new IMailbox[m_slotCount];                      //alloc_Debug.Assert(slots);                        // Initialise the infrastructure for zmq_term thread.                      m_slots[TermTid] = m_termMailbox;                        // Create the reaper thread.                      m_reaper = new Reaper(this' ReaperTid);                      //alloc_Debug.Assert(reaper);                      m_slots[ReaperTid] = m_reaper.Mailbox;                      m_reaper.Start();                        // Create I/O thread objects and launch them.                      for (int i = 2; i != ios + 2; i++)                      {                          var ioThread = new IOThread(this' i);                          //alloc_Debug.Assert(io_thread);                          m_ioThreads.Add(ioThread);                          m_slots[i] = ioThread.Mailbox;                          ioThread.Start();                      }                        // In the unused part of the slot array' create a list of empty slots.                      for (int i = m_slotCount - 1; i >= ios + 2; i--)                      {                          m_emptySlots.Push(i);                          m_slots[i] = null;                      }                  }                    // Once zmq_term() was called' we can't create new sockets.                  if (m_terminating)                  {                      string xMsg = $"Ctx.CreateSocket({type})' cannot create new socket while terminating.";                      throw new TerminatingException(innerException: null' message: xMsg);                  }                    // If max_sockets limit was reached' return error.                  if (m_emptySlots.Count == 0)                  {  #if DEBUG                      string xMsg = $"Ctx.CreateSocket({type})' max number of sockets {m_maxSockets} reached.";                      throw NetMQException.Create(xMsg' ErrorCode.TooManyOpenSockets);  #else                      throw NetMQException.Create(ErrorCode.TooManyOpenSockets);  #endif                  }                    // Choose a slot for the socket.                  int slot = m_emptySlots.Pop();                    // Generate new unique socket ID.                  int socketId = Interlocked.Increment(ref s_maxSocketId);                    // Create the socket and register its mailbox.                  SocketBase s = SocketBase.Create(type' this' slot' socketId);                    m_sockets.Add(s);                  m_slots[slot] = s.Mailbox;                    //LOG.debug("NEW Slot [" + slot + "] " + s);                    return s;              }
Magic Number,NetMQ.Core,Ctx,C:\repos\zeromq_netmq\src\NetMQ\Core\Ctx.cs,CreateSocket,The following statement contains a magic number: lock (m_slotSync)              {                  if (m_starting)                  {                      m_starting = false;                      // Initialise the array of mailboxes. Additional three slots are for                      // zmq_term thread and reaper thread.                        int ios;                      int mazmq;                        lock (m_optSync)                      {                          mazmq = m_maxSockets;                          ios = m_ioThreadCount;                      }                      m_slotCount = mazmq + ios + 2;                      m_slots = new IMailbox[m_slotCount];                      //alloc_Debug.Assert(slots);                        // Initialise the infrastructure for zmq_term thread.                      m_slots[TermTid] = m_termMailbox;                        // Create the reaper thread.                      m_reaper = new Reaper(this' ReaperTid);                      //alloc_Debug.Assert(reaper);                      m_slots[ReaperTid] = m_reaper.Mailbox;                      m_reaper.Start();                        // Create I/O thread objects and launch them.                      for (int i = 2; i != ios + 2; i++)                      {                          var ioThread = new IOThread(this' i);                          //alloc_Debug.Assert(io_thread);                          m_ioThreads.Add(ioThread);                          m_slots[i] = ioThread.Mailbox;                          ioThread.Start();                      }                        // In the unused part of the slot array' create a list of empty slots.                      for (int i = m_slotCount - 1; i >= ios + 2; i--)                      {                          m_emptySlots.Push(i);                          m_slots[i] = null;                      }                  }                    // Once zmq_term() was called' we can't create new sockets.                  if (m_terminating)                  {                      string xMsg = $"Ctx.CreateSocket({type})' cannot create new socket while terminating.";                      throw new TerminatingException(innerException: null' message: xMsg);                  }                    // If max_sockets limit was reached' return error.                  if (m_emptySlots.Count == 0)                  {  #if DEBUG                      string xMsg = $"Ctx.CreateSocket({type})' max number of sockets {m_maxSockets} reached.";                      throw NetMQException.Create(xMsg' ErrorCode.TooManyOpenSockets);  #else                      throw NetMQException.Create(ErrorCode.TooManyOpenSockets);  #endif                  }                    // Choose a slot for the socket.                  int slot = m_emptySlots.Pop();                    // Generate new unique socket ID.                  int socketId = Interlocked.Increment(ref s_maxSocketId);                    // Create the socket and register its mailbox.                  SocketBase s = SocketBase.Create(type' this' slot' socketId);                    m_sockets.Add(s);                  m_slots[slot] = s.Mailbox;                    //LOG.debug("NEW Slot [" + slot + "] " + s);                    return s;              }
Magic Number,NetMQ.Core,Ctx,C:\repos\zeromq_netmq\src\NetMQ\Core\Ctx.cs,CreateSocket,The following statement contains a magic number: lock (m_slotSync)              {                  if (m_starting)                  {                      m_starting = false;                      // Initialise the array of mailboxes. Additional three slots are for                      // zmq_term thread and reaper thread.                        int ios;                      int mazmq;                        lock (m_optSync)                      {                          mazmq = m_maxSockets;                          ios = m_ioThreadCount;                      }                      m_slotCount = mazmq + ios + 2;                      m_slots = new IMailbox[m_slotCount];                      //alloc_Debug.Assert(slots);                        // Initialise the infrastructure for zmq_term thread.                      m_slots[TermTid] = m_termMailbox;                        // Create the reaper thread.                      m_reaper = new Reaper(this' ReaperTid);                      //alloc_Debug.Assert(reaper);                      m_slots[ReaperTid] = m_reaper.Mailbox;                      m_reaper.Start();                        // Create I/O thread objects and launch them.                      for (int i = 2; i != ios + 2; i++)                      {                          var ioThread = new IOThread(this' i);                          //alloc_Debug.Assert(io_thread);                          m_ioThreads.Add(ioThread);                          m_slots[i] = ioThread.Mailbox;                          ioThread.Start();                      }                        // In the unused part of the slot array' create a list of empty slots.                      for (int i = m_slotCount - 1; i >= ios + 2; i--)                      {                          m_emptySlots.Push(i);                          m_slots[i] = null;                      }                  }                    // Once zmq_term() was called' we can't create new sockets.                  if (m_terminating)                  {                      string xMsg = $"Ctx.CreateSocket({type})' cannot create new socket while terminating.";                      throw new TerminatingException(innerException: null' message: xMsg);                  }                    // If max_sockets limit was reached' return error.                  if (m_emptySlots.Count == 0)                  {  #if DEBUG                      string xMsg = $"Ctx.CreateSocket({type})' max number of sockets {m_maxSockets} reached.";                      throw NetMQException.Create(xMsg' ErrorCode.TooManyOpenSockets);  #else                      throw NetMQException.Create(ErrorCode.TooManyOpenSockets);  #endif                  }                    // Choose a slot for the socket.                  int slot = m_emptySlots.Pop();                    // Generate new unique socket ID.                  int socketId = Interlocked.Increment(ref s_maxSocketId);                    // Create the socket and register its mailbox.                  SocketBase s = SocketBase.Create(type' this' slot' socketId);                    m_sockets.Add(s);                  m_slots[slot] = s.Mailbox;                    //LOG.debug("NEW Slot [" + slot + "] " + s);                    return s;              }
Magic Number,NetMQ.Core,Ctx,C:\repos\zeromq_netmq\src\NetMQ\Core\Ctx.cs,CreateSocket,The following statement contains a magic number: lock (m_slotSync)              {                  if (m_starting)                  {                      m_starting = false;                      // Initialise the array of mailboxes. Additional three slots are for                      // zmq_term thread and reaper thread.                        int ios;                      int mazmq;                        lock (m_optSync)                      {                          mazmq = m_maxSockets;                          ios = m_ioThreadCount;                      }                      m_slotCount = mazmq + ios + 2;                      m_slots = new IMailbox[m_slotCount];                      //alloc_Debug.Assert(slots);                        // Initialise the infrastructure for zmq_term thread.                      m_slots[TermTid] = m_termMailbox;                        // Create the reaper thread.                      m_reaper = new Reaper(this' ReaperTid);                      //alloc_Debug.Assert(reaper);                      m_slots[ReaperTid] = m_reaper.Mailbox;                      m_reaper.Start();                        // Create I/O thread objects and launch them.                      for (int i = 2; i != ios + 2; i++)                      {                          var ioThread = new IOThread(this' i);                          //alloc_Debug.Assert(io_thread);                          m_ioThreads.Add(ioThread);                          m_slots[i] = ioThread.Mailbox;                          ioThread.Start();                      }                        // In the unused part of the slot array' create a list of empty slots.                      for (int i = m_slotCount - 1; i >= ios + 2; i--)                      {                          m_emptySlots.Push(i);                          m_slots[i] = null;                      }                  }                    // Once zmq_term() was called' we can't create new sockets.                  if (m_terminating)                  {                      string xMsg = $"Ctx.CreateSocket({type})' cannot create new socket while terminating.";                      throw new TerminatingException(innerException: null' message: xMsg);                  }                    // If max_sockets limit was reached' return error.                  if (m_emptySlots.Count == 0)                  {  #if DEBUG                      string xMsg = $"Ctx.CreateSocket({type})' max number of sockets {m_maxSockets} reached.";                      throw NetMQException.Create(xMsg' ErrorCode.TooManyOpenSockets);  #else                      throw NetMQException.Create(ErrorCode.TooManyOpenSockets);  #endif                  }                    // Choose a slot for the socket.                  int slot = m_emptySlots.Pop();                    // Generate new unique socket ID.                  int socketId = Interlocked.Increment(ref s_maxSocketId);                    // Create the socket and register its mailbox.                  SocketBase s = SocketBase.Create(type' this' slot' socketId);                    m_sockets.Add(s);                  m_slots[slot] = s.Mailbox;                    //LOG.debug("NEW Slot [" + slot + "] " + s);                    return s;              }
Magic Number,NetMQ.Core,MonitorEvent,C:\repos\zeromq_netmq\src\NetMQ\Core\MonitorEvent.cs,MonitorEvent,The following statement contains a magic number: if (s_sizeOfIntPtr > 4)                  s_sizeOfIntPtr = 8;
Magic Number,NetMQ.Core,MonitorEvent,C:\repos\zeromq_netmq\src\NetMQ\Core\MonitorEvent.cs,MonitorEvent,The following statement contains a magic number: if (s_sizeOfIntPtr > 4)                  s_sizeOfIntPtr = 8;
Magic Number,NetMQ.Core,MonitorEvent,C:\repos\zeromq_netmq\src\NetMQ\Core\MonitorEvent.cs,Write,The following statement contains a magic number: int size = 4 + 1 + (m_addr?.Length ?? 0) + 1;
Magic Number,NetMQ.Core,MonitorEvent,C:\repos\zeromq_netmq\src\NetMQ\Core\MonitorEvent.cs,Write,The following statement contains a magic number: if (m_flag == ValueInteger)                  size += 4;              else if (m_flag == ValueChannel)                  size += s_sizeOfIntPtr;
Magic Number,NetMQ.Core,MonitorEvent,C:\repos\zeromq_netmq\src\NetMQ\Core\MonitorEvent.cs,Write,The following statement contains a magic number: pos += 4;
Magic Number,NetMQ.Core,MonitorEvent,C:\repos\zeromq_netmq\src\NetMQ\Core\MonitorEvent.cs,Write,The following statement contains a magic number: if (m_flag == ValueInteger)              {                  buffer.PutInteger(Endianness.Little' (int)m_arg' pos);              }              else if (m_flag == ValueChannel)              {                  GCHandle handle = GCHandle.Alloc(m_arg' GCHandleType.Weak);                    if (s_sizeOfIntPtr == 4)                      buffer.PutInteger(Endianness.Little' GCHandle.ToIntPtr(handle).ToInt32()' pos);                  else                      buffer.PutLong(Endianness.Little' GCHandle.ToIntPtr(handle).ToInt64()' pos);              }
Magic Number,NetMQ.Core,MonitorEvent,C:\repos\zeromq_netmq\src\NetMQ\Core\MonitorEvent.cs,Read,The following statement contains a magic number: pos += 4;
Magic Number,NetMQ.Core,MonitorEvent,C:\repos\zeromq_netmq\src\NetMQ\Core\MonitorEvent.cs,Read,The following statement contains a magic number: if (flag == ValueInteger)              {                  arg = data.GetInteger(Endianness.Little' pos);              }              else if (flag == ValueChannel)              {                  IntPtr value = s_sizeOfIntPtr == 4                      ? new IntPtr(data.GetInteger(Endianness.Little' pos))                      : new IntPtr(data.GetLong(Endianness.Little' pos));                    GCHandle handle = GCHandle.FromIntPtr(value);                  AsyncSocket socket = null;                    if (handle.IsAllocated)                  {                      socket = handle.Target as AsyncSocket;                  }                    handle.Free();                    arg = socket;              }
Magic Number,NetMQ.Core,Options,C:\repos\zeromq_netmq\src\NetMQ\Core\Options.cs,Options,The following statement contains a magic number: Backlog = 100;
Magic Number,NetMQ.Core,Options,C:\repos\zeromq_netmq\src\NetMQ\Core\Options.cs,Options,The following statement contains a magic number: Rate = 100;
Magic Number,NetMQ.Core,Options,C:\repos\zeromq_netmq\src\NetMQ\Core\Options.cs,Options,The following statement contains a magic number: ReceiveHighWatermark = 1000;
Magic Number,NetMQ.Core,Options,C:\repos\zeromq_netmq\src\NetMQ\Core\Options.cs,Options,The following statement contains a magic number: ReconnectIvl = 100;
Magic Number,NetMQ.Core,Options,C:\repos\zeromq_netmq\src\NetMQ\Core\Options.cs,Options,The following statement contains a magic number: RecoveryIvl = 10000;
Magic Number,NetMQ.Core,Options,C:\repos\zeromq_netmq\src\NetMQ\Core\Options.cs,Options,The following statement contains a magic number: SendHighWatermark = 1000;
Magic Number,NetMQ.Core,Options,C:\repos\zeromq_netmq\src\NetMQ\Core\Options.cs,SetSocketOption,The following statement contains a magic number: switch (option)              {                  case ZmqSocketOption.SendHighWatermark:                      SendHighWatermark = (int)optionValue;                      break;                    case ZmqSocketOption.ReceiveHighWatermark:                      ReceiveHighWatermark = (int)optionValue;                      break;                    case ZmqSocketOption.SendLowWatermark:                      SendLowWatermark = (int)optionValue;                      break;                    case ZmqSocketOption.ReceiveLowWatermark:                      ReceiveLowWatermark = (int)optionValue;                      break;                    case ZmqSocketOption.Affinity:                      Affinity = (long)optionValue;                      break;                    case ZmqSocketOption.Identity:                      byte[] val;                        if (optionValue is string)                          val = Encoding.ASCII.GetBytes((string)optionValue);                      else if (optionValue is byte[])                          val = (byte[])optionValue;                      else                          throw new InvalidException($"In Options.SetSocketOption(Identity' {optionValue?.ToString() ?? "null"}) optionValue must be a string or byte-array.");                        if (val.Length == 0 || val.Length > 255)                          throw new InvalidException($"In Options.SetSocketOption(Identity') optionValue yielded a byte-array of length {val.Length}' should be 1..255.");                      Identity = new byte[val.Length];                      val.CopyTo(Identity' 0);                      IdentitySize = (byte)Identity.Length;                      break;                    case ZmqSocketOption.Rate:                      Rate = (int)optionValue;                      break;                    case ZmqSocketOption.RecoveryIvl:                      RecoveryIvl = (int)optionValue;                      break;                    case ZmqSocketOption.SendBuffer:                      SendBuffer = (int)optionValue;                      break;                    case ZmqSocketOption.ReceiveBuffer:                      ReceiveBuffer = (int)optionValue;                      break;                    case ZmqSocketOption.Linger:                      Linger = (int)optionValue;                      break;                    case ZmqSocketOption.ReconnectIvl:                      var reconnectIvl = (int)optionValue;                      if (reconnectIvl < -1)                          throw new InvalidException($"Options.SetSocketOption(ReconnectIvl' {reconnectIvl}) optionValue must be >= -1.");                      ReconnectIvl = reconnectIvl;                      break;                    case ZmqSocketOption.ReconnectIvlMax:                      var reconnectIvlMax = (int)optionValue;                      if (reconnectIvlMax < 0)                          throw new InvalidException($"Options.SetSocketOption(ReconnectIvlMax' {reconnectIvlMax}) optionValue must be non-negative.");                      ReconnectIvlMax = reconnectIvlMax;                      break;                    case ZmqSocketOption.Backlog:                      Backlog = (int)optionValue;                      break;                    case ZmqSocketOption.MaxMessageSize:                      MaxMessageSize = (long)optionValue;                      break;                    case ZmqSocketOption.MulticastHops:                      MulticastHops = (int)optionValue;                      break;                    case ZmqSocketOption.SendTimeout:                      SendTimeout = (int)optionValue;                      break;                    case ZmqSocketOption.IPv4Only:                      IPv4Only = (bool)optionValue;                      break;                    case ZmqSocketOption.TcpKeepalive:                      var tcpKeepalive = (int)optionValue;                      if (tcpKeepalive != -1 && tcpKeepalive != 0 && tcpKeepalive != 1)                          throw new InvalidException($"Options.SetSocketOption(TcpKeepalive' {tcpKeepalive}) optionValue is neither -1' 0' nor 1.");                      TcpKeepalive = tcpKeepalive;                      break;                    case ZmqSocketOption.DelayAttachOnConnect:                      DelayAttachOnConnect = (bool)optionValue;                      break;                    case ZmqSocketOption.TcpKeepaliveIdle:                      TcpKeepaliveIdle = (int)optionValue;                      break;                    case ZmqSocketOption.TcpKeepaliveIntvl:                      TcpKeepaliveIntvl = (int)optionValue;                      break;                    case ZmqSocketOption.Endian:                      Endian = (Endianness)optionValue;                      break;                    case ZmqSocketOption.DisableTimeWait:                      DisableTimeWait = (bool)optionValue;                      break;                    case ZmqSocketOption.PgmMaxTransportServiceDataUnitLength:                      PgmMaxTransportServiceDataUnitLength = (int)optionValue;                      break;                    default:                      throw new InvalidException("Options.SetSocketOption called with invalid ZmqSocketOption of " + option);              }
Magic Number,NetMQ.Core,Pipe,C:\repos\zeromq_netmq\src\NetMQ\Core\Pipe.cs,ComputeLowWatermark,The following statement contains a magic number: int result = (highWatermark > Config.MaxWatermarkDelta*2)                  ? highWatermark - Config.MaxWatermarkDelta                  : (highWatermark + 1)/2;
Magic Number,NetMQ.Core,Pipe,C:\repos\zeromq_netmq\src\NetMQ\Core\Pipe.cs,ComputeLowWatermark,The following statement contains a magic number: int result = (highWatermark > Config.MaxWatermarkDelta*2)                  ? highWatermark - Config.MaxWatermarkDelta                  : (highWatermark + 1)/2;
Magic Number,NetMQ.Core.Patterns,Router,C:\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Router.cs,IdentifyPeer,The following statement contains a magic number: if (m_options.RawSocket)              {                  // Always assign identity for raw-socket                  identity = new byte[5];                  byte[] result = BitConverter.GetBytes(m_nextPeerId++);                  Buffer.BlockCopy(result' 0' identity' 1' 4);              }              else              {                  // Pick up handshake cases and also case where next identity is set                    var msg = new Msg();                  msg.InitEmpty();                    bool ok = pipe.Read(ref msg);                    if (!ok)                      return false;                    if (msg.Size == 0)                  {                      // Fall back on the auto-generation                      identity = new byte[5];                        byte[] result = BitConverter.GetBytes(m_nextPeerId++);                        Buffer.BlockCopy(result' 0' identity' 1' 4);                        msg.Close();                  }                  else                  {                      identity = msg.CloneData();                      msg.Close();                          if (m_outpipes.TryGetValue(identity' out Outpipe existPipe))                      {                          if (!m_handover)                          {                              // Ignore peers with duplicate ID.                              return false;                          }                          else                          {                              //  We will allow the new connection to take over this                              //  identity. Temporarily assign a new identity to the                              //  existing pipe so we can terminate it asynchronously.                              var newIdentity = new byte[5];                              byte[] result = BitConverter.GetBytes(m_nextPeerId++);                              Buffer.BlockCopy(result' 0' newIdentity' 1' 4);                              existPipe.Pipe.Identity = newIdentity;                              m_outpipes.Add(newIdentity' existPipe);                                //  Remove the existing identity entry to allow the new                              //  connection to take the identity.                              m_outpipes.Remove(identity);                                if (existPipe.Pipe == m_currentIn)                                  m_closingCurrentIn = true;                              else                                  existPipe.Pipe.Terminate(true);                          }                      }                  }              }
Magic Number,NetMQ.Core.Patterns,Router,C:\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Router.cs,IdentifyPeer,The following statement contains a magic number: if (m_options.RawSocket)              {                  // Always assign identity for raw-socket                  identity = new byte[5];                  byte[] result = BitConverter.GetBytes(m_nextPeerId++);                  Buffer.BlockCopy(result' 0' identity' 1' 4);              }              else              {                  // Pick up handshake cases and also case where next identity is set                    var msg = new Msg();                  msg.InitEmpty();                    bool ok = pipe.Read(ref msg);                    if (!ok)                      return false;                    if (msg.Size == 0)                  {                      // Fall back on the auto-generation                      identity = new byte[5];                        byte[] result = BitConverter.GetBytes(m_nextPeerId++);                        Buffer.BlockCopy(result' 0' identity' 1' 4);                        msg.Close();                  }                  else                  {                      identity = msg.CloneData();                      msg.Close();                          if (m_outpipes.TryGetValue(identity' out Outpipe existPipe))                      {                          if (!m_handover)                          {                              // Ignore peers with duplicate ID.                              return false;                          }                          else                          {                              //  We will allow the new connection to take over this                              //  identity. Temporarily assign a new identity to the                              //  existing pipe so we can terminate it asynchronously.                              var newIdentity = new byte[5];                              byte[] result = BitConverter.GetBytes(m_nextPeerId++);                              Buffer.BlockCopy(result' 0' newIdentity' 1' 4);                              existPipe.Pipe.Identity = newIdentity;                              m_outpipes.Add(newIdentity' existPipe);                                //  Remove the existing identity entry to allow the new                              //  connection to take the identity.                              m_outpipes.Remove(identity);                                if (existPipe.Pipe == m_currentIn)                                  m_closingCurrentIn = true;                              else                                  existPipe.Pipe.Terminate(true);                          }                      }                  }              }
Magic Number,NetMQ.Core.Patterns,Router,C:\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Router.cs,IdentifyPeer,The following statement contains a magic number: if (m_options.RawSocket)              {                  // Always assign identity for raw-socket                  identity = new byte[5];                  byte[] result = BitConverter.GetBytes(m_nextPeerId++);                  Buffer.BlockCopy(result' 0' identity' 1' 4);              }              else              {                  // Pick up handshake cases and also case where next identity is set                    var msg = new Msg();                  msg.InitEmpty();                    bool ok = pipe.Read(ref msg);                    if (!ok)                      return false;                    if (msg.Size == 0)                  {                      // Fall back on the auto-generation                      identity = new byte[5];                        byte[] result = BitConverter.GetBytes(m_nextPeerId++);                        Buffer.BlockCopy(result' 0' identity' 1' 4);                        msg.Close();                  }                  else                  {                      identity = msg.CloneData();                      msg.Close();                          if (m_outpipes.TryGetValue(identity' out Outpipe existPipe))                      {                          if (!m_handover)                          {                              // Ignore peers with duplicate ID.                              return false;                          }                          else                          {                              //  We will allow the new connection to take over this                              //  identity. Temporarily assign a new identity to the                              //  existing pipe so we can terminate it asynchronously.                              var newIdentity = new byte[5];                              byte[] result = BitConverter.GetBytes(m_nextPeerId++);                              Buffer.BlockCopy(result' 0' newIdentity' 1' 4);                              existPipe.Pipe.Identity = newIdentity;                              m_outpipes.Add(newIdentity' existPipe);                                //  Remove the existing identity entry to allow the new                              //  connection to take the identity.                              m_outpipes.Remove(identity);                                if (existPipe.Pipe == m_currentIn)                                  m_closingCurrentIn = true;                              else                                  existPipe.Pipe.Terminate(true);                          }                      }                  }              }
Magic Number,NetMQ.Core.Patterns,Router,C:\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Router.cs,IdentifyPeer,The following statement contains a magic number: if (m_options.RawSocket)              {                  // Always assign identity for raw-socket                  identity = new byte[5];                  byte[] result = BitConverter.GetBytes(m_nextPeerId++);                  Buffer.BlockCopy(result' 0' identity' 1' 4);              }              else              {                  // Pick up handshake cases and also case where next identity is set                    var msg = new Msg();                  msg.InitEmpty();                    bool ok = pipe.Read(ref msg);                    if (!ok)                      return false;                    if (msg.Size == 0)                  {                      // Fall back on the auto-generation                      identity = new byte[5];                        byte[] result = BitConverter.GetBytes(m_nextPeerId++);                        Buffer.BlockCopy(result' 0' identity' 1' 4);                        msg.Close();                  }                  else                  {                      identity = msg.CloneData();                      msg.Close();                          if (m_outpipes.TryGetValue(identity' out Outpipe existPipe))                      {                          if (!m_handover)                          {                              // Ignore peers with duplicate ID.                              return false;                          }                          else                          {                              //  We will allow the new connection to take over this                              //  identity. Temporarily assign a new identity to the                              //  existing pipe so we can terminate it asynchronously.                              var newIdentity = new byte[5];                              byte[] result = BitConverter.GetBytes(m_nextPeerId++);                              Buffer.BlockCopy(result' 0' newIdentity' 1' 4);                              existPipe.Pipe.Identity = newIdentity;                              m_outpipes.Add(newIdentity' existPipe);                                //  Remove the existing identity entry to allow the new                              //  connection to take the identity.                              m_outpipes.Remove(identity);                                if (existPipe.Pipe == m_currentIn)                                  m_closingCurrentIn = true;                              else                                  existPipe.Pipe.Terminate(true);                          }                      }                  }              }
Magic Number,NetMQ.Core.Patterns,Router,C:\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Router.cs,IdentifyPeer,The following statement contains a magic number: if (m_options.RawSocket)              {                  // Always assign identity for raw-socket                  identity = new byte[5];                  byte[] result = BitConverter.GetBytes(m_nextPeerId++);                  Buffer.BlockCopy(result' 0' identity' 1' 4);              }              else              {                  // Pick up handshake cases and also case where next identity is set                    var msg = new Msg();                  msg.InitEmpty();                    bool ok = pipe.Read(ref msg);                    if (!ok)                      return false;                    if (msg.Size == 0)                  {                      // Fall back on the auto-generation                      identity = new byte[5];                        byte[] result = BitConverter.GetBytes(m_nextPeerId++);                        Buffer.BlockCopy(result' 0' identity' 1' 4);                        msg.Close();                  }                  else                  {                      identity = msg.CloneData();                      msg.Close();                          if (m_outpipes.TryGetValue(identity' out Outpipe existPipe))                      {                          if (!m_handover)                          {                              // Ignore peers with duplicate ID.                              return false;                          }                          else                          {                              //  We will allow the new connection to take over this                              //  identity. Temporarily assign a new identity to the                              //  existing pipe so we can terminate it asynchronously.                              var newIdentity = new byte[5];                              byte[] result = BitConverter.GetBytes(m_nextPeerId++);                              Buffer.BlockCopy(result' 0' newIdentity' 1' 4);                              existPipe.Pipe.Identity = newIdentity;                              m_outpipes.Add(newIdentity' existPipe);                                //  Remove the existing identity entry to allow the new                              //  connection to take the identity.                              m_outpipes.Remove(identity);                                if (existPipe.Pipe == m_currentIn)                                  m_closingCurrentIn = true;                              else                                  existPipe.Pipe.Terminate(true);                          }                      }                  }              }
Magic Number,NetMQ.Core.Patterns,Router,C:\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Router.cs,IdentifyPeer,The following statement contains a magic number: if (m_options.RawSocket)              {                  // Always assign identity for raw-socket                  identity = new byte[5];                  byte[] result = BitConverter.GetBytes(m_nextPeerId++);                  Buffer.BlockCopy(result' 0' identity' 1' 4);              }              else              {                  // Pick up handshake cases and also case where next identity is set                    var msg = new Msg();                  msg.InitEmpty();                    bool ok = pipe.Read(ref msg);                    if (!ok)                      return false;                    if (msg.Size == 0)                  {                      // Fall back on the auto-generation                      identity = new byte[5];                        byte[] result = BitConverter.GetBytes(m_nextPeerId++);                        Buffer.BlockCopy(result' 0' identity' 1' 4);                        msg.Close();                  }                  else                  {                      identity = msg.CloneData();                      msg.Close();                          if (m_outpipes.TryGetValue(identity' out Outpipe existPipe))                      {                          if (!m_handover)                          {                              // Ignore peers with duplicate ID.                              return false;                          }                          else                          {                              //  We will allow the new connection to take over this                              //  identity. Temporarily assign a new identity to the                              //  existing pipe so we can terminate it asynchronously.                              var newIdentity = new byte[5];                              byte[] result = BitConverter.GetBytes(m_nextPeerId++);                              Buffer.BlockCopy(result' 0' newIdentity' 1' 4);                              existPipe.Pipe.Identity = newIdentity;                              m_outpipes.Add(newIdentity' existPipe);                                //  Remove the existing identity entry to allow the new                              //  connection to take the identity.                              m_outpipes.Remove(identity);                                if (existPipe.Pipe == m_currentIn)                                  m_closingCurrentIn = true;                              else                                  existPipe.Pipe.Terminate(true);                          }                      }                  }              }
Magic Number,NetMQ.Core.Patterns,Stream,C:\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Stream.cs,IdentifyPeer,The following statement contains a magic number: var identity = new byte[5];
Magic Number,NetMQ.Core.Patterns,Stream,C:\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Stream.cs,IdentifyPeer,The following statement contains a magic number: Buffer.BlockCopy(result' 0' identity' 1' 4);
Magic Number,NetMQ.Core.Patterns,XPub,C:\repos\zeromq_netmq\src\NetMQ\Core\Patterns\XPub.cs,XReadActivated,The following statement contains a magic number: while (pipe.Read(ref sub))              {                  // Apply the subscription to the trie.                  int size = sub.Size;                  var msgMoreTmp = sub.HasMore;                  if (!msgMore && !isBroadcast && size > 0 && (sub[0] == 0 || sub[0] == 1) )                  {                      if (m_manual)                      {                          m_pendingMessages.Enqueue(new KeyValuePair<Msg'Pipe>(sub' pipe));                      }                      else                      {                          var unique = sub[0] == 0                              ? m_subscriptions.Remove(sub.Data' sub.Offset + 1' size - 1' pipe)                              : m_subscriptions.Add(sub.Data' sub.Offset + 1' size - 1' pipe);                            // If the subscription is not a duplicate' store it so that it can be                          // passed to used on next recv call.                          if (m_options.SocketType == ZmqSocketType.Xpub && (unique || m_verbose))                          {                              m_pendingMessages.Enqueue(new KeyValuePair<Msg' Pipe>(sub' pipe));                          }                          else                          {                              sub.Close();                          }                      }                  }                  else if (!msgMore && m_broadcastEnabled && size > 0 && sub[0] == 2)                  {                      m_pendingMessages.Enqueue(new KeyValuePair<Msg' Pipe>(sub' pipe));                      isBroadcast = true;                  }                  else // process message unrelated to sub/unsub/broadcast                  {                      m_pendingMessages.Enqueue(new KeyValuePair<Msg' Pipe>(sub' pipe));                  }                  msgMore = msgMoreTmp;              }
Magic Number,NetMQ.Core.Patterns,XPub,C:\repos\zeromq_netmq\src\NetMQ\Core\Patterns\XPub.cs,XSetSocketOption,The following statement contains a magic number: switch (option)              {                  case ZmqSocketOption.XpubVerbose:                  {                      m_verbose = (bool)optionValue;                      return true;                  }                  case ZmqSocketOption.XPublisherManual:                  {                      m_manual = (bool)optionValue;                      return true;                  }                  case ZmqSocketOption.XPublisherBroadcast:                  {                      m_broadcastEnabled = (bool)optionValue;                      return true;                  }                  case ZmqSocketOption.Identity:                  {                      if (m_manual && m_lastPipe != null)                      {                          byte[] val;                            if (optionValue is string)                              val = Encoding.ASCII.GetBytes((string)optionValue);                          else if (optionValue is byte[])                              val = (byte[])optionValue;                          else                              throw new InvalidException($"In XPub.XSetSocketOption(Identity' {optionValue?.ToString() ?? "null"}) optionValue must be a string or byte-array.");                          if (val.Length == 0 || val.Length > 255)                              throw new InvalidException($"In XPub.XSetSocketOption(Identity') optionValue yielded a byte-array of length {val.Length}' should be 1..255.");                            m_lastPipe.Identity = val;                          m_options.Identity = val;                      }                      return true;                  }                    case ZmqSocketOption.Subscribe:                  {                      if (m_manual && m_lastPipe != null)                      {                          var subscription = optionValue as byte[] ?? Encoding.ASCII.GetBytes((string)optionValue);                          m_subscriptions.Add(subscription' 0' subscription.Length' m_lastPipe);                          m_lastPipe = null;                          return true;                      }                      break;                  }                  case ZmqSocketOption.Unsubscribe:                  {                      if (m_manual && m_lastPipe != null)                      {                          var subscription = optionValue as byte[] ?? Encoding.ASCII.GetBytes((string)optionValue);                          m_subscriptions.Remove(subscription' 0' subscription.Length' m_lastPipe);                          m_lastPipe = null;                          return true;                      }                      break;                  }                  case ZmqSocketOption.XPublisherWelcomeMessage:                  {                      m_welcomeMessage.Close();                        if (optionValue != null)                      {                          var bytes = optionValue as byte[];                          if (bytes == null)                              throw new InvalidException($"In XPub.XSetSocketOption({option}'{optionValue})' optionValue must be a byte-array.");                          var welcomeBytes = new byte[bytes.Length];                          bytes.CopyTo(welcomeBytes' 0);                          m_welcomeMessage.InitGC(welcomeBytes' welcomeBytes.Length);                      }                      else                      {                          m_welcomeMessage.InitEmpty();                      }                        return true;                  }              }
Magic Number,NetMQ.Core.Patterns,XPub,C:\repos\zeromq_netmq\src\NetMQ\Core\Patterns\XPub.cs,XRecv,The following statement contains a magic number: if (msgPipePair.Value != null && !m_moreIn)              {                  if (!m_moreIn && m_broadcastEnabled && msg[0] == 2) {                      m_lastPipeIsBroadcast = true;                  }                  if (!m_moreIn && m_manual && (msg[0] == 0 || msg[0] == 1)) {                      m_lastPipeIsBroadcast = false;                  }                  m_lastPipe = msgPipePair.Value;              }
Magic Number,NetMQ.Core.Patterns.Utils,MultiTrie,C:\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Utils\MultiTrie.cs,RemoveHelper,The following statement contains a magic number: if (bufferSize >= maxBufferSize)              {                  maxBufferSize = bufferSize + 256;                  Array.Resize(ref buffer' maxBufferSize);              }
Magic Number,NetMQ.Core.Patterns.Utils,Trie,C:\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Utils\Trie.cs,ApplyHelper,The following statement contains a magic number: if (bufferSize >= maxBufferSize)              {                  maxBufferSize = bufferSize + 256;                  Array.Resize(ref buffer' maxBufferSize);                  Debug.Assert(buffer != null);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,PutLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  m_innerBuffer[i + Offset] = (byte)(((value) >> 56) & 0xff);                  m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 48) & 0xff);                  m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 40) & 0xff);                  m_innerBuffer[i + Offset + 3] = (byte)(((value) >> 32) & 0xff);                  m_innerBuffer[i + Offset + 4] = (byte)(((value) >> 24) & 0xff);                  m_innerBuffer[i + Offset + 5] = (byte)(((value) >> 16) & 0xff);                  m_innerBuffer[i + Offset + 6] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset + 7] = (byte)(value & 0xff);              }              else              {                  m_innerBuffer[i + Offset + 7] = (byte)(((value) >> 56) & 0xff);                  m_innerBuffer[i + Offset + 6] = (byte)(((value) >> 48) & 0xff);                  m_innerBuffer[i + Offset + 5] = (byte)(((value) >> 40) & 0xff);                  m_innerBuffer[i + Offset + 4] = (byte)(((value) >> 32) & 0xff);                  m_innerBuffer[i + Offset + 3] = (byte)(((value) >> 24) & 0xff);                  m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 16) & 0xff);                  m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset] = (byte)(value & 0xff);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,PutLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  m_innerBuffer[i + Offset] = (byte)(((value) >> 56) & 0xff);                  m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 48) & 0xff);                  m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 40) & 0xff);                  m_innerBuffer[i + Offset + 3] = (byte)(((value) >> 32) & 0xff);                  m_innerBuffer[i + Offset + 4] = (byte)(((value) >> 24) & 0xff);                  m_innerBuffer[i + Offset + 5] = (byte)(((value) >> 16) & 0xff);                  m_innerBuffer[i + Offset + 6] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset + 7] = (byte)(value & 0xff);              }              else              {                  m_innerBuffer[i + Offset + 7] = (byte)(((value) >> 56) & 0xff);                  m_innerBuffer[i + Offset + 6] = (byte)(((value) >> 48) & 0xff);                  m_innerBuffer[i + Offset + 5] = (byte)(((value) >> 40) & 0xff);                  m_innerBuffer[i + Offset + 4] = (byte)(((value) >> 32) & 0xff);                  m_innerBuffer[i + Offset + 3] = (byte)(((value) >> 24) & 0xff);                  m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 16) & 0xff);                  m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset] = (byte)(value & 0xff);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,PutLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  m_innerBuffer[i + Offset] = (byte)(((value) >> 56) & 0xff);                  m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 48) & 0xff);                  m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 40) & 0xff);                  m_innerBuffer[i + Offset + 3] = (byte)(((value) >> 32) & 0xff);                  m_innerBuffer[i + Offset + 4] = (byte)(((value) >> 24) & 0xff);                  m_innerBuffer[i + Offset + 5] = (byte)(((value) >> 16) & 0xff);                  m_innerBuffer[i + Offset + 6] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset + 7] = (byte)(value & 0xff);              }              else              {                  m_innerBuffer[i + Offset + 7] = (byte)(((value) >> 56) & 0xff);                  m_innerBuffer[i + Offset + 6] = (byte)(((value) >> 48) & 0xff);                  m_innerBuffer[i + Offset + 5] = (byte)(((value) >> 40) & 0xff);                  m_innerBuffer[i + Offset + 4] = (byte)(((value) >> 32) & 0xff);                  m_innerBuffer[i + Offset + 3] = (byte)(((value) >> 24) & 0xff);                  m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 16) & 0xff);                  m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset] = (byte)(value & 0xff);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,PutLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  m_innerBuffer[i + Offset] = (byte)(((value) >> 56) & 0xff);                  m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 48) & 0xff);                  m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 40) & 0xff);                  m_innerBuffer[i + Offset + 3] = (byte)(((value) >> 32) & 0xff);                  m_innerBuffer[i + Offset + 4] = (byte)(((value) >> 24) & 0xff);                  m_innerBuffer[i + Offset + 5] = (byte)(((value) >> 16) & 0xff);                  m_innerBuffer[i + Offset + 6] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset + 7] = (byte)(value & 0xff);              }              else              {                  m_innerBuffer[i + Offset + 7] = (byte)(((value) >> 56) & 0xff);                  m_innerBuffer[i + Offset + 6] = (byte)(((value) >> 48) & 0xff);                  m_innerBuffer[i + Offset + 5] = (byte)(((value) >> 40) & 0xff);                  m_innerBuffer[i + Offset + 4] = (byte)(((value) >> 32) & 0xff);                  m_innerBuffer[i + Offset + 3] = (byte)(((value) >> 24) & 0xff);                  m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 16) & 0xff);                  m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset] = (byte)(value & 0xff);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,PutLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  m_innerBuffer[i + Offset] = (byte)(((value) >> 56) & 0xff);                  m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 48) & 0xff);                  m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 40) & 0xff);                  m_innerBuffer[i + Offset + 3] = (byte)(((value) >> 32) & 0xff);                  m_innerBuffer[i + Offset + 4] = (byte)(((value) >> 24) & 0xff);                  m_innerBuffer[i + Offset + 5] = (byte)(((value) >> 16) & 0xff);                  m_innerBuffer[i + Offset + 6] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset + 7] = (byte)(value & 0xff);              }              else              {                  m_innerBuffer[i + Offset + 7] = (byte)(((value) >> 56) & 0xff);                  m_innerBuffer[i + Offset + 6] = (byte)(((value) >> 48) & 0xff);                  m_innerBuffer[i + Offset + 5] = (byte)(((value) >> 40) & 0xff);                  m_innerBuffer[i + Offset + 4] = (byte)(((value) >> 32) & 0xff);                  m_innerBuffer[i + Offset + 3] = (byte)(((value) >> 24) & 0xff);                  m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 16) & 0xff);                  m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset] = (byte)(value & 0xff);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,PutLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  m_innerBuffer[i + Offset] = (byte)(((value) >> 56) & 0xff);                  m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 48) & 0xff);                  m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 40) & 0xff);                  m_innerBuffer[i + Offset + 3] = (byte)(((value) >> 32) & 0xff);                  m_innerBuffer[i + Offset + 4] = (byte)(((value) >> 24) & 0xff);                  m_innerBuffer[i + Offset + 5] = (byte)(((value) >> 16) & 0xff);                  m_innerBuffer[i + Offset + 6] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset + 7] = (byte)(value & 0xff);              }              else              {                  m_innerBuffer[i + Offset + 7] = (byte)(((value) >> 56) & 0xff);                  m_innerBuffer[i + Offset + 6] = (byte)(((value) >> 48) & 0xff);                  m_innerBuffer[i + Offset + 5] = (byte)(((value) >> 40) & 0xff);                  m_innerBuffer[i + Offset + 4] = (byte)(((value) >> 32) & 0xff);                  m_innerBuffer[i + Offset + 3] = (byte)(((value) >> 24) & 0xff);                  m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 16) & 0xff);                  m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset] = (byte)(value & 0xff);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,PutLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  m_innerBuffer[i + Offset] = (byte)(((value) >> 56) & 0xff);                  m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 48) & 0xff);                  m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 40) & 0xff);                  m_innerBuffer[i + Offset + 3] = (byte)(((value) >> 32) & 0xff);                  m_innerBuffer[i + Offset + 4] = (byte)(((value) >> 24) & 0xff);                  m_innerBuffer[i + Offset + 5] = (byte)(((value) >> 16) & 0xff);                  m_innerBuffer[i + Offset + 6] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset + 7] = (byte)(value & 0xff);              }              else              {                  m_innerBuffer[i + Offset + 7] = (byte)(((value) >> 56) & 0xff);                  m_innerBuffer[i + Offset + 6] = (byte)(((value) >> 48) & 0xff);                  m_innerBuffer[i + Offset + 5] = (byte)(((value) >> 40) & 0xff);                  m_innerBuffer[i + Offset + 4] = (byte)(((value) >> 32) & 0xff);                  m_innerBuffer[i + Offset + 3] = (byte)(((value) >> 24) & 0xff);                  m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 16) & 0xff);                  m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset] = (byte)(value & 0xff);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,PutLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  m_innerBuffer[i + Offset] = (byte)(((value) >> 56) & 0xff);                  m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 48) & 0xff);                  m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 40) & 0xff);                  m_innerBuffer[i + Offset + 3] = (byte)(((value) >> 32) & 0xff);                  m_innerBuffer[i + Offset + 4] = (byte)(((value) >> 24) & 0xff);                  m_innerBuffer[i + Offset + 5] = (byte)(((value) >> 16) & 0xff);                  m_innerBuffer[i + Offset + 6] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset + 7] = (byte)(value & 0xff);              }              else              {                  m_innerBuffer[i + Offset + 7] = (byte)(((value) >> 56) & 0xff);                  m_innerBuffer[i + Offset + 6] = (byte)(((value) >> 48) & 0xff);                  m_innerBuffer[i + Offset + 5] = (byte)(((value) >> 40) & 0xff);                  m_innerBuffer[i + Offset + 4] = (byte)(((value) >> 32) & 0xff);                  m_innerBuffer[i + Offset + 3] = (byte)(((value) >> 24) & 0xff);                  m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 16) & 0xff);                  m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset] = (byte)(value & 0xff);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,PutLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  m_innerBuffer[i + Offset] = (byte)(((value) >> 56) & 0xff);                  m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 48) & 0xff);                  m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 40) & 0xff);                  m_innerBuffer[i + Offset + 3] = (byte)(((value) >> 32) & 0xff);                  m_innerBuffer[i + Offset + 4] = (byte)(((value) >> 24) & 0xff);                  m_innerBuffer[i + Offset + 5] = (byte)(((value) >> 16) & 0xff);                  m_innerBuffer[i + Offset + 6] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset + 7] = (byte)(value & 0xff);              }              else              {                  m_innerBuffer[i + Offset + 7] = (byte)(((value) >> 56) & 0xff);                  m_innerBuffer[i + Offset + 6] = (byte)(((value) >> 48) & 0xff);                  m_innerBuffer[i + Offset + 5] = (byte)(((value) >> 40) & 0xff);                  m_innerBuffer[i + Offset + 4] = (byte)(((value) >> 32) & 0xff);                  m_innerBuffer[i + Offset + 3] = (byte)(((value) >> 24) & 0xff);                  m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 16) & 0xff);                  m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset] = (byte)(value & 0xff);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,PutLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  m_innerBuffer[i + Offset] = (byte)(((value) >> 56) & 0xff);                  m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 48) & 0xff);                  m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 40) & 0xff);                  m_innerBuffer[i + Offset + 3] = (byte)(((value) >> 32) & 0xff);                  m_innerBuffer[i + Offset + 4] = (byte)(((value) >> 24) & 0xff);                  m_innerBuffer[i + Offset + 5] = (byte)(((value) >> 16) & 0xff);                  m_innerBuffer[i + Offset + 6] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset + 7] = (byte)(value & 0xff);              }              else              {                  m_innerBuffer[i + Offset + 7] = (byte)(((value) >> 56) & 0xff);                  m_innerBuffer[i + Offset + 6] = (byte)(((value) >> 48) & 0xff);                  m_innerBuffer[i + Offset + 5] = (byte)(((value) >> 40) & 0xff);                  m_innerBuffer[i + Offset + 4] = (byte)(((value) >> 32) & 0xff);                  m_innerBuffer[i + Offset + 3] = (byte)(((value) >> 24) & 0xff);                  m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 16) & 0xff);                  m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset] = (byte)(value & 0xff);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,PutLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  m_innerBuffer[i + Offset] = (byte)(((value) >> 56) & 0xff);                  m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 48) & 0xff);                  m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 40) & 0xff);                  m_innerBuffer[i + Offset + 3] = (byte)(((value) >> 32) & 0xff);                  m_innerBuffer[i + Offset + 4] = (byte)(((value) >> 24) & 0xff);                  m_innerBuffer[i + Offset + 5] = (byte)(((value) >> 16) & 0xff);                  m_innerBuffer[i + Offset + 6] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset + 7] = (byte)(value & 0xff);              }              else              {                  m_innerBuffer[i + Offset + 7] = (byte)(((value) >> 56) & 0xff);                  m_innerBuffer[i + Offset + 6] = (byte)(((value) >> 48) & 0xff);                  m_innerBuffer[i + Offset + 5] = (byte)(((value) >> 40) & 0xff);                  m_innerBuffer[i + Offset + 4] = (byte)(((value) >> 32) & 0xff);                  m_innerBuffer[i + Offset + 3] = (byte)(((value) >> 24) & 0xff);                  m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 16) & 0xff);                  m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset] = (byte)(value & 0xff);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,PutLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  m_innerBuffer[i + Offset] = (byte)(((value) >> 56) & 0xff);                  m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 48) & 0xff);                  m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 40) & 0xff);                  m_innerBuffer[i + Offset + 3] = (byte)(((value) >> 32) & 0xff);                  m_innerBuffer[i + Offset + 4] = (byte)(((value) >> 24) & 0xff);                  m_innerBuffer[i + Offset + 5] = (byte)(((value) >> 16) & 0xff);                  m_innerBuffer[i + Offset + 6] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset + 7] = (byte)(value & 0xff);              }              else              {                  m_innerBuffer[i + Offset + 7] = (byte)(((value) >> 56) & 0xff);                  m_innerBuffer[i + Offset + 6] = (byte)(((value) >> 48) & 0xff);                  m_innerBuffer[i + Offset + 5] = (byte)(((value) >> 40) & 0xff);                  m_innerBuffer[i + Offset + 4] = (byte)(((value) >> 32) & 0xff);                  m_innerBuffer[i + Offset + 3] = (byte)(((value) >> 24) & 0xff);                  m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 16) & 0xff);                  m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset] = (byte)(value & 0xff);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,PutLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  m_innerBuffer[i + Offset] = (byte)(((value) >> 56) & 0xff);                  m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 48) & 0xff);                  m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 40) & 0xff);                  m_innerBuffer[i + Offset + 3] = (byte)(((value) >> 32) & 0xff);                  m_innerBuffer[i + Offset + 4] = (byte)(((value) >> 24) & 0xff);                  m_innerBuffer[i + Offset + 5] = (byte)(((value) >> 16) & 0xff);                  m_innerBuffer[i + Offset + 6] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset + 7] = (byte)(value & 0xff);              }              else              {                  m_innerBuffer[i + Offset + 7] = (byte)(((value) >> 56) & 0xff);                  m_innerBuffer[i + Offset + 6] = (byte)(((value) >> 48) & 0xff);                  m_innerBuffer[i + Offset + 5] = (byte)(((value) >> 40) & 0xff);                  m_innerBuffer[i + Offset + 4] = (byte)(((value) >> 32) & 0xff);                  m_innerBuffer[i + Offset + 3] = (byte)(((value) >> 24) & 0xff);                  m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 16) & 0xff);                  m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset] = (byte)(value & 0xff);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,PutLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  m_innerBuffer[i + Offset] = (byte)(((value) >> 56) & 0xff);                  m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 48) & 0xff);                  m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 40) & 0xff);                  m_innerBuffer[i + Offset + 3] = (byte)(((value) >> 32) & 0xff);                  m_innerBuffer[i + Offset + 4] = (byte)(((value) >> 24) & 0xff);                  m_innerBuffer[i + Offset + 5] = (byte)(((value) >> 16) & 0xff);                  m_innerBuffer[i + Offset + 6] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset + 7] = (byte)(value & 0xff);              }              else              {                  m_innerBuffer[i + Offset + 7] = (byte)(((value) >> 56) & 0xff);                  m_innerBuffer[i + Offset + 6] = (byte)(((value) >> 48) & 0xff);                  m_innerBuffer[i + Offset + 5] = (byte)(((value) >> 40) & 0xff);                  m_innerBuffer[i + Offset + 4] = (byte)(((value) >> 32) & 0xff);                  m_innerBuffer[i + Offset + 3] = (byte)(((value) >> 24) & 0xff);                  m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 16) & 0xff);                  m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset] = (byte)(value & 0xff);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,PutLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  m_innerBuffer[i + Offset] = (byte)(((value) >> 56) & 0xff);                  m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 48) & 0xff);                  m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 40) & 0xff);                  m_innerBuffer[i + Offset + 3] = (byte)(((value) >> 32) & 0xff);                  m_innerBuffer[i + Offset + 4] = (byte)(((value) >> 24) & 0xff);                  m_innerBuffer[i + Offset + 5] = (byte)(((value) >> 16) & 0xff);                  m_innerBuffer[i + Offset + 6] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset + 7] = (byte)(value & 0xff);              }              else              {                  m_innerBuffer[i + Offset + 7] = (byte)(((value) >> 56) & 0xff);                  m_innerBuffer[i + Offset + 6] = (byte)(((value) >> 48) & 0xff);                  m_innerBuffer[i + Offset + 5] = (byte)(((value) >> 40) & 0xff);                  m_innerBuffer[i + Offset + 4] = (byte)(((value) >> 32) & 0xff);                  m_innerBuffer[i + Offset + 3] = (byte)(((value) >> 24) & 0xff);                  m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 16) & 0xff);                  m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset] = (byte)(value & 0xff);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,PutLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  m_innerBuffer[i + Offset] = (byte)(((value) >> 56) & 0xff);                  m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 48) & 0xff);                  m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 40) & 0xff);                  m_innerBuffer[i + Offset + 3] = (byte)(((value) >> 32) & 0xff);                  m_innerBuffer[i + Offset + 4] = (byte)(((value) >> 24) & 0xff);                  m_innerBuffer[i + Offset + 5] = (byte)(((value) >> 16) & 0xff);                  m_innerBuffer[i + Offset + 6] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset + 7] = (byte)(value & 0xff);              }              else              {                  m_innerBuffer[i + Offset + 7] = (byte)(((value) >> 56) & 0xff);                  m_innerBuffer[i + Offset + 6] = (byte)(((value) >> 48) & 0xff);                  m_innerBuffer[i + Offset + 5] = (byte)(((value) >> 40) & 0xff);                  m_innerBuffer[i + Offset + 4] = (byte)(((value) >> 32) & 0xff);                  m_innerBuffer[i + Offset + 3] = (byte)(((value) >> 24) & 0xff);                  m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 16) & 0xff);                  m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset] = (byte)(value & 0xff);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,PutLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  m_innerBuffer[i + Offset] = (byte)(((value) >> 56) & 0xff);                  m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 48) & 0xff);                  m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 40) & 0xff);                  m_innerBuffer[i + Offset + 3] = (byte)(((value) >> 32) & 0xff);                  m_innerBuffer[i + Offset + 4] = (byte)(((value) >> 24) & 0xff);                  m_innerBuffer[i + Offset + 5] = (byte)(((value) >> 16) & 0xff);                  m_innerBuffer[i + Offset + 6] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset + 7] = (byte)(value & 0xff);              }              else              {                  m_innerBuffer[i + Offset + 7] = (byte)(((value) >> 56) & 0xff);                  m_innerBuffer[i + Offset + 6] = (byte)(((value) >> 48) & 0xff);                  m_innerBuffer[i + Offset + 5] = (byte)(((value) >> 40) & 0xff);                  m_innerBuffer[i + Offset + 4] = (byte)(((value) >> 32) & 0xff);                  m_innerBuffer[i + Offset + 3] = (byte)(((value) >> 24) & 0xff);                  m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 16) & 0xff);                  m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset] = (byte)(value & 0xff);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,PutLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  m_innerBuffer[i + Offset] = (byte)(((value) >> 56) & 0xff);                  m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 48) & 0xff);                  m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 40) & 0xff);                  m_innerBuffer[i + Offset + 3] = (byte)(((value) >> 32) & 0xff);                  m_innerBuffer[i + Offset + 4] = (byte)(((value) >> 24) & 0xff);                  m_innerBuffer[i + Offset + 5] = (byte)(((value) >> 16) & 0xff);                  m_innerBuffer[i + Offset + 6] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset + 7] = (byte)(value & 0xff);              }              else              {                  m_innerBuffer[i + Offset + 7] = (byte)(((value) >> 56) & 0xff);                  m_innerBuffer[i + Offset + 6] = (byte)(((value) >> 48) & 0xff);                  m_innerBuffer[i + Offset + 5] = (byte)(((value) >> 40) & 0xff);                  m_innerBuffer[i + Offset + 4] = (byte)(((value) >> 32) & 0xff);                  m_innerBuffer[i + Offset + 3] = (byte)(((value) >> 24) & 0xff);                  m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 16) & 0xff);                  m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset] = (byte)(value & 0xff);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,PutLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  m_innerBuffer[i + Offset] = (byte)(((value) >> 56) & 0xff);                  m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 48) & 0xff);                  m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 40) & 0xff);                  m_innerBuffer[i + Offset + 3] = (byte)(((value) >> 32) & 0xff);                  m_innerBuffer[i + Offset + 4] = (byte)(((value) >> 24) & 0xff);                  m_innerBuffer[i + Offset + 5] = (byte)(((value) >> 16) & 0xff);                  m_innerBuffer[i + Offset + 6] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset + 7] = (byte)(value & 0xff);              }              else              {                  m_innerBuffer[i + Offset + 7] = (byte)(((value) >> 56) & 0xff);                  m_innerBuffer[i + Offset + 6] = (byte)(((value) >> 48) & 0xff);                  m_innerBuffer[i + Offset + 5] = (byte)(((value) >> 40) & 0xff);                  m_innerBuffer[i + Offset + 4] = (byte)(((value) >> 32) & 0xff);                  m_innerBuffer[i + Offset + 3] = (byte)(((value) >> 24) & 0xff);                  m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 16) & 0xff);                  m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset] = (byte)(value & 0xff);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,PutLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  m_innerBuffer[i + Offset] = (byte)(((value) >> 56) & 0xff);                  m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 48) & 0xff);                  m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 40) & 0xff);                  m_innerBuffer[i + Offset + 3] = (byte)(((value) >> 32) & 0xff);                  m_innerBuffer[i + Offset + 4] = (byte)(((value) >> 24) & 0xff);                  m_innerBuffer[i + Offset + 5] = (byte)(((value) >> 16) & 0xff);                  m_innerBuffer[i + Offset + 6] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset + 7] = (byte)(value & 0xff);              }              else              {                  m_innerBuffer[i + Offset + 7] = (byte)(((value) >> 56) & 0xff);                  m_innerBuffer[i + Offset + 6] = (byte)(((value) >> 48) & 0xff);                  m_innerBuffer[i + Offset + 5] = (byte)(((value) >> 40) & 0xff);                  m_innerBuffer[i + Offset + 4] = (byte)(((value) >> 32) & 0xff);                  m_innerBuffer[i + Offset + 3] = (byte)(((value) >> 24) & 0xff);                  m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 16) & 0xff);                  m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset] = (byte)(value & 0xff);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,PutLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  m_innerBuffer[i + Offset] = (byte)(((value) >> 56) & 0xff);                  m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 48) & 0xff);                  m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 40) & 0xff);                  m_innerBuffer[i + Offset + 3] = (byte)(((value) >> 32) & 0xff);                  m_innerBuffer[i + Offset + 4] = (byte)(((value) >> 24) & 0xff);                  m_innerBuffer[i + Offset + 5] = (byte)(((value) >> 16) & 0xff);                  m_innerBuffer[i + Offset + 6] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset + 7] = (byte)(value & 0xff);              }              else              {                  m_innerBuffer[i + Offset + 7] = (byte)(((value) >> 56) & 0xff);                  m_innerBuffer[i + Offset + 6] = (byte)(((value) >> 48) & 0xff);                  m_innerBuffer[i + Offset + 5] = (byte)(((value) >> 40) & 0xff);                  m_innerBuffer[i + Offset + 4] = (byte)(((value) >> 32) & 0xff);                  m_innerBuffer[i + Offset + 3] = (byte)(((value) >> 24) & 0xff);                  m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 16) & 0xff);                  m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset] = (byte)(value & 0xff);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,PutLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  m_innerBuffer[i + Offset] = (byte)(((value) >> 56) & 0xff);                  m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 48) & 0xff);                  m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 40) & 0xff);                  m_innerBuffer[i + Offset + 3] = (byte)(((value) >> 32) & 0xff);                  m_innerBuffer[i + Offset + 4] = (byte)(((value) >> 24) & 0xff);                  m_innerBuffer[i + Offset + 5] = (byte)(((value) >> 16) & 0xff);                  m_innerBuffer[i + Offset + 6] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset + 7] = (byte)(value & 0xff);              }              else              {                  m_innerBuffer[i + Offset + 7] = (byte)(((value) >> 56) & 0xff);                  m_innerBuffer[i + Offset + 6] = (byte)(((value) >> 48) & 0xff);                  m_innerBuffer[i + Offset + 5] = (byte)(((value) >> 40) & 0xff);                  m_innerBuffer[i + Offset + 4] = (byte)(((value) >> 32) & 0xff);                  m_innerBuffer[i + Offset + 3] = (byte)(((value) >> 24) & 0xff);                  m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 16) & 0xff);                  m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset] = (byte)(value & 0xff);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,PutLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  m_innerBuffer[i + Offset] = (byte)(((value) >> 56) & 0xff);                  m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 48) & 0xff);                  m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 40) & 0xff);                  m_innerBuffer[i + Offset + 3] = (byte)(((value) >> 32) & 0xff);                  m_innerBuffer[i + Offset + 4] = (byte)(((value) >> 24) & 0xff);                  m_innerBuffer[i + Offset + 5] = (byte)(((value) >> 16) & 0xff);                  m_innerBuffer[i + Offset + 6] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset + 7] = (byte)(value & 0xff);              }              else              {                  m_innerBuffer[i + Offset + 7] = (byte)(((value) >> 56) & 0xff);                  m_innerBuffer[i + Offset + 6] = (byte)(((value) >> 48) & 0xff);                  m_innerBuffer[i + Offset + 5] = (byte)(((value) >> 40) & 0xff);                  m_innerBuffer[i + Offset + 4] = (byte)(((value) >> 32) & 0xff);                  m_innerBuffer[i + Offset + 3] = (byte)(((value) >> 24) & 0xff);                  m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 16) & 0xff);                  m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset] = (byte)(value & 0xff);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,PutLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  m_innerBuffer[i + Offset] = (byte)(((value) >> 56) & 0xff);                  m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 48) & 0xff);                  m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 40) & 0xff);                  m_innerBuffer[i + Offset + 3] = (byte)(((value) >> 32) & 0xff);                  m_innerBuffer[i + Offset + 4] = (byte)(((value) >> 24) & 0xff);                  m_innerBuffer[i + Offset + 5] = (byte)(((value) >> 16) & 0xff);                  m_innerBuffer[i + Offset + 6] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset + 7] = (byte)(value & 0xff);              }              else              {                  m_innerBuffer[i + Offset + 7] = (byte)(((value) >> 56) & 0xff);                  m_innerBuffer[i + Offset + 6] = (byte)(((value) >> 48) & 0xff);                  m_innerBuffer[i + Offset + 5] = (byte)(((value) >> 40) & 0xff);                  m_innerBuffer[i + Offset + 4] = (byte)(((value) >> 32) & 0xff);                  m_innerBuffer[i + Offset + 3] = (byte)(((value) >> 24) & 0xff);                  m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 16) & 0xff);                  m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset] = (byte)(value & 0xff);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,PutLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  m_innerBuffer[i + Offset] = (byte)(((value) >> 56) & 0xff);                  m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 48) & 0xff);                  m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 40) & 0xff);                  m_innerBuffer[i + Offset + 3] = (byte)(((value) >> 32) & 0xff);                  m_innerBuffer[i + Offset + 4] = (byte)(((value) >> 24) & 0xff);                  m_innerBuffer[i + Offset + 5] = (byte)(((value) >> 16) & 0xff);                  m_innerBuffer[i + Offset + 6] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset + 7] = (byte)(value & 0xff);              }              else              {                  m_innerBuffer[i + Offset + 7] = (byte)(((value) >> 56) & 0xff);                  m_innerBuffer[i + Offset + 6] = (byte)(((value) >> 48) & 0xff);                  m_innerBuffer[i + Offset + 5] = (byte)(((value) >> 40) & 0xff);                  m_innerBuffer[i + Offset + 4] = (byte)(((value) >> 32) & 0xff);                  m_innerBuffer[i + Offset + 3] = (byte)(((value) >> 24) & 0xff);                  m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 16) & 0xff);                  m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset] = (byte)(value & 0xff);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,PutLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  m_innerBuffer[i + Offset] = (byte)(((value) >> 56) & 0xff);                  m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 48) & 0xff);                  m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 40) & 0xff);                  m_innerBuffer[i + Offset + 3] = (byte)(((value) >> 32) & 0xff);                  m_innerBuffer[i + Offset + 4] = (byte)(((value) >> 24) & 0xff);                  m_innerBuffer[i + Offset + 5] = (byte)(((value) >> 16) & 0xff);                  m_innerBuffer[i + Offset + 6] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset + 7] = (byte)(value & 0xff);              }              else              {                  m_innerBuffer[i + Offset + 7] = (byte)(((value) >> 56) & 0xff);                  m_innerBuffer[i + Offset + 6] = (byte)(((value) >> 48) & 0xff);                  m_innerBuffer[i + Offset + 5] = (byte)(((value) >> 40) & 0xff);                  m_innerBuffer[i + Offset + 4] = (byte)(((value) >> 32) & 0xff);                  m_innerBuffer[i + Offset + 3] = (byte)(((value) >> 24) & 0xff);                  m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 16) & 0xff);                  m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset] = (byte)(value & 0xff);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,PutUnsignedShort,The following statement contains a magic number: if (endian == Endianness.Big)              {                  m_innerBuffer[i + Offset] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset + 1] = (byte)(value & 0xff);              }              else              {                  m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset] = (byte)(value & 0xff);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,PutUnsignedShort,The following statement contains a magic number: if (endian == Endianness.Big)              {                  m_innerBuffer[i + Offset] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset + 1] = (byte)(value & 0xff);              }              else              {                  m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset] = (byte)(value & 0xff);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,PutInteger,The following statement contains a magic number: if (endian == Endianness.Big)              {                  m_innerBuffer[i + Offset] = (byte)(((value) >> 24) & 0xff);                  m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 16) & 0xff);                  m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset + 3] = (byte)(value & 0xff);              }              else              {                  m_innerBuffer[i + Offset + 3] = (byte)(((value) >> 24) & 0xff);                  m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 16) & 0xff);                  m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset] = (byte)(value & 0xff);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,PutInteger,The following statement contains a magic number: if (endian == Endianness.Big)              {                  m_innerBuffer[i + Offset] = (byte)(((value) >> 24) & 0xff);                  m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 16) & 0xff);                  m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset + 3] = (byte)(value & 0xff);              }              else              {                  m_innerBuffer[i + Offset + 3] = (byte)(((value) >> 24) & 0xff);                  m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 16) & 0xff);                  m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset] = (byte)(value & 0xff);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,PutInteger,The following statement contains a magic number: if (endian == Endianness.Big)              {                  m_innerBuffer[i + Offset] = (byte)(((value) >> 24) & 0xff);                  m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 16) & 0xff);                  m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset + 3] = (byte)(value & 0xff);              }              else              {                  m_innerBuffer[i + Offset + 3] = (byte)(((value) >> 24) & 0xff);                  m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 16) & 0xff);                  m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset] = (byte)(value & 0xff);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,PutInteger,The following statement contains a magic number: if (endian == Endianness.Big)              {                  m_innerBuffer[i + Offset] = (byte)(((value) >> 24) & 0xff);                  m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 16) & 0xff);                  m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset + 3] = (byte)(value & 0xff);              }              else              {                  m_innerBuffer[i + Offset + 3] = (byte)(((value) >> 24) & 0xff);                  m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 16) & 0xff);                  m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset] = (byte)(value & 0xff);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,PutInteger,The following statement contains a magic number: if (endian == Endianness.Big)              {                  m_innerBuffer[i + Offset] = (byte)(((value) >> 24) & 0xff);                  m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 16) & 0xff);                  m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset + 3] = (byte)(value & 0xff);              }              else              {                  m_innerBuffer[i + Offset + 3] = (byte)(((value) >> 24) & 0xff);                  m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 16) & 0xff);                  m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset] = (byte)(value & 0xff);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,PutInteger,The following statement contains a magic number: if (endian == Endianness.Big)              {                  m_innerBuffer[i + Offset] = (byte)(((value) >> 24) & 0xff);                  m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 16) & 0xff);                  m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset + 3] = (byte)(value & 0xff);              }              else              {                  m_innerBuffer[i + Offset + 3] = (byte)(((value) >> 24) & 0xff);                  m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 16) & 0xff);                  m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset] = (byte)(value & 0xff);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,PutInteger,The following statement contains a magic number: if (endian == Endianness.Big)              {                  m_innerBuffer[i + Offset] = (byte)(((value) >> 24) & 0xff);                  m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 16) & 0xff);                  m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset + 3] = (byte)(value & 0xff);              }              else              {                  m_innerBuffer[i + Offset + 3] = (byte)(((value) >> 24) & 0xff);                  m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 16) & 0xff);                  m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset] = (byte)(value & 0xff);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,PutInteger,The following statement contains a magic number: if (endian == Endianness.Big)              {                  m_innerBuffer[i + Offset] = (byte)(((value) >> 24) & 0xff);                  m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 16) & 0xff);                  m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset + 3] = (byte)(value & 0xff);              }              else              {                  m_innerBuffer[i + Offset + 3] = (byte)(((value) >> 24) & 0xff);                  m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 16) & 0xff);                  m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset] = (byte)(value & 0xff);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,PutInteger,The following statement contains a magic number: if (endian == Endianness.Big)              {                  m_innerBuffer[i + Offset] = (byte)(((value) >> 24) & 0xff);                  m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 16) & 0xff);                  m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset + 3] = (byte)(value & 0xff);              }              else              {                  m_innerBuffer[i + Offset + 3] = (byte)(((value) >> 24) & 0xff);                  m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 16) & 0xff);                  m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset] = (byte)(value & 0xff);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,PutInteger,The following statement contains a magic number: if (endian == Endianness.Big)              {                  m_innerBuffer[i + Offset] = (byte)(((value) >> 24) & 0xff);                  m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 16) & 0xff);                  m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset + 3] = (byte)(value & 0xff);              }              else              {                  m_innerBuffer[i + Offset + 3] = (byte)(((value) >> 24) & 0xff);                  m_innerBuffer[i + Offset + 2] = (byte)(((value) >> 16) & 0xff);                  m_innerBuffer[i + Offset + 1] = (byte)(((value) >> 8) & 0xff);                  m_innerBuffer[i + Offset] = (byte)(value & 0xff);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  return                      (((long)m_innerBuffer[i + Offset]) << 56) |                      (((long)m_innerBuffer[i + Offset + 1]) << 48) |                      (((long)m_innerBuffer[i + Offset + 2]) << 40) |                      (((long)m_innerBuffer[i + Offset + 3]) << 32) |                      (((long)m_innerBuffer[i + Offset + 4]) << 24) |                      (((long)m_innerBuffer[i + Offset + 5]) << 16) |                      (((long)m_innerBuffer[i + Offset + 6]) << 8) |                      ((long)m_innerBuffer[i + Offset + 7]);              }              else              {                  return                  (((long)m_innerBuffer[i + Offset + 7]) << 56) |                  (((long)m_innerBuffer[i + Offset + 6]) << 48) |                  (((long)m_innerBuffer[i + Offset + 5]) << 40) |                  (((long)m_innerBuffer[i + Offset + 4]) << 32) |                  (((long)m_innerBuffer[i + Offset + 3]) << 24) |                  (((long)m_innerBuffer[i + Offset + 2]) << 16) |                  (((long)m_innerBuffer[i + Offset + 1]) << 8) |                  ((long)m_innerBuffer[i + Offset + 0]);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  return                      (((long)m_innerBuffer[i + Offset]) << 56) |                      (((long)m_innerBuffer[i + Offset + 1]) << 48) |                      (((long)m_innerBuffer[i + Offset + 2]) << 40) |                      (((long)m_innerBuffer[i + Offset + 3]) << 32) |                      (((long)m_innerBuffer[i + Offset + 4]) << 24) |                      (((long)m_innerBuffer[i + Offset + 5]) << 16) |                      (((long)m_innerBuffer[i + Offset + 6]) << 8) |                      ((long)m_innerBuffer[i + Offset + 7]);              }              else              {                  return                  (((long)m_innerBuffer[i + Offset + 7]) << 56) |                  (((long)m_innerBuffer[i + Offset + 6]) << 48) |                  (((long)m_innerBuffer[i + Offset + 5]) << 40) |                  (((long)m_innerBuffer[i + Offset + 4]) << 32) |                  (((long)m_innerBuffer[i + Offset + 3]) << 24) |                  (((long)m_innerBuffer[i + Offset + 2]) << 16) |                  (((long)m_innerBuffer[i + Offset + 1]) << 8) |                  ((long)m_innerBuffer[i + Offset + 0]);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  return                      (((long)m_innerBuffer[i + Offset]) << 56) |                      (((long)m_innerBuffer[i + Offset + 1]) << 48) |                      (((long)m_innerBuffer[i + Offset + 2]) << 40) |                      (((long)m_innerBuffer[i + Offset + 3]) << 32) |                      (((long)m_innerBuffer[i + Offset + 4]) << 24) |                      (((long)m_innerBuffer[i + Offset + 5]) << 16) |                      (((long)m_innerBuffer[i + Offset + 6]) << 8) |                      ((long)m_innerBuffer[i + Offset + 7]);              }              else              {                  return                  (((long)m_innerBuffer[i + Offset + 7]) << 56) |                  (((long)m_innerBuffer[i + Offset + 6]) << 48) |                  (((long)m_innerBuffer[i + Offset + 5]) << 40) |                  (((long)m_innerBuffer[i + Offset + 4]) << 32) |                  (((long)m_innerBuffer[i + Offset + 3]) << 24) |                  (((long)m_innerBuffer[i + Offset + 2]) << 16) |                  (((long)m_innerBuffer[i + Offset + 1]) << 8) |                  ((long)m_innerBuffer[i + Offset + 0]);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  return                      (((long)m_innerBuffer[i + Offset]) << 56) |                      (((long)m_innerBuffer[i + Offset + 1]) << 48) |                      (((long)m_innerBuffer[i + Offset + 2]) << 40) |                      (((long)m_innerBuffer[i + Offset + 3]) << 32) |                      (((long)m_innerBuffer[i + Offset + 4]) << 24) |                      (((long)m_innerBuffer[i + Offset + 5]) << 16) |                      (((long)m_innerBuffer[i + Offset + 6]) << 8) |                      ((long)m_innerBuffer[i + Offset + 7]);              }              else              {                  return                  (((long)m_innerBuffer[i + Offset + 7]) << 56) |                  (((long)m_innerBuffer[i + Offset + 6]) << 48) |                  (((long)m_innerBuffer[i + Offset + 5]) << 40) |                  (((long)m_innerBuffer[i + Offset + 4]) << 32) |                  (((long)m_innerBuffer[i + Offset + 3]) << 24) |                  (((long)m_innerBuffer[i + Offset + 2]) << 16) |                  (((long)m_innerBuffer[i + Offset + 1]) << 8) |                  ((long)m_innerBuffer[i + Offset + 0]);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  return                      (((long)m_innerBuffer[i + Offset]) << 56) |                      (((long)m_innerBuffer[i + Offset + 1]) << 48) |                      (((long)m_innerBuffer[i + Offset + 2]) << 40) |                      (((long)m_innerBuffer[i + Offset + 3]) << 32) |                      (((long)m_innerBuffer[i + Offset + 4]) << 24) |                      (((long)m_innerBuffer[i + Offset + 5]) << 16) |                      (((long)m_innerBuffer[i + Offset + 6]) << 8) |                      ((long)m_innerBuffer[i + Offset + 7]);              }              else              {                  return                  (((long)m_innerBuffer[i + Offset + 7]) << 56) |                  (((long)m_innerBuffer[i + Offset + 6]) << 48) |                  (((long)m_innerBuffer[i + Offset + 5]) << 40) |                  (((long)m_innerBuffer[i + Offset + 4]) << 32) |                  (((long)m_innerBuffer[i + Offset + 3]) << 24) |                  (((long)m_innerBuffer[i + Offset + 2]) << 16) |                  (((long)m_innerBuffer[i + Offset + 1]) << 8) |                  ((long)m_innerBuffer[i + Offset + 0]);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  return                      (((long)m_innerBuffer[i + Offset]) << 56) |                      (((long)m_innerBuffer[i + Offset + 1]) << 48) |                      (((long)m_innerBuffer[i + Offset + 2]) << 40) |                      (((long)m_innerBuffer[i + Offset + 3]) << 32) |                      (((long)m_innerBuffer[i + Offset + 4]) << 24) |                      (((long)m_innerBuffer[i + Offset + 5]) << 16) |                      (((long)m_innerBuffer[i + Offset + 6]) << 8) |                      ((long)m_innerBuffer[i + Offset + 7]);              }              else              {                  return                  (((long)m_innerBuffer[i + Offset + 7]) << 56) |                  (((long)m_innerBuffer[i + Offset + 6]) << 48) |                  (((long)m_innerBuffer[i + Offset + 5]) << 40) |                  (((long)m_innerBuffer[i + Offset + 4]) << 32) |                  (((long)m_innerBuffer[i + Offset + 3]) << 24) |                  (((long)m_innerBuffer[i + Offset + 2]) << 16) |                  (((long)m_innerBuffer[i + Offset + 1]) << 8) |                  ((long)m_innerBuffer[i + Offset + 0]);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  return                      (((long)m_innerBuffer[i + Offset]) << 56) |                      (((long)m_innerBuffer[i + Offset + 1]) << 48) |                      (((long)m_innerBuffer[i + Offset + 2]) << 40) |                      (((long)m_innerBuffer[i + Offset + 3]) << 32) |                      (((long)m_innerBuffer[i + Offset + 4]) << 24) |                      (((long)m_innerBuffer[i + Offset + 5]) << 16) |                      (((long)m_innerBuffer[i + Offset + 6]) << 8) |                      ((long)m_innerBuffer[i + Offset + 7]);              }              else              {                  return                  (((long)m_innerBuffer[i + Offset + 7]) << 56) |                  (((long)m_innerBuffer[i + Offset + 6]) << 48) |                  (((long)m_innerBuffer[i + Offset + 5]) << 40) |                  (((long)m_innerBuffer[i + Offset + 4]) << 32) |                  (((long)m_innerBuffer[i + Offset + 3]) << 24) |                  (((long)m_innerBuffer[i + Offset + 2]) << 16) |                  (((long)m_innerBuffer[i + Offset + 1]) << 8) |                  ((long)m_innerBuffer[i + Offset + 0]);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  return                      (((long)m_innerBuffer[i + Offset]) << 56) |                      (((long)m_innerBuffer[i + Offset + 1]) << 48) |                      (((long)m_innerBuffer[i + Offset + 2]) << 40) |                      (((long)m_innerBuffer[i + Offset + 3]) << 32) |                      (((long)m_innerBuffer[i + Offset + 4]) << 24) |                      (((long)m_innerBuffer[i + Offset + 5]) << 16) |                      (((long)m_innerBuffer[i + Offset + 6]) << 8) |                      ((long)m_innerBuffer[i + Offset + 7]);              }              else              {                  return                  (((long)m_innerBuffer[i + Offset + 7]) << 56) |                  (((long)m_innerBuffer[i + Offset + 6]) << 48) |                  (((long)m_innerBuffer[i + Offset + 5]) << 40) |                  (((long)m_innerBuffer[i + Offset + 4]) << 32) |                  (((long)m_innerBuffer[i + Offset + 3]) << 24) |                  (((long)m_innerBuffer[i + Offset + 2]) << 16) |                  (((long)m_innerBuffer[i + Offset + 1]) << 8) |                  ((long)m_innerBuffer[i + Offset + 0]);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  return                      (((long)m_innerBuffer[i + Offset]) << 56) |                      (((long)m_innerBuffer[i + Offset + 1]) << 48) |                      (((long)m_innerBuffer[i + Offset + 2]) << 40) |                      (((long)m_innerBuffer[i + Offset + 3]) << 32) |                      (((long)m_innerBuffer[i + Offset + 4]) << 24) |                      (((long)m_innerBuffer[i + Offset + 5]) << 16) |                      (((long)m_innerBuffer[i + Offset + 6]) << 8) |                      ((long)m_innerBuffer[i + Offset + 7]);              }              else              {                  return                  (((long)m_innerBuffer[i + Offset + 7]) << 56) |                  (((long)m_innerBuffer[i + Offset + 6]) << 48) |                  (((long)m_innerBuffer[i + Offset + 5]) << 40) |                  (((long)m_innerBuffer[i + Offset + 4]) << 32) |                  (((long)m_innerBuffer[i + Offset + 3]) << 24) |                  (((long)m_innerBuffer[i + Offset + 2]) << 16) |                  (((long)m_innerBuffer[i + Offset + 1]) << 8) |                  ((long)m_innerBuffer[i + Offset + 0]);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  return                      (((long)m_innerBuffer[i + Offset]) << 56) |                      (((long)m_innerBuffer[i + Offset + 1]) << 48) |                      (((long)m_innerBuffer[i + Offset + 2]) << 40) |                      (((long)m_innerBuffer[i + Offset + 3]) << 32) |                      (((long)m_innerBuffer[i + Offset + 4]) << 24) |                      (((long)m_innerBuffer[i + Offset + 5]) << 16) |                      (((long)m_innerBuffer[i + Offset + 6]) << 8) |                      ((long)m_innerBuffer[i + Offset + 7]);              }              else              {                  return                  (((long)m_innerBuffer[i + Offset + 7]) << 56) |                  (((long)m_innerBuffer[i + Offset + 6]) << 48) |                  (((long)m_innerBuffer[i + Offset + 5]) << 40) |                  (((long)m_innerBuffer[i + Offset + 4]) << 32) |                  (((long)m_innerBuffer[i + Offset + 3]) << 24) |                  (((long)m_innerBuffer[i + Offset + 2]) << 16) |                  (((long)m_innerBuffer[i + Offset + 1]) << 8) |                  ((long)m_innerBuffer[i + Offset + 0]);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  return                      (((long)m_innerBuffer[i + Offset]) << 56) |                      (((long)m_innerBuffer[i + Offset + 1]) << 48) |                      (((long)m_innerBuffer[i + Offset + 2]) << 40) |                      (((long)m_innerBuffer[i + Offset + 3]) << 32) |                      (((long)m_innerBuffer[i + Offset + 4]) << 24) |                      (((long)m_innerBuffer[i + Offset + 5]) << 16) |                      (((long)m_innerBuffer[i + Offset + 6]) << 8) |                      ((long)m_innerBuffer[i + Offset + 7]);              }              else              {                  return                  (((long)m_innerBuffer[i + Offset + 7]) << 56) |                  (((long)m_innerBuffer[i + Offset + 6]) << 48) |                  (((long)m_innerBuffer[i + Offset + 5]) << 40) |                  (((long)m_innerBuffer[i + Offset + 4]) << 32) |                  (((long)m_innerBuffer[i + Offset + 3]) << 24) |                  (((long)m_innerBuffer[i + Offset + 2]) << 16) |                  (((long)m_innerBuffer[i + Offset + 1]) << 8) |                  ((long)m_innerBuffer[i + Offset + 0]);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  return                      (((long)m_innerBuffer[i + Offset]) << 56) |                      (((long)m_innerBuffer[i + Offset + 1]) << 48) |                      (((long)m_innerBuffer[i + Offset + 2]) << 40) |                      (((long)m_innerBuffer[i + Offset + 3]) << 32) |                      (((long)m_innerBuffer[i + Offset + 4]) << 24) |                      (((long)m_innerBuffer[i + Offset + 5]) << 16) |                      (((long)m_innerBuffer[i + Offset + 6]) << 8) |                      ((long)m_innerBuffer[i + Offset + 7]);              }              else              {                  return                  (((long)m_innerBuffer[i + Offset + 7]) << 56) |                  (((long)m_innerBuffer[i + Offset + 6]) << 48) |                  (((long)m_innerBuffer[i + Offset + 5]) << 40) |                  (((long)m_innerBuffer[i + Offset + 4]) << 32) |                  (((long)m_innerBuffer[i + Offset + 3]) << 24) |                  (((long)m_innerBuffer[i + Offset + 2]) << 16) |                  (((long)m_innerBuffer[i + Offset + 1]) << 8) |                  ((long)m_innerBuffer[i + Offset + 0]);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  return                      (((long)m_innerBuffer[i + Offset]) << 56) |                      (((long)m_innerBuffer[i + Offset + 1]) << 48) |                      (((long)m_innerBuffer[i + Offset + 2]) << 40) |                      (((long)m_innerBuffer[i + Offset + 3]) << 32) |                      (((long)m_innerBuffer[i + Offset + 4]) << 24) |                      (((long)m_innerBuffer[i + Offset + 5]) << 16) |                      (((long)m_innerBuffer[i + Offset + 6]) << 8) |                      ((long)m_innerBuffer[i + Offset + 7]);              }              else              {                  return                  (((long)m_innerBuffer[i + Offset + 7]) << 56) |                  (((long)m_innerBuffer[i + Offset + 6]) << 48) |                  (((long)m_innerBuffer[i + Offset + 5]) << 40) |                  (((long)m_innerBuffer[i + Offset + 4]) << 32) |                  (((long)m_innerBuffer[i + Offset + 3]) << 24) |                  (((long)m_innerBuffer[i + Offset + 2]) << 16) |                  (((long)m_innerBuffer[i + Offset + 1]) << 8) |                  ((long)m_innerBuffer[i + Offset + 0]);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  return                      (((long)m_innerBuffer[i + Offset]) << 56) |                      (((long)m_innerBuffer[i + Offset + 1]) << 48) |                      (((long)m_innerBuffer[i + Offset + 2]) << 40) |                      (((long)m_innerBuffer[i + Offset + 3]) << 32) |                      (((long)m_innerBuffer[i + Offset + 4]) << 24) |                      (((long)m_innerBuffer[i + Offset + 5]) << 16) |                      (((long)m_innerBuffer[i + Offset + 6]) << 8) |                      ((long)m_innerBuffer[i + Offset + 7]);              }              else              {                  return                  (((long)m_innerBuffer[i + Offset + 7]) << 56) |                  (((long)m_innerBuffer[i + Offset + 6]) << 48) |                  (((long)m_innerBuffer[i + Offset + 5]) << 40) |                  (((long)m_innerBuffer[i + Offset + 4]) << 32) |                  (((long)m_innerBuffer[i + Offset + 3]) << 24) |                  (((long)m_innerBuffer[i + Offset + 2]) << 16) |                  (((long)m_innerBuffer[i + Offset + 1]) << 8) |                  ((long)m_innerBuffer[i + Offset + 0]);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  return                      (((long)m_innerBuffer[i + Offset]) << 56) |                      (((long)m_innerBuffer[i + Offset + 1]) << 48) |                      (((long)m_innerBuffer[i + Offset + 2]) << 40) |                      (((long)m_innerBuffer[i + Offset + 3]) << 32) |                      (((long)m_innerBuffer[i + Offset + 4]) << 24) |                      (((long)m_innerBuffer[i + Offset + 5]) << 16) |                      (((long)m_innerBuffer[i + Offset + 6]) << 8) |                      ((long)m_innerBuffer[i + Offset + 7]);              }              else              {                  return                  (((long)m_innerBuffer[i + Offset + 7]) << 56) |                  (((long)m_innerBuffer[i + Offset + 6]) << 48) |                  (((long)m_innerBuffer[i + Offset + 5]) << 40) |                  (((long)m_innerBuffer[i + Offset + 4]) << 32) |                  (((long)m_innerBuffer[i + Offset + 3]) << 24) |                  (((long)m_innerBuffer[i + Offset + 2]) << 16) |                  (((long)m_innerBuffer[i + Offset + 1]) << 8) |                  ((long)m_innerBuffer[i + Offset + 0]);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  return                      (((long)m_innerBuffer[i + Offset]) << 56) |                      (((long)m_innerBuffer[i + Offset + 1]) << 48) |                      (((long)m_innerBuffer[i + Offset + 2]) << 40) |                      (((long)m_innerBuffer[i + Offset + 3]) << 32) |                      (((long)m_innerBuffer[i + Offset + 4]) << 24) |                      (((long)m_innerBuffer[i + Offset + 5]) << 16) |                      (((long)m_innerBuffer[i + Offset + 6]) << 8) |                      ((long)m_innerBuffer[i + Offset + 7]);              }              else              {                  return                  (((long)m_innerBuffer[i + Offset + 7]) << 56) |                  (((long)m_innerBuffer[i + Offset + 6]) << 48) |                  (((long)m_innerBuffer[i + Offset + 5]) << 40) |                  (((long)m_innerBuffer[i + Offset + 4]) << 32) |                  (((long)m_innerBuffer[i + Offset + 3]) << 24) |                  (((long)m_innerBuffer[i + Offset + 2]) << 16) |                  (((long)m_innerBuffer[i + Offset + 1]) << 8) |                  ((long)m_innerBuffer[i + Offset + 0]);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  return                      (((long)m_innerBuffer[i + Offset]) << 56) |                      (((long)m_innerBuffer[i + Offset + 1]) << 48) |                      (((long)m_innerBuffer[i + Offset + 2]) << 40) |                      (((long)m_innerBuffer[i + Offset + 3]) << 32) |                      (((long)m_innerBuffer[i + Offset + 4]) << 24) |                      (((long)m_innerBuffer[i + Offset + 5]) << 16) |                      (((long)m_innerBuffer[i + Offset + 6]) << 8) |                      ((long)m_innerBuffer[i + Offset + 7]);              }              else              {                  return                  (((long)m_innerBuffer[i + Offset + 7]) << 56) |                  (((long)m_innerBuffer[i + Offset + 6]) << 48) |                  (((long)m_innerBuffer[i + Offset + 5]) << 40) |                  (((long)m_innerBuffer[i + Offset + 4]) << 32) |                  (((long)m_innerBuffer[i + Offset + 3]) << 24) |                  (((long)m_innerBuffer[i + Offset + 2]) << 16) |                  (((long)m_innerBuffer[i + Offset + 1]) << 8) |                  ((long)m_innerBuffer[i + Offset + 0]);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  return                      (((long)m_innerBuffer[i + Offset]) << 56) |                      (((long)m_innerBuffer[i + Offset + 1]) << 48) |                      (((long)m_innerBuffer[i + Offset + 2]) << 40) |                      (((long)m_innerBuffer[i + Offset + 3]) << 32) |                      (((long)m_innerBuffer[i + Offset + 4]) << 24) |                      (((long)m_innerBuffer[i + Offset + 5]) << 16) |                      (((long)m_innerBuffer[i + Offset + 6]) << 8) |                      ((long)m_innerBuffer[i + Offset + 7]);              }              else              {                  return                  (((long)m_innerBuffer[i + Offset + 7]) << 56) |                  (((long)m_innerBuffer[i + Offset + 6]) << 48) |                  (((long)m_innerBuffer[i + Offset + 5]) << 40) |                  (((long)m_innerBuffer[i + Offset + 4]) << 32) |                  (((long)m_innerBuffer[i + Offset + 3]) << 24) |                  (((long)m_innerBuffer[i + Offset + 2]) << 16) |                  (((long)m_innerBuffer[i + Offset + 1]) << 8) |                  ((long)m_innerBuffer[i + Offset + 0]);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  return                      (((long)m_innerBuffer[i + Offset]) << 56) |                      (((long)m_innerBuffer[i + Offset + 1]) << 48) |                      (((long)m_innerBuffer[i + Offset + 2]) << 40) |                      (((long)m_innerBuffer[i + Offset + 3]) << 32) |                      (((long)m_innerBuffer[i + Offset + 4]) << 24) |                      (((long)m_innerBuffer[i + Offset + 5]) << 16) |                      (((long)m_innerBuffer[i + Offset + 6]) << 8) |                      ((long)m_innerBuffer[i + Offset + 7]);              }              else              {                  return                  (((long)m_innerBuffer[i + Offset + 7]) << 56) |                  (((long)m_innerBuffer[i + Offset + 6]) << 48) |                  (((long)m_innerBuffer[i + Offset + 5]) << 40) |                  (((long)m_innerBuffer[i + Offset + 4]) << 32) |                  (((long)m_innerBuffer[i + Offset + 3]) << 24) |                  (((long)m_innerBuffer[i + Offset + 2]) << 16) |                  (((long)m_innerBuffer[i + Offset + 1]) << 8) |                  ((long)m_innerBuffer[i + Offset + 0]);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  return                      (((long)m_innerBuffer[i + Offset]) << 56) |                      (((long)m_innerBuffer[i + Offset + 1]) << 48) |                      (((long)m_innerBuffer[i + Offset + 2]) << 40) |                      (((long)m_innerBuffer[i + Offset + 3]) << 32) |                      (((long)m_innerBuffer[i + Offset + 4]) << 24) |                      (((long)m_innerBuffer[i + Offset + 5]) << 16) |                      (((long)m_innerBuffer[i + Offset + 6]) << 8) |                      ((long)m_innerBuffer[i + Offset + 7]);              }              else              {                  return                  (((long)m_innerBuffer[i + Offset + 7]) << 56) |                  (((long)m_innerBuffer[i + Offset + 6]) << 48) |                  (((long)m_innerBuffer[i + Offset + 5]) << 40) |                  (((long)m_innerBuffer[i + Offset + 4]) << 32) |                  (((long)m_innerBuffer[i + Offset + 3]) << 24) |                  (((long)m_innerBuffer[i + Offset + 2]) << 16) |                  (((long)m_innerBuffer[i + Offset + 1]) << 8) |                  ((long)m_innerBuffer[i + Offset + 0]);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  return                      (((long)m_innerBuffer[i + Offset]) << 56) |                      (((long)m_innerBuffer[i + Offset + 1]) << 48) |                      (((long)m_innerBuffer[i + Offset + 2]) << 40) |                      (((long)m_innerBuffer[i + Offset + 3]) << 32) |                      (((long)m_innerBuffer[i + Offset + 4]) << 24) |                      (((long)m_innerBuffer[i + Offset + 5]) << 16) |                      (((long)m_innerBuffer[i + Offset + 6]) << 8) |                      ((long)m_innerBuffer[i + Offset + 7]);              }              else              {                  return                  (((long)m_innerBuffer[i + Offset + 7]) << 56) |                  (((long)m_innerBuffer[i + Offset + 6]) << 48) |                  (((long)m_innerBuffer[i + Offset + 5]) << 40) |                  (((long)m_innerBuffer[i + Offset + 4]) << 32) |                  (((long)m_innerBuffer[i + Offset + 3]) << 24) |                  (((long)m_innerBuffer[i + Offset + 2]) << 16) |                  (((long)m_innerBuffer[i + Offset + 1]) << 8) |                  ((long)m_innerBuffer[i + Offset + 0]);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  return                      (((long)m_innerBuffer[i + Offset]) << 56) |                      (((long)m_innerBuffer[i + Offset + 1]) << 48) |                      (((long)m_innerBuffer[i + Offset + 2]) << 40) |                      (((long)m_innerBuffer[i + Offset + 3]) << 32) |                      (((long)m_innerBuffer[i + Offset + 4]) << 24) |                      (((long)m_innerBuffer[i + Offset + 5]) << 16) |                      (((long)m_innerBuffer[i + Offset + 6]) << 8) |                      ((long)m_innerBuffer[i + Offset + 7]);              }              else              {                  return                  (((long)m_innerBuffer[i + Offset + 7]) << 56) |                  (((long)m_innerBuffer[i + Offset + 6]) << 48) |                  (((long)m_innerBuffer[i + Offset + 5]) << 40) |                  (((long)m_innerBuffer[i + Offset + 4]) << 32) |                  (((long)m_innerBuffer[i + Offset + 3]) << 24) |                  (((long)m_innerBuffer[i + Offset + 2]) << 16) |                  (((long)m_innerBuffer[i + Offset + 1]) << 8) |                  ((long)m_innerBuffer[i + Offset + 0]);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  return                      (((long)m_innerBuffer[i + Offset]) << 56) |                      (((long)m_innerBuffer[i + Offset + 1]) << 48) |                      (((long)m_innerBuffer[i + Offset + 2]) << 40) |                      (((long)m_innerBuffer[i + Offset + 3]) << 32) |                      (((long)m_innerBuffer[i + Offset + 4]) << 24) |                      (((long)m_innerBuffer[i + Offset + 5]) << 16) |                      (((long)m_innerBuffer[i + Offset + 6]) << 8) |                      ((long)m_innerBuffer[i + Offset + 7]);              }              else              {                  return                  (((long)m_innerBuffer[i + Offset + 7]) << 56) |                  (((long)m_innerBuffer[i + Offset + 6]) << 48) |                  (((long)m_innerBuffer[i + Offset + 5]) << 40) |                  (((long)m_innerBuffer[i + Offset + 4]) << 32) |                  (((long)m_innerBuffer[i + Offset + 3]) << 24) |                  (((long)m_innerBuffer[i + Offset + 2]) << 16) |                  (((long)m_innerBuffer[i + Offset + 1]) << 8) |                  ((long)m_innerBuffer[i + Offset + 0]);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  return                      (((long)m_innerBuffer[i + Offset]) << 56) |                      (((long)m_innerBuffer[i + Offset + 1]) << 48) |                      (((long)m_innerBuffer[i + Offset + 2]) << 40) |                      (((long)m_innerBuffer[i + Offset + 3]) << 32) |                      (((long)m_innerBuffer[i + Offset + 4]) << 24) |                      (((long)m_innerBuffer[i + Offset + 5]) << 16) |                      (((long)m_innerBuffer[i + Offset + 6]) << 8) |                      ((long)m_innerBuffer[i + Offset + 7]);              }              else              {                  return                  (((long)m_innerBuffer[i + Offset + 7]) << 56) |                  (((long)m_innerBuffer[i + Offset + 6]) << 48) |                  (((long)m_innerBuffer[i + Offset + 5]) << 40) |                  (((long)m_innerBuffer[i + Offset + 4]) << 32) |                  (((long)m_innerBuffer[i + Offset + 3]) << 24) |                  (((long)m_innerBuffer[i + Offset + 2]) << 16) |                  (((long)m_innerBuffer[i + Offset + 1]) << 8) |                  ((long)m_innerBuffer[i + Offset + 0]);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  return                      (((long)m_innerBuffer[i + Offset]) << 56) |                      (((long)m_innerBuffer[i + Offset + 1]) << 48) |                      (((long)m_innerBuffer[i + Offset + 2]) << 40) |                      (((long)m_innerBuffer[i + Offset + 3]) << 32) |                      (((long)m_innerBuffer[i + Offset + 4]) << 24) |                      (((long)m_innerBuffer[i + Offset + 5]) << 16) |                      (((long)m_innerBuffer[i + Offset + 6]) << 8) |                      ((long)m_innerBuffer[i + Offset + 7]);              }              else              {                  return                  (((long)m_innerBuffer[i + Offset + 7]) << 56) |                  (((long)m_innerBuffer[i + Offset + 6]) << 48) |                  (((long)m_innerBuffer[i + Offset + 5]) << 40) |                  (((long)m_innerBuffer[i + Offset + 4]) << 32) |                  (((long)m_innerBuffer[i + Offset + 3]) << 24) |                  (((long)m_innerBuffer[i + Offset + 2]) << 16) |                  (((long)m_innerBuffer[i + Offset + 1]) << 8) |                  ((long)m_innerBuffer[i + Offset + 0]);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  return                      (((long)m_innerBuffer[i + Offset]) << 56) |                      (((long)m_innerBuffer[i + Offset + 1]) << 48) |                      (((long)m_innerBuffer[i + Offset + 2]) << 40) |                      (((long)m_innerBuffer[i + Offset + 3]) << 32) |                      (((long)m_innerBuffer[i + Offset + 4]) << 24) |                      (((long)m_innerBuffer[i + Offset + 5]) << 16) |                      (((long)m_innerBuffer[i + Offset + 6]) << 8) |                      ((long)m_innerBuffer[i + Offset + 7]);              }              else              {                  return                  (((long)m_innerBuffer[i + Offset + 7]) << 56) |                  (((long)m_innerBuffer[i + Offset + 6]) << 48) |                  (((long)m_innerBuffer[i + Offset + 5]) << 40) |                  (((long)m_innerBuffer[i + Offset + 4]) << 32) |                  (((long)m_innerBuffer[i + Offset + 3]) << 24) |                  (((long)m_innerBuffer[i + Offset + 2]) << 16) |                  (((long)m_innerBuffer[i + Offset + 1]) << 8) |                  ((long)m_innerBuffer[i + Offset + 0]);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetUnsignedLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  return                      (((ulong)m_innerBuffer[i + Offset]) << 56) |                      (((ulong)m_innerBuffer[i + Offset + 1]) << 48) |                      (((ulong)m_innerBuffer[i + Offset + 2]) << 40) |                      (((ulong)m_innerBuffer[i + Offset + 3]) << 32) |                      (((ulong)m_innerBuffer[i + Offset + 4]) << 24) |                      (((ulong)m_innerBuffer[i + Offset + 5]) << 16) |                      (((ulong)m_innerBuffer[i + Offset + 6]) << 8) |                      ((ulong)m_innerBuffer[i + Offset + 7]);              }              else              {                  return                  (((ulong)m_innerBuffer[i + Offset + 7]) << 56) |                  (((ulong)m_innerBuffer[i + Offset + 6]) << 48) |                  (((ulong)m_innerBuffer[i + Offset + 5]) << 40) |                  (((ulong)m_innerBuffer[i + Offset + 4]) << 32) |                  (((ulong)m_innerBuffer[i + Offset + 3]) << 24) |                  (((ulong)m_innerBuffer[i + Offset + 2]) << 16) |                  (((ulong)m_innerBuffer[i + Offset + 1]) << 8) |                  ((ulong)m_innerBuffer[i + Offset + 0]);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetUnsignedLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  return                      (((ulong)m_innerBuffer[i + Offset]) << 56) |                      (((ulong)m_innerBuffer[i + Offset + 1]) << 48) |                      (((ulong)m_innerBuffer[i + Offset + 2]) << 40) |                      (((ulong)m_innerBuffer[i + Offset + 3]) << 32) |                      (((ulong)m_innerBuffer[i + Offset + 4]) << 24) |                      (((ulong)m_innerBuffer[i + Offset + 5]) << 16) |                      (((ulong)m_innerBuffer[i + Offset + 6]) << 8) |                      ((ulong)m_innerBuffer[i + Offset + 7]);              }              else              {                  return                  (((ulong)m_innerBuffer[i + Offset + 7]) << 56) |                  (((ulong)m_innerBuffer[i + Offset + 6]) << 48) |                  (((ulong)m_innerBuffer[i + Offset + 5]) << 40) |                  (((ulong)m_innerBuffer[i + Offset + 4]) << 32) |                  (((ulong)m_innerBuffer[i + Offset + 3]) << 24) |                  (((ulong)m_innerBuffer[i + Offset + 2]) << 16) |                  (((ulong)m_innerBuffer[i + Offset + 1]) << 8) |                  ((ulong)m_innerBuffer[i + Offset + 0]);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetUnsignedLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  return                      (((ulong)m_innerBuffer[i + Offset]) << 56) |                      (((ulong)m_innerBuffer[i + Offset + 1]) << 48) |                      (((ulong)m_innerBuffer[i + Offset + 2]) << 40) |                      (((ulong)m_innerBuffer[i + Offset + 3]) << 32) |                      (((ulong)m_innerBuffer[i + Offset + 4]) << 24) |                      (((ulong)m_innerBuffer[i + Offset + 5]) << 16) |                      (((ulong)m_innerBuffer[i + Offset + 6]) << 8) |                      ((ulong)m_innerBuffer[i + Offset + 7]);              }              else              {                  return                  (((ulong)m_innerBuffer[i + Offset + 7]) << 56) |                  (((ulong)m_innerBuffer[i + Offset + 6]) << 48) |                  (((ulong)m_innerBuffer[i + Offset + 5]) << 40) |                  (((ulong)m_innerBuffer[i + Offset + 4]) << 32) |                  (((ulong)m_innerBuffer[i + Offset + 3]) << 24) |                  (((ulong)m_innerBuffer[i + Offset + 2]) << 16) |                  (((ulong)m_innerBuffer[i + Offset + 1]) << 8) |                  ((ulong)m_innerBuffer[i + Offset + 0]);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetUnsignedLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  return                      (((ulong)m_innerBuffer[i + Offset]) << 56) |                      (((ulong)m_innerBuffer[i + Offset + 1]) << 48) |                      (((ulong)m_innerBuffer[i + Offset + 2]) << 40) |                      (((ulong)m_innerBuffer[i + Offset + 3]) << 32) |                      (((ulong)m_innerBuffer[i + Offset + 4]) << 24) |                      (((ulong)m_innerBuffer[i + Offset + 5]) << 16) |                      (((ulong)m_innerBuffer[i + Offset + 6]) << 8) |                      ((ulong)m_innerBuffer[i + Offset + 7]);              }              else              {                  return                  (((ulong)m_innerBuffer[i + Offset + 7]) << 56) |                  (((ulong)m_innerBuffer[i + Offset + 6]) << 48) |                  (((ulong)m_innerBuffer[i + Offset + 5]) << 40) |                  (((ulong)m_innerBuffer[i + Offset + 4]) << 32) |                  (((ulong)m_innerBuffer[i + Offset + 3]) << 24) |                  (((ulong)m_innerBuffer[i + Offset + 2]) << 16) |                  (((ulong)m_innerBuffer[i + Offset + 1]) << 8) |                  ((ulong)m_innerBuffer[i + Offset + 0]);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetUnsignedLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  return                      (((ulong)m_innerBuffer[i + Offset]) << 56) |                      (((ulong)m_innerBuffer[i + Offset + 1]) << 48) |                      (((ulong)m_innerBuffer[i + Offset + 2]) << 40) |                      (((ulong)m_innerBuffer[i + Offset + 3]) << 32) |                      (((ulong)m_innerBuffer[i + Offset + 4]) << 24) |                      (((ulong)m_innerBuffer[i + Offset + 5]) << 16) |                      (((ulong)m_innerBuffer[i + Offset + 6]) << 8) |                      ((ulong)m_innerBuffer[i + Offset + 7]);              }              else              {                  return                  (((ulong)m_innerBuffer[i + Offset + 7]) << 56) |                  (((ulong)m_innerBuffer[i + Offset + 6]) << 48) |                  (((ulong)m_innerBuffer[i + Offset + 5]) << 40) |                  (((ulong)m_innerBuffer[i + Offset + 4]) << 32) |                  (((ulong)m_innerBuffer[i + Offset + 3]) << 24) |                  (((ulong)m_innerBuffer[i + Offset + 2]) << 16) |                  (((ulong)m_innerBuffer[i + Offset + 1]) << 8) |                  ((ulong)m_innerBuffer[i + Offset + 0]);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetUnsignedLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  return                      (((ulong)m_innerBuffer[i + Offset]) << 56) |                      (((ulong)m_innerBuffer[i + Offset + 1]) << 48) |                      (((ulong)m_innerBuffer[i + Offset + 2]) << 40) |                      (((ulong)m_innerBuffer[i + Offset + 3]) << 32) |                      (((ulong)m_innerBuffer[i + Offset + 4]) << 24) |                      (((ulong)m_innerBuffer[i + Offset + 5]) << 16) |                      (((ulong)m_innerBuffer[i + Offset + 6]) << 8) |                      ((ulong)m_innerBuffer[i + Offset + 7]);              }              else              {                  return                  (((ulong)m_innerBuffer[i + Offset + 7]) << 56) |                  (((ulong)m_innerBuffer[i + Offset + 6]) << 48) |                  (((ulong)m_innerBuffer[i + Offset + 5]) << 40) |                  (((ulong)m_innerBuffer[i + Offset + 4]) << 32) |                  (((ulong)m_innerBuffer[i + Offset + 3]) << 24) |                  (((ulong)m_innerBuffer[i + Offset + 2]) << 16) |                  (((ulong)m_innerBuffer[i + Offset + 1]) << 8) |                  ((ulong)m_innerBuffer[i + Offset + 0]);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetUnsignedLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  return                      (((ulong)m_innerBuffer[i + Offset]) << 56) |                      (((ulong)m_innerBuffer[i + Offset + 1]) << 48) |                      (((ulong)m_innerBuffer[i + Offset + 2]) << 40) |                      (((ulong)m_innerBuffer[i + Offset + 3]) << 32) |                      (((ulong)m_innerBuffer[i + Offset + 4]) << 24) |                      (((ulong)m_innerBuffer[i + Offset + 5]) << 16) |                      (((ulong)m_innerBuffer[i + Offset + 6]) << 8) |                      ((ulong)m_innerBuffer[i + Offset + 7]);              }              else              {                  return                  (((ulong)m_innerBuffer[i + Offset + 7]) << 56) |                  (((ulong)m_innerBuffer[i + Offset + 6]) << 48) |                  (((ulong)m_innerBuffer[i + Offset + 5]) << 40) |                  (((ulong)m_innerBuffer[i + Offset + 4]) << 32) |                  (((ulong)m_innerBuffer[i + Offset + 3]) << 24) |                  (((ulong)m_innerBuffer[i + Offset + 2]) << 16) |                  (((ulong)m_innerBuffer[i + Offset + 1]) << 8) |                  ((ulong)m_innerBuffer[i + Offset + 0]);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetUnsignedLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  return                      (((ulong)m_innerBuffer[i + Offset]) << 56) |                      (((ulong)m_innerBuffer[i + Offset + 1]) << 48) |                      (((ulong)m_innerBuffer[i + Offset + 2]) << 40) |                      (((ulong)m_innerBuffer[i + Offset + 3]) << 32) |                      (((ulong)m_innerBuffer[i + Offset + 4]) << 24) |                      (((ulong)m_innerBuffer[i + Offset + 5]) << 16) |                      (((ulong)m_innerBuffer[i + Offset + 6]) << 8) |                      ((ulong)m_innerBuffer[i + Offset + 7]);              }              else              {                  return                  (((ulong)m_innerBuffer[i + Offset + 7]) << 56) |                  (((ulong)m_innerBuffer[i + Offset + 6]) << 48) |                  (((ulong)m_innerBuffer[i + Offset + 5]) << 40) |                  (((ulong)m_innerBuffer[i + Offset + 4]) << 32) |                  (((ulong)m_innerBuffer[i + Offset + 3]) << 24) |                  (((ulong)m_innerBuffer[i + Offset + 2]) << 16) |                  (((ulong)m_innerBuffer[i + Offset + 1]) << 8) |                  ((ulong)m_innerBuffer[i + Offset + 0]);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetUnsignedLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  return                      (((ulong)m_innerBuffer[i + Offset]) << 56) |                      (((ulong)m_innerBuffer[i + Offset + 1]) << 48) |                      (((ulong)m_innerBuffer[i + Offset + 2]) << 40) |                      (((ulong)m_innerBuffer[i + Offset + 3]) << 32) |                      (((ulong)m_innerBuffer[i + Offset + 4]) << 24) |                      (((ulong)m_innerBuffer[i + Offset + 5]) << 16) |                      (((ulong)m_innerBuffer[i + Offset + 6]) << 8) |                      ((ulong)m_innerBuffer[i + Offset + 7]);              }              else              {                  return                  (((ulong)m_innerBuffer[i + Offset + 7]) << 56) |                  (((ulong)m_innerBuffer[i + Offset + 6]) << 48) |                  (((ulong)m_innerBuffer[i + Offset + 5]) << 40) |                  (((ulong)m_innerBuffer[i + Offset + 4]) << 32) |                  (((ulong)m_innerBuffer[i + Offset + 3]) << 24) |                  (((ulong)m_innerBuffer[i + Offset + 2]) << 16) |                  (((ulong)m_innerBuffer[i + Offset + 1]) << 8) |                  ((ulong)m_innerBuffer[i + Offset + 0]);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetUnsignedLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  return                      (((ulong)m_innerBuffer[i + Offset]) << 56) |                      (((ulong)m_innerBuffer[i + Offset + 1]) << 48) |                      (((ulong)m_innerBuffer[i + Offset + 2]) << 40) |                      (((ulong)m_innerBuffer[i + Offset + 3]) << 32) |                      (((ulong)m_innerBuffer[i + Offset + 4]) << 24) |                      (((ulong)m_innerBuffer[i + Offset + 5]) << 16) |                      (((ulong)m_innerBuffer[i + Offset + 6]) << 8) |                      ((ulong)m_innerBuffer[i + Offset + 7]);              }              else              {                  return                  (((ulong)m_innerBuffer[i + Offset + 7]) << 56) |                  (((ulong)m_innerBuffer[i + Offset + 6]) << 48) |                  (((ulong)m_innerBuffer[i + Offset + 5]) << 40) |                  (((ulong)m_innerBuffer[i + Offset + 4]) << 32) |                  (((ulong)m_innerBuffer[i + Offset + 3]) << 24) |                  (((ulong)m_innerBuffer[i + Offset + 2]) << 16) |                  (((ulong)m_innerBuffer[i + Offset + 1]) << 8) |                  ((ulong)m_innerBuffer[i + Offset + 0]);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetUnsignedLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  return                      (((ulong)m_innerBuffer[i + Offset]) << 56) |                      (((ulong)m_innerBuffer[i + Offset + 1]) << 48) |                      (((ulong)m_innerBuffer[i + Offset + 2]) << 40) |                      (((ulong)m_innerBuffer[i + Offset + 3]) << 32) |                      (((ulong)m_innerBuffer[i + Offset + 4]) << 24) |                      (((ulong)m_innerBuffer[i + Offset + 5]) << 16) |                      (((ulong)m_innerBuffer[i + Offset + 6]) << 8) |                      ((ulong)m_innerBuffer[i + Offset + 7]);              }              else              {                  return                  (((ulong)m_innerBuffer[i + Offset + 7]) << 56) |                  (((ulong)m_innerBuffer[i + Offset + 6]) << 48) |                  (((ulong)m_innerBuffer[i + Offset + 5]) << 40) |                  (((ulong)m_innerBuffer[i + Offset + 4]) << 32) |                  (((ulong)m_innerBuffer[i + Offset + 3]) << 24) |                  (((ulong)m_innerBuffer[i + Offset + 2]) << 16) |                  (((ulong)m_innerBuffer[i + Offset + 1]) << 8) |                  ((ulong)m_innerBuffer[i + Offset + 0]);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetUnsignedLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  return                      (((ulong)m_innerBuffer[i + Offset]) << 56) |                      (((ulong)m_innerBuffer[i + Offset + 1]) << 48) |                      (((ulong)m_innerBuffer[i + Offset + 2]) << 40) |                      (((ulong)m_innerBuffer[i + Offset + 3]) << 32) |                      (((ulong)m_innerBuffer[i + Offset + 4]) << 24) |                      (((ulong)m_innerBuffer[i + Offset + 5]) << 16) |                      (((ulong)m_innerBuffer[i + Offset + 6]) << 8) |                      ((ulong)m_innerBuffer[i + Offset + 7]);              }              else              {                  return                  (((ulong)m_innerBuffer[i + Offset + 7]) << 56) |                  (((ulong)m_innerBuffer[i + Offset + 6]) << 48) |                  (((ulong)m_innerBuffer[i + Offset + 5]) << 40) |                  (((ulong)m_innerBuffer[i + Offset + 4]) << 32) |                  (((ulong)m_innerBuffer[i + Offset + 3]) << 24) |                  (((ulong)m_innerBuffer[i + Offset + 2]) << 16) |                  (((ulong)m_innerBuffer[i + Offset + 1]) << 8) |                  ((ulong)m_innerBuffer[i + Offset + 0]);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetUnsignedLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  return                      (((ulong)m_innerBuffer[i + Offset]) << 56) |                      (((ulong)m_innerBuffer[i + Offset + 1]) << 48) |                      (((ulong)m_innerBuffer[i + Offset + 2]) << 40) |                      (((ulong)m_innerBuffer[i + Offset + 3]) << 32) |                      (((ulong)m_innerBuffer[i + Offset + 4]) << 24) |                      (((ulong)m_innerBuffer[i + Offset + 5]) << 16) |                      (((ulong)m_innerBuffer[i + Offset + 6]) << 8) |                      ((ulong)m_innerBuffer[i + Offset + 7]);              }              else              {                  return                  (((ulong)m_innerBuffer[i + Offset + 7]) << 56) |                  (((ulong)m_innerBuffer[i + Offset + 6]) << 48) |                  (((ulong)m_innerBuffer[i + Offset + 5]) << 40) |                  (((ulong)m_innerBuffer[i + Offset + 4]) << 32) |                  (((ulong)m_innerBuffer[i + Offset + 3]) << 24) |                  (((ulong)m_innerBuffer[i + Offset + 2]) << 16) |                  (((ulong)m_innerBuffer[i + Offset + 1]) << 8) |                  ((ulong)m_innerBuffer[i + Offset + 0]);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetUnsignedLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  return                      (((ulong)m_innerBuffer[i + Offset]) << 56) |                      (((ulong)m_innerBuffer[i + Offset + 1]) << 48) |                      (((ulong)m_innerBuffer[i + Offset + 2]) << 40) |                      (((ulong)m_innerBuffer[i + Offset + 3]) << 32) |                      (((ulong)m_innerBuffer[i + Offset + 4]) << 24) |                      (((ulong)m_innerBuffer[i + Offset + 5]) << 16) |                      (((ulong)m_innerBuffer[i + Offset + 6]) << 8) |                      ((ulong)m_innerBuffer[i + Offset + 7]);              }              else              {                  return                  (((ulong)m_innerBuffer[i + Offset + 7]) << 56) |                  (((ulong)m_innerBuffer[i + Offset + 6]) << 48) |                  (((ulong)m_innerBuffer[i + Offset + 5]) << 40) |                  (((ulong)m_innerBuffer[i + Offset + 4]) << 32) |                  (((ulong)m_innerBuffer[i + Offset + 3]) << 24) |                  (((ulong)m_innerBuffer[i + Offset + 2]) << 16) |                  (((ulong)m_innerBuffer[i + Offset + 1]) << 8) |                  ((ulong)m_innerBuffer[i + Offset + 0]);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetUnsignedLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  return                      (((ulong)m_innerBuffer[i + Offset]) << 56) |                      (((ulong)m_innerBuffer[i + Offset + 1]) << 48) |                      (((ulong)m_innerBuffer[i + Offset + 2]) << 40) |                      (((ulong)m_innerBuffer[i + Offset + 3]) << 32) |                      (((ulong)m_innerBuffer[i + Offset + 4]) << 24) |                      (((ulong)m_innerBuffer[i + Offset + 5]) << 16) |                      (((ulong)m_innerBuffer[i + Offset + 6]) << 8) |                      ((ulong)m_innerBuffer[i + Offset + 7]);              }              else              {                  return                  (((ulong)m_innerBuffer[i + Offset + 7]) << 56) |                  (((ulong)m_innerBuffer[i + Offset + 6]) << 48) |                  (((ulong)m_innerBuffer[i + Offset + 5]) << 40) |                  (((ulong)m_innerBuffer[i + Offset + 4]) << 32) |                  (((ulong)m_innerBuffer[i + Offset + 3]) << 24) |                  (((ulong)m_innerBuffer[i + Offset + 2]) << 16) |                  (((ulong)m_innerBuffer[i + Offset + 1]) << 8) |                  ((ulong)m_innerBuffer[i + Offset + 0]);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetUnsignedLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  return                      (((ulong)m_innerBuffer[i + Offset]) << 56) |                      (((ulong)m_innerBuffer[i + Offset + 1]) << 48) |                      (((ulong)m_innerBuffer[i + Offset + 2]) << 40) |                      (((ulong)m_innerBuffer[i + Offset + 3]) << 32) |                      (((ulong)m_innerBuffer[i + Offset + 4]) << 24) |                      (((ulong)m_innerBuffer[i + Offset + 5]) << 16) |                      (((ulong)m_innerBuffer[i + Offset + 6]) << 8) |                      ((ulong)m_innerBuffer[i + Offset + 7]);              }              else              {                  return                  (((ulong)m_innerBuffer[i + Offset + 7]) << 56) |                  (((ulong)m_innerBuffer[i + Offset + 6]) << 48) |                  (((ulong)m_innerBuffer[i + Offset + 5]) << 40) |                  (((ulong)m_innerBuffer[i + Offset + 4]) << 32) |                  (((ulong)m_innerBuffer[i + Offset + 3]) << 24) |                  (((ulong)m_innerBuffer[i + Offset + 2]) << 16) |                  (((ulong)m_innerBuffer[i + Offset + 1]) << 8) |                  ((ulong)m_innerBuffer[i + Offset + 0]);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetUnsignedLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  return                      (((ulong)m_innerBuffer[i + Offset]) << 56) |                      (((ulong)m_innerBuffer[i + Offset + 1]) << 48) |                      (((ulong)m_innerBuffer[i + Offset + 2]) << 40) |                      (((ulong)m_innerBuffer[i + Offset + 3]) << 32) |                      (((ulong)m_innerBuffer[i + Offset + 4]) << 24) |                      (((ulong)m_innerBuffer[i + Offset + 5]) << 16) |                      (((ulong)m_innerBuffer[i + Offset + 6]) << 8) |                      ((ulong)m_innerBuffer[i + Offset + 7]);              }              else              {                  return                  (((ulong)m_innerBuffer[i + Offset + 7]) << 56) |                  (((ulong)m_innerBuffer[i + Offset + 6]) << 48) |                  (((ulong)m_innerBuffer[i + Offset + 5]) << 40) |                  (((ulong)m_innerBuffer[i + Offset + 4]) << 32) |                  (((ulong)m_innerBuffer[i + Offset + 3]) << 24) |                  (((ulong)m_innerBuffer[i + Offset + 2]) << 16) |                  (((ulong)m_innerBuffer[i + Offset + 1]) << 8) |                  ((ulong)m_innerBuffer[i + Offset + 0]);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetUnsignedLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  return                      (((ulong)m_innerBuffer[i + Offset]) << 56) |                      (((ulong)m_innerBuffer[i + Offset + 1]) << 48) |                      (((ulong)m_innerBuffer[i + Offset + 2]) << 40) |                      (((ulong)m_innerBuffer[i + Offset + 3]) << 32) |                      (((ulong)m_innerBuffer[i + Offset + 4]) << 24) |                      (((ulong)m_innerBuffer[i + Offset + 5]) << 16) |                      (((ulong)m_innerBuffer[i + Offset + 6]) << 8) |                      ((ulong)m_innerBuffer[i + Offset + 7]);              }              else              {                  return                  (((ulong)m_innerBuffer[i + Offset + 7]) << 56) |                  (((ulong)m_innerBuffer[i + Offset + 6]) << 48) |                  (((ulong)m_innerBuffer[i + Offset + 5]) << 40) |                  (((ulong)m_innerBuffer[i + Offset + 4]) << 32) |                  (((ulong)m_innerBuffer[i + Offset + 3]) << 24) |                  (((ulong)m_innerBuffer[i + Offset + 2]) << 16) |                  (((ulong)m_innerBuffer[i + Offset + 1]) << 8) |                  ((ulong)m_innerBuffer[i + Offset + 0]);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetUnsignedLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  return                      (((ulong)m_innerBuffer[i + Offset]) << 56) |                      (((ulong)m_innerBuffer[i + Offset + 1]) << 48) |                      (((ulong)m_innerBuffer[i + Offset + 2]) << 40) |                      (((ulong)m_innerBuffer[i + Offset + 3]) << 32) |                      (((ulong)m_innerBuffer[i + Offset + 4]) << 24) |                      (((ulong)m_innerBuffer[i + Offset + 5]) << 16) |                      (((ulong)m_innerBuffer[i + Offset + 6]) << 8) |                      ((ulong)m_innerBuffer[i + Offset + 7]);              }              else              {                  return                  (((ulong)m_innerBuffer[i + Offset + 7]) << 56) |                  (((ulong)m_innerBuffer[i + Offset + 6]) << 48) |                  (((ulong)m_innerBuffer[i + Offset + 5]) << 40) |                  (((ulong)m_innerBuffer[i + Offset + 4]) << 32) |                  (((ulong)m_innerBuffer[i + Offset + 3]) << 24) |                  (((ulong)m_innerBuffer[i + Offset + 2]) << 16) |                  (((ulong)m_innerBuffer[i + Offset + 1]) << 8) |                  ((ulong)m_innerBuffer[i + Offset + 0]);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetUnsignedLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  return                      (((ulong)m_innerBuffer[i + Offset]) << 56) |                      (((ulong)m_innerBuffer[i + Offset + 1]) << 48) |                      (((ulong)m_innerBuffer[i + Offset + 2]) << 40) |                      (((ulong)m_innerBuffer[i + Offset + 3]) << 32) |                      (((ulong)m_innerBuffer[i + Offset + 4]) << 24) |                      (((ulong)m_innerBuffer[i + Offset + 5]) << 16) |                      (((ulong)m_innerBuffer[i + Offset + 6]) << 8) |                      ((ulong)m_innerBuffer[i + Offset + 7]);              }              else              {                  return                  (((ulong)m_innerBuffer[i + Offset + 7]) << 56) |                  (((ulong)m_innerBuffer[i + Offset + 6]) << 48) |                  (((ulong)m_innerBuffer[i + Offset + 5]) << 40) |                  (((ulong)m_innerBuffer[i + Offset + 4]) << 32) |                  (((ulong)m_innerBuffer[i + Offset + 3]) << 24) |                  (((ulong)m_innerBuffer[i + Offset + 2]) << 16) |                  (((ulong)m_innerBuffer[i + Offset + 1]) << 8) |                  ((ulong)m_innerBuffer[i + Offset + 0]);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetUnsignedLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  return                      (((ulong)m_innerBuffer[i + Offset]) << 56) |                      (((ulong)m_innerBuffer[i + Offset + 1]) << 48) |                      (((ulong)m_innerBuffer[i + Offset + 2]) << 40) |                      (((ulong)m_innerBuffer[i + Offset + 3]) << 32) |                      (((ulong)m_innerBuffer[i + Offset + 4]) << 24) |                      (((ulong)m_innerBuffer[i + Offset + 5]) << 16) |                      (((ulong)m_innerBuffer[i + Offset + 6]) << 8) |                      ((ulong)m_innerBuffer[i + Offset + 7]);              }              else              {                  return                  (((ulong)m_innerBuffer[i + Offset + 7]) << 56) |                  (((ulong)m_innerBuffer[i + Offset + 6]) << 48) |                  (((ulong)m_innerBuffer[i + Offset + 5]) << 40) |                  (((ulong)m_innerBuffer[i + Offset + 4]) << 32) |                  (((ulong)m_innerBuffer[i + Offset + 3]) << 24) |                  (((ulong)m_innerBuffer[i + Offset + 2]) << 16) |                  (((ulong)m_innerBuffer[i + Offset + 1]) << 8) |                  ((ulong)m_innerBuffer[i + Offset + 0]);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetUnsignedLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  return                      (((ulong)m_innerBuffer[i + Offset]) << 56) |                      (((ulong)m_innerBuffer[i + Offset + 1]) << 48) |                      (((ulong)m_innerBuffer[i + Offset + 2]) << 40) |                      (((ulong)m_innerBuffer[i + Offset + 3]) << 32) |                      (((ulong)m_innerBuffer[i + Offset + 4]) << 24) |                      (((ulong)m_innerBuffer[i + Offset + 5]) << 16) |                      (((ulong)m_innerBuffer[i + Offset + 6]) << 8) |                      ((ulong)m_innerBuffer[i + Offset + 7]);              }              else              {                  return                  (((ulong)m_innerBuffer[i + Offset + 7]) << 56) |                  (((ulong)m_innerBuffer[i + Offset + 6]) << 48) |                  (((ulong)m_innerBuffer[i + Offset + 5]) << 40) |                  (((ulong)m_innerBuffer[i + Offset + 4]) << 32) |                  (((ulong)m_innerBuffer[i + Offset + 3]) << 24) |                  (((ulong)m_innerBuffer[i + Offset + 2]) << 16) |                  (((ulong)m_innerBuffer[i + Offset + 1]) << 8) |                  ((ulong)m_innerBuffer[i + Offset + 0]);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetUnsignedLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  return                      (((ulong)m_innerBuffer[i + Offset]) << 56) |                      (((ulong)m_innerBuffer[i + Offset + 1]) << 48) |                      (((ulong)m_innerBuffer[i + Offset + 2]) << 40) |                      (((ulong)m_innerBuffer[i + Offset + 3]) << 32) |                      (((ulong)m_innerBuffer[i + Offset + 4]) << 24) |                      (((ulong)m_innerBuffer[i + Offset + 5]) << 16) |                      (((ulong)m_innerBuffer[i + Offset + 6]) << 8) |                      ((ulong)m_innerBuffer[i + Offset + 7]);              }              else              {                  return                  (((ulong)m_innerBuffer[i + Offset + 7]) << 56) |                  (((ulong)m_innerBuffer[i + Offset + 6]) << 48) |                  (((ulong)m_innerBuffer[i + Offset + 5]) << 40) |                  (((ulong)m_innerBuffer[i + Offset + 4]) << 32) |                  (((ulong)m_innerBuffer[i + Offset + 3]) << 24) |                  (((ulong)m_innerBuffer[i + Offset + 2]) << 16) |                  (((ulong)m_innerBuffer[i + Offset + 1]) << 8) |                  ((ulong)m_innerBuffer[i + Offset + 0]);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetUnsignedLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  return                      (((ulong)m_innerBuffer[i + Offset]) << 56) |                      (((ulong)m_innerBuffer[i + Offset + 1]) << 48) |                      (((ulong)m_innerBuffer[i + Offset + 2]) << 40) |                      (((ulong)m_innerBuffer[i + Offset + 3]) << 32) |                      (((ulong)m_innerBuffer[i + Offset + 4]) << 24) |                      (((ulong)m_innerBuffer[i + Offset + 5]) << 16) |                      (((ulong)m_innerBuffer[i + Offset + 6]) << 8) |                      ((ulong)m_innerBuffer[i + Offset + 7]);              }              else              {                  return                  (((ulong)m_innerBuffer[i + Offset + 7]) << 56) |                  (((ulong)m_innerBuffer[i + Offset + 6]) << 48) |                  (((ulong)m_innerBuffer[i + Offset + 5]) << 40) |                  (((ulong)m_innerBuffer[i + Offset + 4]) << 32) |                  (((ulong)m_innerBuffer[i + Offset + 3]) << 24) |                  (((ulong)m_innerBuffer[i + Offset + 2]) << 16) |                  (((ulong)m_innerBuffer[i + Offset + 1]) << 8) |                  ((ulong)m_innerBuffer[i + Offset + 0]);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetUnsignedLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  return                      (((ulong)m_innerBuffer[i + Offset]) << 56) |                      (((ulong)m_innerBuffer[i + Offset + 1]) << 48) |                      (((ulong)m_innerBuffer[i + Offset + 2]) << 40) |                      (((ulong)m_innerBuffer[i + Offset + 3]) << 32) |                      (((ulong)m_innerBuffer[i + Offset + 4]) << 24) |                      (((ulong)m_innerBuffer[i + Offset + 5]) << 16) |                      (((ulong)m_innerBuffer[i + Offset + 6]) << 8) |                      ((ulong)m_innerBuffer[i + Offset + 7]);              }              else              {                  return                  (((ulong)m_innerBuffer[i + Offset + 7]) << 56) |                  (((ulong)m_innerBuffer[i + Offset + 6]) << 48) |                  (((ulong)m_innerBuffer[i + Offset + 5]) << 40) |                  (((ulong)m_innerBuffer[i + Offset + 4]) << 32) |                  (((ulong)m_innerBuffer[i + Offset + 3]) << 24) |                  (((ulong)m_innerBuffer[i + Offset + 2]) << 16) |                  (((ulong)m_innerBuffer[i + Offset + 1]) << 8) |                  ((ulong)m_innerBuffer[i + Offset + 0]);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetUnsignedLong,The following statement contains a magic number: if (endian == Endianness.Big)              {                  return                      (((ulong)m_innerBuffer[i + Offset]) << 56) |                      (((ulong)m_innerBuffer[i + Offset + 1]) << 48) |                      (((ulong)m_innerBuffer[i + Offset + 2]) << 40) |                      (((ulong)m_innerBuffer[i + Offset + 3]) << 32) |                      (((ulong)m_innerBuffer[i + Offset + 4]) << 24) |                      (((ulong)m_innerBuffer[i + Offset + 5]) << 16) |                      (((ulong)m_innerBuffer[i + Offset + 6]) << 8) |                      ((ulong)m_innerBuffer[i + Offset + 7]);              }              else              {                  return                  (((ulong)m_innerBuffer[i + Offset + 7]) << 56) |                  (((ulong)m_innerBuffer[i + Offset + 6]) << 48) |                  (((ulong)m_innerBuffer[i + Offset + 5]) << 40) |                  (((ulong)m_innerBuffer[i + Offset + 4]) << 32) |                  (((ulong)m_innerBuffer[i + Offset + 3]) << 24) |                  (((ulong)m_innerBuffer[i + Offset + 2]) << 16) |                  (((ulong)m_innerBuffer[i + Offset + 1]) << 8) |                  ((ulong)m_innerBuffer[i + Offset + 0]);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetInteger,The following statement contains a magic number: if (endian == Endianness.Big)              {                  return                       ((m_innerBuffer[i + Offset]) << 24) |                       ((m_innerBuffer[i + Offset + 1]) << 16) |                       ((m_innerBuffer[i + Offset + 2]) << 8) |                       (m_innerBuffer[i + Offset + 3]);              }              else              {                  return                       ((m_innerBuffer[i + Offset + 3]) << 24) |                       ((m_innerBuffer[i + Offset + 2]) << 16) |                       ((m_innerBuffer[i + Offset + 1]) << 8) |                       (m_innerBuffer[i + Offset]);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetInteger,The following statement contains a magic number: if (endian == Endianness.Big)              {                  return                       ((m_innerBuffer[i + Offset]) << 24) |                       ((m_innerBuffer[i + Offset + 1]) << 16) |                       ((m_innerBuffer[i + Offset + 2]) << 8) |                       (m_innerBuffer[i + Offset + 3]);              }              else              {                  return                       ((m_innerBuffer[i + Offset + 3]) << 24) |                       ((m_innerBuffer[i + Offset + 2]) << 16) |                       ((m_innerBuffer[i + Offset + 1]) << 8) |                       (m_innerBuffer[i + Offset]);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetInteger,The following statement contains a magic number: if (endian == Endianness.Big)              {                  return                       ((m_innerBuffer[i + Offset]) << 24) |                       ((m_innerBuffer[i + Offset + 1]) << 16) |                       ((m_innerBuffer[i + Offset + 2]) << 8) |                       (m_innerBuffer[i + Offset + 3]);              }              else              {                  return                       ((m_innerBuffer[i + Offset + 3]) << 24) |                       ((m_innerBuffer[i + Offset + 2]) << 16) |                       ((m_innerBuffer[i + Offset + 1]) << 8) |                       (m_innerBuffer[i + Offset]);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetInteger,The following statement contains a magic number: if (endian == Endianness.Big)              {                  return                       ((m_innerBuffer[i + Offset]) << 24) |                       ((m_innerBuffer[i + Offset + 1]) << 16) |                       ((m_innerBuffer[i + Offset + 2]) << 8) |                       (m_innerBuffer[i + Offset + 3]);              }              else              {                  return                       ((m_innerBuffer[i + Offset + 3]) << 24) |                       ((m_innerBuffer[i + Offset + 2]) << 16) |                       ((m_innerBuffer[i + Offset + 1]) << 8) |                       (m_innerBuffer[i + Offset]);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetInteger,The following statement contains a magic number: if (endian == Endianness.Big)              {                  return                       ((m_innerBuffer[i + Offset]) << 24) |                       ((m_innerBuffer[i + Offset + 1]) << 16) |                       ((m_innerBuffer[i + Offset + 2]) << 8) |                       (m_innerBuffer[i + Offset + 3]);              }              else              {                  return                       ((m_innerBuffer[i + Offset + 3]) << 24) |                       ((m_innerBuffer[i + Offset + 2]) << 16) |                       ((m_innerBuffer[i + Offset + 1]) << 8) |                       (m_innerBuffer[i + Offset]);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetInteger,The following statement contains a magic number: if (endian == Endianness.Big)              {                  return                       ((m_innerBuffer[i + Offset]) << 24) |                       ((m_innerBuffer[i + Offset + 1]) << 16) |                       ((m_innerBuffer[i + Offset + 2]) << 8) |                       (m_innerBuffer[i + Offset + 3]);              }              else              {                  return                       ((m_innerBuffer[i + Offset + 3]) << 24) |                       ((m_innerBuffer[i + Offset + 2]) << 16) |                       ((m_innerBuffer[i + Offset + 1]) << 8) |                       (m_innerBuffer[i + Offset]);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetInteger,The following statement contains a magic number: if (endian == Endianness.Big)              {                  return                       ((m_innerBuffer[i + Offset]) << 24) |                       ((m_innerBuffer[i + Offset + 1]) << 16) |                       ((m_innerBuffer[i + Offset + 2]) << 8) |                       (m_innerBuffer[i + Offset + 3]);              }              else              {                  return                       ((m_innerBuffer[i + Offset + 3]) << 24) |                       ((m_innerBuffer[i + Offset + 2]) << 16) |                       ((m_innerBuffer[i + Offset + 1]) << 8) |                       (m_innerBuffer[i + Offset]);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetInteger,The following statement contains a magic number: if (endian == Endianness.Big)              {                  return                       ((m_innerBuffer[i + Offset]) << 24) |                       ((m_innerBuffer[i + Offset + 1]) << 16) |                       ((m_innerBuffer[i + Offset + 2]) << 8) |                       (m_innerBuffer[i + Offset + 3]);              }              else              {                  return                       ((m_innerBuffer[i + Offset + 3]) << 24) |                       ((m_innerBuffer[i + Offset + 2]) << 16) |                       ((m_innerBuffer[i + Offset + 1]) << 8) |                       (m_innerBuffer[i + Offset]);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetInteger,The following statement contains a magic number: if (endian == Endianness.Big)              {                  return                       ((m_innerBuffer[i + Offset]) << 24) |                       ((m_innerBuffer[i + Offset + 1]) << 16) |                       ((m_innerBuffer[i + Offset + 2]) << 8) |                       (m_innerBuffer[i + Offset + 3]);              }              else              {                  return                       ((m_innerBuffer[i + Offset + 3]) << 24) |                       ((m_innerBuffer[i + Offset + 2]) << 16) |                       ((m_innerBuffer[i + Offset + 1]) << 8) |                       (m_innerBuffer[i + Offset]);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetInteger,The following statement contains a magic number: if (endian == Endianness.Big)              {                  return                       ((m_innerBuffer[i + Offset]) << 24) |                       ((m_innerBuffer[i + Offset + 1]) << 16) |                       ((m_innerBuffer[i + Offset + 2]) << 8) |                       (m_innerBuffer[i + Offset + 3]);              }              else              {                  return                       ((m_innerBuffer[i + Offset + 3]) << 24) |                       ((m_innerBuffer[i + Offset + 2]) << 16) |                       ((m_innerBuffer[i + Offset + 1]) << 8) |                       (m_innerBuffer[i + Offset]);              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetUnsignedShort,The following statement contains a magic number: if (endian == Endianness.Big)              {                  return (ushort)(((m_innerBuffer[i + Offset]) << 8) |                       (m_innerBuffer[i + Offset + 1]));              }              else              {                  return (ushort)(((m_innerBuffer[i + Offset + 1]) << 8) |                      (m_innerBuffer[i + Offset]));              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetUnsignedShort,The following statement contains a magic number: if (endian == Endianness.Big)              {                  return (ushort)(((m_innerBuffer[i + Offset]) << 8) |                       (m_innerBuffer[i + Offset + 1]));              }              else              {                  return (ushort)(((m_innerBuffer[i + Offset + 1]) << 8) |                      (m_innerBuffer[i + Offset]));              }
Magic Number,NetMQ.Core.Transports,ByteArraySegment,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\ByteArraySegment.cs,GetHashCode,The following statement contains a magic number: int value = m_innerBuffer.GetHashCode()*27;
Magic Number,NetMQ.Core.Transports,StreamEngine,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\StreamEngine.cs,HandleHandshake,The following statement contains a magic number: switch (m_handshakeState)              {                  case HandshakeState.Closed:                      switch (action)                      {                          case Action.Start:                              // Send the 'length' and 'flags' fields of the identity message.                              // The 'length' field is encoded in the long format.                                m_greetingOutputBuffer[m_outsize++] = 0xff;                              m_greetingOutputBuffer.PutLong(m_options.Endian' (long)m_options.IdentitySize + 1' 1);                              m_outsize += 8;                              m_greetingOutputBuffer[m_outsize++] = 0x7f;                                m_outpos = new ByteArraySegment(m_greetingOutputBuffer);                                m_handshakeState = HandshakeState.SendingGreeting;                                BeginWrite(m_outpos' m_outsize);                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  case HandshakeState.SendingGreeting:                      switch (action)                      {                          case Action.OutCompleted:                              bytesSent = EndWrite(socketError' bytesTransferred);                                if (bytesSent == -1)                              {                                  Error();                              }                              else                              {                                  m_outpos.AdvanceOffset(bytesSent);                                  m_outsize -= bytesSent;                                    if (m_outsize > 0)                                  {                                      BeginWrite(m_outpos' m_outsize);                                  }                                  else                                  {                                      m_greetingBytesRead = 0;                                        var greetingSegment = new ByteArraySegment(m_greeting' m_greetingBytesRead);                                        m_handshakeState = HandshakeState.ReceivingGreeting;                                        BeginRead(greetingSegment' PreambleSize);                                  }                              }                              break;                          case Action.ActivateIn:                          case Action.ActivateOut:                              // nothing to do                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  case HandshakeState.ReceivingGreeting:                      switch (action)                      {                          case Action.InCompleted:                              bytesReceived = EndRead(socketError' bytesTransferred);                                if (bytesReceived == -1)                              {                                  Error();                              }                              else                              {                                  m_greetingBytesRead += bytesReceived;                                    // check if it is an unversioned protocol                                  if (m_greeting[0] != 0xff || (m_greetingBytesRead == 10 && (m_greeting[9] & 0x01) == 0))                                  {                                      m_encoder = new V1Encoder(Config.OutBatchSize' m_options.Endian);                                      m_encoder.SetMsgSource(m_session);                                        m_decoder = new V1Decoder(Config.InBatchSize' m_options.MaxMessageSize' m_options.Endian);                                      m_decoder.SetMsgSink(m_session);                                        // We have already sent the message header.                                      // Since there is no way to tell the encoder to                                      // skip the message header' we simply throw that                                      // header data away.                                      int headerSize = m_options.IdentitySize + 1 >= 255 ? 10 : 2;                                      var tmp = new byte[10];                                      var bufferp = new ByteArraySegment(tmp);                                        int bufferSize = headerSize;                                        m_encoder.GetData(ref bufferp' ref bufferSize);                                        Debug.Assert(bufferSize == headerSize);                                        // Make sure the decoder sees the data we have already received.                                      m_inpos = new ByteArraySegment(m_greeting);                                      m_insize = m_greetingBytesRead;                                        // To allow for interoperability with peers that do not forward                                      // their subscriptions' we inject a phony subscription                                      // message into the incoming message stream. To put this                                      // message right after the identity message' we temporarily                                      // divert the message stream from session to ourselves.                                      if (m_options.SocketType == ZmqSocketType.Pub || m_options.SocketType == ZmqSocketType.Xpub)                                          m_decoder.SetMsgSink(this);                                        // handshake is done                                      Activate();                                  }                                  else if (m_greetingBytesRead < 10)                                  {                                      var greetingSegment = new ByteArraySegment(m_greeting' m_greetingBytesRead);                                      BeginRead(greetingSegment' PreambleSize - m_greetingBytesRead);                                  }                                  else                                  {                                      // The peer is using versioned protocol.                                      // Send the rest of the greeting.                                      m_outpos[m_outsize++] = 1; // Protocol version                                      m_outpos[m_outsize++] = (byte)m_options.SocketType;                                        m_handshakeState = HandshakeState.SendingRestOfGreeting;                                        BeginWrite(m_outpos' m_outsize);                                  }                              }                              break;                          case Action.ActivateIn:                          case Action.ActivateOut:                              // nothing to do                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  case HandshakeState.SendingRestOfGreeting:                      switch (action)                      {                          case Action.OutCompleted:                              bytesSent = EndWrite(socketError' bytesTransferred);                                if (bytesSent == -1)                              {                                  Error();                              }                              else                              {                                  m_outpos.AdvanceOffset(bytesSent);                                  m_outsize -= bytesSent;                                    if (m_outsize > 0)                                  {                                      BeginWrite(m_outpos' m_outsize);                                  }                                  else                                  {                                      var greetingSegment = new ByteArraySegment(m_greeting' m_greetingBytesRead);                                        m_handshakeState = HandshakeState.ReceivingRestOfGreeting;                                      BeginRead(greetingSegment' GreetingSize - m_greetingBytesRead);                                  }                              }                              break;                          case Action.ActivateIn:                          case Action.ActivateOut:                              // nothing to do                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  case HandshakeState.ReceivingRestOfGreeting:                      switch (action)                      {                          case Action.InCompleted:                              bytesReceived = EndRead(socketError' bytesTransferred);                                if (bytesReceived == -1)                              {                                  Error();                              }                              else                              {                                  m_greetingBytesRead += bytesReceived;                                    if (m_greetingBytesRead < GreetingSize)                                  {                                      var greetingSegment = new ByteArraySegment(m_greeting' m_greetingBytesRead);                                      BeginRead(greetingSegment' GreetingSize - m_greetingBytesRead);                                  }                                  else                                  {                                      if (m_greeting[VersionPos] == 0)                                      {                                          // ZMTP/1.0 framing.                                          m_encoder = new V1Encoder(Config.OutBatchSize' m_options.Endian);                                          m_encoder.SetMsgSource(m_session);                                            m_decoder = new V1Decoder(Config.InBatchSize' m_options.MaxMessageSize' m_options.Endian);                                          m_decoder.SetMsgSink(m_session);                                      }                                      else                                      {                                          // v1 framing protocol.                                          m_encoder = new V2Encoder(Config.OutBatchSize' m_session' m_options.Endian);                                          m_decoder = new V2Decoder(Config.InBatchSize' m_options.MaxMessageSize' m_session' m_options.Endian);                                      }                                        // handshake is done                                      Activate();                                  }                              }                              break;                          case Action.ActivateIn:                          case Action.ActivateOut:                              // nothing to do                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  default:                      Debug.Assert(false);                      break;              }
Magic Number,NetMQ.Core.Transports,StreamEngine,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\StreamEngine.cs,HandleHandshake,The following statement contains a magic number: switch (m_handshakeState)              {                  case HandshakeState.Closed:                      switch (action)                      {                          case Action.Start:                              // Send the 'length' and 'flags' fields of the identity message.                              // The 'length' field is encoded in the long format.                                m_greetingOutputBuffer[m_outsize++] = 0xff;                              m_greetingOutputBuffer.PutLong(m_options.Endian' (long)m_options.IdentitySize + 1' 1);                              m_outsize += 8;                              m_greetingOutputBuffer[m_outsize++] = 0x7f;                                m_outpos = new ByteArraySegment(m_greetingOutputBuffer);                                m_handshakeState = HandshakeState.SendingGreeting;                                BeginWrite(m_outpos' m_outsize);                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  case HandshakeState.SendingGreeting:                      switch (action)                      {                          case Action.OutCompleted:                              bytesSent = EndWrite(socketError' bytesTransferred);                                if (bytesSent == -1)                              {                                  Error();                              }                              else                              {                                  m_outpos.AdvanceOffset(bytesSent);                                  m_outsize -= bytesSent;                                    if (m_outsize > 0)                                  {                                      BeginWrite(m_outpos' m_outsize);                                  }                                  else                                  {                                      m_greetingBytesRead = 0;                                        var greetingSegment = new ByteArraySegment(m_greeting' m_greetingBytesRead);                                        m_handshakeState = HandshakeState.ReceivingGreeting;                                        BeginRead(greetingSegment' PreambleSize);                                  }                              }                              break;                          case Action.ActivateIn:                          case Action.ActivateOut:                              // nothing to do                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  case HandshakeState.ReceivingGreeting:                      switch (action)                      {                          case Action.InCompleted:                              bytesReceived = EndRead(socketError' bytesTransferred);                                if (bytesReceived == -1)                              {                                  Error();                              }                              else                              {                                  m_greetingBytesRead += bytesReceived;                                    // check if it is an unversioned protocol                                  if (m_greeting[0] != 0xff || (m_greetingBytesRead == 10 && (m_greeting[9] & 0x01) == 0))                                  {                                      m_encoder = new V1Encoder(Config.OutBatchSize' m_options.Endian);                                      m_encoder.SetMsgSource(m_session);                                        m_decoder = new V1Decoder(Config.InBatchSize' m_options.MaxMessageSize' m_options.Endian);                                      m_decoder.SetMsgSink(m_session);                                        // We have already sent the message header.                                      // Since there is no way to tell the encoder to                                      // skip the message header' we simply throw that                                      // header data away.                                      int headerSize = m_options.IdentitySize + 1 >= 255 ? 10 : 2;                                      var tmp = new byte[10];                                      var bufferp = new ByteArraySegment(tmp);                                        int bufferSize = headerSize;                                        m_encoder.GetData(ref bufferp' ref bufferSize);                                        Debug.Assert(bufferSize == headerSize);                                        // Make sure the decoder sees the data we have already received.                                      m_inpos = new ByteArraySegment(m_greeting);                                      m_insize = m_greetingBytesRead;                                        // To allow for interoperability with peers that do not forward                                      // their subscriptions' we inject a phony subscription                                      // message into the incoming message stream. To put this                                      // message right after the identity message' we temporarily                                      // divert the message stream from session to ourselves.                                      if (m_options.SocketType == ZmqSocketType.Pub || m_options.SocketType == ZmqSocketType.Xpub)                                          m_decoder.SetMsgSink(this);                                        // handshake is done                                      Activate();                                  }                                  else if (m_greetingBytesRead < 10)                                  {                                      var greetingSegment = new ByteArraySegment(m_greeting' m_greetingBytesRead);                                      BeginRead(greetingSegment' PreambleSize - m_greetingBytesRead);                                  }                                  else                                  {                                      // The peer is using versioned protocol.                                      // Send the rest of the greeting.                                      m_outpos[m_outsize++] = 1; // Protocol version                                      m_outpos[m_outsize++] = (byte)m_options.SocketType;                                        m_handshakeState = HandshakeState.SendingRestOfGreeting;                                        BeginWrite(m_outpos' m_outsize);                                  }                              }                              break;                          case Action.ActivateIn:                          case Action.ActivateOut:                              // nothing to do                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  case HandshakeState.SendingRestOfGreeting:                      switch (action)                      {                          case Action.OutCompleted:                              bytesSent = EndWrite(socketError' bytesTransferred);                                if (bytesSent == -1)                              {                                  Error();                              }                              else                              {                                  m_outpos.AdvanceOffset(bytesSent);                                  m_outsize -= bytesSent;                                    if (m_outsize > 0)                                  {                                      BeginWrite(m_outpos' m_outsize);                                  }                                  else                                  {                                      var greetingSegment = new ByteArraySegment(m_greeting' m_greetingBytesRead);                                        m_handshakeState = HandshakeState.ReceivingRestOfGreeting;                                      BeginRead(greetingSegment' GreetingSize - m_greetingBytesRead);                                  }                              }                              break;                          case Action.ActivateIn:                          case Action.ActivateOut:                              // nothing to do                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  case HandshakeState.ReceivingRestOfGreeting:                      switch (action)                      {                          case Action.InCompleted:                              bytesReceived = EndRead(socketError' bytesTransferred);                                if (bytesReceived == -1)                              {                                  Error();                              }                              else                              {                                  m_greetingBytesRead += bytesReceived;                                    if (m_greetingBytesRead < GreetingSize)                                  {                                      var greetingSegment = new ByteArraySegment(m_greeting' m_greetingBytesRead);                                      BeginRead(greetingSegment' GreetingSize - m_greetingBytesRead);                                  }                                  else                                  {                                      if (m_greeting[VersionPos] == 0)                                      {                                          // ZMTP/1.0 framing.                                          m_encoder = new V1Encoder(Config.OutBatchSize' m_options.Endian);                                          m_encoder.SetMsgSource(m_session);                                            m_decoder = new V1Decoder(Config.InBatchSize' m_options.MaxMessageSize' m_options.Endian);                                          m_decoder.SetMsgSink(m_session);                                      }                                      else                                      {                                          // v1 framing protocol.                                          m_encoder = new V2Encoder(Config.OutBatchSize' m_session' m_options.Endian);                                          m_decoder = new V2Decoder(Config.InBatchSize' m_options.MaxMessageSize' m_session' m_options.Endian);                                      }                                        // handshake is done                                      Activate();                                  }                              }                              break;                          case Action.ActivateIn:                          case Action.ActivateOut:                              // nothing to do                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  default:                      Debug.Assert(false);                      break;              }
Magic Number,NetMQ.Core.Transports,StreamEngine,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\StreamEngine.cs,HandleHandshake,The following statement contains a magic number: switch (m_handshakeState)              {                  case HandshakeState.Closed:                      switch (action)                      {                          case Action.Start:                              // Send the 'length' and 'flags' fields of the identity message.                              // The 'length' field is encoded in the long format.                                m_greetingOutputBuffer[m_outsize++] = 0xff;                              m_greetingOutputBuffer.PutLong(m_options.Endian' (long)m_options.IdentitySize + 1' 1);                              m_outsize += 8;                              m_greetingOutputBuffer[m_outsize++] = 0x7f;                                m_outpos = new ByteArraySegment(m_greetingOutputBuffer);                                m_handshakeState = HandshakeState.SendingGreeting;                                BeginWrite(m_outpos' m_outsize);                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  case HandshakeState.SendingGreeting:                      switch (action)                      {                          case Action.OutCompleted:                              bytesSent = EndWrite(socketError' bytesTransferred);                                if (bytesSent == -1)                              {                                  Error();                              }                              else                              {                                  m_outpos.AdvanceOffset(bytesSent);                                  m_outsize -= bytesSent;                                    if (m_outsize > 0)                                  {                                      BeginWrite(m_outpos' m_outsize);                                  }                                  else                                  {                                      m_greetingBytesRead = 0;                                        var greetingSegment = new ByteArraySegment(m_greeting' m_greetingBytesRead);                                        m_handshakeState = HandshakeState.ReceivingGreeting;                                        BeginRead(greetingSegment' PreambleSize);                                  }                              }                              break;                          case Action.ActivateIn:                          case Action.ActivateOut:                              // nothing to do                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  case HandshakeState.ReceivingGreeting:                      switch (action)                      {                          case Action.InCompleted:                              bytesReceived = EndRead(socketError' bytesTransferred);                                if (bytesReceived == -1)                              {                                  Error();                              }                              else                              {                                  m_greetingBytesRead += bytesReceived;                                    // check if it is an unversioned protocol                                  if (m_greeting[0] != 0xff || (m_greetingBytesRead == 10 && (m_greeting[9] & 0x01) == 0))                                  {                                      m_encoder = new V1Encoder(Config.OutBatchSize' m_options.Endian);                                      m_encoder.SetMsgSource(m_session);                                        m_decoder = new V1Decoder(Config.InBatchSize' m_options.MaxMessageSize' m_options.Endian);                                      m_decoder.SetMsgSink(m_session);                                        // We have already sent the message header.                                      // Since there is no way to tell the encoder to                                      // skip the message header' we simply throw that                                      // header data away.                                      int headerSize = m_options.IdentitySize + 1 >= 255 ? 10 : 2;                                      var tmp = new byte[10];                                      var bufferp = new ByteArraySegment(tmp);                                        int bufferSize = headerSize;                                        m_encoder.GetData(ref bufferp' ref bufferSize);                                        Debug.Assert(bufferSize == headerSize);                                        // Make sure the decoder sees the data we have already received.                                      m_inpos = new ByteArraySegment(m_greeting);                                      m_insize = m_greetingBytesRead;                                        // To allow for interoperability with peers that do not forward                                      // their subscriptions' we inject a phony subscription                                      // message into the incoming message stream. To put this                                      // message right after the identity message' we temporarily                                      // divert the message stream from session to ourselves.                                      if (m_options.SocketType == ZmqSocketType.Pub || m_options.SocketType == ZmqSocketType.Xpub)                                          m_decoder.SetMsgSink(this);                                        // handshake is done                                      Activate();                                  }                                  else if (m_greetingBytesRead < 10)                                  {                                      var greetingSegment = new ByteArraySegment(m_greeting' m_greetingBytesRead);                                      BeginRead(greetingSegment' PreambleSize - m_greetingBytesRead);                                  }                                  else                                  {                                      // The peer is using versioned protocol.                                      // Send the rest of the greeting.                                      m_outpos[m_outsize++] = 1; // Protocol version                                      m_outpos[m_outsize++] = (byte)m_options.SocketType;                                        m_handshakeState = HandshakeState.SendingRestOfGreeting;                                        BeginWrite(m_outpos' m_outsize);                                  }                              }                              break;                          case Action.ActivateIn:                          case Action.ActivateOut:                              // nothing to do                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  case HandshakeState.SendingRestOfGreeting:                      switch (action)                      {                          case Action.OutCompleted:                              bytesSent = EndWrite(socketError' bytesTransferred);                                if (bytesSent == -1)                              {                                  Error();                              }                              else                              {                                  m_outpos.AdvanceOffset(bytesSent);                                  m_outsize -= bytesSent;                                    if (m_outsize > 0)                                  {                                      BeginWrite(m_outpos' m_outsize);                                  }                                  else                                  {                                      var greetingSegment = new ByteArraySegment(m_greeting' m_greetingBytesRead);                                        m_handshakeState = HandshakeState.ReceivingRestOfGreeting;                                      BeginRead(greetingSegment' GreetingSize - m_greetingBytesRead);                                  }                              }                              break;                          case Action.ActivateIn:                          case Action.ActivateOut:                              // nothing to do                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  case HandshakeState.ReceivingRestOfGreeting:                      switch (action)                      {                          case Action.InCompleted:                              bytesReceived = EndRead(socketError' bytesTransferred);                                if (bytesReceived == -1)                              {                                  Error();                              }                              else                              {                                  m_greetingBytesRead += bytesReceived;                                    if (m_greetingBytesRead < GreetingSize)                                  {                                      var greetingSegment = new ByteArraySegment(m_greeting' m_greetingBytesRead);                                      BeginRead(greetingSegment' GreetingSize - m_greetingBytesRead);                                  }                                  else                                  {                                      if (m_greeting[VersionPos] == 0)                                      {                                          // ZMTP/1.0 framing.                                          m_encoder = new V1Encoder(Config.OutBatchSize' m_options.Endian);                                          m_encoder.SetMsgSource(m_session);                                            m_decoder = new V1Decoder(Config.InBatchSize' m_options.MaxMessageSize' m_options.Endian);                                          m_decoder.SetMsgSink(m_session);                                      }                                      else                                      {                                          // v1 framing protocol.                                          m_encoder = new V2Encoder(Config.OutBatchSize' m_session' m_options.Endian);                                          m_decoder = new V2Decoder(Config.InBatchSize' m_options.MaxMessageSize' m_session' m_options.Endian);                                      }                                        // handshake is done                                      Activate();                                  }                              }                              break;                          case Action.ActivateIn:                          case Action.ActivateOut:                              // nothing to do                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  default:                      Debug.Assert(false);                      break;              }
Magic Number,NetMQ.Core.Transports,StreamEngine,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\StreamEngine.cs,HandleHandshake,The following statement contains a magic number: switch (m_handshakeState)              {                  case HandshakeState.Closed:                      switch (action)                      {                          case Action.Start:                              // Send the 'length' and 'flags' fields of the identity message.                              // The 'length' field is encoded in the long format.                                m_greetingOutputBuffer[m_outsize++] = 0xff;                              m_greetingOutputBuffer.PutLong(m_options.Endian' (long)m_options.IdentitySize + 1' 1);                              m_outsize += 8;                              m_greetingOutputBuffer[m_outsize++] = 0x7f;                                m_outpos = new ByteArraySegment(m_greetingOutputBuffer);                                m_handshakeState = HandshakeState.SendingGreeting;                                BeginWrite(m_outpos' m_outsize);                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  case HandshakeState.SendingGreeting:                      switch (action)                      {                          case Action.OutCompleted:                              bytesSent = EndWrite(socketError' bytesTransferred);                                if (bytesSent == -1)                              {                                  Error();                              }                              else                              {                                  m_outpos.AdvanceOffset(bytesSent);                                  m_outsize -= bytesSent;                                    if (m_outsize > 0)                                  {                                      BeginWrite(m_outpos' m_outsize);                                  }                                  else                                  {                                      m_greetingBytesRead = 0;                                        var greetingSegment = new ByteArraySegment(m_greeting' m_greetingBytesRead);                                        m_handshakeState = HandshakeState.ReceivingGreeting;                                        BeginRead(greetingSegment' PreambleSize);                                  }                              }                              break;                          case Action.ActivateIn:                          case Action.ActivateOut:                              // nothing to do                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  case HandshakeState.ReceivingGreeting:                      switch (action)                      {                          case Action.InCompleted:                              bytesReceived = EndRead(socketError' bytesTransferred);                                if (bytesReceived == -1)                              {                                  Error();                              }                              else                              {                                  m_greetingBytesRead += bytesReceived;                                    // check if it is an unversioned protocol                                  if (m_greeting[0] != 0xff || (m_greetingBytesRead == 10 && (m_greeting[9] & 0x01) == 0))                                  {                                      m_encoder = new V1Encoder(Config.OutBatchSize' m_options.Endian);                                      m_encoder.SetMsgSource(m_session);                                        m_decoder = new V1Decoder(Config.InBatchSize' m_options.MaxMessageSize' m_options.Endian);                                      m_decoder.SetMsgSink(m_session);                                        // We have already sent the message header.                                      // Since there is no way to tell the encoder to                                      // skip the message header' we simply throw that                                      // header data away.                                      int headerSize = m_options.IdentitySize + 1 >= 255 ? 10 : 2;                                      var tmp = new byte[10];                                      var bufferp = new ByteArraySegment(tmp);                                        int bufferSize = headerSize;                                        m_encoder.GetData(ref bufferp' ref bufferSize);                                        Debug.Assert(bufferSize == headerSize);                                        // Make sure the decoder sees the data we have already received.                                      m_inpos = new ByteArraySegment(m_greeting);                                      m_insize = m_greetingBytesRead;                                        // To allow for interoperability with peers that do not forward                                      // their subscriptions' we inject a phony subscription                                      // message into the incoming message stream. To put this                                      // message right after the identity message' we temporarily                                      // divert the message stream from session to ourselves.                                      if (m_options.SocketType == ZmqSocketType.Pub || m_options.SocketType == ZmqSocketType.Xpub)                                          m_decoder.SetMsgSink(this);                                        // handshake is done                                      Activate();                                  }                                  else if (m_greetingBytesRead < 10)                                  {                                      var greetingSegment = new ByteArraySegment(m_greeting' m_greetingBytesRead);                                      BeginRead(greetingSegment' PreambleSize - m_greetingBytesRead);                                  }                                  else                                  {                                      // The peer is using versioned protocol.                                      // Send the rest of the greeting.                                      m_outpos[m_outsize++] = 1; // Protocol version                                      m_outpos[m_outsize++] = (byte)m_options.SocketType;                                        m_handshakeState = HandshakeState.SendingRestOfGreeting;                                        BeginWrite(m_outpos' m_outsize);                                  }                              }                              break;                          case Action.ActivateIn:                          case Action.ActivateOut:                              // nothing to do                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  case HandshakeState.SendingRestOfGreeting:                      switch (action)                      {                          case Action.OutCompleted:                              bytesSent = EndWrite(socketError' bytesTransferred);                                if (bytesSent == -1)                              {                                  Error();                              }                              else                              {                                  m_outpos.AdvanceOffset(bytesSent);                                  m_outsize -= bytesSent;                                    if (m_outsize > 0)                                  {                                      BeginWrite(m_outpos' m_outsize);                                  }                                  else                                  {                                      var greetingSegment = new ByteArraySegment(m_greeting' m_greetingBytesRead);                                        m_handshakeState = HandshakeState.ReceivingRestOfGreeting;                                      BeginRead(greetingSegment' GreetingSize - m_greetingBytesRead);                                  }                              }                              break;                          case Action.ActivateIn:                          case Action.ActivateOut:                              // nothing to do                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  case HandshakeState.ReceivingRestOfGreeting:                      switch (action)                      {                          case Action.InCompleted:                              bytesReceived = EndRead(socketError' bytesTransferred);                                if (bytesReceived == -1)                              {                                  Error();                              }                              else                              {                                  m_greetingBytesRead += bytesReceived;                                    if (m_greetingBytesRead < GreetingSize)                                  {                                      var greetingSegment = new ByteArraySegment(m_greeting' m_greetingBytesRead);                                      BeginRead(greetingSegment' GreetingSize - m_greetingBytesRead);                                  }                                  else                                  {                                      if (m_greeting[VersionPos] == 0)                                      {                                          // ZMTP/1.0 framing.                                          m_encoder = new V1Encoder(Config.OutBatchSize' m_options.Endian);                                          m_encoder.SetMsgSource(m_session);                                            m_decoder = new V1Decoder(Config.InBatchSize' m_options.MaxMessageSize' m_options.Endian);                                          m_decoder.SetMsgSink(m_session);                                      }                                      else                                      {                                          // v1 framing protocol.                                          m_encoder = new V2Encoder(Config.OutBatchSize' m_session' m_options.Endian);                                          m_decoder = new V2Decoder(Config.InBatchSize' m_options.MaxMessageSize' m_session' m_options.Endian);                                      }                                        // handshake is done                                      Activate();                                  }                              }                              break;                          case Action.ActivateIn:                          case Action.ActivateOut:                              // nothing to do                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  default:                      Debug.Assert(false);                      break;              }
Magic Number,NetMQ.Core.Transports,StreamEngine,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\StreamEngine.cs,HandleHandshake,The following statement contains a magic number: switch (m_handshakeState)              {                  case HandshakeState.Closed:                      switch (action)                      {                          case Action.Start:                              // Send the 'length' and 'flags' fields of the identity message.                              // The 'length' field is encoded in the long format.                                m_greetingOutputBuffer[m_outsize++] = 0xff;                              m_greetingOutputBuffer.PutLong(m_options.Endian' (long)m_options.IdentitySize + 1' 1);                              m_outsize += 8;                              m_greetingOutputBuffer[m_outsize++] = 0x7f;                                m_outpos = new ByteArraySegment(m_greetingOutputBuffer);                                m_handshakeState = HandshakeState.SendingGreeting;                                BeginWrite(m_outpos' m_outsize);                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  case HandshakeState.SendingGreeting:                      switch (action)                      {                          case Action.OutCompleted:                              bytesSent = EndWrite(socketError' bytesTransferred);                                if (bytesSent == -1)                              {                                  Error();                              }                              else                              {                                  m_outpos.AdvanceOffset(bytesSent);                                  m_outsize -= bytesSent;                                    if (m_outsize > 0)                                  {                                      BeginWrite(m_outpos' m_outsize);                                  }                                  else                                  {                                      m_greetingBytesRead = 0;                                        var greetingSegment = new ByteArraySegment(m_greeting' m_greetingBytesRead);                                        m_handshakeState = HandshakeState.ReceivingGreeting;                                        BeginRead(greetingSegment' PreambleSize);                                  }                              }                              break;                          case Action.ActivateIn:                          case Action.ActivateOut:                              // nothing to do                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  case HandshakeState.ReceivingGreeting:                      switch (action)                      {                          case Action.InCompleted:                              bytesReceived = EndRead(socketError' bytesTransferred);                                if (bytesReceived == -1)                              {                                  Error();                              }                              else                              {                                  m_greetingBytesRead += bytesReceived;                                    // check if it is an unversioned protocol                                  if (m_greeting[0] != 0xff || (m_greetingBytesRead == 10 && (m_greeting[9] & 0x01) == 0))                                  {                                      m_encoder = new V1Encoder(Config.OutBatchSize' m_options.Endian);                                      m_encoder.SetMsgSource(m_session);                                        m_decoder = new V1Decoder(Config.InBatchSize' m_options.MaxMessageSize' m_options.Endian);                                      m_decoder.SetMsgSink(m_session);                                        // We have already sent the message header.                                      // Since there is no way to tell the encoder to                                      // skip the message header' we simply throw that                                      // header data away.                                      int headerSize = m_options.IdentitySize + 1 >= 255 ? 10 : 2;                                      var tmp = new byte[10];                                      var bufferp = new ByteArraySegment(tmp);                                        int bufferSize = headerSize;                                        m_encoder.GetData(ref bufferp' ref bufferSize);                                        Debug.Assert(bufferSize == headerSize);                                        // Make sure the decoder sees the data we have already received.                                      m_inpos = new ByteArraySegment(m_greeting);                                      m_insize = m_greetingBytesRead;                                        // To allow for interoperability with peers that do not forward                                      // their subscriptions' we inject a phony subscription                                      // message into the incoming message stream. To put this                                      // message right after the identity message' we temporarily                                      // divert the message stream from session to ourselves.                                      if (m_options.SocketType == ZmqSocketType.Pub || m_options.SocketType == ZmqSocketType.Xpub)                                          m_decoder.SetMsgSink(this);                                        // handshake is done                                      Activate();                                  }                                  else if (m_greetingBytesRead < 10)                                  {                                      var greetingSegment = new ByteArraySegment(m_greeting' m_greetingBytesRead);                                      BeginRead(greetingSegment' PreambleSize - m_greetingBytesRead);                                  }                                  else                                  {                                      // The peer is using versioned protocol.                                      // Send the rest of the greeting.                                      m_outpos[m_outsize++] = 1; // Protocol version                                      m_outpos[m_outsize++] = (byte)m_options.SocketType;                                        m_handshakeState = HandshakeState.SendingRestOfGreeting;                                        BeginWrite(m_outpos' m_outsize);                                  }                              }                              break;                          case Action.ActivateIn:                          case Action.ActivateOut:                              // nothing to do                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  case HandshakeState.SendingRestOfGreeting:                      switch (action)                      {                          case Action.OutCompleted:                              bytesSent = EndWrite(socketError' bytesTransferred);                                if (bytesSent == -1)                              {                                  Error();                              }                              else                              {                                  m_outpos.AdvanceOffset(bytesSent);                                  m_outsize -= bytesSent;                                    if (m_outsize > 0)                                  {                                      BeginWrite(m_outpos' m_outsize);                                  }                                  else                                  {                                      var greetingSegment = new ByteArraySegment(m_greeting' m_greetingBytesRead);                                        m_handshakeState = HandshakeState.ReceivingRestOfGreeting;                                      BeginRead(greetingSegment' GreetingSize - m_greetingBytesRead);                                  }                              }                              break;                          case Action.ActivateIn:                          case Action.ActivateOut:                              // nothing to do                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  case HandshakeState.ReceivingRestOfGreeting:                      switch (action)                      {                          case Action.InCompleted:                              bytesReceived = EndRead(socketError' bytesTransferred);                                if (bytesReceived == -1)                              {                                  Error();                              }                              else                              {                                  m_greetingBytesRead += bytesReceived;                                    if (m_greetingBytesRead < GreetingSize)                                  {                                      var greetingSegment = new ByteArraySegment(m_greeting' m_greetingBytesRead);                                      BeginRead(greetingSegment' GreetingSize - m_greetingBytesRead);                                  }                                  else                                  {                                      if (m_greeting[VersionPos] == 0)                                      {                                          // ZMTP/1.0 framing.                                          m_encoder = new V1Encoder(Config.OutBatchSize' m_options.Endian);                                          m_encoder.SetMsgSource(m_session);                                            m_decoder = new V1Decoder(Config.InBatchSize' m_options.MaxMessageSize' m_options.Endian);                                          m_decoder.SetMsgSink(m_session);                                      }                                      else                                      {                                          // v1 framing protocol.                                          m_encoder = new V2Encoder(Config.OutBatchSize' m_session' m_options.Endian);                                          m_decoder = new V2Decoder(Config.InBatchSize' m_options.MaxMessageSize' m_session' m_options.Endian);                                      }                                        // handshake is done                                      Activate();                                  }                              }                              break;                          case Action.ActivateIn:                          case Action.ActivateOut:                              // nothing to do                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  default:                      Debug.Assert(false);                      break;              }
Magic Number,NetMQ.Core.Transports,StreamEngine,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\StreamEngine.cs,HandleHandshake,The following statement contains a magic number: switch (m_handshakeState)              {                  case HandshakeState.Closed:                      switch (action)                      {                          case Action.Start:                              // Send the 'length' and 'flags' fields of the identity message.                              // The 'length' field is encoded in the long format.                                m_greetingOutputBuffer[m_outsize++] = 0xff;                              m_greetingOutputBuffer.PutLong(m_options.Endian' (long)m_options.IdentitySize + 1' 1);                              m_outsize += 8;                              m_greetingOutputBuffer[m_outsize++] = 0x7f;                                m_outpos = new ByteArraySegment(m_greetingOutputBuffer);                                m_handshakeState = HandshakeState.SendingGreeting;                                BeginWrite(m_outpos' m_outsize);                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  case HandshakeState.SendingGreeting:                      switch (action)                      {                          case Action.OutCompleted:                              bytesSent = EndWrite(socketError' bytesTransferred);                                if (bytesSent == -1)                              {                                  Error();                              }                              else                              {                                  m_outpos.AdvanceOffset(bytesSent);                                  m_outsize -= bytesSent;                                    if (m_outsize > 0)                                  {                                      BeginWrite(m_outpos' m_outsize);                                  }                                  else                                  {                                      m_greetingBytesRead = 0;                                        var greetingSegment = new ByteArraySegment(m_greeting' m_greetingBytesRead);                                        m_handshakeState = HandshakeState.ReceivingGreeting;                                        BeginRead(greetingSegment' PreambleSize);                                  }                              }                              break;                          case Action.ActivateIn:                          case Action.ActivateOut:                              // nothing to do                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  case HandshakeState.ReceivingGreeting:                      switch (action)                      {                          case Action.InCompleted:                              bytesReceived = EndRead(socketError' bytesTransferred);                                if (bytesReceived == -1)                              {                                  Error();                              }                              else                              {                                  m_greetingBytesRead += bytesReceived;                                    // check if it is an unversioned protocol                                  if (m_greeting[0] != 0xff || (m_greetingBytesRead == 10 && (m_greeting[9] & 0x01) == 0))                                  {                                      m_encoder = new V1Encoder(Config.OutBatchSize' m_options.Endian);                                      m_encoder.SetMsgSource(m_session);                                        m_decoder = new V1Decoder(Config.InBatchSize' m_options.MaxMessageSize' m_options.Endian);                                      m_decoder.SetMsgSink(m_session);                                        // We have already sent the message header.                                      // Since there is no way to tell the encoder to                                      // skip the message header' we simply throw that                                      // header data away.                                      int headerSize = m_options.IdentitySize + 1 >= 255 ? 10 : 2;                                      var tmp = new byte[10];                                      var bufferp = new ByteArraySegment(tmp);                                        int bufferSize = headerSize;                                        m_encoder.GetData(ref bufferp' ref bufferSize);                                        Debug.Assert(bufferSize == headerSize);                                        // Make sure the decoder sees the data we have already received.                                      m_inpos = new ByteArraySegment(m_greeting);                                      m_insize = m_greetingBytesRead;                                        // To allow for interoperability with peers that do not forward                                      // their subscriptions' we inject a phony subscription                                      // message into the incoming message stream. To put this                                      // message right after the identity message' we temporarily                                      // divert the message stream from session to ourselves.                                      if (m_options.SocketType == ZmqSocketType.Pub || m_options.SocketType == ZmqSocketType.Xpub)                                          m_decoder.SetMsgSink(this);                                        // handshake is done                                      Activate();                                  }                                  else if (m_greetingBytesRead < 10)                                  {                                      var greetingSegment = new ByteArraySegment(m_greeting' m_greetingBytesRead);                                      BeginRead(greetingSegment' PreambleSize - m_greetingBytesRead);                                  }                                  else                                  {                                      // The peer is using versioned protocol.                                      // Send the rest of the greeting.                                      m_outpos[m_outsize++] = 1; // Protocol version                                      m_outpos[m_outsize++] = (byte)m_options.SocketType;                                        m_handshakeState = HandshakeState.SendingRestOfGreeting;                                        BeginWrite(m_outpos' m_outsize);                                  }                              }                              break;                          case Action.ActivateIn:                          case Action.ActivateOut:                              // nothing to do                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  case HandshakeState.SendingRestOfGreeting:                      switch (action)                      {                          case Action.OutCompleted:                              bytesSent = EndWrite(socketError' bytesTransferred);                                if (bytesSent == -1)                              {                                  Error();                              }                              else                              {                                  m_outpos.AdvanceOffset(bytesSent);                                  m_outsize -= bytesSent;                                    if (m_outsize > 0)                                  {                                      BeginWrite(m_outpos' m_outsize);                                  }                                  else                                  {                                      var greetingSegment = new ByteArraySegment(m_greeting' m_greetingBytesRead);                                        m_handshakeState = HandshakeState.ReceivingRestOfGreeting;                                      BeginRead(greetingSegment' GreetingSize - m_greetingBytesRead);                                  }                              }                              break;                          case Action.ActivateIn:                          case Action.ActivateOut:                              // nothing to do                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  case HandshakeState.ReceivingRestOfGreeting:                      switch (action)                      {                          case Action.InCompleted:                              bytesReceived = EndRead(socketError' bytesTransferred);                                if (bytesReceived == -1)                              {                                  Error();                              }                              else                              {                                  m_greetingBytesRead += bytesReceived;                                    if (m_greetingBytesRead < GreetingSize)                                  {                                      var greetingSegment = new ByteArraySegment(m_greeting' m_greetingBytesRead);                                      BeginRead(greetingSegment' GreetingSize - m_greetingBytesRead);                                  }                                  else                                  {                                      if (m_greeting[VersionPos] == 0)                                      {                                          // ZMTP/1.0 framing.                                          m_encoder = new V1Encoder(Config.OutBatchSize' m_options.Endian);                                          m_encoder.SetMsgSource(m_session);                                            m_decoder = new V1Decoder(Config.InBatchSize' m_options.MaxMessageSize' m_options.Endian);                                          m_decoder.SetMsgSink(m_session);                                      }                                      else                                      {                                          // v1 framing protocol.                                          m_encoder = new V2Encoder(Config.OutBatchSize' m_session' m_options.Endian);                                          m_decoder = new V2Decoder(Config.InBatchSize' m_options.MaxMessageSize' m_session' m_options.Endian);                                      }                                        // handshake is done                                      Activate();                                  }                              }                              break;                          case Action.ActivateIn:                          case Action.ActivateOut:                              // nothing to do                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  default:                      Debug.Assert(false);                      break;              }
Magic Number,NetMQ.Core.Transports,StreamEngine,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\StreamEngine.cs,HandleHandshake,The following statement contains a magic number: switch (m_handshakeState)              {                  case HandshakeState.Closed:                      switch (action)                      {                          case Action.Start:                              // Send the 'length' and 'flags' fields of the identity message.                              // The 'length' field is encoded in the long format.                                m_greetingOutputBuffer[m_outsize++] = 0xff;                              m_greetingOutputBuffer.PutLong(m_options.Endian' (long)m_options.IdentitySize + 1' 1);                              m_outsize += 8;                              m_greetingOutputBuffer[m_outsize++] = 0x7f;                                m_outpos = new ByteArraySegment(m_greetingOutputBuffer);                                m_handshakeState = HandshakeState.SendingGreeting;                                BeginWrite(m_outpos' m_outsize);                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  case HandshakeState.SendingGreeting:                      switch (action)                      {                          case Action.OutCompleted:                              bytesSent = EndWrite(socketError' bytesTransferred);                                if (bytesSent == -1)                              {                                  Error();                              }                              else                              {                                  m_outpos.AdvanceOffset(bytesSent);                                  m_outsize -= bytesSent;                                    if (m_outsize > 0)                                  {                                      BeginWrite(m_outpos' m_outsize);                                  }                                  else                                  {                                      m_greetingBytesRead = 0;                                        var greetingSegment = new ByteArraySegment(m_greeting' m_greetingBytesRead);                                        m_handshakeState = HandshakeState.ReceivingGreeting;                                        BeginRead(greetingSegment' PreambleSize);                                  }                              }                              break;                          case Action.ActivateIn:                          case Action.ActivateOut:                              // nothing to do                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  case HandshakeState.ReceivingGreeting:                      switch (action)                      {                          case Action.InCompleted:                              bytesReceived = EndRead(socketError' bytesTransferred);                                if (bytesReceived == -1)                              {                                  Error();                              }                              else                              {                                  m_greetingBytesRead += bytesReceived;                                    // check if it is an unversioned protocol                                  if (m_greeting[0] != 0xff || (m_greetingBytesRead == 10 && (m_greeting[9] & 0x01) == 0))                                  {                                      m_encoder = new V1Encoder(Config.OutBatchSize' m_options.Endian);                                      m_encoder.SetMsgSource(m_session);                                        m_decoder = new V1Decoder(Config.InBatchSize' m_options.MaxMessageSize' m_options.Endian);                                      m_decoder.SetMsgSink(m_session);                                        // We have already sent the message header.                                      // Since there is no way to tell the encoder to                                      // skip the message header' we simply throw that                                      // header data away.                                      int headerSize = m_options.IdentitySize + 1 >= 255 ? 10 : 2;                                      var tmp = new byte[10];                                      var bufferp = new ByteArraySegment(tmp);                                        int bufferSize = headerSize;                                        m_encoder.GetData(ref bufferp' ref bufferSize);                                        Debug.Assert(bufferSize == headerSize);                                        // Make sure the decoder sees the data we have already received.                                      m_inpos = new ByteArraySegment(m_greeting);                                      m_insize = m_greetingBytesRead;                                        // To allow for interoperability with peers that do not forward                                      // their subscriptions' we inject a phony subscription                                      // message into the incoming message stream. To put this                                      // message right after the identity message' we temporarily                                      // divert the message stream from session to ourselves.                                      if (m_options.SocketType == ZmqSocketType.Pub || m_options.SocketType == ZmqSocketType.Xpub)                                          m_decoder.SetMsgSink(this);                                        // handshake is done                                      Activate();                                  }                                  else if (m_greetingBytesRead < 10)                                  {                                      var greetingSegment = new ByteArraySegment(m_greeting' m_greetingBytesRead);                                      BeginRead(greetingSegment' PreambleSize - m_greetingBytesRead);                                  }                                  else                                  {                                      // The peer is using versioned protocol.                                      // Send the rest of the greeting.                                      m_outpos[m_outsize++] = 1; // Protocol version                                      m_outpos[m_outsize++] = (byte)m_options.SocketType;                                        m_handshakeState = HandshakeState.SendingRestOfGreeting;                                        BeginWrite(m_outpos' m_outsize);                                  }                              }                              break;                          case Action.ActivateIn:                          case Action.ActivateOut:                              // nothing to do                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  case HandshakeState.SendingRestOfGreeting:                      switch (action)                      {                          case Action.OutCompleted:                              bytesSent = EndWrite(socketError' bytesTransferred);                                if (bytesSent == -1)                              {                                  Error();                              }                              else                              {                                  m_outpos.AdvanceOffset(bytesSent);                                  m_outsize -= bytesSent;                                    if (m_outsize > 0)                                  {                                      BeginWrite(m_outpos' m_outsize);                                  }                                  else                                  {                                      var greetingSegment = new ByteArraySegment(m_greeting' m_greetingBytesRead);                                        m_handshakeState = HandshakeState.ReceivingRestOfGreeting;                                      BeginRead(greetingSegment' GreetingSize - m_greetingBytesRead);                                  }                              }                              break;                          case Action.ActivateIn:                          case Action.ActivateOut:                              // nothing to do                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  case HandshakeState.ReceivingRestOfGreeting:                      switch (action)                      {                          case Action.InCompleted:                              bytesReceived = EndRead(socketError' bytesTransferred);                                if (bytesReceived == -1)                              {                                  Error();                              }                              else                              {                                  m_greetingBytesRead += bytesReceived;                                    if (m_greetingBytesRead < GreetingSize)                                  {                                      var greetingSegment = new ByteArraySegment(m_greeting' m_greetingBytesRead);                                      BeginRead(greetingSegment' GreetingSize - m_greetingBytesRead);                                  }                                  else                                  {                                      if (m_greeting[VersionPos] == 0)                                      {                                          // ZMTP/1.0 framing.                                          m_encoder = new V1Encoder(Config.OutBatchSize' m_options.Endian);                                          m_encoder.SetMsgSource(m_session);                                            m_decoder = new V1Decoder(Config.InBatchSize' m_options.MaxMessageSize' m_options.Endian);                                          m_decoder.SetMsgSink(m_session);                                      }                                      else                                      {                                          // v1 framing protocol.                                          m_encoder = new V2Encoder(Config.OutBatchSize' m_session' m_options.Endian);                                          m_decoder = new V2Decoder(Config.InBatchSize' m_options.MaxMessageSize' m_session' m_options.Endian);                                      }                                        // handshake is done                                      Activate();                                  }                              }                              break;                          case Action.ActivateIn:                          case Action.ActivateOut:                              // nothing to do                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  default:                      Debug.Assert(false);                      break;              }
Magic Number,NetMQ.Core.Transports,StreamEngine,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\StreamEngine.cs,HandleHandshake,The following statement contains a magic number: switch (m_handshakeState)              {                  case HandshakeState.Closed:                      switch (action)                      {                          case Action.Start:                              // Send the 'length' and 'flags' fields of the identity message.                              // The 'length' field is encoded in the long format.                                m_greetingOutputBuffer[m_outsize++] = 0xff;                              m_greetingOutputBuffer.PutLong(m_options.Endian' (long)m_options.IdentitySize + 1' 1);                              m_outsize += 8;                              m_greetingOutputBuffer[m_outsize++] = 0x7f;                                m_outpos = new ByteArraySegment(m_greetingOutputBuffer);                                m_handshakeState = HandshakeState.SendingGreeting;                                BeginWrite(m_outpos' m_outsize);                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  case HandshakeState.SendingGreeting:                      switch (action)                      {                          case Action.OutCompleted:                              bytesSent = EndWrite(socketError' bytesTransferred);                                if (bytesSent == -1)                              {                                  Error();                              }                              else                              {                                  m_outpos.AdvanceOffset(bytesSent);                                  m_outsize -= bytesSent;                                    if (m_outsize > 0)                                  {                                      BeginWrite(m_outpos' m_outsize);                                  }                                  else                                  {                                      m_greetingBytesRead = 0;                                        var greetingSegment = new ByteArraySegment(m_greeting' m_greetingBytesRead);                                        m_handshakeState = HandshakeState.ReceivingGreeting;                                        BeginRead(greetingSegment' PreambleSize);                                  }                              }                              break;                          case Action.ActivateIn:                          case Action.ActivateOut:                              // nothing to do                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  case HandshakeState.ReceivingGreeting:                      switch (action)                      {                          case Action.InCompleted:                              bytesReceived = EndRead(socketError' bytesTransferred);                                if (bytesReceived == -1)                              {                                  Error();                              }                              else                              {                                  m_greetingBytesRead += bytesReceived;                                    // check if it is an unversioned protocol                                  if (m_greeting[0] != 0xff || (m_greetingBytesRead == 10 && (m_greeting[9] & 0x01) == 0))                                  {                                      m_encoder = new V1Encoder(Config.OutBatchSize' m_options.Endian);                                      m_encoder.SetMsgSource(m_session);                                        m_decoder = new V1Decoder(Config.InBatchSize' m_options.MaxMessageSize' m_options.Endian);                                      m_decoder.SetMsgSink(m_session);                                        // We have already sent the message header.                                      // Since there is no way to tell the encoder to                                      // skip the message header' we simply throw that                                      // header data away.                                      int headerSize = m_options.IdentitySize + 1 >= 255 ? 10 : 2;                                      var tmp = new byte[10];                                      var bufferp = new ByteArraySegment(tmp);                                        int bufferSize = headerSize;                                        m_encoder.GetData(ref bufferp' ref bufferSize);                                        Debug.Assert(bufferSize == headerSize);                                        // Make sure the decoder sees the data we have already received.                                      m_inpos = new ByteArraySegment(m_greeting);                                      m_insize = m_greetingBytesRead;                                        // To allow for interoperability with peers that do not forward                                      // their subscriptions' we inject a phony subscription                                      // message into the incoming message stream. To put this                                      // message right after the identity message' we temporarily                                      // divert the message stream from session to ourselves.                                      if (m_options.SocketType == ZmqSocketType.Pub || m_options.SocketType == ZmqSocketType.Xpub)                                          m_decoder.SetMsgSink(this);                                        // handshake is done                                      Activate();                                  }                                  else if (m_greetingBytesRead < 10)                                  {                                      var greetingSegment = new ByteArraySegment(m_greeting' m_greetingBytesRead);                                      BeginRead(greetingSegment' PreambleSize - m_greetingBytesRead);                                  }                                  else                                  {                                      // The peer is using versioned protocol.                                      // Send the rest of the greeting.                                      m_outpos[m_outsize++] = 1; // Protocol version                                      m_outpos[m_outsize++] = (byte)m_options.SocketType;                                        m_handshakeState = HandshakeState.SendingRestOfGreeting;                                        BeginWrite(m_outpos' m_outsize);                                  }                              }                              break;                          case Action.ActivateIn:                          case Action.ActivateOut:                              // nothing to do                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  case HandshakeState.SendingRestOfGreeting:                      switch (action)                      {                          case Action.OutCompleted:                              bytesSent = EndWrite(socketError' bytesTransferred);                                if (bytesSent == -1)                              {                                  Error();                              }                              else                              {                                  m_outpos.AdvanceOffset(bytesSent);                                  m_outsize -= bytesSent;                                    if (m_outsize > 0)                                  {                                      BeginWrite(m_outpos' m_outsize);                                  }                                  else                                  {                                      var greetingSegment = new ByteArraySegment(m_greeting' m_greetingBytesRead);                                        m_handshakeState = HandshakeState.ReceivingRestOfGreeting;                                      BeginRead(greetingSegment' GreetingSize - m_greetingBytesRead);                                  }                              }                              break;                          case Action.ActivateIn:                          case Action.ActivateOut:                              // nothing to do                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  case HandshakeState.ReceivingRestOfGreeting:                      switch (action)                      {                          case Action.InCompleted:                              bytesReceived = EndRead(socketError' bytesTransferred);                                if (bytesReceived == -1)                              {                                  Error();                              }                              else                              {                                  m_greetingBytesRead += bytesReceived;                                    if (m_greetingBytesRead < GreetingSize)                                  {                                      var greetingSegment = new ByteArraySegment(m_greeting' m_greetingBytesRead);                                      BeginRead(greetingSegment' GreetingSize - m_greetingBytesRead);                                  }                                  else                                  {                                      if (m_greeting[VersionPos] == 0)                                      {                                          // ZMTP/1.0 framing.                                          m_encoder = new V1Encoder(Config.OutBatchSize' m_options.Endian);                                          m_encoder.SetMsgSource(m_session);                                            m_decoder = new V1Decoder(Config.InBatchSize' m_options.MaxMessageSize' m_options.Endian);                                          m_decoder.SetMsgSink(m_session);                                      }                                      else                                      {                                          // v1 framing protocol.                                          m_encoder = new V2Encoder(Config.OutBatchSize' m_session' m_options.Endian);                                          m_decoder = new V2Decoder(Config.InBatchSize' m_options.MaxMessageSize' m_session' m_options.Endian);                                      }                                        // handshake is done                                      Activate();                                  }                              }                              break;                          case Action.ActivateIn:                          case Action.ActivateOut:                              // nothing to do                              break;                          default:                              Debug.Assert(false);                              break;                      }                      break;                  default:                      Debug.Assert(false);                      break;              }
Magic Number,NetMQ.Core.Transports,V1Decoder,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\V1Decoder.cs,V1Decoder,The following statement contains a magic number: m_tmpbuf = new ByteArraySegment(new byte[8]);
Magic Number,NetMQ.Core.Transports,V1Decoder,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\V1Decoder.cs,OneByteSizeReady,The following statement contains a magic number: if (first == 0xff)              {                  NextStep(m_tmpbuf' 8' EightByteSizeReadyState);              }              else              {                    // There has to be at least one byte (the flags) in the message).                  if (first == 0)                  {                      DecodingError();                      return false;                  }                    // in_progress is initialised at this point so in theory we should                  // close it before calling zmq_msg_init_size' however' it's a 0-byte                  // message and thus we can treat it as uninitialised...                  if (m_maxMessageSize >= 0 && (long)(first - 1) > m_maxMessageSize)                  {                      DecodingError();                      return false;                    }                  else                  {                      m_inProgress.InitPool(first - 1);                  }                    NextStep(m_tmpbuf' 1' FlagsReadyState);              }
Magic Number,NetMQ.Core.Transports,V1Encoder,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\V1Encoder.cs,MessageReady,The following statement contains a magic number: if (size < 255)              {                  m_tmpbuf[0] = (byte)size;                  m_tmpbuf[1] = (byte)(m_inProgress.Flags & MsgFlags.More);                  NextStep(m_tmpbuf' 2' SizeReadyState' false);              }              else              {                  m_tmpbuf[0] = 0xff;                  m_tmpbuf.PutLong(Endian' size' 1);                  m_tmpbuf[9] = (byte)(m_inProgress.Flags & MsgFlags.More);                  NextStep(m_tmpbuf' 10' SizeReadyState' false);              }
Magic Number,NetMQ.Core.Transports,V1Encoder,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\V1Encoder.cs,MessageReady,The following statement contains a magic number: if (size < 255)              {                  m_tmpbuf[0] = (byte)size;                  m_tmpbuf[1] = (byte)(m_inProgress.Flags & MsgFlags.More);                  NextStep(m_tmpbuf' 2' SizeReadyState' false);              }              else              {                  m_tmpbuf[0] = 0xff;                  m_tmpbuf.PutLong(Endian' size' 1);                  m_tmpbuf[9] = (byte)(m_inProgress.Flags & MsgFlags.More);                  NextStep(m_tmpbuf' 10' SizeReadyState' false);              }
Magic Number,NetMQ.Core.Transports,V1Encoder,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\V1Encoder.cs,MessageReady,The following statement contains a magic number: if (size < 255)              {                  m_tmpbuf[0] = (byte)size;                  m_tmpbuf[1] = (byte)(m_inProgress.Flags & MsgFlags.More);                  NextStep(m_tmpbuf' 2' SizeReadyState' false);              }              else              {                  m_tmpbuf[0] = 0xff;                  m_tmpbuf.PutLong(Endian' size' 1);                  m_tmpbuf[9] = (byte)(m_inProgress.Flags & MsgFlags.More);                  NextStep(m_tmpbuf' 10' SizeReadyState' false);              }
Magic Number,NetMQ.Core.Transports,V1Encoder,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\V1Encoder.cs,MessageReady,The following statement contains a magic number: if (size < 255)              {                  m_tmpbuf[0] = (byte)size;                  m_tmpbuf[1] = (byte)(m_inProgress.Flags & MsgFlags.More);                  NextStep(m_tmpbuf' 2' SizeReadyState' false);              }              else              {                  m_tmpbuf[0] = 0xff;                  m_tmpbuf.PutLong(Endian' size' 1);                  m_tmpbuf[9] = (byte)(m_inProgress.Flags & MsgFlags.More);                  NextStep(m_tmpbuf' 10' SizeReadyState' false);              }
Magic Number,NetMQ.Core.Transports,V2Decoder,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\V2Decoder.cs,V2Decoder,The following statement contains a magic number: m_tmpbuf = new byte[8];
Magic Number,NetMQ.Core.Transports,V2Decoder,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\V2Decoder.cs,FlagsReady,The following statement contains a magic number: if ((first & V2Protocol.LargeFlag) > 0)                  NextStep(m_tmpbuf' 8' EightByteSizeReadyState);              else                  NextStep(m_tmpbuf' 1' OneByteSizeReadyState);
Magic Number,NetMQ.Core.Transports,V2Encoder,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\V2Encoder.cs,MessageReady,The following statement contains a magic number: if (m_inProgress.Size > 255)                  protocolFlags |= V2Protocol.LargeFlag;
Magic Number,NetMQ.Core.Transports,V2Encoder,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\V2Encoder.cs,MessageReady,The following statement contains a magic number: if (size > 255)              {                  m_tmpbuf.PutLong(Endian' size' 1);                  NextStep(m_tmpbuf' 9' SizeReadyState' false);              }              else              {                  m_tmpbuf[1] = (byte)(size);                  NextStep(m_tmpbuf' 2' SizeReadyState' false);              }
Magic Number,NetMQ.Core.Transports,V2Encoder,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\V2Encoder.cs,MessageReady,The following statement contains a magic number: if (size > 255)              {                  m_tmpbuf.PutLong(Endian' size' 1);                  NextStep(m_tmpbuf' 9' SizeReadyState' false);              }              else              {                  m_tmpbuf[1] = (byte)(size);                  NextStep(m_tmpbuf' 2' SizeReadyState' false);              }
Magic Number,NetMQ.Core.Transports,V2Encoder,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\V2Encoder.cs,MessageReady,The following statement contains a magic number: if (size > 255)              {                  m_tmpbuf.PutLong(Endian' size' 1);                  NextStep(m_tmpbuf' 9' SizeReadyState' false);              }              else              {                  m_tmpbuf[1] = (byte)(size);                  NextStep(m_tmpbuf' 2' SizeReadyState' false);              }
Magic Number,NetMQ.Core.Transports.Ipc,IpcAddress,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\Ipc\IpcAddress.cs,Resolve,The following statement contains a magic number: hash = hash%55536;
Magic Number,NetMQ.Core.Transports.Ipc,IpcAddress,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\Ipc\IpcAddress.cs,Resolve,The following statement contains a magic number: hash += 10000;
Magic Number,NetMQ.Core.Transports.Pgm,PgmAddress,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\Pgm\PgmAddress.cs,Resolve,The following statement contains a magic number: if (addrStr.Length >= 2 && addrStr[0] == '[' && addrStr[addrStr.Length - 1] == ']')                  addrStr = addrStr.Substring(1' addrStr.Length - 2);
Magic Number,NetMQ.Core.Transports.Pgm,PgmAddress,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\Pgm\PgmAddress.cs,Resolve,The following statement contains a magic number: if (addrStr.Length >= 2 && addrStr[0] == '[' && addrStr[addrStr.Length - 1] == ']')                  addrStr = addrStr.Substring(1' addrStr.Length - 2);
Magic Number,NetMQ.Core.Transports.Pgm,PgmSender,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\Pgm\PgmSender.cs,GetNewReconnectIvl,The following statement contains a magic number: if (m_options.ReconnectIvlMax > 0 &&                  m_options.ReconnectIvlMax > m_options.ReconnectIvl)              {                  // Calculate the next interval                  m_currentReconnectIvl = m_currentReconnectIvl * 2;                  if (m_currentReconnectIvl >= m_options.ReconnectIvlMax)                  {                      m_currentReconnectIvl = m_options.ReconnectIvlMax;                  }              }
Magic Number,NetMQ.Core.Transports.Pgm,PgmSocket,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\Pgm\PgmSocket.cs,InitOptions,The following statement contains a magic number: if (m_pgmSocketType == PgmSocketType.Listener || m_pgmSocketType == PgmSocketType.Receiver)              {                  if (m_pgmAddress.InterfaceAddress != null)                  {                      Handle.SetSocketOption(PgmLevel' RM_ADD_RECEIVE_IF' m_pgmAddress.InterfaceAddress.GetAddressBytes());                  }              }              else if (m_pgmSocketType == PgmSocketType.Publisher)              {                  // set multicast hops for the publisher                  Handle.SetSocketOption(PgmLevel' RM_SET_MCAST_TTL' m_options.MulticastHops);                    // set the publisher send interface                  if (m_pgmAddress.InterfaceAddress != null)                  {                      Handle.SetSocketOption(PgmLevel' RM_SET_SEND_IF' m_pgmAddress.InterfaceAddress.GetAddressBytes());                  }                    // instead of using the struct _RM_SEND_WINDOW we are using byte array of size 12 (the size of the original struct and the size of three ints)                  // typedef struct _RM_SEND_WINDOW {                  // ULONG RateKbitsPerSec;                  // ULONG WindowSizeInMSecs;                  // ULONG WindowSizeInBytes;                  //} RM_SEND_WINDOW;                  var sendWindow = new byte[12];                    // setting the rate of the transmission in Kilobits per second                  var rate = (uint)(m_options.Rate);                  Array.Copy(BitConverter.GetBytes(rate)' 0' sendWindow' 0' 4);                    // setting the recovery interval                  var sizeInMS = (uint)(m_options.RecoveryIvl);                  Array.Copy(BitConverter.GetBytes(sizeInMS)' 0' sendWindow' 4' 4);                    // we are not setting the size in bytes because it get filled automatically' if we want to set it we would just uncomment the following lines                  //uint sizeInBytes = (uint)((rate / 8.0) * sizeInMS);                  //Array.Copy(BitConverter.GetBytes(sizeInBytes)' 0' sendWindow' 8' 4);                    Handle.SetSocketOption(PgmLevel' RM_RATE_WINDOW_SIZE' sendWindow);              }
Magic Number,NetMQ.Core.Transports.Pgm,PgmSocket,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\Pgm\PgmSocket.cs,InitOptions,The following statement contains a magic number: if (m_pgmSocketType == PgmSocketType.Listener || m_pgmSocketType == PgmSocketType.Receiver)              {                  if (m_pgmAddress.InterfaceAddress != null)                  {                      Handle.SetSocketOption(PgmLevel' RM_ADD_RECEIVE_IF' m_pgmAddress.InterfaceAddress.GetAddressBytes());                  }              }              else if (m_pgmSocketType == PgmSocketType.Publisher)              {                  // set multicast hops for the publisher                  Handle.SetSocketOption(PgmLevel' RM_SET_MCAST_TTL' m_options.MulticastHops);                    // set the publisher send interface                  if (m_pgmAddress.InterfaceAddress != null)                  {                      Handle.SetSocketOption(PgmLevel' RM_SET_SEND_IF' m_pgmAddress.InterfaceAddress.GetAddressBytes());                  }                    // instead of using the struct _RM_SEND_WINDOW we are using byte array of size 12 (the size of the original struct and the size of three ints)                  // typedef struct _RM_SEND_WINDOW {                  // ULONG RateKbitsPerSec;                  // ULONG WindowSizeInMSecs;                  // ULONG WindowSizeInBytes;                  //} RM_SEND_WINDOW;                  var sendWindow = new byte[12];                    // setting the rate of the transmission in Kilobits per second                  var rate = (uint)(m_options.Rate);                  Array.Copy(BitConverter.GetBytes(rate)' 0' sendWindow' 0' 4);                    // setting the recovery interval                  var sizeInMS = (uint)(m_options.RecoveryIvl);                  Array.Copy(BitConverter.GetBytes(sizeInMS)' 0' sendWindow' 4' 4);                    // we are not setting the size in bytes because it get filled automatically' if we want to set it we would just uncomment the following lines                  //uint sizeInBytes = (uint)((rate / 8.0) * sizeInMS);                  //Array.Copy(BitConverter.GetBytes(sizeInBytes)' 0' sendWindow' 8' 4);                    Handle.SetSocketOption(PgmLevel' RM_RATE_WINDOW_SIZE' sendWindow);              }
Magic Number,NetMQ.Core.Transports.Pgm,PgmSocket,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\Pgm\PgmSocket.cs,InitOptions,The following statement contains a magic number: if (m_pgmSocketType == PgmSocketType.Listener || m_pgmSocketType == PgmSocketType.Receiver)              {                  if (m_pgmAddress.InterfaceAddress != null)                  {                      Handle.SetSocketOption(PgmLevel' RM_ADD_RECEIVE_IF' m_pgmAddress.InterfaceAddress.GetAddressBytes());                  }              }              else if (m_pgmSocketType == PgmSocketType.Publisher)              {                  // set multicast hops for the publisher                  Handle.SetSocketOption(PgmLevel' RM_SET_MCAST_TTL' m_options.MulticastHops);                    // set the publisher send interface                  if (m_pgmAddress.InterfaceAddress != null)                  {                      Handle.SetSocketOption(PgmLevel' RM_SET_SEND_IF' m_pgmAddress.InterfaceAddress.GetAddressBytes());                  }                    // instead of using the struct _RM_SEND_WINDOW we are using byte array of size 12 (the size of the original struct and the size of three ints)                  // typedef struct _RM_SEND_WINDOW {                  // ULONG RateKbitsPerSec;                  // ULONG WindowSizeInMSecs;                  // ULONG WindowSizeInBytes;                  //} RM_SEND_WINDOW;                  var sendWindow = new byte[12];                    // setting the rate of the transmission in Kilobits per second                  var rate = (uint)(m_options.Rate);                  Array.Copy(BitConverter.GetBytes(rate)' 0' sendWindow' 0' 4);                    // setting the recovery interval                  var sizeInMS = (uint)(m_options.RecoveryIvl);                  Array.Copy(BitConverter.GetBytes(sizeInMS)' 0' sendWindow' 4' 4);                    // we are not setting the size in bytes because it get filled automatically' if we want to set it we would just uncomment the following lines                  //uint sizeInBytes = (uint)((rate / 8.0) * sizeInMS);                  //Array.Copy(BitConverter.GetBytes(sizeInBytes)' 0' sendWindow' 8' 4);                    Handle.SetSocketOption(PgmLevel' RM_RATE_WINDOW_SIZE' sendWindow);              }
Magic Number,NetMQ.Core.Transports.Pgm,PgmSocket,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\Pgm\PgmSocket.cs,InitOptions,The following statement contains a magic number: if (m_pgmSocketType == PgmSocketType.Listener || m_pgmSocketType == PgmSocketType.Receiver)              {                  if (m_pgmAddress.InterfaceAddress != null)                  {                      Handle.SetSocketOption(PgmLevel' RM_ADD_RECEIVE_IF' m_pgmAddress.InterfaceAddress.GetAddressBytes());                  }              }              else if (m_pgmSocketType == PgmSocketType.Publisher)              {                  // set multicast hops for the publisher                  Handle.SetSocketOption(PgmLevel' RM_SET_MCAST_TTL' m_options.MulticastHops);                    // set the publisher send interface                  if (m_pgmAddress.InterfaceAddress != null)                  {                      Handle.SetSocketOption(PgmLevel' RM_SET_SEND_IF' m_pgmAddress.InterfaceAddress.GetAddressBytes());                  }                    // instead of using the struct _RM_SEND_WINDOW we are using byte array of size 12 (the size of the original struct and the size of three ints)                  // typedef struct _RM_SEND_WINDOW {                  // ULONG RateKbitsPerSec;                  // ULONG WindowSizeInMSecs;                  // ULONG WindowSizeInBytes;                  //} RM_SEND_WINDOW;                  var sendWindow = new byte[12];                    // setting the rate of the transmission in Kilobits per second                  var rate = (uint)(m_options.Rate);                  Array.Copy(BitConverter.GetBytes(rate)' 0' sendWindow' 0' 4);                    // setting the recovery interval                  var sizeInMS = (uint)(m_options.RecoveryIvl);                  Array.Copy(BitConverter.GetBytes(sizeInMS)' 0' sendWindow' 4' 4);                    // we are not setting the size in bytes because it get filled automatically' if we want to set it we would just uncomment the following lines                  //uint sizeInBytes = (uint)((rate / 8.0) * sizeInMS);                  //Array.Copy(BitConverter.GetBytes(sizeInBytes)' 0' sendWindow' 8' 4);                    Handle.SetSocketOption(PgmLevel' RM_RATE_WINDOW_SIZE' sendWindow);              }
Magic Number,NetMQ.Core.Transports.Tcp,TcpAddress,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\Tcp\TcpAddress.cs,Resolve,The following statement contains a magic number: if (addrStr.Length >= 2 && addrStr[0] == '[' && addrStr[addrStr.Length - 1] == ']')                  addrStr = addrStr.Substring(1' addrStr.Length - 2);
Magic Number,NetMQ.Core.Transports.Tcp,TcpAddress,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\Tcp\TcpAddress.cs,Resolve,The following statement contains a magic number: if (addrStr.Length >= 2 && addrStr[0] == '[' && addrStr[addrStr.Length - 1] == ']')                  addrStr = addrStr.Substring(1' addrStr.Length - 2);
Magic Number,NetMQ.Core.Transports.Tcp,TcpConnector,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\Tcp\TcpConnector.cs,OutCompleted,The following statement contains a magic number: if (socketError != SocketError.Success)              {                  m_ioObject.RemoveSocket(m_s);                  m_handleValid = false;                    Close();                    // Try again to connect after a time'                  // as long as the error is one of these..                  if (socketError == SocketError.ConnectionRefused || socketError == SocketError.TimedOut ||                      socketError == SocketError.ConnectionAborted ||                      socketError == SocketError.HostUnreachable || socketError == SocketError.NetworkUnreachable ||                      socketError == SocketError.NetworkDown || socketError == SocketError.AccessDenied ||                      socketError == SocketError.OperationAborted)                  {                      if (m_options.ReconnectIvl >= 0)                          AddReconnectTimer();                  }                  else                  {                      throw NetMQException.Create(socketError);                  }              }              else              {                  m_ioObject.RemoveSocket(m_s);                  m_handleValid = false;                    m_s.NoDelay = true;                    // As long as the TCP keep-alive option is not -1 (indicating no change)'                  if (m_options.TcpKeepalive != -1)                  {                      // Set the TCP keep-alive option values to the underlying socket.                      m_s.SetSocketOption(SocketOptionLevel.Socket' SocketOptionName.KeepAlive' m_options.TcpKeepalive);                        if (m_options.TcpKeepaliveIdle != -1 && m_options.TcpKeepaliveIntvl != -1)                      {                          // Write the TCP keep-alive options to a byte-array' to feed to the IOControl method..                          var bytes = new ByteArraySegment(new byte[12]);                            Endianness endian = BitConverter.IsLittleEndian ? Endianness.Little : Endianness.Big;                            bytes.PutInteger(endian' m_options.TcpKeepalive' 0);                          bytes.PutInteger(endian' m_options.TcpKeepaliveIdle' 4);                          bytes.PutInteger(endian' m_options.TcpKeepaliveIntvl' 8);                            m_s.IOControl(IOControlCode.KeepAliveValues' (byte[])bytes' null);                      }                  }                    // Create the engine object for this connection.                  var engine = new StreamEngine(m_s' m_options' m_endpoint);                    m_socket.EventConnected(m_endpoint' m_s);                    m_s = null;                    // Attach the engine to the corresponding session object.                  SendAttach(m_session' engine);                    // Shut the connector down.                  Terminate();              }
Magic Number,NetMQ.Core.Transports.Tcp,TcpConnector,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\Tcp\TcpConnector.cs,OutCompleted,The following statement contains a magic number: if (socketError != SocketError.Success)              {                  m_ioObject.RemoveSocket(m_s);                  m_handleValid = false;                    Close();                    // Try again to connect after a time'                  // as long as the error is one of these..                  if (socketError == SocketError.ConnectionRefused || socketError == SocketError.TimedOut ||                      socketError == SocketError.ConnectionAborted ||                      socketError == SocketError.HostUnreachable || socketError == SocketError.NetworkUnreachable ||                      socketError == SocketError.NetworkDown || socketError == SocketError.AccessDenied ||                      socketError == SocketError.OperationAborted)                  {                      if (m_options.ReconnectIvl >= 0)                          AddReconnectTimer();                  }                  else                  {                      throw NetMQException.Create(socketError);                  }              }              else              {                  m_ioObject.RemoveSocket(m_s);                  m_handleValid = false;                    m_s.NoDelay = true;                    // As long as the TCP keep-alive option is not -1 (indicating no change)'                  if (m_options.TcpKeepalive != -1)                  {                      // Set the TCP keep-alive option values to the underlying socket.                      m_s.SetSocketOption(SocketOptionLevel.Socket' SocketOptionName.KeepAlive' m_options.TcpKeepalive);                        if (m_options.TcpKeepaliveIdle != -1 && m_options.TcpKeepaliveIntvl != -1)                      {                          // Write the TCP keep-alive options to a byte-array' to feed to the IOControl method..                          var bytes = new ByteArraySegment(new byte[12]);                            Endianness endian = BitConverter.IsLittleEndian ? Endianness.Little : Endianness.Big;                            bytes.PutInteger(endian' m_options.TcpKeepalive' 0);                          bytes.PutInteger(endian' m_options.TcpKeepaliveIdle' 4);                          bytes.PutInteger(endian' m_options.TcpKeepaliveIntvl' 8);                            m_s.IOControl(IOControlCode.KeepAliveValues' (byte[])bytes' null);                      }                  }                    // Create the engine object for this connection.                  var engine = new StreamEngine(m_s' m_options' m_endpoint);                    m_socket.EventConnected(m_endpoint' m_s);                    m_s = null;                    // Attach the engine to the corresponding session object.                  SendAttach(m_session' engine);                    // Shut the connector down.                  Terminate();              }
Magic Number,NetMQ.Core.Transports.Tcp,TcpConnector,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\Tcp\TcpConnector.cs,OutCompleted,The following statement contains a magic number: if (socketError != SocketError.Success)              {                  m_ioObject.RemoveSocket(m_s);                  m_handleValid = false;                    Close();                    // Try again to connect after a time'                  // as long as the error is one of these..                  if (socketError == SocketError.ConnectionRefused || socketError == SocketError.TimedOut ||                      socketError == SocketError.ConnectionAborted ||                      socketError == SocketError.HostUnreachable || socketError == SocketError.NetworkUnreachable ||                      socketError == SocketError.NetworkDown || socketError == SocketError.AccessDenied ||                      socketError == SocketError.OperationAborted)                  {                      if (m_options.ReconnectIvl >= 0)                          AddReconnectTimer();                  }                  else                  {                      throw NetMQException.Create(socketError);                  }              }              else              {                  m_ioObject.RemoveSocket(m_s);                  m_handleValid = false;                    m_s.NoDelay = true;                    // As long as the TCP keep-alive option is not -1 (indicating no change)'                  if (m_options.TcpKeepalive != -1)                  {                      // Set the TCP keep-alive option values to the underlying socket.                      m_s.SetSocketOption(SocketOptionLevel.Socket' SocketOptionName.KeepAlive' m_options.TcpKeepalive);                        if (m_options.TcpKeepaliveIdle != -1 && m_options.TcpKeepaliveIntvl != -1)                      {                          // Write the TCP keep-alive options to a byte-array' to feed to the IOControl method..                          var bytes = new ByteArraySegment(new byte[12]);                            Endianness endian = BitConverter.IsLittleEndian ? Endianness.Little : Endianness.Big;                            bytes.PutInteger(endian' m_options.TcpKeepalive' 0);                          bytes.PutInteger(endian' m_options.TcpKeepaliveIdle' 4);                          bytes.PutInteger(endian' m_options.TcpKeepaliveIntvl' 8);                            m_s.IOControl(IOControlCode.KeepAliveValues' (byte[])bytes' null);                      }                  }                    // Create the engine object for this connection.                  var engine = new StreamEngine(m_s' m_options' m_endpoint);                    m_socket.EventConnected(m_endpoint' m_s);                    m_s = null;                    // Attach the engine to the corresponding session object.                  SendAttach(m_session' engine);                    // Shut the connector down.                  Terminate();              }
Magic Number,NetMQ.Core.Transports.Tcp,TcpConnector,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\Tcp\TcpConnector.cs,GetNewReconnectIvl,The following statement contains a magic number: if (m_options.ReconnectIvlMax > 0 &&                  m_options.ReconnectIvlMax > m_options.ReconnectIvl)              {                  // Calculate the next interval                  m_currentReconnectIvl = m_currentReconnectIvl * 2;                  if (m_currentReconnectIvl >= m_options.ReconnectIvlMax)                  {                      m_currentReconnectIvl = m_options.ReconnectIvlMax;                  }              }
Magic Number,NetMQ.Core.Transports.Tcp,TcpListener,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\Tcp\TcpListener.cs,InCompleted,The following statement contains a magic number: switch (socketError)              {                  case SocketError.Success:                  {                      // TODO: check TcpFilters                      var acceptedSocket = m_handle.GetAcceptedSocket();                            acceptedSocket.NoDelay = true;                        if (m_options.TcpKeepalive != -1)                      {                          acceptedSocket.SetSocketOption(SocketOptionLevel.Socket' SocketOptionName.KeepAlive' m_options.TcpKeepalive);                            if (m_options.TcpKeepaliveIdle != -1 && m_options.TcpKeepaliveIntvl != -1)                          {                              var bytes = new ByteArraySegment(new byte[12]);                                Endianness endian = BitConverter.IsLittleEndian ? Endianness.Little : Endianness.Big;                                bytes.PutInteger(endian' m_options.TcpKeepalive' 0);                              bytes.PutInteger(endian' m_options.TcpKeepaliveIdle' 4);                              bytes.PutInteger(endian' m_options.TcpKeepaliveIntvl' 8);                                acceptedSocket.IOControl(IOControlCode.KeepAliveValues' (byte[])bytes' null);                          }                      }                        // Create the engine object for this connection.                      var engine = new StreamEngine(acceptedSocket' m_options' m_endpoint);                        // Choose I/O thread to run connector in. Given that we are already                      // running in an I/O thread' there must be at least one available.                      IOThread ioThread = ChooseIOThread(m_options.Affinity);                        // Create and launch a session object.                      // TODO: send null in address parameter' is unneeded in this case                      SessionBase session = SessionBase.Create(ioThread' false' m_socket' m_options' new Address(m_handle.LocalEndPoint));                      session.IncSeqnum();                      LaunchChild(session);                        SendAttach(session' engine' false);                        m_socket.EventAccepted(m_endpoint' acceptedSocket);                        Accept();                      break;                  }                  case SocketError.ConnectionReset:                  case SocketError.NoBufferSpaceAvailable:                  case SocketError.TooManyOpenSockets:                  {                      m_socket.EventAcceptFailed(m_endpoint' socketError.ToErrorCode());                        Accept();                      break;                  }                  default:                  {                      NetMQException exception = NetMQException.Create(socketError);                        m_socket.EventAcceptFailed(m_endpoint' exception.ErrorCode);                      throw exception;                  }              }
Magic Number,NetMQ.Core.Transports.Tcp,TcpListener,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\Tcp\TcpListener.cs,InCompleted,The following statement contains a magic number: switch (socketError)              {                  case SocketError.Success:                  {                      // TODO: check TcpFilters                      var acceptedSocket = m_handle.GetAcceptedSocket();                            acceptedSocket.NoDelay = true;                        if (m_options.TcpKeepalive != -1)                      {                          acceptedSocket.SetSocketOption(SocketOptionLevel.Socket' SocketOptionName.KeepAlive' m_options.TcpKeepalive);                            if (m_options.TcpKeepaliveIdle != -1 && m_options.TcpKeepaliveIntvl != -1)                          {                              var bytes = new ByteArraySegment(new byte[12]);                                Endianness endian = BitConverter.IsLittleEndian ? Endianness.Little : Endianness.Big;                                bytes.PutInteger(endian' m_options.TcpKeepalive' 0);                              bytes.PutInteger(endian' m_options.TcpKeepaliveIdle' 4);                              bytes.PutInteger(endian' m_options.TcpKeepaliveIntvl' 8);                                acceptedSocket.IOControl(IOControlCode.KeepAliveValues' (byte[])bytes' null);                          }                      }                        // Create the engine object for this connection.                      var engine = new StreamEngine(acceptedSocket' m_options' m_endpoint);                        // Choose I/O thread to run connector in. Given that we are already                      // running in an I/O thread' there must be at least one available.                      IOThread ioThread = ChooseIOThread(m_options.Affinity);                        // Create and launch a session object.                      // TODO: send null in address parameter' is unneeded in this case                      SessionBase session = SessionBase.Create(ioThread' false' m_socket' m_options' new Address(m_handle.LocalEndPoint));                      session.IncSeqnum();                      LaunchChild(session);                        SendAttach(session' engine' false);                        m_socket.EventAccepted(m_endpoint' acceptedSocket);                        Accept();                      break;                  }                  case SocketError.ConnectionReset:                  case SocketError.NoBufferSpaceAvailable:                  case SocketError.TooManyOpenSockets:                  {                      m_socket.EventAcceptFailed(m_endpoint' socketError.ToErrorCode());                        Accept();                      break;                  }                  default:                  {                      NetMQException exception = NetMQException.Create(socketError);                        m_socket.EventAcceptFailed(m_endpoint' exception.ErrorCode);                      throw exception;                  }              }
Magic Number,NetMQ.Core.Transports.Tcp,TcpListener,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\Tcp\TcpListener.cs,InCompleted,The following statement contains a magic number: switch (socketError)              {                  case SocketError.Success:                  {                      // TODO: check TcpFilters                      var acceptedSocket = m_handle.GetAcceptedSocket();                            acceptedSocket.NoDelay = true;                        if (m_options.TcpKeepalive != -1)                      {                          acceptedSocket.SetSocketOption(SocketOptionLevel.Socket' SocketOptionName.KeepAlive' m_options.TcpKeepalive);                            if (m_options.TcpKeepaliveIdle != -1 && m_options.TcpKeepaliveIntvl != -1)                          {                              var bytes = new ByteArraySegment(new byte[12]);                                Endianness endian = BitConverter.IsLittleEndian ? Endianness.Little : Endianness.Big;                                bytes.PutInteger(endian' m_options.TcpKeepalive' 0);                              bytes.PutInteger(endian' m_options.TcpKeepaliveIdle' 4);                              bytes.PutInteger(endian' m_options.TcpKeepaliveIntvl' 8);                                acceptedSocket.IOControl(IOControlCode.KeepAliveValues' (byte[])bytes' null);                          }                      }                        // Create the engine object for this connection.                      var engine = new StreamEngine(acceptedSocket' m_options' m_endpoint);                        // Choose I/O thread to run connector in. Given that we are already                      // running in an I/O thread' there must be at least one available.                      IOThread ioThread = ChooseIOThread(m_options.Affinity);                        // Create and launch a session object.                      // TODO: send null in address parameter' is unneeded in this case                      SessionBase session = SessionBase.Create(ioThread' false' m_socket' m_options' new Address(m_handle.LocalEndPoint));                      session.IncSeqnum();                      LaunchChild(session);                        SendAttach(session' engine' false);                        m_socket.EventAccepted(m_endpoint' acceptedSocket);                        Accept();                      break;                  }                  case SocketError.ConnectionReset:                  case SocketError.NoBufferSpaceAvailable:                  case SocketError.TooManyOpenSockets:                  {                      m_socket.EventAcceptFailed(m_endpoint' socketError.ToErrorCode());                        Accept();                      break;                  }                  default:                  {                      NetMQException exception = NetMQException.Create(socketError);                        m_socket.EventAcceptFailed(m_endpoint' exception.ErrorCode);                      throw exception;                  }              }
Magic Number,NetMQ.Core.Utils,ByteArrayEqualityComparer,C:\repos\zeromq_netmq\src\NetMQ\Core\Utils\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int remainder = data.Length & 3;                  int alignedLength = data.Length - remainder;                    uint hash = 0;                    // Walk through data four bytes at a time                  for (int i = 0; i < alignedLength; i += 4)                  {                      var k = (uint)(data[i] | data[i + 1] << 8 | data[i + 2] << 16 | data[i + 3] << 24);                      k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                      hash = (hash << 13) | (hash >> (32 - 13));                      hash = hash * 5 + 0xe6546b64;                  }                    // Deal with the one' two or three leftover bytes                  if (remainder > 0)                  {                      uint k = 0;                        // determine how many bytes we have left to work with based on length                      switch (remainder)                      {                          case 3:                              k ^= (uint)data[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)data[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= data[alignedLength];                              break;                      }                        k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                  }                    hash ^= (uint)data.Length;                  hash ^= hash >> 16;                  hash *= 0x85ebca6b;                  hash ^= hash >> 13;                  hash *= 0xc2b2ae35;                  hash ^= hash >> 16;                    return (int)hash;              }
Magic Number,NetMQ.Core.Utils,ByteArrayEqualityComparer,C:\repos\zeromq_netmq\src\NetMQ\Core\Utils\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int remainder = data.Length & 3;                  int alignedLength = data.Length - remainder;                    uint hash = 0;                    // Walk through data four bytes at a time                  for (int i = 0; i < alignedLength; i += 4)                  {                      var k = (uint)(data[i] | data[i + 1] << 8 | data[i + 2] << 16 | data[i + 3] << 24);                      k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                      hash = (hash << 13) | (hash >> (32 - 13));                      hash = hash * 5 + 0xe6546b64;                  }                    // Deal with the one' two or three leftover bytes                  if (remainder > 0)                  {                      uint k = 0;                        // determine how many bytes we have left to work with based on length                      switch (remainder)                      {                          case 3:                              k ^= (uint)data[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)data[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= data[alignedLength];                              break;                      }                        k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                  }                    hash ^= (uint)data.Length;                  hash ^= hash >> 16;                  hash *= 0x85ebca6b;                  hash ^= hash >> 13;                  hash *= 0xc2b2ae35;                  hash ^= hash >> 16;                    return (int)hash;              }
Magic Number,NetMQ.Core.Utils,ByteArrayEqualityComparer,C:\repos\zeromq_netmq\src\NetMQ\Core\Utils\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int remainder = data.Length & 3;                  int alignedLength = data.Length - remainder;                    uint hash = 0;                    // Walk through data four bytes at a time                  for (int i = 0; i < alignedLength; i += 4)                  {                      var k = (uint)(data[i] | data[i + 1] << 8 | data[i + 2] << 16 | data[i + 3] << 24);                      k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                      hash = (hash << 13) | (hash >> (32 - 13));                      hash = hash * 5 + 0xe6546b64;                  }                    // Deal with the one' two or three leftover bytes                  if (remainder > 0)                  {                      uint k = 0;                        // determine how many bytes we have left to work with based on length                      switch (remainder)                      {                          case 3:                              k ^= (uint)data[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)data[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= data[alignedLength];                              break;                      }                        k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                  }                    hash ^= (uint)data.Length;                  hash ^= hash >> 16;                  hash *= 0x85ebca6b;                  hash ^= hash >> 13;                  hash *= 0xc2b2ae35;                  hash ^= hash >> 16;                    return (int)hash;              }
Magic Number,NetMQ.Core.Utils,ByteArrayEqualityComparer,C:\repos\zeromq_netmq\src\NetMQ\Core\Utils\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int remainder = data.Length & 3;                  int alignedLength = data.Length - remainder;                    uint hash = 0;                    // Walk through data four bytes at a time                  for (int i = 0; i < alignedLength; i += 4)                  {                      var k = (uint)(data[i] | data[i + 1] << 8 | data[i + 2] << 16 | data[i + 3] << 24);                      k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                      hash = (hash << 13) | (hash >> (32 - 13));                      hash = hash * 5 + 0xe6546b64;                  }                    // Deal with the one' two or three leftover bytes                  if (remainder > 0)                  {                      uint k = 0;                        // determine how many bytes we have left to work with based on length                      switch (remainder)                      {                          case 3:                              k ^= (uint)data[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)data[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= data[alignedLength];                              break;                      }                        k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                  }                    hash ^= (uint)data.Length;                  hash ^= hash >> 16;                  hash *= 0x85ebca6b;                  hash ^= hash >> 13;                  hash *= 0xc2b2ae35;                  hash ^= hash >> 16;                    return (int)hash;              }
Magic Number,NetMQ.Core.Utils,ByteArrayEqualityComparer,C:\repos\zeromq_netmq\src\NetMQ\Core\Utils\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int remainder = data.Length & 3;                  int alignedLength = data.Length - remainder;                    uint hash = 0;                    // Walk through data four bytes at a time                  for (int i = 0; i < alignedLength; i += 4)                  {                      var k = (uint)(data[i] | data[i + 1] << 8 | data[i + 2] << 16 | data[i + 3] << 24);                      k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                      hash = (hash << 13) | (hash >> (32 - 13));                      hash = hash * 5 + 0xe6546b64;                  }                    // Deal with the one' two or three leftover bytes                  if (remainder > 0)                  {                      uint k = 0;                        // determine how many bytes we have left to work with based on length                      switch (remainder)                      {                          case 3:                              k ^= (uint)data[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)data[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= data[alignedLength];                              break;                      }                        k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                  }                    hash ^= (uint)data.Length;                  hash ^= hash >> 16;                  hash *= 0x85ebca6b;                  hash ^= hash >> 13;                  hash *= 0xc2b2ae35;                  hash ^= hash >> 16;                    return (int)hash;              }
Magic Number,NetMQ.Core.Utils,ByteArrayEqualityComparer,C:\repos\zeromq_netmq\src\NetMQ\Core\Utils\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int remainder = data.Length & 3;                  int alignedLength = data.Length - remainder;                    uint hash = 0;                    // Walk through data four bytes at a time                  for (int i = 0; i < alignedLength; i += 4)                  {                      var k = (uint)(data[i] | data[i + 1] << 8 | data[i + 2] << 16 | data[i + 3] << 24);                      k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                      hash = (hash << 13) | (hash >> (32 - 13));                      hash = hash * 5 + 0xe6546b64;                  }                    // Deal with the one' two or three leftover bytes                  if (remainder > 0)                  {                      uint k = 0;                        // determine how many bytes we have left to work with based on length                      switch (remainder)                      {                          case 3:                              k ^= (uint)data[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)data[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= data[alignedLength];                              break;                      }                        k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                  }                    hash ^= (uint)data.Length;                  hash ^= hash >> 16;                  hash *= 0x85ebca6b;                  hash ^= hash >> 13;                  hash *= 0xc2b2ae35;                  hash ^= hash >> 16;                    return (int)hash;              }
Magic Number,NetMQ.Core.Utils,ByteArrayEqualityComparer,C:\repos\zeromq_netmq\src\NetMQ\Core\Utils\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int remainder = data.Length & 3;                  int alignedLength = data.Length - remainder;                    uint hash = 0;                    // Walk through data four bytes at a time                  for (int i = 0; i < alignedLength; i += 4)                  {                      var k = (uint)(data[i] | data[i + 1] << 8 | data[i + 2] << 16 | data[i + 3] << 24);                      k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                      hash = (hash << 13) | (hash >> (32 - 13));                      hash = hash * 5 + 0xe6546b64;                  }                    // Deal with the one' two or three leftover bytes                  if (remainder > 0)                  {                      uint k = 0;                        // determine how many bytes we have left to work with based on length                      switch (remainder)                      {                          case 3:                              k ^= (uint)data[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)data[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= data[alignedLength];                              break;                      }                        k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                  }                    hash ^= (uint)data.Length;                  hash ^= hash >> 16;                  hash *= 0x85ebca6b;                  hash ^= hash >> 13;                  hash *= 0xc2b2ae35;                  hash ^= hash >> 16;                    return (int)hash;              }
Magic Number,NetMQ.Core.Utils,ByteArrayEqualityComparer,C:\repos\zeromq_netmq\src\NetMQ\Core\Utils\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int remainder = data.Length & 3;                  int alignedLength = data.Length - remainder;                    uint hash = 0;                    // Walk through data four bytes at a time                  for (int i = 0; i < alignedLength; i += 4)                  {                      var k = (uint)(data[i] | data[i + 1] << 8 | data[i + 2] << 16 | data[i + 3] << 24);                      k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                      hash = (hash << 13) | (hash >> (32 - 13));                      hash = hash * 5 + 0xe6546b64;                  }                    // Deal with the one' two or three leftover bytes                  if (remainder > 0)                  {                      uint k = 0;                        // determine how many bytes we have left to work with based on length                      switch (remainder)                      {                          case 3:                              k ^= (uint)data[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)data[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= data[alignedLength];                              break;                      }                        k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                  }                    hash ^= (uint)data.Length;                  hash ^= hash >> 16;                  hash *= 0x85ebca6b;                  hash ^= hash >> 13;                  hash *= 0xc2b2ae35;                  hash ^= hash >> 16;                    return (int)hash;              }
Magic Number,NetMQ.Core.Utils,ByteArrayEqualityComparer,C:\repos\zeromq_netmq\src\NetMQ\Core\Utils\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int remainder = data.Length & 3;                  int alignedLength = data.Length - remainder;                    uint hash = 0;                    // Walk through data four bytes at a time                  for (int i = 0; i < alignedLength; i += 4)                  {                      var k = (uint)(data[i] | data[i + 1] << 8 | data[i + 2] << 16 | data[i + 3] << 24);                      k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                      hash = (hash << 13) | (hash >> (32 - 13));                      hash = hash * 5 + 0xe6546b64;                  }                    // Deal with the one' two or three leftover bytes                  if (remainder > 0)                  {                      uint k = 0;                        // determine how many bytes we have left to work with based on length                      switch (remainder)                      {                          case 3:                              k ^= (uint)data[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)data[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= data[alignedLength];                              break;                      }                        k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                  }                    hash ^= (uint)data.Length;                  hash ^= hash >> 16;                  hash *= 0x85ebca6b;                  hash ^= hash >> 13;                  hash *= 0xc2b2ae35;                  hash ^= hash >> 16;                    return (int)hash;              }
Magic Number,NetMQ.Core.Utils,ByteArrayEqualityComparer,C:\repos\zeromq_netmq\src\NetMQ\Core\Utils\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int remainder = data.Length & 3;                  int alignedLength = data.Length - remainder;                    uint hash = 0;                    // Walk through data four bytes at a time                  for (int i = 0; i < alignedLength; i += 4)                  {                      var k = (uint)(data[i] | data[i + 1] << 8 | data[i + 2] << 16 | data[i + 3] << 24);                      k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                      hash = (hash << 13) | (hash >> (32 - 13));                      hash = hash * 5 + 0xe6546b64;                  }                    // Deal with the one' two or three leftover bytes                  if (remainder > 0)                  {                      uint k = 0;                        // determine how many bytes we have left to work with based on length                      switch (remainder)                      {                          case 3:                              k ^= (uint)data[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)data[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= data[alignedLength];                              break;                      }                        k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                  }                    hash ^= (uint)data.Length;                  hash ^= hash >> 16;                  hash *= 0x85ebca6b;                  hash ^= hash >> 13;                  hash *= 0xc2b2ae35;                  hash ^= hash >> 16;                    return (int)hash;              }
Magic Number,NetMQ.Core.Utils,ByteArrayEqualityComparer,C:\repos\zeromq_netmq\src\NetMQ\Core\Utils\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int remainder = data.Length & 3;                  int alignedLength = data.Length - remainder;                    uint hash = 0;                    // Walk through data four bytes at a time                  for (int i = 0; i < alignedLength; i += 4)                  {                      var k = (uint)(data[i] | data[i + 1] << 8 | data[i + 2] << 16 | data[i + 3] << 24);                      k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                      hash = (hash << 13) | (hash >> (32 - 13));                      hash = hash * 5 + 0xe6546b64;                  }                    // Deal with the one' two or three leftover bytes                  if (remainder > 0)                  {                      uint k = 0;                        // determine how many bytes we have left to work with based on length                      switch (remainder)                      {                          case 3:                              k ^= (uint)data[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)data[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= data[alignedLength];                              break;                      }                        k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                  }                    hash ^= (uint)data.Length;                  hash ^= hash >> 16;                  hash *= 0x85ebca6b;                  hash ^= hash >> 13;                  hash *= 0xc2b2ae35;                  hash ^= hash >> 16;                    return (int)hash;              }
Magic Number,NetMQ.Core.Utils,ByteArrayEqualityComparer,C:\repos\zeromq_netmq\src\NetMQ\Core\Utils\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int remainder = data.Length & 3;                  int alignedLength = data.Length - remainder;                    uint hash = 0;                    // Walk through data four bytes at a time                  for (int i = 0; i < alignedLength; i += 4)                  {                      var k = (uint)(data[i] | data[i + 1] << 8 | data[i + 2] << 16 | data[i + 3] << 24);                      k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                      hash = (hash << 13) | (hash >> (32 - 13));                      hash = hash * 5 + 0xe6546b64;                  }                    // Deal with the one' two or three leftover bytes                  if (remainder > 0)                  {                      uint k = 0;                        // determine how many bytes we have left to work with based on length                      switch (remainder)                      {                          case 3:                              k ^= (uint)data[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)data[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= data[alignedLength];                              break;                      }                        k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                  }                    hash ^= (uint)data.Length;                  hash ^= hash >> 16;                  hash *= 0x85ebca6b;                  hash ^= hash >> 13;                  hash *= 0xc2b2ae35;                  hash ^= hash >> 16;                    return (int)hash;              }
Magic Number,NetMQ.Core.Utils,ByteArrayEqualityComparer,C:\repos\zeromq_netmq\src\NetMQ\Core\Utils\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int remainder = data.Length & 3;                  int alignedLength = data.Length - remainder;                    uint hash = 0;                    // Walk through data four bytes at a time                  for (int i = 0; i < alignedLength; i += 4)                  {                      var k = (uint)(data[i] | data[i + 1] << 8 | data[i + 2] << 16 | data[i + 3] << 24);                      k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                      hash = (hash << 13) | (hash >> (32 - 13));                      hash = hash * 5 + 0xe6546b64;                  }                    // Deal with the one' two or three leftover bytes                  if (remainder > 0)                  {                      uint k = 0;                        // determine how many bytes we have left to work with based on length                      switch (remainder)                      {                          case 3:                              k ^= (uint)data[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)data[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= data[alignedLength];                              break;                      }                        k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                  }                    hash ^= (uint)data.Length;                  hash ^= hash >> 16;                  hash *= 0x85ebca6b;                  hash ^= hash >> 13;                  hash *= 0xc2b2ae35;                  hash ^= hash >> 16;                    return (int)hash;              }
Magic Number,NetMQ.Core.Utils,ByteArrayEqualityComparer,C:\repos\zeromq_netmq\src\NetMQ\Core\Utils\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int remainder = data.Length & 3;                  int alignedLength = data.Length - remainder;                    uint hash = 0;                    // Walk through data four bytes at a time                  for (int i = 0; i < alignedLength; i += 4)                  {                      var k = (uint)(data[i] | data[i + 1] << 8 | data[i + 2] << 16 | data[i + 3] << 24);                      k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                      hash = (hash << 13) | (hash >> (32 - 13));                      hash = hash * 5 + 0xe6546b64;                  }                    // Deal with the one' two or three leftover bytes                  if (remainder > 0)                  {                      uint k = 0;                        // determine how many bytes we have left to work with based on length                      switch (remainder)                      {                          case 3:                              k ^= (uint)data[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)data[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= data[alignedLength];                              break;                      }                        k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                  }                    hash ^= (uint)data.Length;                  hash ^= hash >> 16;                  hash *= 0x85ebca6b;                  hash ^= hash >> 13;                  hash *= 0xc2b2ae35;                  hash ^= hash >> 16;                    return (int)hash;              }
Magic Number,NetMQ.Core.Utils,ByteArrayEqualityComparer,C:\repos\zeromq_netmq\src\NetMQ\Core\Utils\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int remainder = data.Length & 3;                  int alignedLength = data.Length - remainder;                    uint hash = 0;                    // Walk through data four bytes at a time                  for (int i = 0; i < alignedLength; i += 4)                  {                      var k = (uint)(data[i] | data[i + 1] << 8 | data[i + 2] << 16 | data[i + 3] << 24);                      k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                      hash = (hash << 13) | (hash >> (32 - 13));                      hash = hash * 5 + 0xe6546b64;                  }                    // Deal with the one' two or three leftover bytes                  if (remainder > 0)                  {                      uint k = 0;                        // determine how many bytes we have left to work with based on length                      switch (remainder)                      {                          case 3:                              k ^= (uint)data[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)data[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= data[alignedLength];                              break;                      }                        k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                  }                    hash ^= (uint)data.Length;                  hash ^= hash >> 16;                  hash *= 0x85ebca6b;                  hash ^= hash >> 13;                  hash *= 0xc2b2ae35;                  hash ^= hash >> 16;                    return (int)hash;              }
Magic Number,NetMQ.Core.Utils,ByteArrayEqualityComparer,C:\repos\zeromq_netmq\src\NetMQ\Core\Utils\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int remainder = data.Length & 3;                  int alignedLength = data.Length - remainder;                    uint hash = 0;                    // Walk through data four bytes at a time                  for (int i = 0; i < alignedLength; i += 4)                  {                      var k = (uint)(data[i] | data[i + 1] << 8 | data[i + 2] << 16 | data[i + 3] << 24);                      k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                      hash = (hash << 13) | (hash >> (32 - 13));                      hash = hash * 5 + 0xe6546b64;                  }                    // Deal with the one' two or three leftover bytes                  if (remainder > 0)                  {                      uint k = 0;                        // determine how many bytes we have left to work with based on length                      switch (remainder)                      {                          case 3:                              k ^= (uint)data[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)data[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= data[alignedLength];                              break;                      }                        k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                  }                    hash ^= (uint)data.Length;                  hash ^= hash >> 16;                  hash *= 0x85ebca6b;                  hash ^= hash >> 13;                  hash *= 0xc2b2ae35;                  hash ^= hash >> 16;                    return (int)hash;              }
Magic Number,NetMQ.Core.Utils,ByteArrayEqualityComparer,C:\repos\zeromq_netmq\src\NetMQ\Core\Utils\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int remainder = data.Length & 3;                  int alignedLength = data.Length - remainder;                    uint hash = 0;                    // Walk through data four bytes at a time                  for (int i = 0; i < alignedLength; i += 4)                  {                      var k = (uint)(data[i] | data[i + 1] << 8 | data[i + 2] << 16 | data[i + 3] << 24);                      k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                      hash = (hash << 13) | (hash >> (32 - 13));                      hash = hash * 5 + 0xe6546b64;                  }                    // Deal with the one' two or three leftover bytes                  if (remainder > 0)                  {                      uint k = 0;                        // determine how many bytes we have left to work with based on length                      switch (remainder)                      {                          case 3:                              k ^= (uint)data[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)data[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= data[alignedLength];                              break;                      }                        k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                  }                    hash ^= (uint)data.Length;                  hash ^= hash >> 16;                  hash *= 0x85ebca6b;                  hash ^= hash >> 13;                  hash *= 0xc2b2ae35;                  hash ^= hash >> 16;                    return (int)hash;              }
Magic Number,NetMQ.Core.Utils,ByteArrayEqualityComparer,C:\repos\zeromq_netmq\src\NetMQ\Core\Utils\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int remainder = data.Length & 3;                  int alignedLength = data.Length - remainder;                    uint hash = 0;                    // Walk through data four bytes at a time                  for (int i = 0; i < alignedLength; i += 4)                  {                      var k = (uint)(data[i] | data[i + 1] << 8 | data[i + 2] << 16 | data[i + 3] << 24);                      k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                      hash = (hash << 13) | (hash >> (32 - 13));                      hash = hash * 5 + 0xe6546b64;                  }                    // Deal with the one' two or three leftover bytes                  if (remainder > 0)                  {                      uint k = 0;                        // determine how many bytes we have left to work with based on length                      switch (remainder)                      {                          case 3:                              k ^= (uint)data[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)data[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= data[alignedLength];                              break;                      }                        k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                  }                    hash ^= (uint)data.Length;                  hash ^= hash >> 16;                  hash *= 0x85ebca6b;                  hash ^= hash >> 13;                  hash *= 0xc2b2ae35;                  hash ^= hash >> 16;                    return (int)hash;              }
Magic Number,NetMQ.Core.Utils,ByteArrayEqualityComparer,C:\repos\zeromq_netmq\src\NetMQ\Core\Utils\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int remainder = data.Length & 3;                  int alignedLength = data.Length - remainder;                    uint hash = 0;                    // Walk through data four bytes at a time                  for (int i = 0; i < alignedLength; i += 4)                  {                      var k = (uint)(data[i] | data[i + 1] << 8 | data[i + 2] << 16 | data[i + 3] << 24);                      k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                      hash = (hash << 13) | (hash >> (32 - 13));                      hash = hash * 5 + 0xe6546b64;                  }                    // Deal with the one' two or three leftover bytes                  if (remainder > 0)                  {                      uint k = 0;                        // determine how many bytes we have left to work with based on length                      switch (remainder)                      {                          case 3:                              k ^= (uint)data[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)data[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= data[alignedLength];                              break;                      }                        k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                  }                    hash ^= (uint)data.Length;                  hash ^= hash >> 16;                  hash *= 0x85ebca6b;                  hash ^= hash >> 13;                  hash *= 0xc2b2ae35;                  hash ^= hash >> 16;                    return (int)hash;              }
Magic Number,NetMQ.Core.Utils,ByteArrayEqualityComparer,C:\repos\zeromq_netmq\src\NetMQ\Core\Utils\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int remainder = data.Length & 3;                  int alignedLength = data.Length - remainder;                    uint hash = 0;                    // Walk through data four bytes at a time                  for (int i = 0; i < alignedLength; i += 4)                  {                      var k = (uint)(data[i] | data[i + 1] << 8 | data[i + 2] << 16 | data[i + 3] << 24);                      k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                      hash = (hash << 13) | (hash >> (32 - 13));                      hash = hash * 5 + 0xe6546b64;                  }                    // Deal with the one' two or three leftover bytes                  if (remainder > 0)                  {                      uint k = 0;                        // determine how many bytes we have left to work with based on length                      switch (remainder)                      {                          case 3:                              k ^= (uint)data[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)data[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= data[alignedLength];                              break;                      }                        k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                  }                    hash ^= (uint)data.Length;                  hash ^= hash >> 16;                  hash *= 0x85ebca6b;                  hash ^= hash >> 13;                  hash *= 0xc2b2ae35;                  hash ^= hash >> 16;                    return (int)hash;              }
Magic Number,NetMQ.Core.Utils,ByteArrayEqualityComparer,C:\repos\zeromq_netmq\src\NetMQ\Core\Utils\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int remainder = data.Length & 3;                  int alignedLength = data.Length - remainder;                    uint hash = 0;                    // Walk through data four bytes at a time                  for (int i = 0; i < alignedLength; i += 4)                  {                      var k = (uint)(data[i] | data[i + 1] << 8 | data[i + 2] << 16 | data[i + 3] << 24);                      k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                      hash = (hash << 13) | (hash >> (32 - 13));                      hash = hash * 5 + 0xe6546b64;                  }                    // Deal with the one' two or three leftover bytes                  if (remainder > 0)                  {                      uint k = 0;                        // determine how many bytes we have left to work with based on length                      switch (remainder)                      {                          case 3:                              k ^= (uint)data[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)data[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= data[alignedLength];                              break;                      }                        k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                  }                    hash ^= (uint)data.Length;                  hash ^= hash >> 16;                  hash *= 0x85ebca6b;                  hash ^= hash >> 13;                  hash *= 0xc2b2ae35;                  hash ^= hash >> 16;                    return (int)hash;              }
Magic Number,NetMQ.Core.Utils,ByteArrayEqualityComparer,C:\repos\zeromq_netmq\src\NetMQ\Core\Utils\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int remainder = data.Length & 3;                  int alignedLength = data.Length - remainder;                    uint hash = 0;                    // Walk through data four bytes at a time                  for (int i = 0; i < alignedLength; i += 4)                  {                      var k = (uint)(data[i] | data[i + 1] << 8 | data[i + 2] << 16 | data[i + 3] << 24);                      k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                      hash = (hash << 13) | (hash >> (32 - 13));                      hash = hash * 5 + 0xe6546b64;                  }                    // Deal with the one' two or three leftover bytes                  if (remainder > 0)                  {                      uint k = 0;                        // determine how many bytes we have left to work with based on length                      switch (remainder)                      {                          case 3:                              k ^= (uint)data[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)data[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= data[alignedLength];                              break;                      }                        k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                  }                    hash ^= (uint)data.Length;                  hash ^= hash >> 16;                  hash *= 0x85ebca6b;                  hash ^= hash >> 13;                  hash *= 0xc2b2ae35;                  hash ^= hash >> 16;                    return (int)hash;              }
Magic Number,NetMQ.Core.Utils,ByteArrayEqualityComparer,C:\repos\zeromq_netmq\src\NetMQ\Core\Utils\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int remainder = data.Length & 3;                  int alignedLength = data.Length - remainder;                    uint hash = 0;                    // Walk through data four bytes at a time                  for (int i = 0; i < alignedLength; i += 4)                  {                      var k = (uint)(data[i] | data[i + 1] << 8 | data[i + 2] << 16 | data[i + 3] << 24);                      k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                      hash = (hash << 13) | (hash >> (32 - 13));                      hash = hash * 5 + 0xe6546b64;                  }                    // Deal with the one' two or three leftover bytes                  if (remainder > 0)                  {                      uint k = 0;                        // determine how many bytes we have left to work with based on length                      switch (remainder)                      {                          case 3:                              k ^= (uint)data[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)data[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= data[alignedLength];                              break;                      }                        k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                  }                    hash ^= (uint)data.Length;                  hash ^= hash >> 16;                  hash *= 0x85ebca6b;                  hash ^= hash >> 13;                  hash *= 0xc2b2ae35;                  hash ^= hash >> 16;                    return (int)hash;              }
Magic Number,NetMQ.Core.Utils,ByteArrayEqualityComparer,C:\repos\zeromq_netmq\src\NetMQ\Core\Utils\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int remainder = data.Length & 3;                  int alignedLength = data.Length - remainder;                    uint hash = 0;                    // Walk through data four bytes at a time                  for (int i = 0; i < alignedLength; i += 4)                  {                      var k = (uint)(data[i] | data[i + 1] << 8 | data[i + 2] << 16 | data[i + 3] << 24);                      k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                      hash = (hash << 13) | (hash >> (32 - 13));                      hash = hash * 5 + 0xe6546b64;                  }                    // Deal with the one' two or three leftover bytes                  if (remainder > 0)                  {                      uint k = 0;                        // determine how many bytes we have left to work with based on length                      switch (remainder)                      {                          case 3:                              k ^= (uint)data[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)data[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= data[alignedLength];                              break;                      }                        k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                  }                    hash ^= (uint)data.Length;                  hash ^= hash >> 16;                  hash *= 0x85ebca6b;                  hash ^= hash >> 13;                  hash *= 0xc2b2ae35;                  hash ^= hash >> 16;                    return (int)hash;              }
Magic Number,NetMQ.Core.Utils,ByteArrayEqualityComparer,C:\repos\zeromq_netmq\src\NetMQ\Core\Utils\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int remainder = data.Length & 3;                  int alignedLength = data.Length - remainder;                    uint hash = 0;                    // Walk through data four bytes at a time                  for (int i = 0; i < alignedLength; i += 4)                  {                      var k = (uint)(data[i] | data[i + 1] << 8 | data[i + 2] << 16 | data[i + 3] << 24);                      k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                      hash = (hash << 13) | (hash >> (32 - 13));                      hash = hash * 5 + 0xe6546b64;                  }                    // Deal with the one' two or three leftover bytes                  if (remainder > 0)                  {                      uint k = 0;                        // determine how many bytes we have left to work with based on length                      switch (remainder)                      {                          case 3:                              k ^= (uint)data[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)data[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= data[alignedLength];                              break;                      }                        k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                  }                    hash ^= (uint)data.Length;                  hash ^= hash >> 16;                  hash *= 0x85ebca6b;                  hash ^= hash >> 13;                  hash *= 0xc2b2ae35;                  hash ^= hash >> 16;                    return (int)hash;              }
Magic Number,NetMQ.Core.Utils,ByteArrayEqualityComparer,C:\repos\zeromq_netmq\src\NetMQ\Core\Utils\ByteArrayEqualityComparer.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int remainder = data.Length & 3;                  int alignedLength = data.Length - remainder;                    uint hash = 0;                    // Walk through data four bytes at a time                  for (int i = 0; i < alignedLength; i += 4)                  {                      var k = (uint)(data[i] | data[i + 1] << 8 | data[i + 2] << 16 | data[i + 3] << 24);                      k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                      hash = (hash << 13) | (hash >> (32 - 13));                      hash = hash * 5 + 0xe6546b64;                  }                    // Deal with the one' two or three leftover bytes                  if (remainder > 0)                  {                      uint k = 0;                        // determine how many bytes we have left to work with based on length                      switch (remainder)                      {                          case 3:                              k ^= (uint)data[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)data[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= data[alignedLength];                              break;                      }                        k *= C1;                      k = (k << 15) | (k >> (32 - 15));                      k *= C2;                        hash ^= k;                  }                    hash ^= (uint)data.Length;                  hash ^= hash >> 16;                  hash *= 0x85ebca6b;                  hash ^= hash >> 13;                  hash *= 0xc2b2ae35;                  hash ^= hash >> 16;                    return (int)hash;              }
Magic Number,NetMQ.Core.Utils,Clock,C:\repos\zeromq_netmq\src\NetMQ\Core\Utils\Clock.cs,Clock,The following statement contains a magic number: try              {                  if (Environment.OSVersion.Platform == PlatformID.Win32NT ||                      Environment.OSVersion.Platform == PlatformID.Unix ||                      Environment.OSVersion.Platform == (PlatformID)128)                  {                      s_rdtscSupported = Opcode.Open();                  }                  else                  {                      s_rdtscSupported = false;                  }              }              catch (Exception)              {                  s_rdtscSupported = false;              }
Magic Number,NetMQ.Core.Utils,Clock,C:\repos\zeromq_netmq\src\NetMQ\Core\Utils\Clock.cs,NowUs,The following statement contains a magic number: double ticksPerMicrosecond = ticksPerSecond / 1000000.0;
Magic Number,NetMQ.Core.Utils,Clock,C:\repos\zeromq_netmq\src\NetMQ\Core\Utils\Clock.cs,NowMs,The following statement contains a magic number: if (tsc == 0)              {                  return NowUs() / 1000;              }
Magic Number,NetMQ.Core.Utils,Clock,C:\repos\zeromq_netmq\src\NetMQ\Core\Utils\Clock.cs,NowMs,The following statement contains a magic number: if (tsc - s_lastTsc <= Config.ClockPrecision / 2 && tsc >= s_lastTsc)              {                  return s_lastTime;              }
Magic Number,NetMQ.Core.Utils,Clock,C:\repos\zeromq_netmq\src\NetMQ\Core\Utils\Clock.cs,NowMs,The following statement contains a magic number: s_lastTime = NowUs() / 1000;
Magic Number,NetMQ.Core.Utils,Opcode,C:\repos\zeromq_netmq\src\NetMQ\Core\Utils\OpCode.cs,Open,The following statement contains a magic number: byte[] rdtscCode = IntPtr.Size == 4 ? RDTSC_32 : RDTSC_64;
Magic Number,NetMQ.Core.Utils,Opcode,C:\repos\zeromq_netmq\src\NetMQ\Core\Utils\OpCode.cs,Open,The following statement contains a magic number: if ((p == 4) || (p == 128))              {                  // Unix                  if (IsARMArchitecture()) return false;                    Assembly assembly = Assembly.Load("Mono.Posix");                    Type syscall = assembly.GetType("Mono.Unix.Native.Syscall");                  MethodInfo mmap = syscall.GetMethod("mmap");                    Type mmapProts = assembly.GetType("Mono.Unix.Native.MmapProts");                  object mmapProtsParam = Enum.ToObject(mmapProts'                      (int)mmapProts.GetField("PROT_READ").GetValue(null) |                      (int)mmapProts.GetField("PROT_WRITE").GetValue(null) |                      (int)mmapProts.GetField("PROT_EXEC").GetValue(null));                    Type mmapFlags = assembly.GetType("Mono.Unix.Native.MmapFlags");                  object mmapFlagsParam = Enum.ToObject(mmapFlags'                      (int)mmapFlags.GetField("MAP_ANONYMOUS").GetValue(null) |                      (int)mmapFlags.GetField("MAP_PRIVATE").GetValue(null));                    s_codeBuffer = (IntPtr)mmap.Invoke(null'                      new[] { IntPtr.Zero' s_size' mmapProtsParam' mmapFlagsParam' -1' 0 });                    if (s_codeBuffer == IntPtr.Zero || s_codeBuffer == (IntPtr)(-1))                  {                      throw new InvalidOperationException("Mmap failed");                  }              }              else              {                  // Windows                  s_codeBuffer = NativeMethods.VirtualAlloc(IntPtr.Zero'                      (UIntPtr)s_size' AllocationType.COMMIT | AllocationType.RESERVE'                      MemoryProtection.EXECUTE_READWRITE);              }
Magic Number,NetMQ.Core.Utils,Opcode,C:\repos\zeromq_netmq\src\NetMQ\Core\Utils\OpCode.cs,Open,The following statement contains a magic number: if ((p == 4) || (p == 128))              {                  // Unix                  if (IsARMArchitecture()) return false;                    Assembly assembly = Assembly.Load("Mono.Posix");                    Type syscall = assembly.GetType("Mono.Unix.Native.Syscall");                  MethodInfo mmap = syscall.GetMethod("mmap");                    Type mmapProts = assembly.GetType("Mono.Unix.Native.MmapProts");                  object mmapProtsParam = Enum.ToObject(mmapProts'                      (int)mmapProts.GetField("PROT_READ").GetValue(null) |                      (int)mmapProts.GetField("PROT_WRITE").GetValue(null) |                      (int)mmapProts.GetField("PROT_EXEC").GetValue(null));                    Type mmapFlags = assembly.GetType("Mono.Unix.Native.MmapFlags");                  object mmapFlagsParam = Enum.ToObject(mmapFlags'                      (int)mmapFlags.GetField("MAP_ANONYMOUS").GetValue(null) |                      (int)mmapFlags.GetField("MAP_PRIVATE").GetValue(null));                    s_codeBuffer = (IntPtr)mmap.Invoke(null'                      new[] { IntPtr.Zero' s_size' mmapProtsParam' mmapFlagsParam' -1' 0 });                    if (s_codeBuffer == IntPtr.Zero || s_codeBuffer == (IntPtr)(-1))                  {                      throw new InvalidOperationException("Mmap failed");                  }              }              else              {                  // Windows                  s_codeBuffer = NativeMethods.VirtualAlloc(IntPtr.Zero'                      (UIntPtr)s_size' AllocationType.COMMIT | AllocationType.RESERVE'                      MemoryProtection.EXECUTE_READWRITE);              }
Magic Number,NetMQ.Core.Utils,Opcode,C:\repos\zeromq_netmq\src\NetMQ\Core\Utils\OpCode.cs,Close,The following statement contains a magic number: if ((p == 4) || (p == 128))              {                  // Unix                  Assembly assembly =                      Assembly.Load("Mono.Posix' Version=2.0.0.0' Culture=neutral' " +                      "PublicKeyToken=0738eb9f132ed756");                    Type syscall = assembly.GetType("Mono.Unix.Native.Syscall");                  MethodInfo munmap = syscall.GetMethod("munmap");                  munmap.Invoke(null' new object[] { s_codeBuffer' s_size });              }              else              {                  // Windows                  NativeMethods.VirtualFree(s_codeBuffer' UIntPtr.Zero' FreeType.RELEASE);              }
Magic Number,NetMQ.Core.Utils,Opcode,C:\repos\zeromq_netmq\src\NetMQ\Core\Utils\OpCode.cs,Close,The following statement contains a magic number: if ((p == 4) || (p == 128))              {                  // Unix                  Assembly assembly =                      Assembly.Load("Mono.Posix' Version=2.0.0.0' Culture=neutral' " +                      "PublicKeyToken=0738eb9f132ed756");                    Type syscall = assembly.GetType("Mono.Unix.Native.Syscall");                  MethodInfo munmap = syscall.GetMethod("munmap");                  munmap.Invoke(null' new object[] { s_codeBuffer' s_size });              }              else              {                  // Windows                  NativeMethods.VirtualFree(s_codeBuffer' UIntPtr.Zero' FreeType.RELEASE);              }
Magic Number,NetMQ.Core.Utils,Poller,C:\repos\zeromq_netmq\src\NetMQ\Core\Utils\Poller.cs,Loop,The following statement contains a magic number: while (!m_stopping)              {                  // Transfer any sockets from the add-list.                  m_handles.AddRange(m_addList);                  m_addList.Clear();                    // Execute any due timers.                  int timeout = ExecuteTimers();                    readList.AddRange(m_checkRead.ToArray());  //                writeList.AddRange(m_checkWrite.ToArray());                  errorList.AddRange(m_checkError.ToArray());                    try                  {                      SocketUtility.Select(readList' /*writeList*/null' errorList' timeout != 0 ? timeout * 1000 : -1);                  }                  catch (SocketException)                  {                      continue;                  }                    // For every PollSet in our list.                  foreach (var pollSet in m_handles)                  {                      if (pollSet.Cancelled)                          continue;                        // Invoke its handler's InEvent if it's in our error-list.                      if (errorList.Contains(pollSet.Socket))                      {                          try                          {                              pollSet.Handler.InEvent();                          }                          catch (TerminatingException)                          {                          }                      }                        if (pollSet.Cancelled)                          continue;    //                    // Invoke its handler's OutEvent if it's in our write-list.  //                    if (writeList.Contains(pollSet.Socket))  //                    {  //                        try  //                        {  //                            pollSet.Handler.OutEvent();  //                        }  //                        catch (TerminatingException)  //                        {  //                        }  //                    }  //  //                    if (pollSet.Cancelled)  //                        continue;                        // Invoke its handler's InEvent if it's in our read-list.                      if (readList.Contains(pollSet.Socket))                      {                          try                          {                              pollSet.Handler.InEvent();                          }                          catch (TerminatingException)                          {                          }                      }                  }                    errorList.Clear();  //                writeList.Clear();                  readList.Clear();                    if (m_retired)                  {                      // Take any sockets that have been cancelled out of the list.                      foreach (var item in m_handles.Where(k => k.Cancelled).ToList())                          m_handles.Remove(item);                        m_retired = false;                  }              }
Magic Number,NetMQ.Core.Utils,Signaler,C:\repos\zeromq_netmq\src\NetMQ\Core\Utils\Signaler.cs,WaitEvent,The following statement contains a magic number: int timeoutInMicroSeconds = (timeout >= 0)                  ? timeout * 1000                  : Timeout.Infinite;
Magic Number,NetMQ.Core.Utils,YQueue<T>,C:\repos\zeromq_netmq\src\NetMQ\Core\Utils\YQueue.cs,YQueue,The following statement contains a magic number: if (chunkSize < 2)                  throw new ArgumentOutOfRangeException(nameof(chunkSize)' "Should be no less than 2");
Magic Number,NetMQ.Monitoring,NetMQMonitor,C:\repos\zeromq_netmq\src\NetMQ\Monitoring\NetMQMonitor.cs,NetMQMonitor,The following statement contains a magic number: Timeout = TimeSpan.FromSeconds(0.5);
Magic Number,NetMQ.Monitoring,NetMQMonitor,C:\repos\zeromq_netmq\src\NetMQ\Monitoring\NetMQMonitor.cs,NetMQMonitor,The following statement contains a magic number: Timeout = TimeSpan.FromSeconds(0.5);
Duplicate Code,NetMQ.Core.Transports,StreamEngine,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\StreamEngine.cs,HandleHandshake,The method contains a code clone-set at the following line numbers (starting from the method definition): ((31' 50)' (150' 169))
Missing Default,NetMQ.Core,Address,C:\repos\zeromq_netmq\src\NetMQ\Core\Address.cs,ToString,The following switch statement is missing a default case: switch (Protocol)                  {                      case TcpProtocol: return Resolved.ToString();                      case IpcProtocol: return Resolved.ToString();                      case PgmProtocol: return Resolved.ToString();                  }
Missing Default,NetMQ.Core,SessionBase,C:\repos\zeromq_netmq\src\NetMQ\Core\SessionBase.cs,StartConnecting,The following switch statement is missing a default case: switch (m_addr.Protocol)              {                  case Address.TcpProtocol:                  {                      LaunchChild(new TcpConnector(ioThread' this' m_options' m_addr' wait));                      return;                  }                  case Address.IpcProtocol:                  {                      LaunchChild(new IpcConnector(ioThread' this' m_options' m_addr' wait));                      return;                  }                  case Address.PgmProtocol:                  case Address.EpgmProtocol:                  {                      var pgmSender = new PgmSender(m_ioThread' m_options' m_addr' wait);                      pgmSender.Init((PgmAddress)m_addr.Resolved);                      SendAttach(this' pgmSender);                      return;                  }              }
Missing Default,NetMQ.Core,SocketBase,C:\repos\zeromq_netmq\src\NetMQ\Core\SocketBase.cs,Bind,The following switch statement is missing a default case: switch (protocol)              {                  case Address.InProcProtocol:                      {                          var endpoint = new Ctx.Endpoint(this' m_options);                          bool addressRegistered = RegisterEndpoint(addr' endpoint);                            if (!addressRegistered)                              throw new AddressAlreadyInUseException($"Cannot bind address ( {addr} ) - already in use.");                            m_options.LastEndpoint = addr;                          return;                      }                  case Address.PgmProtocol:                  case Address.EpgmProtocol:                      {                          if (m_options.SocketType == ZmqSocketType.Pub || m_options.SocketType == ZmqSocketType.Xpub)                          {                              // For convenience's sake' bind can be used interchangeable with                              // connect for PGM and EPGM transports.                              Connect(addr);                              return;                          }                          break;                      }              }
Missing Default,NetMQ.Core,SocketBase,C:\repos\zeromq_netmq\src\NetMQ\Core\SocketBase.cs,Connect,The following switch statement is missing a default case: switch (protocol)              {                  case Address.TcpProtocol:                      {                          paddr.Resolved = (new TcpAddress());                          paddr.Resolved.Resolve(address' m_options.IPv4Only);                          break;                      }                  case Address.IpcProtocol:                      {                          paddr.Resolved = (new IpcAddress());                          paddr.Resolved.Resolve(address' true);                          break;                      }                  case Address.PgmProtocol:                  case Address.EpgmProtocol:                      {                          if (m_options.SocketType == ZmqSocketType.Sub || m_options.SocketType == ZmqSocketType.Xsub)                          {                              Bind(addr);                              return;                          }                          paddr.Resolved = new PgmAddress();                          paddr.Resolved.Resolve(address' m_options.IPv4Only);                          break;                      }              }
Missing Default,NetMQ.Core.Patterns,ReqSession,C:\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Req.cs,PushMsg,The following switch statement is missing a default case: switch (m_state)                  {                      case State.Bottom:                          if (msg.Flags == MsgFlags.More && msg.Size == 0)                          {                              m_state = State.Body;                              return base.PushMsg(ref msg);                          }                          break;                      case State.Body:                          if (msg.Flags == MsgFlags.More)                              return base.PushMsg(ref msg);                          if (msg.Flags == MsgFlags.None)                          {                              m_state = State.Bottom;                              return base.PushMsg(ref msg);                          }                          break;                      case State.Identity:                          if (msg.Flags == MsgFlags.None)                          {                              m_state = State.Bottom;                              return base.PushMsg(ref msg);                          }                          break;                  }
Missing Default,NetMQ.Core.Patterns,Router,C:\repos\zeromq_netmq\src\NetMQ\Core\Patterns\Router.cs,XSetSocketOption,The following switch statement is missing a default case: switch (option)              {                  case ZmqSocketOption.RouterRawSocket:                      m_rawSocket = (bool)optval;                      if (m_rawSocket)                      {                          m_options.RecvIdentity = false;                          m_options.RawSocket = true;                      }                      return true;                  case ZmqSocketOption.RouterMandatory:                      m_mandatory = (bool)optval;                      return true;                  case ZmqSocketOption.RouterHandover:                      m_handover = (bool)optval;                      return true;              }
Missing Default,NetMQ.Core.Patterns,XPub,C:\repos\zeromq_netmq\src\NetMQ\Core\Patterns\XPub.cs,XSetSocketOption,The following switch statement is missing a default case: switch (option)              {                  case ZmqSocketOption.XpubVerbose:                  {                      m_verbose = (bool)optionValue;                      return true;                  }                  case ZmqSocketOption.XPublisherManual:                  {                      m_manual = (bool)optionValue;                      return true;                  }                  case ZmqSocketOption.XPublisherBroadcast:                  {                      m_broadcastEnabled = (bool)optionValue;                      return true;                  }                  case ZmqSocketOption.Identity:                  {                      if (m_manual && m_lastPipe != null)                      {                          byte[] val;                            if (optionValue is string)                              val = Encoding.ASCII.GetBytes((string)optionValue);                          else if (optionValue is byte[])                              val = (byte[])optionValue;                          else                              throw new InvalidException($"In XPub.XSetSocketOption(Identity' {optionValue?.ToString() ?? "null"}) optionValue must be a string or byte-array.");                          if (val.Length == 0 || val.Length > 255)                              throw new InvalidException($"In XPub.XSetSocketOption(Identity') optionValue yielded a byte-array of length {val.Length}' should be 1..255.");                            m_lastPipe.Identity = val;                          m_options.Identity = val;                      }                      return true;                  }                    case ZmqSocketOption.Subscribe:                  {                      if (m_manual && m_lastPipe != null)                      {                          var subscription = optionValue as byte[] ?? Encoding.ASCII.GetBytes((string)optionValue);                          m_subscriptions.Add(subscription' 0' subscription.Length' m_lastPipe);                          m_lastPipe = null;                          return true;                      }                      break;                  }                  case ZmqSocketOption.Unsubscribe:                  {                      if (m_manual && m_lastPipe != null)                      {                          var subscription = optionValue as byte[] ?? Encoding.ASCII.GetBytes((string)optionValue);                          m_subscriptions.Remove(subscription' 0' subscription.Length' m_lastPipe);                          m_lastPipe = null;                          return true;                      }                      break;                  }                  case ZmqSocketOption.XPublisherWelcomeMessage:                  {                      m_welcomeMessage.Close();                        if (optionValue != null)                      {                          var bytes = optionValue as byte[];                          if (bytes == null)                              throw new InvalidException($"In XPub.XSetSocketOption({option}'{optionValue})' optionValue must be a byte-array.");                          var welcomeBytes = new byte[bytes.Length];                          bytes.CopyTo(welcomeBytes' 0);                          m_welcomeMessage.InitGC(welcomeBytes' welcomeBytes.Length);                      }                      else                      {                          m_welcomeMessage.InitEmpty();                      }                        return true;                  }              }
Missing Default,NetMQ.Core.Transports,StreamEngine,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\StreamEngine.cs,Handle,The following switch statement is missing a default case: switch (action)                      {                          case Action.Start:                              if (m_options.RawSocket)                              {                                  m_encoder = new RawEncoder(Config.OutBatchSize' m_session' m_options.Endian);                                  m_decoder = new RawDecoder(Config.InBatchSize' m_options.MaxMessageSize' m_session' m_options.Endian);                                    Activate();                              }                              else                              {                                  m_state = State.Handshaking;                                  m_handshakeState = HandshakeState.Closed;                                  HandleHandshake(action' socketError' bytesTransferred);                              }                                break;                      }
Missing Default,NetMQ.Core.Transports,StreamEngine,C:\repos\zeromq_netmq\src\NetMQ\Core\Transports\StreamEngine.cs,Handle,The following switch statement is missing a default case: switch (action)                      {                          case Action.ActivateIn:                              // There was an input error but the engine could not                              // be terminated (due to the stalled decoder).                              // Flush the pending message and terminate the engine now.                              m_decoder.ProcessBuffer(m_inpos' 0);                              Debug.Assert(!m_decoder.Stalled());                              m_session.Flush();                              Error();                              break;                          case Action.ActivateOut:                              break;                      }
Missing Default,NetMQ.Core.Utils,ByteArrayEqualityComparer,C:\repos\zeromq_netmq\src\NetMQ\Core\Utils\ByteArrayEqualityComparer.cs,GetHashCode,The following switch statement is missing a default case: switch (remainder)                      {                          case 3:                              k ^= (uint)data[alignedLength + 2] << 16;                              goto case 2;                          case 2:                              k ^= (uint)data[alignedLength + 1] << 8;                              goto case 1;                          case 1:                              k ^= data[alignedLength];                              break;                      }
