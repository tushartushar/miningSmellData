Implementation smell,Namespace,Class,File,Method,Description
Long Method,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseStdoutLineNew,The method has 238 lines of code.
Long Method,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseStdoutLine,The method has 452 lines of code.
Long Method,Microsoft.Research.JobObjectModel,DryadLinqJobStaticPlan,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseQueryPlan,The method has 143 lines of code.
Long Method,Microsoft.Research.JobObjectModel,ScopeJobStaticPlan,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseAlgebra,The method has 152 lines of code.
Complex Method,Microsoft.Research.JobObjectModel,AzureDfsFile,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\ClusterAccess.cs,GetStream,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Research.JobObjectModel,AzureDfsClusterStatus,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\ClusterStatus.cs,GetJobInfo,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseStdout,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseJMLogs,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseJMLogFile,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Research.JobObjectModel,DryadLinqJobStaticPlan,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseQueryPlan,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Research.JobObjectModel,ScopeJobStaticPlan,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseAlgebra,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.Research.JobObjectModel,ScopeJobStaticPlan,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseVertexDef,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Research.JobObjectModel,ExecutedVertexInstance,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,SetTiming,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Research.JobObjectModel,ExecutedVertexInstance,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,DiscoverOriginalInfoChannels,Cyclomatic complexity of the method is 8
Long Parameter List,Microsoft.Research.JobObjectModel,AzureDfsFile,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\ClusterAccess.cs,AzureDfsFile,The method has 6 parameters. Parameters: config' job' client' path' canCache' isFolder
Long Parameter List,Microsoft.Research.JobObjectModel,DfsFile,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\ClusterAccess.cs,DfsFile,The method has 7 parameters. Parameters: config' jobFolderUri' job' client' path' canCache' isFolder
Long Parameter List,Microsoft.Research.JobObjectModel,ChannelEndpointDescription,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ChannelEndpointDescription,The method has 6 parameters. Parameters: isInput' number' uri' uripathprefix' fast' reporter
Long Parameter List,Microsoft.Research.JobObjectModel,ExecutedVertexInstance,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ExecutedVertexInstance,The method has 6 parameters. Parameters: job' number' version' name' uniqueId' timeStamp
Long Parameter List,Microsoft.Research.JobObjectModel,ExecutedVertexInstance,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,SetStartInformation,The method has 5 parameters. Parameters: job' machine' approxStartTime' identifier' uniqueId
Long Parameter List,Microsoft.Research.JobObjectModel,ExecutedVertexInstance,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,SetTiming,The method has 6 parameters. Parameters: creation' creatToScheduleTime' schedToStartProcessTime' startToCreatedProcessTime' processToRunTime' runToCompTime
Long Parameter List,Microsoft.Research.JobObjectModel,ExecutedVertexInstance,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,DiscoverOriginalInfoChannels,The method has 5 parameters. Parameters: sr' uriprefix' skip' fast' manager
Long Parameter List,Microsoft.Research.JobObjectModel,DryadLinqJobSummary,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\JobSummary.cs,DryadLinqJobSummary,The method has 12 parameters. Parameters: cluster' clusterType' virtualcluster' machine' jobId' clusterJobId' jmProcessGuid' friendlyname' username' date' endTime' status
Long Parameter List,Microsoft.Research.JobObjectModel,ClusterJobInformation,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\JobSummary.cs,ClusterJobInformation,The method has 8 parameters. Parameters: cluster' virtualCluster' clusterJobGuid' jobName' username' date' runningTime' status
Long Parameter List,Microsoft.Research.JobObjectModel,StaticPartitionedTableInformation,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\Storage.cs,StageOutput,The method has 5 parameters. Parameters: job' plan' source' status' showCancelled
Long Parameter List,Microsoft.Research.JobObjectModel,StaticPartitionedTableInformation,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\Storage.cs,StaticPartitionedTableInformation,The method has 5 parameters. Parameters: config' uriType' uri' code' statusReporter
Long Statement,Microsoft.Research.JobObjectModel,AzureDfsFile,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\ClusterAccess.cs,UriFromPath,The length of the statement  "            var retval = Microsoft.Research.Peloponnese.Azure.Utils.ToAzureUri(config.AccountName' config.Container' path' null' config.AccountKey); " is 136.
Long Statement,Microsoft.Research.JobObjectModel,AzureDfsFile,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\ClusterAccess.cs,GetFilesAndFolders,The length of the statement  "                var file = new AzureDfsFile(this.Config' this.Job' this.client' PathFromUri(this.Config as AzureDfsClusterConfiguration' child)' this.ShouldCacheLocally' isFolder); " is 164.
Long Statement,Microsoft.Research.JobObjectModel,DfsFile,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\ClusterAccess.cs,GetFilesAndFolders,The length of the statement  "                var file = new DfsFile(this.Config' this.baseUri' this.Job' this.client' PathFromUri(this.baseUri' child)' this.ShouldCacheLocally' isFolder); " is 142.
Long Statement,Microsoft.Research.JobObjectModel,LocalEmulator,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\ClusterConfiguration.cs,ProcessDirectory,The length of the statement  "                return new LocalFile(Utilities.PathCombine(this.JobsFolder' job.ClusterJobId' identifier.ProcessIdentifier' "Process.000.001")); " is 128.
Long Statement,Microsoft.Research.JobObjectModel,LocalEmulator,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\ClusterConfiguration.cs,JobQueryPlan,The length of the statement  "                IClusterResidentObject dir = this.ProcessWorkDirectory(job.ManagerProcessGuid' true' job.Machine' job); // this is missing at this point " is 136.
Long Statement,Microsoft.Research.JobObjectModel,LocalEmulator,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\ClusterConfiguration.cs,JobQueryPlan,The length of the statement  "                //IClusterResidentObject dir = this.ProcessWorkDirectory(new DryadProcessIdentifier("Process.000.001")' true' job.Machine' job); " is 128.
Long Statement,Microsoft.Research.JobObjectModel,AzureDfsClusterConfiguration,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\ClusterConfiguration.cs,Initialize,The length of the statement  "                this.baseUri = Microsoft.Research.Peloponnese.Azure.Utils.ToAzureUri(this.AccountName' this.Container' ""' null' this.AccountKey); " is 130.
Long Statement,Microsoft.Research.JobObjectModel,CacheClusterStatus,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\ClusterStatus.cs,RecomputeClusterJobList,The length of the statement  "                ClusterJobInformation ci = new ClusterJobInformation(this.Config.Name' job.Cluster' cjid' job.Name' job.User' job.Date' job.EndTime - job.Date' job.Status); " is 156.
Long Statement,Microsoft.Research.JobObjectModel,YarnEmulatedClusterStatus,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\ClusterStatus.cs,GetJobInfo,The length of the statement  "            ClusterJobInformation info = new ClusterJobInformation(this.config.Name' ""' jobId' jobId' Environment.UserName' date' TimeSpan.Zero' ClusterJobInformation.ClusterJobStatus.Unknown); " is 182.
Long Statement,Microsoft.Research.JobObjectModel,AzureDfsClusterStatus,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\ClusterStatus.cs,GetJobInfo,The length of the statement  "            var info = new ClusterJobInformation(this.config.Name' ""' jobRootFolder' jobName' Environment.UserName' date' running' status); " is 128.
Long Statement,Microsoft.Research.JobObjectModel,AzureDfsClusterStatus,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\ClusterStatus.cs,CancelJob,The length of the statement  "            Microsoft.Research.Peloponnese.Azure.Utils.KillJob(this.config.AccountName' this.config.AccountKey' this.config.Container' job.ClusterJobId); " is 141.
Long Statement,Microsoft.Research.JobObjectModel,WebHdfsClusterStatus,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\ClusterStatus.cs,GetJobInfo,The length of the statement  "            var info = new ClusterJobInformation(this.config.Name' ""' jobName' jobName' Environment.UserName' date' running' status); " is 122.
Long Statement,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,Initialize,The length of the statement  "            IClusterResidentObject managerstdoutfile = this.ClusterConfiguration.ProcessStdoutFile(summary.ManagerProcessGuid' terminated' summary.Machine' summary); " is 153.
Long Statement,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,Initialize,The length of the statement  "                IClusterResidentObject jmdir = this.ClusterConfiguration.ProcessDirectory(summary.ManagerProcessGuid' terminated' summary.Machine' summary); " is 140.
Long Statement,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,CollectEssentialInformation,The length of the statement  "                this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' this.Summary.Date' this.Summary.ManagerProcessGuid' ""); " is 123.
Long Statement,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,CollectEssentialInformation,The length of the statement  "                this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = this.Summary.Date; " is 130.
Long Statement,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseStdoutLineNew,The length of the statement  "                        this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = timeStamp; " is 122.
Long Statement,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseStdoutLine,The length of the statement  "                        // Created process execution record for vertices 192 (Merge__41[0]) 223 (Union__45[0]) v.0 GUID {0297A91C-FFEA-42EA-94AF-CD0163A04D45} " is 134.
Long Statement,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseStdoutLine,The length of the statement  "                // ---HiPriTime D7D51A1F-6693-4378-95FD-FC778A67C632'F52CA694-0202-411E-85E9-0C883E770A0E'SV4_Extract_Split[0]'Completed'ch1sch010331112'2011-05-03 15:26:01.681 PDT'2011-05-03 15:26:01.696 PDT'2011-05-03 15:26:02.118 PDT'2011-05-03 15:26:04.286 PDT'2011-05-03 15:26:07.656 PDT'2011-05-03 15:26:01.696 PDT'97390825'1498630 " is 321.
Long Statement,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseStdoutLine,The length of the statement  "                    // Process started for vertices 23 (Merge__29) 24 (Apply__33) v.0 GUID {E945DC5D-9AF6-4732-8770-2A6BF7FA3041} machine sherwood-237 " is 130.
Long Statement,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseStdoutLine,The length of the statement  "                // terminatedRegex = new Regex(@"Process was terminated Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) status (.*)"' " is 136.
Long Statement,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseStdoutLine,The length of the statement  "                // Process was terminated Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 status The operation succeeded " is 148.
Long Statement,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseStdoutLine,The length of the statement  "                DateTime createTime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value); " is 120.
Long Statement,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseStdoutLine,The length of the statement  "                this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime; " is 123.
Long Statement,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseStdoutLine,The length of the statement  "                    this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime; " is 123.
Long Statement,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseStdoutLine,The length of the statement  "                    DateTime createtime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[4].Value); " is 120.
Long Statement,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseStdoutLine,The length of the statement  "                    DateTime last = vi.SetTiming(createtime' m.Groups[5].Value' m.Groups[6].Value' m.Groups[7].Value' m.Groups[8].Value' m.Groups[9].Value); " is 136.
Long Statement,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseStdoutLine,The length of the statement  "                // Process has failed Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 Exitcode 0 status The operation succeeded " is 155.
Long Statement,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseStdoutLine,The length of the statement  "                // failedRegex = new Regex(@"Process has failed Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) Exitcode (.*)"' " is 130.
Long Statement,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseJMLogs,The length of the statement  "            IClusterResidentObject dir = this.ClusterConfiguration.ProcessLogDirectory(this.Summary.ManagerProcessGuid' this.ManagerVertex.VertexIsCompleted' this.Summary.Machine' this.Summary); " is 182.
Long Statement,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseJMLogFile,The length of the statement  "                    // Vertex=69.0' Name=Merge__446[3]' MachPod=sherwood-005:pod1' TotalRead=1470802' TotalReadFromMach=1470802' TotalReadCrossMach=1470802' TotalReadCrossPod=0 " is 156.
Long Statement,Microsoft.Research.JobObjectModel,ScopeJobStaticPlan,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseAlgebra,The length of the statement  "            Dictionary<string' string> outToStage = new Dictionary<string' string>(); // map an output to a stage name. Assume that ios have unique names. " is 142.
Long Statement,Microsoft.Research.JobObjectModel,ChannelEndpointDescription,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ToString,The length of the statement  "                return string.Format("{0'4} {1'20:N0}/{2'20:N0} {3}://{4}"' this.Number' this.Size' this.TotalSize' uritype' localpath); " is 120.
Long Statement,Microsoft.Research.JobObjectModel,ExecutedVertexInstance,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,SetStartInformation,The length of the statement  "            this.WorkDirectory = job.ClusterConfiguration.ProcessWorkDirectory(this.ProcessIdentifier' false' machine' job.Summary); " is 120.
Long Statement,Microsoft.Research.JobObjectModel,ExecutedVertexInstance,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,AsCSV,The length of the statement  "                this.Name' this.StageName' start' end' running' this.State' this.DataRead' this.DataWritten' this.Version' this.Machine' this.ProcessIdentifier); " is 145.
Long Statement,Microsoft.Research.JobObjectModel,DryadLinqJobSummary,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\JobSummary.cs,GetHashCode,The length of the statement  "            return this.ClusterJobId.GetHashCode() ^ this.ClusterJobId.GetHashCode() ^ this.Date.GetHashCode() ^ this.Machine.GetHashCode() ^ this.Name.GetHashCode() ^ this.User.GetHashCode(); " is 180.
Long Statement,Microsoft.Research.JobObjectModel,StaticPartitionedTableInformation,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\Storage.cs,StageOutput,The length of the statement  "                StaticPartitionedTableInformation result = new StaticPartitionedTableInformation(job.ClusterConfiguration' source.UriType' source.Uri' source.Code' status); " is 156.
Long Statement,Microsoft.Research.JobObjectModel,StaticPartitionedTableInformation,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\Storage.cs,Refresh,The length of the statement  "                return new StaticPartitionedTableInformation(this.Config' this.UriType' this.Uri' this.constructorArguments.code' statusReporter); " is 130.
Long Statement,Microsoft.Research.JobObjectModel,StaticPartitionedTableInformation,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\Storage.cs,Refresh,The length of the statement  "                return StageOutput(job' this.constructorArguments.plan' this.constructorArguments.source' statusReporter' showCancelled); " is 121.
Complex Conditional,Microsoft.Research.JobObjectModel,ExecutedVertexInstance,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,DiscoverChannels,The conditional expression  "(this.InputChannels != null || !inputs) &&                  (this.OutputChannels != null || !outputs)"  is complex.
Complex Conditional,Microsoft.Research.JobObjectModel,StaticPartitionedTableInformation,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\Storage.cs,StageOutput,The conditional expression  "vi.State == ExecutedVertexInstance.VertexState.Successful ||                          vi.State == ExecutedVertexInstance.VertexState.Failed ||                          (showCancelled && vi.State == ExecutedVertexInstance.VertexState.Cancelled)"  is complex.
Virtual Method Call from Constructor,Microsoft.Research.JobObjectModel,DryadLogEntry,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\dryadlog.cs,DryadLogEntry,The constructor "DryadLogEntry" calls a virtual method "Parse".
Empty Catch Block,Microsoft.Research.JobObjectModel,WebHdfsClusterStatus,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\ClusterStatus.cs,GetJobInfo,The method has an empty catch block.
Empty Catch Block,Microsoft.Research.JobObjectModel,HdfsClusterStatus,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\ClusterStatus.cs,GetJobInfo,The method has an empty catch block.
Magic Number,Microsoft.Research.JobObjectModel,AzureDfsFile,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\ClusterAccess.cs,GetStream,The following statement contains a magic number: int bufferSize = 1024*1024;
Magic Number,Microsoft.Research.JobObjectModel,AzureDfsFile,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\ClusterAccess.cs,GetStream,The following statement contains a magic number: int bufferSize = 1024*1024;
Magic Number,Microsoft.Research.JobObjectModel,AzureDfsFile,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\ClusterAccess.cs,GetStream,The following statement contains a magic number: if (sz >= 0)              {                  bufferSize = (int)(sz/10);                  if (bufferSize < 1024*1024)                      bufferSize = 1024*1024;                  if (bufferSize > 20*1024*1024)                      bufferSize = 20*1024*1024;              }
Magic Number,Microsoft.Research.JobObjectModel,AzureDfsFile,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\ClusterAccess.cs,GetStream,The following statement contains a magic number: if (sz >= 0)              {                  bufferSize = (int)(sz/10);                  if (bufferSize < 1024*1024)                      bufferSize = 1024*1024;                  if (bufferSize > 20*1024*1024)                      bufferSize = 20*1024*1024;              }
Magic Number,Microsoft.Research.JobObjectModel,AzureDfsFile,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\ClusterAccess.cs,GetStream,The following statement contains a magic number: if (sz >= 0)              {                  bufferSize = (int)(sz/10);                  if (bufferSize < 1024*1024)                      bufferSize = 1024*1024;                  if (bufferSize > 20*1024*1024)                      bufferSize = 20*1024*1024;              }
Magic Number,Microsoft.Research.JobObjectModel,AzureDfsFile,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\ClusterAccess.cs,GetStream,The following statement contains a magic number: if (sz >= 0)              {                  bufferSize = (int)(sz/10);                  if (bufferSize < 1024*1024)                      bufferSize = 1024*1024;                  if (bufferSize > 20*1024*1024)                      bufferSize = 20*1024*1024;              }
Magic Number,Microsoft.Research.JobObjectModel,AzureDfsFile,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\ClusterAccess.cs,GetStream,The following statement contains a magic number: if (sz >= 0)              {                  bufferSize = (int)(sz/10);                  if (bufferSize < 1024*1024)                      bufferSize = 1024*1024;                  if (bufferSize > 20*1024*1024)                      bufferSize = 20*1024*1024;              }
Magic Number,Microsoft.Research.JobObjectModel,AzureDfsFile,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\ClusterAccess.cs,GetStream,The following statement contains a magic number: if (sz >= 0)              {                  bufferSize = (int)(sz/10);                  if (bufferSize < 1024*1024)                      bufferSize = 1024*1024;                  if (bufferSize > 20*1024*1024)                      bufferSize = 20*1024*1024;              }
Magic Number,Microsoft.Research.JobObjectModel,AzureDfsFile,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\ClusterAccess.cs,GetStream,The following statement contains a magic number: if (sz >= 0)              {                  bufferSize = (int)(sz/10);                  if (bufferSize < 1024*1024)                      bufferSize = 1024*1024;                  if (bufferSize > 20*1024*1024)                      bufferSize = 20*1024*1024;              }
Magic Number,Microsoft.Research.JobObjectModel,AzureDfsFile,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\ClusterAccess.cs,GetStream,The following statement contains a magic number: if (sz >= 0)              {                  bufferSize = (int)(sz/10);                  if (bufferSize < 1024*1024)                      bufferSize = 1024*1024;                  if (bufferSize > 20*1024*1024)                      bufferSize = 20*1024*1024;              }
Magic Number,Microsoft.Research.JobObjectModel,AzureDfsFile,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\ClusterAccess.cs,GetStream,The following statement contains a magic number: if (sz >= 0)              {                  bufferSize = (int)(sz/10);                  if (bufferSize < 1024*1024)                      bufferSize = 1024*1024;                  if (bufferSize > 20*1024*1024)                      bufferSize = 20*1024*1024;              }
Magic Number,Microsoft.Research.JobObjectModel,AzureDfsFile,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\ClusterAccess.cs,GetStream,The following statement contains a magic number: if (sz >= 0)              {                  bufferSize = (int)(sz/10);                  if (bufferSize < 1024*1024)                      bufferSize = 1024*1024;                  if (bufferSize > 20*1024*1024)                      bufferSize = 20*1024*1024;              }
Magic Number,Microsoft.Research.JobObjectModel,AzureDfsFile,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\ClusterAccess.cs,GetStream,The following statement contains a magic number: if (sz >= 0)              {                  bufferSize = (int)(sz/10);                  if (bufferSize < 1024*1024)                      bufferSize = 1024*1024;                  if (bufferSize > 20*1024*1024)                      bufferSize = 20*1024*1024;              }
Magic Number,Microsoft.Research.JobObjectModel,DfsFile,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\ClusterAccess.cs,GetStream,The following statement contains a magic number: int bufferSize = 1024 * 1024;
Magic Number,Microsoft.Research.JobObjectModel,DfsFile,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\ClusterAccess.cs,GetStream,The following statement contains a magic number: int bufferSize = 1024 * 1024;
Magic Number,Microsoft.Research.JobObjectModel,DfsFile,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\ClusterAccess.cs,GetStream,The following statement contains a magic number: if (sz >= 0)              {                  bufferSize = (int)(sz / 10);                  if (bufferSize < 1024 * 1024)                      bufferSize = 1024 * 1024;                  if (bufferSize > 20 * 1024 * 1024)                      bufferSize = 20 * 1024 * 1024;              }
Magic Number,Microsoft.Research.JobObjectModel,DfsFile,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\ClusterAccess.cs,GetStream,The following statement contains a magic number: if (sz >= 0)              {                  bufferSize = (int)(sz / 10);                  if (bufferSize < 1024 * 1024)                      bufferSize = 1024 * 1024;                  if (bufferSize > 20 * 1024 * 1024)                      bufferSize = 20 * 1024 * 1024;              }
Magic Number,Microsoft.Research.JobObjectModel,DfsFile,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\ClusterAccess.cs,GetStream,The following statement contains a magic number: if (sz >= 0)              {                  bufferSize = (int)(sz / 10);                  if (bufferSize < 1024 * 1024)                      bufferSize = 1024 * 1024;                  if (bufferSize > 20 * 1024 * 1024)                      bufferSize = 20 * 1024 * 1024;              }
Magic Number,Microsoft.Research.JobObjectModel,DfsFile,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\ClusterAccess.cs,GetStream,The following statement contains a magic number: if (sz >= 0)              {                  bufferSize = (int)(sz / 10);                  if (bufferSize < 1024 * 1024)                      bufferSize = 1024 * 1024;                  if (bufferSize > 20 * 1024 * 1024)                      bufferSize = 20 * 1024 * 1024;              }
Magic Number,Microsoft.Research.JobObjectModel,DfsFile,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\ClusterAccess.cs,GetStream,The following statement contains a magic number: if (sz >= 0)              {                  bufferSize = (int)(sz / 10);                  if (bufferSize < 1024 * 1024)                      bufferSize = 1024 * 1024;                  if (bufferSize > 20 * 1024 * 1024)                      bufferSize = 20 * 1024 * 1024;              }
Magic Number,Microsoft.Research.JobObjectModel,DfsFile,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\ClusterAccess.cs,GetStream,The following statement contains a magic number: if (sz >= 0)              {                  bufferSize = (int)(sz / 10);                  if (bufferSize < 1024 * 1024)                      bufferSize = 1024 * 1024;                  if (bufferSize > 20 * 1024 * 1024)                      bufferSize = 20 * 1024 * 1024;              }
Magic Number,Microsoft.Research.JobObjectModel,DfsFile,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\ClusterAccess.cs,GetStream,The following statement contains a magic number: if (sz >= 0)              {                  bufferSize = (int)(sz / 10);                  if (bufferSize < 1024 * 1024)                      bufferSize = 1024 * 1024;                  if (bufferSize > 20 * 1024 * 1024)                      bufferSize = 20 * 1024 * 1024;              }
Magic Number,Microsoft.Research.JobObjectModel,DfsFile,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\ClusterAccess.cs,GetStream,The following statement contains a magic number: if (sz >= 0)              {                  bufferSize = (int)(sz / 10);                  if (bufferSize < 1024 * 1024)                      bufferSize = 1024 * 1024;                  if (bufferSize > 20 * 1024 * 1024)                      bufferSize = 20 * 1024 * 1024;              }
Magic Number,Microsoft.Research.JobObjectModel,DfsFile,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\ClusterAccess.cs,GetStream,The following statement contains a magic number: if (sz >= 0)              {                  bufferSize = (int)(sz / 10);                  if (bufferSize < 1024 * 1024)                      bufferSize = 1024 * 1024;                  if (bufferSize > 20 * 1024 * 1024)                      bufferSize = 20 * 1024 * 1024;              }
Magic Number,Microsoft.Research.JobObjectModel,DfsFile,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\ClusterAccess.cs,GetStream,The following statement contains a magic number: if (sz >= 0)              {                  bufferSize = (int)(sz / 10);                  if (bufferSize < 1024 * 1024)                      bufferSize = 1024 * 1024;                  if (bufferSize > 20 * 1024 * 1024)                      bufferSize = 20 * 1024 * 1024;              }
Magic Number,Microsoft.Research.JobObjectModel,DfsFile,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\ClusterAccess.cs,GetStream,The following statement contains a magic number: if (sz >= 0)              {                  bufferSize = (int)(sz / 10);                  if (bufferSize < 1024 * 1024)                      bufferSize = 1024 * 1024;                  if (bufferSize > 20 * 1024 * 1024)                      bufferSize = 20 * 1024 * 1024;              }
Magic Number,Microsoft.Research.JobObjectModel,ClusterConfiguration,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\ClusterConfiguration.cs,EnumerateSubscribedClusters,The following statement contains a magic number: try              {                  Work work = AzureDfsClusterConfiguration.EnumerateAzureDfsSubscribedClusters;                  IAsyncResult result = work.BeginInvoke(null' null);                  if (result.IsCompleted == false)                  {                      result.AsyncWaitHandle.WaitOne(3000' false);                      if (result.IsCompleted == false)                          throw new ApplicationException("Timeout scanning Azure clusters");                  }                  list = (List<ClusterConfiguration>)work.EndInvoke(result);              }              catch (Exception ex)              {                  Console.WriteLine("Exception enumerating DFS clusters: " + ex);              }
Magic Number,Microsoft.Research.JobObjectModel,CacheClusterStatus,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\ClusterStatus.cs,RecomputeClusterJobList,The following statement contains a magic number: manager.Progress(100);
Magic Number,Microsoft.Research.JobObjectModel,YarnEmulatedClusterStatus,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\ClusterStatus.cs,RecomputeClusterJobList,The following statement contains a magic number: foreach (var job in subfolders)              {                  manager.Token.ThrowIfCancellationRequested();                  string jobId = Path.GetFileName(job);                  ClusterJobInformation info = this.GetJobInfo(job' jobId);                  if (info != null)                  {                      // ReSharper disable once AssignNullToNotNullAttribute                      this.clusterJobs.Add(jobId' info);                  }                  manager.Progress(done++ *100/subfolders.Length);              }
Magic Number,Microsoft.Research.JobObjectModel,YarnEmulatedClusterStatus,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\ClusterStatus.cs,RecomputeClusterJobList,The following statement contains a magic number: manager.Progress(100);
Magic Number,Microsoft.Research.JobObjectModel,AzureDfsClusterStatus,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\ClusterStatus.cs,RecomputeClusterJobList,The following statement contains a magic number: foreach (var job in jobs)              {                  manager.Token.ThrowIfCancellationRequested();                  string jobRootFolder = AzureDfsFile.PathFromUri(this.config' job);                  ClusterJobInformation info = this.GetJobInfo(jobRootFolder);                  if (info != null)                  {                      // ReSharper disable once AssignNullToNotNullAttribute                      this.clusterJobs.Add(job.AbsolutePath' info);                  }                  manager.Progress(100*done++/jobs.Count);              }
Magic Number,Microsoft.Research.JobObjectModel,AzureDfsClusterStatus,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\ClusterStatus.cs,RecomputeClusterJobList,The following statement contains a magic number: manager.Progress(100);
Magic Number,Microsoft.Research.JobObjectModel,AzureDfsClusterStatus,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\ClusterStatus.cs,GetBlobName,The following statement contains a magic number: if (path.StartsWith("/" + container + "/"))                  path = path.Substring(container.Length + 2);
Magic Number,Microsoft.Research.JobObjectModel,AzureDfsClusterStatus,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\ClusterStatus.cs,GetJobInfo,The following statement contains a magic number: foreach (var file in jobsFolders)              {                  if (file.AbsolutePath.EndsWith("heartbeat"))                  {                      string blobName = GetBlobName(this.config.Container' file.AbsolutePath);                      var blob = this.config.AzureClient.Container.GetPageBlobReference(blobName);                      blob.FetchAttributes();                      var props = blob.Metadata;                      if (props.ContainsKey("status"))                      {                          var st = props["status"];                          switch (st)                          {                              case "failure":                                  status = ClusterJobInformation.ClusterJobStatus.Failed;                                  break;                              case "success":                                  status = ClusterJobInformation.ClusterJobStatus.Succeeded;                                  break;                              case "running":                                  status = ClusterJobInformation.ClusterJobStatus.Running;                                  break;                              case "killed":                                  status = ClusterJobInformation.ClusterJobStatus.Cancelled;                                  break;                              default:                                  Console.WriteLine("Unknown status " + st);                                  break;                          }                      }                      if (props.ContainsKey("heartbeat"))                      {                          var hb = props["heartbeat"];                          if (DateTime.TryParse(hb' out lastHeartBeat))                          {                              lastHeartBeat = lastHeartBeat.ToLocalTime();                              if (status == ClusterJobInformation.ClusterJobStatus.Running &&                                  DateTime.Now - lastHeartBeat > TimeSpan.FromSeconds(40))                                  // job has in fact crashed                                  status = ClusterJobInformation.ClusterJobStatus.Failed;                          }                      }                      if (props.ContainsKey("jobname"))                      {                          jobName = props["jobname"];                      }                      if (props.ContainsKey("starttime"))                      {                          var t = props["starttime"];                          if (DateTime.TryParse(t' out date))                              date = date.ToLocalTime();                      }                                            found = true;                  }                  else if (file.AbsolutePath.Contains("DryadLinqProgram__") &&                       // newer heartbeats contain the date                      date != DateTime.MinValue)                  {                      var blob = this.config.AzureClient.Container.GetBlockBlobReference(AzureDfsFile.PathFromUri(this.config' file));                      blob.FetchAttributes();                      var props = blob.Properties;                      if (props.LastModified.HasValue)                      {                          date = props.LastModified.Value.DateTime;                          date = date.ToLocalTime();                      }                  }              }
Magic Number,Microsoft.Research.JobObjectModel,WebHdfsClusterStatus,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\ClusterStatus.cs,RecomputeClusterJobList,The following statement contains a magic number: foreach (var job in jobs)              {                  manager.Token.ThrowIfCancellationRequested();                  ClusterJobInformation info = this.GetJobInfo(DfsFile.PathFromUri(this.config.JobsFolderUri' job));                  if (info != null)                  {                      // ReSharper disable once AssignNullToNotNullAttribute                      this.clusterJobs.Add(info.ClusterJobID' info);                  }                  manager.Progress(100 * done++ / jobs.Count);              }
Magic Number,Microsoft.Research.JobObjectModel,WebHdfsClusterStatus,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\ClusterStatus.cs,RecomputeClusterJobList,The following statement contains a magic number: manager.Progress(100);
Magic Number,Microsoft.Research.JobObjectModel,HdfsClusterStatus,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\ClusterStatus.cs,RecomputeClusterJobList,The following statement contains a magic number: foreach (var job in jobs)              {                  manager.Token.ThrowIfCancellationRequested();                  ClusterJobInformation info = this.GetJobInfo(DfsFile.PathFromUri(this.config.JobsFolderUri' job));                  if (info != null)                  {                      // ReSharper disable once AssignNullToNotNullAttribute                      this.clusterJobs.Add(info.ClusterJobID' info);                  }                  manager.Progress(100 * done++ / jobs.Count);              }
Magic Number,Microsoft.Research.JobObjectModel,HdfsClusterStatus,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\ClusterStatus.cs,RecomputeClusterJobList,The following statement contains a magic number: manager.Progress(100);
Magic Number,Microsoft.Research.JobObjectModel,DryadLogEntry,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\dryadlog.cs,Parse,The following statement contains a magic number: if (m.Success)              {                  this.Severity = m.Groups[1].Value.ToCharArray()[0];                  this.Timestamp = DateTime.Parse(m.Groups[2].Value);                  this.Subsystem = m.Groups[3].Value;                  this.Message = m.Groups[4].Value;                  this.SourceFile = m.Groups[5].Value;                  this.SourceFunction = m.Groups[6].Value;                  this.SourceLineNumber = Int32.Parse(m.Groups[7].Value);                  this.ProcessId = Int32.Parse(m.Groups[8].Value);                  this.ThreadId = Int32.Parse(m.Groups[9].Value);                  if (m.Groups.Count >= 12)                      // the String1 may be missing                      this.ExtraInfo = m.Groups[12].Value;                  else                      this.ExtraInfo = "";                  this.Malformed = false;              }              else              {                  Trace.TraceInformation("Could not parse line as cosmos log entry:" + line);              }
Magic Number,Microsoft.Research.JobObjectModel,DryadLogEntry,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\dryadlog.cs,Parse,The following statement contains a magic number: if (m.Success)              {                  this.Severity = m.Groups[1].Value.ToCharArray()[0];                  this.Timestamp = DateTime.Parse(m.Groups[2].Value);                  this.Subsystem = m.Groups[3].Value;                  this.Message = m.Groups[4].Value;                  this.SourceFile = m.Groups[5].Value;                  this.SourceFunction = m.Groups[6].Value;                  this.SourceLineNumber = Int32.Parse(m.Groups[7].Value);                  this.ProcessId = Int32.Parse(m.Groups[8].Value);                  this.ThreadId = Int32.Parse(m.Groups[9].Value);                  if (m.Groups.Count >= 12)                      // the String1 may be missing                      this.ExtraInfo = m.Groups[12].Value;                  else                      this.ExtraInfo = "";                  this.Malformed = false;              }              else              {                  Trace.TraceInformation("Could not parse line as cosmos log entry:" + line);              }
Magic Number,Microsoft.Research.JobObjectModel,DryadLogEntry,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\dryadlog.cs,Parse,The following statement contains a magic number: if (m.Success)              {                  this.Severity = m.Groups[1].Value.ToCharArray()[0];                  this.Timestamp = DateTime.Parse(m.Groups[2].Value);                  this.Subsystem = m.Groups[3].Value;                  this.Message = m.Groups[4].Value;                  this.SourceFile = m.Groups[5].Value;                  this.SourceFunction = m.Groups[6].Value;                  this.SourceLineNumber = Int32.Parse(m.Groups[7].Value);                  this.ProcessId = Int32.Parse(m.Groups[8].Value);                  this.ThreadId = Int32.Parse(m.Groups[9].Value);                  if (m.Groups.Count >= 12)                      // the String1 may be missing                      this.ExtraInfo = m.Groups[12].Value;                  else                      this.ExtraInfo = "";                  this.Malformed = false;              }              else              {                  Trace.TraceInformation("Could not parse line as cosmos log entry:" + line);              }
Magic Number,Microsoft.Research.JobObjectModel,DryadLogEntry,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\dryadlog.cs,Parse,The following statement contains a magic number: if (m.Success)              {                  this.Severity = m.Groups[1].Value.ToCharArray()[0];                  this.Timestamp = DateTime.Parse(m.Groups[2].Value);                  this.Subsystem = m.Groups[3].Value;                  this.Message = m.Groups[4].Value;                  this.SourceFile = m.Groups[5].Value;                  this.SourceFunction = m.Groups[6].Value;                  this.SourceLineNumber = Int32.Parse(m.Groups[7].Value);                  this.ProcessId = Int32.Parse(m.Groups[8].Value);                  this.ThreadId = Int32.Parse(m.Groups[9].Value);                  if (m.Groups.Count >= 12)                      // the String1 may be missing                      this.ExtraInfo = m.Groups[12].Value;                  else                      this.ExtraInfo = "";                  this.Malformed = false;              }              else              {                  Trace.TraceInformation("Could not parse line as cosmos log entry:" + line);              }
Magic Number,Microsoft.Research.JobObjectModel,DryadLogEntry,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\dryadlog.cs,Parse,The following statement contains a magic number: if (m.Success)              {                  this.Severity = m.Groups[1].Value.ToCharArray()[0];                  this.Timestamp = DateTime.Parse(m.Groups[2].Value);                  this.Subsystem = m.Groups[3].Value;                  this.Message = m.Groups[4].Value;                  this.SourceFile = m.Groups[5].Value;                  this.SourceFunction = m.Groups[6].Value;                  this.SourceLineNumber = Int32.Parse(m.Groups[7].Value);                  this.ProcessId = Int32.Parse(m.Groups[8].Value);                  this.ThreadId = Int32.Parse(m.Groups[9].Value);                  if (m.Groups.Count >= 12)                      // the String1 may be missing                      this.ExtraInfo = m.Groups[12].Value;                  else                      this.ExtraInfo = "";                  this.Malformed = false;              }              else              {                  Trace.TraceInformation("Could not parse line as cosmos log entry:" + line);              }
Magic Number,Microsoft.Research.JobObjectModel,DryadLogEntry,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\dryadlog.cs,Parse,The following statement contains a magic number: if (m.Success)              {                  this.Severity = m.Groups[1].Value.ToCharArray()[0];                  this.Timestamp = DateTime.Parse(m.Groups[2].Value);                  this.Subsystem = m.Groups[3].Value;                  this.Message = m.Groups[4].Value;                  this.SourceFile = m.Groups[5].Value;                  this.SourceFunction = m.Groups[6].Value;                  this.SourceLineNumber = Int32.Parse(m.Groups[7].Value);                  this.ProcessId = Int32.Parse(m.Groups[8].Value);                  this.ThreadId = Int32.Parse(m.Groups[9].Value);                  if (m.Groups.Count >= 12)                      // the String1 may be missing                      this.ExtraInfo = m.Groups[12].Value;                  else                      this.ExtraInfo = "";                  this.Malformed = false;              }              else              {                  Trace.TraceInformation("Could not parse line as cosmos log entry:" + line);              }
Magic Number,Microsoft.Research.JobObjectModel,DryadLogEntry,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\dryadlog.cs,Parse,The following statement contains a magic number: if (m.Success)              {                  this.Severity = m.Groups[1].Value.ToCharArray()[0];                  this.Timestamp = DateTime.Parse(m.Groups[2].Value);                  this.Subsystem = m.Groups[3].Value;                  this.Message = m.Groups[4].Value;                  this.SourceFile = m.Groups[5].Value;                  this.SourceFunction = m.Groups[6].Value;                  this.SourceLineNumber = Int32.Parse(m.Groups[7].Value);                  this.ProcessId = Int32.Parse(m.Groups[8].Value);                  this.ThreadId = Int32.Parse(m.Groups[9].Value);                  if (m.Groups.Count >= 12)                      // the String1 may be missing                      this.ExtraInfo = m.Groups[12].Value;                  else                      this.ExtraInfo = "";                  this.Malformed = false;              }              else              {                  Trace.TraceInformation("Could not parse line as cosmos log entry:" + line);              }
Magic Number,Microsoft.Research.JobObjectModel,DryadLogEntry,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\dryadlog.cs,Parse,The following statement contains a magic number: if (m.Success)              {                  this.Severity = m.Groups[1].Value.ToCharArray()[0];                  this.Timestamp = DateTime.Parse(m.Groups[2].Value);                  this.Subsystem = m.Groups[3].Value;                  this.Message = m.Groups[4].Value;                  this.SourceFile = m.Groups[5].Value;                  this.SourceFunction = m.Groups[6].Value;                  this.SourceLineNumber = Int32.Parse(m.Groups[7].Value);                  this.ProcessId = Int32.Parse(m.Groups[8].Value);                  this.ThreadId = Int32.Parse(m.Groups[9].Value);                  if (m.Groups.Count >= 12)                      // the String1 may be missing                      this.ExtraInfo = m.Groups[12].Value;                  else                      this.ExtraInfo = "";                  this.Malformed = false;              }              else              {                  Trace.TraceInformation("Could not parse line as cosmos log entry:" + line);              }
Magic Number,Microsoft.Research.JobObjectModel,DryadLogEntry,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\dryadlog.cs,Parse,The following statement contains a magic number: if (m.Success)              {                  this.Severity = m.Groups[1].Value.ToCharArray()[0];                  this.Timestamp = DateTime.Parse(m.Groups[2].Value);                  this.Subsystem = m.Groups[3].Value;                  this.Message = m.Groups[4].Value;                  this.SourceFile = m.Groups[5].Value;                  this.SourceFunction = m.Groups[6].Value;                  this.SourceLineNumber = Int32.Parse(m.Groups[7].Value);                  this.ProcessId = Int32.Parse(m.Groups[8].Value);                  this.ThreadId = Int32.Parse(m.Groups[9].Value);                  if (m.Groups.Count >= 12)                      // the String1 may be missing                      this.ExtraInfo = m.Groups[12].Value;                  else                      this.ExtraInfo = "";                  this.Malformed = false;              }              else              {                  Trace.TraceInformation("Could not parse line as cosmos log entry:" + line);              }
Magic Number,Microsoft.Research.JobObjectModel,DryadLogEntry,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\dryadlog.cs,Parse,The following statement contains a magic number: if (m.Success)              {                  this.Severity = m.Groups[1].Value.ToCharArray()[0];                  this.Timestamp = DateTime.Parse(m.Groups[2].Value);                  this.Subsystem = m.Groups[3].Value;                  this.Message = m.Groups[4].Value;                  this.SourceFile = m.Groups[5].Value;                  this.SourceFunction = m.Groups[6].Value;                  this.SourceLineNumber = Int32.Parse(m.Groups[7].Value);                  this.ProcessId = Int32.Parse(m.Groups[8].Value);                  this.ThreadId = Int32.Parse(m.Groups[9].Value);                  if (m.Groups.Count >= 12)                      // the String1 may be missing                      this.ExtraInfo = m.Groups[12].Value;                  else                      this.ExtraInfo = "";                  this.Malformed = false;              }              else              {                  Trace.TraceInformation("Could not parse line as cosmos log entry:" + line);              }
Magic Number,Microsoft.Research.JobObjectModel,ExtendedLogEntry,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\dryadlog.cs,Parse,The following statement contains a magic number: if (m.Success)              {                  try                  {                      this.Guid = m.Groups[1].Value;                      this.Machine = m.Groups[2].Value;                        this.Severity = m.Groups[3].Value.ToCharArray()[0];                      this.Timestamp = DateTime.Parse(m.Groups[4].Value);                      this.Subsystem = m.Groups[5].Value;                      this.Message = m.Groups[6].Value;                      this.SourceFile = m.Groups[7].Value;                      this.SourceFunction = m.Groups[8].Value;                      this.SourceLineNumber = Int32.Parse(m.Groups[9].Value);                      this.ProcessId = Int32.Parse(m.Groups[10].Value);                      this.ThreadId = Int32.Parse(m.Groups[11].Value);                      if (m.Groups.Count >= 14)                          // the String1 may be missing                          this.ExtraInfo = m.Groups[14].Value;                      else                          this.ExtraInfo = "";                      this.Malformed = false;                  }                  catch (FormatException)                  {                      Trace.TraceInformation("Failed to parse as extended log entry: {0}"' line);                      this.Malformed = true;                  }              }              else this.Malformed = true;
Magic Number,Microsoft.Research.JobObjectModel,ExtendedLogEntry,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\dryadlog.cs,Parse,The following statement contains a magic number: if (m.Success)              {                  try                  {                      this.Guid = m.Groups[1].Value;                      this.Machine = m.Groups[2].Value;                        this.Severity = m.Groups[3].Value.ToCharArray()[0];                      this.Timestamp = DateTime.Parse(m.Groups[4].Value);                      this.Subsystem = m.Groups[5].Value;                      this.Message = m.Groups[6].Value;                      this.SourceFile = m.Groups[7].Value;                      this.SourceFunction = m.Groups[8].Value;                      this.SourceLineNumber = Int32.Parse(m.Groups[9].Value);                      this.ProcessId = Int32.Parse(m.Groups[10].Value);                      this.ThreadId = Int32.Parse(m.Groups[11].Value);                      if (m.Groups.Count >= 14)                          // the String1 may be missing                          this.ExtraInfo = m.Groups[14].Value;                      else                          this.ExtraInfo = "";                      this.Malformed = false;                  }                  catch (FormatException)                  {                      Trace.TraceInformation("Failed to parse as extended log entry: {0}"' line);                      this.Malformed = true;                  }              }              else this.Malformed = true;
Magic Number,Microsoft.Research.JobObjectModel,ExtendedLogEntry,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\dryadlog.cs,Parse,The following statement contains a magic number: if (m.Success)              {                  try                  {                      this.Guid = m.Groups[1].Value;                      this.Machine = m.Groups[2].Value;                        this.Severity = m.Groups[3].Value.ToCharArray()[0];                      this.Timestamp = DateTime.Parse(m.Groups[4].Value);                      this.Subsystem = m.Groups[5].Value;                      this.Message = m.Groups[6].Value;                      this.SourceFile = m.Groups[7].Value;                      this.SourceFunction = m.Groups[8].Value;                      this.SourceLineNumber = Int32.Parse(m.Groups[9].Value);                      this.ProcessId = Int32.Parse(m.Groups[10].Value);                      this.ThreadId = Int32.Parse(m.Groups[11].Value);                      if (m.Groups.Count >= 14)                          // the String1 may be missing                          this.ExtraInfo = m.Groups[14].Value;                      else                          this.ExtraInfo = "";                      this.Malformed = false;                  }                  catch (FormatException)                  {                      Trace.TraceInformation("Failed to parse as extended log entry: {0}"' line);                      this.Malformed = true;                  }              }              else this.Malformed = true;
Magic Number,Microsoft.Research.JobObjectModel,ExtendedLogEntry,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\dryadlog.cs,Parse,The following statement contains a magic number: if (m.Success)              {                  try                  {                      this.Guid = m.Groups[1].Value;                      this.Machine = m.Groups[2].Value;                        this.Severity = m.Groups[3].Value.ToCharArray()[0];                      this.Timestamp = DateTime.Parse(m.Groups[4].Value);                      this.Subsystem = m.Groups[5].Value;                      this.Message = m.Groups[6].Value;                      this.SourceFile = m.Groups[7].Value;                      this.SourceFunction = m.Groups[8].Value;                      this.SourceLineNumber = Int32.Parse(m.Groups[9].Value);                      this.ProcessId = Int32.Parse(m.Groups[10].Value);                      this.ThreadId = Int32.Parse(m.Groups[11].Value);                      if (m.Groups.Count >= 14)                          // the String1 may be missing                          this.ExtraInfo = m.Groups[14].Value;                      else                          this.ExtraInfo = "";                      this.Malformed = false;                  }                  catch (FormatException)                  {                      Trace.TraceInformation("Failed to parse as extended log entry: {0}"' line);                      this.Malformed = true;                  }              }              else this.Malformed = true;
Magic Number,Microsoft.Research.JobObjectModel,ExtendedLogEntry,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\dryadlog.cs,Parse,The following statement contains a magic number: if (m.Success)              {                  try                  {                      this.Guid = m.Groups[1].Value;                      this.Machine = m.Groups[2].Value;                        this.Severity = m.Groups[3].Value.ToCharArray()[0];                      this.Timestamp = DateTime.Parse(m.Groups[4].Value);                      this.Subsystem = m.Groups[5].Value;                      this.Message = m.Groups[6].Value;                      this.SourceFile = m.Groups[7].Value;                      this.SourceFunction = m.Groups[8].Value;                      this.SourceLineNumber = Int32.Parse(m.Groups[9].Value);                      this.ProcessId = Int32.Parse(m.Groups[10].Value);                      this.ThreadId = Int32.Parse(m.Groups[11].Value);                      if (m.Groups.Count >= 14)                          // the String1 may be missing                          this.ExtraInfo = m.Groups[14].Value;                      else                          this.ExtraInfo = "";                      this.Malformed = false;                  }                  catch (FormatException)                  {                      Trace.TraceInformation("Failed to parse as extended log entry: {0}"' line);                      this.Malformed = true;                  }              }              else this.Malformed = true;
Magic Number,Microsoft.Research.JobObjectModel,ExtendedLogEntry,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\dryadlog.cs,Parse,The following statement contains a magic number: if (m.Success)              {                  try                  {                      this.Guid = m.Groups[1].Value;                      this.Machine = m.Groups[2].Value;                        this.Severity = m.Groups[3].Value.ToCharArray()[0];                      this.Timestamp = DateTime.Parse(m.Groups[4].Value);                      this.Subsystem = m.Groups[5].Value;                      this.Message = m.Groups[6].Value;                      this.SourceFile = m.Groups[7].Value;                      this.SourceFunction = m.Groups[8].Value;                      this.SourceLineNumber = Int32.Parse(m.Groups[9].Value);                      this.ProcessId = Int32.Parse(m.Groups[10].Value);                      this.ThreadId = Int32.Parse(m.Groups[11].Value);                      if (m.Groups.Count >= 14)                          // the String1 may be missing                          this.ExtraInfo = m.Groups[14].Value;                      else                          this.ExtraInfo = "";                      this.Malformed = false;                  }                  catch (FormatException)                  {                      Trace.TraceInformation("Failed to parse as extended log entry: {0}"' line);                      this.Malformed = true;                  }              }              else this.Malformed = true;
Magic Number,Microsoft.Research.JobObjectModel,ExtendedLogEntry,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\dryadlog.cs,Parse,The following statement contains a magic number: if (m.Success)              {                  try                  {                      this.Guid = m.Groups[1].Value;                      this.Machine = m.Groups[2].Value;                        this.Severity = m.Groups[3].Value.ToCharArray()[0];                      this.Timestamp = DateTime.Parse(m.Groups[4].Value);                      this.Subsystem = m.Groups[5].Value;                      this.Message = m.Groups[6].Value;                      this.SourceFile = m.Groups[7].Value;                      this.SourceFunction = m.Groups[8].Value;                      this.SourceLineNumber = Int32.Parse(m.Groups[9].Value);                      this.ProcessId = Int32.Parse(m.Groups[10].Value);                      this.ThreadId = Int32.Parse(m.Groups[11].Value);                      if (m.Groups.Count >= 14)                          // the String1 may be missing                          this.ExtraInfo = m.Groups[14].Value;                      else                          this.ExtraInfo = "";                      this.Malformed = false;                  }                  catch (FormatException)                  {                      Trace.TraceInformation("Failed to parse as extended log entry: {0}"' line);                      this.Malformed = true;                  }              }              else this.Malformed = true;
Magic Number,Microsoft.Research.JobObjectModel,ExtendedLogEntry,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\dryadlog.cs,Parse,The following statement contains a magic number: if (m.Success)              {                  try                  {                      this.Guid = m.Groups[1].Value;                      this.Machine = m.Groups[2].Value;                        this.Severity = m.Groups[3].Value.ToCharArray()[0];                      this.Timestamp = DateTime.Parse(m.Groups[4].Value);                      this.Subsystem = m.Groups[5].Value;                      this.Message = m.Groups[6].Value;                      this.SourceFile = m.Groups[7].Value;                      this.SourceFunction = m.Groups[8].Value;                      this.SourceLineNumber = Int32.Parse(m.Groups[9].Value);                      this.ProcessId = Int32.Parse(m.Groups[10].Value);                      this.ThreadId = Int32.Parse(m.Groups[11].Value);                      if (m.Groups.Count >= 14)                          // the String1 may be missing                          this.ExtraInfo = m.Groups[14].Value;                      else                          this.ExtraInfo = "";                      this.Malformed = false;                  }                  catch (FormatException)                  {                      Trace.TraceInformation("Failed to parse as extended log entry: {0}"' line);                      this.Malformed = true;                  }              }              else this.Malformed = true;
Magic Number,Microsoft.Research.JobObjectModel,ExtendedLogEntry,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\dryadlog.cs,Parse,The following statement contains a magic number: if (m.Success)              {                  try                  {                      this.Guid = m.Groups[1].Value;                      this.Machine = m.Groups[2].Value;                        this.Severity = m.Groups[3].Value.ToCharArray()[0];                      this.Timestamp = DateTime.Parse(m.Groups[4].Value);                      this.Subsystem = m.Groups[5].Value;                      this.Message = m.Groups[6].Value;                      this.SourceFile = m.Groups[7].Value;                      this.SourceFunction = m.Groups[8].Value;                      this.SourceLineNumber = Int32.Parse(m.Groups[9].Value);                      this.ProcessId = Int32.Parse(m.Groups[10].Value);                      this.ThreadId = Int32.Parse(m.Groups[11].Value);                      if (m.Groups.Count >= 14)                          // the String1 may be missing                          this.ExtraInfo = m.Groups[14].Value;                      else                          this.ExtraInfo = "";                      this.Malformed = false;                  }                  catch (FormatException)                  {                      Trace.TraceInformation("Failed to parse as extended log entry: {0}"' line);                      this.Malformed = true;                  }              }              else this.Malformed = true;
Magic Number,Microsoft.Research.JobObjectModel,ExtendedLogEntry,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\dryadlog.cs,Parse,The following statement contains a magic number: if (m.Success)              {                  try                  {                      this.Guid = m.Groups[1].Value;                      this.Machine = m.Groups[2].Value;                        this.Severity = m.Groups[3].Value.ToCharArray()[0];                      this.Timestamp = DateTime.Parse(m.Groups[4].Value);                      this.Subsystem = m.Groups[5].Value;                      this.Message = m.Groups[6].Value;                      this.SourceFile = m.Groups[7].Value;                      this.SourceFunction = m.Groups[8].Value;                      this.SourceLineNumber = Int32.Parse(m.Groups[9].Value);                      this.ProcessId = Int32.Parse(m.Groups[10].Value);                      this.ThreadId = Int32.Parse(m.Groups[11].Value);                      if (m.Groups.Count >= 14)                          // the String1 may be missing                          this.ExtraInfo = m.Groups[14].Value;                      else                          this.ExtraInfo = "";                      this.Malformed = false;                  }                  catch (FormatException)                  {                      Trace.TraceInformation("Failed to parse as extended log entry: {0}"' line);                      this.Malformed = true;                  }              }              else this.Malformed = true;
Magic Number,Microsoft.Research.JobObjectModel,ExtendedLogEntry,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\dryadlog.cs,Parse,The following statement contains a magic number: if (m.Success)              {                  try                  {                      this.Guid = m.Groups[1].Value;                      this.Machine = m.Groups[2].Value;                        this.Severity = m.Groups[3].Value.ToCharArray()[0];                      this.Timestamp = DateTime.Parse(m.Groups[4].Value);                      this.Subsystem = m.Groups[5].Value;                      this.Message = m.Groups[6].Value;                      this.SourceFile = m.Groups[7].Value;                      this.SourceFunction = m.Groups[8].Value;                      this.SourceLineNumber = Int32.Parse(m.Groups[9].Value);                      this.ProcessId = Int32.Parse(m.Groups[10].Value);                      this.ThreadId = Int32.Parse(m.Groups[11].Value);                      if (m.Groups.Count >= 14)                          // the String1 may be missing                          this.ExtraInfo = m.Groups[14].Value;                      else                          this.ExtraInfo = "";                      this.Malformed = false;                  }                  catch (FormatException)                  {                      Trace.TraceInformation("Failed to parse as extended log entry: {0}"' line);                      this.Malformed = true;                  }              }              else this.Malformed = true;
Magic Number,Microsoft.Research.JobObjectModel,ExtendedLogEntry,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\dryadlog.cs,Parse,The following statement contains a magic number: if (m.Success)              {                  try                  {                      this.Guid = m.Groups[1].Value;                      this.Machine = m.Groups[2].Value;                        this.Severity = m.Groups[3].Value.ToCharArray()[0];                      this.Timestamp = DateTime.Parse(m.Groups[4].Value);                      this.Subsystem = m.Groups[5].Value;                      this.Message = m.Groups[6].Value;                      this.SourceFile = m.Groups[7].Value;                      this.SourceFunction = m.Groups[8].Value;                      this.SourceLineNumber = Int32.Parse(m.Groups[9].Value);                      this.ProcessId = Int32.Parse(m.Groups[10].Value);                      this.ThreadId = Int32.Parse(m.Groups[11].Value);                      if (m.Groups.Count >= 14)                          // the String1 may be missing                          this.ExtraInfo = m.Groups[14].Value;                      else                          this.ExtraInfo = "";                      this.Malformed = false;                  }                  catch (FormatException)                  {                      Trace.TraceInformation("Failed to parse as extended log entry: {0}"' line);                      this.Malformed = true;                  }              }              else this.Malformed = true;
Magic Number,Microsoft.Research.JobObjectModel,ExtendedLogEntry,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\dryadlog.cs,Parse,The following statement contains a magic number: if (this.Malformed)              // much simpler parsing              {                  m = simpleloglineregex.Match(line);                  if (m.Success)                  {                      this.Guid = m.Groups[1].Value;                      this.Machine = m.Groups[2].Value;                  }                  else                  {                      this.Guid = "?";                      this.Machine = "?";                  }                    this.Severity = '?';                  this.Timestamp = DateTime.Now;                  this.Subsystem = "";                  this.Message = "";                  this.SourceFile = "";                  this.SourceFunction = "";                  this.SourceLineNumber = 0;                  this.ProcessId = 0;                  this.ThreadId = 0;                  this.ExtraInfo = "";              }
Magic Number,Microsoft.Research.JobObjectModel,ArgentiaDryadLogEntry,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\dryadlog.cs,Parse,The following statement contains a magic number: if (m.Success)              {                  this.Severity = m.Groups[1].Value.ToCharArray()[0];                  this.SourceFunction = m.Groups[2].Value;                  this.SourceFile = m.Groups[3].Value;                  this.SourceLineNumber = Int32.Parse(m.Groups[4].Value);                  this.Message = m.Groups[5].Value;                  this.Malformed = false;              }              else              {                  this.Malformed = true;              }
Magic Number,Microsoft.Research.JobObjectModel,ArgentiaDryadLogEntry,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\dryadlog.cs,Parse,The following statement contains a magic number: if (m.Success)              {                  this.Severity = m.Groups[1].Value.ToCharArray()[0];                  this.SourceFunction = m.Groups[2].Value;                  this.SourceFile = m.Groups[3].Value;                  this.SourceLineNumber = Int32.Parse(m.Groups[4].Value);                  this.Message = m.Groups[5].Value;                  this.Malformed = false;              }              else              {                  this.Malformed = true;              }
Magic Number,Microsoft.Research.JobObjectModel,ArgentiaDryadLogEntry,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\dryadlog.cs,Parse,The following statement contains a magic number: if (m.Success)              {                  this.Severity = m.Groups[1].Value.ToCharArray()[0];                  this.SourceFunction = m.Groups[2].Value;                  this.SourceFile = m.Groups[3].Value;                  this.SourceLineNumber = Int32.Parse(m.Groups[4].Value);                  this.Message = m.Groups[5].Value;                  this.Malformed = false;              }              else              {                  this.Malformed = true;              }
Magic Number,Microsoft.Research.JobObjectModel,ArgentiaDryadLogEntry,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\dryadlog.cs,Parse,The following statement contains a magic number: if (m.Success)              {                  this.Severity = m.Groups[1].Value.ToCharArray()[0];                  this.SourceFunction = m.Groups[2].Value;                  this.SourceFile = m.Groups[3].Value;                  this.SourceLineNumber = Int32.Parse(m.Groups[4].Value);                  this.Message = m.Groups[5].Value;                  this.Malformed = false;              }              else              {                  this.Malformed = true;              }
Magic Number,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,CollectEssentialInformation,The following statement contains a magic number: manager.Progress(100);
Magic Number,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseVertices,The following statement contains a magic number: while (vertexlist.Length > 0)              {                  Match m = numberre.Match(vertexlist);                  if (!m.Success)                      throw new DryadException("Could not find vertex number in " + vertexlist);                  string number = m.Groups[1].Value;                    // now scan a balanced number of parantheses                  string rest = m.Groups[2].Value;                  if (rest[0] != '(')                      throw new DryadException("Expecting open parens after vertex number");                  int opened = 0;                  int i;                  for (i = 0; i < rest.Length; i++)                  {                      if (rest[i] == '(')                          opened++;                      else if (rest[i] == ')')                      {                          opened--;                          if (opened == 0)                          {                              i++;                              break;                          }                      }                  }                  if (opened != 0 || i <= 2)                      throw new DryadException("did not find matched parantheses in vertex name in " + vertexlist + "' can't parse");                  string name = rest.Substring(1' i - 2); // skip first and last paranthesis                  yield return new Tuple<string' int>(name' int.Parse(number));                  vertexlist = rest.Substring(i);              }
Magic Number,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseVertices,The following statement contains a magic number: while (vertexlist.Length > 0)              {                  Match m = numberre.Match(vertexlist);                  if (!m.Success)                      throw new DryadException("Could not find vertex number in " + vertexlist);                  string number = m.Groups[1].Value;                    // now scan a balanced number of parantheses                  string rest = m.Groups[2].Value;                  if (rest[0] != '(')                      throw new DryadException("Expecting open parens after vertex number");                  int opened = 0;                  int i;                  for (i = 0; i < rest.Length; i++)                  {                      if (rest[i] == '(')                          opened++;                      else if (rest[i] == ')')                      {                          opened--;                          if (opened == 0)                          {                              i++;                              break;                          }                      }                  }                  if (opened != 0 || i <= 2)                      throw new DryadException("did not find matched parantheses in vertex name in " + vertexlist + "' can't parse");                  string name = rest.Substring(1' i - 2); // skip first and last paranthesis                  yield return new Tuple<string' int>(name' int.Parse(number));                  vertexlist = rest.Substring(i);              }
Magic Number,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseVertices,The following statement contains a magic number: while (vertexlist.Length > 0)              {                  Match m = numberre.Match(vertexlist);                  if (!m.Success)                      throw new DryadException("Could not find vertex number in " + vertexlist);                  string number = m.Groups[1].Value;                    // now scan a balanced number of parantheses                  string rest = m.Groups[2].Value;                  if (rest[0] != '(')                      throw new DryadException("Expecting open parens after vertex number");                  int opened = 0;                  int i;                  for (i = 0; i < rest.Length; i++)                  {                      if (rest[i] == '(')                          opened++;                      else if (rest[i] == ')')                      {                          opened--;                          if (opened == 0)                          {                              i++;                              break;                          }                      }                  }                  if (opened != 0 || i <= 2)                      throw new DryadException("did not find matched parantheses in vertex name in " + vertexlist + "' can't parse");                  string name = rest.Substring(1' i - 2); // skip first and last paranthesis                  yield return new Tuple<string' int>(name' int.Parse(number));                  vertexlist = rest.Substring(i);              }
Magic Number,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseStdoutLineNew,The following statement contains a magic number: if (kvp.ContainsKey("job"))              {                  string operation = kvp["job"];                  switch (operation)                  {                      case "start":                          this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' timeStamp' this.Summary.ManagerProcessGuid' "");                          this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = timeStamp;                          break;                      case "stop":                          this.ManagerVertex.End = timeStamp;                          string exitcode;                            if (kvp.TryGetValue("exitcode"' out exitcode))                          {                              this.ErrorCode = exitcode;                              int numCode = Convert.ToInt32(exitcode' 16);                              if (numCode == 0)                              {                                  this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                              }                              else                              {                                  this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                              }                          }                            string errorstring;                          if (kvp.TryGetValue("errorstring"' out errorstring))                          {                              this.ManagerVertex.AddErrorString(errorstring);                              this.AbortingMsg = errorstring;                          }                            break;                  }              }              else if (kvp.ContainsKey("vertex"))              {                  string vertex = kvp["vertex"];                  int number;                  int version;                    int dot = vertex.IndexOf('.');                  if (dot < 0)                  {                      number = int.Parse(vertex);                      version = int.Parse(kvp["version"]);                  }                  else                  {                      number = int.Parse(vertex.Substring(0' dot));                      version = int.Parse(vertex.Substring(dot + 1));                  }                    if (kvp.ContainsKey("transition"))                  {                      string transition = kvp["transition"];                      switch (transition)                      {                          case "created":                          {                              string name = kvp["name"];                              ExecutedVertexInstance vi = new ExecutedVertexInstance(this' number' version' name' ""' timeStamp);                              this.jobVertices.Add(vi);                          }                          break;                          case "starting":                          {                              // not doing anything                              break;                          }                          case "running":                          {                              string process;                              kvp.TryGetValue("id"' out process);                              if (process == null)                                  kvp.TryGetValue("process"' out process);                              string machine = kvp["computer"];                              ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                              this.jobVertices.Remap(vi' process);                              string pid = this.ClusterConfiguration.ExtractPidFromGuid(process' this.Summary);                              DryadProcessIdentifier identifier = new DryadProcessIdentifier(pid);                              vi.SetStartInformation(this' machine' timeStamp' identifier' process);                          }                          break;                          case "completed":                          {                              ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                              vi.SetState(ExecutedVertexInstance.VertexState.Successful);                              vi.End = timeStamp;                              vi.ExitCode = "";                              this.UsefulCPUTime += vi.RunningTime;                              break;                          }                          case "failed":                          {                              ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                              if (vi.State != ExecutedVertexInstance.VertexState.Started)                                  vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                              else                              {                                  vi.SetState(ExecutedVertexInstance.VertexState.Failed);                                  if (vi.RunningTime > TimeSpan.Zero)                                      this.WastedCPUTime += vi.RunningTime;                              }                              if (kvp.ContainsKey("errorstring"))                                  vi.AddErrorString(kvp["errorstring"]);                              string exitcode;                              if (kvp.TryGetValue("errorcode"' out exitcode))                                  vi.ExitCode = exitcode;                              vi.End = timeStamp;                              break;                          }                      }                  }                  else if (kvp.ContainsKey("outputChannel"))                  {                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (kvp.ContainsKey("errorstring"))                          vi.AddErrorString(kvp["errorstring"]);                  }                  else if (kvp.ContainsKey("inputChannel"))                  {                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (kvp.ContainsKey("errorstring"))                          vi.AddErrorString(kvp["errorstring"]);                  }                  else if (kvp.ContainsKey("io"))                  {                      if (kvp["io"] == "starting")                      {                          ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                          int numberOfInputs = (int) TryGetNumeric(kvp' "numberOfInputs");                          int numberOfOutputs = (int)TryGetNumeric(kvp' "numberOfOutputs");                            if (vi.InputChannels == null)                              vi.InputChannels = new Dictionary<int' ChannelEndpointDescription>();                            for (int i = 0; i < numberOfInputs; i++)                          {                              string uri;                              if (kvp.TryGetValue("uriIn." + i' out uri))                              {                                  var ched = new ChannelEndpointDescription(false' i' uri' 0);                                  vi.InputChannels[i] = ched;                              }                          }                            if (vi.OutputChannels == null)                              vi.OutputChannels = new Dictionary<int' ChannelEndpointDescription>();                          for (int i = 0; i < numberOfOutputs; i++)                          {                              string uri;                              if (kvp.TryGetValue("uriOut." + i' out uri))                              {                                  var ched = new ChannelEndpointDescription(false' i' uri' 0);                                  vi.OutputChannels[i] = ched;                              }                          }                      }                      else if (kvp["io"] == "total")                      {                          ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                            long totalRead = TryGetNumeric(kvp' "totalRead");                          //long tempRead = TryGetNumeric(kvp' "tempRead");                          long tempReadInRack = TryGetNumeric(kvp' "tempReadInRack");                          long tempReadCrossRack = TryGetNumeric(kvp' "tempReadCrossRack");                          long localRead = TryGetNumeric(kvp' "localRead");                          long totalWritten = TryGetNumeric(kvp' "totalWritten");                            vi.DataRead = totalRead;                          vi.DataWritten = totalWritten;                            if (vi.InputChannels != null)                          {                              foreach (int ch in vi.InputChannels.Keys)                              {                                  long bytes = TryGetNumeric(kvp' "rb." + ch);                                  vi.InputChannels[ch].Size = bytes;                              }                          }                            if (vi.OutputChannels != null)                          {                              foreach (int ch in vi.OutputChannels.Keys)                              {                                  long bytes = TryGetNumeric(kvp' "wb." + ch);                                  vi.OutputChannels[ch].Size = bytes;                              }                          }                            this.TotalDataRead += totalRead;                          this.LocalReadData += localRead;                          this.CrossPodDataRead += tempReadCrossRack;                          this.IntraPodDataRead += tempReadInRack;                      }                      else if (kvp["io"] == "running")                      {                          ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                            if (vi.InputChannels != null)                          {                              foreach (int ch in vi.InputChannels.Keys)                              {                                  long bytes = TryGetNumeric(kvp' "rb." + ch);                                  vi.InputChannels[ch].Size = bytes;                                    bytes = TryGetNumeric(kvp' "tb." + ch);                                  vi.InputChannels[ch].TotalSize = bytes;                              }                          }                            if (vi.InputChannels != null)                          {                              foreach (int ch in vi.OutputChannels.Keys)                              {                                  long bytes = TryGetNumeric(kvp' "wb." + ch);                                  vi.OutputChannels[ch].Size = bytes;                              }                          }                            long totalRead = TryGetNumeric(kvp' "totalRead");                          long totalWritten = TryGetNumeric(kvp' "totalWritten");                            vi.DataRead = totalRead;                          vi.DataWritten = totalWritten;                      }                  }              }
Magic Number,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseStdoutLine,The following statement contains a magic number: if (line.Contains("Created process execution record"))              {                  Match m = vertexCreatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Created process execution record for vertex (\d+) \((.*)\) v.(\d+) GUID \{?([-A-F0-9]+)\}?                      int number = Int32.Parse(m.Groups[1].Value);                      string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                        // the vertex may be already there' sometimes numbers are reused...                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi == null)                      {                          vi = new ExecutedVertexInstance(this' number' version' name' guid' lineTimeStamp);                          this.jobVertices.Add(vi);                      }                  }                  else                  {                      m = verticesCreatedRegex.Match(line);                      if (m.Success)                      {                          lineTimeStamp = ParseLineTimestamp(line);                            // Created process execution record for vertices (.*) v.(\d+) GUID \{?([-A-F0-9]+)\}?                          // Created process execution record for vertices 192 (Merge__41[0]) 223 (Union__45[0]) v.0 GUID {0297A91C-FFEA-42EA-94AF-CD0163A04D45}                          int version = Int32.Parse(m.Groups[2].Value);                          string vertices = m.Groups[1].Value;                          string guid = m.Groups[3].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                            IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                          foreach (var p in vertexList)                          {                              int number = p.Item2;                              ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                              if (vi == null)                              {                                  vi = new ExecutedVertexInstance(this' number' version' p.Item1' guid' lineTimeStamp);                                  this.jobVertices.Add(vi);                              }                          }                      }                  }              }              else if (line.StartsWith("Creating process"))              {                  Match m = processCreatingRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Creating process for vertex (\d+) \((.*)\\) v.(\d+) GUID \{?([-A-F0-9]+)\}? machine (\w+)                      int number = Int32.Parse(m.Groups[1].Value);                      //string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value;                         ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          this.jobVertices.Remap(vi' guid);                      }                  }              }              else if (line.StartsWith("Process was revoked"))              {                  Match m = revokedRegex.Match(line);                  if (m.Success)                  {                      string oldGuid = m.Groups[1].Value;                      ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(oldGuid);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Revoked);                          string newGuid = m.Groups[2].Value;                          this.jobVertices.Remap(vi' newGuid);                      }                      else                      {                          Trace.TraceInformation("Could not find revoked vertex with guid " + oldGuid);                      }                  }              }              else if (line.StartsWith("---HiPriTime"))              {                  // Scope-specific line which we use to get the i/o information                  // ---HiPriTime D7D51A1F-6693-4378-95FD-FC778A67C632'F52CA694-0202-411E-85E9-0C883E770A0E'SV4_Extract_Split[0]'Completed'ch1sch010331112'2011-05-03 15:26:01.681 PDT'2011-05-03 15:26:01.696 PDT'2011-05-03 15:26:02.118 PDT'2011-05-03 15:26:04.286 PDT'2011-05-03 15:26:07.656 PDT'2011-05-03 15:26:01.696 PDT'97390825'1498630                  string info = line.Substring(13);                  string[] parts = info.Split(''');                  if (parts.Length >= 13)                  {                      long read = long.Parse(parts[11]);                      long written = long.Parse(parts[12]);                      string guid = parts[1];                        ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(guid);                      if (vi != null)                      {                          vi.DataRead = read;                          vi.DataWritten = written;                          this.TotalDataRead += read;                      }                  }              }              else if (line.Contains("Io information"))              {                  // HPC-specific line                  Match m = ioRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.DataRead = long.Parse(m.Groups[4].Value);                          vi.DataWritten = long.Parse(m.Groups[5].Value);                          this.TotalDataRead += vi.DataRead;                      }                  }              }              else if (line.Contains("Process started"))              {                  //those vertices which are being canceled may not be here                  Match m = vertexStartRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        string version = m.Groups[3].Value;                      string guid = m.Groups[4].Value;                      string pid = this.ClusterConfiguration.ExtractPidFromGuid(guid' this.Summary);                      DryadProcessIdentifier identifier = new DryadProcessIdentifier(pid);                      string machine = m.Groups[5].Value;                        // Process started for vertex 4 (Super__0[0]) v.0 GUID {9DDD0B00-C93F-46D2-9073-1CFD27829300} machine sherwood-255                      // Process started for vertices 23 (Merge__29) 24 (Apply__33) v.0 GUID {E945DC5D-9AF6-4732-8770-2A6BF7FA3041} machine sherwood-237                        string vertices = m.Groups[2].Value;                      // This is a list of (number \(name\))* pairs                      // we will assume that the parantheses are matched' or we can't do much                        bool onevertex;                      if (m.Groups[1].Value == "ex")  // one vertEX                          onevertex = true;                      else if (m.Groups[1].Value == "ices")                          onevertex = false;                      else                          throw new DryadException("Can't figure out if one or many vertices");                        IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                        int vertexcount = 0;                      int iversion = int.Parse(version);                        if (lineTimeStamp > this.lastTimestampSeen)                          this.lastTimestampSeen = lineTimeStamp;                      foreach (var p in vertexList)                      {                          int number = p.Item2;                          ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' iversion);                          //new ExecutedVertexInstance(this' number' version' name' identifier' machine' this.lastTimestampSeen);                          if (vi == null)                              Trace.TraceInformation("Could not find information for vertex {0}.{1}"' number' version);                          else                              vi.SetStartInformation(this' machine' this.lastTimestampSeen' identifier' guid);                          vertexcount++;                      }                        if (vertexcount > 1 && onevertex)                          throw new DryadException("Expected one vertex' found " + vertexcount);                  }                  else                  {                      Trace.TraceInformation("Unexpected parsing error on line {0}"' line);                  }              }              else if (line.Contains("Abandoning"))              {                  Match m = vertexAbandonedRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                          vi.SetState(ExecutedVertexInstance.VertexState.Abandoned);                  }              }              else if (line.Contains("Setting"))              {                  Match m = setToFailedlRegex.Match(line);                  if (m.Success)                  {                      // Setting vertex 1461.0 (Merge__13[258]) to failed                      // Setting vertex (\d+)\.(\d+) \((.+)\) to failed(.*)                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          //vi.ErrorString = m.Groups[4].Value;                      }                  }              }              else if (line.Contains("Process was terminated"))              {                  // terminatedRegex = new Regex(@"Process was terminated Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) status (.*)"'                  // Process was terminated Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 status The operation succeeded                  Match m = terminatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          // sometimes successful processes are terminated' because they don't report quickly enough being done                          if (vi.State != ExecutedVertexInstance.VertexState.Successful)                          {                              vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          }                          vi.ErrorString = m.Groups[6].Value;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                  }              }              else if (line.Contains("Timing Information Graph Start Time"))              {                  // Cosmos-specific line                  // Timing Information Graph Start Time 128654556581866096                  Match m = Regex.Match(line' @"Timing Information Graph Start Time (\d+)");                  DateTime createTime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                  this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                  this.lastTimestampSeen = createTime;              }              else if (line.StartsWith("Start time: "))              {                  // HPC L2H specific line                  // Start time: 04/05/2011 17:25:42.223                  DateTime createTime;                  bool parse = DateTime.TryParse(line.Substring("Start time: ".Length)' out createTime);                    if (parse)                  {                      this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                      this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                      this.lastTimestampSeen = createTime;                  }              }              else if (line.Contains("JM Finish time:"))              {                  // Cosmos-specific line                  // JM Finish time: 129140295499437263 2010-03-25T22:25:49.943726Z                  Match m = Regex.Match(line' @"JM Finish time: (\d+)");                  DateTime time = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.lastTimestampSeen = time;                  this.ManagerVertex.End = time;              }              else if (line.StartsWith("Stop time "))              {                  // HPC L2H specific line                  // Stop time (Exit code = 2148734208): 04/05/2011 17:25:46.614                  Regex regex = new Regex(@"Stop time \(Exit code = (.*)\): (.*)");                  Match m = regex.Match(line);                  if (m.Success)                  {                      this.ManagerStdoutIncomplete = false;                        DateTime time;                      bool parse = DateTime.TryParse(m.Groups[2].Value' out time);                      if (parse)                      {                          this.lastTimestampSeen = time;                          this.ManagerVertex.End = time;                      }                        this.ErrorCode = m.Groups[1].Value;                      if (this.ErrorCode == "0")                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                      }                      else                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                      }                  }              }              else if (line.Contains("Timing Information"))              {                  // Timing Information 4 1 Super__0[0] 128654556603428182 0.0000 0.0000 0.0000 0.0000 0.2500                   Match m = timingInfoRegex.Match(line);                  if (m.Success)                  {                      int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      DateTime createtime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[4].Value);                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi == null)                          return; // we do not keep track of vertices with duplicate scheduling' so these won't show up here                        if (vi.State == ExecutedVertexInstance.VertexState.Started)                      {                          Console.WriteLine("Timing information while vertex is still running " + vi);                          //throw new ClusterException("Timing information for vertex still running: " + vi);                      }                      DateTime last = vi.SetTiming(createtime' m.Groups[5].Value' m.Groups[6].Value' m.Groups[7].Value' m.Groups[8].Value' m.Groups[9].Value);                      if (last > this.lastTimestampSeen)                          this.lastTimestampSeen = last;                      this.ManagerVertex.MarkVertexWasRunning(last);                        try                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              this.UsefulCPUTime += vi.RunningTime;                          else if (vi.RunningTime > TimeSpan.Zero)                              this.WastedCPUTime += vi.RunningTime;                      }                      catch (Exception ex)                      {                          Console.WriteLine("Time value exception: " + ex.Message);                      }                  }                  else                      throw new DryadException("Unmatched timing information line " + line);              }              else if (line.Contains("Process has failed"))              {                  // Process has failed Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 Exitcode 0 status The operation succeeded                  // failedRegex = new Regex(@"Process has failed Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) Exitcode (.*)"'                  Match m = failedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string exitcode = m.Groups[6].Value;                      //string status = m.Groups[7].Value;                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          vi.ExitCode = exitcode;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                          //vi.ErrorString = status;                      }                  }              }              else if (line.Contains("ABORTING:"))              {                  this.AbortingMsg = line.Substring(10);                  this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);              }              else if (line.Contains("Accurate read data"))              {                  Match m = datareadRegex.Match(line);                  if (m.Success)                  {                      this.TotalDataRead = long.Parse(m.Groups[1].Value);                      this.LocalReadData = long.Parse(m.Groups[2].Value);                      this.IntraPodDataRead = long.Parse(m.Groups[3].Value);                      this.CrossPodDataRead = long.Parse(m.Groups[4].Value);                  }              }              else if (line.Contains("<ErrorString>"))              {                  //some errors contains "Error returned from managed runtime invocation"                  //which shows the error is from application code                  Match m = Regex.Match(line' @"\<ErrorString\>(.*)\</ErrorString\>");                  if (m.Success && lastFailedVertex != null)                  {                      lastFailedVertex.AddErrorString(System.Web.HttpUtility.HtmlDecode(m.Groups[1].Value));                  }              }              else if (line.Contains("Canceling"))              {                  // Canceling vertex 1461.0 (Merge__13[258]) due to dependent failure                  Match m = cancelRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string name = m.Groups[3].Value;                        ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              vi.SetState(ExecutedVertexInstance.VertexState.Invalidated);                          else                               vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                      else                      {                          // TODO: this should not be needed' but this is a workaround for a bug in the HPC L2H software                          vi = new ExecutedVertexInstance(this' vertex' version' name' ""' lineTimeStamp);                          vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          this.jobVertices.Add(vi);                      }                      // Process wasn't even started' so there is nothing to cancel                  }              }              else if (line.Contains("Application"))              {                  //the job ends successfully                  Regex endSuccessRegex = new Regex(@"Application completed successfully.");                  //the job failed                  Regex endFailRegex = new Regex(@"Application failed with error code (.*)");                    Match m1 = endFailRegex.Match(line);                    if (m1.Success)                  {                      this.ErrorCode = m1.Groups[1].Value;                      this.ManagerStdoutIncomplete = false;                      this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                  }                  else                  {                      Match m2 = endSuccessRegex.Match(line);                      if (m2.Success)                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                          this.ManagerStdoutIncomplete = false;                      }                  }              }              else if (line.StartsWith("Input"))              {                  // Input vertex %u (%s) had %u read failure%s\n                  Match m = inputFailureRegex.Match(line);                  if (m.Success)                  {                      this.AbortingMsg = line;                  }              }              else if (line.Contains("Vertex"))              {                  // terminationRegex = new Regex(@"Vertex (\d+)\.(\d+) \((.+)\) machine (\S+) guid \{?([-0-9A-F]+)\}? status (.*)"                  Match m = terminationRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(vertex' version);                      if (vi == null)                      {                          Trace.TraceInformation("Could not find vertex {0}.{1} line {2}"' vertex' version' line);                      }                      else                      {                          bool failed = vi.SetTermination(m.Groups[6].Value' lineTimeStamp);                          if (failed)                              this.lastFailedVertex = vi;                      }                  }              }
Magic Number,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseStdoutLine,The following statement contains a magic number: if (line.Contains("Created process execution record"))              {                  Match m = vertexCreatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Created process execution record for vertex (\d+) \((.*)\) v.(\d+) GUID \{?([-A-F0-9]+)\}?                      int number = Int32.Parse(m.Groups[1].Value);                      string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                        // the vertex may be already there' sometimes numbers are reused...                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi == null)                      {                          vi = new ExecutedVertexInstance(this' number' version' name' guid' lineTimeStamp);                          this.jobVertices.Add(vi);                      }                  }                  else                  {                      m = verticesCreatedRegex.Match(line);                      if (m.Success)                      {                          lineTimeStamp = ParseLineTimestamp(line);                            // Created process execution record for vertices (.*) v.(\d+) GUID \{?([-A-F0-9]+)\}?                          // Created process execution record for vertices 192 (Merge__41[0]) 223 (Union__45[0]) v.0 GUID {0297A91C-FFEA-42EA-94AF-CD0163A04D45}                          int version = Int32.Parse(m.Groups[2].Value);                          string vertices = m.Groups[1].Value;                          string guid = m.Groups[3].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                            IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                          foreach (var p in vertexList)                          {                              int number = p.Item2;                              ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                              if (vi == null)                              {                                  vi = new ExecutedVertexInstance(this' number' version' p.Item1' guid' lineTimeStamp);                                  this.jobVertices.Add(vi);                              }                          }                      }                  }              }              else if (line.StartsWith("Creating process"))              {                  Match m = processCreatingRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Creating process for vertex (\d+) \((.*)\\) v.(\d+) GUID \{?([-A-F0-9]+)\}? machine (\w+)                      int number = Int32.Parse(m.Groups[1].Value);                      //string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value;                         ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          this.jobVertices.Remap(vi' guid);                      }                  }              }              else if (line.StartsWith("Process was revoked"))              {                  Match m = revokedRegex.Match(line);                  if (m.Success)                  {                      string oldGuid = m.Groups[1].Value;                      ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(oldGuid);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Revoked);                          string newGuid = m.Groups[2].Value;                          this.jobVertices.Remap(vi' newGuid);                      }                      else                      {                          Trace.TraceInformation("Could not find revoked vertex with guid " + oldGuid);                      }                  }              }              else if (line.StartsWith("---HiPriTime"))              {                  // Scope-specific line which we use to get the i/o information                  // ---HiPriTime D7D51A1F-6693-4378-95FD-FC778A67C632'F52CA694-0202-411E-85E9-0C883E770A0E'SV4_Extract_Split[0]'Completed'ch1sch010331112'2011-05-03 15:26:01.681 PDT'2011-05-03 15:26:01.696 PDT'2011-05-03 15:26:02.118 PDT'2011-05-03 15:26:04.286 PDT'2011-05-03 15:26:07.656 PDT'2011-05-03 15:26:01.696 PDT'97390825'1498630                  string info = line.Substring(13);                  string[] parts = info.Split(''');                  if (parts.Length >= 13)                  {                      long read = long.Parse(parts[11]);                      long written = long.Parse(parts[12]);                      string guid = parts[1];                        ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(guid);                      if (vi != null)                      {                          vi.DataRead = read;                          vi.DataWritten = written;                          this.TotalDataRead += read;                      }                  }              }              else if (line.Contains("Io information"))              {                  // HPC-specific line                  Match m = ioRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.DataRead = long.Parse(m.Groups[4].Value);                          vi.DataWritten = long.Parse(m.Groups[5].Value);                          this.TotalDataRead += vi.DataRead;                      }                  }              }              else if (line.Contains("Process started"))              {                  //those vertices which are being canceled may not be here                  Match m = vertexStartRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        string version = m.Groups[3].Value;                      string guid = m.Groups[4].Value;                      string pid = this.ClusterConfiguration.ExtractPidFromGuid(guid' this.Summary);                      DryadProcessIdentifier identifier = new DryadProcessIdentifier(pid);                      string machine = m.Groups[5].Value;                        // Process started for vertex 4 (Super__0[0]) v.0 GUID {9DDD0B00-C93F-46D2-9073-1CFD27829300} machine sherwood-255                      // Process started for vertices 23 (Merge__29) 24 (Apply__33) v.0 GUID {E945DC5D-9AF6-4732-8770-2A6BF7FA3041} machine sherwood-237                        string vertices = m.Groups[2].Value;                      // This is a list of (number \(name\))* pairs                      // we will assume that the parantheses are matched' or we can't do much                        bool onevertex;                      if (m.Groups[1].Value == "ex")  // one vertEX                          onevertex = true;                      else if (m.Groups[1].Value == "ices")                          onevertex = false;                      else                          throw new DryadException("Can't figure out if one or many vertices");                        IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                        int vertexcount = 0;                      int iversion = int.Parse(version);                        if (lineTimeStamp > this.lastTimestampSeen)                          this.lastTimestampSeen = lineTimeStamp;                      foreach (var p in vertexList)                      {                          int number = p.Item2;                          ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' iversion);                          //new ExecutedVertexInstance(this' number' version' name' identifier' machine' this.lastTimestampSeen);                          if (vi == null)                              Trace.TraceInformation("Could not find information for vertex {0}.{1}"' number' version);                          else                              vi.SetStartInformation(this' machine' this.lastTimestampSeen' identifier' guid);                          vertexcount++;                      }                        if (vertexcount > 1 && onevertex)                          throw new DryadException("Expected one vertex' found " + vertexcount);                  }                  else                  {                      Trace.TraceInformation("Unexpected parsing error on line {0}"' line);                  }              }              else if (line.Contains("Abandoning"))              {                  Match m = vertexAbandonedRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                          vi.SetState(ExecutedVertexInstance.VertexState.Abandoned);                  }              }              else if (line.Contains("Setting"))              {                  Match m = setToFailedlRegex.Match(line);                  if (m.Success)                  {                      // Setting vertex 1461.0 (Merge__13[258]) to failed                      // Setting vertex (\d+)\.(\d+) \((.+)\) to failed(.*)                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          //vi.ErrorString = m.Groups[4].Value;                      }                  }              }              else if (line.Contains("Process was terminated"))              {                  // terminatedRegex = new Regex(@"Process was terminated Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) status (.*)"'                  // Process was terminated Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 status The operation succeeded                  Match m = terminatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          // sometimes successful processes are terminated' because they don't report quickly enough being done                          if (vi.State != ExecutedVertexInstance.VertexState.Successful)                          {                              vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          }                          vi.ErrorString = m.Groups[6].Value;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                  }              }              else if (line.Contains("Timing Information Graph Start Time"))              {                  // Cosmos-specific line                  // Timing Information Graph Start Time 128654556581866096                  Match m = Regex.Match(line' @"Timing Information Graph Start Time (\d+)");                  DateTime createTime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                  this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                  this.lastTimestampSeen = createTime;              }              else if (line.StartsWith("Start time: "))              {                  // HPC L2H specific line                  // Start time: 04/05/2011 17:25:42.223                  DateTime createTime;                  bool parse = DateTime.TryParse(line.Substring("Start time: ".Length)' out createTime);                    if (parse)                  {                      this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                      this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                      this.lastTimestampSeen = createTime;                  }              }              else if (line.Contains("JM Finish time:"))              {                  // Cosmos-specific line                  // JM Finish time: 129140295499437263 2010-03-25T22:25:49.943726Z                  Match m = Regex.Match(line' @"JM Finish time: (\d+)");                  DateTime time = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.lastTimestampSeen = time;                  this.ManagerVertex.End = time;              }              else if (line.StartsWith("Stop time "))              {                  // HPC L2H specific line                  // Stop time (Exit code = 2148734208): 04/05/2011 17:25:46.614                  Regex regex = new Regex(@"Stop time \(Exit code = (.*)\): (.*)");                  Match m = regex.Match(line);                  if (m.Success)                  {                      this.ManagerStdoutIncomplete = false;                        DateTime time;                      bool parse = DateTime.TryParse(m.Groups[2].Value' out time);                      if (parse)                      {                          this.lastTimestampSeen = time;                          this.ManagerVertex.End = time;                      }                        this.ErrorCode = m.Groups[1].Value;                      if (this.ErrorCode == "0")                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                      }                      else                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                      }                  }              }              else if (line.Contains("Timing Information"))              {                  // Timing Information 4 1 Super__0[0] 128654556603428182 0.0000 0.0000 0.0000 0.0000 0.2500                   Match m = timingInfoRegex.Match(line);                  if (m.Success)                  {                      int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      DateTime createtime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[4].Value);                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi == null)                          return; // we do not keep track of vertices with duplicate scheduling' so these won't show up here                        if (vi.State == ExecutedVertexInstance.VertexState.Started)                      {                          Console.WriteLine("Timing information while vertex is still running " + vi);                          //throw new ClusterException("Timing information for vertex still running: " + vi);                      }                      DateTime last = vi.SetTiming(createtime' m.Groups[5].Value' m.Groups[6].Value' m.Groups[7].Value' m.Groups[8].Value' m.Groups[9].Value);                      if (last > this.lastTimestampSeen)                          this.lastTimestampSeen = last;                      this.ManagerVertex.MarkVertexWasRunning(last);                        try                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              this.UsefulCPUTime += vi.RunningTime;                          else if (vi.RunningTime > TimeSpan.Zero)                              this.WastedCPUTime += vi.RunningTime;                      }                      catch (Exception ex)                      {                          Console.WriteLine("Time value exception: " + ex.Message);                      }                  }                  else                      throw new DryadException("Unmatched timing information line " + line);              }              else if (line.Contains("Process has failed"))              {                  // Process has failed Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 Exitcode 0 status The operation succeeded                  // failedRegex = new Regex(@"Process has failed Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) Exitcode (.*)"'                  Match m = failedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string exitcode = m.Groups[6].Value;                      //string status = m.Groups[7].Value;                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          vi.ExitCode = exitcode;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                          //vi.ErrorString = status;                      }                  }              }              else if (line.Contains("ABORTING:"))              {                  this.AbortingMsg = line.Substring(10);                  this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);              }              else if (line.Contains("Accurate read data"))              {                  Match m = datareadRegex.Match(line);                  if (m.Success)                  {                      this.TotalDataRead = long.Parse(m.Groups[1].Value);                      this.LocalReadData = long.Parse(m.Groups[2].Value);                      this.IntraPodDataRead = long.Parse(m.Groups[3].Value);                      this.CrossPodDataRead = long.Parse(m.Groups[4].Value);                  }              }              else if (line.Contains("<ErrorString>"))              {                  //some errors contains "Error returned from managed runtime invocation"                  //which shows the error is from application code                  Match m = Regex.Match(line' @"\<ErrorString\>(.*)\</ErrorString\>");                  if (m.Success && lastFailedVertex != null)                  {                      lastFailedVertex.AddErrorString(System.Web.HttpUtility.HtmlDecode(m.Groups[1].Value));                  }              }              else if (line.Contains("Canceling"))              {                  // Canceling vertex 1461.0 (Merge__13[258]) due to dependent failure                  Match m = cancelRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string name = m.Groups[3].Value;                        ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              vi.SetState(ExecutedVertexInstance.VertexState.Invalidated);                          else                               vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                      else                      {                          // TODO: this should not be needed' but this is a workaround for a bug in the HPC L2H software                          vi = new ExecutedVertexInstance(this' vertex' version' name' ""' lineTimeStamp);                          vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          this.jobVertices.Add(vi);                      }                      // Process wasn't even started' so there is nothing to cancel                  }              }              else if (line.Contains("Application"))              {                  //the job ends successfully                  Regex endSuccessRegex = new Regex(@"Application completed successfully.");                  //the job failed                  Regex endFailRegex = new Regex(@"Application failed with error code (.*)");                    Match m1 = endFailRegex.Match(line);                    if (m1.Success)                  {                      this.ErrorCode = m1.Groups[1].Value;                      this.ManagerStdoutIncomplete = false;                      this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                  }                  else                  {                      Match m2 = endSuccessRegex.Match(line);                      if (m2.Success)                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                          this.ManagerStdoutIncomplete = false;                      }                  }              }              else if (line.StartsWith("Input"))              {                  // Input vertex %u (%s) had %u read failure%s\n                  Match m = inputFailureRegex.Match(line);                  if (m.Success)                  {                      this.AbortingMsg = line;                  }              }              else if (line.Contains("Vertex"))              {                  // terminationRegex = new Regex(@"Vertex (\d+)\.(\d+) \((.+)\) machine (\S+) guid \{?([-0-9A-F]+)\}? status (.*)"                  Match m = terminationRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(vertex' version);                      if (vi == null)                      {                          Trace.TraceInformation("Could not find vertex {0}.{1} line {2}"' vertex' version' line);                      }                      else                      {                          bool failed = vi.SetTermination(m.Groups[6].Value' lineTimeStamp);                          if (failed)                              this.lastFailedVertex = vi;                      }                  }              }
Magic Number,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseStdoutLine,The following statement contains a magic number: if (line.Contains("Created process execution record"))              {                  Match m = vertexCreatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Created process execution record for vertex (\d+) \((.*)\) v.(\d+) GUID \{?([-A-F0-9]+)\}?                      int number = Int32.Parse(m.Groups[1].Value);                      string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                        // the vertex may be already there' sometimes numbers are reused...                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi == null)                      {                          vi = new ExecutedVertexInstance(this' number' version' name' guid' lineTimeStamp);                          this.jobVertices.Add(vi);                      }                  }                  else                  {                      m = verticesCreatedRegex.Match(line);                      if (m.Success)                      {                          lineTimeStamp = ParseLineTimestamp(line);                            // Created process execution record for vertices (.*) v.(\d+) GUID \{?([-A-F0-9]+)\}?                          // Created process execution record for vertices 192 (Merge__41[0]) 223 (Union__45[0]) v.0 GUID {0297A91C-FFEA-42EA-94AF-CD0163A04D45}                          int version = Int32.Parse(m.Groups[2].Value);                          string vertices = m.Groups[1].Value;                          string guid = m.Groups[3].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                            IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                          foreach (var p in vertexList)                          {                              int number = p.Item2;                              ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                              if (vi == null)                              {                                  vi = new ExecutedVertexInstance(this' number' version' p.Item1' guid' lineTimeStamp);                                  this.jobVertices.Add(vi);                              }                          }                      }                  }              }              else if (line.StartsWith("Creating process"))              {                  Match m = processCreatingRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Creating process for vertex (\d+) \((.*)\\) v.(\d+) GUID \{?([-A-F0-9]+)\}? machine (\w+)                      int number = Int32.Parse(m.Groups[1].Value);                      //string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value;                         ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          this.jobVertices.Remap(vi' guid);                      }                  }              }              else if (line.StartsWith("Process was revoked"))              {                  Match m = revokedRegex.Match(line);                  if (m.Success)                  {                      string oldGuid = m.Groups[1].Value;                      ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(oldGuid);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Revoked);                          string newGuid = m.Groups[2].Value;                          this.jobVertices.Remap(vi' newGuid);                      }                      else                      {                          Trace.TraceInformation("Could not find revoked vertex with guid " + oldGuid);                      }                  }              }              else if (line.StartsWith("---HiPriTime"))              {                  // Scope-specific line which we use to get the i/o information                  // ---HiPriTime D7D51A1F-6693-4378-95FD-FC778A67C632'F52CA694-0202-411E-85E9-0C883E770A0E'SV4_Extract_Split[0]'Completed'ch1sch010331112'2011-05-03 15:26:01.681 PDT'2011-05-03 15:26:01.696 PDT'2011-05-03 15:26:02.118 PDT'2011-05-03 15:26:04.286 PDT'2011-05-03 15:26:07.656 PDT'2011-05-03 15:26:01.696 PDT'97390825'1498630                  string info = line.Substring(13);                  string[] parts = info.Split(''');                  if (parts.Length >= 13)                  {                      long read = long.Parse(parts[11]);                      long written = long.Parse(parts[12]);                      string guid = parts[1];                        ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(guid);                      if (vi != null)                      {                          vi.DataRead = read;                          vi.DataWritten = written;                          this.TotalDataRead += read;                      }                  }              }              else if (line.Contains("Io information"))              {                  // HPC-specific line                  Match m = ioRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.DataRead = long.Parse(m.Groups[4].Value);                          vi.DataWritten = long.Parse(m.Groups[5].Value);                          this.TotalDataRead += vi.DataRead;                      }                  }              }              else if (line.Contains("Process started"))              {                  //those vertices which are being canceled may not be here                  Match m = vertexStartRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        string version = m.Groups[3].Value;                      string guid = m.Groups[4].Value;                      string pid = this.ClusterConfiguration.ExtractPidFromGuid(guid' this.Summary);                      DryadProcessIdentifier identifier = new DryadProcessIdentifier(pid);                      string machine = m.Groups[5].Value;                        // Process started for vertex 4 (Super__0[0]) v.0 GUID {9DDD0B00-C93F-46D2-9073-1CFD27829300} machine sherwood-255                      // Process started for vertices 23 (Merge__29) 24 (Apply__33) v.0 GUID {E945DC5D-9AF6-4732-8770-2A6BF7FA3041} machine sherwood-237                        string vertices = m.Groups[2].Value;                      // This is a list of (number \(name\))* pairs                      // we will assume that the parantheses are matched' or we can't do much                        bool onevertex;                      if (m.Groups[1].Value == "ex")  // one vertEX                          onevertex = true;                      else if (m.Groups[1].Value == "ices")                          onevertex = false;                      else                          throw new DryadException("Can't figure out if one or many vertices");                        IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                        int vertexcount = 0;                      int iversion = int.Parse(version);                        if (lineTimeStamp > this.lastTimestampSeen)                          this.lastTimestampSeen = lineTimeStamp;                      foreach (var p in vertexList)                      {                          int number = p.Item2;                          ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' iversion);                          //new ExecutedVertexInstance(this' number' version' name' identifier' machine' this.lastTimestampSeen);                          if (vi == null)                              Trace.TraceInformation("Could not find information for vertex {0}.{1}"' number' version);                          else                              vi.SetStartInformation(this' machine' this.lastTimestampSeen' identifier' guid);                          vertexcount++;                      }                        if (vertexcount > 1 && onevertex)                          throw new DryadException("Expected one vertex' found " + vertexcount);                  }                  else                  {                      Trace.TraceInformation("Unexpected parsing error on line {0}"' line);                  }              }              else if (line.Contains("Abandoning"))              {                  Match m = vertexAbandonedRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                          vi.SetState(ExecutedVertexInstance.VertexState.Abandoned);                  }              }              else if (line.Contains("Setting"))              {                  Match m = setToFailedlRegex.Match(line);                  if (m.Success)                  {                      // Setting vertex 1461.0 (Merge__13[258]) to failed                      // Setting vertex (\d+)\.(\d+) \((.+)\) to failed(.*)                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          //vi.ErrorString = m.Groups[4].Value;                      }                  }              }              else if (line.Contains("Process was terminated"))              {                  // terminatedRegex = new Regex(@"Process was terminated Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) status (.*)"'                  // Process was terminated Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 status The operation succeeded                  Match m = terminatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          // sometimes successful processes are terminated' because they don't report quickly enough being done                          if (vi.State != ExecutedVertexInstance.VertexState.Successful)                          {                              vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          }                          vi.ErrorString = m.Groups[6].Value;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                  }              }              else if (line.Contains("Timing Information Graph Start Time"))              {                  // Cosmos-specific line                  // Timing Information Graph Start Time 128654556581866096                  Match m = Regex.Match(line' @"Timing Information Graph Start Time (\d+)");                  DateTime createTime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                  this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                  this.lastTimestampSeen = createTime;              }              else if (line.StartsWith("Start time: "))              {                  // HPC L2H specific line                  // Start time: 04/05/2011 17:25:42.223                  DateTime createTime;                  bool parse = DateTime.TryParse(line.Substring("Start time: ".Length)' out createTime);                    if (parse)                  {                      this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                      this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                      this.lastTimestampSeen = createTime;                  }              }              else if (line.Contains("JM Finish time:"))              {                  // Cosmos-specific line                  // JM Finish time: 129140295499437263 2010-03-25T22:25:49.943726Z                  Match m = Regex.Match(line' @"JM Finish time: (\d+)");                  DateTime time = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.lastTimestampSeen = time;                  this.ManagerVertex.End = time;              }              else if (line.StartsWith("Stop time "))              {                  // HPC L2H specific line                  // Stop time (Exit code = 2148734208): 04/05/2011 17:25:46.614                  Regex regex = new Regex(@"Stop time \(Exit code = (.*)\): (.*)");                  Match m = regex.Match(line);                  if (m.Success)                  {                      this.ManagerStdoutIncomplete = false;                        DateTime time;                      bool parse = DateTime.TryParse(m.Groups[2].Value' out time);                      if (parse)                      {                          this.lastTimestampSeen = time;                          this.ManagerVertex.End = time;                      }                        this.ErrorCode = m.Groups[1].Value;                      if (this.ErrorCode == "0")                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                      }                      else                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                      }                  }              }              else if (line.Contains("Timing Information"))              {                  // Timing Information 4 1 Super__0[0] 128654556603428182 0.0000 0.0000 0.0000 0.0000 0.2500                   Match m = timingInfoRegex.Match(line);                  if (m.Success)                  {                      int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      DateTime createtime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[4].Value);                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi == null)                          return; // we do not keep track of vertices with duplicate scheduling' so these won't show up here                        if (vi.State == ExecutedVertexInstance.VertexState.Started)                      {                          Console.WriteLine("Timing information while vertex is still running " + vi);                          //throw new ClusterException("Timing information for vertex still running: " + vi);                      }                      DateTime last = vi.SetTiming(createtime' m.Groups[5].Value' m.Groups[6].Value' m.Groups[7].Value' m.Groups[8].Value' m.Groups[9].Value);                      if (last > this.lastTimestampSeen)                          this.lastTimestampSeen = last;                      this.ManagerVertex.MarkVertexWasRunning(last);                        try                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              this.UsefulCPUTime += vi.RunningTime;                          else if (vi.RunningTime > TimeSpan.Zero)                              this.WastedCPUTime += vi.RunningTime;                      }                      catch (Exception ex)                      {                          Console.WriteLine("Time value exception: " + ex.Message);                      }                  }                  else                      throw new DryadException("Unmatched timing information line " + line);              }              else if (line.Contains("Process has failed"))              {                  // Process has failed Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 Exitcode 0 status The operation succeeded                  // failedRegex = new Regex(@"Process has failed Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) Exitcode (.*)"'                  Match m = failedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string exitcode = m.Groups[6].Value;                      //string status = m.Groups[7].Value;                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          vi.ExitCode = exitcode;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                          //vi.ErrorString = status;                      }                  }              }              else if (line.Contains("ABORTING:"))              {                  this.AbortingMsg = line.Substring(10);                  this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);              }              else if (line.Contains("Accurate read data"))              {                  Match m = datareadRegex.Match(line);                  if (m.Success)                  {                      this.TotalDataRead = long.Parse(m.Groups[1].Value);                      this.LocalReadData = long.Parse(m.Groups[2].Value);                      this.IntraPodDataRead = long.Parse(m.Groups[3].Value);                      this.CrossPodDataRead = long.Parse(m.Groups[4].Value);                  }              }              else if (line.Contains("<ErrorString>"))              {                  //some errors contains "Error returned from managed runtime invocation"                  //which shows the error is from application code                  Match m = Regex.Match(line' @"\<ErrorString\>(.*)\</ErrorString\>");                  if (m.Success && lastFailedVertex != null)                  {                      lastFailedVertex.AddErrorString(System.Web.HttpUtility.HtmlDecode(m.Groups[1].Value));                  }              }              else if (line.Contains("Canceling"))              {                  // Canceling vertex 1461.0 (Merge__13[258]) due to dependent failure                  Match m = cancelRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string name = m.Groups[3].Value;                        ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              vi.SetState(ExecutedVertexInstance.VertexState.Invalidated);                          else                               vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                      else                      {                          // TODO: this should not be needed' but this is a workaround for a bug in the HPC L2H software                          vi = new ExecutedVertexInstance(this' vertex' version' name' ""' lineTimeStamp);                          vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          this.jobVertices.Add(vi);                      }                      // Process wasn't even started' so there is nothing to cancel                  }              }              else if (line.Contains("Application"))              {                  //the job ends successfully                  Regex endSuccessRegex = new Regex(@"Application completed successfully.");                  //the job failed                  Regex endFailRegex = new Regex(@"Application failed with error code (.*)");                    Match m1 = endFailRegex.Match(line);                    if (m1.Success)                  {                      this.ErrorCode = m1.Groups[1].Value;                      this.ManagerStdoutIncomplete = false;                      this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                  }                  else                  {                      Match m2 = endSuccessRegex.Match(line);                      if (m2.Success)                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                          this.ManagerStdoutIncomplete = false;                      }                  }              }              else if (line.StartsWith("Input"))              {                  // Input vertex %u (%s) had %u read failure%s\n                  Match m = inputFailureRegex.Match(line);                  if (m.Success)                  {                      this.AbortingMsg = line;                  }              }              else if (line.Contains("Vertex"))              {                  // terminationRegex = new Regex(@"Vertex (\d+)\.(\d+) \((.+)\) machine (\S+) guid \{?([-0-9A-F]+)\}? status (.*)"                  Match m = terminationRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(vertex' version);                      if (vi == null)                      {                          Trace.TraceInformation("Could not find vertex {0}.{1} line {2}"' vertex' version' line);                      }                      else                      {                          bool failed = vi.SetTermination(m.Groups[6].Value' lineTimeStamp);                          if (failed)                              this.lastFailedVertex = vi;                      }                  }              }
Magic Number,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseStdoutLine,The following statement contains a magic number: if (line.Contains("Created process execution record"))              {                  Match m = vertexCreatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Created process execution record for vertex (\d+) \((.*)\) v.(\d+) GUID \{?([-A-F0-9]+)\}?                      int number = Int32.Parse(m.Groups[1].Value);                      string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                        // the vertex may be already there' sometimes numbers are reused...                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi == null)                      {                          vi = new ExecutedVertexInstance(this' number' version' name' guid' lineTimeStamp);                          this.jobVertices.Add(vi);                      }                  }                  else                  {                      m = verticesCreatedRegex.Match(line);                      if (m.Success)                      {                          lineTimeStamp = ParseLineTimestamp(line);                            // Created process execution record for vertices (.*) v.(\d+) GUID \{?([-A-F0-9]+)\}?                          // Created process execution record for vertices 192 (Merge__41[0]) 223 (Union__45[0]) v.0 GUID {0297A91C-FFEA-42EA-94AF-CD0163A04D45}                          int version = Int32.Parse(m.Groups[2].Value);                          string vertices = m.Groups[1].Value;                          string guid = m.Groups[3].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                            IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                          foreach (var p in vertexList)                          {                              int number = p.Item2;                              ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                              if (vi == null)                              {                                  vi = new ExecutedVertexInstance(this' number' version' p.Item1' guid' lineTimeStamp);                                  this.jobVertices.Add(vi);                              }                          }                      }                  }              }              else if (line.StartsWith("Creating process"))              {                  Match m = processCreatingRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Creating process for vertex (\d+) \((.*)\\) v.(\d+) GUID \{?([-A-F0-9]+)\}? machine (\w+)                      int number = Int32.Parse(m.Groups[1].Value);                      //string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value;                         ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          this.jobVertices.Remap(vi' guid);                      }                  }              }              else if (line.StartsWith("Process was revoked"))              {                  Match m = revokedRegex.Match(line);                  if (m.Success)                  {                      string oldGuid = m.Groups[1].Value;                      ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(oldGuid);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Revoked);                          string newGuid = m.Groups[2].Value;                          this.jobVertices.Remap(vi' newGuid);                      }                      else                      {                          Trace.TraceInformation("Could not find revoked vertex with guid " + oldGuid);                      }                  }              }              else if (line.StartsWith("---HiPriTime"))              {                  // Scope-specific line which we use to get the i/o information                  // ---HiPriTime D7D51A1F-6693-4378-95FD-FC778A67C632'F52CA694-0202-411E-85E9-0C883E770A0E'SV4_Extract_Split[0]'Completed'ch1sch010331112'2011-05-03 15:26:01.681 PDT'2011-05-03 15:26:01.696 PDT'2011-05-03 15:26:02.118 PDT'2011-05-03 15:26:04.286 PDT'2011-05-03 15:26:07.656 PDT'2011-05-03 15:26:01.696 PDT'97390825'1498630                  string info = line.Substring(13);                  string[] parts = info.Split(''');                  if (parts.Length >= 13)                  {                      long read = long.Parse(parts[11]);                      long written = long.Parse(parts[12]);                      string guid = parts[1];                        ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(guid);                      if (vi != null)                      {                          vi.DataRead = read;                          vi.DataWritten = written;                          this.TotalDataRead += read;                      }                  }              }              else if (line.Contains("Io information"))              {                  // HPC-specific line                  Match m = ioRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.DataRead = long.Parse(m.Groups[4].Value);                          vi.DataWritten = long.Parse(m.Groups[5].Value);                          this.TotalDataRead += vi.DataRead;                      }                  }              }              else if (line.Contains("Process started"))              {                  //those vertices which are being canceled may not be here                  Match m = vertexStartRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        string version = m.Groups[3].Value;                      string guid = m.Groups[4].Value;                      string pid = this.ClusterConfiguration.ExtractPidFromGuid(guid' this.Summary);                      DryadProcessIdentifier identifier = new DryadProcessIdentifier(pid);                      string machine = m.Groups[5].Value;                        // Process started for vertex 4 (Super__0[0]) v.0 GUID {9DDD0B00-C93F-46D2-9073-1CFD27829300} machine sherwood-255                      // Process started for vertices 23 (Merge__29) 24 (Apply__33) v.0 GUID {E945DC5D-9AF6-4732-8770-2A6BF7FA3041} machine sherwood-237                        string vertices = m.Groups[2].Value;                      // This is a list of (number \(name\))* pairs                      // we will assume that the parantheses are matched' or we can't do much                        bool onevertex;                      if (m.Groups[1].Value == "ex")  // one vertEX                          onevertex = true;                      else if (m.Groups[1].Value == "ices")                          onevertex = false;                      else                          throw new DryadException("Can't figure out if one or many vertices");                        IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                        int vertexcount = 0;                      int iversion = int.Parse(version);                        if (lineTimeStamp > this.lastTimestampSeen)                          this.lastTimestampSeen = lineTimeStamp;                      foreach (var p in vertexList)                      {                          int number = p.Item2;                          ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' iversion);                          //new ExecutedVertexInstance(this' number' version' name' identifier' machine' this.lastTimestampSeen);                          if (vi == null)                              Trace.TraceInformation("Could not find information for vertex {0}.{1}"' number' version);                          else                              vi.SetStartInformation(this' machine' this.lastTimestampSeen' identifier' guid);                          vertexcount++;                      }                        if (vertexcount > 1 && onevertex)                          throw new DryadException("Expected one vertex' found " + vertexcount);                  }                  else                  {                      Trace.TraceInformation("Unexpected parsing error on line {0}"' line);                  }              }              else if (line.Contains("Abandoning"))              {                  Match m = vertexAbandonedRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                          vi.SetState(ExecutedVertexInstance.VertexState.Abandoned);                  }              }              else if (line.Contains("Setting"))              {                  Match m = setToFailedlRegex.Match(line);                  if (m.Success)                  {                      // Setting vertex 1461.0 (Merge__13[258]) to failed                      // Setting vertex (\d+)\.(\d+) \((.+)\) to failed(.*)                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          //vi.ErrorString = m.Groups[4].Value;                      }                  }              }              else if (line.Contains("Process was terminated"))              {                  // terminatedRegex = new Regex(@"Process was terminated Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) status (.*)"'                  // Process was terminated Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 status The operation succeeded                  Match m = terminatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          // sometimes successful processes are terminated' because they don't report quickly enough being done                          if (vi.State != ExecutedVertexInstance.VertexState.Successful)                          {                              vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          }                          vi.ErrorString = m.Groups[6].Value;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                  }              }              else if (line.Contains("Timing Information Graph Start Time"))              {                  // Cosmos-specific line                  // Timing Information Graph Start Time 128654556581866096                  Match m = Regex.Match(line' @"Timing Information Graph Start Time (\d+)");                  DateTime createTime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                  this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                  this.lastTimestampSeen = createTime;              }              else if (line.StartsWith("Start time: "))              {                  // HPC L2H specific line                  // Start time: 04/05/2011 17:25:42.223                  DateTime createTime;                  bool parse = DateTime.TryParse(line.Substring("Start time: ".Length)' out createTime);                    if (parse)                  {                      this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                      this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                      this.lastTimestampSeen = createTime;                  }              }              else if (line.Contains("JM Finish time:"))              {                  // Cosmos-specific line                  // JM Finish time: 129140295499437263 2010-03-25T22:25:49.943726Z                  Match m = Regex.Match(line' @"JM Finish time: (\d+)");                  DateTime time = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.lastTimestampSeen = time;                  this.ManagerVertex.End = time;              }              else if (line.StartsWith("Stop time "))              {                  // HPC L2H specific line                  // Stop time (Exit code = 2148734208): 04/05/2011 17:25:46.614                  Regex regex = new Regex(@"Stop time \(Exit code = (.*)\): (.*)");                  Match m = regex.Match(line);                  if (m.Success)                  {                      this.ManagerStdoutIncomplete = false;                        DateTime time;                      bool parse = DateTime.TryParse(m.Groups[2].Value' out time);                      if (parse)                      {                          this.lastTimestampSeen = time;                          this.ManagerVertex.End = time;                      }                        this.ErrorCode = m.Groups[1].Value;                      if (this.ErrorCode == "0")                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                      }                      else                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                      }                  }              }              else if (line.Contains("Timing Information"))              {                  // Timing Information 4 1 Super__0[0] 128654556603428182 0.0000 0.0000 0.0000 0.0000 0.2500                   Match m = timingInfoRegex.Match(line);                  if (m.Success)                  {                      int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      DateTime createtime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[4].Value);                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi == null)                          return; // we do not keep track of vertices with duplicate scheduling' so these won't show up here                        if (vi.State == ExecutedVertexInstance.VertexState.Started)                      {                          Console.WriteLine("Timing information while vertex is still running " + vi);                          //throw new ClusterException("Timing information for vertex still running: " + vi);                      }                      DateTime last = vi.SetTiming(createtime' m.Groups[5].Value' m.Groups[6].Value' m.Groups[7].Value' m.Groups[8].Value' m.Groups[9].Value);                      if (last > this.lastTimestampSeen)                          this.lastTimestampSeen = last;                      this.ManagerVertex.MarkVertexWasRunning(last);                        try                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              this.UsefulCPUTime += vi.RunningTime;                          else if (vi.RunningTime > TimeSpan.Zero)                              this.WastedCPUTime += vi.RunningTime;                      }                      catch (Exception ex)                      {                          Console.WriteLine("Time value exception: " + ex.Message);                      }                  }                  else                      throw new DryadException("Unmatched timing information line " + line);              }              else if (line.Contains("Process has failed"))              {                  // Process has failed Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 Exitcode 0 status The operation succeeded                  // failedRegex = new Regex(@"Process has failed Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) Exitcode (.*)"'                  Match m = failedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string exitcode = m.Groups[6].Value;                      //string status = m.Groups[7].Value;                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          vi.ExitCode = exitcode;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                          //vi.ErrorString = status;                      }                  }              }              else if (line.Contains("ABORTING:"))              {                  this.AbortingMsg = line.Substring(10);                  this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);              }              else if (line.Contains("Accurate read data"))              {                  Match m = datareadRegex.Match(line);                  if (m.Success)                  {                      this.TotalDataRead = long.Parse(m.Groups[1].Value);                      this.LocalReadData = long.Parse(m.Groups[2].Value);                      this.IntraPodDataRead = long.Parse(m.Groups[3].Value);                      this.CrossPodDataRead = long.Parse(m.Groups[4].Value);                  }              }              else if (line.Contains("<ErrorString>"))              {                  //some errors contains "Error returned from managed runtime invocation"                  //which shows the error is from application code                  Match m = Regex.Match(line' @"\<ErrorString\>(.*)\</ErrorString\>");                  if (m.Success && lastFailedVertex != null)                  {                      lastFailedVertex.AddErrorString(System.Web.HttpUtility.HtmlDecode(m.Groups[1].Value));                  }              }              else if (line.Contains("Canceling"))              {                  // Canceling vertex 1461.0 (Merge__13[258]) due to dependent failure                  Match m = cancelRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string name = m.Groups[3].Value;                        ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              vi.SetState(ExecutedVertexInstance.VertexState.Invalidated);                          else                               vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                      else                      {                          // TODO: this should not be needed' but this is a workaround for a bug in the HPC L2H software                          vi = new ExecutedVertexInstance(this' vertex' version' name' ""' lineTimeStamp);                          vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          this.jobVertices.Add(vi);                      }                      // Process wasn't even started' so there is nothing to cancel                  }              }              else if (line.Contains("Application"))              {                  //the job ends successfully                  Regex endSuccessRegex = new Regex(@"Application completed successfully.");                  //the job failed                  Regex endFailRegex = new Regex(@"Application failed with error code (.*)");                    Match m1 = endFailRegex.Match(line);                    if (m1.Success)                  {                      this.ErrorCode = m1.Groups[1].Value;                      this.ManagerStdoutIncomplete = false;                      this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                  }                  else                  {                      Match m2 = endSuccessRegex.Match(line);                      if (m2.Success)                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                          this.ManagerStdoutIncomplete = false;                      }                  }              }              else if (line.StartsWith("Input"))              {                  // Input vertex %u (%s) had %u read failure%s\n                  Match m = inputFailureRegex.Match(line);                  if (m.Success)                  {                      this.AbortingMsg = line;                  }              }              else if (line.Contains("Vertex"))              {                  // terminationRegex = new Regex(@"Vertex (\d+)\.(\d+) \((.+)\) machine (\S+) guid \{?([-0-9A-F]+)\}? status (.*)"                  Match m = terminationRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(vertex' version);                      if (vi == null)                      {                          Trace.TraceInformation("Could not find vertex {0}.{1} line {2}"' vertex' version' line);                      }                      else                      {                          bool failed = vi.SetTermination(m.Groups[6].Value' lineTimeStamp);                          if (failed)                              this.lastFailedVertex = vi;                      }                  }              }
Magic Number,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseStdoutLine,The following statement contains a magic number: if (line.Contains("Created process execution record"))              {                  Match m = vertexCreatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Created process execution record for vertex (\d+) \((.*)\) v.(\d+) GUID \{?([-A-F0-9]+)\}?                      int number = Int32.Parse(m.Groups[1].Value);                      string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                        // the vertex may be already there' sometimes numbers are reused...                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi == null)                      {                          vi = new ExecutedVertexInstance(this' number' version' name' guid' lineTimeStamp);                          this.jobVertices.Add(vi);                      }                  }                  else                  {                      m = verticesCreatedRegex.Match(line);                      if (m.Success)                      {                          lineTimeStamp = ParseLineTimestamp(line);                            // Created process execution record for vertices (.*) v.(\d+) GUID \{?([-A-F0-9]+)\}?                          // Created process execution record for vertices 192 (Merge__41[0]) 223 (Union__45[0]) v.0 GUID {0297A91C-FFEA-42EA-94AF-CD0163A04D45}                          int version = Int32.Parse(m.Groups[2].Value);                          string vertices = m.Groups[1].Value;                          string guid = m.Groups[3].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                            IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                          foreach (var p in vertexList)                          {                              int number = p.Item2;                              ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                              if (vi == null)                              {                                  vi = new ExecutedVertexInstance(this' number' version' p.Item1' guid' lineTimeStamp);                                  this.jobVertices.Add(vi);                              }                          }                      }                  }              }              else if (line.StartsWith("Creating process"))              {                  Match m = processCreatingRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Creating process for vertex (\d+) \((.*)\\) v.(\d+) GUID \{?([-A-F0-9]+)\}? machine (\w+)                      int number = Int32.Parse(m.Groups[1].Value);                      //string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value;                         ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          this.jobVertices.Remap(vi' guid);                      }                  }              }              else if (line.StartsWith("Process was revoked"))              {                  Match m = revokedRegex.Match(line);                  if (m.Success)                  {                      string oldGuid = m.Groups[1].Value;                      ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(oldGuid);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Revoked);                          string newGuid = m.Groups[2].Value;                          this.jobVertices.Remap(vi' newGuid);                      }                      else                      {                          Trace.TraceInformation("Could not find revoked vertex with guid " + oldGuid);                      }                  }              }              else if (line.StartsWith("---HiPriTime"))              {                  // Scope-specific line which we use to get the i/o information                  // ---HiPriTime D7D51A1F-6693-4378-95FD-FC778A67C632'F52CA694-0202-411E-85E9-0C883E770A0E'SV4_Extract_Split[0]'Completed'ch1sch010331112'2011-05-03 15:26:01.681 PDT'2011-05-03 15:26:01.696 PDT'2011-05-03 15:26:02.118 PDT'2011-05-03 15:26:04.286 PDT'2011-05-03 15:26:07.656 PDT'2011-05-03 15:26:01.696 PDT'97390825'1498630                  string info = line.Substring(13);                  string[] parts = info.Split(''');                  if (parts.Length >= 13)                  {                      long read = long.Parse(parts[11]);                      long written = long.Parse(parts[12]);                      string guid = parts[1];                        ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(guid);                      if (vi != null)                      {                          vi.DataRead = read;                          vi.DataWritten = written;                          this.TotalDataRead += read;                      }                  }              }              else if (line.Contains("Io information"))              {                  // HPC-specific line                  Match m = ioRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.DataRead = long.Parse(m.Groups[4].Value);                          vi.DataWritten = long.Parse(m.Groups[5].Value);                          this.TotalDataRead += vi.DataRead;                      }                  }              }              else if (line.Contains("Process started"))              {                  //those vertices which are being canceled may not be here                  Match m = vertexStartRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        string version = m.Groups[3].Value;                      string guid = m.Groups[4].Value;                      string pid = this.ClusterConfiguration.ExtractPidFromGuid(guid' this.Summary);                      DryadProcessIdentifier identifier = new DryadProcessIdentifier(pid);                      string machine = m.Groups[5].Value;                        // Process started for vertex 4 (Super__0[0]) v.0 GUID {9DDD0B00-C93F-46D2-9073-1CFD27829300} machine sherwood-255                      // Process started for vertices 23 (Merge__29) 24 (Apply__33) v.0 GUID {E945DC5D-9AF6-4732-8770-2A6BF7FA3041} machine sherwood-237                        string vertices = m.Groups[2].Value;                      // This is a list of (number \(name\))* pairs                      // we will assume that the parantheses are matched' or we can't do much                        bool onevertex;                      if (m.Groups[1].Value == "ex")  // one vertEX                          onevertex = true;                      else if (m.Groups[1].Value == "ices")                          onevertex = false;                      else                          throw new DryadException("Can't figure out if one or many vertices");                        IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                        int vertexcount = 0;                      int iversion = int.Parse(version);                        if (lineTimeStamp > this.lastTimestampSeen)                          this.lastTimestampSeen = lineTimeStamp;                      foreach (var p in vertexList)                      {                          int number = p.Item2;                          ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' iversion);                          //new ExecutedVertexInstance(this' number' version' name' identifier' machine' this.lastTimestampSeen);                          if (vi == null)                              Trace.TraceInformation("Could not find information for vertex {0}.{1}"' number' version);                          else                              vi.SetStartInformation(this' machine' this.lastTimestampSeen' identifier' guid);                          vertexcount++;                      }                        if (vertexcount > 1 && onevertex)                          throw new DryadException("Expected one vertex' found " + vertexcount);                  }                  else                  {                      Trace.TraceInformation("Unexpected parsing error on line {0}"' line);                  }              }              else if (line.Contains("Abandoning"))              {                  Match m = vertexAbandonedRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                          vi.SetState(ExecutedVertexInstance.VertexState.Abandoned);                  }              }              else if (line.Contains("Setting"))              {                  Match m = setToFailedlRegex.Match(line);                  if (m.Success)                  {                      // Setting vertex 1461.0 (Merge__13[258]) to failed                      // Setting vertex (\d+)\.(\d+) \((.+)\) to failed(.*)                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          //vi.ErrorString = m.Groups[4].Value;                      }                  }              }              else if (line.Contains("Process was terminated"))              {                  // terminatedRegex = new Regex(@"Process was terminated Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) status (.*)"'                  // Process was terminated Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 status The operation succeeded                  Match m = terminatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          // sometimes successful processes are terminated' because they don't report quickly enough being done                          if (vi.State != ExecutedVertexInstance.VertexState.Successful)                          {                              vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          }                          vi.ErrorString = m.Groups[6].Value;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                  }              }              else if (line.Contains("Timing Information Graph Start Time"))              {                  // Cosmos-specific line                  // Timing Information Graph Start Time 128654556581866096                  Match m = Regex.Match(line' @"Timing Information Graph Start Time (\d+)");                  DateTime createTime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                  this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                  this.lastTimestampSeen = createTime;              }              else if (line.StartsWith("Start time: "))              {                  // HPC L2H specific line                  // Start time: 04/05/2011 17:25:42.223                  DateTime createTime;                  bool parse = DateTime.TryParse(line.Substring("Start time: ".Length)' out createTime);                    if (parse)                  {                      this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                      this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                      this.lastTimestampSeen = createTime;                  }              }              else if (line.Contains("JM Finish time:"))              {                  // Cosmos-specific line                  // JM Finish time: 129140295499437263 2010-03-25T22:25:49.943726Z                  Match m = Regex.Match(line' @"JM Finish time: (\d+)");                  DateTime time = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.lastTimestampSeen = time;                  this.ManagerVertex.End = time;              }              else if (line.StartsWith("Stop time "))              {                  // HPC L2H specific line                  // Stop time (Exit code = 2148734208): 04/05/2011 17:25:46.614                  Regex regex = new Regex(@"Stop time \(Exit code = (.*)\): (.*)");                  Match m = regex.Match(line);                  if (m.Success)                  {                      this.ManagerStdoutIncomplete = false;                        DateTime time;                      bool parse = DateTime.TryParse(m.Groups[2].Value' out time);                      if (parse)                      {                          this.lastTimestampSeen = time;                          this.ManagerVertex.End = time;                      }                        this.ErrorCode = m.Groups[1].Value;                      if (this.ErrorCode == "0")                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                      }                      else                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                      }                  }              }              else if (line.Contains("Timing Information"))              {                  // Timing Information 4 1 Super__0[0] 128654556603428182 0.0000 0.0000 0.0000 0.0000 0.2500                   Match m = timingInfoRegex.Match(line);                  if (m.Success)                  {                      int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      DateTime createtime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[4].Value);                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi == null)                          return; // we do not keep track of vertices with duplicate scheduling' so these won't show up here                        if (vi.State == ExecutedVertexInstance.VertexState.Started)                      {                          Console.WriteLine("Timing information while vertex is still running " + vi);                          //throw new ClusterException("Timing information for vertex still running: " + vi);                      }                      DateTime last = vi.SetTiming(createtime' m.Groups[5].Value' m.Groups[6].Value' m.Groups[7].Value' m.Groups[8].Value' m.Groups[9].Value);                      if (last > this.lastTimestampSeen)                          this.lastTimestampSeen = last;                      this.ManagerVertex.MarkVertexWasRunning(last);                        try                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              this.UsefulCPUTime += vi.RunningTime;                          else if (vi.RunningTime > TimeSpan.Zero)                              this.WastedCPUTime += vi.RunningTime;                      }                      catch (Exception ex)                      {                          Console.WriteLine("Time value exception: " + ex.Message);                      }                  }                  else                      throw new DryadException("Unmatched timing information line " + line);              }              else if (line.Contains("Process has failed"))              {                  // Process has failed Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 Exitcode 0 status The operation succeeded                  // failedRegex = new Regex(@"Process has failed Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) Exitcode (.*)"'                  Match m = failedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string exitcode = m.Groups[6].Value;                      //string status = m.Groups[7].Value;                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          vi.ExitCode = exitcode;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                          //vi.ErrorString = status;                      }                  }              }              else if (line.Contains("ABORTING:"))              {                  this.AbortingMsg = line.Substring(10);                  this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);              }              else if (line.Contains("Accurate read data"))              {                  Match m = datareadRegex.Match(line);                  if (m.Success)                  {                      this.TotalDataRead = long.Parse(m.Groups[1].Value);                      this.LocalReadData = long.Parse(m.Groups[2].Value);                      this.IntraPodDataRead = long.Parse(m.Groups[3].Value);                      this.CrossPodDataRead = long.Parse(m.Groups[4].Value);                  }              }              else if (line.Contains("<ErrorString>"))              {                  //some errors contains "Error returned from managed runtime invocation"                  //which shows the error is from application code                  Match m = Regex.Match(line' @"\<ErrorString\>(.*)\</ErrorString\>");                  if (m.Success && lastFailedVertex != null)                  {                      lastFailedVertex.AddErrorString(System.Web.HttpUtility.HtmlDecode(m.Groups[1].Value));                  }              }              else if (line.Contains("Canceling"))              {                  // Canceling vertex 1461.0 (Merge__13[258]) due to dependent failure                  Match m = cancelRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string name = m.Groups[3].Value;                        ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              vi.SetState(ExecutedVertexInstance.VertexState.Invalidated);                          else                               vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                      else                      {                          // TODO: this should not be needed' but this is a workaround for a bug in the HPC L2H software                          vi = new ExecutedVertexInstance(this' vertex' version' name' ""' lineTimeStamp);                          vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          this.jobVertices.Add(vi);                      }                      // Process wasn't even started' so there is nothing to cancel                  }              }              else if (line.Contains("Application"))              {                  //the job ends successfully                  Regex endSuccessRegex = new Regex(@"Application completed successfully.");                  //the job failed                  Regex endFailRegex = new Regex(@"Application failed with error code (.*)");                    Match m1 = endFailRegex.Match(line);                    if (m1.Success)                  {                      this.ErrorCode = m1.Groups[1].Value;                      this.ManagerStdoutIncomplete = false;                      this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                  }                  else                  {                      Match m2 = endSuccessRegex.Match(line);                      if (m2.Success)                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                          this.ManagerStdoutIncomplete = false;                      }                  }              }              else if (line.StartsWith("Input"))              {                  // Input vertex %u (%s) had %u read failure%s\n                  Match m = inputFailureRegex.Match(line);                  if (m.Success)                  {                      this.AbortingMsg = line;                  }              }              else if (line.Contains("Vertex"))              {                  // terminationRegex = new Regex(@"Vertex (\d+)\.(\d+) \((.+)\) machine (\S+) guid \{?([-0-9A-F]+)\}? status (.*)"                  Match m = terminationRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(vertex' version);                      if (vi == null)                      {                          Trace.TraceInformation("Could not find vertex {0}.{1} line {2}"' vertex' version' line);                      }                      else                      {                          bool failed = vi.SetTermination(m.Groups[6].Value' lineTimeStamp);                          if (failed)                              this.lastFailedVertex = vi;                      }                  }              }
Magic Number,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseStdoutLine,The following statement contains a magic number: if (line.Contains("Created process execution record"))              {                  Match m = vertexCreatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Created process execution record for vertex (\d+) \((.*)\) v.(\d+) GUID \{?([-A-F0-9]+)\}?                      int number = Int32.Parse(m.Groups[1].Value);                      string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                        // the vertex may be already there' sometimes numbers are reused...                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi == null)                      {                          vi = new ExecutedVertexInstance(this' number' version' name' guid' lineTimeStamp);                          this.jobVertices.Add(vi);                      }                  }                  else                  {                      m = verticesCreatedRegex.Match(line);                      if (m.Success)                      {                          lineTimeStamp = ParseLineTimestamp(line);                            // Created process execution record for vertices (.*) v.(\d+) GUID \{?([-A-F0-9]+)\}?                          // Created process execution record for vertices 192 (Merge__41[0]) 223 (Union__45[0]) v.0 GUID {0297A91C-FFEA-42EA-94AF-CD0163A04D45}                          int version = Int32.Parse(m.Groups[2].Value);                          string vertices = m.Groups[1].Value;                          string guid = m.Groups[3].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                            IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                          foreach (var p in vertexList)                          {                              int number = p.Item2;                              ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                              if (vi == null)                              {                                  vi = new ExecutedVertexInstance(this' number' version' p.Item1' guid' lineTimeStamp);                                  this.jobVertices.Add(vi);                              }                          }                      }                  }              }              else if (line.StartsWith("Creating process"))              {                  Match m = processCreatingRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Creating process for vertex (\d+) \((.*)\\) v.(\d+) GUID \{?([-A-F0-9]+)\}? machine (\w+)                      int number = Int32.Parse(m.Groups[1].Value);                      //string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value;                         ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          this.jobVertices.Remap(vi' guid);                      }                  }              }              else if (line.StartsWith("Process was revoked"))              {                  Match m = revokedRegex.Match(line);                  if (m.Success)                  {                      string oldGuid = m.Groups[1].Value;                      ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(oldGuid);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Revoked);                          string newGuid = m.Groups[2].Value;                          this.jobVertices.Remap(vi' newGuid);                      }                      else                      {                          Trace.TraceInformation("Could not find revoked vertex with guid " + oldGuid);                      }                  }              }              else if (line.StartsWith("---HiPriTime"))              {                  // Scope-specific line which we use to get the i/o information                  // ---HiPriTime D7D51A1F-6693-4378-95FD-FC778A67C632'F52CA694-0202-411E-85E9-0C883E770A0E'SV4_Extract_Split[0]'Completed'ch1sch010331112'2011-05-03 15:26:01.681 PDT'2011-05-03 15:26:01.696 PDT'2011-05-03 15:26:02.118 PDT'2011-05-03 15:26:04.286 PDT'2011-05-03 15:26:07.656 PDT'2011-05-03 15:26:01.696 PDT'97390825'1498630                  string info = line.Substring(13);                  string[] parts = info.Split(''');                  if (parts.Length >= 13)                  {                      long read = long.Parse(parts[11]);                      long written = long.Parse(parts[12]);                      string guid = parts[1];                        ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(guid);                      if (vi != null)                      {                          vi.DataRead = read;                          vi.DataWritten = written;                          this.TotalDataRead += read;                      }                  }              }              else if (line.Contains("Io information"))              {                  // HPC-specific line                  Match m = ioRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.DataRead = long.Parse(m.Groups[4].Value);                          vi.DataWritten = long.Parse(m.Groups[5].Value);                          this.TotalDataRead += vi.DataRead;                      }                  }              }              else if (line.Contains("Process started"))              {                  //those vertices which are being canceled may not be here                  Match m = vertexStartRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        string version = m.Groups[3].Value;                      string guid = m.Groups[4].Value;                      string pid = this.ClusterConfiguration.ExtractPidFromGuid(guid' this.Summary);                      DryadProcessIdentifier identifier = new DryadProcessIdentifier(pid);                      string machine = m.Groups[5].Value;                        // Process started for vertex 4 (Super__0[0]) v.0 GUID {9DDD0B00-C93F-46D2-9073-1CFD27829300} machine sherwood-255                      // Process started for vertices 23 (Merge__29) 24 (Apply__33) v.0 GUID {E945DC5D-9AF6-4732-8770-2A6BF7FA3041} machine sherwood-237                        string vertices = m.Groups[2].Value;                      // This is a list of (number \(name\))* pairs                      // we will assume that the parantheses are matched' or we can't do much                        bool onevertex;                      if (m.Groups[1].Value == "ex")  // one vertEX                          onevertex = true;                      else if (m.Groups[1].Value == "ices")                          onevertex = false;                      else                          throw new DryadException("Can't figure out if one or many vertices");                        IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                        int vertexcount = 0;                      int iversion = int.Parse(version);                        if (lineTimeStamp > this.lastTimestampSeen)                          this.lastTimestampSeen = lineTimeStamp;                      foreach (var p in vertexList)                      {                          int number = p.Item2;                          ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' iversion);                          //new ExecutedVertexInstance(this' number' version' name' identifier' machine' this.lastTimestampSeen);                          if (vi == null)                              Trace.TraceInformation("Could not find information for vertex {0}.{1}"' number' version);                          else                              vi.SetStartInformation(this' machine' this.lastTimestampSeen' identifier' guid);                          vertexcount++;                      }                        if (vertexcount > 1 && onevertex)                          throw new DryadException("Expected one vertex' found " + vertexcount);                  }                  else                  {                      Trace.TraceInformation("Unexpected parsing error on line {0}"' line);                  }              }              else if (line.Contains("Abandoning"))              {                  Match m = vertexAbandonedRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                          vi.SetState(ExecutedVertexInstance.VertexState.Abandoned);                  }              }              else if (line.Contains("Setting"))              {                  Match m = setToFailedlRegex.Match(line);                  if (m.Success)                  {                      // Setting vertex 1461.0 (Merge__13[258]) to failed                      // Setting vertex (\d+)\.(\d+) \((.+)\) to failed(.*)                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          //vi.ErrorString = m.Groups[4].Value;                      }                  }              }              else if (line.Contains("Process was terminated"))              {                  // terminatedRegex = new Regex(@"Process was terminated Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) status (.*)"'                  // Process was terminated Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 status The operation succeeded                  Match m = terminatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          // sometimes successful processes are terminated' because they don't report quickly enough being done                          if (vi.State != ExecutedVertexInstance.VertexState.Successful)                          {                              vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          }                          vi.ErrorString = m.Groups[6].Value;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                  }              }              else if (line.Contains("Timing Information Graph Start Time"))              {                  // Cosmos-specific line                  // Timing Information Graph Start Time 128654556581866096                  Match m = Regex.Match(line' @"Timing Information Graph Start Time (\d+)");                  DateTime createTime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                  this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                  this.lastTimestampSeen = createTime;              }              else if (line.StartsWith("Start time: "))              {                  // HPC L2H specific line                  // Start time: 04/05/2011 17:25:42.223                  DateTime createTime;                  bool parse = DateTime.TryParse(line.Substring("Start time: ".Length)' out createTime);                    if (parse)                  {                      this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                      this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                      this.lastTimestampSeen = createTime;                  }              }              else if (line.Contains("JM Finish time:"))              {                  // Cosmos-specific line                  // JM Finish time: 129140295499437263 2010-03-25T22:25:49.943726Z                  Match m = Regex.Match(line' @"JM Finish time: (\d+)");                  DateTime time = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.lastTimestampSeen = time;                  this.ManagerVertex.End = time;              }              else if (line.StartsWith("Stop time "))              {                  // HPC L2H specific line                  // Stop time (Exit code = 2148734208): 04/05/2011 17:25:46.614                  Regex regex = new Regex(@"Stop time \(Exit code = (.*)\): (.*)");                  Match m = regex.Match(line);                  if (m.Success)                  {                      this.ManagerStdoutIncomplete = false;                        DateTime time;                      bool parse = DateTime.TryParse(m.Groups[2].Value' out time);                      if (parse)                      {                          this.lastTimestampSeen = time;                          this.ManagerVertex.End = time;                      }                        this.ErrorCode = m.Groups[1].Value;                      if (this.ErrorCode == "0")                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                      }                      else                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                      }                  }              }              else if (line.Contains("Timing Information"))              {                  // Timing Information 4 1 Super__0[0] 128654556603428182 0.0000 0.0000 0.0000 0.0000 0.2500                   Match m = timingInfoRegex.Match(line);                  if (m.Success)                  {                      int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      DateTime createtime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[4].Value);                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi == null)                          return; // we do not keep track of vertices with duplicate scheduling' so these won't show up here                        if (vi.State == ExecutedVertexInstance.VertexState.Started)                      {                          Console.WriteLine("Timing information while vertex is still running " + vi);                          //throw new ClusterException("Timing information for vertex still running: " + vi);                      }                      DateTime last = vi.SetTiming(createtime' m.Groups[5].Value' m.Groups[6].Value' m.Groups[7].Value' m.Groups[8].Value' m.Groups[9].Value);                      if (last > this.lastTimestampSeen)                          this.lastTimestampSeen = last;                      this.ManagerVertex.MarkVertexWasRunning(last);                        try                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              this.UsefulCPUTime += vi.RunningTime;                          else if (vi.RunningTime > TimeSpan.Zero)                              this.WastedCPUTime += vi.RunningTime;                      }                      catch (Exception ex)                      {                          Console.WriteLine("Time value exception: " + ex.Message);                      }                  }                  else                      throw new DryadException("Unmatched timing information line " + line);              }              else if (line.Contains("Process has failed"))              {                  // Process has failed Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 Exitcode 0 status The operation succeeded                  // failedRegex = new Regex(@"Process has failed Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) Exitcode (.*)"'                  Match m = failedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string exitcode = m.Groups[6].Value;                      //string status = m.Groups[7].Value;                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          vi.ExitCode = exitcode;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                          //vi.ErrorString = status;                      }                  }              }              else if (line.Contains("ABORTING:"))              {                  this.AbortingMsg = line.Substring(10);                  this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);              }              else if (line.Contains("Accurate read data"))              {                  Match m = datareadRegex.Match(line);                  if (m.Success)                  {                      this.TotalDataRead = long.Parse(m.Groups[1].Value);                      this.LocalReadData = long.Parse(m.Groups[2].Value);                      this.IntraPodDataRead = long.Parse(m.Groups[3].Value);                      this.CrossPodDataRead = long.Parse(m.Groups[4].Value);                  }              }              else if (line.Contains("<ErrorString>"))              {                  //some errors contains "Error returned from managed runtime invocation"                  //which shows the error is from application code                  Match m = Regex.Match(line' @"\<ErrorString\>(.*)\</ErrorString\>");                  if (m.Success && lastFailedVertex != null)                  {                      lastFailedVertex.AddErrorString(System.Web.HttpUtility.HtmlDecode(m.Groups[1].Value));                  }              }              else if (line.Contains("Canceling"))              {                  // Canceling vertex 1461.0 (Merge__13[258]) due to dependent failure                  Match m = cancelRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string name = m.Groups[3].Value;                        ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              vi.SetState(ExecutedVertexInstance.VertexState.Invalidated);                          else                               vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                      else                      {                          // TODO: this should not be needed' but this is a workaround for a bug in the HPC L2H software                          vi = new ExecutedVertexInstance(this' vertex' version' name' ""' lineTimeStamp);                          vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          this.jobVertices.Add(vi);                      }                      // Process wasn't even started' so there is nothing to cancel                  }              }              else if (line.Contains("Application"))              {                  //the job ends successfully                  Regex endSuccessRegex = new Regex(@"Application completed successfully.");                  //the job failed                  Regex endFailRegex = new Regex(@"Application failed with error code (.*)");                    Match m1 = endFailRegex.Match(line);                    if (m1.Success)                  {                      this.ErrorCode = m1.Groups[1].Value;                      this.ManagerStdoutIncomplete = false;                      this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                  }                  else                  {                      Match m2 = endSuccessRegex.Match(line);                      if (m2.Success)                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                          this.ManagerStdoutIncomplete = false;                      }                  }              }              else if (line.StartsWith("Input"))              {                  // Input vertex %u (%s) had %u read failure%s\n                  Match m = inputFailureRegex.Match(line);                  if (m.Success)                  {                      this.AbortingMsg = line;                  }              }              else if (line.Contains("Vertex"))              {                  // terminationRegex = new Regex(@"Vertex (\d+)\.(\d+) \((.+)\) machine (\S+) guid \{?([-0-9A-F]+)\}? status (.*)"                  Match m = terminationRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(vertex' version);                      if (vi == null)                      {                          Trace.TraceInformation("Could not find vertex {0}.{1} line {2}"' vertex' version' line);                      }                      else                      {                          bool failed = vi.SetTermination(m.Groups[6].Value' lineTimeStamp);                          if (failed)                              this.lastFailedVertex = vi;                      }                  }              }
Magic Number,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseStdoutLine,The following statement contains a magic number: if (line.Contains("Created process execution record"))              {                  Match m = vertexCreatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Created process execution record for vertex (\d+) \((.*)\) v.(\d+) GUID \{?([-A-F0-9]+)\}?                      int number = Int32.Parse(m.Groups[1].Value);                      string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                        // the vertex may be already there' sometimes numbers are reused...                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi == null)                      {                          vi = new ExecutedVertexInstance(this' number' version' name' guid' lineTimeStamp);                          this.jobVertices.Add(vi);                      }                  }                  else                  {                      m = verticesCreatedRegex.Match(line);                      if (m.Success)                      {                          lineTimeStamp = ParseLineTimestamp(line);                            // Created process execution record for vertices (.*) v.(\d+) GUID \{?([-A-F0-9]+)\}?                          // Created process execution record for vertices 192 (Merge__41[0]) 223 (Union__45[0]) v.0 GUID {0297A91C-FFEA-42EA-94AF-CD0163A04D45}                          int version = Int32.Parse(m.Groups[2].Value);                          string vertices = m.Groups[1].Value;                          string guid = m.Groups[3].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                            IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                          foreach (var p in vertexList)                          {                              int number = p.Item2;                              ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                              if (vi == null)                              {                                  vi = new ExecutedVertexInstance(this' number' version' p.Item1' guid' lineTimeStamp);                                  this.jobVertices.Add(vi);                              }                          }                      }                  }              }              else if (line.StartsWith("Creating process"))              {                  Match m = processCreatingRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Creating process for vertex (\d+) \((.*)\\) v.(\d+) GUID \{?([-A-F0-9]+)\}? machine (\w+)                      int number = Int32.Parse(m.Groups[1].Value);                      //string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value;                         ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          this.jobVertices.Remap(vi' guid);                      }                  }              }              else if (line.StartsWith("Process was revoked"))              {                  Match m = revokedRegex.Match(line);                  if (m.Success)                  {                      string oldGuid = m.Groups[1].Value;                      ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(oldGuid);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Revoked);                          string newGuid = m.Groups[2].Value;                          this.jobVertices.Remap(vi' newGuid);                      }                      else                      {                          Trace.TraceInformation("Could not find revoked vertex with guid " + oldGuid);                      }                  }              }              else if (line.StartsWith("---HiPriTime"))              {                  // Scope-specific line which we use to get the i/o information                  // ---HiPriTime D7D51A1F-6693-4378-95FD-FC778A67C632'F52CA694-0202-411E-85E9-0C883E770A0E'SV4_Extract_Split[0]'Completed'ch1sch010331112'2011-05-03 15:26:01.681 PDT'2011-05-03 15:26:01.696 PDT'2011-05-03 15:26:02.118 PDT'2011-05-03 15:26:04.286 PDT'2011-05-03 15:26:07.656 PDT'2011-05-03 15:26:01.696 PDT'97390825'1498630                  string info = line.Substring(13);                  string[] parts = info.Split(''');                  if (parts.Length >= 13)                  {                      long read = long.Parse(parts[11]);                      long written = long.Parse(parts[12]);                      string guid = parts[1];                        ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(guid);                      if (vi != null)                      {                          vi.DataRead = read;                          vi.DataWritten = written;                          this.TotalDataRead += read;                      }                  }              }              else if (line.Contains("Io information"))              {                  // HPC-specific line                  Match m = ioRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.DataRead = long.Parse(m.Groups[4].Value);                          vi.DataWritten = long.Parse(m.Groups[5].Value);                          this.TotalDataRead += vi.DataRead;                      }                  }              }              else if (line.Contains("Process started"))              {                  //those vertices which are being canceled may not be here                  Match m = vertexStartRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        string version = m.Groups[3].Value;                      string guid = m.Groups[4].Value;                      string pid = this.ClusterConfiguration.ExtractPidFromGuid(guid' this.Summary);                      DryadProcessIdentifier identifier = new DryadProcessIdentifier(pid);                      string machine = m.Groups[5].Value;                        // Process started for vertex 4 (Super__0[0]) v.0 GUID {9DDD0B00-C93F-46D2-9073-1CFD27829300} machine sherwood-255                      // Process started for vertices 23 (Merge__29) 24 (Apply__33) v.0 GUID {E945DC5D-9AF6-4732-8770-2A6BF7FA3041} machine sherwood-237                        string vertices = m.Groups[2].Value;                      // This is a list of (number \(name\))* pairs                      // we will assume that the parantheses are matched' or we can't do much                        bool onevertex;                      if (m.Groups[1].Value == "ex")  // one vertEX                          onevertex = true;                      else if (m.Groups[1].Value == "ices")                          onevertex = false;                      else                          throw new DryadException("Can't figure out if one or many vertices");                        IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                        int vertexcount = 0;                      int iversion = int.Parse(version);                        if (lineTimeStamp > this.lastTimestampSeen)                          this.lastTimestampSeen = lineTimeStamp;                      foreach (var p in vertexList)                      {                          int number = p.Item2;                          ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' iversion);                          //new ExecutedVertexInstance(this' number' version' name' identifier' machine' this.lastTimestampSeen);                          if (vi == null)                              Trace.TraceInformation("Could not find information for vertex {0}.{1}"' number' version);                          else                              vi.SetStartInformation(this' machine' this.lastTimestampSeen' identifier' guid);                          vertexcount++;                      }                        if (vertexcount > 1 && onevertex)                          throw new DryadException("Expected one vertex' found " + vertexcount);                  }                  else                  {                      Trace.TraceInformation("Unexpected parsing error on line {0}"' line);                  }              }              else if (line.Contains("Abandoning"))              {                  Match m = vertexAbandonedRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                          vi.SetState(ExecutedVertexInstance.VertexState.Abandoned);                  }              }              else if (line.Contains("Setting"))              {                  Match m = setToFailedlRegex.Match(line);                  if (m.Success)                  {                      // Setting vertex 1461.0 (Merge__13[258]) to failed                      // Setting vertex (\d+)\.(\d+) \((.+)\) to failed(.*)                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          //vi.ErrorString = m.Groups[4].Value;                      }                  }              }              else if (line.Contains("Process was terminated"))              {                  // terminatedRegex = new Regex(@"Process was terminated Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) status (.*)"'                  // Process was terminated Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 status The operation succeeded                  Match m = terminatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          // sometimes successful processes are terminated' because they don't report quickly enough being done                          if (vi.State != ExecutedVertexInstance.VertexState.Successful)                          {                              vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          }                          vi.ErrorString = m.Groups[6].Value;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                  }              }              else if (line.Contains("Timing Information Graph Start Time"))              {                  // Cosmos-specific line                  // Timing Information Graph Start Time 128654556581866096                  Match m = Regex.Match(line' @"Timing Information Graph Start Time (\d+)");                  DateTime createTime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                  this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                  this.lastTimestampSeen = createTime;              }              else if (line.StartsWith("Start time: "))              {                  // HPC L2H specific line                  // Start time: 04/05/2011 17:25:42.223                  DateTime createTime;                  bool parse = DateTime.TryParse(line.Substring("Start time: ".Length)' out createTime);                    if (parse)                  {                      this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                      this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                      this.lastTimestampSeen = createTime;                  }              }              else if (line.Contains("JM Finish time:"))              {                  // Cosmos-specific line                  // JM Finish time: 129140295499437263 2010-03-25T22:25:49.943726Z                  Match m = Regex.Match(line' @"JM Finish time: (\d+)");                  DateTime time = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.lastTimestampSeen = time;                  this.ManagerVertex.End = time;              }              else if (line.StartsWith("Stop time "))              {                  // HPC L2H specific line                  // Stop time (Exit code = 2148734208): 04/05/2011 17:25:46.614                  Regex regex = new Regex(@"Stop time \(Exit code = (.*)\): (.*)");                  Match m = regex.Match(line);                  if (m.Success)                  {                      this.ManagerStdoutIncomplete = false;                        DateTime time;                      bool parse = DateTime.TryParse(m.Groups[2].Value' out time);                      if (parse)                      {                          this.lastTimestampSeen = time;                          this.ManagerVertex.End = time;                      }                        this.ErrorCode = m.Groups[1].Value;                      if (this.ErrorCode == "0")                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                      }                      else                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                      }                  }              }              else if (line.Contains("Timing Information"))              {                  // Timing Information 4 1 Super__0[0] 128654556603428182 0.0000 0.0000 0.0000 0.0000 0.2500                   Match m = timingInfoRegex.Match(line);                  if (m.Success)                  {                      int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      DateTime createtime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[4].Value);                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi == null)                          return; // we do not keep track of vertices with duplicate scheduling' so these won't show up here                        if (vi.State == ExecutedVertexInstance.VertexState.Started)                      {                          Console.WriteLine("Timing information while vertex is still running " + vi);                          //throw new ClusterException("Timing information for vertex still running: " + vi);                      }                      DateTime last = vi.SetTiming(createtime' m.Groups[5].Value' m.Groups[6].Value' m.Groups[7].Value' m.Groups[8].Value' m.Groups[9].Value);                      if (last > this.lastTimestampSeen)                          this.lastTimestampSeen = last;                      this.ManagerVertex.MarkVertexWasRunning(last);                        try                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              this.UsefulCPUTime += vi.RunningTime;                          else if (vi.RunningTime > TimeSpan.Zero)                              this.WastedCPUTime += vi.RunningTime;                      }                      catch (Exception ex)                      {                          Console.WriteLine("Time value exception: " + ex.Message);                      }                  }                  else                      throw new DryadException("Unmatched timing information line " + line);              }              else if (line.Contains("Process has failed"))              {                  // Process has failed Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 Exitcode 0 status The operation succeeded                  // failedRegex = new Regex(@"Process has failed Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) Exitcode (.*)"'                  Match m = failedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string exitcode = m.Groups[6].Value;                      //string status = m.Groups[7].Value;                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          vi.ExitCode = exitcode;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                          //vi.ErrorString = status;                      }                  }              }              else if (line.Contains("ABORTING:"))              {                  this.AbortingMsg = line.Substring(10);                  this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);              }              else if (line.Contains("Accurate read data"))              {                  Match m = datareadRegex.Match(line);                  if (m.Success)                  {                      this.TotalDataRead = long.Parse(m.Groups[1].Value);                      this.LocalReadData = long.Parse(m.Groups[2].Value);                      this.IntraPodDataRead = long.Parse(m.Groups[3].Value);                      this.CrossPodDataRead = long.Parse(m.Groups[4].Value);                  }              }              else if (line.Contains("<ErrorString>"))              {                  //some errors contains "Error returned from managed runtime invocation"                  //which shows the error is from application code                  Match m = Regex.Match(line' @"\<ErrorString\>(.*)\</ErrorString\>");                  if (m.Success && lastFailedVertex != null)                  {                      lastFailedVertex.AddErrorString(System.Web.HttpUtility.HtmlDecode(m.Groups[1].Value));                  }              }              else if (line.Contains("Canceling"))              {                  // Canceling vertex 1461.0 (Merge__13[258]) due to dependent failure                  Match m = cancelRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string name = m.Groups[3].Value;                        ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              vi.SetState(ExecutedVertexInstance.VertexState.Invalidated);                          else                               vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                      else                      {                          // TODO: this should not be needed' but this is a workaround for a bug in the HPC L2H software                          vi = new ExecutedVertexInstance(this' vertex' version' name' ""' lineTimeStamp);                          vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          this.jobVertices.Add(vi);                      }                      // Process wasn't even started' so there is nothing to cancel                  }              }              else if (line.Contains("Application"))              {                  //the job ends successfully                  Regex endSuccessRegex = new Regex(@"Application completed successfully.");                  //the job failed                  Regex endFailRegex = new Regex(@"Application failed with error code (.*)");                    Match m1 = endFailRegex.Match(line);                    if (m1.Success)                  {                      this.ErrorCode = m1.Groups[1].Value;                      this.ManagerStdoutIncomplete = false;                      this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                  }                  else                  {                      Match m2 = endSuccessRegex.Match(line);                      if (m2.Success)                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                          this.ManagerStdoutIncomplete = false;                      }                  }              }              else if (line.StartsWith("Input"))              {                  // Input vertex %u (%s) had %u read failure%s\n                  Match m = inputFailureRegex.Match(line);                  if (m.Success)                  {                      this.AbortingMsg = line;                  }              }              else if (line.Contains("Vertex"))              {                  // terminationRegex = new Regex(@"Vertex (\d+)\.(\d+) \((.+)\) machine (\S+) guid \{?([-0-9A-F]+)\}? status (.*)"                  Match m = terminationRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(vertex' version);                      if (vi == null)                      {                          Trace.TraceInformation("Could not find vertex {0}.{1} line {2}"' vertex' version' line);                      }                      else                      {                          bool failed = vi.SetTermination(m.Groups[6].Value' lineTimeStamp);                          if (failed)                              this.lastFailedVertex = vi;                      }                  }              }
Magic Number,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseStdoutLine,The following statement contains a magic number: if (line.Contains("Created process execution record"))              {                  Match m = vertexCreatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Created process execution record for vertex (\d+) \((.*)\) v.(\d+) GUID \{?([-A-F0-9]+)\}?                      int number = Int32.Parse(m.Groups[1].Value);                      string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                        // the vertex may be already there' sometimes numbers are reused...                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi == null)                      {                          vi = new ExecutedVertexInstance(this' number' version' name' guid' lineTimeStamp);                          this.jobVertices.Add(vi);                      }                  }                  else                  {                      m = verticesCreatedRegex.Match(line);                      if (m.Success)                      {                          lineTimeStamp = ParseLineTimestamp(line);                            // Created process execution record for vertices (.*) v.(\d+) GUID \{?([-A-F0-9]+)\}?                          // Created process execution record for vertices 192 (Merge__41[0]) 223 (Union__45[0]) v.0 GUID {0297A91C-FFEA-42EA-94AF-CD0163A04D45}                          int version = Int32.Parse(m.Groups[2].Value);                          string vertices = m.Groups[1].Value;                          string guid = m.Groups[3].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                            IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                          foreach (var p in vertexList)                          {                              int number = p.Item2;                              ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                              if (vi == null)                              {                                  vi = new ExecutedVertexInstance(this' number' version' p.Item1' guid' lineTimeStamp);                                  this.jobVertices.Add(vi);                              }                          }                      }                  }              }              else if (line.StartsWith("Creating process"))              {                  Match m = processCreatingRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Creating process for vertex (\d+) \((.*)\\) v.(\d+) GUID \{?([-A-F0-9]+)\}? machine (\w+)                      int number = Int32.Parse(m.Groups[1].Value);                      //string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value;                         ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          this.jobVertices.Remap(vi' guid);                      }                  }              }              else if (line.StartsWith("Process was revoked"))              {                  Match m = revokedRegex.Match(line);                  if (m.Success)                  {                      string oldGuid = m.Groups[1].Value;                      ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(oldGuid);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Revoked);                          string newGuid = m.Groups[2].Value;                          this.jobVertices.Remap(vi' newGuid);                      }                      else                      {                          Trace.TraceInformation("Could not find revoked vertex with guid " + oldGuid);                      }                  }              }              else if (line.StartsWith("---HiPriTime"))              {                  // Scope-specific line which we use to get the i/o information                  // ---HiPriTime D7D51A1F-6693-4378-95FD-FC778A67C632'F52CA694-0202-411E-85E9-0C883E770A0E'SV4_Extract_Split[0]'Completed'ch1sch010331112'2011-05-03 15:26:01.681 PDT'2011-05-03 15:26:01.696 PDT'2011-05-03 15:26:02.118 PDT'2011-05-03 15:26:04.286 PDT'2011-05-03 15:26:07.656 PDT'2011-05-03 15:26:01.696 PDT'97390825'1498630                  string info = line.Substring(13);                  string[] parts = info.Split(''');                  if (parts.Length >= 13)                  {                      long read = long.Parse(parts[11]);                      long written = long.Parse(parts[12]);                      string guid = parts[1];                        ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(guid);                      if (vi != null)                      {                          vi.DataRead = read;                          vi.DataWritten = written;                          this.TotalDataRead += read;                      }                  }              }              else if (line.Contains("Io information"))              {                  // HPC-specific line                  Match m = ioRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.DataRead = long.Parse(m.Groups[4].Value);                          vi.DataWritten = long.Parse(m.Groups[5].Value);                          this.TotalDataRead += vi.DataRead;                      }                  }              }              else if (line.Contains("Process started"))              {                  //those vertices which are being canceled may not be here                  Match m = vertexStartRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        string version = m.Groups[3].Value;                      string guid = m.Groups[4].Value;                      string pid = this.ClusterConfiguration.ExtractPidFromGuid(guid' this.Summary);                      DryadProcessIdentifier identifier = new DryadProcessIdentifier(pid);                      string machine = m.Groups[5].Value;                        // Process started for vertex 4 (Super__0[0]) v.0 GUID {9DDD0B00-C93F-46D2-9073-1CFD27829300} machine sherwood-255                      // Process started for vertices 23 (Merge__29) 24 (Apply__33) v.0 GUID {E945DC5D-9AF6-4732-8770-2A6BF7FA3041} machine sherwood-237                        string vertices = m.Groups[2].Value;                      // This is a list of (number \(name\))* pairs                      // we will assume that the parantheses are matched' or we can't do much                        bool onevertex;                      if (m.Groups[1].Value == "ex")  // one vertEX                          onevertex = true;                      else if (m.Groups[1].Value == "ices")                          onevertex = false;                      else                          throw new DryadException("Can't figure out if one or many vertices");                        IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                        int vertexcount = 0;                      int iversion = int.Parse(version);                        if (lineTimeStamp > this.lastTimestampSeen)                          this.lastTimestampSeen = lineTimeStamp;                      foreach (var p in vertexList)                      {                          int number = p.Item2;                          ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' iversion);                          //new ExecutedVertexInstance(this' number' version' name' identifier' machine' this.lastTimestampSeen);                          if (vi == null)                              Trace.TraceInformation("Could not find information for vertex {0}.{1}"' number' version);                          else                              vi.SetStartInformation(this' machine' this.lastTimestampSeen' identifier' guid);                          vertexcount++;                      }                        if (vertexcount > 1 && onevertex)                          throw new DryadException("Expected one vertex' found " + vertexcount);                  }                  else                  {                      Trace.TraceInformation("Unexpected parsing error on line {0}"' line);                  }              }              else if (line.Contains("Abandoning"))              {                  Match m = vertexAbandonedRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                          vi.SetState(ExecutedVertexInstance.VertexState.Abandoned);                  }              }              else if (line.Contains("Setting"))              {                  Match m = setToFailedlRegex.Match(line);                  if (m.Success)                  {                      // Setting vertex 1461.0 (Merge__13[258]) to failed                      // Setting vertex (\d+)\.(\d+) \((.+)\) to failed(.*)                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          //vi.ErrorString = m.Groups[4].Value;                      }                  }              }              else if (line.Contains("Process was terminated"))              {                  // terminatedRegex = new Regex(@"Process was terminated Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) status (.*)"'                  // Process was terminated Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 status The operation succeeded                  Match m = terminatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          // sometimes successful processes are terminated' because they don't report quickly enough being done                          if (vi.State != ExecutedVertexInstance.VertexState.Successful)                          {                              vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          }                          vi.ErrorString = m.Groups[6].Value;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                  }              }              else if (line.Contains("Timing Information Graph Start Time"))              {                  // Cosmos-specific line                  // Timing Information Graph Start Time 128654556581866096                  Match m = Regex.Match(line' @"Timing Information Graph Start Time (\d+)");                  DateTime createTime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                  this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                  this.lastTimestampSeen = createTime;              }              else if (line.StartsWith("Start time: "))              {                  // HPC L2H specific line                  // Start time: 04/05/2011 17:25:42.223                  DateTime createTime;                  bool parse = DateTime.TryParse(line.Substring("Start time: ".Length)' out createTime);                    if (parse)                  {                      this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                      this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                      this.lastTimestampSeen = createTime;                  }              }              else if (line.Contains("JM Finish time:"))              {                  // Cosmos-specific line                  // JM Finish time: 129140295499437263 2010-03-25T22:25:49.943726Z                  Match m = Regex.Match(line' @"JM Finish time: (\d+)");                  DateTime time = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.lastTimestampSeen = time;                  this.ManagerVertex.End = time;              }              else if (line.StartsWith("Stop time "))              {                  // HPC L2H specific line                  // Stop time (Exit code = 2148734208): 04/05/2011 17:25:46.614                  Regex regex = new Regex(@"Stop time \(Exit code = (.*)\): (.*)");                  Match m = regex.Match(line);                  if (m.Success)                  {                      this.ManagerStdoutIncomplete = false;                        DateTime time;                      bool parse = DateTime.TryParse(m.Groups[2].Value' out time);                      if (parse)                      {                          this.lastTimestampSeen = time;                          this.ManagerVertex.End = time;                      }                        this.ErrorCode = m.Groups[1].Value;                      if (this.ErrorCode == "0")                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                      }                      else                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                      }                  }              }              else if (line.Contains("Timing Information"))              {                  // Timing Information 4 1 Super__0[0] 128654556603428182 0.0000 0.0000 0.0000 0.0000 0.2500                   Match m = timingInfoRegex.Match(line);                  if (m.Success)                  {                      int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      DateTime createtime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[4].Value);                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi == null)                          return; // we do not keep track of vertices with duplicate scheduling' so these won't show up here                        if (vi.State == ExecutedVertexInstance.VertexState.Started)                      {                          Console.WriteLine("Timing information while vertex is still running " + vi);                          //throw new ClusterException("Timing information for vertex still running: " + vi);                      }                      DateTime last = vi.SetTiming(createtime' m.Groups[5].Value' m.Groups[6].Value' m.Groups[7].Value' m.Groups[8].Value' m.Groups[9].Value);                      if (last > this.lastTimestampSeen)                          this.lastTimestampSeen = last;                      this.ManagerVertex.MarkVertexWasRunning(last);                        try                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              this.UsefulCPUTime += vi.RunningTime;                          else if (vi.RunningTime > TimeSpan.Zero)                              this.WastedCPUTime += vi.RunningTime;                      }                      catch (Exception ex)                      {                          Console.WriteLine("Time value exception: " + ex.Message);                      }                  }                  else                      throw new DryadException("Unmatched timing information line " + line);              }              else if (line.Contains("Process has failed"))              {                  // Process has failed Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 Exitcode 0 status The operation succeeded                  // failedRegex = new Regex(@"Process has failed Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) Exitcode (.*)"'                  Match m = failedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string exitcode = m.Groups[6].Value;                      //string status = m.Groups[7].Value;                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          vi.ExitCode = exitcode;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                          //vi.ErrorString = status;                      }                  }              }              else if (line.Contains("ABORTING:"))              {                  this.AbortingMsg = line.Substring(10);                  this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);              }              else if (line.Contains("Accurate read data"))              {                  Match m = datareadRegex.Match(line);                  if (m.Success)                  {                      this.TotalDataRead = long.Parse(m.Groups[1].Value);                      this.LocalReadData = long.Parse(m.Groups[2].Value);                      this.IntraPodDataRead = long.Parse(m.Groups[3].Value);                      this.CrossPodDataRead = long.Parse(m.Groups[4].Value);                  }              }              else if (line.Contains("<ErrorString>"))              {                  //some errors contains "Error returned from managed runtime invocation"                  //which shows the error is from application code                  Match m = Regex.Match(line' @"\<ErrorString\>(.*)\</ErrorString\>");                  if (m.Success && lastFailedVertex != null)                  {                      lastFailedVertex.AddErrorString(System.Web.HttpUtility.HtmlDecode(m.Groups[1].Value));                  }              }              else if (line.Contains("Canceling"))              {                  // Canceling vertex 1461.0 (Merge__13[258]) due to dependent failure                  Match m = cancelRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string name = m.Groups[3].Value;                        ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              vi.SetState(ExecutedVertexInstance.VertexState.Invalidated);                          else                               vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                      else                      {                          // TODO: this should not be needed' but this is a workaround for a bug in the HPC L2H software                          vi = new ExecutedVertexInstance(this' vertex' version' name' ""' lineTimeStamp);                          vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          this.jobVertices.Add(vi);                      }                      // Process wasn't even started' so there is nothing to cancel                  }              }              else if (line.Contains("Application"))              {                  //the job ends successfully                  Regex endSuccessRegex = new Regex(@"Application completed successfully.");                  //the job failed                  Regex endFailRegex = new Regex(@"Application failed with error code (.*)");                    Match m1 = endFailRegex.Match(line);                    if (m1.Success)                  {                      this.ErrorCode = m1.Groups[1].Value;                      this.ManagerStdoutIncomplete = false;                      this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                  }                  else                  {                      Match m2 = endSuccessRegex.Match(line);                      if (m2.Success)                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                          this.ManagerStdoutIncomplete = false;                      }                  }              }              else if (line.StartsWith("Input"))              {                  // Input vertex %u (%s) had %u read failure%s\n                  Match m = inputFailureRegex.Match(line);                  if (m.Success)                  {                      this.AbortingMsg = line;                  }              }              else if (line.Contains("Vertex"))              {                  // terminationRegex = new Regex(@"Vertex (\d+)\.(\d+) \((.+)\) machine (\S+) guid \{?([-0-9A-F]+)\}? status (.*)"                  Match m = terminationRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(vertex' version);                      if (vi == null)                      {                          Trace.TraceInformation("Could not find vertex {0}.{1} line {2}"' vertex' version' line);                      }                      else                      {                          bool failed = vi.SetTermination(m.Groups[6].Value' lineTimeStamp);                          if (failed)                              this.lastFailedVertex = vi;                      }                  }              }
Magic Number,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseStdoutLine,The following statement contains a magic number: if (line.Contains("Created process execution record"))              {                  Match m = vertexCreatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Created process execution record for vertex (\d+) \((.*)\) v.(\d+) GUID \{?([-A-F0-9]+)\}?                      int number = Int32.Parse(m.Groups[1].Value);                      string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                        // the vertex may be already there' sometimes numbers are reused...                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi == null)                      {                          vi = new ExecutedVertexInstance(this' number' version' name' guid' lineTimeStamp);                          this.jobVertices.Add(vi);                      }                  }                  else                  {                      m = verticesCreatedRegex.Match(line);                      if (m.Success)                      {                          lineTimeStamp = ParseLineTimestamp(line);                            // Created process execution record for vertices (.*) v.(\d+) GUID \{?([-A-F0-9]+)\}?                          // Created process execution record for vertices 192 (Merge__41[0]) 223 (Union__45[0]) v.0 GUID {0297A91C-FFEA-42EA-94AF-CD0163A04D45}                          int version = Int32.Parse(m.Groups[2].Value);                          string vertices = m.Groups[1].Value;                          string guid = m.Groups[3].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                            IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                          foreach (var p in vertexList)                          {                              int number = p.Item2;                              ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                              if (vi == null)                              {                                  vi = new ExecutedVertexInstance(this' number' version' p.Item1' guid' lineTimeStamp);                                  this.jobVertices.Add(vi);                              }                          }                      }                  }              }              else if (line.StartsWith("Creating process"))              {                  Match m = processCreatingRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Creating process for vertex (\d+) \((.*)\\) v.(\d+) GUID \{?([-A-F0-9]+)\}? machine (\w+)                      int number = Int32.Parse(m.Groups[1].Value);                      //string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value;                         ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          this.jobVertices.Remap(vi' guid);                      }                  }              }              else if (line.StartsWith("Process was revoked"))              {                  Match m = revokedRegex.Match(line);                  if (m.Success)                  {                      string oldGuid = m.Groups[1].Value;                      ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(oldGuid);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Revoked);                          string newGuid = m.Groups[2].Value;                          this.jobVertices.Remap(vi' newGuid);                      }                      else                      {                          Trace.TraceInformation("Could not find revoked vertex with guid " + oldGuid);                      }                  }              }              else if (line.StartsWith("---HiPriTime"))              {                  // Scope-specific line which we use to get the i/o information                  // ---HiPriTime D7D51A1F-6693-4378-95FD-FC778A67C632'F52CA694-0202-411E-85E9-0C883E770A0E'SV4_Extract_Split[0]'Completed'ch1sch010331112'2011-05-03 15:26:01.681 PDT'2011-05-03 15:26:01.696 PDT'2011-05-03 15:26:02.118 PDT'2011-05-03 15:26:04.286 PDT'2011-05-03 15:26:07.656 PDT'2011-05-03 15:26:01.696 PDT'97390825'1498630                  string info = line.Substring(13);                  string[] parts = info.Split(''');                  if (parts.Length >= 13)                  {                      long read = long.Parse(parts[11]);                      long written = long.Parse(parts[12]);                      string guid = parts[1];                        ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(guid);                      if (vi != null)                      {                          vi.DataRead = read;                          vi.DataWritten = written;                          this.TotalDataRead += read;                      }                  }              }              else if (line.Contains("Io information"))              {                  // HPC-specific line                  Match m = ioRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.DataRead = long.Parse(m.Groups[4].Value);                          vi.DataWritten = long.Parse(m.Groups[5].Value);                          this.TotalDataRead += vi.DataRead;                      }                  }              }              else if (line.Contains("Process started"))              {                  //those vertices which are being canceled may not be here                  Match m = vertexStartRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        string version = m.Groups[3].Value;                      string guid = m.Groups[4].Value;                      string pid = this.ClusterConfiguration.ExtractPidFromGuid(guid' this.Summary);                      DryadProcessIdentifier identifier = new DryadProcessIdentifier(pid);                      string machine = m.Groups[5].Value;                        // Process started for vertex 4 (Super__0[0]) v.0 GUID {9DDD0B00-C93F-46D2-9073-1CFD27829300} machine sherwood-255                      // Process started for vertices 23 (Merge__29) 24 (Apply__33) v.0 GUID {E945DC5D-9AF6-4732-8770-2A6BF7FA3041} machine sherwood-237                        string vertices = m.Groups[2].Value;                      // This is a list of (number \(name\))* pairs                      // we will assume that the parantheses are matched' or we can't do much                        bool onevertex;                      if (m.Groups[1].Value == "ex")  // one vertEX                          onevertex = true;                      else if (m.Groups[1].Value == "ices")                          onevertex = false;                      else                          throw new DryadException("Can't figure out if one or many vertices");                        IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                        int vertexcount = 0;                      int iversion = int.Parse(version);                        if (lineTimeStamp > this.lastTimestampSeen)                          this.lastTimestampSeen = lineTimeStamp;                      foreach (var p in vertexList)                      {                          int number = p.Item2;                          ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' iversion);                          //new ExecutedVertexInstance(this' number' version' name' identifier' machine' this.lastTimestampSeen);                          if (vi == null)                              Trace.TraceInformation("Could not find information for vertex {0}.{1}"' number' version);                          else                              vi.SetStartInformation(this' machine' this.lastTimestampSeen' identifier' guid);                          vertexcount++;                      }                        if (vertexcount > 1 && onevertex)                          throw new DryadException("Expected one vertex' found " + vertexcount);                  }                  else                  {                      Trace.TraceInformation("Unexpected parsing error on line {0}"' line);                  }              }              else if (line.Contains("Abandoning"))              {                  Match m = vertexAbandonedRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                          vi.SetState(ExecutedVertexInstance.VertexState.Abandoned);                  }              }              else if (line.Contains("Setting"))              {                  Match m = setToFailedlRegex.Match(line);                  if (m.Success)                  {                      // Setting vertex 1461.0 (Merge__13[258]) to failed                      // Setting vertex (\d+)\.(\d+) \((.+)\) to failed(.*)                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          //vi.ErrorString = m.Groups[4].Value;                      }                  }              }              else if (line.Contains("Process was terminated"))              {                  // terminatedRegex = new Regex(@"Process was terminated Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) status (.*)"'                  // Process was terminated Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 status The operation succeeded                  Match m = terminatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          // sometimes successful processes are terminated' because they don't report quickly enough being done                          if (vi.State != ExecutedVertexInstance.VertexState.Successful)                          {                              vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          }                          vi.ErrorString = m.Groups[6].Value;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                  }              }              else if (line.Contains("Timing Information Graph Start Time"))              {                  // Cosmos-specific line                  // Timing Information Graph Start Time 128654556581866096                  Match m = Regex.Match(line' @"Timing Information Graph Start Time (\d+)");                  DateTime createTime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                  this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                  this.lastTimestampSeen = createTime;              }              else if (line.StartsWith("Start time: "))              {                  // HPC L2H specific line                  // Start time: 04/05/2011 17:25:42.223                  DateTime createTime;                  bool parse = DateTime.TryParse(line.Substring("Start time: ".Length)' out createTime);                    if (parse)                  {                      this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                      this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                      this.lastTimestampSeen = createTime;                  }              }              else if (line.Contains("JM Finish time:"))              {                  // Cosmos-specific line                  // JM Finish time: 129140295499437263 2010-03-25T22:25:49.943726Z                  Match m = Regex.Match(line' @"JM Finish time: (\d+)");                  DateTime time = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.lastTimestampSeen = time;                  this.ManagerVertex.End = time;              }              else if (line.StartsWith("Stop time "))              {                  // HPC L2H specific line                  // Stop time (Exit code = 2148734208): 04/05/2011 17:25:46.614                  Regex regex = new Regex(@"Stop time \(Exit code = (.*)\): (.*)");                  Match m = regex.Match(line);                  if (m.Success)                  {                      this.ManagerStdoutIncomplete = false;                        DateTime time;                      bool parse = DateTime.TryParse(m.Groups[2].Value' out time);                      if (parse)                      {                          this.lastTimestampSeen = time;                          this.ManagerVertex.End = time;                      }                        this.ErrorCode = m.Groups[1].Value;                      if (this.ErrorCode == "0")                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                      }                      else                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                      }                  }              }              else if (line.Contains("Timing Information"))              {                  // Timing Information 4 1 Super__0[0] 128654556603428182 0.0000 0.0000 0.0000 0.0000 0.2500                   Match m = timingInfoRegex.Match(line);                  if (m.Success)                  {                      int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      DateTime createtime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[4].Value);                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi == null)                          return; // we do not keep track of vertices with duplicate scheduling' so these won't show up here                        if (vi.State == ExecutedVertexInstance.VertexState.Started)                      {                          Console.WriteLine("Timing information while vertex is still running " + vi);                          //throw new ClusterException("Timing information for vertex still running: " + vi);                      }                      DateTime last = vi.SetTiming(createtime' m.Groups[5].Value' m.Groups[6].Value' m.Groups[7].Value' m.Groups[8].Value' m.Groups[9].Value);                      if (last > this.lastTimestampSeen)                          this.lastTimestampSeen = last;                      this.ManagerVertex.MarkVertexWasRunning(last);                        try                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              this.UsefulCPUTime += vi.RunningTime;                          else if (vi.RunningTime > TimeSpan.Zero)                              this.WastedCPUTime += vi.RunningTime;                      }                      catch (Exception ex)                      {                          Console.WriteLine("Time value exception: " + ex.Message);                      }                  }                  else                      throw new DryadException("Unmatched timing information line " + line);              }              else if (line.Contains("Process has failed"))              {                  // Process has failed Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 Exitcode 0 status The operation succeeded                  // failedRegex = new Regex(@"Process has failed Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) Exitcode (.*)"'                  Match m = failedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string exitcode = m.Groups[6].Value;                      //string status = m.Groups[7].Value;                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          vi.ExitCode = exitcode;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                          //vi.ErrorString = status;                      }                  }              }              else if (line.Contains("ABORTING:"))              {                  this.AbortingMsg = line.Substring(10);                  this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);              }              else if (line.Contains("Accurate read data"))              {                  Match m = datareadRegex.Match(line);                  if (m.Success)                  {                      this.TotalDataRead = long.Parse(m.Groups[1].Value);                      this.LocalReadData = long.Parse(m.Groups[2].Value);                      this.IntraPodDataRead = long.Parse(m.Groups[3].Value);                      this.CrossPodDataRead = long.Parse(m.Groups[4].Value);                  }              }              else if (line.Contains("<ErrorString>"))              {                  //some errors contains "Error returned from managed runtime invocation"                  //which shows the error is from application code                  Match m = Regex.Match(line' @"\<ErrorString\>(.*)\</ErrorString\>");                  if (m.Success && lastFailedVertex != null)                  {                      lastFailedVertex.AddErrorString(System.Web.HttpUtility.HtmlDecode(m.Groups[1].Value));                  }              }              else if (line.Contains("Canceling"))              {                  // Canceling vertex 1461.0 (Merge__13[258]) due to dependent failure                  Match m = cancelRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string name = m.Groups[3].Value;                        ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              vi.SetState(ExecutedVertexInstance.VertexState.Invalidated);                          else                               vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                      else                      {                          // TODO: this should not be needed' but this is a workaround for a bug in the HPC L2H software                          vi = new ExecutedVertexInstance(this' vertex' version' name' ""' lineTimeStamp);                          vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          this.jobVertices.Add(vi);                      }                      // Process wasn't even started' so there is nothing to cancel                  }              }              else if (line.Contains("Application"))              {                  //the job ends successfully                  Regex endSuccessRegex = new Regex(@"Application completed successfully.");                  //the job failed                  Regex endFailRegex = new Regex(@"Application failed with error code (.*)");                    Match m1 = endFailRegex.Match(line);                    if (m1.Success)                  {                      this.ErrorCode = m1.Groups[1].Value;                      this.ManagerStdoutIncomplete = false;                      this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                  }                  else                  {                      Match m2 = endSuccessRegex.Match(line);                      if (m2.Success)                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                          this.ManagerStdoutIncomplete = false;                      }                  }              }              else if (line.StartsWith("Input"))              {                  // Input vertex %u (%s) had %u read failure%s\n                  Match m = inputFailureRegex.Match(line);                  if (m.Success)                  {                      this.AbortingMsg = line;                  }              }              else if (line.Contains("Vertex"))              {                  // terminationRegex = new Regex(@"Vertex (\d+)\.(\d+) \((.+)\) machine (\S+) guid \{?([-0-9A-F]+)\}? status (.*)"                  Match m = terminationRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(vertex' version);                      if (vi == null)                      {                          Trace.TraceInformation("Could not find vertex {0}.{1} line {2}"' vertex' version' line);                      }                      else                      {                          bool failed = vi.SetTermination(m.Groups[6].Value' lineTimeStamp);                          if (failed)                              this.lastFailedVertex = vi;                      }                  }              }
Magic Number,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseStdoutLine,The following statement contains a magic number: if (line.Contains("Created process execution record"))              {                  Match m = vertexCreatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Created process execution record for vertex (\d+) \((.*)\) v.(\d+) GUID \{?([-A-F0-9]+)\}?                      int number = Int32.Parse(m.Groups[1].Value);                      string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                        // the vertex may be already there' sometimes numbers are reused...                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi == null)                      {                          vi = new ExecutedVertexInstance(this' number' version' name' guid' lineTimeStamp);                          this.jobVertices.Add(vi);                      }                  }                  else                  {                      m = verticesCreatedRegex.Match(line);                      if (m.Success)                      {                          lineTimeStamp = ParseLineTimestamp(line);                            // Created process execution record for vertices (.*) v.(\d+) GUID \{?([-A-F0-9]+)\}?                          // Created process execution record for vertices 192 (Merge__41[0]) 223 (Union__45[0]) v.0 GUID {0297A91C-FFEA-42EA-94AF-CD0163A04D45}                          int version = Int32.Parse(m.Groups[2].Value);                          string vertices = m.Groups[1].Value;                          string guid = m.Groups[3].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                            IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                          foreach (var p in vertexList)                          {                              int number = p.Item2;                              ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                              if (vi == null)                              {                                  vi = new ExecutedVertexInstance(this' number' version' p.Item1' guid' lineTimeStamp);                                  this.jobVertices.Add(vi);                              }                          }                      }                  }              }              else if (line.StartsWith("Creating process"))              {                  Match m = processCreatingRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Creating process for vertex (\d+) \((.*)\\) v.(\d+) GUID \{?([-A-F0-9]+)\}? machine (\w+)                      int number = Int32.Parse(m.Groups[1].Value);                      //string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value;                         ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          this.jobVertices.Remap(vi' guid);                      }                  }              }              else if (line.StartsWith("Process was revoked"))              {                  Match m = revokedRegex.Match(line);                  if (m.Success)                  {                      string oldGuid = m.Groups[1].Value;                      ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(oldGuid);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Revoked);                          string newGuid = m.Groups[2].Value;                          this.jobVertices.Remap(vi' newGuid);                      }                      else                      {                          Trace.TraceInformation("Could not find revoked vertex with guid " + oldGuid);                      }                  }              }              else if (line.StartsWith("---HiPriTime"))              {                  // Scope-specific line which we use to get the i/o information                  // ---HiPriTime D7D51A1F-6693-4378-95FD-FC778A67C632'F52CA694-0202-411E-85E9-0C883E770A0E'SV4_Extract_Split[0]'Completed'ch1sch010331112'2011-05-03 15:26:01.681 PDT'2011-05-03 15:26:01.696 PDT'2011-05-03 15:26:02.118 PDT'2011-05-03 15:26:04.286 PDT'2011-05-03 15:26:07.656 PDT'2011-05-03 15:26:01.696 PDT'97390825'1498630                  string info = line.Substring(13);                  string[] parts = info.Split(''');                  if (parts.Length >= 13)                  {                      long read = long.Parse(parts[11]);                      long written = long.Parse(parts[12]);                      string guid = parts[1];                        ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(guid);                      if (vi != null)                      {                          vi.DataRead = read;                          vi.DataWritten = written;                          this.TotalDataRead += read;                      }                  }              }              else if (line.Contains("Io information"))              {                  // HPC-specific line                  Match m = ioRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.DataRead = long.Parse(m.Groups[4].Value);                          vi.DataWritten = long.Parse(m.Groups[5].Value);                          this.TotalDataRead += vi.DataRead;                      }                  }              }              else if (line.Contains("Process started"))              {                  //those vertices which are being canceled may not be here                  Match m = vertexStartRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        string version = m.Groups[3].Value;                      string guid = m.Groups[4].Value;                      string pid = this.ClusterConfiguration.ExtractPidFromGuid(guid' this.Summary);                      DryadProcessIdentifier identifier = new DryadProcessIdentifier(pid);                      string machine = m.Groups[5].Value;                        // Process started for vertex 4 (Super__0[0]) v.0 GUID {9DDD0B00-C93F-46D2-9073-1CFD27829300} machine sherwood-255                      // Process started for vertices 23 (Merge__29) 24 (Apply__33) v.0 GUID {E945DC5D-9AF6-4732-8770-2A6BF7FA3041} machine sherwood-237                        string vertices = m.Groups[2].Value;                      // This is a list of (number \(name\))* pairs                      // we will assume that the parantheses are matched' or we can't do much                        bool onevertex;                      if (m.Groups[1].Value == "ex")  // one vertEX                          onevertex = true;                      else if (m.Groups[1].Value == "ices")                          onevertex = false;                      else                          throw new DryadException("Can't figure out if one or many vertices");                        IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                        int vertexcount = 0;                      int iversion = int.Parse(version);                        if (lineTimeStamp > this.lastTimestampSeen)                          this.lastTimestampSeen = lineTimeStamp;                      foreach (var p in vertexList)                      {                          int number = p.Item2;                          ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' iversion);                          //new ExecutedVertexInstance(this' number' version' name' identifier' machine' this.lastTimestampSeen);                          if (vi == null)                              Trace.TraceInformation("Could not find information for vertex {0}.{1}"' number' version);                          else                              vi.SetStartInformation(this' machine' this.lastTimestampSeen' identifier' guid);                          vertexcount++;                      }                        if (vertexcount > 1 && onevertex)                          throw new DryadException("Expected one vertex' found " + vertexcount);                  }                  else                  {                      Trace.TraceInformation("Unexpected parsing error on line {0}"' line);                  }              }              else if (line.Contains("Abandoning"))              {                  Match m = vertexAbandonedRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                          vi.SetState(ExecutedVertexInstance.VertexState.Abandoned);                  }              }              else if (line.Contains("Setting"))              {                  Match m = setToFailedlRegex.Match(line);                  if (m.Success)                  {                      // Setting vertex 1461.0 (Merge__13[258]) to failed                      // Setting vertex (\d+)\.(\d+) \((.+)\) to failed(.*)                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          //vi.ErrorString = m.Groups[4].Value;                      }                  }              }              else if (line.Contains("Process was terminated"))              {                  // terminatedRegex = new Regex(@"Process was terminated Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) status (.*)"'                  // Process was terminated Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 status The operation succeeded                  Match m = terminatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          // sometimes successful processes are terminated' because they don't report quickly enough being done                          if (vi.State != ExecutedVertexInstance.VertexState.Successful)                          {                              vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          }                          vi.ErrorString = m.Groups[6].Value;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                  }              }              else if (line.Contains("Timing Information Graph Start Time"))              {                  // Cosmos-specific line                  // Timing Information Graph Start Time 128654556581866096                  Match m = Regex.Match(line' @"Timing Information Graph Start Time (\d+)");                  DateTime createTime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                  this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                  this.lastTimestampSeen = createTime;              }              else if (line.StartsWith("Start time: "))              {                  // HPC L2H specific line                  // Start time: 04/05/2011 17:25:42.223                  DateTime createTime;                  bool parse = DateTime.TryParse(line.Substring("Start time: ".Length)' out createTime);                    if (parse)                  {                      this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                      this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                      this.lastTimestampSeen = createTime;                  }              }              else if (line.Contains("JM Finish time:"))              {                  // Cosmos-specific line                  // JM Finish time: 129140295499437263 2010-03-25T22:25:49.943726Z                  Match m = Regex.Match(line' @"JM Finish time: (\d+)");                  DateTime time = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.lastTimestampSeen = time;                  this.ManagerVertex.End = time;              }              else if (line.StartsWith("Stop time "))              {                  // HPC L2H specific line                  // Stop time (Exit code = 2148734208): 04/05/2011 17:25:46.614                  Regex regex = new Regex(@"Stop time \(Exit code = (.*)\): (.*)");                  Match m = regex.Match(line);                  if (m.Success)                  {                      this.ManagerStdoutIncomplete = false;                        DateTime time;                      bool parse = DateTime.TryParse(m.Groups[2].Value' out time);                      if (parse)                      {                          this.lastTimestampSeen = time;                          this.ManagerVertex.End = time;                      }                        this.ErrorCode = m.Groups[1].Value;                      if (this.ErrorCode == "0")                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                      }                      else                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                      }                  }              }              else if (line.Contains("Timing Information"))              {                  // Timing Information 4 1 Super__0[0] 128654556603428182 0.0000 0.0000 0.0000 0.0000 0.2500                   Match m = timingInfoRegex.Match(line);                  if (m.Success)                  {                      int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      DateTime createtime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[4].Value);                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi == null)                          return; // we do not keep track of vertices with duplicate scheduling' so these won't show up here                        if (vi.State == ExecutedVertexInstance.VertexState.Started)                      {                          Console.WriteLine("Timing information while vertex is still running " + vi);                          //throw new ClusterException("Timing information for vertex still running: " + vi);                      }                      DateTime last = vi.SetTiming(createtime' m.Groups[5].Value' m.Groups[6].Value' m.Groups[7].Value' m.Groups[8].Value' m.Groups[9].Value);                      if (last > this.lastTimestampSeen)                          this.lastTimestampSeen = last;                      this.ManagerVertex.MarkVertexWasRunning(last);                        try                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              this.UsefulCPUTime += vi.RunningTime;                          else if (vi.RunningTime > TimeSpan.Zero)                              this.WastedCPUTime += vi.RunningTime;                      }                      catch (Exception ex)                      {                          Console.WriteLine("Time value exception: " + ex.Message);                      }                  }                  else                      throw new DryadException("Unmatched timing information line " + line);              }              else if (line.Contains("Process has failed"))              {                  // Process has failed Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 Exitcode 0 status The operation succeeded                  // failedRegex = new Regex(@"Process has failed Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) Exitcode (.*)"'                  Match m = failedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string exitcode = m.Groups[6].Value;                      //string status = m.Groups[7].Value;                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          vi.ExitCode = exitcode;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                          //vi.ErrorString = status;                      }                  }              }              else if (line.Contains("ABORTING:"))              {                  this.AbortingMsg = line.Substring(10);                  this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);              }              else if (line.Contains("Accurate read data"))              {                  Match m = datareadRegex.Match(line);                  if (m.Success)                  {                      this.TotalDataRead = long.Parse(m.Groups[1].Value);                      this.LocalReadData = long.Parse(m.Groups[2].Value);                      this.IntraPodDataRead = long.Parse(m.Groups[3].Value);                      this.CrossPodDataRead = long.Parse(m.Groups[4].Value);                  }              }              else if (line.Contains("<ErrorString>"))              {                  //some errors contains "Error returned from managed runtime invocation"                  //which shows the error is from application code                  Match m = Regex.Match(line' @"\<ErrorString\>(.*)\</ErrorString\>");                  if (m.Success && lastFailedVertex != null)                  {                      lastFailedVertex.AddErrorString(System.Web.HttpUtility.HtmlDecode(m.Groups[1].Value));                  }              }              else if (line.Contains("Canceling"))              {                  // Canceling vertex 1461.0 (Merge__13[258]) due to dependent failure                  Match m = cancelRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string name = m.Groups[3].Value;                        ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              vi.SetState(ExecutedVertexInstance.VertexState.Invalidated);                          else                               vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                      else                      {                          // TODO: this should not be needed' but this is a workaround for a bug in the HPC L2H software                          vi = new ExecutedVertexInstance(this' vertex' version' name' ""' lineTimeStamp);                          vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          this.jobVertices.Add(vi);                      }                      // Process wasn't even started' so there is nothing to cancel                  }              }              else if (line.Contains("Application"))              {                  //the job ends successfully                  Regex endSuccessRegex = new Regex(@"Application completed successfully.");                  //the job failed                  Regex endFailRegex = new Regex(@"Application failed with error code (.*)");                    Match m1 = endFailRegex.Match(line);                    if (m1.Success)                  {                      this.ErrorCode = m1.Groups[1].Value;                      this.ManagerStdoutIncomplete = false;                      this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                  }                  else                  {                      Match m2 = endSuccessRegex.Match(line);                      if (m2.Success)                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                          this.ManagerStdoutIncomplete = false;                      }                  }              }              else if (line.StartsWith("Input"))              {                  // Input vertex %u (%s) had %u read failure%s\n                  Match m = inputFailureRegex.Match(line);                  if (m.Success)                  {                      this.AbortingMsg = line;                  }              }              else if (line.Contains("Vertex"))              {                  // terminationRegex = new Regex(@"Vertex (\d+)\.(\d+) \((.+)\) machine (\S+) guid \{?([-0-9A-F]+)\}? status (.*)"                  Match m = terminationRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(vertex' version);                      if (vi == null)                      {                          Trace.TraceInformation("Could not find vertex {0}.{1} line {2}"' vertex' version' line);                      }                      else                      {                          bool failed = vi.SetTermination(m.Groups[6].Value' lineTimeStamp);                          if (failed)                              this.lastFailedVertex = vi;                      }                  }              }
Magic Number,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseStdoutLine,The following statement contains a magic number: if (line.Contains("Created process execution record"))              {                  Match m = vertexCreatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Created process execution record for vertex (\d+) \((.*)\) v.(\d+) GUID \{?([-A-F0-9]+)\}?                      int number = Int32.Parse(m.Groups[1].Value);                      string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                        // the vertex may be already there' sometimes numbers are reused...                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi == null)                      {                          vi = new ExecutedVertexInstance(this' number' version' name' guid' lineTimeStamp);                          this.jobVertices.Add(vi);                      }                  }                  else                  {                      m = verticesCreatedRegex.Match(line);                      if (m.Success)                      {                          lineTimeStamp = ParseLineTimestamp(line);                            // Created process execution record for vertices (.*) v.(\d+) GUID \{?([-A-F0-9]+)\}?                          // Created process execution record for vertices 192 (Merge__41[0]) 223 (Union__45[0]) v.0 GUID {0297A91C-FFEA-42EA-94AF-CD0163A04D45}                          int version = Int32.Parse(m.Groups[2].Value);                          string vertices = m.Groups[1].Value;                          string guid = m.Groups[3].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                            IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                          foreach (var p in vertexList)                          {                              int number = p.Item2;                              ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                              if (vi == null)                              {                                  vi = new ExecutedVertexInstance(this' number' version' p.Item1' guid' lineTimeStamp);                                  this.jobVertices.Add(vi);                              }                          }                      }                  }              }              else if (line.StartsWith("Creating process"))              {                  Match m = processCreatingRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Creating process for vertex (\d+) \((.*)\\) v.(\d+) GUID \{?([-A-F0-9]+)\}? machine (\w+)                      int number = Int32.Parse(m.Groups[1].Value);                      //string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value;                         ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          this.jobVertices.Remap(vi' guid);                      }                  }              }              else if (line.StartsWith("Process was revoked"))              {                  Match m = revokedRegex.Match(line);                  if (m.Success)                  {                      string oldGuid = m.Groups[1].Value;                      ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(oldGuid);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Revoked);                          string newGuid = m.Groups[2].Value;                          this.jobVertices.Remap(vi' newGuid);                      }                      else                      {                          Trace.TraceInformation("Could not find revoked vertex with guid " + oldGuid);                      }                  }              }              else if (line.StartsWith("---HiPriTime"))              {                  // Scope-specific line which we use to get the i/o information                  // ---HiPriTime D7D51A1F-6693-4378-95FD-FC778A67C632'F52CA694-0202-411E-85E9-0C883E770A0E'SV4_Extract_Split[0]'Completed'ch1sch010331112'2011-05-03 15:26:01.681 PDT'2011-05-03 15:26:01.696 PDT'2011-05-03 15:26:02.118 PDT'2011-05-03 15:26:04.286 PDT'2011-05-03 15:26:07.656 PDT'2011-05-03 15:26:01.696 PDT'97390825'1498630                  string info = line.Substring(13);                  string[] parts = info.Split(''');                  if (parts.Length >= 13)                  {                      long read = long.Parse(parts[11]);                      long written = long.Parse(parts[12]);                      string guid = parts[1];                        ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(guid);                      if (vi != null)                      {                          vi.DataRead = read;                          vi.DataWritten = written;                          this.TotalDataRead += read;                      }                  }              }              else if (line.Contains("Io information"))              {                  // HPC-specific line                  Match m = ioRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.DataRead = long.Parse(m.Groups[4].Value);                          vi.DataWritten = long.Parse(m.Groups[5].Value);                          this.TotalDataRead += vi.DataRead;                      }                  }              }              else if (line.Contains("Process started"))              {                  //those vertices which are being canceled may not be here                  Match m = vertexStartRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        string version = m.Groups[3].Value;                      string guid = m.Groups[4].Value;                      string pid = this.ClusterConfiguration.ExtractPidFromGuid(guid' this.Summary);                      DryadProcessIdentifier identifier = new DryadProcessIdentifier(pid);                      string machine = m.Groups[5].Value;                        // Process started for vertex 4 (Super__0[0]) v.0 GUID {9DDD0B00-C93F-46D2-9073-1CFD27829300} machine sherwood-255                      // Process started for vertices 23 (Merge__29) 24 (Apply__33) v.0 GUID {E945DC5D-9AF6-4732-8770-2A6BF7FA3041} machine sherwood-237                        string vertices = m.Groups[2].Value;                      // This is a list of (number \(name\))* pairs                      // we will assume that the parantheses are matched' or we can't do much                        bool onevertex;                      if (m.Groups[1].Value == "ex")  // one vertEX                          onevertex = true;                      else if (m.Groups[1].Value == "ices")                          onevertex = false;                      else                          throw new DryadException("Can't figure out if one or many vertices");                        IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                        int vertexcount = 0;                      int iversion = int.Parse(version);                        if (lineTimeStamp > this.lastTimestampSeen)                          this.lastTimestampSeen = lineTimeStamp;                      foreach (var p in vertexList)                      {                          int number = p.Item2;                          ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' iversion);                          //new ExecutedVertexInstance(this' number' version' name' identifier' machine' this.lastTimestampSeen);                          if (vi == null)                              Trace.TraceInformation("Could not find information for vertex {0}.{1}"' number' version);                          else                              vi.SetStartInformation(this' machine' this.lastTimestampSeen' identifier' guid);                          vertexcount++;                      }                        if (vertexcount > 1 && onevertex)                          throw new DryadException("Expected one vertex' found " + vertexcount);                  }                  else                  {                      Trace.TraceInformation("Unexpected parsing error on line {0}"' line);                  }              }              else if (line.Contains("Abandoning"))              {                  Match m = vertexAbandonedRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                          vi.SetState(ExecutedVertexInstance.VertexState.Abandoned);                  }              }              else if (line.Contains("Setting"))              {                  Match m = setToFailedlRegex.Match(line);                  if (m.Success)                  {                      // Setting vertex 1461.0 (Merge__13[258]) to failed                      // Setting vertex (\d+)\.(\d+) \((.+)\) to failed(.*)                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          //vi.ErrorString = m.Groups[4].Value;                      }                  }              }              else if (line.Contains("Process was terminated"))              {                  // terminatedRegex = new Regex(@"Process was terminated Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) status (.*)"'                  // Process was terminated Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 status The operation succeeded                  Match m = terminatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          // sometimes successful processes are terminated' because they don't report quickly enough being done                          if (vi.State != ExecutedVertexInstance.VertexState.Successful)                          {                              vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          }                          vi.ErrorString = m.Groups[6].Value;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                  }              }              else if (line.Contains("Timing Information Graph Start Time"))              {                  // Cosmos-specific line                  // Timing Information Graph Start Time 128654556581866096                  Match m = Regex.Match(line' @"Timing Information Graph Start Time (\d+)");                  DateTime createTime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                  this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                  this.lastTimestampSeen = createTime;              }              else if (line.StartsWith("Start time: "))              {                  // HPC L2H specific line                  // Start time: 04/05/2011 17:25:42.223                  DateTime createTime;                  bool parse = DateTime.TryParse(line.Substring("Start time: ".Length)' out createTime);                    if (parse)                  {                      this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                      this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                      this.lastTimestampSeen = createTime;                  }              }              else if (line.Contains("JM Finish time:"))              {                  // Cosmos-specific line                  // JM Finish time: 129140295499437263 2010-03-25T22:25:49.943726Z                  Match m = Regex.Match(line' @"JM Finish time: (\d+)");                  DateTime time = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.lastTimestampSeen = time;                  this.ManagerVertex.End = time;              }              else if (line.StartsWith("Stop time "))              {                  // HPC L2H specific line                  // Stop time (Exit code = 2148734208): 04/05/2011 17:25:46.614                  Regex regex = new Regex(@"Stop time \(Exit code = (.*)\): (.*)");                  Match m = regex.Match(line);                  if (m.Success)                  {                      this.ManagerStdoutIncomplete = false;                        DateTime time;                      bool parse = DateTime.TryParse(m.Groups[2].Value' out time);                      if (parse)                      {                          this.lastTimestampSeen = time;                          this.ManagerVertex.End = time;                      }                        this.ErrorCode = m.Groups[1].Value;                      if (this.ErrorCode == "0")                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                      }                      else                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                      }                  }              }              else if (line.Contains("Timing Information"))              {                  // Timing Information 4 1 Super__0[0] 128654556603428182 0.0000 0.0000 0.0000 0.0000 0.2500                   Match m = timingInfoRegex.Match(line);                  if (m.Success)                  {                      int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      DateTime createtime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[4].Value);                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi == null)                          return; // we do not keep track of vertices with duplicate scheduling' so these won't show up here                        if (vi.State == ExecutedVertexInstance.VertexState.Started)                      {                          Console.WriteLine("Timing information while vertex is still running " + vi);                          //throw new ClusterException("Timing information for vertex still running: " + vi);                      }                      DateTime last = vi.SetTiming(createtime' m.Groups[5].Value' m.Groups[6].Value' m.Groups[7].Value' m.Groups[8].Value' m.Groups[9].Value);                      if (last > this.lastTimestampSeen)                          this.lastTimestampSeen = last;                      this.ManagerVertex.MarkVertexWasRunning(last);                        try                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              this.UsefulCPUTime += vi.RunningTime;                          else if (vi.RunningTime > TimeSpan.Zero)                              this.WastedCPUTime += vi.RunningTime;                      }                      catch (Exception ex)                      {                          Console.WriteLine("Time value exception: " + ex.Message);                      }                  }                  else                      throw new DryadException("Unmatched timing information line " + line);              }              else if (line.Contains("Process has failed"))              {                  // Process has failed Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 Exitcode 0 status The operation succeeded                  // failedRegex = new Regex(@"Process has failed Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) Exitcode (.*)"'                  Match m = failedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string exitcode = m.Groups[6].Value;                      //string status = m.Groups[7].Value;                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          vi.ExitCode = exitcode;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                          //vi.ErrorString = status;                      }                  }              }              else if (line.Contains("ABORTING:"))              {                  this.AbortingMsg = line.Substring(10);                  this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);              }              else if (line.Contains("Accurate read data"))              {                  Match m = datareadRegex.Match(line);                  if (m.Success)                  {                      this.TotalDataRead = long.Parse(m.Groups[1].Value);                      this.LocalReadData = long.Parse(m.Groups[2].Value);                      this.IntraPodDataRead = long.Parse(m.Groups[3].Value);                      this.CrossPodDataRead = long.Parse(m.Groups[4].Value);                  }              }              else if (line.Contains("<ErrorString>"))              {                  //some errors contains "Error returned from managed runtime invocation"                  //which shows the error is from application code                  Match m = Regex.Match(line' @"\<ErrorString\>(.*)\</ErrorString\>");                  if (m.Success && lastFailedVertex != null)                  {                      lastFailedVertex.AddErrorString(System.Web.HttpUtility.HtmlDecode(m.Groups[1].Value));                  }              }              else if (line.Contains("Canceling"))              {                  // Canceling vertex 1461.0 (Merge__13[258]) due to dependent failure                  Match m = cancelRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string name = m.Groups[3].Value;                        ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              vi.SetState(ExecutedVertexInstance.VertexState.Invalidated);                          else                               vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                      else                      {                          // TODO: this should not be needed' but this is a workaround for a bug in the HPC L2H software                          vi = new ExecutedVertexInstance(this' vertex' version' name' ""' lineTimeStamp);                          vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          this.jobVertices.Add(vi);                      }                      // Process wasn't even started' so there is nothing to cancel                  }              }              else if (line.Contains("Application"))              {                  //the job ends successfully                  Regex endSuccessRegex = new Regex(@"Application completed successfully.");                  //the job failed                  Regex endFailRegex = new Regex(@"Application failed with error code (.*)");                    Match m1 = endFailRegex.Match(line);                    if (m1.Success)                  {                      this.ErrorCode = m1.Groups[1].Value;                      this.ManagerStdoutIncomplete = false;                      this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                  }                  else                  {                      Match m2 = endSuccessRegex.Match(line);                      if (m2.Success)                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                          this.ManagerStdoutIncomplete = false;                      }                  }              }              else if (line.StartsWith("Input"))              {                  // Input vertex %u (%s) had %u read failure%s\n                  Match m = inputFailureRegex.Match(line);                  if (m.Success)                  {                      this.AbortingMsg = line;                  }              }              else if (line.Contains("Vertex"))              {                  // terminationRegex = new Regex(@"Vertex (\d+)\.(\d+) \((.+)\) machine (\S+) guid \{?([-0-9A-F]+)\}? status (.*)"                  Match m = terminationRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(vertex' version);                      if (vi == null)                      {                          Trace.TraceInformation("Could not find vertex {0}.{1} line {2}"' vertex' version' line);                      }                      else                      {                          bool failed = vi.SetTermination(m.Groups[6].Value' lineTimeStamp);                          if (failed)                              this.lastFailedVertex = vi;                      }                  }              }
Magic Number,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseStdoutLine,The following statement contains a magic number: if (line.Contains("Created process execution record"))              {                  Match m = vertexCreatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Created process execution record for vertex (\d+) \((.*)\) v.(\d+) GUID \{?([-A-F0-9]+)\}?                      int number = Int32.Parse(m.Groups[1].Value);                      string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                        // the vertex may be already there' sometimes numbers are reused...                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi == null)                      {                          vi = new ExecutedVertexInstance(this' number' version' name' guid' lineTimeStamp);                          this.jobVertices.Add(vi);                      }                  }                  else                  {                      m = verticesCreatedRegex.Match(line);                      if (m.Success)                      {                          lineTimeStamp = ParseLineTimestamp(line);                            // Created process execution record for vertices (.*) v.(\d+) GUID \{?([-A-F0-9]+)\}?                          // Created process execution record for vertices 192 (Merge__41[0]) 223 (Union__45[0]) v.0 GUID {0297A91C-FFEA-42EA-94AF-CD0163A04D45}                          int version = Int32.Parse(m.Groups[2].Value);                          string vertices = m.Groups[1].Value;                          string guid = m.Groups[3].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                            IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                          foreach (var p in vertexList)                          {                              int number = p.Item2;                              ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                              if (vi == null)                              {                                  vi = new ExecutedVertexInstance(this' number' version' p.Item1' guid' lineTimeStamp);                                  this.jobVertices.Add(vi);                              }                          }                      }                  }              }              else if (line.StartsWith("Creating process"))              {                  Match m = processCreatingRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Creating process for vertex (\d+) \((.*)\\) v.(\d+) GUID \{?([-A-F0-9]+)\}? machine (\w+)                      int number = Int32.Parse(m.Groups[1].Value);                      //string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value;                         ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          this.jobVertices.Remap(vi' guid);                      }                  }              }              else if (line.StartsWith("Process was revoked"))              {                  Match m = revokedRegex.Match(line);                  if (m.Success)                  {                      string oldGuid = m.Groups[1].Value;                      ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(oldGuid);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Revoked);                          string newGuid = m.Groups[2].Value;                          this.jobVertices.Remap(vi' newGuid);                      }                      else                      {                          Trace.TraceInformation("Could not find revoked vertex with guid " + oldGuid);                      }                  }              }              else if (line.StartsWith("---HiPriTime"))              {                  // Scope-specific line which we use to get the i/o information                  // ---HiPriTime D7D51A1F-6693-4378-95FD-FC778A67C632'F52CA694-0202-411E-85E9-0C883E770A0E'SV4_Extract_Split[0]'Completed'ch1sch010331112'2011-05-03 15:26:01.681 PDT'2011-05-03 15:26:01.696 PDT'2011-05-03 15:26:02.118 PDT'2011-05-03 15:26:04.286 PDT'2011-05-03 15:26:07.656 PDT'2011-05-03 15:26:01.696 PDT'97390825'1498630                  string info = line.Substring(13);                  string[] parts = info.Split(''');                  if (parts.Length >= 13)                  {                      long read = long.Parse(parts[11]);                      long written = long.Parse(parts[12]);                      string guid = parts[1];                        ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(guid);                      if (vi != null)                      {                          vi.DataRead = read;                          vi.DataWritten = written;                          this.TotalDataRead += read;                      }                  }              }              else if (line.Contains("Io information"))              {                  // HPC-specific line                  Match m = ioRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.DataRead = long.Parse(m.Groups[4].Value);                          vi.DataWritten = long.Parse(m.Groups[5].Value);                          this.TotalDataRead += vi.DataRead;                      }                  }              }              else if (line.Contains("Process started"))              {                  //those vertices which are being canceled may not be here                  Match m = vertexStartRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        string version = m.Groups[3].Value;                      string guid = m.Groups[4].Value;                      string pid = this.ClusterConfiguration.ExtractPidFromGuid(guid' this.Summary);                      DryadProcessIdentifier identifier = new DryadProcessIdentifier(pid);                      string machine = m.Groups[5].Value;                        // Process started for vertex 4 (Super__0[0]) v.0 GUID {9DDD0B00-C93F-46D2-9073-1CFD27829300} machine sherwood-255                      // Process started for vertices 23 (Merge__29) 24 (Apply__33) v.0 GUID {E945DC5D-9AF6-4732-8770-2A6BF7FA3041} machine sherwood-237                        string vertices = m.Groups[2].Value;                      // This is a list of (number \(name\))* pairs                      // we will assume that the parantheses are matched' or we can't do much                        bool onevertex;                      if (m.Groups[1].Value == "ex")  // one vertEX                          onevertex = true;                      else if (m.Groups[1].Value == "ices")                          onevertex = false;                      else                          throw new DryadException("Can't figure out if one or many vertices");                        IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                        int vertexcount = 0;                      int iversion = int.Parse(version);                        if (lineTimeStamp > this.lastTimestampSeen)                          this.lastTimestampSeen = lineTimeStamp;                      foreach (var p in vertexList)                      {                          int number = p.Item2;                          ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' iversion);                          //new ExecutedVertexInstance(this' number' version' name' identifier' machine' this.lastTimestampSeen);                          if (vi == null)                              Trace.TraceInformation("Could not find information for vertex {0}.{1}"' number' version);                          else                              vi.SetStartInformation(this' machine' this.lastTimestampSeen' identifier' guid);                          vertexcount++;                      }                        if (vertexcount > 1 && onevertex)                          throw new DryadException("Expected one vertex' found " + vertexcount);                  }                  else                  {                      Trace.TraceInformation("Unexpected parsing error on line {0}"' line);                  }              }              else if (line.Contains("Abandoning"))              {                  Match m = vertexAbandonedRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                          vi.SetState(ExecutedVertexInstance.VertexState.Abandoned);                  }              }              else if (line.Contains("Setting"))              {                  Match m = setToFailedlRegex.Match(line);                  if (m.Success)                  {                      // Setting vertex 1461.0 (Merge__13[258]) to failed                      // Setting vertex (\d+)\.(\d+) \((.+)\) to failed(.*)                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          //vi.ErrorString = m.Groups[4].Value;                      }                  }              }              else if (line.Contains("Process was terminated"))              {                  // terminatedRegex = new Regex(@"Process was terminated Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) status (.*)"'                  // Process was terminated Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 status The operation succeeded                  Match m = terminatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          // sometimes successful processes are terminated' because they don't report quickly enough being done                          if (vi.State != ExecutedVertexInstance.VertexState.Successful)                          {                              vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          }                          vi.ErrorString = m.Groups[6].Value;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                  }              }              else if (line.Contains("Timing Information Graph Start Time"))              {                  // Cosmos-specific line                  // Timing Information Graph Start Time 128654556581866096                  Match m = Regex.Match(line' @"Timing Information Graph Start Time (\d+)");                  DateTime createTime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                  this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                  this.lastTimestampSeen = createTime;              }              else if (line.StartsWith("Start time: "))              {                  // HPC L2H specific line                  // Start time: 04/05/2011 17:25:42.223                  DateTime createTime;                  bool parse = DateTime.TryParse(line.Substring("Start time: ".Length)' out createTime);                    if (parse)                  {                      this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                      this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                      this.lastTimestampSeen = createTime;                  }              }              else if (line.Contains("JM Finish time:"))              {                  // Cosmos-specific line                  // JM Finish time: 129140295499437263 2010-03-25T22:25:49.943726Z                  Match m = Regex.Match(line' @"JM Finish time: (\d+)");                  DateTime time = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.lastTimestampSeen = time;                  this.ManagerVertex.End = time;              }              else if (line.StartsWith("Stop time "))              {                  // HPC L2H specific line                  // Stop time (Exit code = 2148734208): 04/05/2011 17:25:46.614                  Regex regex = new Regex(@"Stop time \(Exit code = (.*)\): (.*)");                  Match m = regex.Match(line);                  if (m.Success)                  {                      this.ManagerStdoutIncomplete = false;                        DateTime time;                      bool parse = DateTime.TryParse(m.Groups[2].Value' out time);                      if (parse)                      {                          this.lastTimestampSeen = time;                          this.ManagerVertex.End = time;                      }                        this.ErrorCode = m.Groups[1].Value;                      if (this.ErrorCode == "0")                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                      }                      else                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                      }                  }              }              else if (line.Contains("Timing Information"))              {                  // Timing Information 4 1 Super__0[0] 128654556603428182 0.0000 0.0000 0.0000 0.0000 0.2500                   Match m = timingInfoRegex.Match(line);                  if (m.Success)                  {                      int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      DateTime createtime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[4].Value);                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi == null)                          return; // we do not keep track of vertices with duplicate scheduling' so these won't show up here                        if (vi.State == ExecutedVertexInstance.VertexState.Started)                      {                          Console.WriteLine("Timing information while vertex is still running " + vi);                          //throw new ClusterException("Timing information for vertex still running: " + vi);                      }                      DateTime last = vi.SetTiming(createtime' m.Groups[5].Value' m.Groups[6].Value' m.Groups[7].Value' m.Groups[8].Value' m.Groups[9].Value);                      if (last > this.lastTimestampSeen)                          this.lastTimestampSeen = last;                      this.ManagerVertex.MarkVertexWasRunning(last);                        try                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              this.UsefulCPUTime += vi.RunningTime;                          else if (vi.RunningTime > TimeSpan.Zero)                              this.WastedCPUTime += vi.RunningTime;                      }                      catch (Exception ex)                      {                          Console.WriteLine("Time value exception: " + ex.Message);                      }                  }                  else                      throw new DryadException("Unmatched timing information line " + line);              }              else if (line.Contains("Process has failed"))              {                  // Process has failed Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 Exitcode 0 status The operation succeeded                  // failedRegex = new Regex(@"Process has failed Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) Exitcode (.*)"'                  Match m = failedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string exitcode = m.Groups[6].Value;                      //string status = m.Groups[7].Value;                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          vi.ExitCode = exitcode;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                          //vi.ErrorString = status;                      }                  }              }              else if (line.Contains("ABORTING:"))              {                  this.AbortingMsg = line.Substring(10);                  this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);              }              else if (line.Contains("Accurate read data"))              {                  Match m = datareadRegex.Match(line);                  if (m.Success)                  {                      this.TotalDataRead = long.Parse(m.Groups[1].Value);                      this.LocalReadData = long.Parse(m.Groups[2].Value);                      this.IntraPodDataRead = long.Parse(m.Groups[3].Value);                      this.CrossPodDataRead = long.Parse(m.Groups[4].Value);                  }              }              else if (line.Contains("<ErrorString>"))              {                  //some errors contains "Error returned from managed runtime invocation"                  //which shows the error is from application code                  Match m = Regex.Match(line' @"\<ErrorString\>(.*)\</ErrorString\>");                  if (m.Success && lastFailedVertex != null)                  {                      lastFailedVertex.AddErrorString(System.Web.HttpUtility.HtmlDecode(m.Groups[1].Value));                  }              }              else if (line.Contains("Canceling"))              {                  // Canceling vertex 1461.0 (Merge__13[258]) due to dependent failure                  Match m = cancelRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string name = m.Groups[3].Value;                        ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              vi.SetState(ExecutedVertexInstance.VertexState.Invalidated);                          else                               vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                      else                      {                          // TODO: this should not be needed' but this is a workaround for a bug in the HPC L2H software                          vi = new ExecutedVertexInstance(this' vertex' version' name' ""' lineTimeStamp);                          vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          this.jobVertices.Add(vi);                      }                      // Process wasn't even started' so there is nothing to cancel                  }              }              else if (line.Contains("Application"))              {                  //the job ends successfully                  Regex endSuccessRegex = new Regex(@"Application completed successfully.");                  //the job failed                  Regex endFailRegex = new Regex(@"Application failed with error code (.*)");                    Match m1 = endFailRegex.Match(line);                    if (m1.Success)                  {                      this.ErrorCode = m1.Groups[1].Value;                      this.ManagerStdoutIncomplete = false;                      this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                  }                  else                  {                      Match m2 = endSuccessRegex.Match(line);                      if (m2.Success)                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                          this.ManagerStdoutIncomplete = false;                      }                  }              }              else if (line.StartsWith("Input"))              {                  // Input vertex %u (%s) had %u read failure%s\n                  Match m = inputFailureRegex.Match(line);                  if (m.Success)                  {                      this.AbortingMsg = line;                  }              }              else if (line.Contains("Vertex"))              {                  // terminationRegex = new Regex(@"Vertex (\d+)\.(\d+) \((.+)\) machine (\S+) guid \{?([-0-9A-F]+)\}? status (.*)"                  Match m = terminationRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(vertex' version);                      if (vi == null)                      {                          Trace.TraceInformation("Could not find vertex {0}.{1} line {2}"' vertex' version' line);                      }                      else                      {                          bool failed = vi.SetTermination(m.Groups[6].Value' lineTimeStamp);                          if (failed)                              this.lastFailedVertex = vi;                      }                  }              }
Magic Number,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseStdoutLine,The following statement contains a magic number: if (line.Contains("Created process execution record"))              {                  Match m = vertexCreatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Created process execution record for vertex (\d+) \((.*)\) v.(\d+) GUID \{?([-A-F0-9]+)\}?                      int number = Int32.Parse(m.Groups[1].Value);                      string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                        // the vertex may be already there' sometimes numbers are reused...                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi == null)                      {                          vi = new ExecutedVertexInstance(this' number' version' name' guid' lineTimeStamp);                          this.jobVertices.Add(vi);                      }                  }                  else                  {                      m = verticesCreatedRegex.Match(line);                      if (m.Success)                      {                          lineTimeStamp = ParseLineTimestamp(line);                            // Created process execution record for vertices (.*) v.(\d+) GUID \{?([-A-F0-9]+)\}?                          // Created process execution record for vertices 192 (Merge__41[0]) 223 (Union__45[0]) v.0 GUID {0297A91C-FFEA-42EA-94AF-CD0163A04D45}                          int version = Int32.Parse(m.Groups[2].Value);                          string vertices = m.Groups[1].Value;                          string guid = m.Groups[3].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                            IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                          foreach (var p in vertexList)                          {                              int number = p.Item2;                              ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                              if (vi == null)                              {                                  vi = new ExecutedVertexInstance(this' number' version' p.Item1' guid' lineTimeStamp);                                  this.jobVertices.Add(vi);                              }                          }                      }                  }              }              else if (line.StartsWith("Creating process"))              {                  Match m = processCreatingRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Creating process for vertex (\d+) \((.*)\\) v.(\d+) GUID \{?([-A-F0-9]+)\}? machine (\w+)                      int number = Int32.Parse(m.Groups[1].Value);                      //string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value;                         ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          this.jobVertices.Remap(vi' guid);                      }                  }              }              else if (line.StartsWith("Process was revoked"))              {                  Match m = revokedRegex.Match(line);                  if (m.Success)                  {                      string oldGuid = m.Groups[1].Value;                      ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(oldGuid);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Revoked);                          string newGuid = m.Groups[2].Value;                          this.jobVertices.Remap(vi' newGuid);                      }                      else                      {                          Trace.TraceInformation("Could not find revoked vertex with guid " + oldGuid);                      }                  }              }              else if (line.StartsWith("---HiPriTime"))              {                  // Scope-specific line which we use to get the i/o information                  // ---HiPriTime D7D51A1F-6693-4378-95FD-FC778A67C632'F52CA694-0202-411E-85E9-0C883E770A0E'SV4_Extract_Split[0]'Completed'ch1sch010331112'2011-05-03 15:26:01.681 PDT'2011-05-03 15:26:01.696 PDT'2011-05-03 15:26:02.118 PDT'2011-05-03 15:26:04.286 PDT'2011-05-03 15:26:07.656 PDT'2011-05-03 15:26:01.696 PDT'97390825'1498630                  string info = line.Substring(13);                  string[] parts = info.Split(''');                  if (parts.Length >= 13)                  {                      long read = long.Parse(parts[11]);                      long written = long.Parse(parts[12]);                      string guid = parts[1];                        ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(guid);                      if (vi != null)                      {                          vi.DataRead = read;                          vi.DataWritten = written;                          this.TotalDataRead += read;                      }                  }              }              else if (line.Contains("Io information"))              {                  // HPC-specific line                  Match m = ioRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.DataRead = long.Parse(m.Groups[4].Value);                          vi.DataWritten = long.Parse(m.Groups[5].Value);                          this.TotalDataRead += vi.DataRead;                      }                  }              }              else if (line.Contains("Process started"))              {                  //those vertices which are being canceled may not be here                  Match m = vertexStartRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        string version = m.Groups[3].Value;                      string guid = m.Groups[4].Value;                      string pid = this.ClusterConfiguration.ExtractPidFromGuid(guid' this.Summary);                      DryadProcessIdentifier identifier = new DryadProcessIdentifier(pid);                      string machine = m.Groups[5].Value;                        // Process started for vertex 4 (Super__0[0]) v.0 GUID {9DDD0B00-C93F-46D2-9073-1CFD27829300} machine sherwood-255                      // Process started for vertices 23 (Merge__29) 24 (Apply__33) v.0 GUID {E945DC5D-9AF6-4732-8770-2A6BF7FA3041} machine sherwood-237                        string vertices = m.Groups[2].Value;                      // This is a list of (number \(name\))* pairs                      // we will assume that the parantheses are matched' or we can't do much                        bool onevertex;                      if (m.Groups[1].Value == "ex")  // one vertEX                          onevertex = true;                      else if (m.Groups[1].Value == "ices")                          onevertex = false;                      else                          throw new DryadException("Can't figure out if one or many vertices");                        IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                        int vertexcount = 0;                      int iversion = int.Parse(version);                        if (lineTimeStamp > this.lastTimestampSeen)                          this.lastTimestampSeen = lineTimeStamp;                      foreach (var p in vertexList)                      {                          int number = p.Item2;                          ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' iversion);                          //new ExecutedVertexInstance(this' number' version' name' identifier' machine' this.lastTimestampSeen);                          if (vi == null)                              Trace.TraceInformation("Could not find information for vertex {0}.{1}"' number' version);                          else                              vi.SetStartInformation(this' machine' this.lastTimestampSeen' identifier' guid);                          vertexcount++;                      }                        if (vertexcount > 1 && onevertex)                          throw new DryadException("Expected one vertex' found " + vertexcount);                  }                  else                  {                      Trace.TraceInformation("Unexpected parsing error on line {0}"' line);                  }              }              else if (line.Contains("Abandoning"))              {                  Match m = vertexAbandonedRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                          vi.SetState(ExecutedVertexInstance.VertexState.Abandoned);                  }              }              else if (line.Contains("Setting"))              {                  Match m = setToFailedlRegex.Match(line);                  if (m.Success)                  {                      // Setting vertex 1461.0 (Merge__13[258]) to failed                      // Setting vertex (\d+)\.(\d+) \((.+)\) to failed(.*)                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          //vi.ErrorString = m.Groups[4].Value;                      }                  }              }              else if (line.Contains("Process was terminated"))              {                  // terminatedRegex = new Regex(@"Process was terminated Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) status (.*)"'                  // Process was terminated Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 status The operation succeeded                  Match m = terminatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          // sometimes successful processes are terminated' because they don't report quickly enough being done                          if (vi.State != ExecutedVertexInstance.VertexState.Successful)                          {                              vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          }                          vi.ErrorString = m.Groups[6].Value;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                  }              }              else if (line.Contains("Timing Information Graph Start Time"))              {                  // Cosmos-specific line                  // Timing Information Graph Start Time 128654556581866096                  Match m = Regex.Match(line' @"Timing Information Graph Start Time (\d+)");                  DateTime createTime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                  this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                  this.lastTimestampSeen = createTime;              }              else if (line.StartsWith("Start time: "))              {                  // HPC L2H specific line                  // Start time: 04/05/2011 17:25:42.223                  DateTime createTime;                  bool parse = DateTime.TryParse(line.Substring("Start time: ".Length)' out createTime);                    if (parse)                  {                      this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                      this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                      this.lastTimestampSeen = createTime;                  }              }              else if (line.Contains("JM Finish time:"))              {                  // Cosmos-specific line                  // JM Finish time: 129140295499437263 2010-03-25T22:25:49.943726Z                  Match m = Regex.Match(line' @"JM Finish time: (\d+)");                  DateTime time = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.lastTimestampSeen = time;                  this.ManagerVertex.End = time;              }              else if (line.StartsWith("Stop time "))              {                  // HPC L2H specific line                  // Stop time (Exit code = 2148734208): 04/05/2011 17:25:46.614                  Regex regex = new Regex(@"Stop time \(Exit code = (.*)\): (.*)");                  Match m = regex.Match(line);                  if (m.Success)                  {                      this.ManagerStdoutIncomplete = false;                        DateTime time;                      bool parse = DateTime.TryParse(m.Groups[2].Value' out time);                      if (parse)                      {                          this.lastTimestampSeen = time;                          this.ManagerVertex.End = time;                      }                        this.ErrorCode = m.Groups[1].Value;                      if (this.ErrorCode == "0")                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                      }                      else                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                      }                  }              }              else if (line.Contains("Timing Information"))              {                  // Timing Information 4 1 Super__0[0] 128654556603428182 0.0000 0.0000 0.0000 0.0000 0.2500                   Match m = timingInfoRegex.Match(line);                  if (m.Success)                  {                      int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      DateTime createtime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[4].Value);                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi == null)                          return; // we do not keep track of vertices with duplicate scheduling' so these won't show up here                        if (vi.State == ExecutedVertexInstance.VertexState.Started)                      {                          Console.WriteLine("Timing information while vertex is still running " + vi);                          //throw new ClusterException("Timing information for vertex still running: " + vi);                      }                      DateTime last = vi.SetTiming(createtime' m.Groups[5].Value' m.Groups[6].Value' m.Groups[7].Value' m.Groups[8].Value' m.Groups[9].Value);                      if (last > this.lastTimestampSeen)                          this.lastTimestampSeen = last;                      this.ManagerVertex.MarkVertexWasRunning(last);                        try                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              this.UsefulCPUTime += vi.RunningTime;                          else if (vi.RunningTime > TimeSpan.Zero)                              this.WastedCPUTime += vi.RunningTime;                      }                      catch (Exception ex)                      {                          Console.WriteLine("Time value exception: " + ex.Message);                      }                  }                  else                      throw new DryadException("Unmatched timing information line " + line);              }              else if (line.Contains("Process has failed"))              {                  // Process has failed Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 Exitcode 0 status The operation succeeded                  // failedRegex = new Regex(@"Process has failed Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) Exitcode (.*)"'                  Match m = failedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string exitcode = m.Groups[6].Value;                      //string status = m.Groups[7].Value;                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          vi.ExitCode = exitcode;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                          //vi.ErrorString = status;                      }                  }              }              else if (line.Contains("ABORTING:"))              {                  this.AbortingMsg = line.Substring(10);                  this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);              }              else if (line.Contains("Accurate read data"))              {                  Match m = datareadRegex.Match(line);                  if (m.Success)                  {                      this.TotalDataRead = long.Parse(m.Groups[1].Value);                      this.LocalReadData = long.Parse(m.Groups[2].Value);                      this.IntraPodDataRead = long.Parse(m.Groups[3].Value);                      this.CrossPodDataRead = long.Parse(m.Groups[4].Value);                  }              }              else if (line.Contains("<ErrorString>"))              {                  //some errors contains "Error returned from managed runtime invocation"                  //which shows the error is from application code                  Match m = Regex.Match(line' @"\<ErrorString\>(.*)\</ErrorString\>");                  if (m.Success && lastFailedVertex != null)                  {                      lastFailedVertex.AddErrorString(System.Web.HttpUtility.HtmlDecode(m.Groups[1].Value));                  }              }              else if (line.Contains("Canceling"))              {                  // Canceling vertex 1461.0 (Merge__13[258]) due to dependent failure                  Match m = cancelRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string name = m.Groups[3].Value;                        ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              vi.SetState(ExecutedVertexInstance.VertexState.Invalidated);                          else                               vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                      else                      {                          // TODO: this should not be needed' but this is a workaround for a bug in the HPC L2H software                          vi = new ExecutedVertexInstance(this' vertex' version' name' ""' lineTimeStamp);                          vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          this.jobVertices.Add(vi);                      }                      // Process wasn't even started' so there is nothing to cancel                  }              }              else if (line.Contains("Application"))              {                  //the job ends successfully                  Regex endSuccessRegex = new Regex(@"Application completed successfully.");                  //the job failed                  Regex endFailRegex = new Regex(@"Application failed with error code (.*)");                    Match m1 = endFailRegex.Match(line);                    if (m1.Success)                  {                      this.ErrorCode = m1.Groups[1].Value;                      this.ManagerStdoutIncomplete = false;                      this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                  }                  else                  {                      Match m2 = endSuccessRegex.Match(line);                      if (m2.Success)                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                          this.ManagerStdoutIncomplete = false;                      }                  }              }              else if (line.StartsWith("Input"))              {                  // Input vertex %u (%s) had %u read failure%s\n                  Match m = inputFailureRegex.Match(line);                  if (m.Success)                  {                      this.AbortingMsg = line;                  }              }              else if (line.Contains("Vertex"))              {                  // terminationRegex = new Regex(@"Vertex (\d+)\.(\d+) \((.+)\) machine (\S+) guid \{?([-0-9A-F]+)\}? status (.*)"                  Match m = terminationRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(vertex' version);                      if (vi == null)                      {                          Trace.TraceInformation("Could not find vertex {0}.{1} line {2}"' vertex' version' line);                      }                      else                      {                          bool failed = vi.SetTermination(m.Groups[6].Value' lineTimeStamp);                          if (failed)                              this.lastFailedVertex = vi;                      }                  }              }
Magic Number,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseStdoutLine,The following statement contains a magic number: if (line.Contains("Created process execution record"))              {                  Match m = vertexCreatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Created process execution record for vertex (\d+) \((.*)\) v.(\d+) GUID \{?([-A-F0-9]+)\}?                      int number = Int32.Parse(m.Groups[1].Value);                      string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                        // the vertex may be already there' sometimes numbers are reused...                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi == null)                      {                          vi = new ExecutedVertexInstance(this' number' version' name' guid' lineTimeStamp);                          this.jobVertices.Add(vi);                      }                  }                  else                  {                      m = verticesCreatedRegex.Match(line);                      if (m.Success)                      {                          lineTimeStamp = ParseLineTimestamp(line);                            // Created process execution record for vertices (.*) v.(\d+) GUID \{?([-A-F0-9]+)\}?                          // Created process execution record for vertices 192 (Merge__41[0]) 223 (Union__45[0]) v.0 GUID {0297A91C-FFEA-42EA-94AF-CD0163A04D45}                          int version = Int32.Parse(m.Groups[2].Value);                          string vertices = m.Groups[1].Value;                          string guid = m.Groups[3].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                            IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                          foreach (var p in vertexList)                          {                              int number = p.Item2;                              ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                              if (vi == null)                              {                                  vi = new ExecutedVertexInstance(this' number' version' p.Item1' guid' lineTimeStamp);                                  this.jobVertices.Add(vi);                              }                          }                      }                  }              }              else if (line.StartsWith("Creating process"))              {                  Match m = processCreatingRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Creating process for vertex (\d+) \((.*)\\) v.(\d+) GUID \{?([-A-F0-9]+)\}? machine (\w+)                      int number = Int32.Parse(m.Groups[1].Value);                      //string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value;                         ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          this.jobVertices.Remap(vi' guid);                      }                  }              }              else if (line.StartsWith("Process was revoked"))              {                  Match m = revokedRegex.Match(line);                  if (m.Success)                  {                      string oldGuid = m.Groups[1].Value;                      ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(oldGuid);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Revoked);                          string newGuid = m.Groups[2].Value;                          this.jobVertices.Remap(vi' newGuid);                      }                      else                      {                          Trace.TraceInformation("Could not find revoked vertex with guid " + oldGuid);                      }                  }              }              else if (line.StartsWith("---HiPriTime"))              {                  // Scope-specific line which we use to get the i/o information                  // ---HiPriTime D7D51A1F-6693-4378-95FD-FC778A67C632'F52CA694-0202-411E-85E9-0C883E770A0E'SV4_Extract_Split[0]'Completed'ch1sch010331112'2011-05-03 15:26:01.681 PDT'2011-05-03 15:26:01.696 PDT'2011-05-03 15:26:02.118 PDT'2011-05-03 15:26:04.286 PDT'2011-05-03 15:26:07.656 PDT'2011-05-03 15:26:01.696 PDT'97390825'1498630                  string info = line.Substring(13);                  string[] parts = info.Split(''');                  if (parts.Length >= 13)                  {                      long read = long.Parse(parts[11]);                      long written = long.Parse(parts[12]);                      string guid = parts[1];                        ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(guid);                      if (vi != null)                      {                          vi.DataRead = read;                          vi.DataWritten = written;                          this.TotalDataRead += read;                      }                  }              }              else if (line.Contains("Io information"))              {                  // HPC-specific line                  Match m = ioRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.DataRead = long.Parse(m.Groups[4].Value);                          vi.DataWritten = long.Parse(m.Groups[5].Value);                          this.TotalDataRead += vi.DataRead;                      }                  }              }              else if (line.Contains("Process started"))              {                  //those vertices which are being canceled may not be here                  Match m = vertexStartRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        string version = m.Groups[3].Value;                      string guid = m.Groups[4].Value;                      string pid = this.ClusterConfiguration.ExtractPidFromGuid(guid' this.Summary);                      DryadProcessIdentifier identifier = new DryadProcessIdentifier(pid);                      string machine = m.Groups[5].Value;                        // Process started for vertex 4 (Super__0[0]) v.0 GUID {9DDD0B00-C93F-46D2-9073-1CFD27829300} machine sherwood-255                      // Process started for vertices 23 (Merge__29) 24 (Apply__33) v.0 GUID {E945DC5D-9AF6-4732-8770-2A6BF7FA3041} machine sherwood-237                        string vertices = m.Groups[2].Value;                      // This is a list of (number \(name\))* pairs                      // we will assume that the parantheses are matched' or we can't do much                        bool onevertex;                      if (m.Groups[1].Value == "ex")  // one vertEX                          onevertex = true;                      else if (m.Groups[1].Value == "ices")                          onevertex = false;                      else                          throw new DryadException("Can't figure out if one or many vertices");                        IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                        int vertexcount = 0;                      int iversion = int.Parse(version);                        if (lineTimeStamp > this.lastTimestampSeen)                          this.lastTimestampSeen = lineTimeStamp;                      foreach (var p in vertexList)                      {                          int number = p.Item2;                          ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' iversion);                          //new ExecutedVertexInstance(this' number' version' name' identifier' machine' this.lastTimestampSeen);                          if (vi == null)                              Trace.TraceInformation("Could not find information for vertex {0}.{1}"' number' version);                          else                              vi.SetStartInformation(this' machine' this.lastTimestampSeen' identifier' guid);                          vertexcount++;                      }                        if (vertexcount > 1 && onevertex)                          throw new DryadException("Expected one vertex' found " + vertexcount);                  }                  else                  {                      Trace.TraceInformation("Unexpected parsing error on line {0}"' line);                  }              }              else if (line.Contains("Abandoning"))              {                  Match m = vertexAbandonedRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                          vi.SetState(ExecutedVertexInstance.VertexState.Abandoned);                  }              }              else if (line.Contains("Setting"))              {                  Match m = setToFailedlRegex.Match(line);                  if (m.Success)                  {                      // Setting vertex 1461.0 (Merge__13[258]) to failed                      // Setting vertex (\d+)\.(\d+) \((.+)\) to failed(.*)                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          //vi.ErrorString = m.Groups[4].Value;                      }                  }              }              else if (line.Contains("Process was terminated"))              {                  // terminatedRegex = new Regex(@"Process was terminated Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) status (.*)"'                  // Process was terminated Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 status The operation succeeded                  Match m = terminatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          // sometimes successful processes are terminated' because they don't report quickly enough being done                          if (vi.State != ExecutedVertexInstance.VertexState.Successful)                          {                              vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          }                          vi.ErrorString = m.Groups[6].Value;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                  }              }              else if (line.Contains("Timing Information Graph Start Time"))              {                  // Cosmos-specific line                  // Timing Information Graph Start Time 128654556581866096                  Match m = Regex.Match(line' @"Timing Information Graph Start Time (\d+)");                  DateTime createTime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                  this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                  this.lastTimestampSeen = createTime;              }              else if (line.StartsWith("Start time: "))              {                  // HPC L2H specific line                  // Start time: 04/05/2011 17:25:42.223                  DateTime createTime;                  bool parse = DateTime.TryParse(line.Substring("Start time: ".Length)' out createTime);                    if (parse)                  {                      this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                      this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                      this.lastTimestampSeen = createTime;                  }              }              else if (line.Contains("JM Finish time:"))              {                  // Cosmos-specific line                  // JM Finish time: 129140295499437263 2010-03-25T22:25:49.943726Z                  Match m = Regex.Match(line' @"JM Finish time: (\d+)");                  DateTime time = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.lastTimestampSeen = time;                  this.ManagerVertex.End = time;              }              else if (line.StartsWith("Stop time "))              {                  // HPC L2H specific line                  // Stop time (Exit code = 2148734208): 04/05/2011 17:25:46.614                  Regex regex = new Regex(@"Stop time \(Exit code = (.*)\): (.*)");                  Match m = regex.Match(line);                  if (m.Success)                  {                      this.ManagerStdoutIncomplete = false;                        DateTime time;                      bool parse = DateTime.TryParse(m.Groups[2].Value' out time);                      if (parse)                      {                          this.lastTimestampSeen = time;                          this.ManagerVertex.End = time;                      }                        this.ErrorCode = m.Groups[1].Value;                      if (this.ErrorCode == "0")                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                      }                      else                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                      }                  }              }              else if (line.Contains("Timing Information"))              {                  // Timing Information 4 1 Super__0[0] 128654556603428182 0.0000 0.0000 0.0000 0.0000 0.2500                   Match m = timingInfoRegex.Match(line);                  if (m.Success)                  {                      int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      DateTime createtime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[4].Value);                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi == null)                          return; // we do not keep track of vertices with duplicate scheduling' so these won't show up here                        if (vi.State == ExecutedVertexInstance.VertexState.Started)                      {                          Console.WriteLine("Timing information while vertex is still running " + vi);                          //throw new ClusterException("Timing information for vertex still running: " + vi);                      }                      DateTime last = vi.SetTiming(createtime' m.Groups[5].Value' m.Groups[6].Value' m.Groups[7].Value' m.Groups[8].Value' m.Groups[9].Value);                      if (last > this.lastTimestampSeen)                          this.lastTimestampSeen = last;                      this.ManagerVertex.MarkVertexWasRunning(last);                        try                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              this.UsefulCPUTime += vi.RunningTime;                          else if (vi.RunningTime > TimeSpan.Zero)                              this.WastedCPUTime += vi.RunningTime;                      }                      catch (Exception ex)                      {                          Console.WriteLine("Time value exception: " + ex.Message);                      }                  }                  else                      throw new DryadException("Unmatched timing information line " + line);              }              else if (line.Contains("Process has failed"))              {                  // Process has failed Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 Exitcode 0 status The operation succeeded                  // failedRegex = new Regex(@"Process has failed Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) Exitcode (.*)"'                  Match m = failedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string exitcode = m.Groups[6].Value;                      //string status = m.Groups[7].Value;                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          vi.ExitCode = exitcode;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                          //vi.ErrorString = status;                      }                  }              }              else if (line.Contains("ABORTING:"))              {                  this.AbortingMsg = line.Substring(10);                  this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);              }              else if (line.Contains("Accurate read data"))              {                  Match m = datareadRegex.Match(line);                  if (m.Success)                  {                      this.TotalDataRead = long.Parse(m.Groups[1].Value);                      this.LocalReadData = long.Parse(m.Groups[2].Value);                      this.IntraPodDataRead = long.Parse(m.Groups[3].Value);                      this.CrossPodDataRead = long.Parse(m.Groups[4].Value);                  }              }              else if (line.Contains("<ErrorString>"))              {                  //some errors contains "Error returned from managed runtime invocation"                  //which shows the error is from application code                  Match m = Regex.Match(line' @"\<ErrorString\>(.*)\</ErrorString\>");                  if (m.Success && lastFailedVertex != null)                  {                      lastFailedVertex.AddErrorString(System.Web.HttpUtility.HtmlDecode(m.Groups[1].Value));                  }              }              else if (line.Contains("Canceling"))              {                  // Canceling vertex 1461.0 (Merge__13[258]) due to dependent failure                  Match m = cancelRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string name = m.Groups[3].Value;                        ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              vi.SetState(ExecutedVertexInstance.VertexState.Invalidated);                          else                               vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                      else                      {                          // TODO: this should not be needed' but this is a workaround for a bug in the HPC L2H software                          vi = new ExecutedVertexInstance(this' vertex' version' name' ""' lineTimeStamp);                          vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          this.jobVertices.Add(vi);                      }                      // Process wasn't even started' so there is nothing to cancel                  }              }              else if (line.Contains("Application"))              {                  //the job ends successfully                  Regex endSuccessRegex = new Regex(@"Application completed successfully.");                  //the job failed                  Regex endFailRegex = new Regex(@"Application failed with error code (.*)");                    Match m1 = endFailRegex.Match(line);                    if (m1.Success)                  {                      this.ErrorCode = m1.Groups[1].Value;                      this.ManagerStdoutIncomplete = false;                      this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                  }                  else                  {                      Match m2 = endSuccessRegex.Match(line);                      if (m2.Success)                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                          this.ManagerStdoutIncomplete = false;                      }                  }              }              else if (line.StartsWith("Input"))              {                  // Input vertex %u (%s) had %u read failure%s\n                  Match m = inputFailureRegex.Match(line);                  if (m.Success)                  {                      this.AbortingMsg = line;                  }              }              else if (line.Contains("Vertex"))              {                  // terminationRegex = new Regex(@"Vertex (\d+)\.(\d+) \((.+)\) machine (\S+) guid \{?([-0-9A-F]+)\}? status (.*)"                  Match m = terminationRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(vertex' version);                      if (vi == null)                      {                          Trace.TraceInformation("Could not find vertex {0}.{1} line {2}"' vertex' version' line);                      }                      else                      {                          bool failed = vi.SetTermination(m.Groups[6].Value' lineTimeStamp);                          if (failed)                              this.lastFailedVertex = vi;                      }                  }              }
Magic Number,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseStdoutLine,The following statement contains a magic number: if (line.Contains("Created process execution record"))              {                  Match m = vertexCreatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Created process execution record for vertex (\d+) \((.*)\) v.(\d+) GUID \{?([-A-F0-9]+)\}?                      int number = Int32.Parse(m.Groups[1].Value);                      string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                        // the vertex may be already there' sometimes numbers are reused...                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi == null)                      {                          vi = new ExecutedVertexInstance(this' number' version' name' guid' lineTimeStamp);                          this.jobVertices.Add(vi);                      }                  }                  else                  {                      m = verticesCreatedRegex.Match(line);                      if (m.Success)                      {                          lineTimeStamp = ParseLineTimestamp(line);                            // Created process execution record for vertices (.*) v.(\d+) GUID \{?([-A-F0-9]+)\}?                          // Created process execution record for vertices 192 (Merge__41[0]) 223 (Union__45[0]) v.0 GUID {0297A91C-FFEA-42EA-94AF-CD0163A04D45}                          int version = Int32.Parse(m.Groups[2].Value);                          string vertices = m.Groups[1].Value;                          string guid = m.Groups[3].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                            IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                          foreach (var p in vertexList)                          {                              int number = p.Item2;                              ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                              if (vi == null)                              {                                  vi = new ExecutedVertexInstance(this' number' version' p.Item1' guid' lineTimeStamp);                                  this.jobVertices.Add(vi);                              }                          }                      }                  }              }              else if (line.StartsWith("Creating process"))              {                  Match m = processCreatingRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Creating process for vertex (\d+) \((.*)\\) v.(\d+) GUID \{?([-A-F0-9]+)\}? machine (\w+)                      int number = Int32.Parse(m.Groups[1].Value);                      //string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value;                         ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          this.jobVertices.Remap(vi' guid);                      }                  }              }              else if (line.StartsWith("Process was revoked"))              {                  Match m = revokedRegex.Match(line);                  if (m.Success)                  {                      string oldGuid = m.Groups[1].Value;                      ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(oldGuid);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Revoked);                          string newGuid = m.Groups[2].Value;                          this.jobVertices.Remap(vi' newGuid);                      }                      else                      {                          Trace.TraceInformation("Could not find revoked vertex with guid " + oldGuid);                      }                  }              }              else if (line.StartsWith("---HiPriTime"))              {                  // Scope-specific line which we use to get the i/o information                  // ---HiPriTime D7D51A1F-6693-4378-95FD-FC778A67C632'F52CA694-0202-411E-85E9-0C883E770A0E'SV4_Extract_Split[0]'Completed'ch1sch010331112'2011-05-03 15:26:01.681 PDT'2011-05-03 15:26:01.696 PDT'2011-05-03 15:26:02.118 PDT'2011-05-03 15:26:04.286 PDT'2011-05-03 15:26:07.656 PDT'2011-05-03 15:26:01.696 PDT'97390825'1498630                  string info = line.Substring(13);                  string[] parts = info.Split(''');                  if (parts.Length >= 13)                  {                      long read = long.Parse(parts[11]);                      long written = long.Parse(parts[12]);                      string guid = parts[1];                        ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(guid);                      if (vi != null)                      {                          vi.DataRead = read;                          vi.DataWritten = written;                          this.TotalDataRead += read;                      }                  }              }              else if (line.Contains("Io information"))              {                  // HPC-specific line                  Match m = ioRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.DataRead = long.Parse(m.Groups[4].Value);                          vi.DataWritten = long.Parse(m.Groups[5].Value);                          this.TotalDataRead += vi.DataRead;                      }                  }              }              else if (line.Contains("Process started"))              {                  //those vertices which are being canceled may not be here                  Match m = vertexStartRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        string version = m.Groups[3].Value;                      string guid = m.Groups[4].Value;                      string pid = this.ClusterConfiguration.ExtractPidFromGuid(guid' this.Summary);                      DryadProcessIdentifier identifier = new DryadProcessIdentifier(pid);                      string machine = m.Groups[5].Value;                        // Process started for vertex 4 (Super__0[0]) v.0 GUID {9DDD0B00-C93F-46D2-9073-1CFD27829300} machine sherwood-255                      // Process started for vertices 23 (Merge__29) 24 (Apply__33) v.0 GUID {E945DC5D-9AF6-4732-8770-2A6BF7FA3041} machine sherwood-237                        string vertices = m.Groups[2].Value;                      // This is a list of (number \(name\))* pairs                      // we will assume that the parantheses are matched' or we can't do much                        bool onevertex;                      if (m.Groups[1].Value == "ex")  // one vertEX                          onevertex = true;                      else if (m.Groups[1].Value == "ices")                          onevertex = false;                      else                          throw new DryadException("Can't figure out if one or many vertices");                        IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                        int vertexcount = 0;                      int iversion = int.Parse(version);                        if (lineTimeStamp > this.lastTimestampSeen)                          this.lastTimestampSeen = lineTimeStamp;                      foreach (var p in vertexList)                      {                          int number = p.Item2;                          ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' iversion);                          //new ExecutedVertexInstance(this' number' version' name' identifier' machine' this.lastTimestampSeen);                          if (vi == null)                              Trace.TraceInformation("Could not find information for vertex {0}.{1}"' number' version);                          else                              vi.SetStartInformation(this' machine' this.lastTimestampSeen' identifier' guid);                          vertexcount++;                      }                        if (vertexcount > 1 && onevertex)                          throw new DryadException("Expected one vertex' found " + vertexcount);                  }                  else                  {                      Trace.TraceInformation("Unexpected parsing error on line {0}"' line);                  }              }              else if (line.Contains("Abandoning"))              {                  Match m = vertexAbandonedRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                          vi.SetState(ExecutedVertexInstance.VertexState.Abandoned);                  }              }              else if (line.Contains("Setting"))              {                  Match m = setToFailedlRegex.Match(line);                  if (m.Success)                  {                      // Setting vertex 1461.0 (Merge__13[258]) to failed                      // Setting vertex (\d+)\.(\d+) \((.+)\) to failed(.*)                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          //vi.ErrorString = m.Groups[4].Value;                      }                  }              }              else if (line.Contains("Process was terminated"))              {                  // terminatedRegex = new Regex(@"Process was terminated Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) status (.*)"'                  // Process was terminated Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 status The operation succeeded                  Match m = terminatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          // sometimes successful processes are terminated' because they don't report quickly enough being done                          if (vi.State != ExecutedVertexInstance.VertexState.Successful)                          {                              vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          }                          vi.ErrorString = m.Groups[6].Value;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                  }              }              else if (line.Contains("Timing Information Graph Start Time"))              {                  // Cosmos-specific line                  // Timing Information Graph Start Time 128654556581866096                  Match m = Regex.Match(line' @"Timing Information Graph Start Time (\d+)");                  DateTime createTime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                  this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                  this.lastTimestampSeen = createTime;              }              else if (line.StartsWith("Start time: "))              {                  // HPC L2H specific line                  // Start time: 04/05/2011 17:25:42.223                  DateTime createTime;                  bool parse = DateTime.TryParse(line.Substring("Start time: ".Length)' out createTime);                    if (parse)                  {                      this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                      this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                      this.lastTimestampSeen = createTime;                  }              }              else if (line.Contains("JM Finish time:"))              {                  // Cosmos-specific line                  // JM Finish time: 129140295499437263 2010-03-25T22:25:49.943726Z                  Match m = Regex.Match(line' @"JM Finish time: (\d+)");                  DateTime time = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.lastTimestampSeen = time;                  this.ManagerVertex.End = time;              }              else if (line.StartsWith("Stop time "))              {                  // HPC L2H specific line                  // Stop time (Exit code = 2148734208): 04/05/2011 17:25:46.614                  Regex regex = new Regex(@"Stop time \(Exit code = (.*)\): (.*)");                  Match m = regex.Match(line);                  if (m.Success)                  {                      this.ManagerStdoutIncomplete = false;                        DateTime time;                      bool parse = DateTime.TryParse(m.Groups[2].Value' out time);                      if (parse)                      {                          this.lastTimestampSeen = time;                          this.ManagerVertex.End = time;                      }                        this.ErrorCode = m.Groups[1].Value;                      if (this.ErrorCode == "0")                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                      }                      else                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                      }                  }              }              else if (line.Contains("Timing Information"))              {                  // Timing Information 4 1 Super__0[0] 128654556603428182 0.0000 0.0000 0.0000 0.0000 0.2500                   Match m = timingInfoRegex.Match(line);                  if (m.Success)                  {                      int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      DateTime createtime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[4].Value);                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi == null)                          return; // we do not keep track of vertices with duplicate scheduling' so these won't show up here                        if (vi.State == ExecutedVertexInstance.VertexState.Started)                      {                          Console.WriteLine("Timing information while vertex is still running " + vi);                          //throw new ClusterException("Timing information for vertex still running: " + vi);                      }                      DateTime last = vi.SetTiming(createtime' m.Groups[5].Value' m.Groups[6].Value' m.Groups[7].Value' m.Groups[8].Value' m.Groups[9].Value);                      if (last > this.lastTimestampSeen)                          this.lastTimestampSeen = last;                      this.ManagerVertex.MarkVertexWasRunning(last);                        try                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              this.UsefulCPUTime += vi.RunningTime;                          else if (vi.RunningTime > TimeSpan.Zero)                              this.WastedCPUTime += vi.RunningTime;                      }                      catch (Exception ex)                      {                          Console.WriteLine("Time value exception: " + ex.Message);                      }                  }                  else                      throw new DryadException("Unmatched timing information line " + line);              }              else if (line.Contains("Process has failed"))              {                  // Process has failed Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 Exitcode 0 status The operation succeeded                  // failedRegex = new Regex(@"Process has failed Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) Exitcode (.*)"'                  Match m = failedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string exitcode = m.Groups[6].Value;                      //string status = m.Groups[7].Value;                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          vi.ExitCode = exitcode;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                          //vi.ErrorString = status;                      }                  }              }              else if (line.Contains("ABORTING:"))              {                  this.AbortingMsg = line.Substring(10);                  this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);              }              else if (line.Contains("Accurate read data"))              {                  Match m = datareadRegex.Match(line);                  if (m.Success)                  {                      this.TotalDataRead = long.Parse(m.Groups[1].Value);                      this.LocalReadData = long.Parse(m.Groups[2].Value);                      this.IntraPodDataRead = long.Parse(m.Groups[3].Value);                      this.CrossPodDataRead = long.Parse(m.Groups[4].Value);                  }              }              else if (line.Contains("<ErrorString>"))              {                  //some errors contains "Error returned from managed runtime invocation"                  //which shows the error is from application code                  Match m = Regex.Match(line' @"\<ErrorString\>(.*)\</ErrorString\>");                  if (m.Success && lastFailedVertex != null)                  {                      lastFailedVertex.AddErrorString(System.Web.HttpUtility.HtmlDecode(m.Groups[1].Value));                  }              }              else if (line.Contains("Canceling"))              {                  // Canceling vertex 1461.0 (Merge__13[258]) due to dependent failure                  Match m = cancelRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string name = m.Groups[3].Value;                        ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              vi.SetState(ExecutedVertexInstance.VertexState.Invalidated);                          else                               vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                      else                      {                          // TODO: this should not be needed' but this is a workaround for a bug in the HPC L2H software                          vi = new ExecutedVertexInstance(this' vertex' version' name' ""' lineTimeStamp);                          vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          this.jobVertices.Add(vi);                      }                      // Process wasn't even started' so there is nothing to cancel                  }              }              else if (line.Contains("Application"))              {                  //the job ends successfully                  Regex endSuccessRegex = new Regex(@"Application completed successfully.");                  //the job failed                  Regex endFailRegex = new Regex(@"Application failed with error code (.*)");                    Match m1 = endFailRegex.Match(line);                    if (m1.Success)                  {                      this.ErrorCode = m1.Groups[1].Value;                      this.ManagerStdoutIncomplete = false;                      this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                  }                  else                  {                      Match m2 = endSuccessRegex.Match(line);                      if (m2.Success)                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                          this.ManagerStdoutIncomplete = false;                      }                  }              }              else if (line.StartsWith("Input"))              {                  // Input vertex %u (%s) had %u read failure%s\n                  Match m = inputFailureRegex.Match(line);                  if (m.Success)                  {                      this.AbortingMsg = line;                  }              }              else if (line.Contains("Vertex"))              {                  // terminationRegex = new Regex(@"Vertex (\d+)\.(\d+) \((.+)\) machine (\S+) guid \{?([-0-9A-F]+)\}? status (.*)"                  Match m = terminationRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(vertex' version);                      if (vi == null)                      {                          Trace.TraceInformation("Could not find vertex {0}.{1} line {2}"' vertex' version' line);                      }                      else                      {                          bool failed = vi.SetTermination(m.Groups[6].Value' lineTimeStamp);                          if (failed)                              this.lastFailedVertex = vi;                      }                  }              }
Magic Number,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseStdoutLine,The following statement contains a magic number: if (line.Contains("Created process execution record"))              {                  Match m = vertexCreatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Created process execution record for vertex (\d+) \((.*)\) v.(\d+) GUID \{?([-A-F0-9]+)\}?                      int number = Int32.Parse(m.Groups[1].Value);                      string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                        // the vertex may be already there' sometimes numbers are reused...                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi == null)                      {                          vi = new ExecutedVertexInstance(this' number' version' name' guid' lineTimeStamp);                          this.jobVertices.Add(vi);                      }                  }                  else                  {                      m = verticesCreatedRegex.Match(line);                      if (m.Success)                      {                          lineTimeStamp = ParseLineTimestamp(line);                            // Created process execution record for vertices (.*) v.(\d+) GUID \{?([-A-F0-9]+)\}?                          // Created process execution record for vertices 192 (Merge__41[0]) 223 (Union__45[0]) v.0 GUID {0297A91C-FFEA-42EA-94AF-CD0163A04D45}                          int version = Int32.Parse(m.Groups[2].Value);                          string vertices = m.Groups[1].Value;                          string guid = m.Groups[3].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                            IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                          foreach (var p in vertexList)                          {                              int number = p.Item2;                              ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                              if (vi == null)                              {                                  vi = new ExecutedVertexInstance(this' number' version' p.Item1' guid' lineTimeStamp);                                  this.jobVertices.Add(vi);                              }                          }                      }                  }              }              else if (line.StartsWith("Creating process"))              {                  Match m = processCreatingRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Creating process for vertex (\d+) \((.*)\\) v.(\d+) GUID \{?([-A-F0-9]+)\}? machine (\w+)                      int number = Int32.Parse(m.Groups[1].Value);                      //string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value;                         ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          this.jobVertices.Remap(vi' guid);                      }                  }              }              else if (line.StartsWith("Process was revoked"))              {                  Match m = revokedRegex.Match(line);                  if (m.Success)                  {                      string oldGuid = m.Groups[1].Value;                      ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(oldGuid);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Revoked);                          string newGuid = m.Groups[2].Value;                          this.jobVertices.Remap(vi' newGuid);                      }                      else                      {                          Trace.TraceInformation("Could not find revoked vertex with guid " + oldGuid);                      }                  }              }              else if (line.StartsWith("---HiPriTime"))              {                  // Scope-specific line which we use to get the i/o information                  // ---HiPriTime D7D51A1F-6693-4378-95FD-FC778A67C632'F52CA694-0202-411E-85E9-0C883E770A0E'SV4_Extract_Split[0]'Completed'ch1sch010331112'2011-05-03 15:26:01.681 PDT'2011-05-03 15:26:01.696 PDT'2011-05-03 15:26:02.118 PDT'2011-05-03 15:26:04.286 PDT'2011-05-03 15:26:07.656 PDT'2011-05-03 15:26:01.696 PDT'97390825'1498630                  string info = line.Substring(13);                  string[] parts = info.Split(''');                  if (parts.Length >= 13)                  {                      long read = long.Parse(parts[11]);                      long written = long.Parse(parts[12]);                      string guid = parts[1];                        ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(guid);                      if (vi != null)                      {                          vi.DataRead = read;                          vi.DataWritten = written;                          this.TotalDataRead += read;                      }                  }              }              else if (line.Contains("Io information"))              {                  // HPC-specific line                  Match m = ioRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.DataRead = long.Parse(m.Groups[4].Value);                          vi.DataWritten = long.Parse(m.Groups[5].Value);                          this.TotalDataRead += vi.DataRead;                      }                  }              }              else if (line.Contains("Process started"))              {                  //those vertices which are being canceled may not be here                  Match m = vertexStartRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        string version = m.Groups[3].Value;                      string guid = m.Groups[4].Value;                      string pid = this.ClusterConfiguration.ExtractPidFromGuid(guid' this.Summary);                      DryadProcessIdentifier identifier = new DryadProcessIdentifier(pid);                      string machine = m.Groups[5].Value;                        // Process started for vertex 4 (Super__0[0]) v.0 GUID {9DDD0B00-C93F-46D2-9073-1CFD27829300} machine sherwood-255                      // Process started for vertices 23 (Merge__29) 24 (Apply__33) v.0 GUID {E945DC5D-9AF6-4732-8770-2A6BF7FA3041} machine sherwood-237                        string vertices = m.Groups[2].Value;                      // This is a list of (number \(name\))* pairs                      // we will assume that the parantheses are matched' or we can't do much                        bool onevertex;                      if (m.Groups[1].Value == "ex")  // one vertEX                          onevertex = true;                      else if (m.Groups[1].Value == "ices")                          onevertex = false;                      else                          throw new DryadException("Can't figure out if one or many vertices");                        IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                        int vertexcount = 0;                      int iversion = int.Parse(version);                        if (lineTimeStamp > this.lastTimestampSeen)                          this.lastTimestampSeen = lineTimeStamp;                      foreach (var p in vertexList)                      {                          int number = p.Item2;                          ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' iversion);                          //new ExecutedVertexInstance(this' number' version' name' identifier' machine' this.lastTimestampSeen);                          if (vi == null)                              Trace.TraceInformation("Could not find information for vertex {0}.{1}"' number' version);                          else                              vi.SetStartInformation(this' machine' this.lastTimestampSeen' identifier' guid);                          vertexcount++;                      }                        if (vertexcount > 1 && onevertex)                          throw new DryadException("Expected one vertex' found " + vertexcount);                  }                  else                  {                      Trace.TraceInformation("Unexpected parsing error on line {0}"' line);                  }              }              else if (line.Contains("Abandoning"))              {                  Match m = vertexAbandonedRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                          vi.SetState(ExecutedVertexInstance.VertexState.Abandoned);                  }              }              else if (line.Contains("Setting"))              {                  Match m = setToFailedlRegex.Match(line);                  if (m.Success)                  {                      // Setting vertex 1461.0 (Merge__13[258]) to failed                      // Setting vertex (\d+)\.(\d+) \((.+)\) to failed(.*)                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          //vi.ErrorString = m.Groups[4].Value;                      }                  }              }              else if (line.Contains("Process was terminated"))              {                  // terminatedRegex = new Regex(@"Process was terminated Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) status (.*)"'                  // Process was terminated Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 status The operation succeeded                  Match m = terminatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          // sometimes successful processes are terminated' because they don't report quickly enough being done                          if (vi.State != ExecutedVertexInstance.VertexState.Successful)                          {                              vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          }                          vi.ErrorString = m.Groups[6].Value;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                  }              }              else if (line.Contains("Timing Information Graph Start Time"))              {                  // Cosmos-specific line                  // Timing Information Graph Start Time 128654556581866096                  Match m = Regex.Match(line' @"Timing Information Graph Start Time (\d+)");                  DateTime createTime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                  this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                  this.lastTimestampSeen = createTime;              }              else if (line.StartsWith("Start time: "))              {                  // HPC L2H specific line                  // Start time: 04/05/2011 17:25:42.223                  DateTime createTime;                  bool parse = DateTime.TryParse(line.Substring("Start time: ".Length)' out createTime);                    if (parse)                  {                      this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                      this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                      this.lastTimestampSeen = createTime;                  }              }              else if (line.Contains("JM Finish time:"))              {                  // Cosmos-specific line                  // JM Finish time: 129140295499437263 2010-03-25T22:25:49.943726Z                  Match m = Regex.Match(line' @"JM Finish time: (\d+)");                  DateTime time = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.lastTimestampSeen = time;                  this.ManagerVertex.End = time;              }              else if (line.StartsWith("Stop time "))              {                  // HPC L2H specific line                  // Stop time (Exit code = 2148734208): 04/05/2011 17:25:46.614                  Regex regex = new Regex(@"Stop time \(Exit code = (.*)\): (.*)");                  Match m = regex.Match(line);                  if (m.Success)                  {                      this.ManagerStdoutIncomplete = false;                        DateTime time;                      bool parse = DateTime.TryParse(m.Groups[2].Value' out time);                      if (parse)                      {                          this.lastTimestampSeen = time;                          this.ManagerVertex.End = time;                      }                        this.ErrorCode = m.Groups[1].Value;                      if (this.ErrorCode == "0")                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                      }                      else                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                      }                  }              }              else if (line.Contains("Timing Information"))              {                  // Timing Information 4 1 Super__0[0] 128654556603428182 0.0000 0.0000 0.0000 0.0000 0.2500                   Match m = timingInfoRegex.Match(line);                  if (m.Success)                  {                      int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      DateTime createtime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[4].Value);                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi == null)                          return; // we do not keep track of vertices with duplicate scheduling' so these won't show up here                        if (vi.State == ExecutedVertexInstance.VertexState.Started)                      {                          Console.WriteLine("Timing information while vertex is still running " + vi);                          //throw new ClusterException("Timing information for vertex still running: " + vi);                      }                      DateTime last = vi.SetTiming(createtime' m.Groups[5].Value' m.Groups[6].Value' m.Groups[7].Value' m.Groups[8].Value' m.Groups[9].Value);                      if (last > this.lastTimestampSeen)                          this.lastTimestampSeen = last;                      this.ManagerVertex.MarkVertexWasRunning(last);                        try                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              this.UsefulCPUTime += vi.RunningTime;                          else if (vi.RunningTime > TimeSpan.Zero)                              this.WastedCPUTime += vi.RunningTime;                      }                      catch (Exception ex)                      {                          Console.WriteLine("Time value exception: " + ex.Message);                      }                  }                  else                      throw new DryadException("Unmatched timing information line " + line);              }              else if (line.Contains("Process has failed"))              {                  // Process has failed Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 Exitcode 0 status The operation succeeded                  // failedRegex = new Regex(@"Process has failed Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) Exitcode (.*)"'                  Match m = failedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string exitcode = m.Groups[6].Value;                      //string status = m.Groups[7].Value;                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          vi.ExitCode = exitcode;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                          //vi.ErrorString = status;                      }                  }              }              else if (line.Contains("ABORTING:"))              {                  this.AbortingMsg = line.Substring(10);                  this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);              }              else if (line.Contains("Accurate read data"))              {                  Match m = datareadRegex.Match(line);                  if (m.Success)                  {                      this.TotalDataRead = long.Parse(m.Groups[1].Value);                      this.LocalReadData = long.Parse(m.Groups[2].Value);                      this.IntraPodDataRead = long.Parse(m.Groups[3].Value);                      this.CrossPodDataRead = long.Parse(m.Groups[4].Value);                  }              }              else if (line.Contains("<ErrorString>"))              {                  //some errors contains "Error returned from managed runtime invocation"                  //which shows the error is from application code                  Match m = Regex.Match(line' @"\<ErrorString\>(.*)\</ErrorString\>");                  if (m.Success && lastFailedVertex != null)                  {                      lastFailedVertex.AddErrorString(System.Web.HttpUtility.HtmlDecode(m.Groups[1].Value));                  }              }              else if (line.Contains("Canceling"))              {                  // Canceling vertex 1461.0 (Merge__13[258]) due to dependent failure                  Match m = cancelRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string name = m.Groups[3].Value;                        ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              vi.SetState(ExecutedVertexInstance.VertexState.Invalidated);                          else                               vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                      else                      {                          // TODO: this should not be needed' but this is a workaround for a bug in the HPC L2H software                          vi = new ExecutedVertexInstance(this' vertex' version' name' ""' lineTimeStamp);                          vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          this.jobVertices.Add(vi);                      }                      // Process wasn't even started' so there is nothing to cancel                  }              }              else if (line.Contains("Application"))              {                  //the job ends successfully                  Regex endSuccessRegex = new Regex(@"Application completed successfully.");                  //the job failed                  Regex endFailRegex = new Regex(@"Application failed with error code (.*)");                    Match m1 = endFailRegex.Match(line);                    if (m1.Success)                  {                      this.ErrorCode = m1.Groups[1].Value;                      this.ManagerStdoutIncomplete = false;                      this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                  }                  else                  {                      Match m2 = endSuccessRegex.Match(line);                      if (m2.Success)                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                          this.ManagerStdoutIncomplete = false;                      }                  }              }              else if (line.StartsWith("Input"))              {                  // Input vertex %u (%s) had %u read failure%s\n                  Match m = inputFailureRegex.Match(line);                  if (m.Success)                  {                      this.AbortingMsg = line;                  }              }              else if (line.Contains("Vertex"))              {                  // terminationRegex = new Regex(@"Vertex (\d+)\.(\d+) \((.+)\) machine (\S+) guid \{?([-0-9A-F]+)\}? status (.*)"                  Match m = terminationRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(vertex' version);                      if (vi == null)                      {                          Trace.TraceInformation("Could not find vertex {0}.{1} line {2}"' vertex' version' line);                      }                      else                      {                          bool failed = vi.SetTermination(m.Groups[6].Value' lineTimeStamp);                          if (failed)                              this.lastFailedVertex = vi;                      }                  }              }
Magic Number,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseStdoutLine,The following statement contains a magic number: if (line.Contains("Created process execution record"))              {                  Match m = vertexCreatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Created process execution record for vertex (\d+) \((.*)\) v.(\d+) GUID \{?([-A-F0-9]+)\}?                      int number = Int32.Parse(m.Groups[1].Value);                      string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                        // the vertex may be already there' sometimes numbers are reused...                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi == null)                      {                          vi = new ExecutedVertexInstance(this' number' version' name' guid' lineTimeStamp);                          this.jobVertices.Add(vi);                      }                  }                  else                  {                      m = verticesCreatedRegex.Match(line);                      if (m.Success)                      {                          lineTimeStamp = ParseLineTimestamp(line);                            // Created process execution record for vertices (.*) v.(\d+) GUID \{?([-A-F0-9]+)\}?                          // Created process execution record for vertices 192 (Merge__41[0]) 223 (Union__45[0]) v.0 GUID {0297A91C-FFEA-42EA-94AF-CD0163A04D45}                          int version = Int32.Parse(m.Groups[2].Value);                          string vertices = m.Groups[1].Value;                          string guid = m.Groups[3].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                            IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                          foreach (var p in vertexList)                          {                              int number = p.Item2;                              ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                              if (vi == null)                              {                                  vi = new ExecutedVertexInstance(this' number' version' p.Item1' guid' lineTimeStamp);                                  this.jobVertices.Add(vi);                              }                          }                      }                  }              }              else if (line.StartsWith("Creating process"))              {                  Match m = processCreatingRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Creating process for vertex (\d+) \((.*)\\) v.(\d+) GUID \{?([-A-F0-9]+)\}? machine (\w+)                      int number = Int32.Parse(m.Groups[1].Value);                      //string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value;                         ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          this.jobVertices.Remap(vi' guid);                      }                  }              }              else if (line.StartsWith("Process was revoked"))              {                  Match m = revokedRegex.Match(line);                  if (m.Success)                  {                      string oldGuid = m.Groups[1].Value;                      ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(oldGuid);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Revoked);                          string newGuid = m.Groups[2].Value;                          this.jobVertices.Remap(vi' newGuid);                      }                      else                      {                          Trace.TraceInformation("Could not find revoked vertex with guid " + oldGuid);                      }                  }              }              else if (line.StartsWith("---HiPriTime"))              {                  // Scope-specific line which we use to get the i/o information                  // ---HiPriTime D7D51A1F-6693-4378-95FD-FC778A67C632'F52CA694-0202-411E-85E9-0C883E770A0E'SV4_Extract_Split[0]'Completed'ch1sch010331112'2011-05-03 15:26:01.681 PDT'2011-05-03 15:26:01.696 PDT'2011-05-03 15:26:02.118 PDT'2011-05-03 15:26:04.286 PDT'2011-05-03 15:26:07.656 PDT'2011-05-03 15:26:01.696 PDT'97390825'1498630                  string info = line.Substring(13);                  string[] parts = info.Split(''');                  if (parts.Length >= 13)                  {                      long read = long.Parse(parts[11]);                      long written = long.Parse(parts[12]);                      string guid = parts[1];                        ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(guid);                      if (vi != null)                      {                          vi.DataRead = read;                          vi.DataWritten = written;                          this.TotalDataRead += read;                      }                  }              }              else if (line.Contains("Io information"))              {                  // HPC-specific line                  Match m = ioRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.DataRead = long.Parse(m.Groups[4].Value);                          vi.DataWritten = long.Parse(m.Groups[5].Value);                          this.TotalDataRead += vi.DataRead;                      }                  }              }              else if (line.Contains("Process started"))              {                  //those vertices which are being canceled may not be here                  Match m = vertexStartRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        string version = m.Groups[3].Value;                      string guid = m.Groups[4].Value;                      string pid = this.ClusterConfiguration.ExtractPidFromGuid(guid' this.Summary);                      DryadProcessIdentifier identifier = new DryadProcessIdentifier(pid);                      string machine = m.Groups[5].Value;                        // Process started for vertex 4 (Super__0[0]) v.0 GUID {9DDD0B00-C93F-46D2-9073-1CFD27829300} machine sherwood-255                      // Process started for vertices 23 (Merge__29) 24 (Apply__33) v.0 GUID {E945DC5D-9AF6-4732-8770-2A6BF7FA3041} machine sherwood-237                        string vertices = m.Groups[2].Value;                      // This is a list of (number \(name\))* pairs                      // we will assume that the parantheses are matched' or we can't do much                        bool onevertex;                      if (m.Groups[1].Value == "ex")  // one vertEX                          onevertex = true;                      else if (m.Groups[1].Value == "ices")                          onevertex = false;                      else                          throw new DryadException("Can't figure out if one or many vertices");                        IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                        int vertexcount = 0;                      int iversion = int.Parse(version);                        if (lineTimeStamp > this.lastTimestampSeen)                          this.lastTimestampSeen = lineTimeStamp;                      foreach (var p in vertexList)                      {                          int number = p.Item2;                          ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' iversion);                          //new ExecutedVertexInstance(this' number' version' name' identifier' machine' this.lastTimestampSeen);                          if (vi == null)                              Trace.TraceInformation("Could not find information for vertex {0}.{1}"' number' version);                          else                              vi.SetStartInformation(this' machine' this.lastTimestampSeen' identifier' guid);                          vertexcount++;                      }                        if (vertexcount > 1 && onevertex)                          throw new DryadException("Expected one vertex' found " + vertexcount);                  }                  else                  {                      Trace.TraceInformation("Unexpected parsing error on line {0}"' line);                  }              }              else if (line.Contains("Abandoning"))              {                  Match m = vertexAbandonedRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                          vi.SetState(ExecutedVertexInstance.VertexState.Abandoned);                  }              }              else if (line.Contains("Setting"))              {                  Match m = setToFailedlRegex.Match(line);                  if (m.Success)                  {                      // Setting vertex 1461.0 (Merge__13[258]) to failed                      // Setting vertex (\d+)\.(\d+) \((.+)\) to failed(.*)                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          //vi.ErrorString = m.Groups[4].Value;                      }                  }              }              else if (line.Contains("Process was terminated"))              {                  // terminatedRegex = new Regex(@"Process was terminated Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) status (.*)"'                  // Process was terminated Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 status The operation succeeded                  Match m = terminatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          // sometimes successful processes are terminated' because they don't report quickly enough being done                          if (vi.State != ExecutedVertexInstance.VertexState.Successful)                          {                              vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          }                          vi.ErrorString = m.Groups[6].Value;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                  }              }              else if (line.Contains("Timing Information Graph Start Time"))              {                  // Cosmos-specific line                  // Timing Information Graph Start Time 128654556581866096                  Match m = Regex.Match(line' @"Timing Information Graph Start Time (\d+)");                  DateTime createTime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                  this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                  this.lastTimestampSeen = createTime;              }              else if (line.StartsWith("Start time: "))              {                  // HPC L2H specific line                  // Start time: 04/05/2011 17:25:42.223                  DateTime createTime;                  bool parse = DateTime.TryParse(line.Substring("Start time: ".Length)' out createTime);                    if (parse)                  {                      this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                      this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                      this.lastTimestampSeen = createTime;                  }              }              else if (line.Contains("JM Finish time:"))              {                  // Cosmos-specific line                  // JM Finish time: 129140295499437263 2010-03-25T22:25:49.943726Z                  Match m = Regex.Match(line' @"JM Finish time: (\d+)");                  DateTime time = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.lastTimestampSeen = time;                  this.ManagerVertex.End = time;              }              else if (line.StartsWith("Stop time "))              {                  // HPC L2H specific line                  // Stop time (Exit code = 2148734208): 04/05/2011 17:25:46.614                  Regex regex = new Regex(@"Stop time \(Exit code = (.*)\): (.*)");                  Match m = regex.Match(line);                  if (m.Success)                  {                      this.ManagerStdoutIncomplete = false;                        DateTime time;                      bool parse = DateTime.TryParse(m.Groups[2].Value' out time);                      if (parse)                      {                          this.lastTimestampSeen = time;                          this.ManagerVertex.End = time;                      }                        this.ErrorCode = m.Groups[1].Value;                      if (this.ErrorCode == "0")                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                      }                      else                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                      }                  }              }              else if (line.Contains("Timing Information"))              {                  // Timing Information 4 1 Super__0[0] 128654556603428182 0.0000 0.0000 0.0000 0.0000 0.2500                   Match m = timingInfoRegex.Match(line);                  if (m.Success)                  {                      int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      DateTime createtime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[4].Value);                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi == null)                          return; // we do not keep track of vertices with duplicate scheduling' so these won't show up here                        if (vi.State == ExecutedVertexInstance.VertexState.Started)                      {                          Console.WriteLine("Timing information while vertex is still running " + vi);                          //throw new ClusterException("Timing information for vertex still running: " + vi);                      }                      DateTime last = vi.SetTiming(createtime' m.Groups[5].Value' m.Groups[6].Value' m.Groups[7].Value' m.Groups[8].Value' m.Groups[9].Value);                      if (last > this.lastTimestampSeen)                          this.lastTimestampSeen = last;                      this.ManagerVertex.MarkVertexWasRunning(last);                        try                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              this.UsefulCPUTime += vi.RunningTime;                          else if (vi.RunningTime > TimeSpan.Zero)                              this.WastedCPUTime += vi.RunningTime;                      }                      catch (Exception ex)                      {                          Console.WriteLine("Time value exception: " + ex.Message);                      }                  }                  else                      throw new DryadException("Unmatched timing information line " + line);              }              else if (line.Contains("Process has failed"))              {                  // Process has failed Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 Exitcode 0 status The operation succeeded                  // failedRegex = new Regex(@"Process has failed Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) Exitcode (.*)"'                  Match m = failedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string exitcode = m.Groups[6].Value;                      //string status = m.Groups[7].Value;                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          vi.ExitCode = exitcode;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                          //vi.ErrorString = status;                      }                  }              }              else if (line.Contains("ABORTING:"))              {                  this.AbortingMsg = line.Substring(10);                  this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);              }              else if (line.Contains("Accurate read data"))              {                  Match m = datareadRegex.Match(line);                  if (m.Success)                  {                      this.TotalDataRead = long.Parse(m.Groups[1].Value);                      this.LocalReadData = long.Parse(m.Groups[2].Value);                      this.IntraPodDataRead = long.Parse(m.Groups[3].Value);                      this.CrossPodDataRead = long.Parse(m.Groups[4].Value);                  }              }              else if (line.Contains("<ErrorString>"))              {                  //some errors contains "Error returned from managed runtime invocation"                  //which shows the error is from application code                  Match m = Regex.Match(line' @"\<ErrorString\>(.*)\</ErrorString\>");                  if (m.Success && lastFailedVertex != null)                  {                      lastFailedVertex.AddErrorString(System.Web.HttpUtility.HtmlDecode(m.Groups[1].Value));                  }              }              else if (line.Contains("Canceling"))              {                  // Canceling vertex 1461.0 (Merge__13[258]) due to dependent failure                  Match m = cancelRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string name = m.Groups[3].Value;                        ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              vi.SetState(ExecutedVertexInstance.VertexState.Invalidated);                          else                               vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                      else                      {                          // TODO: this should not be needed' but this is a workaround for a bug in the HPC L2H software                          vi = new ExecutedVertexInstance(this' vertex' version' name' ""' lineTimeStamp);                          vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          this.jobVertices.Add(vi);                      }                      // Process wasn't even started' so there is nothing to cancel                  }              }              else if (line.Contains("Application"))              {                  //the job ends successfully                  Regex endSuccessRegex = new Regex(@"Application completed successfully.");                  //the job failed                  Regex endFailRegex = new Regex(@"Application failed with error code (.*)");                    Match m1 = endFailRegex.Match(line);                    if (m1.Success)                  {                      this.ErrorCode = m1.Groups[1].Value;                      this.ManagerStdoutIncomplete = false;                      this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                  }                  else                  {                      Match m2 = endSuccessRegex.Match(line);                      if (m2.Success)                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                          this.ManagerStdoutIncomplete = false;                      }                  }              }              else if (line.StartsWith("Input"))              {                  // Input vertex %u (%s) had %u read failure%s\n                  Match m = inputFailureRegex.Match(line);                  if (m.Success)                  {                      this.AbortingMsg = line;                  }              }              else if (line.Contains("Vertex"))              {                  // terminationRegex = new Regex(@"Vertex (\d+)\.(\d+) \((.+)\) machine (\S+) guid \{?([-0-9A-F]+)\}? status (.*)"                  Match m = terminationRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(vertex' version);                      if (vi == null)                      {                          Trace.TraceInformation("Could not find vertex {0}.{1} line {2}"' vertex' version' line);                      }                      else                      {                          bool failed = vi.SetTermination(m.Groups[6].Value' lineTimeStamp);                          if (failed)                              this.lastFailedVertex = vi;                      }                  }              }
Magic Number,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseStdoutLine,The following statement contains a magic number: if (line.Contains("Created process execution record"))              {                  Match m = vertexCreatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Created process execution record for vertex (\d+) \((.*)\) v.(\d+) GUID \{?([-A-F0-9]+)\}?                      int number = Int32.Parse(m.Groups[1].Value);                      string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                        // the vertex may be already there' sometimes numbers are reused...                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi == null)                      {                          vi = new ExecutedVertexInstance(this' number' version' name' guid' lineTimeStamp);                          this.jobVertices.Add(vi);                      }                  }                  else                  {                      m = verticesCreatedRegex.Match(line);                      if (m.Success)                      {                          lineTimeStamp = ParseLineTimestamp(line);                            // Created process execution record for vertices (.*) v.(\d+) GUID \{?([-A-F0-9]+)\}?                          // Created process execution record for vertices 192 (Merge__41[0]) 223 (Union__45[0]) v.0 GUID {0297A91C-FFEA-42EA-94AF-CD0163A04D45}                          int version = Int32.Parse(m.Groups[2].Value);                          string vertices = m.Groups[1].Value;                          string guid = m.Groups[3].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                            IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                          foreach (var p in vertexList)                          {                              int number = p.Item2;                              ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                              if (vi == null)                              {                                  vi = new ExecutedVertexInstance(this' number' version' p.Item1' guid' lineTimeStamp);                                  this.jobVertices.Add(vi);                              }                          }                      }                  }              }              else if (line.StartsWith("Creating process"))              {                  Match m = processCreatingRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Creating process for vertex (\d+) \((.*)\\) v.(\d+) GUID \{?([-A-F0-9]+)\}? machine (\w+)                      int number = Int32.Parse(m.Groups[1].Value);                      //string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value;                         ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          this.jobVertices.Remap(vi' guid);                      }                  }              }              else if (line.StartsWith("Process was revoked"))              {                  Match m = revokedRegex.Match(line);                  if (m.Success)                  {                      string oldGuid = m.Groups[1].Value;                      ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(oldGuid);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Revoked);                          string newGuid = m.Groups[2].Value;                          this.jobVertices.Remap(vi' newGuid);                      }                      else                      {                          Trace.TraceInformation("Could not find revoked vertex with guid " + oldGuid);                      }                  }              }              else if (line.StartsWith("---HiPriTime"))              {                  // Scope-specific line which we use to get the i/o information                  // ---HiPriTime D7D51A1F-6693-4378-95FD-FC778A67C632'F52CA694-0202-411E-85E9-0C883E770A0E'SV4_Extract_Split[0]'Completed'ch1sch010331112'2011-05-03 15:26:01.681 PDT'2011-05-03 15:26:01.696 PDT'2011-05-03 15:26:02.118 PDT'2011-05-03 15:26:04.286 PDT'2011-05-03 15:26:07.656 PDT'2011-05-03 15:26:01.696 PDT'97390825'1498630                  string info = line.Substring(13);                  string[] parts = info.Split(''');                  if (parts.Length >= 13)                  {                      long read = long.Parse(parts[11]);                      long written = long.Parse(parts[12]);                      string guid = parts[1];                        ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(guid);                      if (vi != null)                      {                          vi.DataRead = read;                          vi.DataWritten = written;                          this.TotalDataRead += read;                      }                  }              }              else if (line.Contains("Io information"))              {                  // HPC-specific line                  Match m = ioRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.DataRead = long.Parse(m.Groups[4].Value);                          vi.DataWritten = long.Parse(m.Groups[5].Value);                          this.TotalDataRead += vi.DataRead;                      }                  }              }              else if (line.Contains("Process started"))              {                  //those vertices which are being canceled may not be here                  Match m = vertexStartRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        string version = m.Groups[3].Value;                      string guid = m.Groups[4].Value;                      string pid = this.ClusterConfiguration.ExtractPidFromGuid(guid' this.Summary);                      DryadProcessIdentifier identifier = new DryadProcessIdentifier(pid);                      string machine = m.Groups[5].Value;                        // Process started for vertex 4 (Super__0[0]) v.0 GUID {9DDD0B00-C93F-46D2-9073-1CFD27829300} machine sherwood-255                      // Process started for vertices 23 (Merge__29) 24 (Apply__33) v.0 GUID {E945DC5D-9AF6-4732-8770-2A6BF7FA3041} machine sherwood-237                        string vertices = m.Groups[2].Value;                      // This is a list of (number \(name\))* pairs                      // we will assume that the parantheses are matched' or we can't do much                        bool onevertex;                      if (m.Groups[1].Value == "ex")  // one vertEX                          onevertex = true;                      else if (m.Groups[1].Value == "ices")                          onevertex = false;                      else                          throw new DryadException("Can't figure out if one or many vertices");                        IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                        int vertexcount = 0;                      int iversion = int.Parse(version);                        if (lineTimeStamp > this.lastTimestampSeen)                          this.lastTimestampSeen = lineTimeStamp;                      foreach (var p in vertexList)                      {                          int number = p.Item2;                          ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' iversion);                          //new ExecutedVertexInstance(this' number' version' name' identifier' machine' this.lastTimestampSeen);                          if (vi == null)                              Trace.TraceInformation("Could not find information for vertex {0}.{1}"' number' version);                          else                              vi.SetStartInformation(this' machine' this.lastTimestampSeen' identifier' guid);                          vertexcount++;                      }                        if (vertexcount > 1 && onevertex)                          throw new DryadException("Expected one vertex' found " + vertexcount);                  }                  else                  {                      Trace.TraceInformation("Unexpected parsing error on line {0}"' line);                  }              }              else if (line.Contains("Abandoning"))              {                  Match m = vertexAbandonedRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                          vi.SetState(ExecutedVertexInstance.VertexState.Abandoned);                  }              }              else if (line.Contains("Setting"))              {                  Match m = setToFailedlRegex.Match(line);                  if (m.Success)                  {                      // Setting vertex 1461.0 (Merge__13[258]) to failed                      // Setting vertex (\d+)\.(\d+) \((.+)\) to failed(.*)                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          //vi.ErrorString = m.Groups[4].Value;                      }                  }              }              else if (line.Contains("Process was terminated"))              {                  // terminatedRegex = new Regex(@"Process was terminated Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) status (.*)"'                  // Process was terminated Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 status The operation succeeded                  Match m = terminatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          // sometimes successful processes are terminated' because they don't report quickly enough being done                          if (vi.State != ExecutedVertexInstance.VertexState.Successful)                          {                              vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          }                          vi.ErrorString = m.Groups[6].Value;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                  }              }              else if (line.Contains("Timing Information Graph Start Time"))              {                  // Cosmos-specific line                  // Timing Information Graph Start Time 128654556581866096                  Match m = Regex.Match(line' @"Timing Information Graph Start Time (\d+)");                  DateTime createTime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                  this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                  this.lastTimestampSeen = createTime;              }              else if (line.StartsWith("Start time: "))              {                  // HPC L2H specific line                  // Start time: 04/05/2011 17:25:42.223                  DateTime createTime;                  bool parse = DateTime.TryParse(line.Substring("Start time: ".Length)' out createTime);                    if (parse)                  {                      this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                      this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                      this.lastTimestampSeen = createTime;                  }              }              else if (line.Contains("JM Finish time:"))              {                  // Cosmos-specific line                  // JM Finish time: 129140295499437263 2010-03-25T22:25:49.943726Z                  Match m = Regex.Match(line' @"JM Finish time: (\d+)");                  DateTime time = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.lastTimestampSeen = time;                  this.ManagerVertex.End = time;              }              else if (line.StartsWith("Stop time "))              {                  // HPC L2H specific line                  // Stop time (Exit code = 2148734208): 04/05/2011 17:25:46.614                  Regex regex = new Regex(@"Stop time \(Exit code = (.*)\): (.*)");                  Match m = regex.Match(line);                  if (m.Success)                  {                      this.ManagerStdoutIncomplete = false;                        DateTime time;                      bool parse = DateTime.TryParse(m.Groups[2].Value' out time);                      if (parse)                      {                          this.lastTimestampSeen = time;                          this.ManagerVertex.End = time;                      }                        this.ErrorCode = m.Groups[1].Value;                      if (this.ErrorCode == "0")                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                      }                      else                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                      }                  }              }              else if (line.Contains("Timing Information"))              {                  // Timing Information 4 1 Super__0[0] 128654556603428182 0.0000 0.0000 0.0000 0.0000 0.2500                   Match m = timingInfoRegex.Match(line);                  if (m.Success)                  {                      int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      DateTime createtime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[4].Value);                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi == null)                          return; // we do not keep track of vertices with duplicate scheduling' so these won't show up here                        if (vi.State == ExecutedVertexInstance.VertexState.Started)                      {                          Console.WriteLine("Timing information while vertex is still running " + vi);                          //throw new ClusterException("Timing information for vertex still running: " + vi);                      }                      DateTime last = vi.SetTiming(createtime' m.Groups[5].Value' m.Groups[6].Value' m.Groups[7].Value' m.Groups[8].Value' m.Groups[9].Value);                      if (last > this.lastTimestampSeen)                          this.lastTimestampSeen = last;                      this.ManagerVertex.MarkVertexWasRunning(last);                        try                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              this.UsefulCPUTime += vi.RunningTime;                          else if (vi.RunningTime > TimeSpan.Zero)                              this.WastedCPUTime += vi.RunningTime;                      }                      catch (Exception ex)                      {                          Console.WriteLine("Time value exception: " + ex.Message);                      }                  }                  else                      throw new DryadException("Unmatched timing information line " + line);              }              else if (line.Contains("Process has failed"))              {                  // Process has failed Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 Exitcode 0 status The operation succeeded                  // failedRegex = new Regex(@"Process has failed Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) Exitcode (.*)"'                  Match m = failedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string exitcode = m.Groups[6].Value;                      //string status = m.Groups[7].Value;                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          vi.ExitCode = exitcode;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                          //vi.ErrorString = status;                      }                  }              }              else if (line.Contains("ABORTING:"))              {                  this.AbortingMsg = line.Substring(10);                  this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);              }              else if (line.Contains("Accurate read data"))              {                  Match m = datareadRegex.Match(line);                  if (m.Success)                  {                      this.TotalDataRead = long.Parse(m.Groups[1].Value);                      this.LocalReadData = long.Parse(m.Groups[2].Value);                      this.IntraPodDataRead = long.Parse(m.Groups[3].Value);                      this.CrossPodDataRead = long.Parse(m.Groups[4].Value);                  }              }              else if (line.Contains("<ErrorString>"))              {                  //some errors contains "Error returned from managed runtime invocation"                  //which shows the error is from application code                  Match m = Regex.Match(line' @"\<ErrorString\>(.*)\</ErrorString\>");                  if (m.Success && lastFailedVertex != null)                  {                      lastFailedVertex.AddErrorString(System.Web.HttpUtility.HtmlDecode(m.Groups[1].Value));                  }              }              else if (line.Contains("Canceling"))              {                  // Canceling vertex 1461.0 (Merge__13[258]) due to dependent failure                  Match m = cancelRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string name = m.Groups[3].Value;                        ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              vi.SetState(ExecutedVertexInstance.VertexState.Invalidated);                          else                               vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                      else                      {                          // TODO: this should not be needed' but this is a workaround for a bug in the HPC L2H software                          vi = new ExecutedVertexInstance(this' vertex' version' name' ""' lineTimeStamp);                          vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          this.jobVertices.Add(vi);                      }                      // Process wasn't even started' so there is nothing to cancel                  }              }              else if (line.Contains("Application"))              {                  //the job ends successfully                  Regex endSuccessRegex = new Regex(@"Application completed successfully.");                  //the job failed                  Regex endFailRegex = new Regex(@"Application failed with error code (.*)");                    Match m1 = endFailRegex.Match(line);                    if (m1.Success)                  {                      this.ErrorCode = m1.Groups[1].Value;                      this.ManagerStdoutIncomplete = false;                      this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                  }                  else                  {                      Match m2 = endSuccessRegex.Match(line);                      if (m2.Success)                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                          this.ManagerStdoutIncomplete = false;                      }                  }              }              else if (line.StartsWith("Input"))              {                  // Input vertex %u (%s) had %u read failure%s\n                  Match m = inputFailureRegex.Match(line);                  if (m.Success)                  {                      this.AbortingMsg = line;                  }              }              else if (line.Contains("Vertex"))              {                  // terminationRegex = new Regex(@"Vertex (\d+)\.(\d+) \((.+)\) machine (\S+) guid \{?([-0-9A-F]+)\}? status (.*)"                  Match m = terminationRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(vertex' version);                      if (vi == null)                      {                          Trace.TraceInformation("Could not find vertex {0}.{1} line {2}"' vertex' version' line);                      }                      else                      {                          bool failed = vi.SetTermination(m.Groups[6].Value' lineTimeStamp);                          if (failed)                              this.lastFailedVertex = vi;                      }                  }              }
Magic Number,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseStdoutLine,The following statement contains a magic number: if (line.Contains("Created process execution record"))              {                  Match m = vertexCreatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Created process execution record for vertex (\d+) \((.*)\) v.(\d+) GUID \{?([-A-F0-9]+)\}?                      int number = Int32.Parse(m.Groups[1].Value);                      string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                        // the vertex may be already there' sometimes numbers are reused...                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi == null)                      {                          vi = new ExecutedVertexInstance(this' number' version' name' guid' lineTimeStamp);                          this.jobVertices.Add(vi);                      }                  }                  else                  {                      m = verticesCreatedRegex.Match(line);                      if (m.Success)                      {                          lineTimeStamp = ParseLineTimestamp(line);                            // Created process execution record for vertices (.*) v.(\d+) GUID \{?([-A-F0-9]+)\}?                          // Created process execution record for vertices 192 (Merge__41[0]) 223 (Union__45[0]) v.0 GUID {0297A91C-FFEA-42EA-94AF-CD0163A04D45}                          int version = Int32.Parse(m.Groups[2].Value);                          string vertices = m.Groups[1].Value;                          string guid = m.Groups[3].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                            IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                          foreach (var p in vertexList)                          {                              int number = p.Item2;                              ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                              if (vi == null)                              {                                  vi = new ExecutedVertexInstance(this' number' version' p.Item1' guid' lineTimeStamp);                                  this.jobVertices.Add(vi);                              }                          }                      }                  }              }              else if (line.StartsWith("Creating process"))              {                  Match m = processCreatingRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Creating process for vertex (\d+) \((.*)\\) v.(\d+) GUID \{?([-A-F0-9]+)\}? machine (\w+)                      int number = Int32.Parse(m.Groups[1].Value);                      //string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value;                         ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          this.jobVertices.Remap(vi' guid);                      }                  }              }              else if (line.StartsWith("Process was revoked"))              {                  Match m = revokedRegex.Match(line);                  if (m.Success)                  {                      string oldGuid = m.Groups[1].Value;                      ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(oldGuid);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Revoked);                          string newGuid = m.Groups[2].Value;                          this.jobVertices.Remap(vi' newGuid);                      }                      else                      {                          Trace.TraceInformation("Could not find revoked vertex with guid " + oldGuid);                      }                  }              }              else if (line.StartsWith("---HiPriTime"))              {                  // Scope-specific line which we use to get the i/o information                  // ---HiPriTime D7D51A1F-6693-4378-95FD-FC778A67C632'F52CA694-0202-411E-85E9-0C883E770A0E'SV4_Extract_Split[0]'Completed'ch1sch010331112'2011-05-03 15:26:01.681 PDT'2011-05-03 15:26:01.696 PDT'2011-05-03 15:26:02.118 PDT'2011-05-03 15:26:04.286 PDT'2011-05-03 15:26:07.656 PDT'2011-05-03 15:26:01.696 PDT'97390825'1498630                  string info = line.Substring(13);                  string[] parts = info.Split(''');                  if (parts.Length >= 13)                  {                      long read = long.Parse(parts[11]);                      long written = long.Parse(parts[12]);                      string guid = parts[1];                        ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(guid);                      if (vi != null)                      {                          vi.DataRead = read;                          vi.DataWritten = written;                          this.TotalDataRead += read;                      }                  }              }              else if (line.Contains("Io information"))              {                  // HPC-specific line                  Match m = ioRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.DataRead = long.Parse(m.Groups[4].Value);                          vi.DataWritten = long.Parse(m.Groups[5].Value);                          this.TotalDataRead += vi.DataRead;                      }                  }              }              else if (line.Contains("Process started"))              {                  //those vertices which are being canceled may not be here                  Match m = vertexStartRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        string version = m.Groups[3].Value;                      string guid = m.Groups[4].Value;                      string pid = this.ClusterConfiguration.ExtractPidFromGuid(guid' this.Summary);                      DryadProcessIdentifier identifier = new DryadProcessIdentifier(pid);                      string machine = m.Groups[5].Value;                        // Process started for vertex 4 (Super__0[0]) v.0 GUID {9DDD0B00-C93F-46D2-9073-1CFD27829300} machine sherwood-255                      // Process started for vertices 23 (Merge__29) 24 (Apply__33) v.0 GUID {E945DC5D-9AF6-4732-8770-2A6BF7FA3041} machine sherwood-237                        string vertices = m.Groups[2].Value;                      // This is a list of (number \(name\))* pairs                      // we will assume that the parantheses are matched' or we can't do much                        bool onevertex;                      if (m.Groups[1].Value == "ex")  // one vertEX                          onevertex = true;                      else if (m.Groups[1].Value == "ices")                          onevertex = false;                      else                          throw new DryadException("Can't figure out if one or many vertices");                        IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                        int vertexcount = 0;                      int iversion = int.Parse(version);                        if (lineTimeStamp > this.lastTimestampSeen)                          this.lastTimestampSeen = lineTimeStamp;                      foreach (var p in vertexList)                      {                          int number = p.Item2;                          ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' iversion);                          //new ExecutedVertexInstance(this' number' version' name' identifier' machine' this.lastTimestampSeen);                          if (vi == null)                              Trace.TraceInformation("Could not find information for vertex {0}.{1}"' number' version);                          else                              vi.SetStartInformation(this' machine' this.lastTimestampSeen' identifier' guid);                          vertexcount++;                      }                        if (vertexcount > 1 && onevertex)                          throw new DryadException("Expected one vertex' found " + vertexcount);                  }                  else                  {                      Trace.TraceInformation("Unexpected parsing error on line {0}"' line);                  }              }              else if (line.Contains("Abandoning"))              {                  Match m = vertexAbandonedRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                          vi.SetState(ExecutedVertexInstance.VertexState.Abandoned);                  }              }              else if (line.Contains("Setting"))              {                  Match m = setToFailedlRegex.Match(line);                  if (m.Success)                  {                      // Setting vertex 1461.0 (Merge__13[258]) to failed                      // Setting vertex (\d+)\.(\d+) \((.+)\) to failed(.*)                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          //vi.ErrorString = m.Groups[4].Value;                      }                  }              }              else if (line.Contains("Process was terminated"))              {                  // terminatedRegex = new Regex(@"Process was terminated Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) status (.*)"'                  // Process was terminated Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 status The operation succeeded                  Match m = terminatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          // sometimes successful processes are terminated' because they don't report quickly enough being done                          if (vi.State != ExecutedVertexInstance.VertexState.Successful)                          {                              vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          }                          vi.ErrorString = m.Groups[6].Value;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                  }              }              else if (line.Contains("Timing Information Graph Start Time"))              {                  // Cosmos-specific line                  // Timing Information Graph Start Time 128654556581866096                  Match m = Regex.Match(line' @"Timing Information Graph Start Time (\d+)");                  DateTime createTime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                  this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                  this.lastTimestampSeen = createTime;              }              else if (line.StartsWith("Start time: "))              {                  // HPC L2H specific line                  // Start time: 04/05/2011 17:25:42.223                  DateTime createTime;                  bool parse = DateTime.TryParse(line.Substring("Start time: ".Length)' out createTime);                    if (parse)                  {                      this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                      this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                      this.lastTimestampSeen = createTime;                  }              }              else if (line.Contains("JM Finish time:"))              {                  // Cosmos-specific line                  // JM Finish time: 129140295499437263 2010-03-25T22:25:49.943726Z                  Match m = Regex.Match(line' @"JM Finish time: (\d+)");                  DateTime time = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.lastTimestampSeen = time;                  this.ManagerVertex.End = time;              }              else if (line.StartsWith("Stop time "))              {                  // HPC L2H specific line                  // Stop time (Exit code = 2148734208): 04/05/2011 17:25:46.614                  Regex regex = new Regex(@"Stop time \(Exit code = (.*)\): (.*)");                  Match m = regex.Match(line);                  if (m.Success)                  {                      this.ManagerStdoutIncomplete = false;                        DateTime time;                      bool parse = DateTime.TryParse(m.Groups[2].Value' out time);                      if (parse)                      {                          this.lastTimestampSeen = time;                          this.ManagerVertex.End = time;                      }                        this.ErrorCode = m.Groups[1].Value;                      if (this.ErrorCode == "0")                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                      }                      else                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                      }                  }              }              else if (line.Contains("Timing Information"))              {                  // Timing Information 4 1 Super__0[0] 128654556603428182 0.0000 0.0000 0.0000 0.0000 0.2500                   Match m = timingInfoRegex.Match(line);                  if (m.Success)                  {                      int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      DateTime createtime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[4].Value);                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi == null)                          return; // we do not keep track of vertices with duplicate scheduling' so these won't show up here                        if (vi.State == ExecutedVertexInstance.VertexState.Started)                      {                          Console.WriteLine("Timing information while vertex is still running " + vi);                          //throw new ClusterException("Timing information for vertex still running: " + vi);                      }                      DateTime last = vi.SetTiming(createtime' m.Groups[5].Value' m.Groups[6].Value' m.Groups[7].Value' m.Groups[8].Value' m.Groups[9].Value);                      if (last > this.lastTimestampSeen)                          this.lastTimestampSeen = last;                      this.ManagerVertex.MarkVertexWasRunning(last);                        try                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              this.UsefulCPUTime += vi.RunningTime;                          else if (vi.RunningTime > TimeSpan.Zero)                              this.WastedCPUTime += vi.RunningTime;                      }                      catch (Exception ex)                      {                          Console.WriteLine("Time value exception: " + ex.Message);                      }                  }                  else                      throw new DryadException("Unmatched timing information line " + line);              }              else if (line.Contains("Process has failed"))              {                  // Process has failed Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 Exitcode 0 status The operation succeeded                  // failedRegex = new Regex(@"Process has failed Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) Exitcode (.*)"'                  Match m = failedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string exitcode = m.Groups[6].Value;                      //string status = m.Groups[7].Value;                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          vi.ExitCode = exitcode;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                          //vi.ErrorString = status;                      }                  }              }              else if (line.Contains("ABORTING:"))              {                  this.AbortingMsg = line.Substring(10);                  this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);              }              else if (line.Contains("Accurate read data"))              {                  Match m = datareadRegex.Match(line);                  if (m.Success)                  {                      this.TotalDataRead = long.Parse(m.Groups[1].Value);                      this.LocalReadData = long.Parse(m.Groups[2].Value);                      this.IntraPodDataRead = long.Parse(m.Groups[3].Value);                      this.CrossPodDataRead = long.Parse(m.Groups[4].Value);                  }              }              else if (line.Contains("<ErrorString>"))              {                  //some errors contains "Error returned from managed runtime invocation"                  //which shows the error is from application code                  Match m = Regex.Match(line' @"\<ErrorString\>(.*)\</ErrorString\>");                  if (m.Success && lastFailedVertex != null)                  {                      lastFailedVertex.AddErrorString(System.Web.HttpUtility.HtmlDecode(m.Groups[1].Value));                  }              }              else if (line.Contains("Canceling"))              {                  // Canceling vertex 1461.0 (Merge__13[258]) due to dependent failure                  Match m = cancelRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string name = m.Groups[3].Value;                        ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              vi.SetState(ExecutedVertexInstance.VertexState.Invalidated);                          else                               vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                      else                      {                          // TODO: this should not be needed' but this is a workaround for a bug in the HPC L2H software                          vi = new ExecutedVertexInstance(this' vertex' version' name' ""' lineTimeStamp);                          vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          this.jobVertices.Add(vi);                      }                      // Process wasn't even started' so there is nothing to cancel                  }              }              else if (line.Contains("Application"))              {                  //the job ends successfully                  Regex endSuccessRegex = new Regex(@"Application completed successfully.");                  //the job failed                  Regex endFailRegex = new Regex(@"Application failed with error code (.*)");                    Match m1 = endFailRegex.Match(line);                    if (m1.Success)                  {                      this.ErrorCode = m1.Groups[1].Value;                      this.ManagerStdoutIncomplete = false;                      this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                  }                  else                  {                      Match m2 = endSuccessRegex.Match(line);                      if (m2.Success)                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                          this.ManagerStdoutIncomplete = false;                      }                  }              }              else if (line.StartsWith("Input"))              {                  // Input vertex %u (%s) had %u read failure%s\n                  Match m = inputFailureRegex.Match(line);                  if (m.Success)                  {                      this.AbortingMsg = line;                  }              }              else if (line.Contains("Vertex"))              {                  // terminationRegex = new Regex(@"Vertex (\d+)\.(\d+) \((.+)\) machine (\S+) guid \{?([-0-9A-F]+)\}? status (.*)"                  Match m = terminationRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(vertex' version);                      if (vi == null)                      {                          Trace.TraceInformation("Could not find vertex {0}.{1} line {2}"' vertex' version' line);                      }                      else                      {                          bool failed = vi.SetTermination(m.Groups[6].Value' lineTimeStamp);                          if (failed)                              this.lastFailedVertex = vi;                      }                  }              }
Magic Number,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseStdoutLine,The following statement contains a magic number: if (line.Contains("Created process execution record"))              {                  Match m = vertexCreatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Created process execution record for vertex (\d+) \((.*)\) v.(\d+) GUID \{?([-A-F0-9]+)\}?                      int number = Int32.Parse(m.Groups[1].Value);                      string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                        // the vertex may be already there' sometimes numbers are reused...                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi == null)                      {                          vi = new ExecutedVertexInstance(this' number' version' name' guid' lineTimeStamp);                          this.jobVertices.Add(vi);                      }                  }                  else                  {                      m = verticesCreatedRegex.Match(line);                      if (m.Success)                      {                          lineTimeStamp = ParseLineTimestamp(line);                            // Created process execution record for vertices (.*) v.(\d+) GUID \{?([-A-F0-9]+)\}?                          // Created process execution record for vertices 192 (Merge__41[0]) 223 (Union__45[0]) v.0 GUID {0297A91C-FFEA-42EA-94AF-CD0163A04D45}                          int version = Int32.Parse(m.Groups[2].Value);                          string vertices = m.Groups[1].Value;                          string guid = m.Groups[3].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                            IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                          foreach (var p in vertexList)                          {                              int number = p.Item2;                              ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                              if (vi == null)                              {                                  vi = new ExecutedVertexInstance(this' number' version' p.Item1' guid' lineTimeStamp);                                  this.jobVertices.Add(vi);                              }                          }                      }                  }              }              else if (line.StartsWith("Creating process"))              {                  Match m = processCreatingRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Creating process for vertex (\d+) \((.*)\\) v.(\d+) GUID \{?([-A-F0-9]+)\}? machine (\w+)                      int number = Int32.Parse(m.Groups[1].Value);                      //string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value;                         ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          this.jobVertices.Remap(vi' guid);                      }                  }              }              else if (line.StartsWith("Process was revoked"))              {                  Match m = revokedRegex.Match(line);                  if (m.Success)                  {                      string oldGuid = m.Groups[1].Value;                      ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(oldGuid);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Revoked);                          string newGuid = m.Groups[2].Value;                          this.jobVertices.Remap(vi' newGuid);                      }                      else                      {                          Trace.TraceInformation("Could not find revoked vertex with guid " + oldGuid);                      }                  }              }              else if (line.StartsWith("---HiPriTime"))              {                  // Scope-specific line which we use to get the i/o information                  // ---HiPriTime D7D51A1F-6693-4378-95FD-FC778A67C632'F52CA694-0202-411E-85E9-0C883E770A0E'SV4_Extract_Split[0]'Completed'ch1sch010331112'2011-05-03 15:26:01.681 PDT'2011-05-03 15:26:01.696 PDT'2011-05-03 15:26:02.118 PDT'2011-05-03 15:26:04.286 PDT'2011-05-03 15:26:07.656 PDT'2011-05-03 15:26:01.696 PDT'97390825'1498630                  string info = line.Substring(13);                  string[] parts = info.Split(''');                  if (parts.Length >= 13)                  {                      long read = long.Parse(parts[11]);                      long written = long.Parse(parts[12]);                      string guid = parts[1];                        ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(guid);                      if (vi != null)                      {                          vi.DataRead = read;                          vi.DataWritten = written;                          this.TotalDataRead += read;                      }                  }              }              else if (line.Contains("Io information"))              {                  // HPC-specific line                  Match m = ioRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.DataRead = long.Parse(m.Groups[4].Value);                          vi.DataWritten = long.Parse(m.Groups[5].Value);                          this.TotalDataRead += vi.DataRead;                      }                  }              }              else if (line.Contains("Process started"))              {                  //those vertices which are being canceled may not be here                  Match m = vertexStartRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        string version = m.Groups[3].Value;                      string guid = m.Groups[4].Value;                      string pid = this.ClusterConfiguration.ExtractPidFromGuid(guid' this.Summary);                      DryadProcessIdentifier identifier = new DryadProcessIdentifier(pid);                      string machine = m.Groups[5].Value;                        // Process started for vertex 4 (Super__0[0]) v.0 GUID {9DDD0B00-C93F-46D2-9073-1CFD27829300} machine sherwood-255                      // Process started for vertices 23 (Merge__29) 24 (Apply__33) v.0 GUID {E945DC5D-9AF6-4732-8770-2A6BF7FA3041} machine sherwood-237                        string vertices = m.Groups[2].Value;                      // This is a list of (number \(name\))* pairs                      // we will assume that the parantheses are matched' or we can't do much                        bool onevertex;                      if (m.Groups[1].Value == "ex")  // one vertEX                          onevertex = true;                      else if (m.Groups[1].Value == "ices")                          onevertex = false;                      else                          throw new DryadException("Can't figure out if one or many vertices");                        IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                        int vertexcount = 0;                      int iversion = int.Parse(version);                        if (lineTimeStamp > this.lastTimestampSeen)                          this.lastTimestampSeen = lineTimeStamp;                      foreach (var p in vertexList)                      {                          int number = p.Item2;                          ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' iversion);                          //new ExecutedVertexInstance(this' number' version' name' identifier' machine' this.lastTimestampSeen);                          if (vi == null)                              Trace.TraceInformation("Could not find information for vertex {0}.{1}"' number' version);                          else                              vi.SetStartInformation(this' machine' this.lastTimestampSeen' identifier' guid);                          vertexcount++;                      }                        if (vertexcount > 1 && onevertex)                          throw new DryadException("Expected one vertex' found " + vertexcount);                  }                  else                  {                      Trace.TraceInformation("Unexpected parsing error on line {0}"' line);                  }              }              else if (line.Contains("Abandoning"))              {                  Match m = vertexAbandonedRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                          vi.SetState(ExecutedVertexInstance.VertexState.Abandoned);                  }              }              else if (line.Contains("Setting"))              {                  Match m = setToFailedlRegex.Match(line);                  if (m.Success)                  {                      // Setting vertex 1461.0 (Merge__13[258]) to failed                      // Setting vertex (\d+)\.(\d+) \((.+)\) to failed(.*)                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          //vi.ErrorString = m.Groups[4].Value;                      }                  }              }              else if (line.Contains("Process was terminated"))              {                  // terminatedRegex = new Regex(@"Process was terminated Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) status (.*)"'                  // Process was terminated Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 status The operation succeeded                  Match m = terminatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          // sometimes successful processes are terminated' because they don't report quickly enough being done                          if (vi.State != ExecutedVertexInstance.VertexState.Successful)                          {                              vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          }                          vi.ErrorString = m.Groups[6].Value;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                  }              }              else if (line.Contains("Timing Information Graph Start Time"))              {                  // Cosmos-specific line                  // Timing Information Graph Start Time 128654556581866096                  Match m = Regex.Match(line' @"Timing Information Graph Start Time (\d+)");                  DateTime createTime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                  this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                  this.lastTimestampSeen = createTime;              }              else if (line.StartsWith("Start time: "))              {                  // HPC L2H specific line                  // Start time: 04/05/2011 17:25:42.223                  DateTime createTime;                  bool parse = DateTime.TryParse(line.Substring("Start time: ".Length)' out createTime);                    if (parse)                  {                      this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                      this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                      this.lastTimestampSeen = createTime;                  }              }              else if (line.Contains("JM Finish time:"))              {                  // Cosmos-specific line                  // JM Finish time: 129140295499437263 2010-03-25T22:25:49.943726Z                  Match m = Regex.Match(line' @"JM Finish time: (\d+)");                  DateTime time = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.lastTimestampSeen = time;                  this.ManagerVertex.End = time;              }              else if (line.StartsWith("Stop time "))              {                  // HPC L2H specific line                  // Stop time (Exit code = 2148734208): 04/05/2011 17:25:46.614                  Regex regex = new Regex(@"Stop time \(Exit code = (.*)\): (.*)");                  Match m = regex.Match(line);                  if (m.Success)                  {                      this.ManagerStdoutIncomplete = false;                        DateTime time;                      bool parse = DateTime.TryParse(m.Groups[2].Value' out time);                      if (parse)                      {                          this.lastTimestampSeen = time;                          this.ManagerVertex.End = time;                      }                        this.ErrorCode = m.Groups[1].Value;                      if (this.ErrorCode == "0")                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                      }                      else                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                      }                  }              }              else if (line.Contains("Timing Information"))              {                  // Timing Information 4 1 Super__0[0] 128654556603428182 0.0000 0.0000 0.0000 0.0000 0.2500                   Match m = timingInfoRegex.Match(line);                  if (m.Success)                  {                      int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      DateTime createtime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[4].Value);                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi == null)                          return; // we do not keep track of vertices with duplicate scheduling' so these won't show up here                        if (vi.State == ExecutedVertexInstance.VertexState.Started)                      {                          Console.WriteLine("Timing information while vertex is still running " + vi);                          //throw new ClusterException("Timing information for vertex still running: " + vi);                      }                      DateTime last = vi.SetTiming(createtime' m.Groups[5].Value' m.Groups[6].Value' m.Groups[7].Value' m.Groups[8].Value' m.Groups[9].Value);                      if (last > this.lastTimestampSeen)                          this.lastTimestampSeen = last;                      this.ManagerVertex.MarkVertexWasRunning(last);                        try                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              this.UsefulCPUTime += vi.RunningTime;                          else if (vi.RunningTime > TimeSpan.Zero)                              this.WastedCPUTime += vi.RunningTime;                      }                      catch (Exception ex)                      {                          Console.WriteLine("Time value exception: " + ex.Message);                      }                  }                  else                      throw new DryadException("Unmatched timing information line " + line);              }              else if (line.Contains("Process has failed"))              {                  // Process has failed Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 Exitcode 0 status The operation succeeded                  // failedRegex = new Regex(@"Process has failed Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) Exitcode (.*)"'                  Match m = failedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string exitcode = m.Groups[6].Value;                      //string status = m.Groups[7].Value;                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          vi.ExitCode = exitcode;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                          //vi.ErrorString = status;                      }                  }              }              else if (line.Contains("ABORTING:"))              {                  this.AbortingMsg = line.Substring(10);                  this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);              }              else if (line.Contains("Accurate read data"))              {                  Match m = datareadRegex.Match(line);                  if (m.Success)                  {                      this.TotalDataRead = long.Parse(m.Groups[1].Value);                      this.LocalReadData = long.Parse(m.Groups[2].Value);                      this.IntraPodDataRead = long.Parse(m.Groups[3].Value);                      this.CrossPodDataRead = long.Parse(m.Groups[4].Value);                  }              }              else if (line.Contains("<ErrorString>"))              {                  //some errors contains "Error returned from managed runtime invocation"                  //which shows the error is from application code                  Match m = Regex.Match(line' @"\<ErrorString\>(.*)\</ErrorString\>");                  if (m.Success && lastFailedVertex != null)                  {                      lastFailedVertex.AddErrorString(System.Web.HttpUtility.HtmlDecode(m.Groups[1].Value));                  }              }              else if (line.Contains("Canceling"))              {                  // Canceling vertex 1461.0 (Merge__13[258]) due to dependent failure                  Match m = cancelRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string name = m.Groups[3].Value;                        ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              vi.SetState(ExecutedVertexInstance.VertexState.Invalidated);                          else                               vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                      else                      {                          // TODO: this should not be needed' but this is a workaround for a bug in the HPC L2H software                          vi = new ExecutedVertexInstance(this' vertex' version' name' ""' lineTimeStamp);                          vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          this.jobVertices.Add(vi);                      }                      // Process wasn't even started' so there is nothing to cancel                  }              }              else if (line.Contains("Application"))              {                  //the job ends successfully                  Regex endSuccessRegex = new Regex(@"Application completed successfully.");                  //the job failed                  Regex endFailRegex = new Regex(@"Application failed with error code (.*)");                    Match m1 = endFailRegex.Match(line);                    if (m1.Success)                  {                      this.ErrorCode = m1.Groups[1].Value;                      this.ManagerStdoutIncomplete = false;                      this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                  }                  else                  {                      Match m2 = endSuccessRegex.Match(line);                      if (m2.Success)                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                          this.ManagerStdoutIncomplete = false;                      }                  }              }              else if (line.StartsWith("Input"))              {                  // Input vertex %u (%s) had %u read failure%s\n                  Match m = inputFailureRegex.Match(line);                  if (m.Success)                  {                      this.AbortingMsg = line;                  }              }              else if (line.Contains("Vertex"))              {                  // terminationRegex = new Regex(@"Vertex (\d+)\.(\d+) \((.+)\) machine (\S+) guid \{?([-0-9A-F]+)\}? status (.*)"                  Match m = terminationRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(vertex' version);                      if (vi == null)                      {                          Trace.TraceInformation("Could not find vertex {0}.{1} line {2}"' vertex' version' line);                      }                      else                      {                          bool failed = vi.SetTermination(m.Groups[6].Value' lineTimeStamp);                          if (failed)                              this.lastFailedVertex = vi;                      }                  }              }
Magic Number,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseStdoutLine,The following statement contains a magic number: if (line.Contains("Created process execution record"))              {                  Match m = vertexCreatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Created process execution record for vertex (\d+) \((.*)\) v.(\d+) GUID \{?([-A-F0-9]+)\}?                      int number = Int32.Parse(m.Groups[1].Value);                      string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                        // the vertex may be already there' sometimes numbers are reused...                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi == null)                      {                          vi = new ExecutedVertexInstance(this' number' version' name' guid' lineTimeStamp);                          this.jobVertices.Add(vi);                      }                  }                  else                  {                      m = verticesCreatedRegex.Match(line);                      if (m.Success)                      {                          lineTimeStamp = ParseLineTimestamp(line);                            // Created process execution record for vertices (.*) v.(\d+) GUID \{?([-A-F0-9]+)\}?                          // Created process execution record for vertices 192 (Merge__41[0]) 223 (Union__45[0]) v.0 GUID {0297A91C-FFEA-42EA-94AF-CD0163A04D45}                          int version = Int32.Parse(m.Groups[2].Value);                          string vertices = m.Groups[1].Value;                          string guid = m.Groups[3].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                            IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                          foreach (var p in vertexList)                          {                              int number = p.Item2;                              ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                              if (vi == null)                              {                                  vi = new ExecutedVertexInstance(this' number' version' p.Item1' guid' lineTimeStamp);                                  this.jobVertices.Add(vi);                              }                          }                      }                  }              }              else if (line.StartsWith("Creating process"))              {                  Match m = processCreatingRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Creating process for vertex (\d+) \((.*)\\) v.(\d+) GUID \{?([-A-F0-9]+)\}? machine (\w+)                      int number = Int32.Parse(m.Groups[1].Value);                      //string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value;                         ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          this.jobVertices.Remap(vi' guid);                      }                  }              }              else if (line.StartsWith("Process was revoked"))              {                  Match m = revokedRegex.Match(line);                  if (m.Success)                  {                      string oldGuid = m.Groups[1].Value;                      ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(oldGuid);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Revoked);                          string newGuid = m.Groups[2].Value;                          this.jobVertices.Remap(vi' newGuid);                      }                      else                      {                          Trace.TraceInformation("Could not find revoked vertex with guid " + oldGuid);                      }                  }              }              else if (line.StartsWith("---HiPriTime"))              {                  // Scope-specific line which we use to get the i/o information                  // ---HiPriTime D7D51A1F-6693-4378-95FD-FC778A67C632'F52CA694-0202-411E-85E9-0C883E770A0E'SV4_Extract_Split[0]'Completed'ch1sch010331112'2011-05-03 15:26:01.681 PDT'2011-05-03 15:26:01.696 PDT'2011-05-03 15:26:02.118 PDT'2011-05-03 15:26:04.286 PDT'2011-05-03 15:26:07.656 PDT'2011-05-03 15:26:01.696 PDT'97390825'1498630                  string info = line.Substring(13);                  string[] parts = info.Split(''');                  if (parts.Length >= 13)                  {                      long read = long.Parse(parts[11]);                      long written = long.Parse(parts[12]);                      string guid = parts[1];                        ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(guid);                      if (vi != null)                      {                          vi.DataRead = read;                          vi.DataWritten = written;                          this.TotalDataRead += read;                      }                  }              }              else if (line.Contains("Io information"))              {                  // HPC-specific line                  Match m = ioRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.DataRead = long.Parse(m.Groups[4].Value);                          vi.DataWritten = long.Parse(m.Groups[5].Value);                          this.TotalDataRead += vi.DataRead;                      }                  }              }              else if (line.Contains("Process started"))              {                  //those vertices which are being canceled may not be here                  Match m = vertexStartRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        string version = m.Groups[3].Value;                      string guid = m.Groups[4].Value;                      string pid = this.ClusterConfiguration.ExtractPidFromGuid(guid' this.Summary);                      DryadProcessIdentifier identifier = new DryadProcessIdentifier(pid);                      string machine = m.Groups[5].Value;                        // Process started for vertex 4 (Super__0[0]) v.0 GUID {9DDD0B00-C93F-46D2-9073-1CFD27829300} machine sherwood-255                      // Process started for vertices 23 (Merge__29) 24 (Apply__33) v.0 GUID {E945DC5D-9AF6-4732-8770-2A6BF7FA3041} machine sherwood-237                        string vertices = m.Groups[2].Value;                      // This is a list of (number \(name\))* pairs                      // we will assume that the parantheses are matched' or we can't do much                        bool onevertex;                      if (m.Groups[1].Value == "ex")  // one vertEX                          onevertex = true;                      else if (m.Groups[1].Value == "ices")                          onevertex = false;                      else                          throw new DryadException("Can't figure out if one or many vertices");                        IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                        int vertexcount = 0;                      int iversion = int.Parse(version);                        if (lineTimeStamp > this.lastTimestampSeen)                          this.lastTimestampSeen = lineTimeStamp;                      foreach (var p in vertexList)                      {                          int number = p.Item2;                          ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' iversion);                          //new ExecutedVertexInstance(this' number' version' name' identifier' machine' this.lastTimestampSeen);                          if (vi == null)                              Trace.TraceInformation("Could not find information for vertex {0}.{1}"' number' version);                          else                              vi.SetStartInformation(this' machine' this.lastTimestampSeen' identifier' guid);                          vertexcount++;                      }                        if (vertexcount > 1 && onevertex)                          throw new DryadException("Expected one vertex' found " + vertexcount);                  }                  else                  {                      Trace.TraceInformation("Unexpected parsing error on line {0}"' line);                  }              }              else if (line.Contains("Abandoning"))              {                  Match m = vertexAbandonedRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                          vi.SetState(ExecutedVertexInstance.VertexState.Abandoned);                  }              }              else if (line.Contains("Setting"))              {                  Match m = setToFailedlRegex.Match(line);                  if (m.Success)                  {                      // Setting vertex 1461.0 (Merge__13[258]) to failed                      // Setting vertex (\d+)\.(\d+) \((.+)\) to failed(.*)                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          //vi.ErrorString = m.Groups[4].Value;                      }                  }              }              else if (line.Contains("Process was terminated"))              {                  // terminatedRegex = new Regex(@"Process was terminated Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) status (.*)"'                  // Process was terminated Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 status The operation succeeded                  Match m = terminatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          // sometimes successful processes are terminated' because they don't report quickly enough being done                          if (vi.State != ExecutedVertexInstance.VertexState.Successful)                          {                              vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          }                          vi.ErrorString = m.Groups[6].Value;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                  }              }              else if (line.Contains("Timing Information Graph Start Time"))              {                  // Cosmos-specific line                  // Timing Information Graph Start Time 128654556581866096                  Match m = Regex.Match(line' @"Timing Information Graph Start Time (\d+)");                  DateTime createTime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                  this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                  this.lastTimestampSeen = createTime;              }              else if (line.StartsWith("Start time: "))              {                  // HPC L2H specific line                  // Start time: 04/05/2011 17:25:42.223                  DateTime createTime;                  bool parse = DateTime.TryParse(line.Substring("Start time: ".Length)' out createTime);                    if (parse)                  {                      this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                      this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                      this.lastTimestampSeen = createTime;                  }              }              else if (line.Contains("JM Finish time:"))              {                  // Cosmos-specific line                  // JM Finish time: 129140295499437263 2010-03-25T22:25:49.943726Z                  Match m = Regex.Match(line' @"JM Finish time: (\d+)");                  DateTime time = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.lastTimestampSeen = time;                  this.ManagerVertex.End = time;              }              else if (line.StartsWith("Stop time "))              {                  // HPC L2H specific line                  // Stop time (Exit code = 2148734208): 04/05/2011 17:25:46.614                  Regex regex = new Regex(@"Stop time \(Exit code = (.*)\): (.*)");                  Match m = regex.Match(line);                  if (m.Success)                  {                      this.ManagerStdoutIncomplete = false;                        DateTime time;                      bool parse = DateTime.TryParse(m.Groups[2].Value' out time);                      if (parse)                      {                          this.lastTimestampSeen = time;                          this.ManagerVertex.End = time;                      }                        this.ErrorCode = m.Groups[1].Value;                      if (this.ErrorCode == "0")                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                      }                      else                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                      }                  }              }              else if (line.Contains("Timing Information"))              {                  // Timing Information 4 1 Super__0[0] 128654556603428182 0.0000 0.0000 0.0000 0.0000 0.2500                   Match m = timingInfoRegex.Match(line);                  if (m.Success)                  {                      int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      DateTime createtime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[4].Value);                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi == null)                          return; // we do not keep track of vertices with duplicate scheduling' so these won't show up here                        if (vi.State == ExecutedVertexInstance.VertexState.Started)                      {                          Console.WriteLine("Timing information while vertex is still running " + vi);                          //throw new ClusterException("Timing information for vertex still running: " + vi);                      }                      DateTime last = vi.SetTiming(createtime' m.Groups[5].Value' m.Groups[6].Value' m.Groups[7].Value' m.Groups[8].Value' m.Groups[9].Value);                      if (last > this.lastTimestampSeen)                          this.lastTimestampSeen = last;                      this.ManagerVertex.MarkVertexWasRunning(last);                        try                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              this.UsefulCPUTime += vi.RunningTime;                          else if (vi.RunningTime > TimeSpan.Zero)                              this.WastedCPUTime += vi.RunningTime;                      }                      catch (Exception ex)                      {                          Console.WriteLine("Time value exception: " + ex.Message);                      }                  }                  else                      throw new DryadException("Unmatched timing information line " + line);              }              else if (line.Contains("Process has failed"))              {                  // Process has failed Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 Exitcode 0 status The operation succeeded                  // failedRegex = new Regex(@"Process has failed Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) Exitcode (.*)"'                  Match m = failedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string exitcode = m.Groups[6].Value;                      //string status = m.Groups[7].Value;                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          vi.ExitCode = exitcode;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                          //vi.ErrorString = status;                      }                  }              }              else if (line.Contains("ABORTING:"))              {                  this.AbortingMsg = line.Substring(10);                  this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);              }              else if (line.Contains("Accurate read data"))              {                  Match m = datareadRegex.Match(line);                  if (m.Success)                  {                      this.TotalDataRead = long.Parse(m.Groups[1].Value);                      this.LocalReadData = long.Parse(m.Groups[2].Value);                      this.IntraPodDataRead = long.Parse(m.Groups[3].Value);                      this.CrossPodDataRead = long.Parse(m.Groups[4].Value);                  }              }              else if (line.Contains("<ErrorString>"))              {                  //some errors contains "Error returned from managed runtime invocation"                  //which shows the error is from application code                  Match m = Regex.Match(line' @"\<ErrorString\>(.*)\</ErrorString\>");                  if (m.Success && lastFailedVertex != null)                  {                      lastFailedVertex.AddErrorString(System.Web.HttpUtility.HtmlDecode(m.Groups[1].Value));                  }              }              else if (line.Contains("Canceling"))              {                  // Canceling vertex 1461.0 (Merge__13[258]) due to dependent failure                  Match m = cancelRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string name = m.Groups[3].Value;                        ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              vi.SetState(ExecutedVertexInstance.VertexState.Invalidated);                          else                               vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                      else                      {                          // TODO: this should not be needed' but this is a workaround for a bug in the HPC L2H software                          vi = new ExecutedVertexInstance(this' vertex' version' name' ""' lineTimeStamp);                          vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          this.jobVertices.Add(vi);                      }                      // Process wasn't even started' so there is nothing to cancel                  }              }              else if (line.Contains("Application"))              {                  //the job ends successfully                  Regex endSuccessRegex = new Regex(@"Application completed successfully.");                  //the job failed                  Regex endFailRegex = new Regex(@"Application failed with error code (.*)");                    Match m1 = endFailRegex.Match(line);                    if (m1.Success)                  {                      this.ErrorCode = m1.Groups[1].Value;                      this.ManagerStdoutIncomplete = false;                      this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                  }                  else                  {                      Match m2 = endSuccessRegex.Match(line);                      if (m2.Success)                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                          this.ManagerStdoutIncomplete = false;                      }                  }              }              else if (line.StartsWith("Input"))              {                  // Input vertex %u (%s) had %u read failure%s\n                  Match m = inputFailureRegex.Match(line);                  if (m.Success)                  {                      this.AbortingMsg = line;                  }              }              else if (line.Contains("Vertex"))              {                  // terminationRegex = new Regex(@"Vertex (\d+)\.(\d+) \((.+)\) machine (\S+) guid \{?([-0-9A-F]+)\}? status (.*)"                  Match m = terminationRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(vertex' version);                      if (vi == null)                      {                          Trace.TraceInformation("Could not find vertex {0}.{1} line {2}"' vertex' version' line);                      }                      else                      {                          bool failed = vi.SetTermination(m.Groups[6].Value' lineTimeStamp);                          if (failed)                              this.lastFailedVertex = vi;                      }                  }              }
Magic Number,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseStdoutLine,The following statement contains a magic number: if (line.Contains("Created process execution record"))              {                  Match m = vertexCreatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Created process execution record for vertex (\d+) \((.*)\) v.(\d+) GUID \{?([-A-F0-9]+)\}?                      int number = Int32.Parse(m.Groups[1].Value);                      string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                        // the vertex may be already there' sometimes numbers are reused...                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi == null)                      {                          vi = new ExecutedVertexInstance(this' number' version' name' guid' lineTimeStamp);                          this.jobVertices.Add(vi);                      }                  }                  else                  {                      m = verticesCreatedRegex.Match(line);                      if (m.Success)                      {                          lineTimeStamp = ParseLineTimestamp(line);                            // Created process execution record for vertices (.*) v.(\d+) GUID \{?([-A-F0-9]+)\}?                          // Created process execution record for vertices 192 (Merge__41[0]) 223 (Union__45[0]) v.0 GUID {0297A91C-FFEA-42EA-94AF-CD0163A04D45}                          int version = Int32.Parse(m.Groups[2].Value);                          string vertices = m.Groups[1].Value;                          string guid = m.Groups[3].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                            IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                          foreach (var p in vertexList)                          {                              int number = p.Item2;                              ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                              if (vi == null)                              {                                  vi = new ExecutedVertexInstance(this' number' version' p.Item1' guid' lineTimeStamp);                                  this.jobVertices.Add(vi);                              }                          }                      }                  }              }              else if (line.StartsWith("Creating process"))              {                  Match m = processCreatingRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Creating process for vertex (\d+) \((.*)\\) v.(\d+) GUID \{?([-A-F0-9]+)\}? machine (\w+)                      int number = Int32.Parse(m.Groups[1].Value);                      //string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value;                         ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          this.jobVertices.Remap(vi' guid);                      }                  }              }              else if (line.StartsWith("Process was revoked"))              {                  Match m = revokedRegex.Match(line);                  if (m.Success)                  {                      string oldGuid = m.Groups[1].Value;                      ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(oldGuid);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Revoked);                          string newGuid = m.Groups[2].Value;                          this.jobVertices.Remap(vi' newGuid);                      }                      else                      {                          Trace.TraceInformation("Could not find revoked vertex with guid " + oldGuid);                      }                  }              }              else if (line.StartsWith("---HiPriTime"))              {                  // Scope-specific line which we use to get the i/o information                  // ---HiPriTime D7D51A1F-6693-4378-95FD-FC778A67C632'F52CA694-0202-411E-85E9-0C883E770A0E'SV4_Extract_Split[0]'Completed'ch1sch010331112'2011-05-03 15:26:01.681 PDT'2011-05-03 15:26:01.696 PDT'2011-05-03 15:26:02.118 PDT'2011-05-03 15:26:04.286 PDT'2011-05-03 15:26:07.656 PDT'2011-05-03 15:26:01.696 PDT'97390825'1498630                  string info = line.Substring(13);                  string[] parts = info.Split(''');                  if (parts.Length >= 13)                  {                      long read = long.Parse(parts[11]);                      long written = long.Parse(parts[12]);                      string guid = parts[1];                        ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(guid);                      if (vi != null)                      {                          vi.DataRead = read;                          vi.DataWritten = written;                          this.TotalDataRead += read;                      }                  }              }              else if (line.Contains("Io information"))              {                  // HPC-specific line                  Match m = ioRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.DataRead = long.Parse(m.Groups[4].Value);                          vi.DataWritten = long.Parse(m.Groups[5].Value);                          this.TotalDataRead += vi.DataRead;                      }                  }              }              else if (line.Contains("Process started"))              {                  //those vertices which are being canceled may not be here                  Match m = vertexStartRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        string version = m.Groups[3].Value;                      string guid = m.Groups[4].Value;                      string pid = this.ClusterConfiguration.ExtractPidFromGuid(guid' this.Summary);                      DryadProcessIdentifier identifier = new DryadProcessIdentifier(pid);                      string machine = m.Groups[5].Value;                        // Process started for vertex 4 (Super__0[0]) v.0 GUID {9DDD0B00-C93F-46D2-9073-1CFD27829300} machine sherwood-255                      // Process started for vertices 23 (Merge__29) 24 (Apply__33) v.0 GUID {E945DC5D-9AF6-4732-8770-2A6BF7FA3041} machine sherwood-237                        string vertices = m.Groups[2].Value;                      // This is a list of (number \(name\))* pairs                      // we will assume that the parantheses are matched' or we can't do much                        bool onevertex;                      if (m.Groups[1].Value == "ex")  // one vertEX                          onevertex = true;                      else if (m.Groups[1].Value == "ices")                          onevertex = false;                      else                          throw new DryadException("Can't figure out if one or many vertices");                        IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                        int vertexcount = 0;                      int iversion = int.Parse(version);                        if (lineTimeStamp > this.lastTimestampSeen)                          this.lastTimestampSeen = lineTimeStamp;                      foreach (var p in vertexList)                      {                          int number = p.Item2;                          ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' iversion);                          //new ExecutedVertexInstance(this' number' version' name' identifier' machine' this.lastTimestampSeen);                          if (vi == null)                              Trace.TraceInformation("Could not find information for vertex {0}.{1}"' number' version);                          else                              vi.SetStartInformation(this' machine' this.lastTimestampSeen' identifier' guid);                          vertexcount++;                      }                        if (vertexcount > 1 && onevertex)                          throw new DryadException("Expected one vertex' found " + vertexcount);                  }                  else                  {                      Trace.TraceInformation("Unexpected parsing error on line {0}"' line);                  }              }              else if (line.Contains("Abandoning"))              {                  Match m = vertexAbandonedRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                          vi.SetState(ExecutedVertexInstance.VertexState.Abandoned);                  }              }              else if (line.Contains("Setting"))              {                  Match m = setToFailedlRegex.Match(line);                  if (m.Success)                  {                      // Setting vertex 1461.0 (Merge__13[258]) to failed                      // Setting vertex (\d+)\.(\d+) \((.+)\) to failed(.*)                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          //vi.ErrorString = m.Groups[4].Value;                      }                  }              }              else if (line.Contains("Process was terminated"))              {                  // terminatedRegex = new Regex(@"Process was terminated Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) status (.*)"'                  // Process was terminated Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 status The operation succeeded                  Match m = terminatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          // sometimes successful processes are terminated' because they don't report quickly enough being done                          if (vi.State != ExecutedVertexInstance.VertexState.Successful)                          {                              vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          }                          vi.ErrorString = m.Groups[6].Value;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                  }              }              else if (line.Contains("Timing Information Graph Start Time"))              {                  // Cosmos-specific line                  // Timing Information Graph Start Time 128654556581866096                  Match m = Regex.Match(line' @"Timing Information Graph Start Time (\d+)");                  DateTime createTime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                  this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                  this.lastTimestampSeen = createTime;              }              else if (line.StartsWith("Start time: "))              {                  // HPC L2H specific line                  // Start time: 04/05/2011 17:25:42.223                  DateTime createTime;                  bool parse = DateTime.TryParse(line.Substring("Start time: ".Length)' out createTime);                    if (parse)                  {                      this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                      this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                      this.lastTimestampSeen = createTime;                  }              }              else if (line.Contains("JM Finish time:"))              {                  // Cosmos-specific line                  // JM Finish time: 129140295499437263 2010-03-25T22:25:49.943726Z                  Match m = Regex.Match(line' @"JM Finish time: (\d+)");                  DateTime time = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.lastTimestampSeen = time;                  this.ManagerVertex.End = time;              }              else if (line.StartsWith("Stop time "))              {                  // HPC L2H specific line                  // Stop time (Exit code = 2148734208): 04/05/2011 17:25:46.614                  Regex regex = new Regex(@"Stop time \(Exit code = (.*)\): (.*)");                  Match m = regex.Match(line);                  if (m.Success)                  {                      this.ManagerStdoutIncomplete = false;                        DateTime time;                      bool parse = DateTime.TryParse(m.Groups[2].Value' out time);                      if (parse)                      {                          this.lastTimestampSeen = time;                          this.ManagerVertex.End = time;                      }                        this.ErrorCode = m.Groups[1].Value;                      if (this.ErrorCode == "0")                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                      }                      else                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                      }                  }              }              else if (line.Contains("Timing Information"))              {                  // Timing Information 4 1 Super__0[0] 128654556603428182 0.0000 0.0000 0.0000 0.0000 0.2500                   Match m = timingInfoRegex.Match(line);                  if (m.Success)                  {                      int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      DateTime createtime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[4].Value);                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi == null)                          return; // we do not keep track of vertices with duplicate scheduling' so these won't show up here                        if (vi.State == ExecutedVertexInstance.VertexState.Started)                      {                          Console.WriteLine("Timing information while vertex is still running " + vi);                          //throw new ClusterException("Timing information for vertex still running: " + vi);                      }                      DateTime last = vi.SetTiming(createtime' m.Groups[5].Value' m.Groups[6].Value' m.Groups[7].Value' m.Groups[8].Value' m.Groups[9].Value);                      if (last > this.lastTimestampSeen)                          this.lastTimestampSeen = last;                      this.ManagerVertex.MarkVertexWasRunning(last);                        try                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              this.UsefulCPUTime += vi.RunningTime;                          else if (vi.RunningTime > TimeSpan.Zero)                              this.WastedCPUTime += vi.RunningTime;                      }                      catch (Exception ex)                      {                          Console.WriteLine("Time value exception: " + ex.Message);                      }                  }                  else                      throw new DryadException("Unmatched timing information line " + line);              }              else if (line.Contains("Process has failed"))              {                  // Process has failed Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 Exitcode 0 status The operation succeeded                  // failedRegex = new Regex(@"Process has failed Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) Exitcode (.*)"'                  Match m = failedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string exitcode = m.Groups[6].Value;                      //string status = m.Groups[7].Value;                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          vi.ExitCode = exitcode;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                          //vi.ErrorString = status;                      }                  }              }              else if (line.Contains("ABORTING:"))              {                  this.AbortingMsg = line.Substring(10);                  this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);              }              else if (line.Contains("Accurate read data"))              {                  Match m = datareadRegex.Match(line);                  if (m.Success)                  {                      this.TotalDataRead = long.Parse(m.Groups[1].Value);                      this.LocalReadData = long.Parse(m.Groups[2].Value);                      this.IntraPodDataRead = long.Parse(m.Groups[3].Value);                      this.CrossPodDataRead = long.Parse(m.Groups[4].Value);                  }              }              else if (line.Contains("<ErrorString>"))              {                  //some errors contains "Error returned from managed runtime invocation"                  //which shows the error is from application code                  Match m = Regex.Match(line' @"\<ErrorString\>(.*)\</ErrorString\>");                  if (m.Success && lastFailedVertex != null)                  {                      lastFailedVertex.AddErrorString(System.Web.HttpUtility.HtmlDecode(m.Groups[1].Value));                  }              }              else if (line.Contains("Canceling"))              {                  // Canceling vertex 1461.0 (Merge__13[258]) due to dependent failure                  Match m = cancelRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string name = m.Groups[3].Value;                        ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              vi.SetState(ExecutedVertexInstance.VertexState.Invalidated);                          else                               vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                      else                      {                          // TODO: this should not be needed' but this is a workaround for a bug in the HPC L2H software                          vi = new ExecutedVertexInstance(this' vertex' version' name' ""' lineTimeStamp);                          vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          this.jobVertices.Add(vi);                      }                      // Process wasn't even started' so there is nothing to cancel                  }              }              else if (line.Contains("Application"))              {                  //the job ends successfully                  Regex endSuccessRegex = new Regex(@"Application completed successfully.");                  //the job failed                  Regex endFailRegex = new Regex(@"Application failed with error code (.*)");                    Match m1 = endFailRegex.Match(line);                    if (m1.Success)                  {                      this.ErrorCode = m1.Groups[1].Value;                      this.ManagerStdoutIncomplete = false;                      this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                  }                  else                  {                      Match m2 = endSuccessRegex.Match(line);                      if (m2.Success)                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                          this.ManagerStdoutIncomplete = false;                      }                  }              }              else if (line.StartsWith("Input"))              {                  // Input vertex %u (%s) had %u read failure%s\n                  Match m = inputFailureRegex.Match(line);                  if (m.Success)                  {                      this.AbortingMsg = line;                  }              }              else if (line.Contains("Vertex"))              {                  // terminationRegex = new Regex(@"Vertex (\d+)\.(\d+) \((.+)\) machine (\S+) guid \{?([-0-9A-F]+)\}? status (.*)"                  Match m = terminationRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(vertex' version);                      if (vi == null)                      {                          Trace.TraceInformation("Could not find vertex {0}.{1} line {2}"' vertex' version' line);                      }                      else                      {                          bool failed = vi.SetTermination(m.Groups[6].Value' lineTimeStamp);                          if (failed)                              this.lastFailedVertex = vi;                      }                  }              }
Magic Number,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseStdoutLine,The following statement contains a magic number: if (line.Contains("Created process execution record"))              {                  Match m = vertexCreatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Created process execution record for vertex (\d+) \((.*)\) v.(\d+) GUID \{?([-A-F0-9]+)\}?                      int number = Int32.Parse(m.Groups[1].Value);                      string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                        // the vertex may be already there' sometimes numbers are reused...                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi == null)                      {                          vi = new ExecutedVertexInstance(this' number' version' name' guid' lineTimeStamp);                          this.jobVertices.Add(vi);                      }                  }                  else                  {                      m = verticesCreatedRegex.Match(line);                      if (m.Success)                      {                          lineTimeStamp = ParseLineTimestamp(line);                            // Created process execution record for vertices (.*) v.(\d+) GUID \{?([-A-F0-9]+)\}?                          // Created process execution record for vertices 192 (Merge__41[0]) 223 (Union__45[0]) v.0 GUID {0297A91C-FFEA-42EA-94AF-CD0163A04D45}                          int version = Int32.Parse(m.Groups[2].Value);                          string vertices = m.Groups[1].Value;                          string guid = m.Groups[3].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                            IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                          foreach (var p in vertexList)                          {                              int number = p.Item2;                              ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                              if (vi == null)                              {                                  vi = new ExecutedVertexInstance(this' number' version' p.Item1' guid' lineTimeStamp);                                  this.jobVertices.Add(vi);                              }                          }                      }                  }              }              else if (line.StartsWith("Creating process"))              {                  Match m = processCreatingRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Creating process for vertex (\d+) \((.*)\\) v.(\d+) GUID \{?([-A-F0-9]+)\}? machine (\w+)                      int number = Int32.Parse(m.Groups[1].Value);                      //string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value;                         ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          this.jobVertices.Remap(vi' guid);                      }                  }              }              else if (line.StartsWith("Process was revoked"))              {                  Match m = revokedRegex.Match(line);                  if (m.Success)                  {                      string oldGuid = m.Groups[1].Value;                      ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(oldGuid);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Revoked);                          string newGuid = m.Groups[2].Value;                          this.jobVertices.Remap(vi' newGuid);                      }                      else                      {                          Trace.TraceInformation("Could not find revoked vertex with guid " + oldGuid);                      }                  }              }              else if (line.StartsWith("---HiPriTime"))              {                  // Scope-specific line which we use to get the i/o information                  // ---HiPriTime D7D51A1F-6693-4378-95FD-FC778A67C632'F52CA694-0202-411E-85E9-0C883E770A0E'SV4_Extract_Split[0]'Completed'ch1sch010331112'2011-05-03 15:26:01.681 PDT'2011-05-03 15:26:01.696 PDT'2011-05-03 15:26:02.118 PDT'2011-05-03 15:26:04.286 PDT'2011-05-03 15:26:07.656 PDT'2011-05-03 15:26:01.696 PDT'97390825'1498630                  string info = line.Substring(13);                  string[] parts = info.Split(''');                  if (parts.Length >= 13)                  {                      long read = long.Parse(parts[11]);                      long written = long.Parse(parts[12]);                      string guid = parts[1];                        ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(guid);                      if (vi != null)                      {                          vi.DataRead = read;                          vi.DataWritten = written;                          this.TotalDataRead += read;                      }                  }              }              else if (line.Contains("Io information"))              {                  // HPC-specific line                  Match m = ioRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.DataRead = long.Parse(m.Groups[4].Value);                          vi.DataWritten = long.Parse(m.Groups[5].Value);                          this.TotalDataRead += vi.DataRead;                      }                  }              }              else if (line.Contains("Process started"))              {                  //those vertices which are being canceled may not be here                  Match m = vertexStartRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        string version = m.Groups[3].Value;                      string guid = m.Groups[4].Value;                      string pid = this.ClusterConfiguration.ExtractPidFromGuid(guid' this.Summary);                      DryadProcessIdentifier identifier = new DryadProcessIdentifier(pid);                      string machine = m.Groups[5].Value;                        // Process started for vertex 4 (Super__0[0]) v.0 GUID {9DDD0B00-C93F-46D2-9073-1CFD27829300} machine sherwood-255                      // Process started for vertices 23 (Merge__29) 24 (Apply__33) v.0 GUID {E945DC5D-9AF6-4732-8770-2A6BF7FA3041} machine sherwood-237                        string vertices = m.Groups[2].Value;                      // This is a list of (number \(name\))* pairs                      // we will assume that the parantheses are matched' or we can't do much                        bool onevertex;                      if (m.Groups[1].Value == "ex")  // one vertEX                          onevertex = true;                      else if (m.Groups[1].Value == "ices")                          onevertex = false;                      else                          throw new DryadException("Can't figure out if one or many vertices");                        IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                        int vertexcount = 0;                      int iversion = int.Parse(version);                        if (lineTimeStamp > this.lastTimestampSeen)                          this.lastTimestampSeen = lineTimeStamp;                      foreach (var p in vertexList)                      {                          int number = p.Item2;                          ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' iversion);                          //new ExecutedVertexInstance(this' number' version' name' identifier' machine' this.lastTimestampSeen);                          if (vi == null)                              Trace.TraceInformation("Could not find information for vertex {0}.{1}"' number' version);                          else                              vi.SetStartInformation(this' machine' this.lastTimestampSeen' identifier' guid);                          vertexcount++;                      }                        if (vertexcount > 1 && onevertex)                          throw new DryadException("Expected one vertex' found " + vertexcount);                  }                  else                  {                      Trace.TraceInformation("Unexpected parsing error on line {0}"' line);                  }              }              else if (line.Contains("Abandoning"))              {                  Match m = vertexAbandonedRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                          vi.SetState(ExecutedVertexInstance.VertexState.Abandoned);                  }              }              else if (line.Contains("Setting"))              {                  Match m = setToFailedlRegex.Match(line);                  if (m.Success)                  {                      // Setting vertex 1461.0 (Merge__13[258]) to failed                      // Setting vertex (\d+)\.(\d+) \((.+)\) to failed(.*)                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          //vi.ErrorString = m.Groups[4].Value;                      }                  }              }              else if (line.Contains("Process was terminated"))              {                  // terminatedRegex = new Regex(@"Process was terminated Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) status (.*)"'                  // Process was terminated Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 status The operation succeeded                  Match m = terminatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          // sometimes successful processes are terminated' because they don't report quickly enough being done                          if (vi.State != ExecutedVertexInstance.VertexState.Successful)                          {                              vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          }                          vi.ErrorString = m.Groups[6].Value;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                  }              }              else if (line.Contains("Timing Information Graph Start Time"))              {                  // Cosmos-specific line                  // Timing Information Graph Start Time 128654556581866096                  Match m = Regex.Match(line' @"Timing Information Graph Start Time (\d+)");                  DateTime createTime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                  this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                  this.lastTimestampSeen = createTime;              }              else if (line.StartsWith("Start time: "))              {                  // HPC L2H specific line                  // Start time: 04/05/2011 17:25:42.223                  DateTime createTime;                  bool parse = DateTime.TryParse(line.Substring("Start time: ".Length)' out createTime);                    if (parse)                  {                      this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                      this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                      this.lastTimestampSeen = createTime;                  }              }              else if (line.Contains("JM Finish time:"))              {                  // Cosmos-specific line                  // JM Finish time: 129140295499437263 2010-03-25T22:25:49.943726Z                  Match m = Regex.Match(line' @"JM Finish time: (\d+)");                  DateTime time = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.lastTimestampSeen = time;                  this.ManagerVertex.End = time;              }              else if (line.StartsWith("Stop time "))              {                  // HPC L2H specific line                  // Stop time (Exit code = 2148734208): 04/05/2011 17:25:46.614                  Regex regex = new Regex(@"Stop time \(Exit code = (.*)\): (.*)");                  Match m = regex.Match(line);                  if (m.Success)                  {                      this.ManagerStdoutIncomplete = false;                        DateTime time;                      bool parse = DateTime.TryParse(m.Groups[2].Value' out time);                      if (parse)                      {                          this.lastTimestampSeen = time;                          this.ManagerVertex.End = time;                      }                        this.ErrorCode = m.Groups[1].Value;                      if (this.ErrorCode == "0")                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                      }                      else                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                      }                  }              }              else if (line.Contains("Timing Information"))              {                  // Timing Information 4 1 Super__0[0] 128654556603428182 0.0000 0.0000 0.0000 0.0000 0.2500                   Match m = timingInfoRegex.Match(line);                  if (m.Success)                  {                      int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      DateTime createtime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[4].Value);                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi == null)                          return; // we do not keep track of vertices with duplicate scheduling' so these won't show up here                        if (vi.State == ExecutedVertexInstance.VertexState.Started)                      {                          Console.WriteLine("Timing information while vertex is still running " + vi);                          //throw new ClusterException("Timing information for vertex still running: " + vi);                      }                      DateTime last = vi.SetTiming(createtime' m.Groups[5].Value' m.Groups[6].Value' m.Groups[7].Value' m.Groups[8].Value' m.Groups[9].Value);                      if (last > this.lastTimestampSeen)                          this.lastTimestampSeen = last;                      this.ManagerVertex.MarkVertexWasRunning(last);                        try                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              this.UsefulCPUTime += vi.RunningTime;                          else if (vi.RunningTime > TimeSpan.Zero)                              this.WastedCPUTime += vi.RunningTime;                      }                      catch (Exception ex)                      {                          Console.WriteLine("Time value exception: " + ex.Message);                      }                  }                  else                      throw new DryadException("Unmatched timing information line " + line);              }              else if (line.Contains("Process has failed"))              {                  // Process has failed Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 Exitcode 0 status The operation succeeded                  // failedRegex = new Regex(@"Process has failed Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) Exitcode (.*)"'                  Match m = failedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string exitcode = m.Groups[6].Value;                      //string status = m.Groups[7].Value;                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          vi.ExitCode = exitcode;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                          //vi.ErrorString = status;                      }                  }              }              else if (line.Contains("ABORTING:"))              {                  this.AbortingMsg = line.Substring(10);                  this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);              }              else if (line.Contains("Accurate read data"))              {                  Match m = datareadRegex.Match(line);                  if (m.Success)                  {                      this.TotalDataRead = long.Parse(m.Groups[1].Value);                      this.LocalReadData = long.Parse(m.Groups[2].Value);                      this.IntraPodDataRead = long.Parse(m.Groups[3].Value);                      this.CrossPodDataRead = long.Parse(m.Groups[4].Value);                  }              }              else if (line.Contains("<ErrorString>"))              {                  //some errors contains "Error returned from managed runtime invocation"                  //which shows the error is from application code                  Match m = Regex.Match(line' @"\<ErrorString\>(.*)\</ErrorString\>");                  if (m.Success && lastFailedVertex != null)                  {                      lastFailedVertex.AddErrorString(System.Web.HttpUtility.HtmlDecode(m.Groups[1].Value));                  }              }              else if (line.Contains("Canceling"))              {                  // Canceling vertex 1461.0 (Merge__13[258]) due to dependent failure                  Match m = cancelRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string name = m.Groups[3].Value;                        ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              vi.SetState(ExecutedVertexInstance.VertexState.Invalidated);                          else                               vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                      else                      {                          // TODO: this should not be needed' but this is a workaround for a bug in the HPC L2H software                          vi = new ExecutedVertexInstance(this' vertex' version' name' ""' lineTimeStamp);                          vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          this.jobVertices.Add(vi);                      }                      // Process wasn't even started' so there is nothing to cancel                  }              }              else if (line.Contains("Application"))              {                  //the job ends successfully                  Regex endSuccessRegex = new Regex(@"Application completed successfully.");                  //the job failed                  Regex endFailRegex = new Regex(@"Application failed with error code (.*)");                    Match m1 = endFailRegex.Match(line);                    if (m1.Success)                  {                      this.ErrorCode = m1.Groups[1].Value;                      this.ManagerStdoutIncomplete = false;                      this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                  }                  else                  {                      Match m2 = endSuccessRegex.Match(line);                      if (m2.Success)                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                          this.ManagerStdoutIncomplete = false;                      }                  }              }              else if (line.StartsWith("Input"))              {                  // Input vertex %u (%s) had %u read failure%s\n                  Match m = inputFailureRegex.Match(line);                  if (m.Success)                  {                      this.AbortingMsg = line;                  }              }              else if (line.Contains("Vertex"))              {                  // terminationRegex = new Regex(@"Vertex (\d+)\.(\d+) \((.+)\) machine (\S+) guid \{?([-0-9A-F]+)\}? status (.*)"                  Match m = terminationRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(vertex' version);                      if (vi == null)                      {                          Trace.TraceInformation("Could not find vertex {0}.{1} line {2}"' vertex' version' line);                      }                      else                      {                          bool failed = vi.SetTermination(m.Groups[6].Value' lineTimeStamp);                          if (failed)                              this.lastFailedVertex = vi;                      }                  }              }
Magic Number,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseStdoutLine,The following statement contains a magic number: if (line.Contains("Created process execution record"))              {                  Match m = vertexCreatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Created process execution record for vertex (\d+) \((.*)\) v.(\d+) GUID \{?([-A-F0-9]+)\}?                      int number = Int32.Parse(m.Groups[1].Value);                      string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                        // the vertex may be already there' sometimes numbers are reused...                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi == null)                      {                          vi = new ExecutedVertexInstance(this' number' version' name' guid' lineTimeStamp);                          this.jobVertices.Add(vi);                      }                  }                  else                  {                      m = verticesCreatedRegex.Match(line);                      if (m.Success)                      {                          lineTimeStamp = ParseLineTimestamp(line);                            // Created process execution record for vertices (.*) v.(\d+) GUID \{?([-A-F0-9]+)\}?                          // Created process execution record for vertices 192 (Merge__41[0]) 223 (Union__45[0]) v.0 GUID {0297A91C-FFEA-42EA-94AF-CD0163A04D45}                          int version = Int32.Parse(m.Groups[2].Value);                          string vertices = m.Groups[1].Value;                          string guid = m.Groups[3].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                            IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                          foreach (var p in vertexList)                          {                              int number = p.Item2;                              ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                              if (vi == null)                              {                                  vi = new ExecutedVertexInstance(this' number' version' p.Item1' guid' lineTimeStamp);                                  this.jobVertices.Add(vi);                              }                          }                      }                  }              }              else if (line.StartsWith("Creating process"))              {                  Match m = processCreatingRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Creating process for vertex (\d+) \((.*)\\) v.(\d+) GUID \{?([-A-F0-9]+)\}? machine (\w+)                      int number = Int32.Parse(m.Groups[1].Value);                      //string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value;                         ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          this.jobVertices.Remap(vi' guid);                      }                  }              }              else if (line.StartsWith("Process was revoked"))              {                  Match m = revokedRegex.Match(line);                  if (m.Success)                  {                      string oldGuid = m.Groups[1].Value;                      ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(oldGuid);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Revoked);                          string newGuid = m.Groups[2].Value;                          this.jobVertices.Remap(vi' newGuid);                      }                      else                      {                          Trace.TraceInformation("Could not find revoked vertex with guid " + oldGuid);                      }                  }              }              else if (line.StartsWith("---HiPriTime"))              {                  // Scope-specific line which we use to get the i/o information                  // ---HiPriTime D7D51A1F-6693-4378-95FD-FC778A67C632'F52CA694-0202-411E-85E9-0C883E770A0E'SV4_Extract_Split[0]'Completed'ch1sch010331112'2011-05-03 15:26:01.681 PDT'2011-05-03 15:26:01.696 PDT'2011-05-03 15:26:02.118 PDT'2011-05-03 15:26:04.286 PDT'2011-05-03 15:26:07.656 PDT'2011-05-03 15:26:01.696 PDT'97390825'1498630                  string info = line.Substring(13);                  string[] parts = info.Split(''');                  if (parts.Length >= 13)                  {                      long read = long.Parse(parts[11]);                      long written = long.Parse(parts[12]);                      string guid = parts[1];                        ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(guid);                      if (vi != null)                      {                          vi.DataRead = read;                          vi.DataWritten = written;                          this.TotalDataRead += read;                      }                  }              }              else if (line.Contains("Io information"))              {                  // HPC-specific line                  Match m = ioRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.DataRead = long.Parse(m.Groups[4].Value);                          vi.DataWritten = long.Parse(m.Groups[5].Value);                          this.TotalDataRead += vi.DataRead;                      }                  }              }              else if (line.Contains("Process started"))              {                  //those vertices which are being canceled may not be here                  Match m = vertexStartRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        string version = m.Groups[3].Value;                      string guid = m.Groups[4].Value;                      string pid = this.ClusterConfiguration.ExtractPidFromGuid(guid' this.Summary);                      DryadProcessIdentifier identifier = new DryadProcessIdentifier(pid);                      string machine = m.Groups[5].Value;                        // Process started for vertex 4 (Super__0[0]) v.0 GUID {9DDD0B00-C93F-46D2-9073-1CFD27829300} machine sherwood-255                      // Process started for vertices 23 (Merge__29) 24 (Apply__33) v.0 GUID {E945DC5D-9AF6-4732-8770-2A6BF7FA3041} machine sherwood-237                        string vertices = m.Groups[2].Value;                      // This is a list of (number \(name\))* pairs                      // we will assume that the parantheses are matched' or we can't do much                        bool onevertex;                      if (m.Groups[1].Value == "ex")  // one vertEX                          onevertex = true;                      else if (m.Groups[1].Value == "ices")                          onevertex = false;                      else                          throw new DryadException("Can't figure out if one or many vertices");                        IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                        int vertexcount = 0;                      int iversion = int.Parse(version);                        if (lineTimeStamp > this.lastTimestampSeen)                          this.lastTimestampSeen = lineTimeStamp;                      foreach (var p in vertexList)                      {                          int number = p.Item2;                          ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' iversion);                          //new ExecutedVertexInstance(this' number' version' name' identifier' machine' this.lastTimestampSeen);                          if (vi == null)                              Trace.TraceInformation("Could not find information for vertex {0}.{1}"' number' version);                          else                              vi.SetStartInformation(this' machine' this.lastTimestampSeen' identifier' guid);                          vertexcount++;                      }                        if (vertexcount > 1 && onevertex)                          throw new DryadException("Expected one vertex' found " + vertexcount);                  }                  else                  {                      Trace.TraceInformation("Unexpected parsing error on line {0}"' line);                  }              }              else if (line.Contains("Abandoning"))              {                  Match m = vertexAbandonedRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                          vi.SetState(ExecutedVertexInstance.VertexState.Abandoned);                  }              }              else if (line.Contains("Setting"))              {                  Match m = setToFailedlRegex.Match(line);                  if (m.Success)                  {                      // Setting vertex 1461.0 (Merge__13[258]) to failed                      // Setting vertex (\d+)\.(\d+) \((.+)\) to failed(.*)                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          //vi.ErrorString = m.Groups[4].Value;                      }                  }              }              else if (line.Contains("Process was terminated"))              {                  // terminatedRegex = new Regex(@"Process was terminated Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) status (.*)"'                  // Process was terminated Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 status The operation succeeded                  Match m = terminatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          // sometimes successful processes are terminated' because they don't report quickly enough being done                          if (vi.State != ExecutedVertexInstance.VertexState.Successful)                          {                              vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          }                          vi.ErrorString = m.Groups[6].Value;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                  }              }              else if (line.Contains("Timing Information Graph Start Time"))              {                  // Cosmos-specific line                  // Timing Information Graph Start Time 128654556581866096                  Match m = Regex.Match(line' @"Timing Information Graph Start Time (\d+)");                  DateTime createTime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                  this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                  this.lastTimestampSeen = createTime;              }              else if (line.StartsWith("Start time: "))              {                  // HPC L2H specific line                  // Start time: 04/05/2011 17:25:42.223                  DateTime createTime;                  bool parse = DateTime.TryParse(line.Substring("Start time: ".Length)' out createTime);                    if (parse)                  {                      this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                      this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                      this.lastTimestampSeen = createTime;                  }              }              else if (line.Contains("JM Finish time:"))              {                  // Cosmos-specific line                  // JM Finish time: 129140295499437263 2010-03-25T22:25:49.943726Z                  Match m = Regex.Match(line' @"JM Finish time: (\d+)");                  DateTime time = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.lastTimestampSeen = time;                  this.ManagerVertex.End = time;              }              else if (line.StartsWith("Stop time "))              {                  // HPC L2H specific line                  // Stop time (Exit code = 2148734208): 04/05/2011 17:25:46.614                  Regex regex = new Regex(@"Stop time \(Exit code = (.*)\): (.*)");                  Match m = regex.Match(line);                  if (m.Success)                  {                      this.ManagerStdoutIncomplete = false;                        DateTime time;                      bool parse = DateTime.TryParse(m.Groups[2].Value' out time);                      if (parse)                      {                          this.lastTimestampSeen = time;                          this.ManagerVertex.End = time;                      }                        this.ErrorCode = m.Groups[1].Value;                      if (this.ErrorCode == "0")                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                      }                      else                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                      }                  }              }              else if (line.Contains("Timing Information"))              {                  // Timing Information 4 1 Super__0[0] 128654556603428182 0.0000 0.0000 0.0000 0.0000 0.2500                   Match m = timingInfoRegex.Match(line);                  if (m.Success)                  {                      int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      DateTime createtime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[4].Value);                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi == null)                          return; // we do not keep track of vertices with duplicate scheduling' so these won't show up here                        if (vi.State == ExecutedVertexInstance.VertexState.Started)                      {                          Console.WriteLine("Timing information while vertex is still running " + vi);                          //throw new ClusterException("Timing information for vertex still running: " + vi);                      }                      DateTime last = vi.SetTiming(createtime' m.Groups[5].Value' m.Groups[6].Value' m.Groups[7].Value' m.Groups[8].Value' m.Groups[9].Value);                      if (last > this.lastTimestampSeen)                          this.lastTimestampSeen = last;                      this.ManagerVertex.MarkVertexWasRunning(last);                        try                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              this.UsefulCPUTime += vi.RunningTime;                          else if (vi.RunningTime > TimeSpan.Zero)                              this.WastedCPUTime += vi.RunningTime;                      }                      catch (Exception ex)                      {                          Console.WriteLine("Time value exception: " + ex.Message);                      }                  }                  else                      throw new DryadException("Unmatched timing information line " + line);              }              else if (line.Contains("Process has failed"))              {                  // Process has failed Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 Exitcode 0 status The operation succeeded                  // failedRegex = new Regex(@"Process has failed Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) Exitcode (.*)"'                  Match m = failedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string exitcode = m.Groups[6].Value;                      //string status = m.Groups[7].Value;                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          vi.ExitCode = exitcode;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                          //vi.ErrorString = status;                      }                  }              }              else if (line.Contains("ABORTING:"))              {                  this.AbortingMsg = line.Substring(10);                  this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);              }              else if (line.Contains("Accurate read data"))              {                  Match m = datareadRegex.Match(line);                  if (m.Success)                  {                      this.TotalDataRead = long.Parse(m.Groups[1].Value);                      this.LocalReadData = long.Parse(m.Groups[2].Value);                      this.IntraPodDataRead = long.Parse(m.Groups[3].Value);                      this.CrossPodDataRead = long.Parse(m.Groups[4].Value);                  }              }              else if (line.Contains("<ErrorString>"))              {                  //some errors contains "Error returned from managed runtime invocation"                  //which shows the error is from application code                  Match m = Regex.Match(line' @"\<ErrorString\>(.*)\</ErrorString\>");                  if (m.Success && lastFailedVertex != null)                  {                      lastFailedVertex.AddErrorString(System.Web.HttpUtility.HtmlDecode(m.Groups[1].Value));                  }              }              else if (line.Contains("Canceling"))              {                  // Canceling vertex 1461.0 (Merge__13[258]) due to dependent failure                  Match m = cancelRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string name = m.Groups[3].Value;                        ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              vi.SetState(ExecutedVertexInstance.VertexState.Invalidated);                          else                               vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                      else                      {                          // TODO: this should not be needed' but this is a workaround for a bug in the HPC L2H software                          vi = new ExecutedVertexInstance(this' vertex' version' name' ""' lineTimeStamp);                          vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          this.jobVertices.Add(vi);                      }                      // Process wasn't even started' so there is nothing to cancel                  }              }              else if (line.Contains("Application"))              {                  //the job ends successfully                  Regex endSuccessRegex = new Regex(@"Application completed successfully.");                  //the job failed                  Regex endFailRegex = new Regex(@"Application failed with error code (.*)");                    Match m1 = endFailRegex.Match(line);                    if (m1.Success)                  {                      this.ErrorCode = m1.Groups[1].Value;                      this.ManagerStdoutIncomplete = false;                      this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                  }                  else                  {                      Match m2 = endSuccessRegex.Match(line);                      if (m2.Success)                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                          this.ManagerStdoutIncomplete = false;                      }                  }              }              else if (line.StartsWith("Input"))              {                  // Input vertex %u (%s) had %u read failure%s\n                  Match m = inputFailureRegex.Match(line);                  if (m.Success)                  {                      this.AbortingMsg = line;                  }              }              else if (line.Contains("Vertex"))              {                  // terminationRegex = new Regex(@"Vertex (\d+)\.(\d+) \((.+)\) machine (\S+) guid \{?([-0-9A-F]+)\}? status (.*)"                  Match m = terminationRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(vertex' version);                      if (vi == null)                      {                          Trace.TraceInformation("Could not find vertex {0}.{1} line {2}"' vertex' version' line);                      }                      else                      {                          bool failed = vi.SetTermination(m.Groups[6].Value' lineTimeStamp);                          if (failed)                              this.lastFailedVertex = vi;                      }                  }              }
Magic Number,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseStdoutLine,The following statement contains a magic number: if (line.Contains("Created process execution record"))              {                  Match m = vertexCreatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Created process execution record for vertex (\d+) \((.*)\) v.(\d+) GUID \{?([-A-F0-9]+)\}?                      int number = Int32.Parse(m.Groups[1].Value);                      string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                        // the vertex may be already there' sometimes numbers are reused...                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi == null)                      {                          vi = new ExecutedVertexInstance(this' number' version' name' guid' lineTimeStamp);                          this.jobVertices.Add(vi);                      }                  }                  else                  {                      m = verticesCreatedRegex.Match(line);                      if (m.Success)                      {                          lineTimeStamp = ParseLineTimestamp(line);                            // Created process execution record for vertices (.*) v.(\d+) GUID \{?([-A-F0-9]+)\}?                          // Created process execution record for vertices 192 (Merge__41[0]) 223 (Union__45[0]) v.0 GUID {0297A91C-FFEA-42EA-94AF-CD0163A04D45}                          int version = Int32.Parse(m.Groups[2].Value);                          string vertices = m.Groups[1].Value;                          string guid = m.Groups[3].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                            IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                          foreach (var p in vertexList)                          {                              int number = p.Item2;                              ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                              if (vi == null)                              {                                  vi = new ExecutedVertexInstance(this' number' version' p.Item1' guid' lineTimeStamp);                                  this.jobVertices.Add(vi);                              }                          }                      }                  }              }              else if (line.StartsWith("Creating process"))              {                  Match m = processCreatingRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Creating process for vertex (\d+) \((.*)\\) v.(\d+) GUID \{?([-A-F0-9]+)\}? machine (\w+)                      int number = Int32.Parse(m.Groups[1].Value);                      //string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value;                         ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          this.jobVertices.Remap(vi' guid);                      }                  }              }              else if (line.StartsWith("Process was revoked"))              {                  Match m = revokedRegex.Match(line);                  if (m.Success)                  {                      string oldGuid = m.Groups[1].Value;                      ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(oldGuid);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Revoked);                          string newGuid = m.Groups[2].Value;                          this.jobVertices.Remap(vi' newGuid);                      }                      else                      {                          Trace.TraceInformation("Could not find revoked vertex with guid " + oldGuid);                      }                  }              }              else if (line.StartsWith("---HiPriTime"))              {                  // Scope-specific line which we use to get the i/o information                  // ---HiPriTime D7D51A1F-6693-4378-95FD-FC778A67C632'F52CA694-0202-411E-85E9-0C883E770A0E'SV4_Extract_Split[0]'Completed'ch1sch010331112'2011-05-03 15:26:01.681 PDT'2011-05-03 15:26:01.696 PDT'2011-05-03 15:26:02.118 PDT'2011-05-03 15:26:04.286 PDT'2011-05-03 15:26:07.656 PDT'2011-05-03 15:26:01.696 PDT'97390825'1498630                  string info = line.Substring(13);                  string[] parts = info.Split(''');                  if (parts.Length >= 13)                  {                      long read = long.Parse(parts[11]);                      long written = long.Parse(parts[12]);                      string guid = parts[1];                        ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(guid);                      if (vi != null)                      {                          vi.DataRead = read;                          vi.DataWritten = written;                          this.TotalDataRead += read;                      }                  }              }              else if (line.Contains("Io information"))              {                  // HPC-specific line                  Match m = ioRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.DataRead = long.Parse(m.Groups[4].Value);                          vi.DataWritten = long.Parse(m.Groups[5].Value);                          this.TotalDataRead += vi.DataRead;                      }                  }              }              else if (line.Contains("Process started"))              {                  //those vertices which are being canceled may not be here                  Match m = vertexStartRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        string version = m.Groups[3].Value;                      string guid = m.Groups[4].Value;                      string pid = this.ClusterConfiguration.ExtractPidFromGuid(guid' this.Summary);                      DryadProcessIdentifier identifier = new DryadProcessIdentifier(pid);                      string machine = m.Groups[5].Value;                        // Process started for vertex 4 (Super__0[0]) v.0 GUID {9DDD0B00-C93F-46D2-9073-1CFD27829300} machine sherwood-255                      // Process started for vertices 23 (Merge__29) 24 (Apply__33) v.0 GUID {E945DC5D-9AF6-4732-8770-2A6BF7FA3041} machine sherwood-237                        string vertices = m.Groups[2].Value;                      // This is a list of (number \(name\))* pairs                      // we will assume that the parantheses are matched' or we can't do much                        bool onevertex;                      if (m.Groups[1].Value == "ex")  // one vertEX                          onevertex = true;                      else if (m.Groups[1].Value == "ices")                          onevertex = false;                      else                          throw new DryadException("Can't figure out if one or many vertices");                        IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                        int vertexcount = 0;                      int iversion = int.Parse(version);                        if (lineTimeStamp > this.lastTimestampSeen)                          this.lastTimestampSeen = lineTimeStamp;                      foreach (var p in vertexList)                      {                          int number = p.Item2;                          ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' iversion);                          //new ExecutedVertexInstance(this' number' version' name' identifier' machine' this.lastTimestampSeen);                          if (vi == null)                              Trace.TraceInformation("Could not find information for vertex {0}.{1}"' number' version);                          else                              vi.SetStartInformation(this' machine' this.lastTimestampSeen' identifier' guid);                          vertexcount++;                      }                        if (vertexcount > 1 && onevertex)                          throw new DryadException("Expected one vertex' found " + vertexcount);                  }                  else                  {                      Trace.TraceInformation("Unexpected parsing error on line {0}"' line);                  }              }              else if (line.Contains("Abandoning"))              {                  Match m = vertexAbandonedRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                          vi.SetState(ExecutedVertexInstance.VertexState.Abandoned);                  }              }              else if (line.Contains("Setting"))              {                  Match m = setToFailedlRegex.Match(line);                  if (m.Success)                  {                      // Setting vertex 1461.0 (Merge__13[258]) to failed                      // Setting vertex (\d+)\.(\d+) \((.+)\) to failed(.*)                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          //vi.ErrorString = m.Groups[4].Value;                      }                  }              }              else if (line.Contains("Process was terminated"))              {                  // terminatedRegex = new Regex(@"Process was terminated Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) status (.*)"'                  // Process was terminated Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 status The operation succeeded                  Match m = terminatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          // sometimes successful processes are terminated' because they don't report quickly enough being done                          if (vi.State != ExecutedVertexInstance.VertexState.Successful)                          {                              vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          }                          vi.ErrorString = m.Groups[6].Value;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                  }              }              else if (line.Contains("Timing Information Graph Start Time"))              {                  // Cosmos-specific line                  // Timing Information Graph Start Time 128654556581866096                  Match m = Regex.Match(line' @"Timing Information Graph Start Time (\d+)");                  DateTime createTime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                  this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                  this.lastTimestampSeen = createTime;              }              else if (line.StartsWith("Start time: "))              {                  // HPC L2H specific line                  // Start time: 04/05/2011 17:25:42.223                  DateTime createTime;                  bool parse = DateTime.TryParse(line.Substring("Start time: ".Length)' out createTime);                    if (parse)                  {                      this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                      this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                      this.lastTimestampSeen = createTime;                  }              }              else if (line.Contains("JM Finish time:"))              {                  // Cosmos-specific line                  // JM Finish time: 129140295499437263 2010-03-25T22:25:49.943726Z                  Match m = Regex.Match(line' @"JM Finish time: (\d+)");                  DateTime time = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.lastTimestampSeen = time;                  this.ManagerVertex.End = time;              }              else if (line.StartsWith("Stop time "))              {                  // HPC L2H specific line                  // Stop time (Exit code = 2148734208): 04/05/2011 17:25:46.614                  Regex regex = new Regex(@"Stop time \(Exit code = (.*)\): (.*)");                  Match m = regex.Match(line);                  if (m.Success)                  {                      this.ManagerStdoutIncomplete = false;                        DateTime time;                      bool parse = DateTime.TryParse(m.Groups[2].Value' out time);                      if (parse)                      {                          this.lastTimestampSeen = time;                          this.ManagerVertex.End = time;                      }                        this.ErrorCode = m.Groups[1].Value;                      if (this.ErrorCode == "0")                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                      }                      else                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                      }                  }              }              else if (line.Contains("Timing Information"))              {                  // Timing Information 4 1 Super__0[0] 128654556603428182 0.0000 0.0000 0.0000 0.0000 0.2500                   Match m = timingInfoRegex.Match(line);                  if (m.Success)                  {                      int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      DateTime createtime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[4].Value);                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi == null)                          return; // we do not keep track of vertices with duplicate scheduling' so these won't show up here                        if (vi.State == ExecutedVertexInstance.VertexState.Started)                      {                          Console.WriteLine("Timing information while vertex is still running " + vi);                          //throw new ClusterException("Timing information for vertex still running: " + vi);                      }                      DateTime last = vi.SetTiming(createtime' m.Groups[5].Value' m.Groups[6].Value' m.Groups[7].Value' m.Groups[8].Value' m.Groups[9].Value);                      if (last > this.lastTimestampSeen)                          this.lastTimestampSeen = last;                      this.ManagerVertex.MarkVertexWasRunning(last);                        try                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              this.UsefulCPUTime += vi.RunningTime;                          else if (vi.RunningTime > TimeSpan.Zero)                              this.WastedCPUTime += vi.RunningTime;                      }                      catch (Exception ex)                      {                          Console.WriteLine("Time value exception: " + ex.Message);                      }                  }                  else                      throw new DryadException("Unmatched timing information line " + line);              }              else if (line.Contains("Process has failed"))              {                  // Process has failed Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 Exitcode 0 status The operation succeeded                  // failedRegex = new Regex(@"Process has failed Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) Exitcode (.*)"'                  Match m = failedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string exitcode = m.Groups[6].Value;                      //string status = m.Groups[7].Value;                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          vi.ExitCode = exitcode;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                          //vi.ErrorString = status;                      }                  }              }              else if (line.Contains("ABORTING:"))              {                  this.AbortingMsg = line.Substring(10);                  this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);              }              else if (line.Contains("Accurate read data"))              {                  Match m = datareadRegex.Match(line);                  if (m.Success)                  {                      this.TotalDataRead = long.Parse(m.Groups[1].Value);                      this.LocalReadData = long.Parse(m.Groups[2].Value);                      this.IntraPodDataRead = long.Parse(m.Groups[3].Value);                      this.CrossPodDataRead = long.Parse(m.Groups[4].Value);                  }              }              else if (line.Contains("<ErrorString>"))              {                  //some errors contains "Error returned from managed runtime invocation"                  //which shows the error is from application code                  Match m = Regex.Match(line' @"\<ErrorString\>(.*)\</ErrorString\>");                  if (m.Success && lastFailedVertex != null)                  {                      lastFailedVertex.AddErrorString(System.Web.HttpUtility.HtmlDecode(m.Groups[1].Value));                  }              }              else if (line.Contains("Canceling"))              {                  // Canceling vertex 1461.0 (Merge__13[258]) due to dependent failure                  Match m = cancelRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string name = m.Groups[3].Value;                        ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              vi.SetState(ExecutedVertexInstance.VertexState.Invalidated);                          else                               vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                      else                      {                          // TODO: this should not be needed' but this is a workaround for a bug in the HPC L2H software                          vi = new ExecutedVertexInstance(this' vertex' version' name' ""' lineTimeStamp);                          vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          this.jobVertices.Add(vi);                      }                      // Process wasn't even started' so there is nothing to cancel                  }              }              else if (line.Contains("Application"))              {                  //the job ends successfully                  Regex endSuccessRegex = new Regex(@"Application completed successfully.");                  //the job failed                  Regex endFailRegex = new Regex(@"Application failed with error code (.*)");                    Match m1 = endFailRegex.Match(line);                    if (m1.Success)                  {                      this.ErrorCode = m1.Groups[1].Value;                      this.ManagerStdoutIncomplete = false;                      this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                  }                  else                  {                      Match m2 = endSuccessRegex.Match(line);                      if (m2.Success)                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                          this.ManagerStdoutIncomplete = false;                      }                  }              }              else if (line.StartsWith("Input"))              {                  // Input vertex %u (%s) had %u read failure%s\n                  Match m = inputFailureRegex.Match(line);                  if (m.Success)                  {                      this.AbortingMsg = line;                  }              }              else if (line.Contains("Vertex"))              {                  // terminationRegex = new Regex(@"Vertex (\d+)\.(\d+) \((.+)\) machine (\S+) guid \{?([-0-9A-F]+)\}? status (.*)"                  Match m = terminationRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(vertex' version);                      if (vi == null)                      {                          Trace.TraceInformation("Could not find vertex {0}.{1} line {2}"' vertex' version' line);                      }                      else                      {                          bool failed = vi.SetTermination(m.Groups[6].Value' lineTimeStamp);                          if (failed)                              this.lastFailedVertex = vi;                      }                  }              }
Magic Number,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseStdoutLine,The following statement contains a magic number: if (line.Contains("Created process execution record"))              {                  Match m = vertexCreatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Created process execution record for vertex (\d+) \((.*)\) v.(\d+) GUID \{?([-A-F0-9]+)\}?                      int number = Int32.Parse(m.Groups[1].Value);                      string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                        // the vertex may be already there' sometimes numbers are reused...                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi == null)                      {                          vi = new ExecutedVertexInstance(this' number' version' name' guid' lineTimeStamp);                          this.jobVertices.Add(vi);                      }                  }                  else                  {                      m = verticesCreatedRegex.Match(line);                      if (m.Success)                      {                          lineTimeStamp = ParseLineTimestamp(line);                            // Created process execution record for vertices (.*) v.(\d+) GUID \{?([-A-F0-9]+)\}?                          // Created process execution record for vertices 192 (Merge__41[0]) 223 (Union__45[0]) v.0 GUID {0297A91C-FFEA-42EA-94AF-CD0163A04D45}                          int version = Int32.Parse(m.Groups[2].Value);                          string vertices = m.Groups[1].Value;                          string guid = m.Groups[3].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                            IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                          foreach (var p in vertexList)                          {                              int number = p.Item2;                              ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                              if (vi == null)                              {                                  vi = new ExecutedVertexInstance(this' number' version' p.Item1' guid' lineTimeStamp);                                  this.jobVertices.Add(vi);                              }                          }                      }                  }              }              else if (line.StartsWith("Creating process"))              {                  Match m = processCreatingRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Creating process for vertex (\d+) \((.*)\\) v.(\d+) GUID \{?([-A-F0-9]+)\}? machine (\w+)                      int number = Int32.Parse(m.Groups[1].Value);                      //string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value;                         ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          this.jobVertices.Remap(vi' guid);                      }                  }              }              else if (line.StartsWith("Process was revoked"))              {                  Match m = revokedRegex.Match(line);                  if (m.Success)                  {                      string oldGuid = m.Groups[1].Value;                      ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(oldGuid);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Revoked);                          string newGuid = m.Groups[2].Value;                          this.jobVertices.Remap(vi' newGuid);                      }                      else                      {                          Trace.TraceInformation("Could not find revoked vertex with guid " + oldGuid);                      }                  }              }              else if (line.StartsWith("---HiPriTime"))              {                  // Scope-specific line which we use to get the i/o information                  // ---HiPriTime D7D51A1F-6693-4378-95FD-FC778A67C632'F52CA694-0202-411E-85E9-0C883E770A0E'SV4_Extract_Split[0]'Completed'ch1sch010331112'2011-05-03 15:26:01.681 PDT'2011-05-03 15:26:01.696 PDT'2011-05-03 15:26:02.118 PDT'2011-05-03 15:26:04.286 PDT'2011-05-03 15:26:07.656 PDT'2011-05-03 15:26:01.696 PDT'97390825'1498630                  string info = line.Substring(13);                  string[] parts = info.Split(''');                  if (parts.Length >= 13)                  {                      long read = long.Parse(parts[11]);                      long written = long.Parse(parts[12]);                      string guid = parts[1];                        ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(guid);                      if (vi != null)                      {                          vi.DataRead = read;                          vi.DataWritten = written;                          this.TotalDataRead += read;                      }                  }              }              else if (line.Contains("Io information"))              {                  // HPC-specific line                  Match m = ioRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.DataRead = long.Parse(m.Groups[4].Value);                          vi.DataWritten = long.Parse(m.Groups[5].Value);                          this.TotalDataRead += vi.DataRead;                      }                  }              }              else if (line.Contains("Process started"))              {                  //those vertices which are being canceled may not be here                  Match m = vertexStartRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        string version = m.Groups[3].Value;                      string guid = m.Groups[4].Value;                      string pid = this.ClusterConfiguration.ExtractPidFromGuid(guid' this.Summary);                      DryadProcessIdentifier identifier = new DryadProcessIdentifier(pid);                      string machine = m.Groups[5].Value;                        // Process started for vertex 4 (Super__0[0]) v.0 GUID {9DDD0B00-C93F-46D2-9073-1CFD27829300} machine sherwood-255                      // Process started for vertices 23 (Merge__29) 24 (Apply__33) v.0 GUID {E945DC5D-9AF6-4732-8770-2A6BF7FA3041} machine sherwood-237                        string vertices = m.Groups[2].Value;                      // This is a list of (number \(name\))* pairs                      // we will assume that the parantheses are matched' or we can't do much                        bool onevertex;                      if (m.Groups[1].Value == "ex")  // one vertEX                          onevertex = true;                      else if (m.Groups[1].Value == "ices")                          onevertex = false;                      else                          throw new DryadException("Can't figure out if one or many vertices");                        IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                        int vertexcount = 0;                      int iversion = int.Parse(version);                        if (lineTimeStamp > this.lastTimestampSeen)                          this.lastTimestampSeen = lineTimeStamp;                      foreach (var p in vertexList)                      {                          int number = p.Item2;                          ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' iversion);                          //new ExecutedVertexInstance(this' number' version' name' identifier' machine' this.lastTimestampSeen);                          if (vi == null)                              Trace.TraceInformation("Could not find information for vertex {0}.{1}"' number' version);                          else                              vi.SetStartInformation(this' machine' this.lastTimestampSeen' identifier' guid);                          vertexcount++;                      }                        if (vertexcount > 1 && onevertex)                          throw new DryadException("Expected one vertex' found " + vertexcount);                  }                  else                  {                      Trace.TraceInformation("Unexpected parsing error on line {0}"' line);                  }              }              else if (line.Contains("Abandoning"))              {                  Match m = vertexAbandonedRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                          vi.SetState(ExecutedVertexInstance.VertexState.Abandoned);                  }              }              else if (line.Contains("Setting"))              {                  Match m = setToFailedlRegex.Match(line);                  if (m.Success)                  {                      // Setting vertex 1461.0 (Merge__13[258]) to failed                      // Setting vertex (\d+)\.(\d+) \((.+)\) to failed(.*)                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          //vi.ErrorString = m.Groups[4].Value;                      }                  }              }              else if (line.Contains("Process was terminated"))              {                  // terminatedRegex = new Regex(@"Process was terminated Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) status (.*)"'                  // Process was terminated Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 status The operation succeeded                  Match m = terminatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          // sometimes successful processes are terminated' because they don't report quickly enough being done                          if (vi.State != ExecutedVertexInstance.VertexState.Successful)                          {                              vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          }                          vi.ErrorString = m.Groups[6].Value;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                  }              }              else if (line.Contains("Timing Information Graph Start Time"))              {                  // Cosmos-specific line                  // Timing Information Graph Start Time 128654556581866096                  Match m = Regex.Match(line' @"Timing Information Graph Start Time (\d+)");                  DateTime createTime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                  this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                  this.lastTimestampSeen = createTime;              }              else if (line.StartsWith("Start time: "))              {                  // HPC L2H specific line                  // Start time: 04/05/2011 17:25:42.223                  DateTime createTime;                  bool parse = DateTime.TryParse(line.Substring("Start time: ".Length)' out createTime);                    if (parse)                  {                      this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                      this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                      this.lastTimestampSeen = createTime;                  }              }              else if (line.Contains("JM Finish time:"))              {                  // Cosmos-specific line                  // JM Finish time: 129140295499437263 2010-03-25T22:25:49.943726Z                  Match m = Regex.Match(line' @"JM Finish time: (\d+)");                  DateTime time = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.lastTimestampSeen = time;                  this.ManagerVertex.End = time;              }              else if (line.StartsWith("Stop time "))              {                  // HPC L2H specific line                  // Stop time (Exit code = 2148734208): 04/05/2011 17:25:46.614                  Regex regex = new Regex(@"Stop time \(Exit code = (.*)\): (.*)");                  Match m = regex.Match(line);                  if (m.Success)                  {                      this.ManagerStdoutIncomplete = false;                        DateTime time;                      bool parse = DateTime.TryParse(m.Groups[2].Value' out time);                      if (parse)                      {                          this.lastTimestampSeen = time;                          this.ManagerVertex.End = time;                      }                        this.ErrorCode = m.Groups[1].Value;                      if (this.ErrorCode == "0")                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                      }                      else                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                      }                  }              }              else if (line.Contains("Timing Information"))              {                  // Timing Information 4 1 Super__0[0] 128654556603428182 0.0000 0.0000 0.0000 0.0000 0.2500                   Match m = timingInfoRegex.Match(line);                  if (m.Success)                  {                      int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      DateTime createtime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[4].Value);                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi == null)                          return; // we do not keep track of vertices with duplicate scheduling' so these won't show up here                        if (vi.State == ExecutedVertexInstance.VertexState.Started)                      {                          Console.WriteLine("Timing information while vertex is still running " + vi);                          //throw new ClusterException("Timing information for vertex still running: " + vi);                      }                      DateTime last = vi.SetTiming(createtime' m.Groups[5].Value' m.Groups[6].Value' m.Groups[7].Value' m.Groups[8].Value' m.Groups[9].Value);                      if (last > this.lastTimestampSeen)                          this.lastTimestampSeen = last;                      this.ManagerVertex.MarkVertexWasRunning(last);                        try                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              this.UsefulCPUTime += vi.RunningTime;                          else if (vi.RunningTime > TimeSpan.Zero)                              this.WastedCPUTime += vi.RunningTime;                      }                      catch (Exception ex)                      {                          Console.WriteLine("Time value exception: " + ex.Message);                      }                  }                  else                      throw new DryadException("Unmatched timing information line " + line);              }              else if (line.Contains("Process has failed"))              {                  // Process has failed Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 Exitcode 0 status The operation succeeded                  // failedRegex = new Regex(@"Process has failed Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) Exitcode (.*)"'                  Match m = failedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string exitcode = m.Groups[6].Value;                      //string status = m.Groups[7].Value;                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          vi.ExitCode = exitcode;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                          //vi.ErrorString = status;                      }                  }              }              else if (line.Contains("ABORTING:"))              {                  this.AbortingMsg = line.Substring(10);                  this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);              }              else if (line.Contains("Accurate read data"))              {                  Match m = datareadRegex.Match(line);                  if (m.Success)                  {                      this.TotalDataRead = long.Parse(m.Groups[1].Value);                      this.LocalReadData = long.Parse(m.Groups[2].Value);                      this.IntraPodDataRead = long.Parse(m.Groups[3].Value);                      this.CrossPodDataRead = long.Parse(m.Groups[4].Value);                  }              }              else if (line.Contains("<ErrorString>"))              {                  //some errors contains "Error returned from managed runtime invocation"                  //which shows the error is from application code                  Match m = Regex.Match(line' @"\<ErrorString\>(.*)\</ErrorString\>");                  if (m.Success && lastFailedVertex != null)                  {                      lastFailedVertex.AddErrorString(System.Web.HttpUtility.HtmlDecode(m.Groups[1].Value));                  }              }              else if (line.Contains("Canceling"))              {                  // Canceling vertex 1461.0 (Merge__13[258]) due to dependent failure                  Match m = cancelRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string name = m.Groups[3].Value;                        ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              vi.SetState(ExecutedVertexInstance.VertexState.Invalidated);                          else                               vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                      else                      {                          // TODO: this should not be needed' but this is a workaround for a bug in the HPC L2H software                          vi = new ExecutedVertexInstance(this' vertex' version' name' ""' lineTimeStamp);                          vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          this.jobVertices.Add(vi);                      }                      // Process wasn't even started' so there is nothing to cancel                  }              }              else if (line.Contains("Application"))              {                  //the job ends successfully                  Regex endSuccessRegex = new Regex(@"Application completed successfully.");                  //the job failed                  Regex endFailRegex = new Regex(@"Application failed with error code (.*)");                    Match m1 = endFailRegex.Match(line);                    if (m1.Success)                  {                      this.ErrorCode = m1.Groups[1].Value;                      this.ManagerStdoutIncomplete = false;                      this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                  }                  else                  {                      Match m2 = endSuccessRegex.Match(line);                      if (m2.Success)                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                          this.ManagerStdoutIncomplete = false;                      }                  }              }              else if (line.StartsWith("Input"))              {                  // Input vertex %u (%s) had %u read failure%s\n                  Match m = inputFailureRegex.Match(line);                  if (m.Success)                  {                      this.AbortingMsg = line;                  }              }              else if (line.Contains("Vertex"))              {                  // terminationRegex = new Regex(@"Vertex (\d+)\.(\d+) \((.+)\) machine (\S+) guid \{?([-0-9A-F]+)\}? status (.*)"                  Match m = terminationRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(vertex' version);                      if (vi == null)                      {                          Trace.TraceInformation("Could not find vertex {0}.{1} line {2}"' vertex' version' line);                      }                      else                      {                          bool failed = vi.SetTermination(m.Groups[6].Value' lineTimeStamp);                          if (failed)                              this.lastFailedVertex = vi;                      }                  }              }
Magic Number,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseStdoutLine,The following statement contains a magic number: if (line.Contains("Created process execution record"))              {                  Match m = vertexCreatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Created process execution record for vertex (\d+) \((.*)\) v.(\d+) GUID \{?([-A-F0-9]+)\}?                      int number = Int32.Parse(m.Groups[1].Value);                      string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                        // the vertex may be already there' sometimes numbers are reused...                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi == null)                      {                          vi = new ExecutedVertexInstance(this' number' version' name' guid' lineTimeStamp);                          this.jobVertices.Add(vi);                      }                  }                  else                  {                      m = verticesCreatedRegex.Match(line);                      if (m.Success)                      {                          lineTimeStamp = ParseLineTimestamp(line);                            // Created process execution record for vertices (.*) v.(\d+) GUID \{?([-A-F0-9]+)\}?                          // Created process execution record for vertices 192 (Merge__41[0]) 223 (Union__45[0]) v.0 GUID {0297A91C-FFEA-42EA-94AF-CD0163A04D45}                          int version = Int32.Parse(m.Groups[2].Value);                          string vertices = m.Groups[1].Value;                          string guid = m.Groups[3].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                            IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                          foreach (var p in vertexList)                          {                              int number = p.Item2;                              ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                              if (vi == null)                              {                                  vi = new ExecutedVertexInstance(this' number' version' p.Item1' guid' lineTimeStamp);                                  this.jobVertices.Add(vi);                              }                          }                      }                  }              }              else if (line.StartsWith("Creating process"))              {                  Match m = processCreatingRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Creating process for vertex (\d+) \((.*)\\) v.(\d+) GUID \{?([-A-F0-9]+)\}? machine (\w+)                      int number = Int32.Parse(m.Groups[1].Value);                      //string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value;                         ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          this.jobVertices.Remap(vi' guid);                      }                  }              }              else if (line.StartsWith("Process was revoked"))              {                  Match m = revokedRegex.Match(line);                  if (m.Success)                  {                      string oldGuid = m.Groups[1].Value;                      ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(oldGuid);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Revoked);                          string newGuid = m.Groups[2].Value;                          this.jobVertices.Remap(vi' newGuid);                      }                      else                      {                          Trace.TraceInformation("Could not find revoked vertex with guid " + oldGuid);                      }                  }              }              else if (line.StartsWith("---HiPriTime"))              {                  // Scope-specific line which we use to get the i/o information                  // ---HiPriTime D7D51A1F-6693-4378-95FD-FC778A67C632'F52CA694-0202-411E-85E9-0C883E770A0E'SV4_Extract_Split[0]'Completed'ch1sch010331112'2011-05-03 15:26:01.681 PDT'2011-05-03 15:26:01.696 PDT'2011-05-03 15:26:02.118 PDT'2011-05-03 15:26:04.286 PDT'2011-05-03 15:26:07.656 PDT'2011-05-03 15:26:01.696 PDT'97390825'1498630                  string info = line.Substring(13);                  string[] parts = info.Split(''');                  if (parts.Length >= 13)                  {                      long read = long.Parse(parts[11]);                      long written = long.Parse(parts[12]);                      string guid = parts[1];                        ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(guid);                      if (vi != null)                      {                          vi.DataRead = read;                          vi.DataWritten = written;                          this.TotalDataRead += read;                      }                  }              }              else if (line.Contains("Io information"))              {                  // HPC-specific line                  Match m = ioRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.DataRead = long.Parse(m.Groups[4].Value);                          vi.DataWritten = long.Parse(m.Groups[5].Value);                          this.TotalDataRead += vi.DataRead;                      }                  }              }              else if (line.Contains("Process started"))              {                  //those vertices which are being canceled may not be here                  Match m = vertexStartRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        string version = m.Groups[3].Value;                      string guid = m.Groups[4].Value;                      string pid = this.ClusterConfiguration.ExtractPidFromGuid(guid' this.Summary);                      DryadProcessIdentifier identifier = new DryadProcessIdentifier(pid);                      string machine = m.Groups[5].Value;                        // Process started for vertex 4 (Super__0[0]) v.0 GUID {9DDD0B00-C93F-46D2-9073-1CFD27829300} machine sherwood-255                      // Process started for vertices 23 (Merge__29) 24 (Apply__33) v.0 GUID {E945DC5D-9AF6-4732-8770-2A6BF7FA3041} machine sherwood-237                        string vertices = m.Groups[2].Value;                      // This is a list of (number \(name\))* pairs                      // we will assume that the parantheses are matched' or we can't do much                        bool onevertex;                      if (m.Groups[1].Value == "ex")  // one vertEX                          onevertex = true;                      else if (m.Groups[1].Value == "ices")                          onevertex = false;                      else                          throw new DryadException("Can't figure out if one or many vertices");                        IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                        int vertexcount = 0;                      int iversion = int.Parse(version);                        if (lineTimeStamp > this.lastTimestampSeen)                          this.lastTimestampSeen = lineTimeStamp;                      foreach (var p in vertexList)                      {                          int number = p.Item2;                          ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' iversion);                          //new ExecutedVertexInstance(this' number' version' name' identifier' machine' this.lastTimestampSeen);                          if (vi == null)                              Trace.TraceInformation("Could not find information for vertex {0}.{1}"' number' version);                          else                              vi.SetStartInformation(this' machine' this.lastTimestampSeen' identifier' guid);                          vertexcount++;                      }                        if (vertexcount > 1 && onevertex)                          throw new DryadException("Expected one vertex' found " + vertexcount);                  }                  else                  {                      Trace.TraceInformation("Unexpected parsing error on line {0}"' line);                  }              }              else if (line.Contains("Abandoning"))              {                  Match m = vertexAbandonedRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                          vi.SetState(ExecutedVertexInstance.VertexState.Abandoned);                  }              }              else if (line.Contains("Setting"))              {                  Match m = setToFailedlRegex.Match(line);                  if (m.Success)                  {                      // Setting vertex 1461.0 (Merge__13[258]) to failed                      // Setting vertex (\d+)\.(\d+) \((.+)\) to failed(.*)                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          //vi.ErrorString = m.Groups[4].Value;                      }                  }              }              else if (line.Contains("Process was terminated"))              {                  // terminatedRegex = new Regex(@"Process was terminated Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) status (.*)"'                  // Process was terminated Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 status The operation succeeded                  Match m = terminatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          // sometimes successful processes are terminated' because they don't report quickly enough being done                          if (vi.State != ExecutedVertexInstance.VertexState.Successful)                          {                              vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          }                          vi.ErrorString = m.Groups[6].Value;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                  }              }              else if (line.Contains("Timing Information Graph Start Time"))              {                  // Cosmos-specific line                  // Timing Information Graph Start Time 128654556581866096                  Match m = Regex.Match(line' @"Timing Information Graph Start Time (\d+)");                  DateTime createTime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                  this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                  this.lastTimestampSeen = createTime;              }              else if (line.StartsWith("Start time: "))              {                  // HPC L2H specific line                  // Start time: 04/05/2011 17:25:42.223                  DateTime createTime;                  bool parse = DateTime.TryParse(line.Substring("Start time: ".Length)' out createTime);                    if (parse)                  {                      this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                      this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                      this.lastTimestampSeen = createTime;                  }              }              else if (line.Contains("JM Finish time:"))              {                  // Cosmos-specific line                  // JM Finish time: 129140295499437263 2010-03-25T22:25:49.943726Z                  Match m = Regex.Match(line' @"JM Finish time: (\d+)");                  DateTime time = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.lastTimestampSeen = time;                  this.ManagerVertex.End = time;              }              else if (line.StartsWith("Stop time "))              {                  // HPC L2H specific line                  // Stop time (Exit code = 2148734208): 04/05/2011 17:25:46.614                  Regex regex = new Regex(@"Stop time \(Exit code = (.*)\): (.*)");                  Match m = regex.Match(line);                  if (m.Success)                  {                      this.ManagerStdoutIncomplete = false;                        DateTime time;                      bool parse = DateTime.TryParse(m.Groups[2].Value' out time);                      if (parse)                      {                          this.lastTimestampSeen = time;                          this.ManagerVertex.End = time;                      }                        this.ErrorCode = m.Groups[1].Value;                      if (this.ErrorCode == "0")                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                      }                      else                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                      }                  }              }              else if (line.Contains("Timing Information"))              {                  // Timing Information 4 1 Super__0[0] 128654556603428182 0.0000 0.0000 0.0000 0.0000 0.2500                   Match m = timingInfoRegex.Match(line);                  if (m.Success)                  {                      int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      DateTime createtime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[4].Value);                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi == null)                          return; // we do not keep track of vertices with duplicate scheduling' so these won't show up here                        if (vi.State == ExecutedVertexInstance.VertexState.Started)                      {                          Console.WriteLine("Timing information while vertex is still running " + vi);                          //throw new ClusterException("Timing information for vertex still running: " + vi);                      }                      DateTime last = vi.SetTiming(createtime' m.Groups[5].Value' m.Groups[6].Value' m.Groups[7].Value' m.Groups[8].Value' m.Groups[9].Value);                      if (last > this.lastTimestampSeen)                          this.lastTimestampSeen = last;                      this.ManagerVertex.MarkVertexWasRunning(last);                        try                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              this.UsefulCPUTime += vi.RunningTime;                          else if (vi.RunningTime > TimeSpan.Zero)                              this.WastedCPUTime += vi.RunningTime;                      }                      catch (Exception ex)                      {                          Console.WriteLine("Time value exception: " + ex.Message);                      }                  }                  else                      throw new DryadException("Unmatched timing information line " + line);              }              else if (line.Contains("Process has failed"))              {                  // Process has failed Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 Exitcode 0 status The operation succeeded                  // failedRegex = new Regex(@"Process has failed Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) Exitcode (.*)"'                  Match m = failedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string exitcode = m.Groups[6].Value;                      //string status = m.Groups[7].Value;                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          vi.ExitCode = exitcode;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                          //vi.ErrorString = status;                      }                  }              }              else if (line.Contains("ABORTING:"))              {                  this.AbortingMsg = line.Substring(10);                  this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);              }              else if (line.Contains("Accurate read data"))              {                  Match m = datareadRegex.Match(line);                  if (m.Success)                  {                      this.TotalDataRead = long.Parse(m.Groups[1].Value);                      this.LocalReadData = long.Parse(m.Groups[2].Value);                      this.IntraPodDataRead = long.Parse(m.Groups[3].Value);                      this.CrossPodDataRead = long.Parse(m.Groups[4].Value);                  }              }              else if (line.Contains("<ErrorString>"))              {                  //some errors contains "Error returned from managed runtime invocation"                  //which shows the error is from application code                  Match m = Regex.Match(line' @"\<ErrorString\>(.*)\</ErrorString\>");                  if (m.Success && lastFailedVertex != null)                  {                      lastFailedVertex.AddErrorString(System.Web.HttpUtility.HtmlDecode(m.Groups[1].Value));                  }              }              else if (line.Contains("Canceling"))              {                  // Canceling vertex 1461.0 (Merge__13[258]) due to dependent failure                  Match m = cancelRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string name = m.Groups[3].Value;                        ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              vi.SetState(ExecutedVertexInstance.VertexState.Invalidated);                          else                               vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                      else                      {                          // TODO: this should not be needed' but this is a workaround for a bug in the HPC L2H software                          vi = new ExecutedVertexInstance(this' vertex' version' name' ""' lineTimeStamp);                          vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          this.jobVertices.Add(vi);                      }                      // Process wasn't even started' so there is nothing to cancel                  }              }              else if (line.Contains("Application"))              {                  //the job ends successfully                  Regex endSuccessRegex = new Regex(@"Application completed successfully.");                  //the job failed                  Regex endFailRegex = new Regex(@"Application failed with error code (.*)");                    Match m1 = endFailRegex.Match(line);                    if (m1.Success)                  {                      this.ErrorCode = m1.Groups[1].Value;                      this.ManagerStdoutIncomplete = false;                      this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                  }                  else                  {                      Match m2 = endSuccessRegex.Match(line);                      if (m2.Success)                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                          this.ManagerStdoutIncomplete = false;                      }                  }              }              else if (line.StartsWith("Input"))              {                  // Input vertex %u (%s) had %u read failure%s\n                  Match m = inputFailureRegex.Match(line);                  if (m.Success)                  {                      this.AbortingMsg = line;                  }              }              else if (line.Contains("Vertex"))              {                  // terminationRegex = new Regex(@"Vertex (\d+)\.(\d+) \((.+)\) machine (\S+) guid \{?([-0-9A-F]+)\}? status (.*)"                  Match m = terminationRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(vertex' version);                      if (vi == null)                      {                          Trace.TraceInformation("Could not find vertex {0}.{1} line {2}"' vertex' version' line);                      }                      else                      {                          bool failed = vi.SetTermination(m.Groups[6].Value' lineTimeStamp);                          if (failed)                              this.lastFailedVertex = vi;                      }                  }              }
Magic Number,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseStdoutLine,The following statement contains a magic number: if (line.Contains("Created process execution record"))              {                  Match m = vertexCreatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Created process execution record for vertex (\d+) \((.*)\) v.(\d+) GUID \{?([-A-F0-9]+)\}?                      int number = Int32.Parse(m.Groups[1].Value);                      string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                        // the vertex may be already there' sometimes numbers are reused...                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi == null)                      {                          vi = new ExecutedVertexInstance(this' number' version' name' guid' lineTimeStamp);                          this.jobVertices.Add(vi);                      }                  }                  else                  {                      m = verticesCreatedRegex.Match(line);                      if (m.Success)                      {                          lineTimeStamp = ParseLineTimestamp(line);                            // Created process execution record for vertices (.*) v.(\d+) GUID \{?([-A-F0-9]+)\}?                          // Created process execution record for vertices 192 (Merge__41[0]) 223 (Union__45[0]) v.0 GUID {0297A91C-FFEA-42EA-94AF-CD0163A04D45}                          int version = Int32.Parse(m.Groups[2].Value);                          string vertices = m.Groups[1].Value;                          string guid = m.Groups[3].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                            IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                          foreach (var p in vertexList)                          {                              int number = p.Item2;                              ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                              if (vi == null)                              {                                  vi = new ExecutedVertexInstance(this' number' version' p.Item1' guid' lineTimeStamp);                                  this.jobVertices.Add(vi);                              }                          }                      }                  }              }              else if (line.StartsWith("Creating process"))              {                  Match m = processCreatingRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Creating process for vertex (\d+) \((.*)\\) v.(\d+) GUID \{?([-A-F0-9]+)\}? machine (\w+)                      int number = Int32.Parse(m.Groups[1].Value);                      //string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value;                         ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          this.jobVertices.Remap(vi' guid);                      }                  }              }              else if (line.StartsWith("Process was revoked"))              {                  Match m = revokedRegex.Match(line);                  if (m.Success)                  {                      string oldGuid = m.Groups[1].Value;                      ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(oldGuid);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Revoked);                          string newGuid = m.Groups[2].Value;                          this.jobVertices.Remap(vi' newGuid);                      }                      else                      {                          Trace.TraceInformation("Could not find revoked vertex with guid " + oldGuid);                      }                  }              }              else if (line.StartsWith("---HiPriTime"))              {                  // Scope-specific line which we use to get the i/o information                  // ---HiPriTime D7D51A1F-6693-4378-95FD-FC778A67C632'F52CA694-0202-411E-85E9-0C883E770A0E'SV4_Extract_Split[0]'Completed'ch1sch010331112'2011-05-03 15:26:01.681 PDT'2011-05-03 15:26:01.696 PDT'2011-05-03 15:26:02.118 PDT'2011-05-03 15:26:04.286 PDT'2011-05-03 15:26:07.656 PDT'2011-05-03 15:26:01.696 PDT'97390825'1498630                  string info = line.Substring(13);                  string[] parts = info.Split(''');                  if (parts.Length >= 13)                  {                      long read = long.Parse(parts[11]);                      long written = long.Parse(parts[12]);                      string guid = parts[1];                        ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(guid);                      if (vi != null)                      {                          vi.DataRead = read;                          vi.DataWritten = written;                          this.TotalDataRead += read;                      }                  }              }              else if (line.Contains("Io information"))              {                  // HPC-specific line                  Match m = ioRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.DataRead = long.Parse(m.Groups[4].Value);                          vi.DataWritten = long.Parse(m.Groups[5].Value);                          this.TotalDataRead += vi.DataRead;                      }                  }              }              else if (line.Contains("Process started"))              {                  //those vertices which are being canceled may not be here                  Match m = vertexStartRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        string version = m.Groups[3].Value;                      string guid = m.Groups[4].Value;                      string pid = this.ClusterConfiguration.ExtractPidFromGuid(guid' this.Summary);                      DryadProcessIdentifier identifier = new DryadProcessIdentifier(pid);                      string machine = m.Groups[5].Value;                        // Process started for vertex 4 (Super__0[0]) v.0 GUID {9DDD0B00-C93F-46D2-9073-1CFD27829300} machine sherwood-255                      // Process started for vertices 23 (Merge__29) 24 (Apply__33) v.0 GUID {E945DC5D-9AF6-4732-8770-2A6BF7FA3041} machine sherwood-237                        string vertices = m.Groups[2].Value;                      // This is a list of (number \(name\))* pairs                      // we will assume that the parantheses are matched' or we can't do much                        bool onevertex;                      if (m.Groups[1].Value == "ex")  // one vertEX                          onevertex = true;                      else if (m.Groups[1].Value == "ices")                          onevertex = false;                      else                          throw new DryadException("Can't figure out if one or many vertices");                        IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                        int vertexcount = 0;                      int iversion = int.Parse(version);                        if (lineTimeStamp > this.lastTimestampSeen)                          this.lastTimestampSeen = lineTimeStamp;                      foreach (var p in vertexList)                      {                          int number = p.Item2;                          ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' iversion);                          //new ExecutedVertexInstance(this' number' version' name' identifier' machine' this.lastTimestampSeen);                          if (vi == null)                              Trace.TraceInformation("Could not find information for vertex {0}.{1}"' number' version);                          else                              vi.SetStartInformation(this' machine' this.lastTimestampSeen' identifier' guid);                          vertexcount++;                      }                        if (vertexcount > 1 && onevertex)                          throw new DryadException("Expected one vertex' found " + vertexcount);                  }                  else                  {                      Trace.TraceInformation("Unexpected parsing error on line {0}"' line);                  }              }              else if (line.Contains("Abandoning"))              {                  Match m = vertexAbandonedRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                          vi.SetState(ExecutedVertexInstance.VertexState.Abandoned);                  }              }              else if (line.Contains("Setting"))              {                  Match m = setToFailedlRegex.Match(line);                  if (m.Success)                  {                      // Setting vertex 1461.0 (Merge__13[258]) to failed                      // Setting vertex (\d+)\.(\d+) \((.+)\) to failed(.*)                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          //vi.ErrorString = m.Groups[4].Value;                      }                  }              }              else if (line.Contains("Process was terminated"))              {                  // terminatedRegex = new Regex(@"Process was terminated Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) status (.*)"'                  // Process was terminated Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 status The operation succeeded                  Match m = terminatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          // sometimes successful processes are terminated' because they don't report quickly enough being done                          if (vi.State != ExecutedVertexInstance.VertexState.Successful)                          {                              vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          }                          vi.ErrorString = m.Groups[6].Value;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                  }              }              else if (line.Contains("Timing Information Graph Start Time"))              {                  // Cosmos-specific line                  // Timing Information Graph Start Time 128654556581866096                  Match m = Regex.Match(line' @"Timing Information Graph Start Time (\d+)");                  DateTime createTime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                  this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                  this.lastTimestampSeen = createTime;              }              else if (line.StartsWith("Start time: "))              {                  // HPC L2H specific line                  // Start time: 04/05/2011 17:25:42.223                  DateTime createTime;                  bool parse = DateTime.TryParse(line.Substring("Start time: ".Length)' out createTime);                    if (parse)                  {                      this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                      this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                      this.lastTimestampSeen = createTime;                  }              }              else if (line.Contains("JM Finish time:"))              {                  // Cosmos-specific line                  // JM Finish time: 129140295499437263 2010-03-25T22:25:49.943726Z                  Match m = Regex.Match(line' @"JM Finish time: (\d+)");                  DateTime time = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.lastTimestampSeen = time;                  this.ManagerVertex.End = time;              }              else if (line.StartsWith("Stop time "))              {                  // HPC L2H specific line                  // Stop time (Exit code = 2148734208): 04/05/2011 17:25:46.614                  Regex regex = new Regex(@"Stop time \(Exit code = (.*)\): (.*)");                  Match m = regex.Match(line);                  if (m.Success)                  {                      this.ManagerStdoutIncomplete = false;                        DateTime time;                      bool parse = DateTime.TryParse(m.Groups[2].Value' out time);                      if (parse)                      {                          this.lastTimestampSeen = time;                          this.ManagerVertex.End = time;                      }                        this.ErrorCode = m.Groups[1].Value;                      if (this.ErrorCode == "0")                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                      }                      else                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                      }                  }              }              else if (line.Contains("Timing Information"))              {                  // Timing Information 4 1 Super__0[0] 128654556603428182 0.0000 0.0000 0.0000 0.0000 0.2500                   Match m = timingInfoRegex.Match(line);                  if (m.Success)                  {                      int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      DateTime createtime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[4].Value);                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi == null)                          return; // we do not keep track of vertices with duplicate scheduling' so these won't show up here                        if (vi.State == ExecutedVertexInstance.VertexState.Started)                      {                          Console.WriteLine("Timing information while vertex is still running " + vi);                          //throw new ClusterException("Timing information for vertex still running: " + vi);                      }                      DateTime last = vi.SetTiming(createtime' m.Groups[5].Value' m.Groups[6].Value' m.Groups[7].Value' m.Groups[8].Value' m.Groups[9].Value);                      if (last > this.lastTimestampSeen)                          this.lastTimestampSeen = last;                      this.ManagerVertex.MarkVertexWasRunning(last);                        try                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              this.UsefulCPUTime += vi.RunningTime;                          else if (vi.RunningTime > TimeSpan.Zero)                              this.WastedCPUTime += vi.RunningTime;                      }                      catch (Exception ex)                      {                          Console.WriteLine("Time value exception: " + ex.Message);                      }                  }                  else                      throw new DryadException("Unmatched timing information line " + line);              }              else if (line.Contains("Process has failed"))              {                  // Process has failed Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 Exitcode 0 status The operation succeeded                  // failedRegex = new Regex(@"Process has failed Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) Exitcode (.*)"'                  Match m = failedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string exitcode = m.Groups[6].Value;                      //string status = m.Groups[7].Value;                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          vi.ExitCode = exitcode;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                          //vi.ErrorString = status;                      }                  }              }              else if (line.Contains("ABORTING:"))              {                  this.AbortingMsg = line.Substring(10);                  this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);              }              else if (line.Contains("Accurate read data"))              {                  Match m = datareadRegex.Match(line);                  if (m.Success)                  {                      this.TotalDataRead = long.Parse(m.Groups[1].Value);                      this.LocalReadData = long.Parse(m.Groups[2].Value);                      this.IntraPodDataRead = long.Parse(m.Groups[3].Value);                      this.CrossPodDataRead = long.Parse(m.Groups[4].Value);                  }              }              else if (line.Contains("<ErrorString>"))              {                  //some errors contains "Error returned from managed runtime invocation"                  //which shows the error is from application code                  Match m = Regex.Match(line' @"\<ErrorString\>(.*)\</ErrorString\>");                  if (m.Success && lastFailedVertex != null)                  {                      lastFailedVertex.AddErrorString(System.Web.HttpUtility.HtmlDecode(m.Groups[1].Value));                  }              }              else if (line.Contains("Canceling"))              {                  // Canceling vertex 1461.0 (Merge__13[258]) due to dependent failure                  Match m = cancelRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string name = m.Groups[3].Value;                        ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              vi.SetState(ExecutedVertexInstance.VertexState.Invalidated);                          else                               vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                      else                      {                          // TODO: this should not be needed' but this is a workaround for a bug in the HPC L2H software                          vi = new ExecutedVertexInstance(this' vertex' version' name' ""' lineTimeStamp);                          vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          this.jobVertices.Add(vi);                      }                      // Process wasn't even started' so there is nothing to cancel                  }              }              else if (line.Contains("Application"))              {                  //the job ends successfully                  Regex endSuccessRegex = new Regex(@"Application completed successfully.");                  //the job failed                  Regex endFailRegex = new Regex(@"Application failed with error code (.*)");                    Match m1 = endFailRegex.Match(line);                    if (m1.Success)                  {                      this.ErrorCode = m1.Groups[1].Value;                      this.ManagerStdoutIncomplete = false;                      this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                  }                  else                  {                      Match m2 = endSuccessRegex.Match(line);                      if (m2.Success)                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                          this.ManagerStdoutIncomplete = false;                      }                  }              }              else if (line.StartsWith("Input"))              {                  // Input vertex %u (%s) had %u read failure%s\n                  Match m = inputFailureRegex.Match(line);                  if (m.Success)                  {                      this.AbortingMsg = line;                  }              }              else if (line.Contains("Vertex"))              {                  // terminationRegex = new Regex(@"Vertex (\d+)\.(\d+) \((.+)\) machine (\S+) guid \{?([-0-9A-F]+)\}? status (.*)"                  Match m = terminationRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(vertex' version);                      if (vi == null)                      {                          Trace.TraceInformation("Could not find vertex {0}.{1} line {2}"' vertex' version' line);                      }                      else                      {                          bool failed = vi.SetTermination(m.Groups[6].Value' lineTimeStamp);                          if (failed)                              this.lastFailedVertex = vi;                      }                  }              }
Magic Number,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseStdoutLine,The following statement contains a magic number: if (line.Contains("Created process execution record"))              {                  Match m = vertexCreatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Created process execution record for vertex (\d+) \((.*)\) v.(\d+) GUID \{?([-A-F0-9]+)\}?                      int number = Int32.Parse(m.Groups[1].Value);                      string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                        // the vertex may be already there' sometimes numbers are reused...                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi == null)                      {                          vi = new ExecutedVertexInstance(this' number' version' name' guid' lineTimeStamp);                          this.jobVertices.Add(vi);                      }                  }                  else                  {                      m = verticesCreatedRegex.Match(line);                      if (m.Success)                      {                          lineTimeStamp = ParseLineTimestamp(line);                            // Created process execution record for vertices (.*) v.(\d+) GUID \{?([-A-F0-9]+)\}?                          // Created process execution record for vertices 192 (Merge__41[0]) 223 (Union__45[0]) v.0 GUID {0297A91C-FFEA-42EA-94AF-CD0163A04D45}                          int version = Int32.Parse(m.Groups[2].Value);                          string vertices = m.Groups[1].Value;                          string guid = m.Groups[3].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                            IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                          foreach (var p in vertexList)                          {                              int number = p.Item2;                              ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                              if (vi == null)                              {                                  vi = new ExecutedVertexInstance(this' number' version' p.Item1' guid' lineTimeStamp);                                  this.jobVertices.Add(vi);                              }                          }                      }                  }              }              else if (line.StartsWith("Creating process"))              {                  Match m = processCreatingRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Creating process for vertex (\d+) \((.*)\\) v.(\d+) GUID \{?([-A-F0-9]+)\}? machine (\w+)                      int number = Int32.Parse(m.Groups[1].Value);                      //string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value;                         ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          this.jobVertices.Remap(vi' guid);                      }                  }              }              else if (line.StartsWith("Process was revoked"))              {                  Match m = revokedRegex.Match(line);                  if (m.Success)                  {                      string oldGuid = m.Groups[1].Value;                      ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(oldGuid);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Revoked);                          string newGuid = m.Groups[2].Value;                          this.jobVertices.Remap(vi' newGuid);                      }                      else                      {                          Trace.TraceInformation("Could not find revoked vertex with guid " + oldGuid);                      }                  }              }              else if (line.StartsWith("---HiPriTime"))              {                  // Scope-specific line which we use to get the i/o information                  // ---HiPriTime D7D51A1F-6693-4378-95FD-FC778A67C632'F52CA694-0202-411E-85E9-0C883E770A0E'SV4_Extract_Split[0]'Completed'ch1sch010331112'2011-05-03 15:26:01.681 PDT'2011-05-03 15:26:01.696 PDT'2011-05-03 15:26:02.118 PDT'2011-05-03 15:26:04.286 PDT'2011-05-03 15:26:07.656 PDT'2011-05-03 15:26:01.696 PDT'97390825'1498630                  string info = line.Substring(13);                  string[] parts = info.Split(''');                  if (parts.Length >= 13)                  {                      long read = long.Parse(parts[11]);                      long written = long.Parse(parts[12]);                      string guid = parts[1];                        ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(guid);                      if (vi != null)                      {                          vi.DataRead = read;                          vi.DataWritten = written;                          this.TotalDataRead += read;                      }                  }              }              else if (line.Contains("Io information"))              {                  // HPC-specific line                  Match m = ioRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.DataRead = long.Parse(m.Groups[4].Value);                          vi.DataWritten = long.Parse(m.Groups[5].Value);                          this.TotalDataRead += vi.DataRead;                      }                  }              }              else if (line.Contains("Process started"))              {                  //those vertices which are being canceled may not be here                  Match m = vertexStartRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        string version = m.Groups[3].Value;                      string guid = m.Groups[4].Value;                      string pid = this.ClusterConfiguration.ExtractPidFromGuid(guid' this.Summary);                      DryadProcessIdentifier identifier = new DryadProcessIdentifier(pid);                      string machine = m.Groups[5].Value;                        // Process started for vertex 4 (Super__0[0]) v.0 GUID {9DDD0B00-C93F-46D2-9073-1CFD27829300} machine sherwood-255                      // Process started for vertices 23 (Merge__29) 24 (Apply__33) v.0 GUID {E945DC5D-9AF6-4732-8770-2A6BF7FA3041} machine sherwood-237                        string vertices = m.Groups[2].Value;                      // This is a list of (number \(name\))* pairs                      // we will assume that the parantheses are matched' or we can't do much                        bool onevertex;                      if (m.Groups[1].Value == "ex")  // one vertEX                          onevertex = true;                      else if (m.Groups[1].Value == "ices")                          onevertex = false;                      else                          throw new DryadException("Can't figure out if one or many vertices");                        IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                        int vertexcount = 0;                      int iversion = int.Parse(version);                        if (lineTimeStamp > this.lastTimestampSeen)                          this.lastTimestampSeen = lineTimeStamp;                      foreach (var p in vertexList)                      {                          int number = p.Item2;                          ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' iversion);                          //new ExecutedVertexInstance(this' number' version' name' identifier' machine' this.lastTimestampSeen);                          if (vi == null)                              Trace.TraceInformation("Could not find information for vertex {0}.{1}"' number' version);                          else                              vi.SetStartInformation(this' machine' this.lastTimestampSeen' identifier' guid);                          vertexcount++;                      }                        if (vertexcount > 1 && onevertex)                          throw new DryadException("Expected one vertex' found " + vertexcount);                  }                  else                  {                      Trace.TraceInformation("Unexpected parsing error on line {0}"' line);                  }              }              else if (line.Contains("Abandoning"))              {                  Match m = vertexAbandonedRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                          vi.SetState(ExecutedVertexInstance.VertexState.Abandoned);                  }              }              else if (line.Contains("Setting"))              {                  Match m = setToFailedlRegex.Match(line);                  if (m.Success)                  {                      // Setting vertex 1461.0 (Merge__13[258]) to failed                      // Setting vertex (\d+)\.(\d+) \((.+)\) to failed(.*)                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          //vi.ErrorString = m.Groups[4].Value;                      }                  }              }              else if (line.Contains("Process was terminated"))              {                  // terminatedRegex = new Regex(@"Process was terminated Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) status (.*)"'                  // Process was terminated Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 status The operation succeeded                  Match m = terminatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          // sometimes successful processes are terminated' because they don't report quickly enough being done                          if (vi.State != ExecutedVertexInstance.VertexState.Successful)                          {                              vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          }                          vi.ErrorString = m.Groups[6].Value;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                  }              }              else if (line.Contains("Timing Information Graph Start Time"))              {                  // Cosmos-specific line                  // Timing Information Graph Start Time 128654556581866096                  Match m = Regex.Match(line' @"Timing Information Graph Start Time (\d+)");                  DateTime createTime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                  this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                  this.lastTimestampSeen = createTime;              }              else if (line.StartsWith("Start time: "))              {                  // HPC L2H specific line                  // Start time: 04/05/2011 17:25:42.223                  DateTime createTime;                  bool parse = DateTime.TryParse(line.Substring("Start time: ".Length)' out createTime);                    if (parse)                  {                      this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                      this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                      this.lastTimestampSeen = createTime;                  }              }              else if (line.Contains("JM Finish time:"))              {                  // Cosmos-specific line                  // JM Finish time: 129140295499437263 2010-03-25T22:25:49.943726Z                  Match m = Regex.Match(line' @"JM Finish time: (\d+)");                  DateTime time = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.lastTimestampSeen = time;                  this.ManagerVertex.End = time;              }              else if (line.StartsWith("Stop time "))              {                  // HPC L2H specific line                  // Stop time (Exit code = 2148734208): 04/05/2011 17:25:46.614                  Regex regex = new Regex(@"Stop time \(Exit code = (.*)\): (.*)");                  Match m = regex.Match(line);                  if (m.Success)                  {                      this.ManagerStdoutIncomplete = false;                        DateTime time;                      bool parse = DateTime.TryParse(m.Groups[2].Value' out time);                      if (parse)                      {                          this.lastTimestampSeen = time;                          this.ManagerVertex.End = time;                      }                        this.ErrorCode = m.Groups[1].Value;                      if (this.ErrorCode == "0")                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                      }                      else                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                      }                  }              }              else if (line.Contains("Timing Information"))              {                  // Timing Information 4 1 Super__0[0] 128654556603428182 0.0000 0.0000 0.0000 0.0000 0.2500                   Match m = timingInfoRegex.Match(line);                  if (m.Success)                  {                      int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      DateTime createtime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[4].Value);                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi == null)                          return; // we do not keep track of vertices with duplicate scheduling' so these won't show up here                        if (vi.State == ExecutedVertexInstance.VertexState.Started)                      {                          Console.WriteLine("Timing information while vertex is still running " + vi);                          //throw new ClusterException("Timing information for vertex still running: " + vi);                      }                      DateTime last = vi.SetTiming(createtime' m.Groups[5].Value' m.Groups[6].Value' m.Groups[7].Value' m.Groups[8].Value' m.Groups[9].Value);                      if (last > this.lastTimestampSeen)                          this.lastTimestampSeen = last;                      this.ManagerVertex.MarkVertexWasRunning(last);                        try                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              this.UsefulCPUTime += vi.RunningTime;                          else if (vi.RunningTime > TimeSpan.Zero)                              this.WastedCPUTime += vi.RunningTime;                      }                      catch (Exception ex)                      {                          Console.WriteLine("Time value exception: " + ex.Message);                      }                  }                  else                      throw new DryadException("Unmatched timing information line " + line);              }              else if (line.Contains("Process has failed"))              {                  // Process has failed Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 Exitcode 0 status The operation succeeded                  // failedRegex = new Regex(@"Process has failed Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) Exitcode (.*)"'                  Match m = failedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string exitcode = m.Groups[6].Value;                      //string status = m.Groups[7].Value;                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          vi.ExitCode = exitcode;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                          //vi.ErrorString = status;                      }                  }              }              else if (line.Contains("ABORTING:"))              {                  this.AbortingMsg = line.Substring(10);                  this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);              }              else if (line.Contains("Accurate read data"))              {                  Match m = datareadRegex.Match(line);                  if (m.Success)                  {                      this.TotalDataRead = long.Parse(m.Groups[1].Value);                      this.LocalReadData = long.Parse(m.Groups[2].Value);                      this.IntraPodDataRead = long.Parse(m.Groups[3].Value);                      this.CrossPodDataRead = long.Parse(m.Groups[4].Value);                  }              }              else if (line.Contains("<ErrorString>"))              {                  //some errors contains "Error returned from managed runtime invocation"                  //which shows the error is from application code                  Match m = Regex.Match(line' @"\<ErrorString\>(.*)\</ErrorString\>");                  if (m.Success && lastFailedVertex != null)                  {                      lastFailedVertex.AddErrorString(System.Web.HttpUtility.HtmlDecode(m.Groups[1].Value));                  }              }              else if (line.Contains("Canceling"))              {                  // Canceling vertex 1461.0 (Merge__13[258]) due to dependent failure                  Match m = cancelRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string name = m.Groups[3].Value;                        ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              vi.SetState(ExecutedVertexInstance.VertexState.Invalidated);                          else                               vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                      else                      {                          // TODO: this should not be needed' but this is a workaround for a bug in the HPC L2H software                          vi = new ExecutedVertexInstance(this' vertex' version' name' ""' lineTimeStamp);                          vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          this.jobVertices.Add(vi);                      }                      // Process wasn't even started' so there is nothing to cancel                  }              }              else if (line.Contains("Application"))              {                  //the job ends successfully                  Regex endSuccessRegex = new Regex(@"Application completed successfully.");                  //the job failed                  Regex endFailRegex = new Regex(@"Application failed with error code (.*)");                    Match m1 = endFailRegex.Match(line);                    if (m1.Success)                  {                      this.ErrorCode = m1.Groups[1].Value;                      this.ManagerStdoutIncomplete = false;                      this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                  }                  else                  {                      Match m2 = endSuccessRegex.Match(line);                      if (m2.Success)                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                          this.ManagerStdoutIncomplete = false;                      }                  }              }              else if (line.StartsWith("Input"))              {                  // Input vertex %u (%s) had %u read failure%s\n                  Match m = inputFailureRegex.Match(line);                  if (m.Success)                  {                      this.AbortingMsg = line;                  }              }              else if (line.Contains("Vertex"))              {                  // terminationRegex = new Regex(@"Vertex (\d+)\.(\d+) \((.+)\) machine (\S+) guid \{?([-0-9A-F]+)\}? status (.*)"                  Match m = terminationRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(vertex' version);                      if (vi == null)                      {                          Trace.TraceInformation("Could not find vertex {0}.{1} line {2}"' vertex' version' line);                      }                      else                      {                          bool failed = vi.SetTermination(m.Groups[6].Value' lineTimeStamp);                          if (failed)                              this.lastFailedVertex = vi;                      }                  }              }
Magic Number,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseStdoutLine,The following statement contains a magic number: if (line.Contains("Created process execution record"))              {                  Match m = vertexCreatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Created process execution record for vertex (\d+) \((.*)\) v.(\d+) GUID \{?([-A-F0-9]+)\}?                      int number = Int32.Parse(m.Groups[1].Value);                      string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                        // the vertex may be already there' sometimes numbers are reused...                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi == null)                      {                          vi = new ExecutedVertexInstance(this' number' version' name' guid' lineTimeStamp);                          this.jobVertices.Add(vi);                      }                  }                  else                  {                      m = verticesCreatedRegex.Match(line);                      if (m.Success)                      {                          lineTimeStamp = ParseLineTimestamp(line);                            // Created process execution record for vertices (.*) v.(\d+) GUID \{?([-A-F0-9]+)\}?                          // Created process execution record for vertices 192 (Merge__41[0]) 223 (Union__45[0]) v.0 GUID {0297A91C-FFEA-42EA-94AF-CD0163A04D45}                          int version = Int32.Parse(m.Groups[2].Value);                          string vertices = m.Groups[1].Value;                          string guid = m.Groups[3].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                            IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                          foreach (var p in vertexList)                          {                              int number = p.Item2;                              ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                              if (vi == null)                              {                                  vi = new ExecutedVertexInstance(this' number' version' p.Item1' guid' lineTimeStamp);                                  this.jobVertices.Add(vi);                              }                          }                      }                  }              }              else if (line.StartsWith("Creating process"))              {                  Match m = processCreatingRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Creating process for vertex (\d+) \((.*)\\) v.(\d+) GUID \{?([-A-F0-9]+)\}? machine (\w+)                      int number = Int32.Parse(m.Groups[1].Value);                      //string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value;                         ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          this.jobVertices.Remap(vi' guid);                      }                  }              }              else if (line.StartsWith("Process was revoked"))              {                  Match m = revokedRegex.Match(line);                  if (m.Success)                  {                      string oldGuid = m.Groups[1].Value;                      ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(oldGuid);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Revoked);                          string newGuid = m.Groups[2].Value;                          this.jobVertices.Remap(vi' newGuid);                      }                      else                      {                          Trace.TraceInformation("Could not find revoked vertex with guid " + oldGuid);                      }                  }              }              else if (line.StartsWith("---HiPriTime"))              {                  // Scope-specific line which we use to get the i/o information                  // ---HiPriTime D7D51A1F-6693-4378-95FD-FC778A67C632'F52CA694-0202-411E-85E9-0C883E770A0E'SV4_Extract_Split[0]'Completed'ch1sch010331112'2011-05-03 15:26:01.681 PDT'2011-05-03 15:26:01.696 PDT'2011-05-03 15:26:02.118 PDT'2011-05-03 15:26:04.286 PDT'2011-05-03 15:26:07.656 PDT'2011-05-03 15:26:01.696 PDT'97390825'1498630                  string info = line.Substring(13);                  string[] parts = info.Split(''');                  if (parts.Length >= 13)                  {                      long read = long.Parse(parts[11]);                      long written = long.Parse(parts[12]);                      string guid = parts[1];                        ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(guid);                      if (vi != null)                      {                          vi.DataRead = read;                          vi.DataWritten = written;                          this.TotalDataRead += read;                      }                  }              }              else if (line.Contains("Io information"))              {                  // HPC-specific line                  Match m = ioRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.DataRead = long.Parse(m.Groups[4].Value);                          vi.DataWritten = long.Parse(m.Groups[5].Value);                          this.TotalDataRead += vi.DataRead;                      }                  }              }              else if (line.Contains("Process started"))              {                  //those vertices which are being canceled may not be here                  Match m = vertexStartRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        string version = m.Groups[3].Value;                      string guid = m.Groups[4].Value;                      string pid = this.ClusterConfiguration.ExtractPidFromGuid(guid' this.Summary);                      DryadProcessIdentifier identifier = new DryadProcessIdentifier(pid);                      string machine = m.Groups[5].Value;                        // Process started for vertex 4 (Super__0[0]) v.0 GUID {9DDD0B00-C93F-46D2-9073-1CFD27829300} machine sherwood-255                      // Process started for vertices 23 (Merge__29) 24 (Apply__33) v.0 GUID {E945DC5D-9AF6-4732-8770-2A6BF7FA3041} machine sherwood-237                        string vertices = m.Groups[2].Value;                      // This is a list of (number \(name\))* pairs                      // we will assume that the parantheses are matched' or we can't do much                        bool onevertex;                      if (m.Groups[1].Value == "ex")  // one vertEX                          onevertex = true;                      else if (m.Groups[1].Value == "ices")                          onevertex = false;                      else                          throw new DryadException("Can't figure out if one or many vertices");                        IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                        int vertexcount = 0;                      int iversion = int.Parse(version);                        if (lineTimeStamp > this.lastTimestampSeen)                          this.lastTimestampSeen = lineTimeStamp;                      foreach (var p in vertexList)                      {                          int number = p.Item2;                          ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' iversion);                          //new ExecutedVertexInstance(this' number' version' name' identifier' machine' this.lastTimestampSeen);                          if (vi == null)                              Trace.TraceInformation("Could not find information for vertex {0}.{1}"' number' version);                          else                              vi.SetStartInformation(this' machine' this.lastTimestampSeen' identifier' guid);                          vertexcount++;                      }                        if (vertexcount > 1 && onevertex)                          throw new DryadException("Expected one vertex' found " + vertexcount);                  }                  else                  {                      Trace.TraceInformation("Unexpected parsing error on line {0}"' line);                  }              }              else if (line.Contains("Abandoning"))              {                  Match m = vertexAbandonedRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                          vi.SetState(ExecutedVertexInstance.VertexState.Abandoned);                  }              }              else if (line.Contains("Setting"))              {                  Match m = setToFailedlRegex.Match(line);                  if (m.Success)                  {                      // Setting vertex 1461.0 (Merge__13[258]) to failed                      // Setting vertex (\d+)\.(\d+) \((.+)\) to failed(.*)                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          //vi.ErrorString = m.Groups[4].Value;                      }                  }              }              else if (line.Contains("Process was terminated"))              {                  // terminatedRegex = new Regex(@"Process was terminated Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) status (.*)"'                  // Process was terminated Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 status The operation succeeded                  Match m = terminatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          // sometimes successful processes are terminated' because they don't report quickly enough being done                          if (vi.State != ExecutedVertexInstance.VertexState.Successful)                          {                              vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          }                          vi.ErrorString = m.Groups[6].Value;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                  }              }              else if (line.Contains("Timing Information Graph Start Time"))              {                  // Cosmos-specific line                  // Timing Information Graph Start Time 128654556581866096                  Match m = Regex.Match(line' @"Timing Information Graph Start Time (\d+)");                  DateTime createTime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                  this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                  this.lastTimestampSeen = createTime;              }              else if (line.StartsWith("Start time: "))              {                  // HPC L2H specific line                  // Start time: 04/05/2011 17:25:42.223                  DateTime createTime;                  bool parse = DateTime.TryParse(line.Substring("Start time: ".Length)' out createTime);                    if (parse)                  {                      this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                      this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                      this.lastTimestampSeen = createTime;                  }              }              else if (line.Contains("JM Finish time:"))              {                  // Cosmos-specific line                  // JM Finish time: 129140295499437263 2010-03-25T22:25:49.943726Z                  Match m = Regex.Match(line' @"JM Finish time: (\d+)");                  DateTime time = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.lastTimestampSeen = time;                  this.ManagerVertex.End = time;              }              else if (line.StartsWith("Stop time "))              {                  // HPC L2H specific line                  // Stop time (Exit code = 2148734208): 04/05/2011 17:25:46.614                  Regex regex = new Regex(@"Stop time \(Exit code = (.*)\): (.*)");                  Match m = regex.Match(line);                  if (m.Success)                  {                      this.ManagerStdoutIncomplete = false;                        DateTime time;                      bool parse = DateTime.TryParse(m.Groups[2].Value' out time);                      if (parse)                      {                          this.lastTimestampSeen = time;                          this.ManagerVertex.End = time;                      }                        this.ErrorCode = m.Groups[1].Value;                      if (this.ErrorCode == "0")                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                      }                      else                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                      }                  }              }              else if (line.Contains("Timing Information"))              {                  // Timing Information 4 1 Super__0[0] 128654556603428182 0.0000 0.0000 0.0000 0.0000 0.2500                   Match m = timingInfoRegex.Match(line);                  if (m.Success)                  {                      int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      DateTime createtime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[4].Value);                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi == null)                          return; // we do not keep track of vertices with duplicate scheduling' so these won't show up here                        if (vi.State == ExecutedVertexInstance.VertexState.Started)                      {                          Console.WriteLine("Timing information while vertex is still running " + vi);                          //throw new ClusterException("Timing information for vertex still running: " + vi);                      }                      DateTime last = vi.SetTiming(createtime' m.Groups[5].Value' m.Groups[6].Value' m.Groups[7].Value' m.Groups[8].Value' m.Groups[9].Value);                      if (last > this.lastTimestampSeen)                          this.lastTimestampSeen = last;                      this.ManagerVertex.MarkVertexWasRunning(last);                        try                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              this.UsefulCPUTime += vi.RunningTime;                          else if (vi.RunningTime > TimeSpan.Zero)                              this.WastedCPUTime += vi.RunningTime;                      }                      catch (Exception ex)                      {                          Console.WriteLine("Time value exception: " + ex.Message);                      }                  }                  else                      throw new DryadException("Unmatched timing information line " + line);              }              else if (line.Contains("Process has failed"))              {                  // Process has failed Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 Exitcode 0 status The operation succeeded                  // failedRegex = new Regex(@"Process has failed Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) Exitcode (.*)"'                  Match m = failedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string exitcode = m.Groups[6].Value;                      //string status = m.Groups[7].Value;                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          vi.ExitCode = exitcode;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                          //vi.ErrorString = status;                      }                  }              }              else if (line.Contains("ABORTING:"))              {                  this.AbortingMsg = line.Substring(10);                  this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);              }              else if (line.Contains("Accurate read data"))              {                  Match m = datareadRegex.Match(line);                  if (m.Success)                  {                      this.TotalDataRead = long.Parse(m.Groups[1].Value);                      this.LocalReadData = long.Parse(m.Groups[2].Value);                      this.IntraPodDataRead = long.Parse(m.Groups[3].Value);                      this.CrossPodDataRead = long.Parse(m.Groups[4].Value);                  }              }              else if (line.Contains("<ErrorString>"))              {                  //some errors contains "Error returned from managed runtime invocation"                  //which shows the error is from application code                  Match m = Regex.Match(line' @"\<ErrorString\>(.*)\</ErrorString\>");                  if (m.Success && lastFailedVertex != null)                  {                      lastFailedVertex.AddErrorString(System.Web.HttpUtility.HtmlDecode(m.Groups[1].Value));                  }              }              else if (line.Contains("Canceling"))              {                  // Canceling vertex 1461.0 (Merge__13[258]) due to dependent failure                  Match m = cancelRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string name = m.Groups[3].Value;                        ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              vi.SetState(ExecutedVertexInstance.VertexState.Invalidated);                          else                               vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                      else                      {                          // TODO: this should not be needed' but this is a workaround for a bug in the HPC L2H software                          vi = new ExecutedVertexInstance(this' vertex' version' name' ""' lineTimeStamp);                          vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          this.jobVertices.Add(vi);                      }                      // Process wasn't even started' so there is nothing to cancel                  }              }              else if (line.Contains("Application"))              {                  //the job ends successfully                  Regex endSuccessRegex = new Regex(@"Application completed successfully.");                  //the job failed                  Regex endFailRegex = new Regex(@"Application failed with error code (.*)");                    Match m1 = endFailRegex.Match(line);                    if (m1.Success)                  {                      this.ErrorCode = m1.Groups[1].Value;                      this.ManagerStdoutIncomplete = false;                      this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                  }                  else                  {                      Match m2 = endSuccessRegex.Match(line);                      if (m2.Success)                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                          this.ManagerStdoutIncomplete = false;                      }                  }              }              else if (line.StartsWith("Input"))              {                  // Input vertex %u (%s) had %u read failure%s\n                  Match m = inputFailureRegex.Match(line);                  if (m.Success)                  {                      this.AbortingMsg = line;                  }              }              else if (line.Contains("Vertex"))              {                  // terminationRegex = new Regex(@"Vertex (\d+)\.(\d+) \((.+)\) machine (\S+) guid \{?([-0-9A-F]+)\}? status (.*)"                  Match m = terminationRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(vertex' version);                      if (vi == null)                      {                          Trace.TraceInformation("Could not find vertex {0}.{1} line {2}"' vertex' version' line);                      }                      else                      {                          bool failed = vi.SetTermination(m.Groups[6].Value' lineTimeStamp);                          if (failed)                              this.lastFailedVertex = vi;                      }                  }              }
Magic Number,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseStdoutLine,The following statement contains a magic number: if (line.Contains("Created process execution record"))              {                  Match m = vertexCreatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Created process execution record for vertex (\d+) \((.*)\) v.(\d+) GUID \{?([-A-F0-9]+)\}?                      int number = Int32.Parse(m.Groups[1].Value);                      string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                        // the vertex may be already there' sometimes numbers are reused...                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi == null)                      {                          vi = new ExecutedVertexInstance(this' number' version' name' guid' lineTimeStamp);                          this.jobVertices.Add(vi);                      }                  }                  else                  {                      m = verticesCreatedRegex.Match(line);                      if (m.Success)                      {                          lineTimeStamp = ParseLineTimestamp(line);                            // Created process execution record for vertices (.*) v.(\d+) GUID \{?([-A-F0-9]+)\}?                          // Created process execution record for vertices 192 (Merge__41[0]) 223 (Union__45[0]) v.0 GUID {0297A91C-FFEA-42EA-94AF-CD0163A04D45}                          int version = Int32.Parse(m.Groups[2].Value);                          string vertices = m.Groups[1].Value;                          string guid = m.Groups[3].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                            IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                          foreach (var p in vertexList)                          {                              int number = p.Item2;                              ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                              if (vi == null)                              {                                  vi = new ExecutedVertexInstance(this' number' version' p.Item1' guid' lineTimeStamp);                                  this.jobVertices.Add(vi);                              }                          }                      }                  }              }              else if (line.StartsWith("Creating process"))              {                  Match m = processCreatingRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Creating process for vertex (\d+) \((.*)\\) v.(\d+) GUID \{?([-A-F0-9]+)\}? machine (\w+)                      int number = Int32.Parse(m.Groups[1].Value);                      //string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value;                         ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          this.jobVertices.Remap(vi' guid);                      }                  }              }              else if (line.StartsWith("Process was revoked"))              {                  Match m = revokedRegex.Match(line);                  if (m.Success)                  {                      string oldGuid = m.Groups[1].Value;                      ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(oldGuid);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Revoked);                          string newGuid = m.Groups[2].Value;                          this.jobVertices.Remap(vi' newGuid);                      }                      else                      {                          Trace.TraceInformation("Could not find revoked vertex with guid " + oldGuid);                      }                  }              }              else if (line.StartsWith("---HiPriTime"))              {                  // Scope-specific line which we use to get the i/o information                  // ---HiPriTime D7D51A1F-6693-4378-95FD-FC778A67C632'F52CA694-0202-411E-85E9-0C883E770A0E'SV4_Extract_Split[0]'Completed'ch1sch010331112'2011-05-03 15:26:01.681 PDT'2011-05-03 15:26:01.696 PDT'2011-05-03 15:26:02.118 PDT'2011-05-03 15:26:04.286 PDT'2011-05-03 15:26:07.656 PDT'2011-05-03 15:26:01.696 PDT'97390825'1498630                  string info = line.Substring(13);                  string[] parts = info.Split(''');                  if (parts.Length >= 13)                  {                      long read = long.Parse(parts[11]);                      long written = long.Parse(parts[12]);                      string guid = parts[1];                        ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(guid);                      if (vi != null)                      {                          vi.DataRead = read;                          vi.DataWritten = written;                          this.TotalDataRead += read;                      }                  }              }              else if (line.Contains("Io information"))              {                  // HPC-specific line                  Match m = ioRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.DataRead = long.Parse(m.Groups[4].Value);                          vi.DataWritten = long.Parse(m.Groups[5].Value);                          this.TotalDataRead += vi.DataRead;                      }                  }              }              else if (line.Contains("Process started"))              {                  //those vertices which are being canceled may not be here                  Match m = vertexStartRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        string version = m.Groups[3].Value;                      string guid = m.Groups[4].Value;                      string pid = this.ClusterConfiguration.ExtractPidFromGuid(guid' this.Summary);                      DryadProcessIdentifier identifier = new DryadProcessIdentifier(pid);                      string machine = m.Groups[5].Value;                        // Process started for vertex 4 (Super__0[0]) v.0 GUID {9DDD0B00-C93F-46D2-9073-1CFD27829300} machine sherwood-255                      // Process started for vertices 23 (Merge__29) 24 (Apply__33) v.0 GUID {E945DC5D-9AF6-4732-8770-2A6BF7FA3041} machine sherwood-237                        string vertices = m.Groups[2].Value;                      // This is a list of (number \(name\))* pairs                      // we will assume that the parantheses are matched' or we can't do much                        bool onevertex;                      if (m.Groups[1].Value == "ex")  // one vertEX                          onevertex = true;                      else if (m.Groups[1].Value == "ices")                          onevertex = false;                      else                          throw new DryadException("Can't figure out if one or many vertices");                        IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                        int vertexcount = 0;                      int iversion = int.Parse(version);                        if (lineTimeStamp > this.lastTimestampSeen)                          this.lastTimestampSeen = lineTimeStamp;                      foreach (var p in vertexList)                      {                          int number = p.Item2;                          ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' iversion);                          //new ExecutedVertexInstance(this' number' version' name' identifier' machine' this.lastTimestampSeen);                          if (vi == null)                              Trace.TraceInformation("Could not find information for vertex {0}.{1}"' number' version);                          else                              vi.SetStartInformation(this' machine' this.lastTimestampSeen' identifier' guid);                          vertexcount++;                      }                        if (vertexcount > 1 && onevertex)                          throw new DryadException("Expected one vertex' found " + vertexcount);                  }                  else                  {                      Trace.TraceInformation("Unexpected parsing error on line {0}"' line);                  }              }              else if (line.Contains("Abandoning"))              {                  Match m = vertexAbandonedRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                          vi.SetState(ExecutedVertexInstance.VertexState.Abandoned);                  }              }              else if (line.Contains("Setting"))              {                  Match m = setToFailedlRegex.Match(line);                  if (m.Success)                  {                      // Setting vertex 1461.0 (Merge__13[258]) to failed                      // Setting vertex (\d+)\.(\d+) \((.+)\) to failed(.*)                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          //vi.ErrorString = m.Groups[4].Value;                      }                  }              }              else if (line.Contains("Process was terminated"))              {                  // terminatedRegex = new Regex(@"Process was terminated Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) status (.*)"'                  // Process was terminated Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 status The operation succeeded                  Match m = terminatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          // sometimes successful processes are terminated' because they don't report quickly enough being done                          if (vi.State != ExecutedVertexInstance.VertexState.Successful)                          {                              vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          }                          vi.ErrorString = m.Groups[6].Value;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                  }              }              else if (line.Contains("Timing Information Graph Start Time"))              {                  // Cosmos-specific line                  // Timing Information Graph Start Time 128654556581866096                  Match m = Regex.Match(line' @"Timing Information Graph Start Time (\d+)");                  DateTime createTime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                  this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                  this.lastTimestampSeen = createTime;              }              else if (line.StartsWith("Start time: "))              {                  // HPC L2H specific line                  // Start time: 04/05/2011 17:25:42.223                  DateTime createTime;                  bool parse = DateTime.TryParse(line.Substring("Start time: ".Length)' out createTime);                    if (parse)                  {                      this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                      this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                      this.lastTimestampSeen = createTime;                  }              }              else if (line.Contains("JM Finish time:"))              {                  // Cosmos-specific line                  // JM Finish time: 129140295499437263 2010-03-25T22:25:49.943726Z                  Match m = Regex.Match(line' @"JM Finish time: (\d+)");                  DateTime time = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.lastTimestampSeen = time;                  this.ManagerVertex.End = time;              }              else if (line.StartsWith("Stop time "))              {                  // HPC L2H specific line                  // Stop time (Exit code = 2148734208): 04/05/2011 17:25:46.614                  Regex regex = new Regex(@"Stop time \(Exit code = (.*)\): (.*)");                  Match m = regex.Match(line);                  if (m.Success)                  {                      this.ManagerStdoutIncomplete = false;                        DateTime time;                      bool parse = DateTime.TryParse(m.Groups[2].Value' out time);                      if (parse)                      {                          this.lastTimestampSeen = time;                          this.ManagerVertex.End = time;                      }                        this.ErrorCode = m.Groups[1].Value;                      if (this.ErrorCode == "0")                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                      }                      else                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                      }                  }              }              else if (line.Contains("Timing Information"))              {                  // Timing Information 4 1 Super__0[0] 128654556603428182 0.0000 0.0000 0.0000 0.0000 0.2500                   Match m = timingInfoRegex.Match(line);                  if (m.Success)                  {                      int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      DateTime createtime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[4].Value);                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi == null)                          return; // we do not keep track of vertices with duplicate scheduling' so these won't show up here                        if (vi.State == ExecutedVertexInstance.VertexState.Started)                      {                          Console.WriteLine("Timing information while vertex is still running " + vi);                          //throw new ClusterException("Timing information for vertex still running: " + vi);                      }                      DateTime last = vi.SetTiming(createtime' m.Groups[5].Value' m.Groups[6].Value' m.Groups[7].Value' m.Groups[8].Value' m.Groups[9].Value);                      if (last > this.lastTimestampSeen)                          this.lastTimestampSeen = last;                      this.ManagerVertex.MarkVertexWasRunning(last);                        try                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              this.UsefulCPUTime += vi.RunningTime;                          else if (vi.RunningTime > TimeSpan.Zero)                              this.WastedCPUTime += vi.RunningTime;                      }                      catch (Exception ex)                      {                          Console.WriteLine("Time value exception: " + ex.Message);                      }                  }                  else                      throw new DryadException("Unmatched timing information line " + line);              }              else if (line.Contains("Process has failed"))              {                  // Process has failed Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 Exitcode 0 status The operation succeeded                  // failedRegex = new Regex(@"Process has failed Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) Exitcode (.*)"'                  Match m = failedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string exitcode = m.Groups[6].Value;                      //string status = m.Groups[7].Value;                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          vi.ExitCode = exitcode;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                          //vi.ErrorString = status;                      }                  }              }              else if (line.Contains("ABORTING:"))              {                  this.AbortingMsg = line.Substring(10);                  this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);              }              else if (line.Contains("Accurate read data"))              {                  Match m = datareadRegex.Match(line);                  if (m.Success)                  {                      this.TotalDataRead = long.Parse(m.Groups[1].Value);                      this.LocalReadData = long.Parse(m.Groups[2].Value);                      this.IntraPodDataRead = long.Parse(m.Groups[3].Value);                      this.CrossPodDataRead = long.Parse(m.Groups[4].Value);                  }              }              else if (line.Contains("<ErrorString>"))              {                  //some errors contains "Error returned from managed runtime invocation"                  //which shows the error is from application code                  Match m = Regex.Match(line' @"\<ErrorString\>(.*)\</ErrorString\>");                  if (m.Success && lastFailedVertex != null)                  {                      lastFailedVertex.AddErrorString(System.Web.HttpUtility.HtmlDecode(m.Groups[1].Value));                  }              }              else if (line.Contains("Canceling"))              {                  // Canceling vertex 1461.0 (Merge__13[258]) due to dependent failure                  Match m = cancelRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string name = m.Groups[3].Value;                        ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              vi.SetState(ExecutedVertexInstance.VertexState.Invalidated);                          else                               vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                      else                      {                          // TODO: this should not be needed' but this is a workaround for a bug in the HPC L2H software                          vi = new ExecutedVertexInstance(this' vertex' version' name' ""' lineTimeStamp);                          vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          this.jobVertices.Add(vi);                      }                      // Process wasn't even started' so there is nothing to cancel                  }              }              else if (line.Contains("Application"))              {                  //the job ends successfully                  Regex endSuccessRegex = new Regex(@"Application completed successfully.");                  //the job failed                  Regex endFailRegex = new Regex(@"Application failed with error code (.*)");                    Match m1 = endFailRegex.Match(line);                    if (m1.Success)                  {                      this.ErrorCode = m1.Groups[1].Value;                      this.ManagerStdoutIncomplete = false;                      this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                  }                  else                  {                      Match m2 = endSuccessRegex.Match(line);                      if (m2.Success)                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                          this.ManagerStdoutIncomplete = false;                      }                  }              }              else if (line.StartsWith("Input"))              {                  // Input vertex %u (%s) had %u read failure%s\n                  Match m = inputFailureRegex.Match(line);                  if (m.Success)                  {                      this.AbortingMsg = line;                  }              }              else if (line.Contains("Vertex"))              {                  // terminationRegex = new Regex(@"Vertex (\d+)\.(\d+) \((.+)\) machine (\S+) guid \{?([-0-9A-F]+)\}? status (.*)"                  Match m = terminationRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(vertex' version);                      if (vi == null)                      {                          Trace.TraceInformation("Could not find vertex {0}.{1} line {2}"' vertex' version' line);                      }                      else                      {                          bool failed = vi.SetTermination(m.Groups[6].Value' lineTimeStamp);                          if (failed)                              this.lastFailedVertex = vi;                      }                  }              }
Magic Number,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseStdoutLine,The following statement contains a magic number: if (line.Contains("Created process execution record"))              {                  Match m = vertexCreatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Created process execution record for vertex (\d+) \((.*)\) v.(\d+) GUID \{?([-A-F0-9]+)\}?                      int number = Int32.Parse(m.Groups[1].Value);                      string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                        // the vertex may be already there' sometimes numbers are reused...                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi == null)                      {                          vi = new ExecutedVertexInstance(this' number' version' name' guid' lineTimeStamp);                          this.jobVertices.Add(vi);                      }                  }                  else                  {                      m = verticesCreatedRegex.Match(line);                      if (m.Success)                      {                          lineTimeStamp = ParseLineTimestamp(line);                            // Created process execution record for vertices (.*) v.(\d+) GUID \{?([-A-F0-9]+)\}?                          // Created process execution record for vertices 192 (Merge__41[0]) 223 (Union__45[0]) v.0 GUID {0297A91C-FFEA-42EA-94AF-CD0163A04D45}                          int version = Int32.Parse(m.Groups[2].Value);                          string vertices = m.Groups[1].Value;                          string guid = m.Groups[3].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                            IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                          foreach (var p in vertexList)                          {                              int number = p.Item2;                              ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                              if (vi == null)                              {                                  vi = new ExecutedVertexInstance(this' number' version' p.Item1' guid' lineTimeStamp);                                  this.jobVertices.Add(vi);                              }                          }                      }                  }              }              else if (line.StartsWith("Creating process"))              {                  Match m = processCreatingRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Creating process for vertex (\d+) \((.*)\\) v.(\d+) GUID \{?([-A-F0-9]+)\}? machine (\w+)                      int number = Int32.Parse(m.Groups[1].Value);                      //string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value;                         ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          this.jobVertices.Remap(vi' guid);                      }                  }              }              else if (line.StartsWith("Process was revoked"))              {                  Match m = revokedRegex.Match(line);                  if (m.Success)                  {                      string oldGuid = m.Groups[1].Value;                      ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(oldGuid);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Revoked);                          string newGuid = m.Groups[2].Value;                          this.jobVertices.Remap(vi' newGuid);                      }                      else                      {                          Trace.TraceInformation("Could not find revoked vertex with guid " + oldGuid);                      }                  }              }              else if (line.StartsWith("---HiPriTime"))              {                  // Scope-specific line which we use to get the i/o information                  // ---HiPriTime D7D51A1F-6693-4378-95FD-FC778A67C632'F52CA694-0202-411E-85E9-0C883E770A0E'SV4_Extract_Split[0]'Completed'ch1sch010331112'2011-05-03 15:26:01.681 PDT'2011-05-03 15:26:01.696 PDT'2011-05-03 15:26:02.118 PDT'2011-05-03 15:26:04.286 PDT'2011-05-03 15:26:07.656 PDT'2011-05-03 15:26:01.696 PDT'97390825'1498630                  string info = line.Substring(13);                  string[] parts = info.Split(''');                  if (parts.Length >= 13)                  {                      long read = long.Parse(parts[11]);                      long written = long.Parse(parts[12]);                      string guid = parts[1];                        ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(guid);                      if (vi != null)                      {                          vi.DataRead = read;                          vi.DataWritten = written;                          this.TotalDataRead += read;                      }                  }              }              else if (line.Contains("Io information"))              {                  // HPC-specific line                  Match m = ioRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.DataRead = long.Parse(m.Groups[4].Value);                          vi.DataWritten = long.Parse(m.Groups[5].Value);                          this.TotalDataRead += vi.DataRead;                      }                  }              }              else if (line.Contains("Process started"))              {                  //those vertices which are being canceled may not be here                  Match m = vertexStartRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        string version = m.Groups[3].Value;                      string guid = m.Groups[4].Value;                      string pid = this.ClusterConfiguration.ExtractPidFromGuid(guid' this.Summary);                      DryadProcessIdentifier identifier = new DryadProcessIdentifier(pid);                      string machine = m.Groups[5].Value;                        // Process started for vertex 4 (Super__0[0]) v.0 GUID {9DDD0B00-C93F-46D2-9073-1CFD27829300} machine sherwood-255                      // Process started for vertices 23 (Merge__29) 24 (Apply__33) v.0 GUID {E945DC5D-9AF6-4732-8770-2A6BF7FA3041} machine sherwood-237                        string vertices = m.Groups[2].Value;                      // This is a list of (number \(name\))* pairs                      // we will assume that the parantheses are matched' or we can't do much                        bool onevertex;                      if (m.Groups[1].Value == "ex")  // one vertEX                          onevertex = true;                      else if (m.Groups[1].Value == "ices")                          onevertex = false;                      else                          throw new DryadException("Can't figure out if one or many vertices");                        IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                        int vertexcount = 0;                      int iversion = int.Parse(version);                        if (lineTimeStamp > this.lastTimestampSeen)                          this.lastTimestampSeen = lineTimeStamp;                      foreach (var p in vertexList)                      {                          int number = p.Item2;                          ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' iversion);                          //new ExecutedVertexInstance(this' number' version' name' identifier' machine' this.lastTimestampSeen);                          if (vi == null)                              Trace.TraceInformation("Could not find information for vertex {0}.{1}"' number' version);                          else                              vi.SetStartInformation(this' machine' this.lastTimestampSeen' identifier' guid);                          vertexcount++;                      }                        if (vertexcount > 1 && onevertex)                          throw new DryadException("Expected one vertex' found " + vertexcount);                  }                  else                  {                      Trace.TraceInformation("Unexpected parsing error on line {0}"' line);                  }              }              else if (line.Contains("Abandoning"))              {                  Match m = vertexAbandonedRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                          vi.SetState(ExecutedVertexInstance.VertexState.Abandoned);                  }              }              else if (line.Contains("Setting"))              {                  Match m = setToFailedlRegex.Match(line);                  if (m.Success)                  {                      // Setting vertex 1461.0 (Merge__13[258]) to failed                      // Setting vertex (\d+)\.(\d+) \((.+)\) to failed(.*)                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          //vi.ErrorString = m.Groups[4].Value;                      }                  }              }              else if (line.Contains("Process was terminated"))              {                  // terminatedRegex = new Regex(@"Process was terminated Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) status (.*)"'                  // Process was terminated Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 status The operation succeeded                  Match m = terminatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          // sometimes successful processes are terminated' because they don't report quickly enough being done                          if (vi.State != ExecutedVertexInstance.VertexState.Successful)                          {                              vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          }                          vi.ErrorString = m.Groups[6].Value;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                  }              }              else if (line.Contains("Timing Information Graph Start Time"))              {                  // Cosmos-specific line                  // Timing Information Graph Start Time 128654556581866096                  Match m = Regex.Match(line' @"Timing Information Graph Start Time (\d+)");                  DateTime createTime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                  this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                  this.lastTimestampSeen = createTime;              }              else if (line.StartsWith("Start time: "))              {                  // HPC L2H specific line                  // Start time: 04/05/2011 17:25:42.223                  DateTime createTime;                  bool parse = DateTime.TryParse(line.Substring("Start time: ".Length)' out createTime);                    if (parse)                  {                      this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                      this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                      this.lastTimestampSeen = createTime;                  }              }              else if (line.Contains("JM Finish time:"))              {                  // Cosmos-specific line                  // JM Finish time: 129140295499437263 2010-03-25T22:25:49.943726Z                  Match m = Regex.Match(line' @"JM Finish time: (\d+)");                  DateTime time = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.lastTimestampSeen = time;                  this.ManagerVertex.End = time;              }              else if (line.StartsWith("Stop time "))              {                  // HPC L2H specific line                  // Stop time (Exit code = 2148734208): 04/05/2011 17:25:46.614                  Regex regex = new Regex(@"Stop time \(Exit code = (.*)\): (.*)");                  Match m = regex.Match(line);                  if (m.Success)                  {                      this.ManagerStdoutIncomplete = false;                        DateTime time;                      bool parse = DateTime.TryParse(m.Groups[2].Value' out time);                      if (parse)                      {                          this.lastTimestampSeen = time;                          this.ManagerVertex.End = time;                      }                        this.ErrorCode = m.Groups[1].Value;                      if (this.ErrorCode == "0")                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                      }                      else                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                      }                  }              }              else if (line.Contains("Timing Information"))              {                  // Timing Information 4 1 Super__0[0] 128654556603428182 0.0000 0.0000 0.0000 0.0000 0.2500                   Match m = timingInfoRegex.Match(line);                  if (m.Success)                  {                      int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      DateTime createtime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[4].Value);                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi == null)                          return; // we do not keep track of vertices with duplicate scheduling' so these won't show up here                        if (vi.State == ExecutedVertexInstance.VertexState.Started)                      {                          Console.WriteLine("Timing information while vertex is still running " + vi);                          //throw new ClusterException("Timing information for vertex still running: " + vi);                      }                      DateTime last = vi.SetTiming(createtime' m.Groups[5].Value' m.Groups[6].Value' m.Groups[7].Value' m.Groups[8].Value' m.Groups[9].Value);                      if (last > this.lastTimestampSeen)                          this.lastTimestampSeen = last;                      this.ManagerVertex.MarkVertexWasRunning(last);                        try                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              this.UsefulCPUTime += vi.RunningTime;                          else if (vi.RunningTime > TimeSpan.Zero)                              this.WastedCPUTime += vi.RunningTime;                      }                      catch (Exception ex)                      {                          Console.WriteLine("Time value exception: " + ex.Message);                      }                  }                  else                      throw new DryadException("Unmatched timing information line " + line);              }              else if (line.Contains("Process has failed"))              {                  // Process has failed Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 Exitcode 0 status The operation succeeded                  // failedRegex = new Regex(@"Process has failed Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) Exitcode (.*)"'                  Match m = failedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string exitcode = m.Groups[6].Value;                      //string status = m.Groups[7].Value;                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          vi.ExitCode = exitcode;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                          //vi.ErrorString = status;                      }                  }              }              else if (line.Contains("ABORTING:"))              {                  this.AbortingMsg = line.Substring(10);                  this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);              }              else if (line.Contains("Accurate read data"))              {                  Match m = datareadRegex.Match(line);                  if (m.Success)                  {                      this.TotalDataRead = long.Parse(m.Groups[1].Value);                      this.LocalReadData = long.Parse(m.Groups[2].Value);                      this.IntraPodDataRead = long.Parse(m.Groups[3].Value);                      this.CrossPodDataRead = long.Parse(m.Groups[4].Value);                  }              }              else if (line.Contains("<ErrorString>"))              {                  //some errors contains "Error returned from managed runtime invocation"                  //which shows the error is from application code                  Match m = Regex.Match(line' @"\<ErrorString\>(.*)\</ErrorString\>");                  if (m.Success && lastFailedVertex != null)                  {                      lastFailedVertex.AddErrorString(System.Web.HttpUtility.HtmlDecode(m.Groups[1].Value));                  }              }              else if (line.Contains("Canceling"))              {                  // Canceling vertex 1461.0 (Merge__13[258]) due to dependent failure                  Match m = cancelRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string name = m.Groups[3].Value;                        ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              vi.SetState(ExecutedVertexInstance.VertexState.Invalidated);                          else                               vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                      else                      {                          // TODO: this should not be needed' but this is a workaround for a bug in the HPC L2H software                          vi = new ExecutedVertexInstance(this' vertex' version' name' ""' lineTimeStamp);                          vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          this.jobVertices.Add(vi);                      }                      // Process wasn't even started' so there is nothing to cancel                  }              }              else if (line.Contains("Application"))              {                  //the job ends successfully                  Regex endSuccessRegex = new Regex(@"Application completed successfully.");                  //the job failed                  Regex endFailRegex = new Regex(@"Application failed with error code (.*)");                    Match m1 = endFailRegex.Match(line);                    if (m1.Success)                  {                      this.ErrorCode = m1.Groups[1].Value;                      this.ManagerStdoutIncomplete = false;                      this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                  }                  else                  {                      Match m2 = endSuccessRegex.Match(line);                      if (m2.Success)                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                          this.ManagerStdoutIncomplete = false;                      }                  }              }              else if (line.StartsWith("Input"))              {                  // Input vertex %u (%s) had %u read failure%s\n                  Match m = inputFailureRegex.Match(line);                  if (m.Success)                  {                      this.AbortingMsg = line;                  }              }              else if (line.Contains("Vertex"))              {                  // terminationRegex = new Regex(@"Vertex (\d+)\.(\d+) \((.+)\) machine (\S+) guid \{?([-0-9A-F]+)\}? status (.*)"                  Match m = terminationRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(vertex' version);                      if (vi == null)                      {                          Trace.TraceInformation("Could not find vertex {0}.{1} line {2}"' vertex' version' line);                      }                      else                      {                          bool failed = vi.SetTermination(m.Groups[6].Value' lineTimeStamp);                          if (failed)                              this.lastFailedVertex = vi;                      }                  }              }
Magic Number,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseStdoutLine,The following statement contains a magic number: if (line.Contains("Created process execution record"))              {                  Match m = vertexCreatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Created process execution record for vertex (\d+) \((.*)\) v.(\d+) GUID \{?([-A-F0-9]+)\}?                      int number = Int32.Parse(m.Groups[1].Value);                      string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                        // the vertex may be already there' sometimes numbers are reused...                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi == null)                      {                          vi = new ExecutedVertexInstance(this' number' version' name' guid' lineTimeStamp);                          this.jobVertices.Add(vi);                      }                  }                  else                  {                      m = verticesCreatedRegex.Match(line);                      if (m.Success)                      {                          lineTimeStamp = ParseLineTimestamp(line);                            // Created process execution record for vertices (.*) v.(\d+) GUID \{?([-A-F0-9]+)\}?                          // Created process execution record for vertices 192 (Merge__41[0]) 223 (Union__45[0]) v.0 GUID {0297A91C-FFEA-42EA-94AF-CD0163A04D45}                          int version = Int32.Parse(m.Groups[2].Value);                          string vertices = m.Groups[1].Value;                          string guid = m.Groups[3].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                            IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                          foreach (var p in vertexList)                          {                              int number = p.Item2;                              ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                              if (vi == null)                              {                                  vi = new ExecutedVertexInstance(this' number' version' p.Item1' guid' lineTimeStamp);                                  this.jobVertices.Add(vi);                              }                          }                      }                  }              }              else if (line.StartsWith("Creating process"))              {                  Match m = processCreatingRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Creating process for vertex (\d+) \((.*)\\) v.(\d+) GUID \{?([-A-F0-9]+)\}? machine (\w+)                      int number = Int32.Parse(m.Groups[1].Value);                      //string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value;                         ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          this.jobVertices.Remap(vi' guid);                      }                  }              }              else if (line.StartsWith("Process was revoked"))              {                  Match m = revokedRegex.Match(line);                  if (m.Success)                  {                      string oldGuid = m.Groups[1].Value;                      ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(oldGuid);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Revoked);                          string newGuid = m.Groups[2].Value;                          this.jobVertices.Remap(vi' newGuid);                      }                      else                      {                          Trace.TraceInformation("Could not find revoked vertex with guid " + oldGuid);                      }                  }              }              else if (line.StartsWith("---HiPriTime"))              {                  // Scope-specific line which we use to get the i/o information                  // ---HiPriTime D7D51A1F-6693-4378-95FD-FC778A67C632'F52CA694-0202-411E-85E9-0C883E770A0E'SV4_Extract_Split[0]'Completed'ch1sch010331112'2011-05-03 15:26:01.681 PDT'2011-05-03 15:26:01.696 PDT'2011-05-03 15:26:02.118 PDT'2011-05-03 15:26:04.286 PDT'2011-05-03 15:26:07.656 PDT'2011-05-03 15:26:01.696 PDT'97390825'1498630                  string info = line.Substring(13);                  string[] parts = info.Split(''');                  if (parts.Length >= 13)                  {                      long read = long.Parse(parts[11]);                      long written = long.Parse(parts[12]);                      string guid = parts[1];                        ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(guid);                      if (vi != null)                      {                          vi.DataRead = read;                          vi.DataWritten = written;                          this.TotalDataRead += read;                      }                  }              }              else if (line.Contains("Io information"))              {                  // HPC-specific line                  Match m = ioRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.DataRead = long.Parse(m.Groups[4].Value);                          vi.DataWritten = long.Parse(m.Groups[5].Value);                          this.TotalDataRead += vi.DataRead;                      }                  }              }              else if (line.Contains("Process started"))              {                  //those vertices which are being canceled may not be here                  Match m = vertexStartRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        string version = m.Groups[3].Value;                      string guid = m.Groups[4].Value;                      string pid = this.ClusterConfiguration.ExtractPidFromGuid(guid' this.Summary);                      DryadProcessIdentifier identifier = new DryadProcessIdentifier(pid);                      string machine = m.Groups[5].Value;                        // Process started for vertex 4 (Super__0[0]) v.0 GUID {9DDD0B00-C93F-46D2-9073-1CFD27829300} machine sherwood-255                      // Process started for vertices 23 (Merge__29) 24 (Apply__33) v.0 GUID {E945DC5D-9AF6-4732-8770-2A6BF7FA3041} machine sherwood-237                        string vertices = m.Groups[2].Value;                      // This is a list of (number \(name\))* pairs                      // we will assume that the parantheses are matched' or we can't do much                        bool onevertex;                      if (m.Groups[1].Value == "ex")  // one vertEX                          onevertex = true;                      else if (m.Groups[1].Value == "ices")                          onevertex = false;                      else                          throw new DryadException("Can't figure out if one or many vertices");                        IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                        int vertexcount = 0;                      int iversion = int.Parse(version);                        if (lineTimeStamp > this.lastTimestampSeen)                          this.lastTimestampSeen = lineTimeStamp;                      foreach (var p in vertexList)                      {                          int number = p.Item2;                          ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' iversion);                          //new ExecutedVertexInstance(this' number' version' name' identifier' machine' this.lastTimestampSeen);                          if (vi == null)                              Trace.TraceInformation("Could not find information for vertex {0}.{1}"' number' version);                          else                              vi.SetStartInformation(this' machine' this.lastTimestampSeen' identifier' guid);                          vertexcount++;                      }                        if (vertexcount > 1 && onevertex)                          throw new DryadException("Expected one vertex' found " + vertexcount);                  }                  else                  {                      Trace.TraceInformation("Unexpected parsing error on line {0}"' line);                  }              }              else if (line.Contains("Abandoning"))              {                  Match m = vertexAbandonedRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                          vi.SetState(ExecutedVertexInstance.VertexState.Abandoned);                  }              }              else if (line.Contains("Setting"))              {                  Match m = setToFailedlRegex.Match(line);                  if (m.Success)                  {                      // Setting vertex 1461.0 (Merge__13[258]) to failed                      // Setting vertex (\d+)\.(\d+) \((.+)\) to failed(.*)                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          //vi.ErrorString = m.Groups[4].Value;                      }                  }              }              else if (line.Contains("Process was terminated"))              {                  // terminatedRegex = new Regex(@"Process was terminated Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) status (.*)"'                  // Process was terminated Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 status The operation succeeded                  Match m = terminatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          // sometimes successful processes are terminated' because they don't report quickly enough being done                          if (vi.State != ExecutedVertexInstance.VertexState.Successful)                          {                              vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          }                          vi.ErrorString = m.Groups[6].Value;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                  }              }              else if (line.Contains("Timing Information Graph Start Time"))              {                  // Cosmos-specific line                  // Timing Information Graph Start Time 128654556581866096                  Match m = Regex.Match(line' @"Timing Information Graph Start Time (\d+)");                  DateTime createTime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                  this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                  this.lastTimestampSeen = createTime;              }              else if (line.StartsWith("Start time: "))              {                  // HPC L2H specific line                  // Start time: 04/05/2011 17:25:42.223                  DateTime createTime;                  bool parse = DateTime.TryParse(line.Substring("Start time: ".Length)' out createTime);                    if (parse)                  {                      this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                      this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                      this.lastTimestampSeen = createTime;                  }              }              else if (line.Contains("JM Finish time:"))              {                  // Cosmos-specific line                  // JM Finish time: 129140295499437263 2010-03-25T22:25:49.943726Z                  Match m = Regex.Match(line' @"JM Finish time: (\d+)");                  DateTime time = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.lastTimestampSeen = time;                  this.ManagerVertex.End = time;              }              else if (line.StartsWith("Stop time "))              {                  // HPC L2H specific line                  // Stop time (Exit code = 2148734208): 04/05/2011 17:25:46.614                  Regex regex = new Regex(@"Stop time \(Exit code = (.*)\): (.*)");                  Match m = regex.Match(line);                  if (m.Success)                  {                      this.ManagerStdoutIncomplete = false;                        DateTime time;                      bool parse = DateTime.TryParse(m.Groups[2].Value' out time);                      if (parse)                      {                          this.lastTimestampSeen = time;                          this.ManagerVertex.End = time;                      }                        this.ErrorCode = m.Groups[1].Value;                      if (this.ErrorCode == "0")                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                      }                      else                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                      }                  }              }              else if (line.Contains("Timing Information"))              {                  // Timing Information 4 1 Super__0[0] 128654556603428182 0.0000 0.0000 0.0000 0.0000 0.2500                   Match m = timingInfoRegex.Match(line);                  if (m.Success)                  {                      int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      DateTime createtime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[4].Value);                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi == null)                          return; // we do not keep track of vertices with duplicate scheduling' so these won't show up here                        if (vi.State == ExecutedVertexInstance.VertexState.Started)                      {                          Console.WriteLine("Timing information while vertex is still running " + vi);                          //throw new ClusterException("Timing information for vertex still running: " + vi);                      }                      DateTime last = vi.SetTiming(createtime' m.Groups[5].Value' m.Groups[6].Value' m.Groups[7].Value' m.Groups[8].Value' m.Groups[9].Value);                      if (last > this.lastTimestampSeen)                          this.lastTimestampSeen = last;                      this.ManagerVertex.MarkVertexWasRunning(last);                        try                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              this.UsefulCPUTime += vi.RunningTime;                          else if (vi.RunningTime > TimeSpan.Zero)                              this.WastedCPUTime += vi.RunningTime;                      }                      catch (Exception ex)                      {                          Console.WriteLine("Time value exception: " + ex.Message);                      }                  }                  else                      throw new DryadException("Unmatched timing information line " + line);              }              else if (line.Contains("Process has failed"))              {                  // Process has failed Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 Exitcode 0 status The operation succeeded                  // failedRegex = new Regex(@"Process has failed Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) Exitcode (.*)"'                  Match m = failedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string exitcode = m.Groups[6].Value;                      //string status = m.Groups[7].Value;                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          vi.ExitCode = exitcode;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                          //vi.ErrorString = status;                      }                  }              }              else if (line.Contains("ABORTING:"))              {                  this.AbortingMsg = line.Substring(10);                  this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);              }              else if (line.Contains("Accurate read data"))              {                  Match m = datareadRegex.Match(line);                  if (m.Success)                  {                      this.TotalDataRead = long.Parse(m.Groups[1].Value);                      this.LocalReadData = long.Parse(m.Groups[2].Value);                      this.IntraPodDataRead = long.Parse(m.Groups[3].Value);                      this.CrossPodDataRead = long.Parse(m.Groups[4].Value);                  }              }              else if (line.Contains("<ErrorString>"))              {                  //some errors contains "Error returned from managed runtime invocation"                  //which shows the error is from application code                  Match m = Regex.Match(line' @"\<ErrorString\>(.*)\</ErrorString\>");                  if (m.Success && lastFailedVertex != null)                  {                      lastFailedVertex.AddErrorString(System.Web.HttpUtility.HtmlDecode(m.Groups[1].Value));                  }              }              else if (line.Contains("Canceling"))              {                  // Canceling vertex 1461.0 (Merge__13[258]) due to dependent failure                  Match m = cancelRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string name = m.Groups[3].Value;                        ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              vi.SetState(ExecutedVertexInstance.VertexState.Invalidated);                          else                               vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                      else                      {                          // TODO: this should not be needed' but this is a workaround for a bug in the HPC L2H software                          vi = new ExecutedVertexInstance(this' vertex' version' name' ""' lineTimeStamp);                          vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          this.jobVertices.Add(vi);                      }                      // Process wasn't even started' so there is nothing to cancel                  }              }              else if (line.Contains("Application"))              {                  //the job ends successfully                  Regex endSuccessRegex = new Regex(@"Application completed successfully.");                  //the job failed                  Regex endFailRegex = new Regex(@"Application failed with error code (.*)");                    Match m1 = endFailRegex.Match(line);                    if (m1.Success)                  {                      this.ErrorCode = m1.Groups[1].Value;                      this.ManagerStdoutIncomplete = false;                      this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                  }                  else                  {                      Match m2 = endSuccessRegex.Match(line);                      if (m2.Success)                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                          this.ManagerStdoutIncomplete = false;                      }                  }              }              else if (line.StartsWith("Input"))              {                  // Input vertex %u (%s) had %u read failure%s\n                  Match m = inputFailureRegex.Match(line);                  if (m.Success)                  {                      this.AbortingMsg = line;                  }              }              else if (line.Contains("Vertex"))              {                  // terminationRegex = new Regex(@"Vertex (\d+)\.(\d+) \((.+)\) machine (\S+) guid \{?([-0-9A-F]+)\}? status (.*)"                  Match m = terminationRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(vertex' version);                      if (vi == null)                      {                          Trace.TraceInformation("Could not find vertex {0}.{1} line {2}"' vertex' version' line);                      }                      else                      {                          bool failed = vi.SetTermination(m.Groups[6].Value' lineTimeStamp);                          if (failed)                              this.lastFailedVertex = vi;                      }                  }              }
Magic Number,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseStdoutLine,The following statement contains a magic number: if (line.Contains("Created process execution record"))              {                  Match m = vertexCreatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Created process execution record for vertex (\d+) \((.*)\) v.(\d+) GUID \{?([-A-F0-9]+)\}?                      int number = Int32.Parse(m.Groups[1].Value);                      string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                        // the vertex may be already there' sometimes numbers are reused...                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi == null)                      {                          vi = new ExecutedVertexInstance(this' number' version' name' guid' lineTimeStamp);                          this.jobVertices.Add(vi);                      }                  }                  else                  {                      m = verticesCreatedRegex.Match(line);                      if (m.Success)                      {                          lineTimeStamp = ParseLineTimestamp(line);                            // Created process execution record for vertices (.*) v.(\d+) GUID \{?([-A-F0-9]+)\}?                          // Created process execution record for vertices 192 (Merge__41[0]) 223 (Union__45[0]) v.0 GUID {0297A91C-FFEA-42EA-94AF-CD0163A04D45}                          int version = Int32.Parse(m.Groups[2].Value);                          string vertices = m.Groups[1].Value;                          string guid = m.Groups[3].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                            IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                          foreach (var p in vertexList)                          {                              int number = p.Item2;                              ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                              if (vi == null)                              {                                  vi = new ExecutedVertexInstance(this' number' version' p.Item1' guid' lineTimeStamp);                                  this.jobVertices.Add(vi);                              }                          }                      }                  }              }              else if (line.StartsWith("Creating process"))              {                  Match m = processCreatingRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Creating process for vertex (\d+) \((.*)\\) v.(\d+) GUID \{?([-A-F0-9]+)\}? machine (\w+)                      int number = Int32.Parse(m.Groups[1].Value);                      //string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value;                         ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          this.jobVertices.Remap(vi' guid);                      }                  }              }              else if (line.StartsWith("Process was revoked"))              {                  Match m = revokedRegex.Match(line);                  if (m.Success)                  {                      string oldGuid = m.Groups[1].Value;                      ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(oldGuid);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Revoked);                          string newGuid = m.Groups[2].Value;                          this.jobVertices.Remap(vi' newGuid);                      }                      else                      {                          Trace.TraceInformation("Could not find revoked vertex with guid " + oldGuid);                      }                  }              }              else if (line.StartsWith("---HiPriTime"))              {                  // Scope-specific line which we use to get the i/o information                  // ---HiPriTime D7D51A1F-6693-4378-95FD-FC778A67C632'F52CA694-0202-411E-85E9-0C883E770A0E'SV4_Extract_Split[0]'Completed'ch1sch010331112'2011-05-03 15:26:01.681 PDT'2011-05-03 15:26:01.696 PDT'2011-05-03 15:26:02.118 PDT'2011-05-03 15:26:04.286 PDT'2011-05-03 15:26:07.656 PDT'2011-05-03 15:26:01.696 PDT'97390825'1498630                  string info = line.Substring(13);                  string[] parts = info.Split(''');                  if (parts.Length >= 13)                  {                      long read = long.Parse(parts[11]);                      long written = long.Parse(parts[12]);                      string guid = parts[1];                        ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(guid);                      if (vi != null)                      {                          vi.DataRead = read;                          vi.DataWritten = written;                          this.TotalDataRead += read;                      }                  }              }              else if (line.Contains("Io information"))              {                  // HPC-specific line                  Match m = ioRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.DataRead = long.Parse(m.Groups[4].Value);                          vi.DataWritten = long.Parse(m.Groups[5].Value);                          this.TotalDataRead += vi.DataRead;                      }                  }              }              else if (line.Contains("Process started"))              {                  //those vertices which are being canceled may not be here                  Match m = vertexStartRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        string version = m.Groups[3].Value;                      string guid = m.Groups[4].Value;                      string pid = this.ClusterConfiguration.ExtractPidFromGuid(guid' this.Summary);                      DryadProcessIdentifier identifier = new DryadProcessIdentifier(pid);                      string machine = m.Groups[5].Value;                        // Process started for vertex 4 (Super__0[0]) v.0 GUID {9DDD0B00-C93F-46D2-9073-1CFD27829300} machine sherwood-255                      // Process started for vertices 23 (Merge__29) 24 (Apply__33) v.0 GUID {E945DC5D-9AF6-4732-8770-2A6BF7FA3041} machine sherwood-237                        string vertices = m.Groups[2].Value;                      // This is a list of (number \(name\))* pairs                      // we will assume that the parantheses are matched' or we can't do much                        bool onevertex;                      if (m.Groups[1].Value == "ex")  // one vertEX                          onevertex = true;                      else if (m.Groups[1].Value == "ices")                          onevertex = false;                      else                          throw new DryadException("Can't figure out if one or many vertices");                        IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                        int vertexcount = 0;                      int iversion = int.Parse(version);                        if (lineTimeStamp > this.lastTimestampSeen)                          this.lastTimestampSeen = lineTimeStamp;                      foreach (var p in vertexList)                      {                          int number = p.Item2;                          ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' iversion);                          //new ExecutedVertexInstance(this' number' version' name' identifier' machine' this.lastTimestampSeen);                          if (vi == null)                              Trace.TraceInformation("Could not find information for vertex {0}.{1}"' number' version);                          else                              vi.SetStartInformation(this' machine' this.lastTimestampSeen' identifier' guid);                          vertexcount++;                      }                        if (vertexcount > 1 && onevertex)                          throw new DryadException("Expected one vertex' found " + vertexcount);                  }                  else                  {                      Trace.TraceInformation("Unexpected parsing error on line {0}"' line);                  }              }              else if (line.Contains("Abandoning"))              {                  Match m = vertexAbandonedRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                          vi.SetState(ExecutedVertexInstance.VertexState.Abandoned);                  }              }              else if (line.Contains("Setting"))              {                  Match m = setToFailedlRegex.Match(line);                  if (m.Success)                  {                      // Setting vertex 1461.0 (Merge__13[258]) to failed                      // Setting vertex (\d+)\.(\d+) \((.+)\) to failed(.*)                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          //vi.ErrorString = m.Groups[4].Value;                      }                  }              }              else if (line.Contains("Process was terminated"))              {                  // terminatedRegex = new Regex(@"Process was terminated Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) status (.*)"'                  // Process was terminated Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 status The operation succeeded                  Match m = terminatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          // sometimes successful processes are terminated' because they don't report quickly enough being done                          if (vi.State != ExecutedVertexInstance.VertexState.Successful)                          {                              vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          }                          vi.ErrorString = m.Groups[6].Value;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                  }              }              else if (line.Contains("Timing Information Graph Start Time"))              {                  // Cosmos-specific line                  // Timing Information Graph Start Time 128654556581866096                  Match m = Regex.Match(line' @"Timing Information Graph Start Time (\d+)");                  DateTime createTime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                  this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                  this.lastTimestampSeen = createTime;              }              else if (line.StartsWith("Start time: "))              {                  // HPC L2H specific line                  // Start time: 04/05/2011 17:25:42.223                  DateTime createTime;                  bool parse = DateTime.TryParse(line.Substring("Start time: ".Length)' out createTime);                    if (parse)                  {                      this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                      this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                      this.lastTimestampSeen = createTime;                  }              }              else if (line.Contains("JM Finish time:"))              {                  // Cosmos-specific line                  // JM Finish time: 129140295499437263 2010-03-25T22:25:49.943726Z                  Match m = Regex.Match(line' @"JM Finish time: (\d+)");                  DateTime time = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.lastTimestampSeen = time;                  this.ManagerVertex.End = time;              }              else if (line.StartsWith("Stop time "))              {                  // HPC L2H specific line                  // Stop time (Exit code = 2148734208): 04/05/2011 17:25:46.614                  Regex regex = new Regex(@"Stop time \(Exit code = (.*)\): (.*)");                  Match m = regex.Match(line);                  if (m.Success)                  {                      this.ManagerStdoutIncomplete = false;                        DateTime time;                      bool parse = DateTime.TryParse(m.Groups[2].Value' out time);                      if (parse)                      {                          this.lastTimestampSeen = time;                          this.ManagerVertex.End = time;                      }                        this.ErrorCode = m.Groups[1].Value;                      if (this.ErrorCode == "0")                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                      }                      else                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                      }                  }              }              else if (line.Contains("Timing Information"))              {                  // Timing Information 4 1 Super__0[0] 128654556603428182 0.0000 0.0000 0.0000 0.0000 0.2500                   Match m = timingInfoRegex.Match(line);                  if (m.Success)                  {                      int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      DateTime createtime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[4].Value);                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi == null)                          return; // we do not keep track of vertices with duplicate scheduling' so these won't show up here                        if (vi.State == ExecutedVertexInstance.VertexState.Started)                      {                          Console.WriteLine("Timing information while vertex is still running " + vi);                          //throw new ClusterException("Timing information for vertex still running: " + vi);                      }                      DateTime last = vi.SetTiming(createtime' m.Groups[5].Value' m.Groups[6].Value' m.Groups[7].Value' m.Groups[8].Value' m.Groups[9].Value);                      if (last > this.lastTimestampSeen)                          this.lastTimestampSeen = last;                      this.ManagerVertex.MarkVertexWasRunning(last);                        try                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              this.UsefulCPUTime += vi.RunningTime;                          else if (vi.RunningTime > TimeSpan.Zero)                              this.WastedCPUTime += vi.RunningTime;                      }                      catch (Exception ex)                      {                          Console.WriteLine("Time value exception: " + ex.Message);                      }                  }                  else                      throw new DryadException("Unmatched timing information line " + line);              }              else if (line.Contains("Process has failed"))              {                  // Process has failed Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 Exitcode 0 status The operation succeeded                  // failedRegex = new Regex(@"Process has failed Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) Exitcode (.*)"'                  Match m = failedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string exitcode = m.Groups[6].Value;                      //string status = m.Groups[7].Value;                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          vi.ExitCode = exitcode;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                          //vi.ErrorString = status;                      }                  }              }              else if (line.Contains("ABORTING:"))              {                  this.AbortingMsg = line.Substring(10);                  this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);              }              else if (line.Contains("Accurate read data"))              {                  Match m = datareadRegex.Match(line);                  if (m.Success)                  {                      this.TotalDataRead = long.Parse(m.Groups[1].Value);                      this.LocalReadData = long.Parse(m.Groups[2].Value);                      this.IntraPodDataRead = long.Parse(m.Groups[3].Value);                      this.CrossPodDataRead = long.Parse(m.Groups[4].Value);                  }              }              else if (line.Contains("<ErrorString>"))              {                  //some errors contains "Error returned from managed runtime invocation"                  //which shows the error is from application code                  Match m = Regex.Match(line' @"\<ErrorString\>(.*)\</ErrorString\>");                  if (m.Success && lastFailedVertex != null)                  {                      lastFailedVertex.AddErrorString(System.Web.HttpUtility.HtmlDecode(m.Groups[1].Value));                  }              }              else if (line.Contains("Canceling"))              {                  // Canceling vertex 1461.0 (Merge__13[258]) due to dependent failure                  Match m = cancelRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string name = m.Groups[3].Value;                        ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              vi.SetState(ExecutedVertexInstance.VertexState.Invalidated);                          else                               vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                      else                      {                          // TODO: this should not be needed' but this is a workaround for a bug in the HPC L2H software                          vi = new ExecutedVertexInstance(this' vertex' version' name' ""' lineTimeStamp);                          vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          this.jobVertices.Add(vi);                      }                      // Process wasn't even started' so there is nothing to cancel                  }              }              else if (line.Contains("Application"))              {                  //the job ends successfully                  Regex endSuccessRegex = new Regex(@"Application completed successfully.");                  //the job failed                  Regex endFailRegex = new Regex(@"Application failed with error code (.*)");                    Match m1 = endFailRegex.Match(line);                    if (m1.Success)                  {                      this.ErrorCode = m1.Groups[1].Value;                      this.ManagerStdoutIncomplete = false;                      this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                  }                  else                  {                      Match m2 = endSuccessRegex.Match(line);                      if (m2.Success)                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                          this.ManagerStdoutIncomplete = false;                      }                  }              }              else if (line.StartsWith("Input"))              {                  // Input vertex %u (%s) had %u read failure%s\n                  Match m = inputFailureRegex.Match(line);                  if (m.Success)                  {                      this.AbortingMsg = line;                  }              }              else if (line.Contains("Vertex"))              {                  // terminationRegex = new Regex(@"Vertex (\d+)\.(\d+) \((.+)\) machine (\S+) guid \{?([-0-9A-F]+)\}? status (.*)"                  Match m = terminationRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(vertex' version);                      if (vi == null)                      {                          Trace.TraceInformation("Could not find vertex {0}.{1} line {2}"' vertex' version' line);                      }                      else                      {                          bool failed = vi.SetTermination(m.Groups[6].Value' lineTimeStamp);                          if (failed)                              this.lastFailedVertex = vi;                      }                  }              }
Magic Number,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseStdoutLine,The following statement contains a magic number: if (line.Contains("Created process execution record"))              {                  Match m = vertexCreatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Created process execution record for vertex (\d+) \((.*)\) v.(\d+) GUID \{?([-A-F0-9]+)\}?                      int number = Int32.Parse(m.Groups[1].Value);                      string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                        // the vertex may be already there' sometimes numbers are reused...                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi == null)                      {                          vi = new ExecutedVertexInstance(this' number' version' name' guid' lineTimeStamp);                          this.jobVertices.Add(vi);                      }                  }                  else                  {                      m = verticesCreatedRegex.Match(line);                      if (m.Success)                      {                          lineTimeStamp = ParseLineTimestamp(line);                            // Created process execution record for vertices (.*) v.(\d+) GUID \{?([-A-F0-9]+)\}?                          // Created process execution record for vertices 192 (Merge__41[0]) 223 (Union__45[0]) v.0 GUID {0297A91C-FFEA-42EA-94AF-CD0163A04D45}                          int version = Int32.Parse(m.Groups[2].Value);                          string vertices = m.Groups[1].Value;                          string guid = m.Groups[3].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                            IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                          foreach (var p in vertexList)                          {                              int number = p.Item2;                              ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                              if (vi == null)                              {                                  vi = new ExecutedVertexInstance(this' number' version' p.Item1' guid' lineTimeStamp);                                  this.jobVertices.Add(vi);                              }                          }                      }                  }              }              else if (line.StartsWith("Creating process"))              {                  Match m = processCreatingRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Creating process for vertex (\d+) \((.*)\\) v.(\d+) GUID \{?([-A-F0-9]+)\}? machine (\w+)                      int number = Int32.Parse(m.Groups[1].Value);                      //string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value;                         ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          this.jobVertices.Remap(vi' guid);                      }                  }              }              else if (line.StartsWith("Process was revoked"))              {                  Match m = revokedRegex.Match(line);                  if (m.Success)                  {                      string oldGuid = m.Groups[1].Value;                      ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(oldGuid);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Revoked);                          string newGuid = m.Groups[2].Value;                          this.jobVertices.Remap(vi' newGuid);                      }                      else                      {                          Trace.TraceInformation("Could not find revoked vertex with guid " + oldGuid);                      }                  }              }              else if (line.StartsWith("---HiPriTime"))              {                  // Scope-specific line which we use to get the i/o information                  // ---HiPriTime D7D51A1F-6693-4378-95FD-FC778A67C632'F52CA694-0202-411E-85E9-0C883E770A0E'SV4_Extract_Split[0]'Completed'ch1sch010331112'2011-05-03 15:26:01.681 PDT'2011-05-03 15:26:01.696 PDT'2011-05-03 15:26:02.118 PDT'2011-05-03 15:26:04.286 PDT'2011-05-03 15:26:07.656 PDT'2011-05-03 15:26:01.696 PDT'97390825'1498630                  string info = line.Substring(13);                  string[] parts = info.Split(''');                  if (parts.Length >= 13)                  {                      long read = long.Parse(parts[11]);                      long written = long.Parse(parts[12]);                      string guid = parts[1];                        ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(guid);                      if (vi != null)                      {                          vi.DataRead = read;                          vi.DataWritten = written;                          this.TotalDataRead += read;                      }                  }              }              else if (line.Contains("Io information"))              {                  // HPC-specific line                  Match m = ioRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.DataRead = long.Parse(m.Groups[4].Value);                          vi.DataWritten = long.Parse(m.Groups[5].Value);                          this.TotalDataRead += vi.DataRead;                      }                  }              }              else if (line.Contains("Process started"))              {                  //those vertices which are being canceled may not be here                  Match m = vertexStartRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        string version = m.Groups[3].Value;                      string guid = m.Groups[4].Value;                      string pid = this.ClusterConfiguration.ExtractPidFromGuid(guid' this.Summary);                      DryadProcessIdentifier identifier = new DryadProcessIdentifier(pid);                      string machine = m.Groups[5].Value;                        // Process started for vertex 4 (Super__0[0]) v.0 GUID {9DDD0B00-C93F-46D2-9073-1CFD27829300} machine sherwood-255                      // Process started for vertices 23 (Merge__29) 24 (Apply__33) v.0 GUID {E945DC5D-9AF6-4732-8770-2A6BF7FA3041} machine sherwood-237                        string vertices = m.Groups[2].Value;                      // This is a list of (number \(name\))* pairs                      // we will assume that the parantheses are matched' or we can't do much                        bool onevertex;                      if (m.Groups[1].Value == "ex")  // one vertEX                          onevertex = true;                      else if (m.Groups[1].Value == "ices")                          onevertex = false;                      else                          throw new DryadException("Can't figure out if one or many vertices");                        IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                        int vertexcount = 0;                      int iversion = int.Parse(version);                        if (lineTimeStamp > this.lastTimestampSeen)                          this.lastTimestampSeen = lineTimeStamp;                      foreach (var p in vertexList)                      {                          int number = p.Item2;                          ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' iversion);                          //new ExecutedVertexInstance(this' number' version' name' identifier' machine' this.lastTimestampSeen);                          if (vi == null)                              Trace.TraceInformation("Could not find information for vertex {0}.{1}"' number' version);                          else                              vi.SetStartInformation(this' machine' this.lastTimestampSeen' identifier' guid);                          vertexcount++;                      }                        if (vertexcount > 1 && onevertex)                          throw new DryadException("Expected one vertex' found " + vertexcount);                  }                  else                  {                      Trace.TraceInformation("Unexpected parsing error on line {0}"' line);                  }              }              else if (line.Contains("Abandoning"))              {                  Match m = vertexAbandonedRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                          vi.SetState(ExecutedVertexInstance.VertexState.Abandoned);                  }              }              else if (line.Contains("Setting"))              {                  Match m = setToFailedlRegex.Match(line);                  if (m.Success)                  {                      // Setting vertex 1461.0 (Merge__13[258]) to failed                      // Setting vertex (\d+)\.(\d+) \((.+)\) to failed(.*)                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          //vi.ErrorString = m.Groups[4].Value;                      }                  }              }              else if (line.Contains("Process was terminated"))              {                  // terminatedRegex = new Regex(@"Process was terminated Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) status (.*)"'                  // Process was terminated Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 status The operation succeeded                  Match m = terminatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          // sometimes successful processes are terminated' because they don't report quickly enough being done                          if (vi.State != ExecutedVertexInstance.VertexState.Successful)                          {                              vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          }                          vi.ErrorString = m.Groups[6].Value;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                  }              }              else if (line.Contains("Timing Information Graph Start Time"))              {                  // Cosmos-specific line                  // Timing Information Graph Start Time 128654556581866096                  Match m = Regex.Match(line' @"Timing Information Graph Start Time (\d+)");                  DateTime createTime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                  this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                  this.lastTimestampSeen = createTime;              }              else if (line.StartsWith("Start time: "))              {                  // HPC L2H specific line                  // Start time: 04/05/2011 17:25:42.223                  DateTime createTime;                  bool parse = DateTime.TryParse(line.Substring("Start time: ".Length)' out createTime);                    if (parse)                  {                      this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                      this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                      this.lastTimestampSeen = createTime;                  }              }              else if (line.Contains("JM Finish time:"))              {                  // Cosmos-specific line                  // JM Finish time: 129140295499437263 2010-03-25T22:25:49.943726Z                  Match m = Regex.Match(line' @"JM Finish time: (\d+)");                  DateTime time = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.lastTimestampSeen = time;                  this.ManagerVertex.End = time;              }              else if (line.StartsWith("Stop time "))              {                  // HPC L2H specific line                  // Stop time (Exit code = 2148734208): 04/05/2011 17:25:46.614                  Regex regex = new Regex(@"Stop time \(Exit code = (.*)\): (.*)");                  Match m = regex.Match(line);                  if (m.Success)                  {                      this.ManagerStdoutIncomplete = false;                        DateTime time;                      bool parse = DateTime.TryParse(m.Groups[2].Value' out time);                      if (parse)                      {                          this.lastTimestampSeen = time;                          this.ManagerVertex.End = time;                      }                        this.ErrorCode = m.Groups[1].Value;                      if (this.ErrorCode == "0")                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                      }                      else                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                      }                  }              }              else if (line.Contains("Timing Information"))              {                  // Timing Information 4 1 Super__0[0] 128654556603428182 0.0000 0.0000 0.0000 0.0000 0.2500                   Match m = timingInfoRegex.Match(line);                  if (m.Success)                  {                      int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      DateTime createtime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[4].Value);                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi == null)                          return; // we do not keep track of vertices with duplicate scheduling' so these won't show up here                        if (vi.State == ExecutedVertexInstance.VertexState.Started)                      {                          Console.WriteLine("Timing information while vertex is still running " + vi);                          //throw new ClusterException("Timing information for vertex still running: " + vi);                      }                      DateTime last = vi.SetTiming(createtime' m.Groups[5].Value' m.Groups[6].Value' m.Groups[7].Value' m.Groups[8].Value' m.Groups[9].Value);                      if (last > this.lastTimestampSeen)                          this.lastTimestampSeen = last;                      this.ManagerVertex.MarkVertexWasRunning(last);                        try                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              this.UsefulCPUTime += vi.RunningTime;                          else if (vi.RunningTime > TimeSpan.Zero)                              this.WastedCPUTime += vi.RunningTime;                      }                      catch (Exception ex)                      {                          Console.WriteLine("Time value exception: " + ex.Message);                      }                  }                  else                      throw new DryadException("Unmatched timing information line " + line);              }              else if (line.Contains("Process has failed"))              {                  // Process has failed Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 Exitcode 0 status The operation succeeded                  // failedRegex = new Regex(@"Process has failed Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) Exitcode (.*)"'                  Match m = failedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string exitcode = m.Groups[6].Value;                      //string status = m.Groups[7].Value;                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          vi.ExitCode = exitcode;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                          //vi.ErrorString = status;                      }                  }              }              else if (line.Contains("ABORTING:"))              {                  this.AbortingMsg = line.Substring(10);                  this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);              }              else if (line.Contains("Accurate read data"))              {                  Match m = datareadRegex.Match(line);                  if (m.Success)                  {                      this.TotalDataRead = long.Parse(m.Groups[1].Value);                      this.LocalReadData = long.Parse(m.Groups[2].Value);                      this.IntraPodDataRead = long.Parse(m.Groups[3].Value);                      this.CrossPodDataRead = long.Parse(m.Groups[4].Value);                  }              }              else if (line.Contains("<ErrorString>"))              {                  //some errors contains "Error returned from managed runtime invocation"                  //which shows the error is from application code                  Match m = Regex.Match(line' @"\<ErrorString\>(.*)\</ErrorString\>");                  if (m.Success && lastFailedVertex != null)                  {                      lastFailedVertex.AddErrorString(System.Web.HttpUtility.HtmlDecode(m.Groups[1].Value));                  }              }              else if (line.Contains("Canceling"))              {                  // Canceling vertex 1461.0 (Merge__13[258]) due to dependent failure                  Match m = cancelRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string name = m.Groups[3].Value;                        ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              vi.SetState(ExecutedVertexInstance.VertexState.Invalidated);                          else                               vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                      else                      {                          // TODO: this should not be needed' but this is a workaround for a bug in the HPC L2H software                          vi = new ExecutedVertexInstance(this' vertex' version' name' ""' lineTimeStamp);                          vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          this.jobVertices.Add(vi);                      }                      // Process wasn't even started' so there is nothing to cancel                  }              }              else if (line.Contains("Application"))              {                  //the job ends successfully                  Regex endSuccessRegex = new Regex(@"Application completed successfully.");                  //the job failed                  Regex endFailRegex = new Regex(@"Application failed with error code (.*)");                    Match m1 = endFailRegex.Match(line);                    if (m1.Success)                  {                      this.ErrorCode = m1.Groups[1].Value;                      this.ManagerStdoutIncomplete = false;                      this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                  }                  else                  {                      Match m2 = endSuccessRegex.Match(line);                      if (m2.Success)                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                          this.ManagerStdoutIncomplete = false;                      }                  }              }              else if (line.StartsWith("Input"))              {                  // Input vertex %u (%s) had %u read failure%s\n                  Match m = inputFailureRegex.Match(line);                  if (m.Success)                  {                      this.AbortingMsg = line;                  }              }              else if (line.Contains("Vertex"))              {                  // terminationRegex = new Regex(@"Vertex (\d+)\.(\d+) \((.+)\) machine (\S+) guid \{?([-0-9A-F]+)\}? status (.*)"                  Match m = terminationRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(vertex' version);                      if (vi == null)                      {                          Trace.TraceInformation("Could not find vertex {0}.{1} line {2}"' vertex' version' line);                      }                      else                      {                          bool failed = vi.SetTermination(m.Groups[6].Value' lineTimeStamp);                          if (failed)                              this.lastFailedVertex = vi;                      }                  }              }
Magic Number,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseStdoutLine,The following statement contains a magic number: if (line.Contains("Created process execution record"))              {                  Match m = vertexCreatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Created process execution record for vertex (\d+) \((.*)\) v.(\d+) GUID \{?([-A-F0-9]+)\}?                      int number = Int32.Parse(m.Groups[1].Value);                      string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                        // the vertex may be already there' sometimes numbers are reused...                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi == null)                      {                          vi = new ExecutedVertexInstance(this' number' version' name' guid' lineTimeStamp);                          this.jobVertices.Add(vi);                      }                  }                  else                  {                      m = verticesCreatedRegex.Match(line);                      if (m.Success)                      {                          lineTimeStamp = ParseLineTimestamp(line);                            // Created process execution record for vertices (.*) v.(\d+) GUID \{?([-A-F0-9]+)\}?                          // Created process execution record for vertices 192 (Merge__41[0]) 223 (Union__45[0]) v.0 GUID {0297A91C-FFEA-42EA-94AF-CD0163A04D45}                          int version = Int32.Parse(m.Groups[2].Value);                          string vertices = m.Groups[1].Value;                          string guid = m.Groups[3].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                            IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                          foreach (var p in vertexList)                          {                              int number = p.Item2;                              ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                              if (vi == null)                              {                                  vi = new ExecutedVertexInstance(this' number' version' p.Item1' guid' lineTimeStamp);                                  this.jobVertices.Add(vi);                              }                          }                      }                  }              }              else if (line.StartsWith("Creating process"))              {                  Match m = processCreatingRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Creating process for vertex (\d+) \((.*)\\) v.(\d+) GUID \{?([-A-F0-9]+)\}? machine (\w+)                      int number = Int32.Parse(m.Groups[1].Value);                      //string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value;                         ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          this.jobVertices.Remap(vi' guid);                      }                  }              }              else if (line.StartsWith("Process was revoked"))              {                  Match m = revokedRegex.Match(line);                  if (m.Success)                  {                      string oldGuid = m.Groups[1].Value;                      ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(oldGuid);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Revoked);                          string newGuid = m.Groups[2].Value;                          this.jobVertices.Remap(vi' newGuid);                      }                      else                      {                          Trace.TraceInformation("Could not find revoked vertex with guid " + oldGuid);                      }                  }              }              else if (line.StartsWith("---HiPriTime"))              {                  // Scope-specific line which we use to get the i/o information                  // ---HiPriTime D7D51A1F-6693-4378-95FD-FC778A67C632'F52CA694-0202-411E-85E9-0C883E770A0E'SV4_Extract_Split[0]'Completed'ch1sch010331112'2011-05-03 15:26:01.681 PDT'2011-05-03 15:26:01.696 PDT'2011-05-03 15:26:02.118 PDT'2011-05-03 15:26:04.286 PDT'2011-05-03 15:26:07.656 PDT'2011-05-03 15:26:01.696 PDT'97390825'1498630                  string info = line.Substring(13);                  string[] parts = info.Split(''');                  if (parts.Length >= 13)                  {                      long read = long.Parse(parts[11]);                      long written = long.Parse(parts[12]);                      string guid = parts[1];                        ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(guid);                      if (vi != null)                      {                          vi.DataRead = read;                          vi.DataWritten = written;                          this.TotalDataRead += read;                      }                  }              }              else if (line.Contains("Io information"))              {                  // HPC-specific line                  Match m = ioRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.DataRead = long.Parse(m.Groups[4].Value);                          vi.DataWritten = long.Parse(m.Groups[5].Value);                          this.TotalDataRead += vi.DataRead;                      }                  }              }              else if (line.Contains("Process started"))              {                  //those vertices which are being canceled may not be here                  Match m = vertexStartRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        string version = m.Groups[3].Value;                      string guid = m.Groups[4].Value;                      string pid = this.ClusterConfiguration.ExtractPidFromGuid(guid' this.Summary);                      DryadProcessIdentifier identifier = new DryadProcessIdentifier(pid);                      string machine = m.Groups[5].Value;                        // Process started for vertex 4 (Super__0[0]) v.0 GUID {9DDD0B00-C93F-46D2-9073-1CFD27829300} machine sherwood-255                      // Process started for vertices 23 (Merge__29) 24 (Apply__33) v.0 GUID {E945DC5D-9AF6-4732-8770-2A6BF7FA3041} machine sherwood-237                        string vertices = m.Groups[2].Value;                      // This is a list of (number \(name\))* pairs                      // we will assume that the parantheses are matched' or we can't do much                        bool onevertex;                      if (m.Groups[1].Value == "ex")  // one vertEX                          onevertex = true;                      else if (m.Groups[1].Value == "ices")                          onevertex = false;                      else                          throw new DryadException("Can't figure out if one or many vertices");                        IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                        int vertexcount = 0;                      int iversion = int.Parse(version);                        if (lineTimeStamp > this.lastTimestampSeen)                          this.lastTimestampSeen = lineTimeStamp;                      foreach (var p in vertexList)                      {                          int number = p.Item2;                          ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' iversion);                          //new ExecutedVertexInstance(this' number' version' name' identifier' machine' this.lastTimestampSeen);                          if (vi == null)                              Trace.TraceInformation("Could not find information for vertex {0}.{1}"' number' version);                          else                              vi.SetStartInformation(this' machine' this.lastTimestampSeen' identifier' guid);                          vertexcount++;                      }                        if (vertexcount > 1 && onevertex)                          throw new DryadException("Expected one vertex' found " + vertexcount);                  }                  else                  {                      Trace.TraceInformation("Unexpected parsing error on line {0}"' line);                  }              }              else if (line.Contains("Abandoning"))              {                  Match m = vertexAbandonedRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                          vi.SetState(ExecutedVertexInstance.VertexState.Abandoned);                  }              }              else if (line.Contains("Setting"))              {                  Match m = setToFailedlRegex.Match(line);                  if (m.Success)                  {                      // Setting vertex 1461.0 (Merge__13[258]) to failed                      // Setting vertex (\d+)\.(\d+) \((.+)\) to failed(.*)                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          //vi.ErrorString = m.Groups[4].Value;                      }                  }              }              else if (line.Contains("Process was terminated"))              {                  // terminatedRegex = new Regex(@"Process was terminated Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) status (.*)"'                  // Process was terminated Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 status The operation succeeded                  Match m = terminatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          // sometimes successful processes are terminated' because they don't report quickly enough being done                          if (vi.State != ExecutedVertexInstance.VertexState.Successful)                          {                              vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          }                          vi.ErrorString = m.Groups[6].Value;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                  }              }              else if (line.Contains("Timing Information Graph Start Time"))              {                  // Cosmos-specific line                  // Timing Information Graph Start Time 128654556581866096                  Match m = Regex.Match(line' @"Timing Information Graph Start Time (\d+)");                  DateTime createTime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                  this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                  this.lastTimestampSeen = createTime;              }              else if (line.StartsWith("Start time: "))              {                  // HPC L2H specific line                  // Start time: 04/05/2011 17:25:42.223                  DateTime createTime;                  bool parse = DateTime.TryParse(line.Substring("Start time: ".Length)' out createTime);                    if (parse)                  {                      this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                      this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                      this.lastTimestampSeen = createTime;                  }              }              else if (line.Contains("JM Finish time:"))              {                  // Cosmos-specific line                  // JM Finish time: 129140295499437263 2010-03-25T22:25:49.943726Z                  Match m = Regex.Match(line' @"JM Finish time: (\d+)");                  DateTime time = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.lastTimestampSeen = time;                  this.ManagerVertex.End = time;              }              else if (line.StartsWith("Stop time "))              {                  // HPC L2H specific line                  // Stop time (Exit code = 2148734208): 04/05/2011 17:25:46.614                  Regex regex = new Regex(@"Stop time \(Exit code = (.*)\): (.*)");                  Match m = regex.Match(line);                  if (m.Success)                  {                      this.ManagerStdoutIncomplete = false;                        DateTime time;                      bool parse = DateTime.TryParse(m.Groups[2].Value' out time);                      if (parse)                      {                          this.lastTimestampSeen = time;                          this.ManagerVertex.End = time;                      }                        this.ErrorCode = m.Groups[1].Value;                      if (this.ErrorCode == "0")                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                      }                      else                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                      }                  }              }              else if (line.Contains("Timing Information"))              {                  // Timing Information 4 1 Super__0[0] 128654556603428182 0.0000 0.0000 0.0000 0.0000 0.2500                   Match m = timingInfoRegex.Match(line);                  if (m.Success)                  {                      int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      DateTime createtime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[4].Value);                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi == null)                          return; // we do not keep track of vertices with duplicate scheduling' so these won't show up here                        if (vi.State == ExecutedVertexInstance.VertexState.Started)                      {                          Console.WriteLine("Timing information while vertex is still running " + vi);                          //throw new ClusterException("Timing information for vertex still running: " + vi);                      }                      DateTime last = vi.SetTiming(createtime' m.Groups[5].Value' m.Groups[6].Value' m.Groups[7].Value' m.Groups[8].Value' m.Groups[9].Value);                      if (last > this.lastTimestampSeen)                          this.lastTimestampSeen = last;                      this.ManagerVertex.MarkVertexWasRunning(last);                        try                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              this.UsefulCPUTime += vi.RunningTime;                          else if (vi.RunningTime > TimeSpan.Zero)                              this.WastedCPUTime += vi.RunningTime;                      }                      catch (Exception ex)                      {                          Console.WriteLine("Time value exception: " + ex.Message);                      }                  }                  else                      throw new DryadException("Unmatched timing information line " + line);              }              else if (line.Contains("Process has failed"))              {                  // Process has failed Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 Exitcode 0 status The operation succeeded                  // failedRegex = new Regex(@"Process has failed Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) Exitcode (.*)"'                  Match m = failedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string exitcode = m.Groups[6].Value;                      //string status = m.Groups[7].Value;                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          vi.ExitCode = exitcode;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                          //vi.ErrorString = status;                      }                  }              }              else if (line.Contains("ABORTING:"))              {                  this.AbortingMsg = line.Substring(10);                  this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);              }              else if (line.Contains("Accurate read data"))              {                  Match m = datareadRegex.Match(line);                  if (m.Success)                  {                      this.TotalDataRead = long.Parse(m.Groups[1].Value);                      this.LocalReadData = long.Parse(m.Groups[2].Value);                      this.IntraPodDataRead = long.Parse(m.Groups[3].Value);                      this.CrossPodDataRead = long.Parse(m.Groups[4].Value);                  }              }              else if (line.Contains("<ErrorString>"))              {                  //some errors contains "Error returned from managed runtime invocation"                  //which shows the error is from application code                  Match m = Regex.Match(line' @"\<ErrorString\>(.*)\</ErrorString\>");                  if (m.Success && lastFailedVertex != null)                  {                      lastFailedVertex.AddErrorString(System.Web.HttpUtility.HtmlDecode(m.Groups[1].Value));                  }              }              else if (line.Contains("Canceling"))              {                  // Canceling vertex 1461.0 (Merge__13[258]) due to dependent failure                  Match m = cancelRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string name = m.Groups[3].Value;                        ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              vi.SetState(ExecutedVertexInstance.VertexState.Invalidated);                          else                               vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                      else                      {                          // TODO: this should not be needed' but this is a workaround for a bug in the HPC L2H software                          vi = new ExecutedVertexInstance(this' vertex' version' name' ""' lineTimeStamp);                          vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          this.jobVertices.Add(vi);                      }                      // Process wasn't even started' so there is nothing to cancel                  }              }              else if (line.Contains("Application"))              {                  //the job ends successfully                  Regex endSuccessRegex = new Regex(@"Application completed successfully.");                  //the job failed                  Regex endFailRegex = new Regex(@"Application failed with error code (.*)");                    Match m1 = endFailRegex.Match(line);                    if (m1.Success)                  {                      this.ErrorCode = m1.Groups[1].Value;                      this.ManagerStdoutIncomplete = false;                      this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                  }                  else                  {                      Match m2 = endSuccessRegex.Match(line);                      if (m2.Success)                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                          this.ManagerStdoutIncomplete = false;                      }                  }              }              else if (line.StartsWith("Input"))              {                  // Input vertex %u (%s) had %u read failure%s\n                  Match m = inputFailureRegex.Match(line);                  if (m.Success)                  {                      this.AbortingMsg = line;                  }              }              else if (line.Contains("Vertex"))              {                  // terminationRegex = new Regex(@"Vertex (\d+)\.(\d+) \((.+)\) machine (\S+) guid \{?([-0-9A-F]+)\}? status (.*)"                  Match m = terminationRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(vertex' version);                      if (vi == null)                      {                          Trace.TraceInformation("Could not find vertex {0}.{1} line {2}"' vertex' version' line);                      }                      else                      {                          bool failed = vi.SetTermination(m.Groups[6].Value' lineTimeStamp);                          if (failed)                              this.lastFailedVertex = vi;                      }                  }              }
Magic Number,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseStdoutLine,The following statement contains a magic number: if (line.Contains("Created process execution record"))              {                  Match m = vertexCreatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Created process execution record for vertex (\d+) \((.*)\) v.(\d+) GUID \{?([-A-F0-9]+)\}?                      int number = Int32.Parse(m.Groups[1].Value);                      string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                        // the vertex may be already there' sometimes numbers are reused...                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi == null)                      {                          vi = new ExecutedVertexInstance(this' number' version' name' guid' lineTimeStamp);                          this.jobVertices.Add(vi);                      }                  }                  else                  {                      m = verticesCreatedRegex.Match(line);                      if (m.Success)                      {                          lineTimeStamp = ParseLineTimestamp(line);                            // Created process execution record for vertices (.*) v.(\d+) GUID \{?([-A-F0-9]+)\}?                          // Created process execution record for vertices 192 (Merge__41[0]) 223 (Union__45[0]) v.0 GUID {0297A91C-FFEA-42EA-94AF-CD0163A04D45}                          int version = Int32.Parse(m.Groups[2].Value);                          string vertices = m.Groups[1].Value;                          string guid = m.Groups[3].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                            IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                          foreach (var p in vertexList)                          {                              int number = p.Item2;                              ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                              if (vi == null)                              {                                  vi = new ExecutedVertexInstance(this' number' version' p.Item1' guid' lineTimeStamp);                                  this.jobVertices.Add(vi);                              }                          }                      }                  }              }              else if (line.StartsWith("Creating process"))              {                  Match m = processCreatingRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Creating process for vertex (\d+) \((.*)\\) v.(\d+) GUID \{?([-A-F0-9]+)\}? machine (\w+)                      int number = Int32.Parse(m.Groups[1].Value);                      //string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value;                         ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          this.jobVertices.Remap(vi' guid);                      }                  }              }              else if (line.StartsWith("Process was revoked"))              {                  Match m = revokedRegex.Match(line);                  if (m.Success)                  {                      string oldGuid = m.Groups[1].Value;                      ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(oldGuid);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Revoked);                          string newGuid = m.Groups[2].Value;                          this.jobVertices.Remap(vi' newGuid);                      }                      else                      {                          Trace.TraceInformation("Could not find revoked vertex with guid " + oldGuid);                      }                  }              }              else if (line.StartsWith("---HiPriTime"))              {                  // Scope-specific line which we use to get the i/o information                  // ---HiPriTime D7D51A1F-6693-4378-95FD-FC778A67C632'F52CA694-0202-411E-85E9-0C883E770A0E'SV4_Extract_Split[0]'Completed'ch1sch010331112'2011-05-03 15:26:01.681 PDT'2011-05-03 15:26:01.696 PDT'2011-05-03 15:26:02.118 PDT'2011-05-03 15:26:04.286 PDT'2011-05-03 15:26:07.656 PDT'2011-05-03 15:26:01.696 PDT'97390825'1498630                  string info = line.Substring(13);                  string[] parts = info.Split(''');                  if (parts.Length >= 13)                  {                      long read = long.Parse(parts[11]);                      long written = long.Parse(parts[12]);                      string guid = parts[1];                        ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(guid);                      if (vi != null)                      {                          vi.DataRead = read;                          vi.DataWritten = written;                          this.TotalDataRead += read;                      }                  }              }              else if (line.Contains("Io information"))              {                  // HPC-specific line                  Match m = ioRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.DataRead = long.Parse(m.Groups[4].Value);                          vi.DataWritten = long.Parse(m.Groups[5].Value);                          this.TotalDataRead += vi.DataRead;                      }                  }              }              else if (line.Contains("Process started"))              {                  //those vertices which are being canceled may not be here                  Match m = vertexStartRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        string version = m.Groups[3].Value;                      string guid = m.Groups[4].Value;                      string pid = this.ClusterConfiguration.ExtractPidFromGuid(guid' this.Summary);                      DryadProcessIdentifier identifier = new DryadProcessIdentifier(pid);                      string machine = m.Groups[5].Value;                        // Process started for vertex 4 (Super__0[0]) v.0 GUID {9DDD0B00-C93F-46D2-9073-1CFD27829300} machine sherwood-255                      // Process started for vertices 23 (Merge__29) 24 (Apply__33) v.0 GUID {E945DC5D-9AF6-4732-8770-2A6BF7FA3041} machine sherwood-237                        string vertices = m.Groups[2].Value;                      // This is a list of (number \(name\))* pairs                      // we will assume that the parantheses are matched' or we can't do much                        bool onevertex;                      if (m.Groups[1].Value == "ex")  // one vertEX                          onevertex = true;                      else if (m.Groups[1].Value == "ices")                          onevertex = false;                      else                          throw new DryadException("Can't figure out if one or many vertices");                        IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                        int vertexcount = 0;                      int iversion = int.Parse(version);                        if (lineTimeStamp > this.lastTimestampSeen)                          this.lastTimestampSeen = lineTimeStamp;                      foreach (var p in vertexList)                      {                          int number = p.Item2;                          ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' iversion);                          //new ExecutedVertexInstance(this' number' version' name' identifier' machine' this.lastTimestampSeen);                          if (vi == null)                              Trace.TraceInformation("Could not find information for vertex {0}.{1}"' number' version);                          else                              vi.SetStartInformation(this' machine' this.lastTimestampSeen' identifier' guid);                          vertexcount++;                      }                        if (vertexcount > 1 && onevertex)                          throw new DryadException("Expected one vertex' found " + vertexcount);                  }                  else                  {                      Trace.TraceInformation("Unexpected parsing error on line {0}"' line);                  }              }              else if (line.Contains("Abandoning"))              {                  Match m = vertexAbandonedRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                          vi.SetState(ExecutedVertexInstance.VertexState.Abandoned);                  }              }              else if (line.Contains("Setting"))              {                  Match m = setToFailedlRegex.Match(line);                  if (m.Success)                  {                      // Setting vertex 1461.0 (Merge__13[258]) to failed                      // Setting vertex (\d+)\.(\d+) \((.+)\) to failed(.*)                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          //vi.ErrorString = m.Groups[4].Value;                      }                  }              }              else if (line.Contains("Process was terminated"))              {                  // terminatedRegex = new Regex(@"Process was terminated Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) status (.*)"'                  // Process was terminated Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 status The operation succeeded                  Match m = terminatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          // sometimes successful processes are terminated' because they don't report quickly enough being done                          if (vi.State != ExecutedVertexInstance.VertexState.Successful)                          {                              vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          }                          vi.ErrorString = m.Groups[6].Value;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                  }              }              else if (line.Contains("Timing Information Graph Start Time"))              {                  // Cosmos-specific line                  // Timing Information Graph Start Time 128654556581866096                  Match m = Regex.Match(line' @"Timing Information Graph Start Time (\d+)");                  DateTime createTime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                  this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                  this.lastTimestampSeen = createTime;              }              else if (line.StartsWith("Start time: "))              {                  // HPC L2H specific line                  // Start time: 04/05/2011 17:25:42.223                  DateTime createTime;                  bool parse = DateTime.TryParse(line.Substring("Start time: ".Length)' out createTime);                    if (parse)                  {                      this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                      this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                      this.lastTimestampSeen = createTime;                  }              }              else if (line.Contains("JM Finish time:"))              {                  // Cosmos-specific line                  // JM Finish time: 129140295499437263 2010-03-25T22:25:49.943726Z                  Match m = Regex.Match(line' @"JM Finish time: (\d+)");                  DateTime time = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.lastTimestampSeen = time;                  this.ManagerVertex.End = time;              }              else if (line.StartsWith("Stop time "))              {                  // HPC L2H specific line                  // Stop time (Exit code = 2148734208): 04/05/2011 17:25:46.614                  Regex regex = new Regex(@"Stop time \(Exit code = (.*)\): (.*)");                  Match m = regex.Match(line);                  if (m.Success)                  {                      this.ManagerStdoutIncomplete = false;                        DateTime time;                      bool parse = DateTime.TryParse(m.Groups[2].Value' out time);                      if (parse)                      {                          this.lastTimestampSeen = time;                          this.ManagerVertex.End = time;                      }                        this.ErrorCode = m.Groups[1].Value;                      if (this.ErrorCode == "0")                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                      }                      else                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                      }                  }              }              else if (line.Contains("Timing Information"))              {                  // Timing Information 4 1 Super__0[0] 128654556603428182 0.0000 0.0000 0.0000 0.0000 0.2500                   Match m = timingInfoRegex.Match(line);                  if (m.Success)                  {                      int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      DateTime createtime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[4].Value);                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi == null)                          return; // we do not keep track of vertices with duplicate scheduling' so these won't show up here                        if (vi.State == ExecutedVertexInstance.VertexState.Started)                      {                          Console.WriteLine("Timing information while vertex is still running " + vi);                          //throw new ClusterException("Timing information for vertex still running: " + vi);                      }                      DateTime last = vi.SetTiming(createtime' m.Groups[5].Value' m.Groups[6].Value' m.Groups[7].Value' m.Groups[8].Value' m.Groups[9].Value);                      if (last > this.lastTimestampSeen)                          this.lastTimestampSeen = last;                      this.ManagerVertex.MarkVertexWasRunning(last);                        try                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              this.UsefulCPUTime += vi.RunningTime;                          else if (vi.RunningTime > TimeSpan.Zero)                              this.WastedCPUTime += vi.RunningTime;                      }                      catch (Exception ex)                      {                          Console.WriteLine("Time value exception: " + ex.Message);                      }                  }                  else                      throw new DryadException("Unmatched timing information line " + line);              }              else if (line.Contains("Process has failed"))              {                  // Process has failed Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 Exitcode 0 status The operation succeeded                  // failedRegex = new Regex(@"Process has failed Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) Exitcode (.*)"'                  Match m = failedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string exitcode = m.Groups[6].Value;                      //string status = m.Groups[7].Value;                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          vi.ExitCode = exitcode;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                          //vi.ErrorString = status;                      }                  }              }              else if (line.Contains("ABORTING:"))              {                  this.AbortingMsg = line.Substring(10);                  this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);              }              else if (line.Contains("Accurate read data"))              {                  Match m = datareadRegex.Match(line);                  if (m.Success)                  {                      this.TotalDataRead = long.Parse(m.Groups[1].Value);                      this.LocalReadData = long.Parse(m.Groups[2].Value);                      this.IntraPodDataRead = long.Parse(m.Groups[3].Value);                      this.CrossPodDataRead = long.Parse(m.Groups[4].Value);                  }              }              else if (line.Contains("<ErrorString>"))              {                  //some errors contains "Error returned from managed runtime invocation"                  //which shows the error is from application code                  Match m = Regex.Match(line' @"\<ErrorString\>(.*)\</ErrorString\>");                  if (m.Success && lastFailedVertex != null)                  {                      lastFailedVertex.AddErrorString(System.Web.HttpUtility.HtmlDecode(m.Groups[1].Value));                  }              }              else if (line.Contains("Canceling"))              {                  // Canceling vertex 1461.0 (Merge__13[258]) due to dependent failure                  Match m = cancelRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string name = m.Groups[3].Value;                        ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              vi.SetState(ExecutedVertexInstance.VertexState.Invalidated);                          else                               vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                      else                      {                          // TODO: this should not be needed' but this is a workaround for a bug in the HPC L2H software                          vi = new ExecutedVertexInstance(this' vertex' version' name' ""' lineTimeStamp);                          vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          this.jobVertices.Add(vi);                      }                      // Process wasn't even started' so there is nothing to cancel                  }              }              else if (line.Contains("Application"))              {                  //the job ends successfully                  Regex endSuccessRegex = new Regex(@"Application completed successfully.");                  //the job failed                  Regex endFailRegex = new Regex(@"Application failed with error code (.*)");                    Match m1 = endFailRegex.Match(line);                    if (m1.Success)                  {                      this.ErrorCode = m1.Groups[1].Value;                      this.ManagerStdoutIncomplete = false;                      this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                  }                  else                  {                      Match m2 = endSuccessRegex.Match(line);                      if (m2.Success)                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                          this.ManagerStdoutIncomplete = false;                      }                  }              }              else if (line.StartsWith("Input"))              {                  // Input vertex %u (%s) had %u read failure%s\n                  Match m = inputFailureRegex.Match(line);                  if (m.Success)                  {                      this.AbortingMsg = line;                  }              }              else if (line.Contains("Vertex"))              {                  // terminationRegex = new Regex(@"Vertex (\d+)\.(\d+) \((.+)\) machine (\S+) guid \{?([-0-9A-F]+)\}? status (.*)"                  Match m = terminationRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(vertex' version);                      if (vi == null)                      {                          Trace.TraceInformation("Could not find vertex {0}.{1} line {2}"' vertex' version' line);                      }                      else                      {                          bool failed = vi.SetTermination(m.Groups[6].Value' lineTimeStamp);                          if (failed)                              this.lastFailedVertex = vi;                      }                  }              }
Magic Number,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseStdoutLine,The following statement contains a magic number: if (line.Contains("Created process execution record"))              {                  Match m = vertexCreatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Created process execution record for vertex (\d+) \((.*)\) v.(\d+) GUID \{?([-A-F0-9]+)\}?                      int number = Int32.Parse(m.Groups[1].Value);                      string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                        // the vertex may be already there' sometimes numbers are reused...                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi == null)                      {                          vi = new ExecutedVertexInstance(this' number' version' name' guid' lineTimeStamp);                          this.jobVertices.Add(vi);                      }                  }                  else                  {                      m = verticesCreatedRegex.Match(line);                      if (m.Success)                      {                          lineTimeStamp = ParseLineTimestamp(line);                            // Created process execution record for vertices (.*) v.(\d+) GUID \{?([-A-F0-9]+)\}?                          // Created process execution record for vertices 192 (Merge__41[0]) 223 (Union__45[0]) v.0 GUID {0297A91C-FFEA-42EA-94AF-CD0163A04D45}                          int version = Int32.Parse(m.Groups[2].Value);                          string vertices = m.Groups[1].Value;                          string guid = m.Groups[3].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                            IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                          foreach (var p in vertexList)                          {                              int number = p.Item2;                              ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                              if (vi == null)                              {                                  vi = new ExecutedVertexInstance(this' number' version' p.Item1' guid' lineTimeStamp);                                  this.jobVertices.Add(vi);                              }                          }                      }                  }              }              else if (line.StartsWith("Creating process"))              {                  Match m = processCreatingRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Creating process for vertex (\d+) \((.*)\\) v.(\d+) GUID \{?([-A-F0-9]+)\}? machine (\w+)                      int number = Int32.Parse(m.Groups[1].Value);                      //string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value;                         ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          this.jobVertices.Remap(vi' guid);                      }                  }              }              else if (line.StartsWith("Process was revoked"))              {                  Match m = revokedRegex.Match(line);                  if (m.Success)                  {                      string oldGuid = m.Groups[1].Value;                      ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(oldGuid);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Revoked);                          string newGuid = m.Groups[2].Value;                          this.jobVertices.Remap(vi' newGuid);                      }                      else                      {                          Trace.TraceInformation("Could not find revoked vertex with guid " + oldGuid);                      }                  }              }              else if (line.StartsWith("---HiPriTime"))              {                  // Scope-specific line which we use to get the i/o information                  // ---HiPriTime D7D51A1F-6693-4378-95FD-FC778A67C632'F52CA694-0202-411E-85E9-0C883E770A0E'SV4_Extract_Split[0]'Completed'ch1sch010331112'2011-05-03 15:26:01.681 PDT'2011-05-03 15:26:01.696 PDT'2011-05-03 15:26:02.118 PDT'2011-05-03 15:26:04.286 PDT'2011-05-03 15:26:07.656 PDT'2011-05-03 15:26:01.696 PDT'97390825'1498630                  string info = line.Substring(13);                  string[] parts = info.Split(''');                  if (parts.Length >= 13)                  {                      long read = long.Parse(parts[11]);                      long written = long.Parse(parts[12]);                      string guid = parts[1];                        ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(guid);                      if (vi != null)                      {                          vi.DataRead = read;                          vi.DataWritten = written;                          this.TotalDataRead += read;                      }                  }              }              else if (line.Contains("Io information"))              {                  // HPC-specific line                  Match m = ioRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.DataRead = long.Parse(m.Groups[4].Value);                          vi.DataWritten = long.Parse(m.Groups[5].Value);                          this.TotalDataRead += vi.DataRead;                      }                  }              }              else if (line.Contains("Process started"))              {                  //those vertices which are being canceled may not be here                  Match m = vertexStartRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        string version = m.Groups[3].Value;                      string guid = m.Groups[4].Value;                      string pid = this.ClusterConfiguration.ExtractPidFromGuid(guid' this.Summary);                      DryadProcessIdentifier identifier = new DryadProcessIdentifier(pid);                      string machine = m.Groups[5].Value;                        // Process started for vertex 4 (Super__0[0]) v.0 GUID {9DDD0B00-C93F-46D2-9073-1CFD27829300} machine sherwood-255                      // Process started for vertices 23 (Merge__29) 24 (Apply__33) v.0 GUID {E945DC5D-9AF6-4732-8770-2A6BF7FA3041} machine sherwood-237                        string vertices = m.Groups[2].Value;                      // This is a list of (number \(name\))* pairs                      // we will assume that the parantheses are matched' or we can't do much                        bool onevertex;                      if (m.Groups[1].Value == "ex")  // one vertEX                          onevertex = true;                      else if (m.Groups[1].Value == "ices")                          onevertex = false;                      else                          throw new DryadException("Can't figure out if one or many vertices");                        IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                        int vertexcount = 0;                      int iversion = int.Parse(version);                        if (lineTimeStamp > this.lastTimestampSeen)                          this.lastTimestampSeen = lineTimeStamp;                      foreach (var p in vertexList)                      {                          int number = p.Item2;                          ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' iversion);                          //new ExecutedVertexInstance(this' number' version' name' identifier' machine' this.lastTimestampSeen);                          if (vi == null)                              Trace.TraceInformation("Could not find information for vertex {0}.{1}"' number' version);                          else                              vi.SetStartInformation(this' machine' this.lastTimestampSeen' identifier' guid);                          vertexcount++;                      }                        if (vertexcount > 1 && onevertex)                          throw new DryadException("Expected one vertex' found " + vertexcount);                  }                  else                  {                      Trace.TraceInformation("Unexpected parsing error on line {0}"' line);                  }              }              else if (line.Contains("Abandoning"))              {                  Match m = vertexAbandonedRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                          vi.SetState(ExecutedVertexInstance.VertexState.Abandoned);                  }              }              else if (line.Contains("Setting"))              {                  Match m = setToFailedlRegex.Match(line);                  if (m.Success)                  {                      // Setting vertex 1461.0 (Merge__13[258]) to failed                      // Setting vertex (\d+)\.(\d+) \((.+)\) to failed(.*)                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          //vi.ErrorString = m.Groups[4].Value;                      }                  }              }              else if (line.Contains("Process was terminated"))              {                  // terminatedRegex = new Regex(@"Process was terminated Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) status (.*)"'                  // Process was terminated Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 status The operation succeeded                  Match m = terminatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          // sometimes successful processes are terminated' because they don't report quickly enough being done                          if (vi.State != ExecutedVertexInstance.VertexState.Successful)                          {                              vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          }                          vi.ErrorString = m.Groups[6].Value;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                  }              }              else if (line.Contains("Timing Information Graph Start Time"))              {                  // Cosmos-specific line                  // Timing Information Graph Start Time 128654556581866096                  Match m = Regex.Match(line' @"Timing Information Graph Start Time (\d+)");                  DateTime createTime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                  this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                  this.lastTimestampSeen = createTime;              }              else if (line.StartsWith("Start time: "))              {                  // HPC L2H specific line                  // Start time: 04/05/2011 17:25:42.223                  DateTime createTime;                  bool parse = DateTime.TryParse(line.Substring("Start time: ".Length)' out createTime);                    if (parse)                  {                      this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                      this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                      this.lastTimestampSeen = createTime;                  }              }              else if (line.Contains("JM Finish time:"))              {                  // Cosmos-specific line                  // JM Finish time: 129140295499437263 2010-03-25T22:25:49.943726Z                  Match m = Regex.Match(line' @"JM Finish time: (\d+)");                  DateTime time = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.lastTimestampSeen = time;                  this.ManagerVertex.End = time;              }              else if (line.StartsWith("Stop time "))              {                  // HPC L2H specific line                  // Stop time (Exit code = 2148734208): 04/05/2011 17:25:46.614                  Regex regex = new Regex(@"Stop time \(Exit code = (.*)\): (.*)");                  Match m = regex.Match(line);                  if (m.Success)                  {                      this.ManagerStdoutIncomplete = false;                        DateTime time;                      bool parse = DateTime.TryParse(m.Groups[2].Value' out time);                      if (parse)                      {                          this.lastTimestampSeen = time;                          this.ManagerVertex.End = time;                      }                        this.ErrorCode = m.Groups[1].Value;                      if (this.ErrorCode == "0")                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                      }                      else                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                      }                  }              }              else if (line.Contains("Timing Information"))              {                  // Timing Information 4 1 Super__0[0] 128654556603428182 0.0000 0.0000 0.0000 0.0000 0.2500                   Match m = timingInfoRegex.Match(line);                  if (m.Success)                  {                      int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      DateTime createtime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[4].Value);                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi == null)                          return; // we do not keep track of vertices with duplicate scheduling' so these won't show up here                        if (vi.State == ExecutedVertexInstance.VertexState.Started)                      {                          Console.WriteLine("Timing information while vertex is still running " + vi);                          //throw new ClusterException("Timing information for vertex still running: " + vi);                      }                      DateTime last = vi.SetTiming(createtime' m.Groups[5].Value' m.Groups[6].Value' m.Groups[7].Value' m.Groups[8].Value' m.Groups[9].Value);                      if (last > this.lastTimestampSeen)                          this.lastTimestampSeen = last;                      this.ManagerVertex.MarkVertexWasRunning(last);                        try                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              this.UsefulCPUTime += vi.RunningTime;                          else if (vi.RunningTime > TimeSpan.Zero)                              this.WastedCPUTime += vi.RunningTime;                      }                      catch (Exception ex)                      {                          Console.WriteLine("Time value exception: " + ex.Message);                      }                  }                  else                      throw new DryadException("Unmatched timing information line " + line);              }              else if (line.Contains("Process has failed"))              {                  // Process has failed Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 Exitcode 0 status The operation succeeded                  // failedRegex = new Regex(@"Process has failed Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) Exitcode (.*)"'                  Match m = failedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string exitcode = m.Groups[6].Value;                      //string status = m.Groups[7].Value;                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          vi.ExitCode = exitcode;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                          //vi.ErrorString = status;                      }                  }              }              else if (line.Contains("ABORTING:"))              {                  this.AbortingMsg = line.Substring(10);                  this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);              }              else if (line.Contains("Accurate read data"))              {                  Match m = datareadRegex.Match(line);                  if (m.Success)                  {                      this.TotalDataRead = long.Parse(m.Groups[1].Value);                      this.LocalReadData = long.Parse(m.Groups[2].Value);                      this.IntraPodDataRead = long.Parse(m.Groups[3].Value);                      this.CrossPodDataRead = long.Parse(m.Groups[4].Value);                  }              }              else if (line.Contains("<ErrorString>"))              {                  //some errors contains "Error returned from managed runtime invocation"                  //which shows the error is from application code                  Match m = Regex.Match(line' @"\<ErrorString\>(.*)\</ErrorString\>");                  if (m.Success && lastFailedVertex != null)                  {                      lastFailedVertex.AddErrorString(System.Web.HttpUtility.HtmlDecode(m.Groups[1].Value));                  }              }              else if (line.Contains("Canceling"))              {                  // Canceling vertex 1461.0 (Merge__13[258]) due to dependent failure                  Match m = cancelRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string name = m.Groups[3].Value;                        ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              vi.SetState(ExecutedVertexInstance.VertexState.Invalidated);                          else                               vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                      else                      {                          // TODO: this should not be needed' but this is a workaround for a bug in the HPC L2H software                          vi = new ExecutedVertexInstance(this' vertex' version' name' ""' lineTimeStamp);                          vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          this.jobVertices.Add(vi);                      }                      // Process wasn't even started' so there is nothing to cancel                  }              }              else if (line.Contains("Application"))              {                  //the job ends successfully                  Regex endSuccessRegex = new Regex(@"Application completed successfully.");                  //the job failed                  Regex endFailRegex = new Regex(@"Application failed with error code (.*)");                    Match m1 = endFailRegex.Match(line);                    if (m1.Success)                  {                      this.ErrorCode = m1.Groups[1].Value;                      this.ManagerStdoutIncomplete = false;                      this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                  }                  else                  {                      Match m2 = endSuccessRegex.Match(line);                      if (m2.Success)                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                          this.ManagerStdoutIncomplete = false;                      }                  }              }              else if (line.StartsWith("Input"))              {                  // Input vertex %u (%s) had %u read failure%s\n                  Match m = inputFailureRegex.Match(line);                  if (m.Success)                  {                      this.AbortingMsg = line;                  }              }              else if (line.Contains("Vertex"))              {                  // terminationRegex = new Regex(@"Vertex (\d+)\.(\d+) \((.+)\) machine (\S+) guid \{?([-0-9A-F]+)\}? status (.*)"                  Match m = terminationRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(vertex' version);                      if (vi == null)                      {                          Trace.TraceInformation("Could not find vertex {0}.{1} line {2}"' vertex' version' line);                      }                      else                      {                          bool failed = vi.SetTermination(m.Groups[6].Value' lineTimeStamp);                          if (failed)                              this.lastFailedVertex = vi;                      }                  }              }
Magic Number,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseStdoutLine,The following statement contains a magic number: if (line.Contains("Created process execution record"))              {                  Match m = vertexCreatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Created process execution record for vertex (\d+) \((.*)\) v.(\d+) GUID \{?([-A-F0-9]+)\}?                      int number = Int32.Parse(m.Groups[1].Value);                      string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                        // the vertex may be already there' sometimes numbers are reused...                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi == null)                      {                          vi = new ExecutedVertexInstance(this' number' version' name' guid' lineTimeStamp);                          this.jobVertices.Add(vi);                      }                  }                  else                  {                      m = verticesCreatedRegex.Match(line);                      if (m.Success)                      {                          lineTimeStamp = ParseLineTimestamp(line);                            // Created process execution record for vertices (.*) v.(\d+) GUID \{?([-A-F0-9]+)\}?                          // Created process execution record for vertices 192 (Merge__41[0]) 223 (Union__45[0]) v.0 GUID {0297A91C-FFEA-42EA-94AF-CD0163A04D45}                          int version = Int32.Parse(m.Groups[2].Value);                          string vertices = m.Groups[1].Value;                          string guid = m.Groups[3].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                            IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                          foreach (var p in vertexList)                          {                              int number = p.Item2;                              ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                              if (vi == null)                              {                                  vi = new ExecutedVertexInstance(this' number' version' p.Item1' guid' lineTimeStamp);                                  this.jobVertices.Add(vi);                              }                          }                      }                  }              }              else if (line.StartsWith("Creating process"))              {                  Match m = processCreatingRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Creating process for vertex (\d+) \((.*)\\) v.(\d+) GUID \{?([-A-F0-9]+)\}? machine (\w+)                      int number = Int32.Parse(m.Groups[1].Value);                      //string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value;                         ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          this.jobVertices.Remap(vi' guid);                      }                  }              }              else if (line.StartsWith("Process was revoked"))              {                  Match m = revokedRegex.Match(line);                  if (m.Success)                  {                      string oldGuid = m.Groups[1].Value;                      ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(oldGuid);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Revoked);                          string newGuid = m.Groups[2].Value;                          this.jobVertices.Remap(vi' newGuid);                      }                      else                      {                          Trace.TraceInformation("Could not find revoked vertex with guid " + oldGuid);                      }                  }              }              else if (line.StartsWith("---HiPriTime"))              {                  // Scope-specific line which we use to get the i/o information                  // ---HiPriTime D7D51A1F-6693-4378-95FD-FC778A67C632'F52CA694-0202-411E-85E9-0C883E770A0E'SV4_Extract_Split[0]'Completed'ch1sch010331112'2011-05-03 15:26:01.681 PDT'2011-05-03 15:26:01.696 PDT'2011-05-03 15:26:02.118 PDT'2011-05-03 15:26:04.286 PDT'2011-05-03 15:26:07.656 PDT'2011-05-03 15:26:01.696 PDT'97390825'1498630                  string info = line.Substring(13);                  string[] parts = info.Split(''');                  if (parts.Length >= 13)                  {                      long read = long.Parse(parts[11]);                      long written = long.Parse(parts[12]);                      string guid = parts[1];                        ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(guid);                      if (vi != null)                      {                          vi.DataRead = read;                          vi.DataWritten = written;                          this.TotalDataRead += read;                      }                  }              }              else if (line.Contains("Io information"))              {                  // HPC-specific line                  Match m = ioRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.DataRead = long.Parse(m.Groups[4].Value);                          vi.DataWritten = long.Parse(m.Groups[5].Value);                          this.TotalDataRead += vi.DataRead;                      }                  }              }              else if (line.Contains("Process started"))              {                  //those vertices which are being canceled may not be here                  Match m = vertexStartRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        string version = m.Groups[3].Value;                      string guid = m.Groups[4].Value;                      string pid = this.ClusterConfiguration.ExtractPidFromGuid(guid' this.Summary);                      DryadProcessIdentifier identifier = new DryadProcessIdentifier(pid);                      string machine = m.Groups[5].Value;                        // Process started for vertex 4 (Super__0[0]) v.0 GUID {9DDD0B00-C93F-46D2-9073-1CFD27829300} machine sherwood-255                      // Process started for vertices 23 (Merge__29) 24 (Apply__33) v.0 GUID {E945DC5D-9AF6-4732-8770-2A6BF7FA3041} machine sherwood-237                        string vertices = m.Groups[2].Value;                      // This is a list of (number \(name\))* pairs                      // we will assume that the parantheses are matched' or we can't do much                        bool onevertex;                      if (m.Groups[1].Value == "ex")  // one vertEX                          onevertex = true;                      else if (m.Groups[1].Value == "ices")                          onevertex = false;                      else                          throw new DryadException("Can't figure out if one or many vertices");                        IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                        int vertexcount = 0;                      int iversion = int.Parse(version);                        if (lineTimeStamp > this.lastTimestampSeen)                          this.lastTimestampSeen = lineTimeStamp;                      foreach (var p in vertexList)                      {                          int number = p.Item2;                          ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' iversion);                          //new ExecutedVertexInstance(this' number' version' name' identifier' machine' this.lastTimestampSeen);                          if (vi == null)                              Trace.TraceInformation("Could not find information for vertex {0}.{1}"' number' version);                          else                              vi.SetStartInformation(this' machine' this.lastTimestampSeen' identifier' guid);                          vertexcount++;                      }                        if (vertexcount > 1 && onevertex)                          throw new DryadException("Expected one vertex' found " + vertexcount);                  }                  else                  {                      Trace.TraceInformation("Unexpected parsing error on line {0}"' line);                  }              }              else if (line.Contains("Abandoning"))              {                  Match m = vertexAbandonedRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                          vi.SetState(ExecutedVertexInstance.VertexState.Abandoned);                  }              }              else if (line.Contains("Setting"))              {                  Match m = setToFailedlRegex.Match(line);                  if (m.Success)                  {                      // Setting vertex 1461.0 (Merge__13[258]) to failed                      // Setting vertex (\d+)\.(\d+) \((.+)\) to failed(.*)                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          //vi.ErrorString = m.Groups[4].Value;                      }                  }              }              else if (line.Contains("Process was terminated"))              {                  // terminatedRegex = new Regex(@"Process was terminated Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) status (.*)"'                  // Process was terminated Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 status The operation succeeded                  Match m = terminatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          // sometimes successful processes are terminated' because they don't report quickly enough being done                          if (vi.State != ExecutedVertexInstance.VertexState.Successful)                          {                              vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          }                          vi.ErrorString = m.Groups[6].Value;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                  }              }              else if (line.Contains("Timing Information Graph Start Time"))              {                  // Cosmos-specific line                  // Timing Information Graph Start Time 128654556581866096                  Match m = Regex.Match(line' @"Timing Information Graph Start Time (\d+)");                  DateTime createTime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                  this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                  this.lastTimestampSeen = createTime;              }              else if (line.StartsWith("Start time: "))              {                  // HPC L2H specific line                  // Start time: 04/05/2011 17:25:42.223                  DateTime createTime;                  bool parse = DateTime.TryParse(line.Substring("Start time: ".Length)' out createTime);                    if (parse)                  {                      this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                      this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                      this.lastTimestampSeen = createTime;                  }              }              else if (line.Contains("JM Finish time:"))              {                  // Cosmos-specific line                  // JM Finish time: 129140295499437263 2010-03-25T22:25:49.943726Z                  Match m = Regex.Match(line' @"JM Finish time: (\d+)");                  DateTime time = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.lastTimestampSeen = time;                  this.ManagerVertex.End = time;              }              else if (line.StartsWith("Stop time "))              {                  // HPC L2H specific line                  // Stop time (Exit code = 2148734208): 04/05/2011 17:25:46.614                  Regex regex = new Regex(@"Stop time \(Exit code = (.*)\): (.*)");                  Match m = regex.Match(line);                  if (m.Success)                  {                      this.ManagerStdoutIncomplete = false;                        DateTime time;                      bool parse = DateTime.TryParse(m.Groups[2].Value' out time);                      if (parse)                      {                          this.lastTimestampSeen = time;                          this.ManagerVertex.End = time;                      }                        this.ErrorCode = m.Groups[1].Value;                      if (this.ErrorCode == "0")                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                      }                      else                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                      }                  }              }              else if (line.Contains("Timing Information"))              {                  // Timing Information 4 1 Super__0[0] 128654556603428182 0.0000 0.0000 0.0000 0.0000 0.2500                   Match m = timingInfoRegex.Match(line);                  if (m.Success)                  {                      int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      DateTime createtime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[4].Value);                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi == null)                          return; // we do not keep track of vertices with duplicate scheduling' so these won't show up here                        if (vi.State == ExecutedVertexInstance.VertexState.Started)                      {                          Console.WriteLine("Timing information while vertex is still running " + vi);                          //throw new ClusterException("Timing information for vertex still running: " + vi);                      }                      DateTime last = vi.SetTiming(createtime' m.Groups[5].Value' m.Groups[6].Value' m.Groups[7].Value' m.Groups[8].Value' m.Groups[9].Value);                      if (last > this.lastTimestampSeen)                          this.lastTimestampSeen = last;                      this.ManagerVertex.MarkVertexWasRunning(last);                        try                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              this.UsefulCPUTime += vi.RunningTime;                          else if (vi.RunningTime > TimeSpan.Zero)                              this.WastedCPUTime += vi.RunningTime;                      }                      catch (Exception ex)                      {                          Console.WriteLine("Time value exception: " + ex.Message);                      }                  }                  else                      throw new DryadException("Unmatched timing information line " + line);              }              else if (line.Contains("Process has failed"))              {                  // Process has failed Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 Exitcode 0 status The operation succeeded                  // failedRegex = new Regex(@"Process has failed Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) Exitcode (.*)"'                  Match m = failedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string exitcode = m.Groups[6].Value;                      //string status = m.Groups[7].Value;                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          vi.ExitCode = exitcode;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                          //vi.ErrorString = status;                      }                  }              }              else if (line.Contains("ABORTING:"))              {                  this.AbortingMsg = line.Substring(10);                  this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);              }              else if (line.Contains("Accurate read data"))              {                  Match m = datareadRegex.Match(line);                  if (m.Success)                  {                      this.TotalDataRead = long.Parse(m.Groups[1].Value);                      this.LocalReadData = long.Parse(m.Groups[2].Value);                      this.IntraPodDataRead = long.Parse(m.Groups[3].Value);                      this.CrossPodDataRead = long.Parse(m.Groups[4].Value);                  }              }              else if (line.Contains("<ErrorString>"))              {                  //some errors contains "Error returned from managed runtime invocation"                  //which shows the error is from application code                  Match m = Regex.Match(line' @"\<ErrorString\>(.*)\</ErrorString\>");                  if (m.Success && lastFailedVertex != null)                  {                      lastFailedVertex.AddErrorString(System.Web.HttpUtility.HtmlDecode(m.Groups[1].Value));                  }              }              else if (line.Contains("Canceling"))              {                  // Canceling vertex 1461.0 (Merge__13[258]) due to dependent failure                  Match m = cancelRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string name = m.Groups[3].Value;                        ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              vi.SetState(ExecutedVertexInstance.VertexState.Invalidated);                          else                               vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                      else                      {                          // TODO: this should not be needed' but this is a workaround for a bug in the HPC L2H software                          vi = new ExecutedVertexInstance(this' vertex' version' name' ""' lineTimeStamp);                          vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          this.jobVertices.Add(vi);                      }                      // Process wasn't even started' so there is nothing to cancel                  }              }              else if (line.Contains("Application"))              {                  //the job ends successfully                  Regex endSuccessRegex = new Regex(@"Application completed successfully.");                  //the job failed                  Regex endFailRegex = new Regex(@"Application failed with error code (.*)");                    Match m1 = endFailRegex.Match(line);                    if (m1.Success)                  {                      this.ErrorCode = m1.Groups[1].Value;                      this.ManagerStdoutIncomplete = false;                      this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                  }                  else                  {                      Match m2 = endSuccessRegex.Match(line);                      if (m2.Success)                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                          this.ManagerStdoutIncomplete = false;                      }                  }              }              else if (line.StartsWith("Input"))              {                  // Input vertex %u (%s) had %u read failure%s\n                  Match m = inputFailureRegex.Match(line);                  if (m.Success)                  {                      this.AbortingMsg = line;                  }              }              else if (line.Contains("Vertex"))              {                  // terminationRegex = new Regex(@"Vertex (\d+)\.(\d+) \((.+)\) machine (\S+) guid \{?([-0-9A-F]+)\}? status (.*)"                  Match m = terminationRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(vertex' version);                      if (vi == null)                      {                          Trace.TraceInformation("Could not find vertex {0}.{1} line {2}"' vertex' version' line);                      }                      else                      {                          bool failed = vi.SetTermination(m.Groups[6].Value' lineTimeStamp);                          if (failed)                              this.lastFailedVertex = vi;                      }                  }              }
Magic Number,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseStdoutLine,The following statement contains a magic number: if (line.Contains("Created process execution record"))              {                  Match m = vertexCreatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Created process execution record for vertex (\d+) \((.*)\) v.(\d+) GUID \{?([-A-F0-9]+)\}?                      int number = Int32.Parse(m.Groups[1].Value);                      string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                        // the vertex may be already there' sometimes numbers are reused...                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi == null)                      {                          vi = new ExecutedVertexInstance(this' number' version' name' guid' lineTimeStamp);                          this.jobVertices.Add(vi);                      }                  }                  else                  {                      m = verticesCreatedRegex.Match(line);                      if (m.Success)                      {                          lineTimeStamp = ParseLineTimestamp(line);                            // Created process execution record for vertices (.*) v.(\d+) GUID \{?([-A-F0-9]+)\}?                          // Created process execution record for vertices 192 (Merge__41[0]) 223 (Union__45[0]) v.0 GUID {0297A91C-FFEA-42EA-94AF-CD0163A04D45}                          int version = Int32.Parse(m.Groups[2].Value);                          string vertices = m.Groups[1].Value;                          string guid = m.Groups[3].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                            IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                          foreach (var p in vertexList)                          {                              int number = p.Item2;                              ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                              if (vi == null)                              {                                  vi = new ExecutedVertexInstance(this' number' version' p.Item1' guid' lineTimeStamp);                                  this.jobVertices.Add(vi);                              }                          }                      }                  }              }              else if (line.StartsWith("Creating process"))              {                  Match m = processCreatingRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Creating process for vertex (\d+) \((.*)\\) v.(\d+) GUID \{?([-A-F0-9]+)\}? machine (\w+)                      int number = Int32.Parse(m.Groups[1].Value);                      //string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value;                         ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          this.jobVertices.Remap(vi' guid);                      }                  }              }              else if (line.StartsWith("Process was revoked"))              {                  Match m = revokedRegex.Match(line);                  if (m.Success)                  {                      string oldGuid = m.Groups[1].Value;                      ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(oldGuid);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Revoked);                          string newGuid = m.Groups[2].Value;                          this.jobVertices.Remap(vi' newGuid);                      }                      else                      {                          Trace.TraceInformation("Could not find revoked vertex with guid " + oldGuid);                      }                  }              }              else if (line.StartsWith("---HiPriTime"))              {                  // Scope-specific line which we use to get the i/o information                  // ---HiPriTime D7D51A1F-6693-4378-95FD-FC778A67C632'F52CA694-0202-411E-85E9-0C883E770A0E'SV4_Extract_Split[0]'Completed'ch1sch010331112'2011-05-03 15:26:01.681 PDT'2011-05-03 15:26:01.696 PDT'2011-05-03 15:26:02.118 PDT'2011-05-03 15:26:04.286 PDT'2011-05-03 15:26:07.656 PDT'2011-05-03 15:26:01.696 PDT'97390825'1498630                  string info = line.Substring(13);                  string[] parts = info.Split(''');                  if (parts.Length >= 13)                  {                      long read = long.Parse(parts[11]);                      long written = long.Parse(parts[12]);                      string guid = parts[1];                        ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(guid);                      if (vi != null)                      {                          vi.DataRead = read;                          vi.DataWritten = written;                          this.TotalDataRead += read;                      }                  }              }              else if (line.Contains("Io information"))              {                  // HPC-specific line                  Match m = ioRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.DataRead = long.Parse(m.Groups[4].Value);                          vi.DataWritten = long.Parse(m.Groups[5].Value);                          this.TotalDataRead += vi.DataRead;                      }                  }              }              else if (line.Contains("Process started"))              {                  //those vertices which are being canceled may not be here                  Match m = vertexStartRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        string version = m.Groups[3].Value;                      string guid = m.Groups[4].Value;                      string pid = this.ClusterConfiguration.ExtractPidFromGuid(guid' this.Summary);                      DryadProcessIdentifier identifier = new DryadProcessIdentifier(pid);                      string machine = m.Groups[5].Value;                        // Process started for vertex 4 (Super__0[0]) v.0 GUID {9DDD0B00-C93F-46D2-9073-1CFD27829300} machine sherwood-255                      // Process started for vertices 23 (Merge__29) 24 (Apply__33) v.0 GUID {E945DC5D-9AF6-4732-8770-2A6BF7FA3041} machine sherwood-237                        string vertices = m.Groups[2].Value;                      // This is a list of (number \(name\))* pairs                      // we will assume that the parantheses are matched' or we can't do much                        bool onevertex;                      if (m.Groups[1].Value == "ex")  // one vertEX                          onevertex = true;                      else if (m.Groups[1].Value == "ices")                          onevertex = false;                      else                          throw new DryadException("Can't figure out if one or many vertices");                        IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                        int vertexcount = 0;                      int iversion = int.Parse(version);                        if (lineTimeStamp > this.lastTimestampSeen)                          this.lastTimestampSeen = lineTimeStamp;                      foreach (var p in vertexList)                      {                          int number = p.Item2;                          ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' iversion);                          //new ExecutedVertexInstance(this' number' version' name' identifier' machine' this.lastTimestampSeen);                          if (vi == null)                              Trace.TraceInformation("Could not find information for vertex {0}.{1}"' number' version);                          else                              vi.SetStartInformation(this' machine' this.lastTimestampSeen' identifier' guid);                          vertexcount++;                      }                        if (vertexcount > 1 && onevertex)                          throw new DryadException("Expected one vertex' found " + vertexcount);                  }                  else                  {                      Trace.TraceInformation("Unexpected parsing error on line {0}"' line);                  }              }              else if (line.Contains("Abandoning"))              {                  Match m = vertexAbandonedRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                          vi.SetState(ExecutedVertexInstance.VertexState.Abandoned);                  }              }              else if (line.Contains("Setting"))              {                  Match m = setToFailedlRegex.Match(line);                  if (m.Success)                  {                      // Setting vertex 1461.0 (Merge__13[258]) to failed                      // Setting vertex (\d+)\.(\d+) \((.+)\) to failed(.*)                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          //vi.ErrorString = m.Groups[4].Value;                      }                  }              }              else if (line.Contains("Process was terminated"))              {                  // terminatedRegex = new Regex(@"Process was terminated Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) status (.*)"'                  // Process was terminated Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 status The operation succeeded                  Match m = terminatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          // sometimes successful processes are terminated' because they don't report quickly enough being done                          if (vi.State != ExecutedVertexInstance.VertexState.Successful)                          {                              vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          }                          vi.ErrorString = m.Groups[6].Value;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                  }              }              else if (line.Contains("Timing Information Graph Start Time"))              {                  // Cosmos-specific line                  // Timing Information Graph Start Time 128654556581866096                  Match m = Regex.Match(line' @"Timing Information Graph Start Time (\d+)");                  DateTime createTime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                  this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                  this.lastTimestampSeen = createTime;              }              else if (line.StartsWith("Start time: "))              {                  // HPC L2H specific line                  // Start time: 04/05/2011 17:25:42.223                  DateTime createTime;                  bool parse = DateTime.TryParse(line.Substring("Start time: ".Length)' out createTime);                    if (parse)                  {                      this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                      this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                      this.lastTimestampSeen = createTime;                  }              }              else if (line.Contains("JM Finish time:"))              {                  // Cosmos-specific line                  // JM Finish time: 129140295499437263 2010-03-25T22:25:49.943726Z                  Match m = Regex.Match(line' @"JM Finish time: (\d+)");                  DateTime time = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.lastTimestampSeen = time;                  this.ManagerVertex.End = time;              }              else if (line.StartsWith("Stop time "))              {                  // HPC L2H specific line                  // Stop time (Exit code = 2148734208): 04/05/2011 17:25:46.614                  Regex regex = new Regex(@"Stop time \(Exit code = (.*)\): (.*)");                  Match m = regex.Match(line);                  if (m.Success)                  {                      this.ManagerStdoutIncomplete = false;                        DateTime time;                      bool parse = DateTime.TryParse(m.Groups[2].Value' out time);                      if (parse)                      {                          this.lastTimestampSeen = time;                          this.ManagerVertex.End = time;                      }                        this.ErrorCode = m.Groups[1].Value;                      if (this.ErrorCode == "0")                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                      }                      else                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                      }                  }              }              else if (line.Contains("Timing Information"))              {                  // Timing Information 4 1 Super__0[0] 128654556603428182 0.0000 0.0000 0.0000 0.0000 0.2500                   Match m = timingInfoRegex.Match(line);                  if (m.Success)                  {                      int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      DateTime createtime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[4].Value);                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi == null)                          return; // we do not keep track of vertices with duplicate scheduling' so these won't show up here                        if (vi.State == ExecutedVertexInstance.VertexState.Started)                      {                          Console.WriteLine("Timing information while vertex is still running " + vi);                          //throw new ClusterException("Timing information for vertex still running: " + vi);                      }                      DateTime last = vi.SetTiming(createtime' m.Groups[5].Value' m.Groups[6].Value' m.Groups[7].Value' m.Groups[8].Value' m.Groups[9].Value);                      if (last > this.lastTimestampSeen)                          this.lastTimestampSeen = last;                      this.ManagerVertex.MarkVertexWasRunning(last);                        try                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              this.UsefulCPUTime += vi.RunningTime;                          else if (vi.RunningTime > TimeSpan.Zero)                              this.WastedCPUTime += vi.RunningTime;                      }                      catch (Exception ex)                      {                          Console.WriteLine("Time value exception: " + ex.Message);                      }                  }                  else                      throw new DryadException("Unmatched timing information line " + line);              }              else if (line.Contains("Process has failed"))              {                  // Process has failed Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 Exitcode 0 status The operation succeeded                  // failedRegex = new Regex(@"Process has failed Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) Exitcode (.*)"'                  Match m = failedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string exitcode = m.Groups[6].Value;                      //string status = m.Groups[7].Value;                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          vi.ExitCode = exitcode;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                          //vi.ErrorString = status;                      }                  }              }              else if (line.Contains("ABORTING:"))              {                  this.AbortingMsg = line.Substring(10);                  this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);              }              else if (line.Contains("Accurate read data"))              {                  Match m = datareadRegex.Match(line);                  if (m.Success)                  {                      this.TotalDataRead = long.Parse(m.Groups[1].Value);                      this.LocalReadData = long.Parse(m.Groups[2].Value);                      this.IntraPodDataRead = long.Parse(m.Groups[3].Value);                      this.CrossPodDataRead = long.Parse(m.Groups[4].Value);                  }              }              else if (line.Contains("<ErrorString>"))              {                  //some errors contains "Error returned from managed runtime invocation"                  //which shows the error is from application code                  Match m = Regex.Match(line' @"\<ErrorString\>(.*)\</ErrorString\>");                  if (m.Success && lastFailedVertex != null)                  {                      lastFailedVertex.AddErrorString(System.Web.HttpUtility.HtmlDecode(m.Groups[1].Value));                  }              }              else if (line.Contains("Canceling"))              {                  // Canceling vertex 1461.0 (Merge__13[258]) due to dependent failure                  Match m = cancelRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string name = m.Groups[3].Value;                        ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              vi.SetState(ExecutedVertexInstance.VertexState.Invalidated);                          else                               vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                      else                      {                          // TODO: this should not be needed' but this is a workaround for a bug in the HPC L2H software                          vi = new ExecutedVertexInstance(this' vertex' version' name' ""' lineTimeStamp);                          vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          this.jobVertices.Add(vi);                      }                      // Process wasn't even started' so there is nothing to cancel                  }              }              else if (line.Contains("Application"))              {                  //the job ends successfully                  Regex endSuccessRegex = new Regex(@"Application completed successfully.");                  //the job failed                  Regex endFailRegex = new Regex(@"Application failed with error code (.*)");                    Match m1 = endFailRegex.Match(line);                    if (m1.Success)                  {                      this.ErrorCode = m1.Groups[1].Value;                      this.ManagerStdoutIncomplete = false;                      this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                  }                  else                  {                      Match m2 = endSuccessRegex.Match(line);                      if (m2.Success)                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                          this.ManagerStdoutIncomplete = false;                      }                  }              }              else if (line.StartsWith("Input"))              {                  // Input vertex %u (%s) had %u read failure%s\n                  Match m = inputFailureRegex.Match(line);                  if (m.Success)                  {                      this.AbortingMsg = line;                  }              }              else if (line.Contains("Vertex"))              {                  // terminationRegex = new Regex(@"Vertex (\d+)\.(\d+) \((.+)\) machine (\S+) guid \{?([-0-9A-F]+)\}? status (.*)"                  Match m = terminationRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(vertex' version);                      if (vi == null)                      {                          Trace.TraceInformation("Could not find vertex {0}.{1} line {2}"' vertex' version' line);                      }                      else                      {                          bool failed = vi.SetTermination(m.Groups[6].Value' lineTimeStamp);                          if (failed)                              this.lastFailedVertex = vi;                      }                  }              }
Magic Number,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseStdoutLine,The following statement contains a magic number: if (line.Contains("Created process execution record"))              {                  Match m = vertexCreatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Created process execution record for vertex (\d+) \((.*)\) v.(\d+) GUID \{?([-A-F0-9]+)\}?                      int number = Int32.Parse(m.Groups[1].Value);                      string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                        // the vertex may be already there' sometimes numbers are reused...                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi == null)                      {                          vi = new ExecutedVertexInstance(this' number' version' name' guid' lineTimeStamp);                          this.jobVertices.Add(vi);                      }                  }                  else                  {                      m = verticesCreatedRegex.Match(line);                      if (m.Success)                      {                          lineTimeStamp = ParseLineTimestamp(line);                            // Created process execution record for vertices (.*) v.(\d+) GUID \{?([-A-F0-9]+)\}?                          // Created process execution record for vertices 192 (Merge__41[0]) 223 (Union__45[0]) v.0 GUID {0297A91C-FFEA-42EA-94AF-CD0163A04D45}                          int version = Int32.Parse(m.Groups[2].Value);                          string vertices = m.Groups[1].Value;                          string guid = m.Groups[3].Value; // on some platforms' e.g. HPC' this identifier is not yet assigned properly                            IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                          foreach (var p in vertexList)                          {                              int number = p.Item2;                              ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                              if (vi == null)                              {                                  vi = new ExecutedVertexInstance(this' number' version' p.Item1' guid' lineTimeStamp);                                  this.jobVertices.Add(vi);                              }                          }                      }                  }              }              else if (line.StartsWith("Creating process"))              {                  Match m = processCreatingRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        // Creating process for vertex (\d+) \((.*)\\) v.(\d+) GUID \{?([-A-F0-9]+)\}? machine (\w+)                      int number = Int32.Parse(m.Groups[1].Value);                      //string name = m.Groups[2].Value;                      int version = Int32.Parse(m.Groups[3].Value);                      string guid = m.Groups[4].Value;                         ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          this.jobVertices.Remap(vi' guid);                      }                  }              }              else if (line.StartsWith("Process was revoked"))              {                  Match m = revokedRegex.Match(line);                  if (m.Success)                  {                      string oldGuid = m.Groups[1].Value;                      ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(oldGuid);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Revoked);                          string newGuid = m.Groups[2].Value;                          this.jobVertices.Remap(vi' newGuid);                      }                      else                      {                          Trace.TraceInformation("Could not find revoked vertex with guid " + oldGuid);                      }                  }              }              else if (line.StartsWith("---HiPriTime"))              {                  // Scope-specific line which we use to get the i/o information                  // ---HiPriTime D7D51A1F-6693-4378-95FD-FC778A67C632'F52CA694-0202-411E-85E9-0C883E770A0E'SV4_Extract_Split[0]'Completed'ch1sch010331112'2011-05-03 15:26:01.681 PDT'2011-05-03 15:26:01.696 PDT'2011-05-03 15:26:02.118 PDT'2011-05-03 15:26:04.286 PDT'2011-05-03 15:26:07.656 PDT'2011-05-03 15:26:01.696 PDT'97390825'1498630                  string info = line.Substring(13);                  string[] parts = info.Split(''');                  if (parts.Length >= 13)                  {                      long read = long.Parse(parts[11]);                      long written = long.Parse(parts[12]);                      string guid = parts[1];                        ExecutedVertexInstance vi = this.jobVertices.FindVertexByGuid(guid);                      if (vi != null)                      {                          vi.DataRead = read;                          vi.DataWritten = written;                          this.TotalDataRead += read;                      }                  }              }              else if (line.Contains("Io information"))              {                  // HPC-specific line                  Match m = ioRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.DataRead = long.Parse(m.Groups[4].Value);                          vi.DataWritten = long.Parse(m.Groups[5].Value);                          this.TotalDataRead += vi.DataRead;                      }                  }              }              else if (line.Contains("Process started"))              {                  //those vertices which are being canceled may not be here                  Match m = vertexStartRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        string version = m.Groups[3].Value;                      string guid = m.Groups[4].Value;                      string pid = this.ClusterConfiguration.ExtractPidFromGuid(guid' this.Summary);                      DryadProcessIdentifier identifier = new DryadProcessIdentifier(pid);                      string machine = m.Groups[5].Value;                        // Process started for vertex 4 (Super__0[0]) v.0 GUID {9DDD0B00-C93F-46D2-9073-1CFD27829300} machine sherwood-255                      // Process started for vertices 23 (Merge__29) 24 (Apply__33) v.0 GUID {E945DC5D-9AF6-4732-8770-2A6BF7FA3041} machine sherwood-237                        string vertices = m.Groups[2].Value;                      // This is a list of (number \(name\))* pairs                      // we will assume that the parantheses are matched' or we can't do much                        bool onevertex;                      if (m.Groups[1].Value == "ex")  // one vertEX                          onevertex = true;                      else if (m.Groups[1].Value == "ices")                          onevertex = false;                      else                          throw new DryadException("Can't figure out if one or many vertices");                        IEnumerable<Tuple<string' int>> vertexList = DryadLinqJobInfo.ParseVertices(vertices);                        int vertexcount = 0;                      int iversion = int.Parse(version);                        if (lineTimeStamp > this.lastTimestampSeen)                          this.lastTimestampSeen = lineTimeStamp;                      foreach (var p in vertexList)                      {                          int number = p.Item2;                          ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' iversion);                          //new ExecutedVertexInstance(this' number' version' name' identifier' machine' this.lastTimestampSeen);                          if (vi == null)                              Trace.TraceInformation("Could not find information for vertex {0}.{1}"' number' version);                          else                              vi.SetStartInformation(this' machine' this.lastTimestampSeen' identifier' guid);                          vertexcount++;                      }                        if (vertexcount > 1 && onevertex)                          throw new DryadException("Expected one vertex' found " + vertexcount);                  }                  else                  {                      Trace.TraceInformation("Unexpected parsing error on line {0}"' line);                  }              }              else if (line.Contains("Abandoning"))              {                  Match m = vertexAbandonedRegex.Match(line);                  if (m.Success)                  {                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                          vi.SetState(ExecutedVertexInstance.VertexState.Abandoned);                  }              }              else if (line.Contains("Setting"))              {                  Match m = setToFailedlRegex.Match(line);                  if (m.Success)                  {                      // Setting vertex 1461.0 (Merge__13[258]) to failed                      // Setting vertex (\d+)\.(\d+) \((.+)\) to failed(.*)                      int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          //vi.ErrorString = m.Groups[4].Value;                      }                  }              }              else if (line.Contains("Process was terminated"))              {                  // terminatedRegex = new Regex(@"Process was terminated Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) status (.*)"'                  // Process was terminated Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 status The operation succeeded                  Match m = terminatedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int number = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                        ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                      if (vi != null)                      {                          // sometimes successful processes are terminated' because they don't report quickly enough being done                          if (vi.State != ExecutedVertexInstance.VertexState.Successful)                          {                              vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          }                          vi.ErrorString = m.Groups[6].Value;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                  }              }              else if (line.Contains("Timing Information Graph Start Time"))              {                  // Cosmos-specific line                  // Timing Information Graph Start Time 128654556581866096                  Match m = Regex.Match(line' @"Timing Information Graph Start Time (\d+)");                  DateTime createTime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                  this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                  this.lastTimestampSeen = createTime;              }              else if (line.StartsWith("Start time: "))              {                  // HPC L2H specific line                  // Start time: 04/05/2011 17:25:42.223                  DateTime createTime;                  bool parse = DateTime.TryParse(line.Substring("Start time: ".Length)' out createTime);                    if (parse)                  {                      this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' createTime' this.Summary.ManagerProcessGuid' "");                      this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = createTime;                      this.lastTimestampSeen = createTime;                  }              }              else if (line.Contains("JM Finish time:"))              {                  // Cosmos-specific line                  // JM Finish time: 129140295499437263 2010-03-25T22:25:49.943726Z                  Match m = Regex.Match(line' @"JM Finish time: (\d+)");                  DateTime time = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[1].Value);                  this.lastTimestampSeen = time;                  this.ManagerVertex.End = time;              }              else if (line.StartsWith("Stop time "))              {                  // HPC L2H specific line                  // Stop time (Exit code = 2148734208): 04/05/2011 17:25:46.614                  Regex regex = new Regex(@"Stop time \(Exit code = (.*)\): (.*)");                  Match m = regex.Match(line);                  if (m.Success)                  {                      this.ManagerStdoutIncomplete = false;                        DateTime time;                      bool parse = DateTime.TryParse(m.Groups[2].Value' out time);                      if (parse)                      {                          this.lastTimestampSeen = time;                          this.ManagerVertex.End = time;                      }                        this.ErrorCode = m.Groups[1].Value;                      if (this.ErrorCode == "0")                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                      }                      else                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                      }                  }              }              else if (line.Contains("Timing Information"))              {                  // Timing Information 4 1 Super__0[0] 128654556603428182 0.0000 0.0000 0.0000 0.0000 0.2500                   Match m = timingInfoRegex.Match(line);                  if (m.Success)                  {                      int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      DateTime createtime = Utilities.Convert64time(ClusterConfiguration.GetClusterTimeZone(this.Summary)' m.Groups[4].Value);                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi == null)                          return; // we do not keep track of vertices with duplicate scheduling' so these won't show up here                        if (vi.State == ExecutedVertexInstance.VertexState.Started)                      {                          Console.WriteLine("Timing information while vertex is still running " + vi);                          //throw new ClusterException("Timing information for vertex still running: " + vi);                      }                      DateTime last = vi.SetTiming(createtime' m.Groups[5].Value' m.Groups[6].Value' m.Groups[7].Value' m.Groups[8].Value' m.Groups[9].Value);                      if (last > this.lastTimestampSeen)                          this.lastTimestampSeen = last;                      this.ManagerVertex.MarkVertexWasRunning(last);                        try                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              this.UsefulCPUTime += vi.RunningTime;                          else if (vi.RunningTime > TimeSpan.Zero)                              this.WastedCPUTime += vi.RunningTime;                      }                      catch (Exception ex)                      {                          Console.WriteLine("Time value exception: " + ex.Message);                      }                  }                  else                      throw new DryadException("Unmatched timing information line " + line);              }              else if (line.Contains("Process has failed"))              {                  // Process has failed Vertex 11.0 (Select__6[1]) GUID {C1E35A88-F5AD-4A26-BE5F-46B6D515623F} machine sherwood-118 Exitcode 0 status The operation succeeded                  // failedRegex = new Regex(@"Process has failed Vertex (\d+)\.(\d+) \((.+)\) GUID \{?([-A-F0-9]+)\}? machine (\S+) Exitcode (.*)"'                  Match m = failedRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string exitcode = m.Groups[6].Value;                      //string status = m.Groups[7].Value;                      ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          vi.SetState(ExecutedVertexInstance.VertexState.Failed);                          vi.ExitCode = exitcode;                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                          //vi.ErrorString = status;                      }                  }              }              else if (line.Contains("ABORTING:"))              {                  this.AbortingMsg = line.Substring(10);                  this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);              }              else if (line.Contains("Accurate read data"))              {                  Match m = datareadRegex.Match(line);                  if (m.Success)                  {                      this.TotalDataRead = long.Parse(m.Groups[1].Value);                      this.LocalReadData = long.Parse(m.Groups[2].Value);                      this.IntraPodDataRead = long.Parse(m.Groups[3].Value);                      this.CrossPodDataRead = long.Parse(m.Groups[4].Value);                  }              }              else if (line.Contains("<ErrorString>"))              {                  //some errors contains "Error returned from managed runtime invocation"                  //which shows the error is from application code                  Match m = Regex.Match(line' @"\<ErrorString\>(.*)\</ErrorString\>");                  if (m.Success && lastFailedVertex != null)                  {                      lastFailedVertex.AddErrorString(System.Web.HttpUtility.HtmlDecode(m.Groups[1].Value));                  }              }              else if (line.Contains("Canceling"))              {                  // Canceling vertex 1461.0 (Merge__13[258]) due to dependent failure                  Match m = cancelRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      string name = m.Groups[3].Value;                        ExecutedVertexInstance vi = jobVertices.FindVertex(vertex' version);                      if (vi != null)                      {                          if (vi.State == ExecutedVertexInstance.VertexState.Successful)                              vi.SetState(ExecutedVertexInstance.VertexState.Invalidated);                          else                               vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          if (lineTimeStamp != DateTime.MinValue)                              vi.End = lineTimeStamp;                      }                      else                      {                          // TODO: this should not be needed' but this is a workaround for a bug in the HPC L2H software                          vi = new ExecutedVertexInstance(this' vertex' version' name' ""' lineTimeStamp);                          vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                          this.jobVertices.Add(vi);                      }                      // Process wasn't even started' so there is nothing to cancel                  }              }              else if (line.Contains("Application"))              {                  //the job ends successfully                  Regex endSuccessRegex = new Regex(@"Application completed successfully.");                  //the job failed                  Regex endFailRegex = new Regex(@"Application failed with error code (.*)");                    Match m1 = endFailRegex.Match(line);                    if (m1.Success)                  {                      this.ErrorCode = m1.Groups[1].Value;                      this.ManagerStdoutIncomplete = false;                      this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                  }                  else                  {                      Match m2 = endSuccessRegex.Match(line);                      if (m2.Success)                      {                          this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                          this.ManagerStdoutIncomplete = false;                      }                  }              }              else if (line.StartsWith("Input"))              {                  // Input vertex %u (%s) had %u read failure%s\n                  Match m = inputFailureRegex.Match(line);                  if (m.Success)                  {                      this.AbortingMsg = line;                  }              }              else if (line.Contains("Vertex"))              {                  // terminationRegex = new Regex(@"Vertex (\d+)\.(\d+) \((.+)\) machine (\S+) guid \{?([-0-9A-F]+)\}? status (.*)"                  Match m = terminationRegex.Match(line);                  if (m.Success)                  {                      lineTimeStamp = ParseLineTimestamp(line);                        int vertex = Int32.Parse(m.Groups[1].Value);                      int version = Int32.Parse(m.Groups[2].Value);                      ExecutedVertexInstance vi = this.jobVertices.FindVertex(vertex' version);                      if (vi == null)                      {                          Trace.TraceInformation("Could not find vertex {0}.{1} line {2}"' vertex' version' line);                      }                      else                      {                          bool failed = vi.SetTermination(m.Groups[6].Value' lineTimeStamp);                          if (failed)                              this.lastFailedVertex = vi;                      }                  }              }
Magic Number,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseStdout,The following statement contains a magic number: try              {                  long filesize = file.Size;                  long readbytes = 0;                  string message = "Scanning JM stdout " + file;                  if (filesize >= 0)                      message += string.Format("({0:N0} bytes)"' filesize);                  manager.Status(message' StatusKind.LongOp);                    if (this.cachedStdoutReader == null)                      this.cachedStdoutReader = file.GetStream(true);                  if (this.cachedStdoutReader.Exception != null)                  {                      manager.Status("Exception while opening stdout " + this.cachedStdoutReader.Exception.Message' StatusKind.Error);                      return false;                  }                    while (!this.cachedStdoutReader.EndOfStream)                  {                      string line = this.cachedStdoutReader.ReadLine();                      readbytes += line.Length;                      if (currentLine >= this.stdoutLinesParsed)                      {                          while (true)                          {                              manager.Token.ThrowIfCancellationRequested();                              bool completeLine = true;                              try                              {                                  if (this.ClusterConfiguration is DfsClusterConfiguration)                                      completeLine = this.ParseStdoutLineNew(line);                                  else                                  {                                      this.ParseStdoutLine(line);                                  }                              }                              catch (Exception ex)                              {                                  manager.Status(string.Format("Line {0}: Exception {1}"' currentLine' ex.Message)' StatusKind.Error);                                  Console.WriteLine("Line {0}: Exception {1}"' currentLine' ex);                              }                              if (!completeLine)                              {                                  if (this.cachedStdoutReader.EndOfStream)                                      // no exception' the log may be truncated                                      break;                                    string extraline = this.cachedStdoutReader.ReadLine();                                  line += "\n" + extraline;                                  currentLine++;                              }                              else break;                          }                      }                      currentLine++;                      if (currentLine % 100 == 0 && filesize > 0)                      {                          manager.Progress(Math.Min(100' (int)(100 * readbytes / filesize)));                      }                  }                    this.stdoutLinesParsed = currentLine;                    if (this.ManagerVertex != null)                  {                      if (this.ManagerVertex.End == DateTime.MinValue)                          // approximation                          this.ManagerVertex.End = this.lastTimestampSeen;                        // we are done with this stream                      if (this.ManagerVertex.State == ExecutedVertexInstance.VertexState.Failed ||                          this.ManagerVertex.State == ExecutedVertexInstance.VertexState.Successful)                      {                          this.cachedStdoutReader.Close();                          this.cachedStdoutReader = null; // will force reopening if refreshed                      }                  }                  return true;              }              catch (Exception e)              {                  manager.Status("Exception while reading stdout " + e.Message' StatusKind.Error);                  Trace.TraceInformation(e.ToString());                  return false;              }
Magic Number,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseStdout,The following statement contains a magic number: try              {                  long filesize = file.Size;                  long readbytes = 0;                  string message = "Scanning JM stdout " + file;                  if (filesize >= 0)                      message += string.Format("({0:N0} bytes)"' filesize);                  manager.Status(message' StatusKind.LongOp);                    if (this.cachedStdoutReader == null)                      this.cachedStdoutReader = file.GetStream(true);                  if (this.cachedStdoutReader.Exception != null)                  {                      manager.Status("Exception while opening stdout " + this.cachedStdoutReader.Exception.Message' StatusKind.Error);                      return false;                  }                    while (!this.cachedStdoutReader.EndOfStream)                  {                      string line = this.cachedStdoutReader.ReadLine();                      readbytes += line.Length;                      if (currentLine >= this.stdoutLinesParsed)                      {                          while (true)                          {                              manager.Token.ThrowIfCancellationRequested();                              bool completeLine = true;                              try                              {                                  if (this.ClusterConfiguration is DfsClusterConfiguration)                                      completeLine = this.ParseStdoutLineNew(line);                                  else                                  {                                      this.ParseStdoutLine(line);                                  }                              }                              catch (Exception ex)                              {                                  manager.Status(string.Format("Line {0}: Exception {1}"' currentLine' ex.Message)' StatusKind.Error);                                  Console.WriteLine("Line {0}: Exception {1}"' currentLine' ex);                              }                              if (!completeLine)                              {                                  if (this.cachedStdoutReader.EndOfStream)                                      // no exception' the log may be truncated                                      break;                                    string extraline = this.cachedStdoutReader.ReadLine();                                  line += "\n" + extraline;                                  currentLine++;                              }                              else break;                          }                      }                      currentLine++;                      if (currentLine % 100 == 0 && filesize > 0)                      {                          manager.Progress(Math.Min(100' (int)(100 * readbytes / filesize)));                      }                  }                    this.stdoutLinesParsed = currentLine;                    if (this.ManagerVertex != null)                  {                      if (this.ManagerVertex.End == DateTime.MinValue)                          // approximation                          this.ManagerVertex.End = this.lastTimestampSeen;                        // we are done with this stream                      if (this.ManagerVertex.State == ExecutedVertexInstance.VertexState.Failed ||                          this.ManagerVertex.State == ExecutedVertexInstance.VertexState.Successful)                      {                          this.cachedStdoutReader.Close();                          this.cachedStdoutReader = null; // will force reopening if refreshed                      }                  }                  return true;              }              catch (Exception e)              {                  manager.Status("Exception while reading stdout " + e.Message' StatusKind.Error);                  Trace.TraceInformation(e.ToString());                  return false;              }
Magic Number,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseStdout,The following statement contains a magic number: try              {                  long filesize = file.Size;                  long readbytes = 0;                  string message = "Scanning JM stdout " + file;                  if (filesize >= 0)                      message += string.Format("({0:N0} bytes)"' filesize);                  manager.Status(message' StatusKind.LongOp);                    if (this.cachedStdoutReader == null)                      this.cachedStdoutReader = file.GetStream(true);                  if (this.cachedStdoutReader.Exception != null)                  {                      manager.Status("Exception while opening stdout " + this.cachedStdoutReader.Exception.Message' StatusKind.Error);                      return false;                  }                    while (!this.cachedStdoutReader.EndOfStream)                  {                      string line = this.cachedStdoutReader.ReadLine();                      readbytes += line.Length;                      if (currentLine >= this.stdoutLinesParsed)                      {                          while (true)                          {                              manager.Token.ThrowIfCancellationRequested();                              bool completeLine = true;                              try                              {                                  if (this.ClusterConfiguration is DfsClusterConfiguration)                                      completeLine = this.ParseStdoutLineNew(line);                                  else                                  {                                      this.ParseStdoutLine(line);                                  }                              }                              catch (Exception ex)                              {                                  manager.Status(string.Format("Line {0}: Exception {1}"' currentLine' ex.Message)' StatusKind.Error);                                  Console.WriteLine("Line {0}: Exception {1}"' currentLine' ex);                              }                              if (!completeLine)                              {                                  if (this.cachedStdoutReader.EndOfStream)                                      // no exception' the log may be truncated                                      break;                                    string extraline = this.cachedStdoutReader.ReadLine();                                  line += "\n" + extraline;                                  currentLine++;                              }                              else break;                          }                      }                      currentLine++;                      if (currentLine % 100 == 0 && filesize > 0)                      {                          manager.Progress(Math.Min(100' (int)(100 * readbytes / filesize)));                      }                  }                    this.stdoutLinesParsed = currentLine;                    if (this.ManagerVertex != null)                  {                      if (this.ManagerVertex.End == DateTime.MinValue)                          // approximation                          this.ManagerVertex.End = this.lastTimestampSeen;                        // we are done with this stream                      if (this.ManagerVertex.State == ExecutedVertexInstance.VertexState.Failed ||                          this.ManagerVertex.State == ExecutedVertexInstance.VertexState.Successful)                      {                          this.cachedStdoutReader.Close();                          this.cachedStdoutReader = null; // will force reopening if refreshed                      }                  }                  return true;              }              catch (Exception e)              {                  manager.Status("Exception while reading stdout " + e.Message' StatusKind.Error);                  Trace.TraceInformation(e.ToString());                  return false;              }
Magic Number,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseJMLogs,The following statement contains a magic number: foreach (var logfile in logfiles)              {                  if (currentFile >= this.logFilesParsed)                  {                      invalidateCache = true;                      success = this.ParseJMLogFile(logfile' statusReporter);                  }                  if (!success)                      // stop at first failure                      break;                  currentFile++;                  updateProgress(100 * currentFile  / logfiles.Count);              }
Magic Number,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseJMLogs,The following statement contains a magic number: updateProgress(100);
Magic Number,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ComputePlanLayout,The following statement contains a magic number: GraphLayout result = new GraphLayout((lastTime - jobStartTime).TotalSeconds' stages.Count()*2);
Magic Number,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ComputePlanLayout,The following statement contains a magic number: foreach (DryadLinqJobStage s in stages)              {                  // node represents the schedule: horizontal position is starttime - endtime                  DateTime endTime = s.EndTime;                  DateTime startTime = s.StartTime;                  if (endTime <= jobStartTime) // unknown time?                      endTime = lastTime;      // assume still running                  if (startTime <= jobStartTime)                      startTime = jobStartTime;                  GraphLayout.GraphNode node = new GraphLayout.GraphNode(                      (startTime - jobStartTime).TotalSeconds' currentStage*2' (endTime - startTime).TotalSeconds' 1);                  node.Shape = GraphLayout.GraphNode.NodeShape.Box;                  node.Label = s.Name;                  node.Stage = s.Name;                    result.Add(node);                  currentStage++;              }
Magic Number,Microsoft.Research.JobObjectModel,DryadJobStaticPlan,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,AddFictitiousStages,The following statement contains a magic number: this.fictitiousStages = 2;
Magic Number,Microsoft.Research.JobObjectModel,DryadJobStaticPlan,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,AddFictitiousStages,The following statement contains a magic number: stage.Id = -2;
Magic Number,Microsoft.Research.JobObjectModel,ChannelEndpointDescription,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ChannelEndpointDescription,The following statement contains a magic number: this.LocalPath = uri.Substring(sepindex + 3).Trim();
Magic Number,Microsoft.Research.JobObjectModel,ChannelEndpointDescription,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ChannelEndpointDescription,The following statement contains a magic number: this.LocalPath = uri.Substring(sepindex + 3);
Magic Number,Microsoft.Research.JobObjectModel,ExecutedVertexInstance,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,DiscoverOriginalInfoChannels,The following statement contains a magic number: for (int i = 0; i < channelCount; i++)              {                  string channel = sr.ReadLine();                  if (channel == null)                  {                      manager.Progress(100);                      return null;                  }                  if (!skip)                  {                      ChannelEndpointDescription desc = new ChannelEndpointDescription(isInput' i' channel' uriprefix' fast' manager.Status);                      channels.Add(i' desc);                      manager.Progress(i * 100 / channelCount);                  }              }
Magic Number,Microsoft.Research.JobObjectModel,ExecutedVertexInstance,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,DiscoverOriginalInfoChannels,The following statement contains a magic number: for (int i = 0; i < channelCount; i++)              {                  string channel = sr.ReadLine();                  if (channel == null)                  {                      manager.Progress(100);                      return null;                  }                  if (!skip)                  {                      ChannelEndpointDescription desc = new ChannelEndpointDescription(isInput' i' channel' uriprefix' fast' manager.Status);                      channels.Add(i' desc);                      manager.Progress(i * 100 / channelCount);                  }              }
Magic Number,Microsoft.Research.JobObjectModel,ExecutedVertexInstance,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,DiscoverOriginalInfoChannels,The following statement contains a magic number: manager.Progress(100);
Missing Default,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,CollectEssentialInformation,The following switch statement is missing a default case: switch (this.Summary.Status)                  {                      case ClusterJobInformation.ClusterJobStatus.Failed:                          jmstate = ExecutedVertexInstance.VertexState.Failed;                          break;                      /*                      case ClusterJobInformation.ClusterJobStatus.Succeeded:                          jmstate = ExecutedVertexInstance.VertexState.Successful;                          break;                      */                  }
Missing Default,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseStdoutLineNew,The following switch statement is missing a default case: switch (operation)                  {                      case "start":                          this.ManagerVertex.SetStartInformation(this' this.Summary.Machine' timeStamp' this.Summary.ManagerProcessGuid' "");                          this.ManagerVertex.StartCommandTime = this.ManagerVertex.CreationTime = this.ManagerVertex.VertexScheduleTime = timeStamp;                          break;                      case "stop":                          this.ManagerVertex.End = timeStamp;                          string exitcode;                            if (kvp.TryGetValue("exitcode"' out exitcode))                          {                              this.ErrorCode = exitcode;                              int numCode = Convert.ToInt32(exitcode' 16);                              if (numCode == 0)                              {                                  this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Successful);                              }                              else                              {                                  this.ManagerVertex.SetState(ExecutedVertexInstance.VertexState.Failed);                              }                          }                            string errorstring;                          if (kvp.TryGetValue("errorstring"' out errorstring))                          {                              this.ManagerVertex.AddErrorString(errorstring);                              this.AbortingMsg = errorstring;                          }                            break;                  }
Missing Default,Microsoft.Research.JobObjectModel,DryadLinqJobInfo,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseStdoutLineNew,The following switch statement is missing a default case: switch (transition)                      {                          case "created":                          {                              string name = kvp["name"];                              ExecutedVertexInstance vi = new ExecutedVertexInstance(this' number' version' name' ""' timeStamp);                              this.jobVertices.Add(vi);                          }                          break;                          case "starting":                          {                              // not doing anything                              break;                          }                          case "running":                          {                              string process;                              kvp.TryGetValue("id"' out process);                              if (process == null)                                  kvp.TryGetValue("process"' out process);                              string machine = kvp["computer"];                              ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                              this.jobVertices.Remap(vi' process);                              string pid = this.ClusterConfiguration.ExtractPidFromGuid(process' this.Summary);                              DryadProcessIdentifier identifier = new DryadProcessIdentifier(pid);                              vi.SetStartInformation(this' machine' timeStamp' identifier' process);                          }                          break;                          case "completed":                          {                              ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                              vi.SetState(ExecutedVertexInstance.VertexState.Successful);                              vi.End = timeStamp;                              vi.ExitCode = "";                              this.UsefulCPUTime += vi.RunningTime;                              break;                          }                          case "failed":                          {                              ExecutedVertexInstance vi = this.jobVertices.FindVertex(number' version);                              if (vi.State != ExecutedVertexInstance.VertexState.Started)                                  vi.SetState(ExecutedVertexInstance.VertexState.Cancelled);                              else                              {                                  vi.SetState(ExecutedVertexInstance.VertexState.Failed);                                  if (vi.RunningTime > TimeSpan.Zero)                                      this.WastedCPUTime += vi.RunningTime;                              }                              if (kvp.ContainsKey("errorstring"))                                  vi.AddErrorString(kvp["errorstring"]);                              string exitcode;                              if (kvp.TryGetValue("errorcode"' out exitcode))                                  vi.ExitCode = exitcode;                              vi.End = timeStamp;                              break;                          }                      }
Missing Default,Microsoft.Research.JobObjectModel,DryadLinqJobStaticPlan,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseQueryPlan,The following switch statement is missing a default case: switch (stage.Operator)                  {                      case "InputTable":                          stage.IsInput = true;                          stage.UriType = v.Element("StorageSet").Element("Type").Value;                          stage.Uri = v.Element("StorageSet").Element("SourceURI").Value;                          break;                      case "OutputTable":                          stage.IsOutput = true;                          stage.UriType = v.Element("StorageSet").Element("Type").Value;                          stage.Uri = v.Element("StorageSet").Element("SinkURI").Value;                          break;                      case "Tee":                          stage.IsTee = true;                          break;                      case "Concat":                          stage.IsConcat = true;                          break;                  }
Missing Default,Microsoft.Research.JobObjectModel,DryadLinqJobStaticPlan,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\jobinfo.cs,ParseQueryPlan,The following switch statement is missing a default case: switch (thisConnectionInformation.ConnectionManager)                      {                          case "FullAggregator":                          case "HashDistributor":                          case "RangeDistributor":                              // Ignore except first child                              if (first)                              {                                  first = false;                                  conn.ConnectionManager = thisConnectionInformation.ConnectionManager;                              }                              else                              {                                  conn.ConnectionManager = "";                              }                              break;                          case "PartialAggregator":                          case "Broadcast":                              // All children have the same connection manager                              conn.ConnectionManager = thisConnectionInformation.ConnectionManager;                              break;                          case "Splitter":                              // The connection manager depends on the number of children                              if (first)                              {                                  first = false;                                  if (children.Count() == 1)                                      conn.ConnectionManager = thisConnectionInformation.ConnectionManager;                                  else                                      conn.ConnectionManager = "SemiSplitter";                              }                              else                              {                                  conn.ConnectionManager = "";                              }                              break;                          case "None":                          case "":                              break;                      }
Missing Default,Microsoft.Research.JobObjectModel,StaticPartitionedTableInformation,C:\repos\MicrosoftResearch_Dryad\JobBrowser\JOM\Storage.cs,StaticPartitionedTableInformation,The following switch statement is missing a default case: switch (uriType)              {                  case "PartitionedFile":                      this.ParsePartitionedFile(statusReporter);                      break;              }
