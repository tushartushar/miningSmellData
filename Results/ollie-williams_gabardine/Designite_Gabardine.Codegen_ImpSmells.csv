Implementation smell,Namespace,Class,File,Method,Description
Complex Method,Gabardine.Codegen,Analysis,C:\repos\ollie-williams_gabardine\Gabardine.Codegen\Anaysis.cs,RemoveStacks,Cyclomatic complexity of the method is 27
Complex Method,Gabardine.Codegen,Analysis,C:\repos\ollie-williams_gabardine\Gabardine.Codegen\Anaysis.cs,FindDependents,Cyclomatic complexity of the method is 10
Complex Method,Gabardine.Codegen,Statements,C:\repos\ollie-williams_gabardine\Gabardine.Codegen\CodegenOps.cs,GetKind,Cyclomatic complexity of the method is 15
Complex Method,Gabardine.Codegen,Instructions,C:\repos\ollie-williams_gabardine\Gabardine.Codegen\CodegenOps.cs,GetKind,Cyclomatic complexity of the method is 14
Complex Method,Gabardine.Codegen,ControlFlow,C:\repos\ollie-williams_gabardine\Gabardine.Codegen\ControlFlow.cs,Split,Cyclomatic complexity of the method is 13
Complex Method,Gabardine.Codegen,ControlFlow,C:\repos\ollie-williams_gabardine\Gabardine.Codegen\ControlFlow.cs,AddEdges,Cyclomatic complexity of the method is 13
Complex Method,Gabardine.Codegen,BuilderExtension,C:\repos\ollie-williams_gabardine\Gabardine.Codegen\LLVMEmitter.cs,AppendType,Cyclomatic complexity of the method is 8
Complex Method,Gabardine.Codegen,LLVMEmitter,C:\repos\ollie-williams_gabardine\Gabardine.Codegen\LLVMEmitter.cs,Binary,Cyclomatic complexity of the method is 27
Long Parameter List,Gabardine.Codegen,Emission,C:\repos\ollie-williams_gabardine\Gabardine.Codegen\Emitter.cs,EmitFunction,The method has 5 parameters.
Long Statement,Gabardine.Codegen,BaseRewriter,C:\repos\ollie-williams_gabardine\Gabardine.Codegen\BaseRewriter.cs,CreateRewriters,The length of the statement  "	after.AddRule (Statements.TmpAssign [u' Special.Cons [v' Special.Nil]]' Cons (v' Statements.TmpAssign [u' Instructions.Pop])); " is 126.
Long Statement,Gabardine.Codegen,BaseRewriter,C:\repos\ollie-williams_gabardine\Gabardine.Codegen\BaseRewriter.cs,CreateRewriters,The length of the statement  "	before.AddRule (OutputDirectives.OutParam [v]' Cons (Statements.Push' Statements.TmpAssign [Term.Const ("v")' Instructions.Generate [v]]' Statements.CopyOut [Tmp ("v")])); " is 171.
Long Statement,Gabardine.Codegen,BaseRewriter,C:\repos\ollie-williams_gabardine\Gabardine.Codegen\BaseRewriter.cs,CreateRewriters,The length of the statement  "	before.AddRule (OutputDirectives.ReturnValue [u]' Cons (Statements.Push' Statements.TmpAssign [Term.Const ("u")' Instructions.Generate [u]]' Statements.Return [Tmp ("u")])); " is 173.
Long Statement,Gabardine.Codegen,Emission,C:\repos\ollie-williams_gabardine\Gabardine.Codegen\Emitter.cs,GetType,The length of the statement  "		throw new InvalidCastException (string.Format ("Cannot get a low level type for {0}: type deduced is {1}."' term' typeTest)); " is 125.
Long Statement,Gabardine.Codegen,LLVMEmitter,C:\repos\ollie-williams_gabardine\Gabardine.Codegen\LLVMEmitter.cs,Store,The length of the statement  "	body.Append ("store ").AppendType (src.Type).Append (' ').Append (src).Append ("' ").AppendType (dstT).Append (' ').Append (dst).AppendLine (); " is 143.
Long Statement,Gabardine.Codegen,LLVMEmitter,C:\repos\ollie-williams_gabardine\Gabardine.Codegen\LLVMEmitter.cs,Binary,The length of the statement  "	body.Append (var_name).Append (" = ").Append (op_name).AppendType (left.Type).Append (' ').Append (left.ToString ()).Append ("' ").AppendLine (right.ToString ()); " is 162.
Long Statement,Gabardine.Codegen,LLVMEmitter,C:\repos\ollie-williams_gabardine\Gabardine.Codegen\LLVMEmitter.cs,TryCast,The length of the statement  "	body.Append (var_name).Append (" = ").Append (op).AppendType (src.Type).Append (' ').Append (src).Append (" to ").AppendType (targetType).AppendLine (); " is 152.
Magic Number,Gabardine.Codegen,Analysis,C:\repos\ollie-williams_gabardine\Gabardine.Codegen\Anaysis.cs,RemoveStacks,The following statement contains a magic number: foreach (Term s in nested) {  	Term t = s;  	if (stack.Count > 0) {  		t = Replace (t' stack.Peek ().dict);  	}  	switch (Statements.GetKind (t.Op)) {  	case Statements.Kind.Push:  		stack.Push (new StackInfo ());  		break;  	case Statements.Kind.TmpAssign:  		{  			Term old_name = t [0];  			string new_name = string.Format ("%{0}"' count++);  			stack.Peek ().dict.Add (Arguments.Tmp [old_name]' Arguments.Tmp [Term.Const (new_name)]);  			Term rhs = t [1];  			if (rhs == Instructions.Pop) {  				rhs = stack.Peek ().retval;  				stack.Peek ().retval = null;  				Debug.Assert (!ReferenceEquals (rhs' null)' "Expected a return value to be available to pop.");  			}  			yield return Statements.TmpAssign [Term.Const (new_name)' rhs];  		}  		break;  	case Statements.Kind.Return:  		stack.Pop ();  		Debug.Assert (stack.Count > 0' "Expected a stack entry to remain.");  		stack.Peek ().retval = t [0];  		break;  	case Statements.Kind.BasicBlock:  		{  			string old_name = (t [0].Op as Constant<string>).Value;  			string new_name = stack.Peek ().GetOrAddBasicBlockName (old_name' ref bbCount);  			yield return Statements.BasicBlock [Term.Const (new_name)];  		}  		break;  	case Statements.Kind.Goto:  		{  			string old_name = (t [0].Op as Constant<string>).Value;  			string new_name = stack.Peek ().GetOrAddBasicBlockName (old_name' ref bbCount);  			yield return Statements.Goto [Term.Const (new_name)];  		}  		break;  	case Statements.Kind.If:  		{  			string then_name = (t [1].Op as Constant<string>).Value;  			string else_name = (t [2].Op as Constant<string>).Value;  			then_name = stack.Peek ().GetOrAddBasicBlockName (then_name' ref bbCount);  			else_name = stack.Peek ().GetOrAddBasicBlockName (else_name' ref bbCount);  			yield return Statements.If [t [0]' Term.Const (then_name)' Term.Const (else_name)];  		}  		break;  	default:  		yield return t;  		break;  	}  }  
Magic Number,Gabardine.Codegen,Analysis,C:\repos\ollie-williams_gabardine\Gabardine.Codegen\Anaysis.cs,RemoveStacks,The following statement contains a magic number: switch (Statements.GetKind (t.Op)) {  case Statements.Kind.Push:  	stack.Push (new StackInfo ());  	break;  case Statements.Kind.TmpAssign:  	{  		Term old_name = t [0];  		string new_name = string.Format ("%{0}"' count++);  		stack.Peek ().dict.Add (Arguments.Tmp [old_name]' Arguments.Tmp [Term.Const (new_name)]);  		Term rhs = t [1];  		if (rhs == Instructions.Pop) {  			rhs = stack.Peek ().retval;  			stack.Peek ().retval = null;  			Debug.Assert (!ReferenceEquals (rhs' null)' "Expected a return value to be available to pop.");  		}  		yield return Statements.TmpAssign [Term.Const (new_name)' rhs];  	}  	break;  case Statements.Kind.Return:  	stack.Pop ();  	Debug.Assert (stack.Count > 0' "Expected a stack entry to remain.");  	stack.Peek ().retval = t [0];  	break;  case Statements.Kind.BasicBlock:  	{  		string old_name = (t [0].Op as Constant<string>).Value;  		string new_name = stack.Peek ().GetOrAddBasicBlockName (old_name' ref bbCount);  		yield return Statements.BasicBlock [Term.Const (new_name)];  	}  	break;  case Statements.Kind.Goto:  	{  		string old_name = (t [0].Op as Constant<string>).Value;  		string new_name = stack.Peek ().GetOrAddBasicBlockName (old_name' ref bbCount);  		yield return Statements.Goto [Term.Const (new_name)];  	}  	break;  case Statements.Kind.If:  	{  		string then_name = (t [1].Op as Constant<string>).Value;  		string else_name = (t [2].Op as Constant<string>).Value;  		then_name = stack.Peek ().GetOrAddBasicBlockName (then_name' ref bbCount);  		else_name = stack.Peek ().GetOrAddBasicBlockName (else_name' ref bbCount);  		yield return Statements.If [t [0]' Term.Const (then_name)' Term.Const (else_name)];  	}  	break;  default:  	yield return t;  	break;  }  
Magic Number,Gabardine.Codegen,ConstantFold,C:\repos\ollie-williams_gabardine\Gabardine.Codegen\ConstantFold.cs,TryInferType,The following statement contains a magic number: if (query == Special.Integer) {  	type = LowLevelType.Integer (32' true);  	return true;  }  
Magic Number,Gabardine.Codegen,ConstantFold,C:\repos\ollie-williams_gabardine\Gabardine.Codegen\ConstantFold.cs,TryInferType,The following statement contains a magic number: type = LowLevelType.Integer (32' true);  
Magic Number,Gabardine.Codegen,ControlFlow,C:\repos\ollie-williams_gabardine\Gabardine.Codegen\ControlFlow.cs,AddEdges,The following statement contains a magic number: foreach (var stmt in bb.Statements) {  	Debug.Assert (stmt.Block == bb);  	Term t = stmt.Statement;  	switch (Statements.GetKind (t.Op)) {  	case Statements.Kind.Goto:  		string destName = GetConst<string> (t [0]);  		AddEdge (bb' destName);  		break;  	case Statements.Kind.If:  		string thenName = GetConst<string> (t [1]);  		string elseName = GetConst<string> (t [2]);  		AddEdge (bb' thenName);  		AddEdge (bb' elseName);  		break;  	default:  		break;  	}  }  
Magic Number,Gabardine.Codegen,ControlFlow,C:\repos\ollie-williams_gabardine\Gabardine.Codegen\ControlFlow.cs,AddEdges,The following statement contains a magic number: switch (Statements.GetKind (t.Op)) {  case Statements.Kind.Goto:  	string destName = GetConst<string> (t [0]);  	AddEdge (bb' destName);  	break;  case Statements.Kind.If:  	string thenName = GetConst<string> (t [1]);  	string elseName = GetConst<string> (t [2]);  	AddEdge (bb' thenName);  	AddEdge (bb' elseName);  	break;  default:  	break;  }  
Magic Number,Gabardine.Codegen,ForeignLibrary,C:\repos\ollie-williams_gabardine\Gabardine.Codegen\ForeignLibrary.cs,ForeignLibrary,The following statement contains a magic number: AddFunction (new ForeignFunction ("malloc_leak"' new LowLevelType[] {  	LowLevelType.NativeInteger'  	LowLevelType.Integer (32' true)  }' i8ptr));  
Magic Number,Gabardine.Codegen,LowLevelType,C:\repos\ollie-williams_gabardine\Gabardine.Codegen\LowLevelType.cs,Convert,The following statement contains a magic number: if (type == typeof(int)) {  	return new Integer (32' true);  }  
Magic Number,Gabardine.Codegen,LowLevelType,C:\repos\ollie-williams_gabardine\Gabardine.Codegen\LowLevelType.cs,Convert,The following statement contains a magic number: return new Integer (32' true);  
Magic Number,Gabardine.Codegen,LowLevelType,C:\repos\ollie-williams_gabardine\Gabardine.Codegen\LowLevelType.cs,Convert,The following statement contains a magic number: if (type == typeof(uint)) {  	return new Integer (32' false);  }  
Magic Number,Gabardine.Codegen,LowLevelType,C:\repos\ollie-williams_gabardine\Gabardine.Codegen\LowLevelType.cs,Convert,The following statement contains a magic number: return new Integer (32' false);  
Magic Number,Gabardine.Codegen,Integer,C:\repos\ollie-williams_gabardine\Gabardine.Codegen\LowLevelType.cs,ToManagedType,The following statement contains a magic number: switch (Bits) {  case 16:  	return typeof(System.Int16);  case 32:  	return typeof(System.Int32);  case 64:  	return typeof(System.Int64);  default:  	throw new InvalidCastException (string.Format ("Cannot translate a {0}-bit integer into a managed type."' Bits));  }  
Magic Number,Gabardine.Codegen,Integer,C:\repos\ollie-williams_gabardine\Gabardine.Codegen\LowLevelType.cs,ToManagedType,The following statement contains a magic number: switch (Bits) {  case 16:  	return typeof(System.Int16);  case 32:  	return typeof(System.Int32);  case 64:  	return typeof(System.Int64);  default:  	throw new InvalidCastException (string.Format ("Cannot translate a {0}-bit integer into a managed type."' Bits));  }  
Magic Number,Gabardine.Codegen,Integer,C:\repos\ollie-williams_gabardine\Gabardine.Codegen\LowLevelType.cs,ToManagedType,The following statement contains a magic number: switch (Bits) {  case 16:  	return typeof(System.Int16);  case 32:  	return typeof(System.Int32);  case 64:  	return typeof(System.Int64);  default:  	throw new InvalidCastException (string.Format ("Cannot translate a {0}-bit integer into a managed type."' Bits));  }  
Missing Default,Gabardine.Codegen,Dominator,C:\repos\ollie-williams_gabardine\Gabardine.Codegen\Dominator.cs,PredecessorCount,The following switch statement is missing a default case: switch (direction) {  case DominatorDirection.Dominator:  	return node.InDegree;  case DominatorDirection.PostDominator:  	return node.OutDegree;  }  
Missing Default,Gabardine.Codegen,Dominator,C:\repos\ollie-williams_gabardine\Gabardine.Codegen\Dominator.cs,GetPredecessor,The following switch statement is missing a default case: switch (direction) {  case DominatorDirection.Dominator:  	return node.InEdge (i);  case DominatorDirection.PostDominator:  	return node.OutEdge (i);  }  
