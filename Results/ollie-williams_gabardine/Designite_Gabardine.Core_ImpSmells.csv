Implementation smell,Namespace,Class,File,Method,Description
Complex Method,Gabardine,LambdaOperator,C:\repos\ollie-williams_gabardine\Gabardine.Core\Lambda.cs,CreateTerm,Cyclomatic complexity of the method is 8
Complex Method,Gabardine,PatternMatcher,C:\repos\ollie-williams_gabardine\Gabardine.Core\PatternMatcher.cs,Match,Cyclomatic complexity of the method is 8
Complex Method,Gabardine,PrettyPrinter,C:\repos\ollie-williams_gabardine\Gabardine.Core\PrettyPrinter.cs,PrintInfixFormat,Cyclomatic complexity of the method is 12
Complex Method,Gabardine,PrettyPrinter,C:\repos\ollie-williams_gabardine\Gabardine.Core\PrettyPrinter.cs,InfixFormat,Cyclomatic complexity of the method is 32
Complex Method,Gabardine,PrettyPrinter,C:\repos\ollie-williams_gabardine\Gabardine.Core\PrettyPrinter.cs,PrintTree,Cyclomatic complexity of the method is 9
Complex Method,Gabardine,RewriteSystem,C:\repos\ollie-williams_gabardine\Gabardine.Core\RewriteSystem.cs,RewriteUnordered,Cyclomatic complexity of the method is 11
Complex Method,Gabardine,TargetBuilder,C:\repos\ollie-williams_gabardine\Gabardine.Core\TargetBuilder.cs,Build,Cyclomatic complexity of the method is 8
Complex Method,Gabardine,TargetBuilder,C:\repos\ollie-williams_gabardine\Gabardine.Core\TargetBuilder.cs,BuildRegular,Cyclomatic complexity of the method is 25
Complex Method,Gabardine,Unifier,C:\repos\ollie-williams_gabardine\Gabardine.Core\Unify.cs,Unify,Cyclomatic complexity of the method is 9
Long Parameter List,Gabardine,Abstraction,C:\repos\ollie-williams_gabardine\Gabardine.Core\Abstraction.cs,TryToGrow,The method has 5 parameters.
Long Parameter List,Gabardine,Abstraction,C:\repos\ollie-williams_gabardine\Gabardine.Core\Abstraction.cs,CreateSeedCandidates,The method has 5 parameters.
Long Parameter List,Gabardine,ModelChecker,C:\repos\ollie-williams_gabardine\Gabardine.Core\ModelChecker.cs,LPO,The method has 9 parameters.
Long Parameter List,Gabardine,RewriteStep,C:\repos\ollie-williams_gabardine\Gabardine.Core\RewriteHistory.cs,RewriteStep,The method has 5 parameters.
Long Parameter List,Gabardine,RewriteHistory,C:\repos\ollie-williams_gabardine\Gabardine.Core\RewriteHistory.cs,AddStep,The method has 5 parameters.
Long Parameter List,Gabardine,Lifter,C:\repos\ollie-williams_gabardine\Gabardine.Core\Lifter.cs,FindTransformations,The method has 5 parameters.
Long Parameter List,Gabardine,RewriteSystem,C:\repos\ollie-williams_gabardine\Gabardine.Core\RewriteSystem.cs,RewriteUnordered,The method has 5 parameters.
Long Parameter List,Gabardine,RewriteRuleFactory,C:\repos\ollie-williams_gabardine\Gabardine.Core\RewriteRuleFactory.cs,Create,The method has 5 parameters.
Long Parameter List,Gabardine,RewriteRuleFactory,C:\repos\ollie-williams_gabardine\Gabardine.Core\RewriteRuleFactory.cs,Create,The method has 6 parameters.
Long Parameter List,Gabardine,RewriteRuleFactory,C:\repos\ollie-williams_gabardine\Gabardine.Core\RewriteRuleFactory.cs,Create,The method has 7 parameters.
Long Parameter List,Gabardine,RewriteRule,C:\repos\ollie-williams_gabardine\Gabardine.Core\RewriteRule.cs,RewriteRule,The method has 8 parameters.
Long Parameter List,Gabardine,Term,C:\repos\ollie-williams_gabardine\Gabardine.Core\Term.cs,Term,The method has 5 parameters.
Long Statement,Gabardine,Abstraction,C:\repos\ollie-williams_gabardine\Gabardine.Core\Abstraction.cs,CreateSeedCandidates,The length of the statement  "	candidates = new Queue<Candidate> (opCounts.Where (kv => kv.Value > 1).Select (kv => PatternMatcherFactory.Create (MakePattern (kv.Key))).Select (pm => new Candidate (pm' true))); " is 179.
Long Statement,Gabardine,CodeMotion,C:\repos\ollie-williams_gabardine\Gabardine.Core\CodeMotion.cs,Hoist,The length of the statement  "		throw new InvalidOperationException ("Cannot hoist this let expression because its binding is not independent of the lambda variable."); " is 136.
Long Statement,Gabardine,LambdaSanity,C:\repos\ollie-williams_gabardine\Gabardine.Core\LambdaAnalysis.cs,Check,The length of the statement  "				throw new InvalidProgramException (string.Format ("Lambda variable {0}' is bound twice in overlapping contexts."' wc.Term [0])); " is 128.
Long Statement,Gabardine,RewriteSystem,C:\repos\ollie-williams_gabardine\Gabardine.Core\RewriteSystem.cs,AddRule,The length of the statement  "	//RewriteRule rule = RewriteRuleFactory.Create(id' lhs' rhs' Enumerable.Empty<ConditionPattern>()' priority' isDefault); " is 120.
Long Statement,Gabardine,TargetBuilder,C:\repos\ollie-williams_gabardine\Gabardine.Core\TargetBuilder.cs,BuildRegular,The length of the statement  "		bool isparam = term [0].Op.Kind == OperatorKind.Parameter || term [0].Op.Kind == OperatorKind.LetVariable || term [0].Op.Kind == OperatorKind.LambdaVariable; " is 157.
Magic Number,Gabardine,CodeMotion,C:\repos\ollie-williams_gabardine\Gabardine.Core\CodeMotion.cs,MoveLetUp,The following statement contains a magic number: for (int i = 0; i < args.Length; ++i) {  	if (i == childIndex) {  		args [i] = let [2];  	}  	else {  		args [i] = parent [i];  	}  }  
Magic Number,Gabardine,CodeMotion,C:\repos\ollie-williams_gabardine\Gabardine.Core\CodeMotion.cs,MoveLetUp,The following statement contains a magic number: if (i == childIndex) {  	args [i] = let [2];  }  else {  	args [i] = parent [i];  }  
Magic Number,Gabardine,CodeMotion,C:\repos\ollie-williams_gabardine\Gabardine.Core\CodeMotion.cs,MoveLetUp,The following statement contains a magic number: args [i] = let [2];  
Magic Number,Gabardine,ConsUtils,C:\repos\ollie-williams_gabardine\Gabardine.Core\ConsUtils.cs,RightAssociate,The following statement contains a magic number: if (aggregator.Arity != 2) {  	throw new System.ArgumentException ("aggregator must be binary.");  }  
Magic Number,Gabardine,ConsUtils,C:\repos\ollie-williams_gabardine\Gabardine.Core\ConsUtils.cs,RightAssociate,The following statement contains a magic number: if (aggregator.Arity != 2) {  	throw new System.ArgumentException ("aggregator must be binary.");  }  
Magic Number,Gabardine,ConsUtils,C:\repos\ollie-williams_gabardine\Gabardine.Core\ConsUtils.cs,RightAssociate,The following statement contains a magic number: for (int i = elements.Length - 2; i >= 0; --i) {  	retval = aggregator [elements [i]' retval];  }  
Magic Number,Gabardine,ConsUtils,C:\repos\ollie-williams_gabardine\Gabardine.Core\ConsUtils.cs,DisaggregateMany,The following statement contains a magic number: if (aggregator.Arity != 2) {  	throw new System.ArgumentException ("aggregator must be binary.");  }  
Magic Number,Gabardine,ConsUtils,C:\repos\ollie-williams_gabardine\Gabardine.Core\ConsUtils.cs,DisaggregateMany,The following statement contains a magic number: if (aggregator.Arity != 2) {  	throw new System.ArgumentException ("aggregator must be binary.");  }  
Magic Number,Gabardine,ConsUtils,C:\repos\ollie-williams_gabardine\Gabardine.Core\ConsUtils.cs,Disaggregate,The following statement contains a magic number: if (aggregator.Arity != 2) {  	throw new System.ArgumentException ("aggregator must be binary.");  }  
Magic Number,Gabardine,Hash,C:\repos\ollie-williams_gabardine\Gabardine.Core\Hash.cs,MakeHash,The following statement contains a magic number: Assert (tableLength == 256);  
Magic Number,Gabardine,Hash,C:\repos\ollie-williams_gabardine\Gabardine.Core\Hash.cs,MakeHash,The following statement contains a magic number: Assert (tableLength == 256);  
Magic Number,Gabardine,PrettyPrinter,C:\repos\ollie-williams_gabardine\Gabardine.Core\PrettyPrinter.cs,PrintInfixFormat,The following statement contains a magic number: switch (segments.Length) {  case 1:  	terminal.Send (str);  	break;  case 3:  	terminal.Send (segments [0]);  	terminal.PushFormat (highlight);  	terminal.Send (segments [1]);  	terminal.PopFormat ();  	terminal.Send (segments [2]);  	break;  default:  	throw new Exception ("Bad highlighting");  }  
Magic Number,Gabardine,PrettyPrinter,C:\repos\ollie-williams_gabardine\Gabardine.Core\PrettyPrinter.cs,PrintInfixFormat,The following statement contains a magic number: switch (segments.Length) {  case 1:  	terminal.Send (str);  	break;  case 3:  	terminal.Send (segments [0]);  	terminal.PushFormat (highlight);  	terminal.Send (segments [1]);  	terminal.PopFormat ();  	terminal.Send (segments [2]);  	break;  default:  	throw new Exception ("Bad highlighting");  }  
Magic Number,Gabardine,PrettyPrinter,C:\repos\ollie-williams_gabardine\Gabardine.Core\PrettyPrinter.cs,PrintInfixFormat,The following statement contains a magic number: terminal.Send (segments [2]);  
Magic Number,Gabardine,PrettyPrinter,C:\repos\ollie-williams_gabardine\Gabardine.Core\PrettyPrinter.cs,InfixFormat,The following statement contains a magic number: while (stack.Count > 0) {  	Term head = stack.Pop ();  	if (object.ReferenceEquals (head' null)) {  		head = stack.Pop ();  		if (head.Op == PrettyPrinter.Highlight) {  			var child = args.Pop ();  			sb.Append ("@#$");  			sb.Append (child.Text);  			sb.Append ("@#$");  			child.Text = sb.ToString ();  			sb.Clear ();  			args.Push (child);  			continue;  		}  		PrecString result = new PrecString ();  		result.Prec = int.MaxValue;  		switch (Special.GetKind (head.Op)) {  		case Special.Kind.Let:  			var body = args.Pop ();  			var binding = args.Pop ();  			PrintLet (binding' body' sb);  			break;  		case Special.Kind.Lambda:  			PrintLambda (args.Pop ()' sb);  			break;  		case Special.Kind.Index:  			var offset = args.Pop ();  			var _base = args.Pop ();  			PrintIndex (_base' offset' sb);  			break;  		default:  			var children = args.PopFIFO (head.Arity);  			var syntax = head.Op.Syntax;  			switch (syntax.Style) {  			case OperatorSyntax.Fix.FunctionCall:  				PrintFunctionCall (syntax.Name' children' sb);  				break;  			case OperatorSyntax.Fix.LeftAssociative:  			case OperatorSyntax.Fix.RightAssociative:  				PrintInfix (syntax' children [0]' children [1]' sb);  				result.Prec = syntax.Precedence;  				break;  			case OperatorSyntax.Fix.Prefix:  				PrintPrefix (syntax' children [0]' sb);  				result.Prec = syntax.Precedence;  				break;  			case OperatorSyntax.Fix.Postfix:  				PrintPostfix (syntax' children [0]' sb);  				result.Prec = syntax.Precedence;  				break;  			}  			break;  		}  		result.Text = sb.ToString ();  		sb.Clear ();  		args.Push (result);  		continue;  	}  	// Nullarys pass through  	if (head.Arity == 0) {  		args.Push (new PrecString {  			Text = head.Op.Name'  			Prec = int.MaxValue  		});  		continue;  	}  	// Return marker  	stack.Push (head);  	stack.Push (null);  	// Schedule children  	switch (Special.GetKind (head.Op)) {  	case Special.Kind.Let:  		stack.Push (head [2]);  		stack.Push (Special.Equals [head [0]' head [1]]);  		break;  	case Special.Kind.Lambda:  		stack.Push (Special.MapsTo [head [0]' head [1]]);  		break;  	default:  		for (int i = head.Arity - 1; i >= 0; --i) {  			stack.Push (head [i]);  		}  		break;  	}  }  
Magic Number,Gabardine,PrettyPrinter,C:\repos\ollie-williams_gabardine\Gabardine.Core\PrettyPrinter.cs,InfixFormat,The following statement contains a magic number: switch (Special.GetKind (head.Op)) {  case Special.Kind.Let:  	stack.Push (head [2]);  	stack.Push (Special.Equals [head [0]' head [1]]);  	break;  case Special.Kind.Lambda:  	stack.Push (Special.MapsTo [head [0]' head [1]]);  	break;  default:  	for (int i = head.Arity - 1; i >= 0; --i) {  		stack.Push (head [i]);  	}  	break;  }  
Magic Number,Gabardine,PrettyPrinter,C:\repos\ollie-williams_gabardine\Gabardine.Core\PrettyPrinter.cs,InfixFormat,The following statement contains a magic number: stack.Push (head [2]);  
Magic Number,Gabardine,TargetBuilder,C:\repos\ollie-williams_gabardine\Gabardine.Core\TargetBuilder.cs,BuildRegular,The following statement contains a magic number: switch (Special.GetKind (step.Op)) {  case Special.Kind.Subs:  	term = Substitution (term [0]' term [1]' term [2]);  	break;  case Special.Kind.Lambda:  	term = FreshenLambda (term);  	break;  case Special.Kind.Fresh:  	term = Freshen (term);  	break;  case Special.Kind.IsParam:  	bool isparam = term [0].Op.Kind == OperatorKind.Parameter || term [0].Op.Kind == OperatorKind.LetVariable || term [0].Op.Kind == OperatorKind.LambdaVariable;  	term = isparam ? Special.True : Special.False;  	break;  case Special.Kind.IsConst:  	// If we can tell immediately that the term is a constant' convert  	// it to True. Otherwise carry on.  	bool isConst = term [0].Op.IsConstant;  	term = isConst ? Special.True : term;  	break;  case Special.Kind.Inherit:  	term = TryImmediateInherit (term);  	break;  case Special.Kind.Breakout:  	term = BreakoutDispatcher.Handle (term [0]);  	break;  default:  	break;  }  
Magic Number,Gabardine,TargetBuilder,C:\repos\ollie-williams_gabardine\Gabardine.Core\TargetBuilder.cs,BuildRegular,The following statement contains a magic number: term = Substitution (term [0]' term [1]' term [2]);  
Missing Default,Gabardine,PrettyPrinter,C:\repos\ollie-williams_gabardine\Gabardine.Core\PrettyPrinter.cs,Print,The following switch statement is missing a default case: switch (format) {  case PrintFormat.Lisp:  	PrintLispFormat (term' terminal' highlight);  	break;  case PrintFormat.Infix:  	PrintInfixFormat (term' terminal' highlight);  	break;  }  
Missing Default,Gabardine,PrettyPrinter,C:\repos\ollie-williams_gabardine\Gabardine.Core\PrettyPrinter.cs,Format,The following switch statement is missing a default case: switch (format) {  case PrintFormat.Lisp:  	return LispFormat (term);  case PrintFormat.Infix:  	return InfixFormat (term);  }  
Missing Default,Gabardine,PrettyPrinter,C:\repos\ollie-williams_gabardine\Gabardine.Core\PrettyPrinter.cs,InfixFormat,The following switch statement is missing a default case: switch (syntax.Style) {  case OperatorSyntax.Fix.FunctionCall:  	PrintFunctionCall (syntax.Name' children' sb);  	break;  case OperatorSyntax.Fix.LeftAssociative:  case OperatorSyntax.Fix.RightAssociative:  	PrintInfix (syntax' children [0]' children [1]' sb);  	result.Prec = syntax.Precedence;  	break;  case OperatorSyntax.Fix.Prefix:  	PrintPrefix (syntax' children [0]' sb);  	result.Prec = syntax.Precedence;  	break;  case OperatorSyntax.Fix.Postfix:  	PrintPostfix (syntax' children [0]' sb);  	result.Prec = syntax.Precedence;  	break;  }  
Missing Default,Gabardine,TargetBuilder,C:\repos\ollie-williams_gabardine\Gabardine.Core\TargetBuilder.cs,Build,The following switch statement is missing a default case: switch (steps [i].Significance) {  case StepSignificance.OnlyVariableInstance:  	// If the operator is a variable' get the appropriate binding from the array. No other occurrances.  	stack.Push (binding);  	break;  case StepSignificance.None:  	Assert (false' "This case should have been handled.");  	break;  }  
