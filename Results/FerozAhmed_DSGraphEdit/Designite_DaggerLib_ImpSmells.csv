Implementation smell,Namespace,Class,File,Method,Description
Long Method,DaggerLib.Core,DaggerGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib\Core\DaggerGraph.cs,CalculateTopology,The method has 113 lines of code.
Long Method,DaggerLib.Core,DaggerGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib\Core\DaggerGraph.cs,GetObjectData,The method has 119 lines of code.
Complex Method,DaggerLib.Core,DaggerGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib\Core\DaggerGraph.cs,AppendGraph,Cyclomatic complexity of the method is 20
Complex Method,DaggerLib.Core,DaggerGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib\Core\DaggerGraph.cs,CalculateTopology,Cyclomatic complexity of the method is 24
Complex Method,DaggerLib.Core,DaggerGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib\Core\DaggerGraph.cs,OnPinsDisonnected,Cyclomatic complexity of the method is 13
Complex Method,DaggerLib.Core,DaggerGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib\Core\DaggerGraph.cs,GetObjectData,Cyclomatic complexity of the method is 28
Complex Method,DaggerLib.Core,DaggerGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib\Core\DaggerGraph.cs,OnDeserializedMethod,Cyclomatic complexity of the method is 19
Complex Method,DaggerLib.Core,DaggerOutputPin,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib\Core\DaggerOutputPin.cs,ConnectToInput,Cyclomatic complexity of the method is 14
Complex Method,DaggerLib.Core,DaggerOutputPin,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib\Core\DaggerOutputPin.cs,Disconnect,Cyclomatic complexity of the method is 11
Complex Method,PIEBALD.Types,Set,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib\SetGeneric\Set.cs,ToString,Cyclomatic complexity of the method is 11
Long Statement,DaggerLib.Core,DaggerGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib\Core\DaggerGraph.cs,OnDeserializedMethod,The length of the statement  "				throw new SerializationException ("Error Assisting Deserialization of DaggerNode Type " + assist.NodeType.ToString ()' ex); " is 123.
Long Statement,DaggerLib.Core,DaggerInterface,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib\Core\DaggerInterface.cs,Implements,The length of the statement  "		if (!((foundPin.PinDataType.IsAssignableFrom (pin.PinDataType)) || pin.PinDataType.IsAssignableFrom (foundPin.PinDataType))) { " is 126.
Long Statement,DaggerLib.Core,DaggerInterface,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib\Core\DaggerInterface.cs,Implements,The length of the statement  "		if (!((foundPin.PinDataType.IsAssignableFrom (pin.PinDataType)) || pin.PinDataType.IsAssignableFrom (foundPin.PinDataType))) { " is 126.
Virtual Method Call from Constructor,PIEBALD.Types,Set,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib\SetGeneric\Set.cs,Set,The constructor "Set" calls a virtual method "Add".
Empty Catch Block,DaggerLib.Core,DaggerGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib\Core\DaggerGraph.cs,DaggerGraph,The method has an empty catch block.
Empty Catch Block,DaggerLib.Core,DaggerInputPin,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib\Core\DaggerInputPin.cs,DaggerInputPin,The method has an empty catch block.
Magic Number,DaggerLib.Core,DaggerGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib\Core\DaggerGraph.cs,CalculateTopology,The following statement contains a magic number: foreach (DaggerNode node in AllNodes) {  	PinMutexGroups allGroups = PinMutexGroups.None;  	// do the input pins  	foreach (DaggerInputPin pin in node.InputPins) {  		//gather exising Mutex groups  		allGroups |= pin.MutexGroup;  	}  	// clear the existing status dictionary  	node._inputMutexConnections.Clear ();  	if (allGroups != PinMutexGroups.None) {  		int bitVal = 1;  		for (int i = 0; i < 9; i++) {  			if (((int)allGroups & bitVal) != 0) {  				node._inputMutexConnections [(PinMutexGroups)bitVal] = node.IsInputMutexGroupsConnected ((PinMutexGroups)bitVal);  			}  			bitVal = bitVal << 1;  		}  	}  	allGroups = PinMutexGroups.None;  	// do the output pins  	foreach (DaggerOutputPin pin in node.OutputPins) {  		// gather exising Mutex groups  		allGroups |= pin.MutexGroup;  	}  	// clear the existing status dictionary  	node._outputMutexConnections.Clear ();  	if (allGroups != PinMutexGroups.None) {  		int bitVal = 1;  		for (int i = 0; i < 9; i++) {  			if (((int)allGroups & bitVal) != 0) {  				node._outputMutexConnections [(PinMutexGroups)bitVal] = node.IsOutputMutexGroupsConnected ((PinMutexGroups)bitVal);  			}  			bitVal = bitVal << 1;  		}  	}  }  
Magic Number,DaggerLib.Core,DaggerGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib\Core\DaggerGraph.cs,CalculateTopology,The following statement contains a magic number: foreach (DaggerNode node in AllNodes) {  	PinMutexGroups allGroups = PinMutexGroups.None;  	// do the input pins  	foreach (DaggerInputPin pin in node.InputPins) {  		//gather exising Mutex groups  		allGroups |= pin.MutexGroup;  	}  	// clear the existing status dictionary  	node._inputMutexConnections.Clear ();  	if (allGroups != PinMutexGroups.None) {  		int bitVal = 1;  		for (int i = 0; i < 9; i++) {  			if (((int)allGroups & bitVal) != 0) {  				node._inputMutexConnections [(PinMutexGroups)bitVal] = node.IsInputMutexGroupsConnected ((PinMutexGroups)bitVal);  			}  			bitVal = bitVal << 1;  		}  	}  	allGroups = PinMutexGroups.None;  	// do the output pins  	foreach (DaggerOutputPin pin in node.OutputPins) {  		// gather exising Mutex groups  		allGroups |= pin.MutexGroup;  	}  	// clear the existing status dictionary  	node._outputMutexConnections.Clear ();  	if (allGroups != PinMutexGroups.None) {  		int bitVal = 1;  		for (int i = 0; i < 9; i++) {  			if (((int)allGroups & bitVal) != 0) {  				node._outputMutexConnections [(PinMutexGroups)bitVal] = node.IsOutputMutexGroupsConnected ((PinMutexGroups)bitVal);  			}  			bitVal = bitVal << 1;  		}  	}  }  
Magic Number,DaggerLib.Core,DaggerGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib\Core\DaggerGraph.cs,CalculateTopology,The following statement contains a magic number: if (allGroups != PinMutexGroups.None) {  	int bitVal = 1;  	for (int i = 0; i < 9; i++) {  		if (((int)allGroups & bitVal) != 0) {  			node._inputMutexConnections [(PinMutexGroups)bitVal] = node.IsInputMutexGroupsConnected ((PinMutexGroups)bitVal);  		}  		bitVal = bitVal << 1;  	}  }  
Magic Number,DaggerLib.Core,DaggerGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib\Core\DaggerGraph.cs,CalculateTopology,The following statement contains a magic number: for (int i = 0; i < 9; i++) {  	if (((int)allGroups & bitVal) != 0) {  		node._inputMutexConnections [(PinMutexGroups)bitVal] = node.IsInputMutexGroupsConnected ((PinMutexGroups)bitVal);  	}  	bitVal = bitVal << 1;  }  
Magic Number,DaggerLib.Core,DaggerGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib\Core\DaggerGraph.cs,CalculateTopology,The following statement contains a magic number: if (allGroups != PinMutexGroups.None) {  	int bitVal = 1;  	for (int i = 0; i < 9; i++) {  		if (((int)allGroups & bitVal) != 0) {  			node._outputMutexConnections [(PinMutexGroups)bitVal] = node.IsOutputMutexGroupsConnected ((PinMutexGroups)bitVal);  		}  		bitVal = bitVal << 1;  	}  }  
Magic Number,DaggerLib.Core,DaggerGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib\Core\DaggerGraph.cs,CalculateTopology,The following statement contains a magic number: for (int i = 0; i < 9; i++) {  	if (((int)allGroups & bitVal) != 0) {  		node._outputMutexConnections [(PinMutexGroups)bitVal] = node.IsOutputMutexGroupsConnected ((PinMutexGroups)bitVal);  	}  	bitVal = bitVal << 1;  }  
Missing Default,PIEBALD.Types,Set,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib\SetGeneric\Set.cs,ToString,The following switch statement is missing a default case: switch (SortMode) {  case SortMode.None: {  	foreach (T t in this) {  		result.Append (sep);  		result.Append ((string)meth.Invoke (t' FormatInfo));  		sep = " ' ";  	}  	break;  }  case SortMode.Native: {  	System.Collections.Generic.List<T> temp = new System.Collections.Generic.List<T> (this.elements.Keys);  	temp.Sort ();  	foreach (T t in temp) {  		result.Append (sep);  		result.Append ((string)meth.Invoke (t' FormatInfo));  		sep = " ' ";  	}  	break;  }  case SortMode.String: {  	System.Collections.Generic.List<string> temp = new System.Collections.Generic.List<string> (this.Cardinality);  	foreach (T t in this) {  		temp.Add ((string)meth.Invoke (t' FormatInfo));  	}  	temp.Sort ();  	foreach (string s in temp) {  		result.Append (sep);  		result.Append (s);  		sep = " ' ";  	}  	break;  }  }  
