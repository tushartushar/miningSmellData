Implementation smell,Namespace,Class,File,Method,Description
Long Method,DaggerLib.UI.AStar,Grid,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\AStar\Grid.cs,GetAdjacentCosts,The method has 128 lines of code.
Long Method,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_pathFinder,The method has 106 lines of code.
Long Method,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,CreateCanvasImage,The method has 126 lines of code.
Complex Method,DaggerLib.UI.AStar,AStar,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\AStar\AStar.cs,DeterminePath,Cyclomatic complexity of the method is 14
Complex Method,DaggerLib.UI.AStar,Grid,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\AStar\Grid.cs,IncLine,Cyclomatic complexity of the method is 24
Complex Method,DaggerLib.UI.AStar,Grid,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\AStar\Grid.cs,GetAdjacentCosts,Cyclomatic complexity of the method is 22
Complex Method,DaggerLib.UI.Windows,BasePinContextMenuStrip,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\BasePinContextMenuStrip.cs,OnOpening,Cyclomatic complexity of the method is 19
Complex Method,DaggerLib.UI.Windows,DaggerNodeTreeView,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNodeTreeView.cs,AddAssembly,Cyclomatic complexity of the method is 9
Complex Method,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodlePath,Cyclomatic complexity of the method is 27
Complex Method,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_pathFinder,Cyclomatic complexity of the method is 15
Complex Method,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_lineStyle,Cyclomatic complexity of the method is 8
Complex Method,DaggerLib.UI.Windows,DaggerNoodleContainer,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodles,Cyclomatic complexity of the method is 28
Complex Method,DaggerLib.UI.Windows,DaggerNoodleContainer,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_createPathGrid,Cyclomatic complexity of the method is 11
Complex Method,DaggerLib.UI.Windows,DaggerPinLegendElement,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerPinLegend.cs,CalculatePinRegion,Cyclomatic complexity of the method is 8
Complex Method,DaggerLib.UI.Windows,DaggerGraphPropertyGrid,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerPropertyGrid\DaggerGraphPropertyGrid.cs,comboBox1_SelectedIndexChanged,Cyclomatic complexity of the method is 8
Complex Method,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,DaggerUIGraph,Cyclomatic complexity of the method is 13
Complex Method,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,_graph_NodeAdded,Cyclomatic complexity of the method is 10
Complex Method,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,contextMenuStrip_Opening,Cyclomatic complexity of the method is 12
Complex Method,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,DeleteAndRelink,Cyclomatic complexity of the method is 8
Complex Method,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,ArrangeNodes,Cyclomatic complexity of the method is 11
Complex Method,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,DeleteSelected,Cyclomatic complexity of the method is 10
Complex Method,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,CreateCanvasImage,Cyclomatic complexity of the method is 23
Complex Method,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,OnMouseDown,Cyclomatic complexity of the method is 21
Complex Method,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,OnMouseMove,Cyclomatic complexity of the method is 18
Complex Method,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,OnDragOver,Cyclomatic complexity of the method is 8
Complex Method,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,MouseProc,Cyclomatic complexity of the method is 12
Complex Method,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,KeyboardProc,Cyclomatic complexity of the method is 12
Complex Method,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,m_wndToolTip_Popup,Cyclomatic complexity of the method is 19
Complex Method,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,m_wndToolTip_Draw,Cyclomatic complexity of the method is 24
Complex Method,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,OnMouseMove,Cyclomatic complexity of the method is 29
Complex Method,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,OnMouseDown,Cyclomatic complexity of the method is 28
Complex Method,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,OnDragDrop,Cyclomatic complexity of the method is 8
Complex Method,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,ValidateContextMenuStrip,Cyclomatic complexity of the method is 8
Complex Method,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,CanConnectToPin,Cyclomatic complexity of the method is 11
Complex Method,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,CreateBackImage,Cyclomatic complexity of the method is 11
Complex Method,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,DrawCaption,Cyclomatic complexity of the method is 10
Complex Method,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,UpdatePaths,Cyclomatic complexity of the method is 13
Complex Method,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,UpdateTargetRegions,Cyclomatic complexity of the method is 8
Complex Method,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,UpdateRegion,Cyclomatic complexity of the method is 8
Complex Method,DaggerLib.UI.Windows,DaggerOverlay,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIOverlay.cs,OnMouseMove,Cyclomatic complexity of the method is 15
Complex Method,DaggerLib.UI.Windows,GenericValueEditor,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,LayoutSubControls,Cyclomatic complexity of the method is 9
Complex Method,DaggerLib.UI.Windows,StandardValuesUIEditor,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,EditValue,Cyclomatic complexity of the method is 9
Complex Method,DaggerLib.UI.Windows,Selector,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\Selector.cs,UpdateSelected,Cyclomatic complexity of the method is 9
Complex Method,PropertyGridEx,CustomPropertyCollection,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerPropertyGrid\PropertyGridEx\CustomPropertyCollection.cs,GetProperties,Cyclomatic complexity of the method is 16
Complex Method,PropertyGridEx,UIListboxEditor,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerPropertyGrid\PropertyGridEx\UIListboxEditor.cs,EditValue,Cyclomatic complexity of the method is 9
Long Parameter List,DaggerLib.UI.Windows,DaggerPinLegend,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerPinLegend.cs,AddPinType,The method has 7 parameters.
Long Parameter List,DaggerLib.UI.Windows,DaggerPinLegendElement,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerPinLegend.cs,DaggerPinLegendElement,The method has 7 parameters.
Long Parameter List,DaggerLib.UI.Windows,DaggerOverlay,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIOverlay.cs,DaggerOverlay,The method has 5 parameters.
Long Parameter List,DaggerLib.UI.Windows,GenericValueEditor,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,SetBoundsCore,The method has 5 parameters.
Long Parameter List,DaggerLib.UI.Windows,DropDownForm,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,SetBoundsCore,The method has 5 parameters.
Long Parameter List,DaggerLib.UI.Windows,Selector,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\Selector.cs,lineSegmentIntersection,The method has 8 parameters.
Long Parameter List,PropertyGridEx,CustomProperty,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerPropertyGrid\PropertyGridEx\CustomProperty.cs,CustomProperty,The method has 6 parameters.
Long Parameter List,PropertyGridEx,CustomProperty,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerPropertyGrid\PropertyGridEx\CustomProperty.cs,CustomProperty,The method has 7 parameters.
Long Parameter List,PropertyGridEx,CustomPropertyCollection,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerPropertyGrid\PropertyGridEx\CustomPropertyCollection.cs,Add,The method has 6 parameters.
Long Parameter List,PropertyGridEx,CustomPropertyCollection,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerPropertyGrid\PropertyGridEx\CustomPropertyCollection.cs,Add,The method has 7 parameters.
Long Statement,DaggerLib.UI.AStar,Grid,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\AStar\Grid.cs,IsOnGrid,The length of the statement  "	if ((X >= m_rWorkingRegion.Left) && (X <= m_rWorkingRegion.Right) && (Y >= m_rWorkingRegion.Top) && (Y <= m_rWorkingRegion.Bottom)) " is 131.
Long Statement,DaggerLib.UI.AStar,Grid,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\AStar\Grid.cs,GoalReached,The length of the statement  "	if (this.m_rGoal.Left <= r.Right && this.m_rGoal.Right >= r.Left && this.m_rGoal.Top <= r.Bottom && this.m_rGoal.Bottom >= r.Top) " is 129.
Long Statement,DaggerLib.UI.AStar,AStarHeap,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\AStar\Heap.cs,IsLower,The length of the statement  "	if (c1.TotalCost < c2.TotalCost || ((c1.TotalCost == c2.TotalCost) && ((c1.TurnCount < c2.TurnCount) || ((c1.TurnCount == c2.TurnCount) && (c1.CurrentCost > c2.CurrentCost))))) " is 176.
Long Statement,DaggerLib.UI.Windows,BasePinContextMenuStrip,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\BasePinContextMenuStrip.cs,OnOpening,The length of the statement  "	if ((pin is DaggerOutputPin && (pin as DaggerOutputPin).AllowMultiConnect) || (pin is DaggerOutputPin && !(pin as DaggerOutputPin).AllowMultiConnect && !pin.IsConnected) || (pin is DaggerInputPin && !pin.IsConnected)) { " is 219.
Long Statement,DaggerLib.UI.Windows,BasePinContextMenuStrip,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\BasePinContextMenuStrip.cs,OnOpening,The length of the statement  "							if ((!outpin.IsConnected || outpin.AllowMultiConnect) && outpin.IsCompatibleDataTypes ((DaggerInputPin)pin' (DaggerOutputPin)outpin)) { " is 135.
Long Statement,DaggerLib.UI.Windows,DaggerNodeTreeView,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNodeTreeView.cs,InitializeComponent,The length of the statement  "	this._categoryContextMenuStrip.Opening += new System.ComponentModel.CancelEventHandler (this._categoryContextMenuStrip_Opening); " is 128.
Long Statement,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodlePath,The length of the statement  "			_outputPoint = (_outputPin.ParentUIGraph as DaggerUIGraph).PointToClient ((_outputPin.ParentNode.UINode as DaggerUINode).PointToScreen ((_outputPin.PinUIElements as PinUI).PinLocation)); " is 186.
Long Statement,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodlePath,The length of the statement  "			_outputPoint.X += (_outputPin.ParentNode.UINode.PinSize / 2) - (_outputPin.ParentUIGraph as DaggerUIGraph).AutoScrollPosition.X; " is 128.
Long Statement,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodlePath,The length of the statement  "			_outputPoint.Y += (_outputPin.ParentNode.UINode.PinSize / 2) - (_outputPin.ParentUIGraph as DaggerUIGraph).AutoScrollPosition.Y; " is 128.
Long Statement,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodlePath,The length of the statement  "			_inputPoint = (_inputPin.ParentUIGraph as DaggerUIGraph).PointToClient ((_inputPin.ParentNode.UINode as DaggerUINode).PointToScreen ((_inputPin.PinUIElements as PinUI).PinLocation)); " is 182.
Long Statement,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodlePath,The length of the statement  "			_inputPoint.X += (_inputPin.ParentNode.UINode.PinSize / 2) - (_inputPin.ParentUIGraph as DaggerUIGraph).AutoScrollPosition.X; " is 125.
Long Statement,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodlePath,The length of the statement  "			_inputPoint.Y += (_inputPin.ParentNode.UINode.PinSize / 2) - (_inputPin.ParentUIGraph as DaggerUIGraph).AutoScrollPosition.Y; " is 125.
Long Statement,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodlePath,The length of the statement  "					Point mpoint = (m2 == 0) ? _hmidPoint (points [pcount + 1]' points [pcount + 2]) : _vmidPoint (points [pcount + 1]' points [pcount + 2]); " is 137.
Long Statement,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_pathFinder,The length of the statement  "			grid.IncLine (new Point (points [i].X / grain' points [i].Y / grain)' new Point (points [i + 1].X / grain' points [i + 1].Y / grain)' pathCost); " is 144.
Long Statement,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_pathFinder,The length of the statement  "		grid.IncLine (new Point (points [points.Count - 2].X / grain' points [points.Count - 2].Y / grain)' new Point (points [points.Count - 1].X / grain' points [points.Count - 1].Y / grain)' pathCost); " is 196.
Long Statement,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_lineStyle,The length of the statement  "		inputPoints.Add (new Point (inputThrowPoint.X - (inputPins.Count - inputPins.IndexOf (_inputPin)) * 10 - 10' inputThrowPoint.Y)); " is 129.
Long Statement,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_lineStyle,The length of the statement  "		Rectangle rect = new Rectangle (_outputPin.ParentNode.UINode.Left - autoscrollOffset.X' _outputPin.ParentNode.UINode.Top - autoscrollOffset.Y' _outputPin.ParentNode.UINode.Width' _outputPin.ParentNode.UINode.Height); " is 216.
Long Statement,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_lineStyle,The length of the statement  "		if (Selector.lineRectangleIntersection (rect' outputPoints [outputPoints.Count - 1]' inputPoints [inputPoints.Count - 1])) { " is 124.
Long Statement,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_lineStyle,The length of the statement  "		Rectangle rect = new Rectangle (_inputPin.ParentNode.UINode.Left - autoscrollOffset.X' _inputPin.ParentNode.UINode.Top - autoscrollOffset.Y' _inputPin.ParentNode.UINode.Width' _inputPin.ParentNode.UINode.Height); " is 212.
Long Statement,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_lineStyle,The length of the statement  "		if (Selector.lineRectangleIntersection (rect' outputPoints [outputPoints.Count - 1]' inputPoints [inputPoints.Count - 1])) { " is 124.
Long Statement,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_bezierStyle,The length of the statement  "			path.AddBezier (OutputPoint' new Point (OutputPoint.X + bezcontroloffset' OutputPoint.Y + slopeOffset)' new Point (InputPoint.X - bezcontroloffset' InputPoint.Y + slopeOffset)' InputPoint); " is 189.
Long Statement,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_bezierStyle,The length of the statement  "			path.AddBezier (OutputPoint' new Point (OutputPoint.X - bezcontroloffset' OutputPoint.Y + slopeOffset)' new Point (InputPoint.X + bezcontroloffset' InputPoint.Y + slopeOffset)' InputPoint); " is 189.
Long Statement,DaggerLib.UI.Windows,DaggerNoodleContainer,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_createPathGrid,The length of the statement  "	DaggerLib.UI.AStar.AStar grid = new DaggerLib.UI.AStar.AStar (new Rectangle (0' 0' w' h)' 10' diagonalCost' new Point (w - 1' h - 1)); " is 134.
Long Statement,DaggerLib.UI.Windows,DaggerPinLegend,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerPinLegend.cs,AddPinType,The length of the statement  "	this [t] = new DaggerPinLegendElement (_pinSize' InputNotConnected' InputConnected' OutputNotConnected' OutputConnected' pinColor' transparencyKey); " is 148.
Long Statement,DaggerLib.UI.Windows,DaggerPinLegendElement,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerPinLegend.cs,CopyAndRecolorBitmap,The length of the statement  "	g.DrawImage (bitmap' new Rectangle (0' 0' pinSize' pinSize)' 0' 0' bitmap.Width' bitmap.Height' GraphicsUnit.Pixel' iat); " is 121.
Long Statement,DaggerLib.UI.Windows,DaggerPinLegendElement,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerPinLegend.cs,CalculatePinRegion,The length of the statement  "	int key = ((transparencyKey.A << 24) | (transparencyKey.R << 16) | (transparencyKey.G << 8) | (transparencyKey.B << 0)); " is 120.
Long Statement,DaggerLib.UI.Windows,DaggerGraphPropertyGrid,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerPropertyGrid\DaggerGraphPropertyGrid.cs,propertyGridEx1_PropertyValueChangedNoProcess,The length of the statement  "	PropertyGridEx.CustomProperty cp = (PropertyGridEx.CustomProperty)((PropertyGridEx.CustomProperty.CustomPropertyDescriptor)(e.ChangedItem.PropertyDescriptor)).CustomProperty; " is 174.
Long Statement,DaggerLib.UI.Windows,DaggerGraphPropertyGrid,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerPropertyGrid\DaggerGraphPropertyGrid.cs,propertyGridEx1_PropertyValueChanged,The length of the statement  "		PropertyGridEx.CustomProperty cp = (PropertyGridEx.CustomProperty)((PropertyGridEx.CustomProperty.CustomPropertyDescriptor)(e.ChangedItem.PropertyDescriptor)).CustomProperty; " is 174.
Long Statement,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,InitializeComponent,The length of the statement  "	System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager (typeof(DaggerUIGraph)); " is 134.
Long Statement,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,InitializeComponent,The length of the statement  "	this.CursorImages.ImageStream = ((System.Windows.Forms.ImageListStreamer)(resources.GetObject ("CursorImages.ImageStream"))); " is 125.
Long Statement,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,stackNodesMenuItem_Click,The length of the statement  "		_focusPuck.Location = new Point (FocusLocationX' FocusLocationY + (node as DaggerUINode).Height + AutoArrangeHeightOffset); " is 123.
Long Statement,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,BeginOutputPinConnect,The length of the statement  "	Point pinCenter = new Point ((pin.PinUIElements as PinUI).PinLocation.X + (pinSize / 2)' (pin.PinUIElements as PinUI).PinLocation.Y + (pinSize / 2)); " is 149.
Long Statement,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,BeginInputPinConnect,The length of the statement  "	Point pinCenter = new Point ((pin.PinUIElements as PinUI).PinLocation.X + (pinSize / 2)' (pin.PinUIElements as PinUI).PinLocation.Y + (pinSize / 2)); " is 149.
Long Statement,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,UpdateImportPins,The length of the statement  "			topOffset = PointToClient (node.PointToScreen ((node._node.InputPins [0].PinUIElements as PinUI).PinLocation)).Y - this._pinLegend.PinSize / 2; " is 143.
Long Statement,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,UpdateImportPins,The length of the statement  "		(pin.PinUIElements as PinUI).PinLocation = new Point ((int)_widestImportName + _pinSpacing' topOffset + (int)(_highestImportName / 2)); " is 135.
Long Statement,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,UpdateImportPins,The length of the statement  "		(pin.PinUIElements as PinUI).TargetRegion = new Region (new Rectangle ((pin.PinUIElements as PinUI).PinLocation' new Size (_pinSize' _pinSize))); " is 145.
Long Statement,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,UpdateExportPins,The length of the statement  "			topOffset = PointToClient (node.PointToScreen ((node._node.OutputPins [0].PinUIElements as PinUI).PinLocation)).Y - this._pinLegend.PinSize / 2; " is 144.
Long Statement,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,UpdateExportPins,The length of the statement  "		(pin.PinUIElements as PinUI).PinLocation = new Point (CanvasSize.Width - (int)_widestExportName - _pinSpacing - _pinSize' topOffset + (int)(_highestExportName / 2)); " is 165.
Long Statement,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,UpdateExportPins,The length of the statement  "		(pin.PinUIElements as PinUI).TargetRegion = new Region (new Rectangle ((pin.PinUIElements as PinUI).PinLocation' new Size (_pinSize' _pinSize))); " is 145.
Long Statement,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,CanConnectToPin,The length of the statement  "	Point actualPosition = new Point (clientMousePosition.X - AutoScrollPosition.X' clientMousePosition.Y - AutoScrollPosition.Y); " is 126.
Long Statement,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,UpdateTrackingNoodle,The length of the statement  "				startPoint = (_trackingConnectPin.InputPin.ParentNode.UINode as DaggerUINode).PointToScreen ((_trackingConnectPin.InputPin.PinUIElements as PinUI).PinLocation); " is 160.
Long Statement,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,UpdateTrackingNoodle,The length of the statement  "				startPoint = (_trackingConnectPin.InputPin.ParentGraph.ParentUIGraph as DaggerUIGraph).PointToScreen ((_trackingConnectPin.InputPin.PinUIElements as PinUI).PinLocation); " is 169.
Long Statement,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,UpdateTrackingNoodle,The length of the statement  "				startPoint = (_trackingConnectPin.OutputPin.ParentNode.UINode as DaggerUINode).PointToScreen ((_trackingConnectPin.OutputPin.PinUIElements as PinUI).PinLocation); " is 162.
Long Statement,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,UpdateTrackingNoodle,The length of the statement  "				startPoint = (_trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph as DaggerUIGraph).PointToScreen ((_trackingConnectPin.OutputPin.PinUIElements as PinUI).PinLocation); " is 171.
Long Statement,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,UpdateTrackingNoodle,The length of the statement  "		_trackingConnectPin.StartPoint = PointToClient (new Point (startPoint.X + AutoScrollOffset.X' startPoint.Y + AutoScrollOffset.Y)); " is 130.
Long Statement,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,CreateDropShadowImage,The length of the statement  "		translateMatrix.Translate ((node.Left + _dropShadowXoffset) - AutoScrollPosition.X' (node.Top + _dropShadowYoffset) - AutoScrollPosition.Y); " is 140.
Long Statement,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,CreateDropShadowImage,The length of the statement  "	g.DrawImage (tempb' new Rectangle (0' 0' tempb.Width' tempb.Height)' 0' 0' tempb.Width' tempb.Height' GraphicsUnit.Pixel' imgAttr); " is 131.
Long Statement,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,CreateCanvasImage,The length of the statement  "			Point outputpoint = new Point (noodle.OutputPoint.X + AutoScrollPosition.X' noodle.OutputPoint.Y + AutoScrollPosition.Y); " is 121.
Long Statement,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,CreateCanvasImage,The length of the statement  "			Brush lb = new LinearGradientBrush (outputpoint' inputpoint' (noodle.OutputPin.PinUIElements as PinUI).NoodleColor' (noodle.InputPin.PinUIElements as PinUI).NoodleColor); " is 170.
Long Statement,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,CreateCanvasImage,The length of the statement  "			Rectangle noderect = new Rectangle ((node as DaggerUINode).Left - AutoScrollPosition.X' (node as DaggerUINode).Top - AutoScrollPosition.Y' (node as DaggerUINode).Width' (node as DaggerUINode).Height); " is 200.
Long Statement,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,CreateCanvasImage,The length of the statement  "					g.DrawString (pin.Name' Font' fontB' new RectangleF (0' (pin.PinUIElements as PinUI).PinLocation.Y' _widestImportName' 20)); " is 124.
Long Statement,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,CreateCanvasImage,The length of the statement  "					g.DrawImage ((pin.PinUIElements as PinUI).PinImageConnected' new Rectangle ((pin.PinUIElements as PinUI).PinLocation.X' (pin.PinUIElements as PinUI).PinLocation.Y' _pinLegend.PinSize' _pinLegend.PinSize)' 0' 0' _pinLegend.PinSize' _pinLegend.PinSize' GraphicsUnit.Pixel' att); " is 276.
Long Statement,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,CreateCanvasImage,The length of the statement  "			g.FillRectangle (backB' CanvasSize.Width - _widestExportName - _pinSpacing' 0' _widestExportName' ActualCanvasSize.Height); " is 123.
Long Statement,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,CreateCanvasImage,The length of the statement  "					g.DrawString (pin.Name' Font' fontB' new RectangleF (CanvasSize.Width - _widestExportName - _pinSpacing' (pin.PinUIElements as PinUI).PinLocation.Y' _widestExportName' 20)); " is 173.
Long Statement,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,CreateCanvasImage,The length of the statement  "					g.DrawImage ((pin.PinUIElements as PinUI).PinImageConnected' new Rectangle ((pin.PinUIElements as PinUI).PinLocation.X' (pin.PinUIElements as PinUI).PinLocation.Y' _pinLegend.PinSize' _pinLegend.PinSize)' 0' 0' _pinLegend.PinSize' _pinLegend.PinSize' GraphicsUnit.Pixel' att); " is 276.
Long Statement,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,OnPaint,The length of the statement  "		Pen np = new Pen ((_trackingConnectPin.OutputPin != null) ? (_trackingConnectPin.OutputPin.PinUIElements as PinUI).NoodleColor : (_trackingConnectPin.InputPin.PinUIElements as PinUI).NoodleColor); " is 196.
Long Statement,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,OnMouseDown,The length of the statement  "			_trackingSelector = new Selector (this' new Point (e.X - AutoScrollPosition.X' e.Y - AutoScrollPosition.Y)' _noodles.Noodles' AllNodes); " is 136.
Long Statement,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,OnDragOver,The length of the statement  "		DaggerNodeTreeViewSubnodeItem tn = (DaggerNodeTreeViewSubnodeItem)((TreeNode)drgevent.Data.GetData (typeof(TreeNode))).Tag; " is 123.
Long Statement,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,OnDragOver,The length of the statement  "				if (DaggerBasePin.IsCompatibleDataTypes (tn.InputpinTypes [0]' noodle.OutputPin.DataType) && DaggerBasePin.IsCompatibleDataTypes (noodle.InputPin.DataType' tn.OutputPinTypes [0])) { " is 181.
Long Statement,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,OnDragDrop,The length of the statement  "	DaggerNodeTreeViewSubnodeItem tn = (DaggerNodeTreeViewSubnodeItem)((TreeNode)drgevent.Data.GetData (typeof(TreeNode))).Tag; " is 123.
Long Statement,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,MouseProc,The length of the statement  "					newscrollpos = Math.Min (HorizontalScroll.Maximum' HorizontalScroll.Value + (_trackingConnectPin.TrackPoint.X - Width)); " is 120.
Long Statement,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,m_wndToolTip_Popup,The length of the statement  "			e.ToolTipSize = TextRenderer.MeasureText (_tooltiptext + (_parentGraph.ShowOrdinal ? ": Ordinal " + _node.Ordinal.ToString () : "")' f); " is 136.
Long Statement,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,m_wndToolTip_Popup,The length of the statement  "			e.ToolTipSize = TextRenderer.MeasureText (_captionText + (_parentGraph.ShowOrdinal ? ": Ordinal " + _node.Ordinal.ToString () : "")' f); " is 136.
Long Statement,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,m_wndToolTip_Draw,The length of the statement  "		string theText = (_mouseOverPin != null) ? _mouseOverPin.Name : ((_tooltiptext == "") ? _captionText : _tooltiptext) + (_parentGraph.ShowOrdinal ? ": Ordinal " + _node.Ordinal.ToString () : ""); " is 194.
Long Statement,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,OnMouseDown,The length of the statement  "				if ((ParentUIGraph as DaggerUIGraph)._trackingSelector != null && (ParentUIGraph as DaggerUIGraph)._trackingSelector.SelectedNodes.Contains (this as IDaggerUINode)) { " is 166.
Long Statement,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,OnMouseDown,The length of the statement  "					eol = new DaggerOverlay (this' _canAlterState' PointToScreen (e.Location)' NodeMinimumSize.Width' NodeMinimumSize.Height); " is 122.
Long Statement,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,OnMouseDown,The length of the statement  "				DaggerOverlay eol = new DaggerOverlay (this' _canAlterState' PointToScreen (e.Location)' NodeMinimumSize.Width' NodeMinimumSize.Height); " is 136.
Long Statement,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,OnDragOver,The length of the statement  "			if ((_parentGraph.TrackingPin.ParentNode != null && _parentGraph.TrackingPin.ParentNode.UINode != this) || _parentGraph.TrackingPin.ParentNode == null) { " is 153.
Long Statement,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,CanConnectToPin,The length of the statement  "				alterState = trackingPin.CanConnectToPin (_mouseOverPin) ? DaggerNodeAlterState.CanConnectToInput : DaggerNodeAlterState.None; " is 126.
Long Statement,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,CanConnectToPin,The length of the statement  "				alterState = trackingPin.CanConnectToPin (_mouseOverPin) ? DaggerNodeAlterState.CanConnectToOutput : DaggerNodeAlterState.None; " is 127.
Long Statement,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,CreateBackImage,The length of the statement  "		int inputpintop = (Height - ((_node.InputPins.MutexAvailablePins.Count * PinSize) + ((_node.InputPins.MutexAvailablePins.Count - 1) * _pinSpacing))) / 2; " is 153.
Long Statement,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,CreateBackImage,The length of the statement  "		int outputpintop = (Height - ((_node.OutputPins.MutexAvailablePins.Count * PinSize) + ((_node.OutputPins.MutexAvailablePins.Count - 1) * _pinSpacing))) / 2; " is 156.
Long Statement,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,CreateBackImage,The length of the statement  "			Image pinimage = _node.InputPins.MutexAvailablePins [i].IsConnected ? (_node.InputPins.MutexAvailablePins [i].PinUIElements as PinUI).PinImageConnected : (_node.InputPins.MutexAvailablePins [i].PinUIElements as PinUI).PinImageDisconnected; " is 239.
Long Statement,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,CreateBackImage,The length of the statement  "			Color alphakey = _node.InputPins.MutexAvailablePins [i].IsConnected ? (_node.InputPins.MutexAvailablePins [i].PinUIElements as PinUI).PinImageConnectedTransparent : (_node.InputPins.MutexAvailablePins [i].PinUIElements as PinUI).PinImageDisconnectedTransparent; " is 261.
Long Statement,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,CreateBackImage,The length of the statement  "			g.DrawImage (pinimage' new Rectangle (0' inputpintop' PinSize' PinSize)' 0' 0' PinSize' PinSize' GraphicsUnit.Pixel' att); " is 122.
Long Statement,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,CreateBackImage,The length of the statement  "			Image pinimage = _node.OutputPins.MutexAvailablePins [i].IsConnected ? (_node.OutputPins.MutexAvailablePins [i].PinUIElements as PinUI).PinImageConnected : (_node.OutputPins.MutexAvailablePins [i].PinUIElements as PinUI).PinImageDisconnected; " is 242.
Long Statement,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,CreateBackImage,The length of the statement  "			Color alphakey = _node.OutputPins.MutexAvailablePins [i].IsConnected ? (_node.OutputPins.MutexAvailablePins [i].PinUIElements as PinUI).PinImageConnectedTransparent : (_node.OutputPins.MutexAvailablePins [i].PinUIElements as PinUI).PinImageDisconnectedTransparent; " is 264.
Long Statement,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,CreateBackImage,The length of the statement  "			g.DrawImage (pinimage' new Rectangle (Width - PinSize' outputpintop' PinSize' PinSize)' 0' 0' PinSize' PinSize' GraphicsUnit.Pixel' att); " is 137.
Long Statement,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,DrawCaption,The length of the statement  "	using (LinearGradientBrush b = new LinearGradientBrush (new Point (0' 0)' new Point (0' _captionSize)' ControlPaint.Dark (capColor)' ControlPaint.Light (capColor))) { " is 166.
Long Statement,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,UpdateTargetRegions,The length of the statement  "		int inputpintop = (Height - ((_node.InputPins.MutexAvailablePins.Count * PinSize) + ((_node.InputPins.MutexAvailablePins.Count - 1) * _pinSpacing))) / 2; " is 153.
Long Statement,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,UpdateTargetRegions,The length of the statement  "		int outputpintop = (Height - ((_node.OutputPins.MutexAvailablePins.Count * PinSize) + ((_node.OutputPins.MutexAvailablePins.Count - 1) * _pinSpacing))) / 2; " is 156.
Long Statement,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,UpdateTargetRegions,The length of the statement  "			(_node.InputPins.MutexAvailablePins [i].PinUIElements as PinUI).TargetRegion = new Region (new Rectangle (0' inputpintop' PinSize' PinSize)); " is 141.
Long Statement,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,UpdateTargetRegions,The length of the statement  "			(_node.OutputPins.MutexAvailablePins [i].PinUIElements as PinUI).TargetRegion = new Region (new Rectangle (Width - PinSize' outputpintop' PinSize' PinSize)); " is 157.
Long Statement,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,UpdateRegion,The length of the statement  "					Region tempr = new Region (pin.IsConnected ? (pin.PinUIElements as PinUI).PinConnectedRegion.GetRegionData () : (pin.PinUIElements as PinUI).PinDisconnectedRegion.GetRegionData ()); " is 181.
Long Statement,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,UpdateRegion,The length of the statement  "					Region tempr = new Region (pin.IsConnected ? (pin.PinUIElements as PinUI).PinConnectedRegion.GetRegionData () : (pin.PinUIElements as PinUI).PinDisconnectedRegion.GetRegionData ()); " is 181.
Long Statement,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,CalculateLayout,The length of the statement  "	_internalControl.Size = new Size (this.Width - (_internalControlPadding * 2) - (PinSize * 2)' this.Height - (_internalControlPadding * 2) - _captionSize); " is 154.
Long Statement,DaggerLib.UI.Windows,GenericValueEditor,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,OnConverterOrEditorChanged,The length of the statement  "	hasStandardValues = converter != null && converter.GetStandardValuesSupported () && converter.GetStandardValues ().Count != 0; " is 126.
Long Statement,DaggerLib.UI.Windows,GenericValueEditor,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,LayoutSubControls,The length of the statement  "		previewControl.SetBounds (cRect.X + 1' cRect.Y + 1' ShowPreviewOnly ? Math.Max (0' cRect.Width - buttonWidth - 2) : Math.Min (PAINT_VALUE_WIDTH' Math.Max (0' cRect.Width - buttonWidth - 2))' Math.Max (0' cRect.Height - 2)); " is 223.
Long Statement,DaggerLib.UI.Windows,GenericValueEditor,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,LayoutSubControls,The length of the statement  "		textBox.SetBounds (cRect.X + leftMargin' cRect.Y + topMargin' Math.Max (0' cRect.Width - buttonWidth - leftMargin)' Math.Max (0' cRect.Height)); " is 144.
Long Statement,DaggerLib.UI.Windows,EditorButton,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,OnPaint,The length of the statement  "		ControlPaint.DrawComboButton (g' ClientRectangle' !Enabled ? ButtonState.Inactive : (pushed ? ButtonState.Pushed : ButtonState.Normal)); " is 136.
Long Statement,DaggerLib.UI.Windows,Selector,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\Selector.cs,UpdateSelected,The length of the statement  "					noderect.Offset ((_parent as ScrollableControl).AutoScrollPosition.X * -1' (_parent as ScrollableControl).AutoScrollPosition.Y * -1); " is 133.
Long Statement,DaggerLib.UI.Windows,SimpleImageButton,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\SimpleImageButton.cs,OnPaint,The length of the statement  "			e.Graphics.DrawImage (_state ? image2 : image' new Rectangle (0' 0' this.Width' this.Height)' 0' 0' image.Width' image.Height' GraphicsUnit.Pixel' ImgAttr); " is 156.
Long Statement,DaggerLib.UI.Windows,SimpleImageButton,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\SimpleImageButton.cs,OnPaint,The length of the statement  "				e.Graphics.DrawImage (_state ? image2 : image' new Rectangle (0' 0' this.Width' this.Height)' 0' 0' image.Width' image.Height' GraphicsUnit.Pixel' ImgAttr); " is 156.
Long Statement,DaggerLib.UI.Windows,SimpleImageButton,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\SimpleImageButton.cs,OnPaint,The length of the statement  "				e.Graphics.DrawImage (_state ? image2 : image' new Rectangle (0' 0' this.Width' this.Height)' 0' 0' image.Width' image.Height' GraphicsUnit.Pixel' ImgAttr); " is 156.
Long Statement,DaggerLib.UI.Windows,UIGraphNavigator,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\UIGraphNavigator.cs,_uigraph_ViewportChanged,The length of the statement  "	_viewPortRect = new Rectangle ((int)(_rzoom.Width * _viewPort.X + _rzoom.X)' (int)(_rzoom.Height * _viewPort.Y + _rzoom.Y)' (int)(_rzoom.Width * _viewPort.Width)' (int)(_rzoom.Height * _viewPort.Height)); " is 204.
Long Statement,DaggerLib.UI.Windows,UIGraphNavigator,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\UIGraphNavigator.cs,_uigraph_CanvasImageChanged,The length of the statement  "		g.DrawImage (tempb' new Rectangle (0' 0' _canvasImage.Width' _canvasImage.Height)' new Rectangle (0' 0' tempb.Width' tempb.Height)' GraphicsUnit.Pixel); " is 152.
Long Statement,DaggerLib.UI.Windows,UIGraphNavigator,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\UIGraphNavigator.cs,OnMouseMove,The length of the statement  "			_uigraph.ScrollToPosition (new Point ((int)(scalex * (float)_uigraph.ActualCanvasSize.Width)' (int)(scaley * (float)_uigraph.ActualCanvasSize.Height))); " is 152.
Long Statement,PropertyGridEx,BrowsableTypeConverter,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerPropertyGrid\PropertyGridEx\BrowsableTypeConverter.cs,ConvertTo,The length of the statement  "	BrowsableLabelStyleAttribute attribute1 = (BrowsableLabelStyleAttribute)context.PropertyDescriptor.Attributes [typeof(BrowsableLabelStyleAttribute)]; " is 149.
Long Statement,PropertyGridEx,CustomProperty,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerPropertyGrid\PropertyGridEx\CustomProperty.cs,BuildAttributes_BrowsableProperty,The length of the statement  "	BrowsableTypeConverter.BrowsableLabelStyleAttribute style = new BrowsableTypeConverter.BrowsableLabelStyleAttribute (eBrowsablePropertyLabel); " is 142.
Long Statement,PropertyGridEx,CustomPropertyCollection,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerPropertyGrid\PropertyGridEx\CustomPropertyCollection.cs,Add,The length of the statement  "	return base.List.Add (new CustomProperty (strName' objValue' boolIsReadOnly' strCategory' strDescription' boolVisible)); " is 120.
Long Statement,PropertyGridEx,CustomPropertyCollection,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerPropertyGrid\PropertyGridEx\CustomPropertyCollection.cs,Add,The length of the statement  "	return base.List.Add (new CustomProperty (strName' ref objRef' strProp' boolIsReadOnly' strCategory' strDescription' boolVisible)); " is 131.
Long Statement,PropertyGridEx,PropertyGridEx,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerPropertyGrid\PropertyGridEx\PropertyGridEx.cs,MoveSplitterTo,The length of the statement  "	oPropertyGridView.GetType ().InvokeMember ("MoveSplitterTo"' BindingFlags.InvokeMethod | BindingFlags.NonPublic | BindingFlags.Instance' null' oPropertyGridView' new object[] { " is 176.
Long Statement,PropertyGridEx,PropertyGridEx,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerPropertyGrid\PropertyGridEx\PropertyGridEx.cs,AutoSizeSplitter,The length of the statement  "	GridItemCollection oItemCollection = (System.Windows.Forms.GridItemCollection)oPropertyGridEntries.GetValue (oPropertyGridView); " is 128.
Long Statement,PropertyGridEx,UIFilenameEditor,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerPropertyGrid\PropertyGridEx\UIFilenameEditor.cs,EditValue,The length of the statement  "	FileDialogFilterAttribute filterAtt = (FileDialogFilterAttribute)context.PropertyDescriptor.Attributes [typeof(FileDialogFilterAttribute)]; " is 139.
Long Statement,PropertyGridEx,UIListboxEditor,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerPropertyGrid\PropertyGridEx\UIListboxEditor.cs,GetEditStyle,The length of the statement  "		UIListboxIsDropDownResizable attribute = (UIListboxIsDropDownResizable)context.PropertyDescriptor.Attributes [typeof(UIListboxIsDropDownResizable)]; " is 148.
Long Statement,PropertyGridEx,UIListboxEditor,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerPropertyGrid\PropertyGridEx\UIListboxEditor.cs,EditValue,The length of the statement  "	oEditorService = (System.Windows.Forms.Design.IWindowsFormsEditorService)provider.GetService (typeof(IWindowsFormsEditorService)); " is 130.
Long Statement,PropertyGridEx,UIListboxEditor,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerPropertyGrid\PropertyGridEx\UIListboxEditor.cs,EditValue,The length of the statement  "		CustomProperty.CustomPropertyDescriptor oDescriptor = (CustomProperty.CustomPropertyDescriptor)context.PropertyDescriptor; " is 122.
Complex Conditional,DaggerLib.UI.AStar,AStar,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\AStar\AStar.cs,IsSameLine,The conditional expression  "((dX2 == 0) && (dX1 == 0)) || // or both slopes are equal  ((dX2 != 0) && (dX1 != 0) && (dY2 / dX2) == (dY1 / dX1) && (dY2 % dX2) == (dY1) % (dX1))"  is complex.
Complex Conditional,DaggerLib.UI.AStar,Grid,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\AStar\Grid.cs,IsOnGrid,The conditional expression  "(X >= m_rWorkingRegion.Left) && (X <= m_rWorkingRegion.Right) && (Y >= m_rWorkingRegion.Top) && (Y <= m_rWorkingRegion.Bottom)"  is complex.
Complex Conditional,DaggerLib.UI.AStar,Grid,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\AStar\Grid.cs,GoalReached,The conditional expression  "this.m_rGoal.Left <= r.Right && this.m_rGoal.Right >= r.Left && this.m_rGoal.Top <= r.Bottom && this.m_rGoal.Bottom >= r.Top"  is complex.
Complex Conditional,DaggerLib.UI.AStar,AStarHeap,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\AStar\Heap.cs,IsLower,The conditional expression  "c1.TotalCost < c2.TotalCost || ((c1.TotalCost == c2.TotalCost) && ((c1.TurnCount < c2.TurnCount) || ((c1.TurnCount == c2.TurnCount) && (c1.CurrentCost > c2.CurrentCost))))"  is complex.
Complex Conditional,DaggerLib.UI.Windows,BasePinContextMenuStrip,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\BasePinContextMenuStrip.cs,OnOpening,The conditional expression  "(pin is DaggerOutputPin && (pin as DaggerOutputPin).AllowMultiConnect) || (pin is DaggerOutputPin && !(pin as DaggerOutputPin).AllowMultiConnect && !pin.IsConnected) || (pin is DaggerInputPin && !pin.IsConnected)"  is complex.
Complex Conditional,DaggerLib.UI.Windows,DaggerNoodleContainer,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_createPathGrid,The conditional expression  "top < 0 || bottom > h || left < 0 || right > w"  is complex.
Complex Conditional,DaggerLib.UI.Windows,Selector,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\Selector.cs,lineSegmentIntersection,The conditional expression  "Ax == Bx && Ay == By || Cx == Dx && Cy == Dy"  is complex.
Complex Conditional,DaggerLib.UI.Windows,Selector,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\Selector.cs,lineSegmentIntersection,The conditional expression  "Cy < 0f && Dy < 0f || Cy >= 0f && Dy >= 0f"  is complex.
Complex Conditional,DaggerLib.UI.Windows,UIGraphNavigator,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\UIGraphNavigator.cs,OnPaintBackground,The conditional expression  "_viewPort.X != 0f || _viewPort.Y != 0f || _viewPort.Width != 1f || _viewPort.Height != 1f"  is complex.
Empty Catch Block,DaggerLib.UI.Windows,GenericValueEditor,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,GetValueAsText,The method has an empty catch block.
Empty Catch Block,DaggerLib.UI.Windows,GenericValueEditor,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,DropEditor,The method has an empty catch block.
Empty Catch Block,DaggerLib.UI.Windows,GenericValueEditor,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,ValidateText,The method has an empty catch block.
Magic Number,DaggerLib.UI.AStar,AStar,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\AStar\AStar.cs,DeterminePath,The following statement contains a magic number: if (!m_bStepInit)// if the solution was previously started   {  	m_bStepInit = true;  	// Add all the accessible points surrounding the start point to the heap.  	// then start with the cheapest and work your way down to the target  	pcCellCosts = GetAdjacentCosts (Start.Location' ObjectSize);  	for (int i = 0; i < 8; i++) {  		if (pcCellCosts [i].Cost == int.MaxValue)  			continue;  		this [pcCellCosts [i].P].CurrentCost = pcCellCosts [i].Cost;  		this [pcCellCosts [i].P].BackDirection = Start.Location;  		this [pcCellCosts [i].P].EstimatedCost = this.EstRemainingCost (pcCellCosts [i].P' ObjectSize);  		m_asHeap.Add (this [pcCellCosts [i].P]);  	}  }  
Magic Number,DaggerLib.UI.AStar,AStar,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\AStar\AStar.cs,DeterminePath,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	if (pcCellCosts [i].Cost == int.MaxValue)  		continue;  	this [pcCellCosts [i].P].CurrentCost = pcCellCosts [i].Cost;  	this [pcCellCosts [i].P].BackDirection = Start.Location;  	this [pcCellCosts [i].P].EstimatedCost = this.EstRemainingCost (pcCellCosts [i].P' ObjectSize);  	m_asHeap.Add (this [pcCellCosts [i].P]);  }  
Magic Number,DaggerLib.UI.AStar,AStar,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\AStar\AStar.cs,DeterminePath,The following statement contains a magic number: for (iCurrentCount = 0' c = m_asHeap.PopCell (); c != null; iCurrentCount++' c = m_asHeap.PopCell ()) {  	// if the current count is equal to the stop count' then push the cell and return  	if ((iStopCount > 0) && (iCurrentCount >= iStopCount)) {  		m_asHeap.Add (c);  		break;  	}  	m_pCurrent = c.Center;  	// if we've reached the goal' then break out of the loop.  	// - added check for estimated cost == 0.  That will short circuit  	// the more expensive GoalReached function most of the time.  	if ((c.EstimatedCost == 0) && (GoalReached (new Rectangle (c.Center' ObjectSize))))  		break;  	pcCellCosts = this.GetAdjacentCosts (c.Center' ObjectSize);  	Cell cNewCell;  	for (int i = 0; i < 8; i++) {  		if ((pcCellCosts [i].Cost == int.MaxValue) || (!IsOnGrid (pcCellCosts [i].P.X' pcCellCosts [i].P.Y)))  			continue;  		cNewCell = this [pcCellCosts [i].P];  		// If that node is being used' check to see if the Current Cost of that  		// Node is greater than the cost of the current route to get there  		int iCurrentCellCost = this [pcCellCosts [i].P].CurrentCost;  		int iNewPathCost = c.CurrentCost + pcCellCosts [i].Cost;  		int iTurnCount = c.TurnCount;  		if (!IsSameLine (c.Center' c.BackDirection' pcCellCosts [i].P))  			iTurnCount++;  		// I needed to change this from >= to > in order to  		// only swap those where the turn count is actually less  		// if ((iCurrentCellCost >= iNewPathCost) ||  		if ((iCurrentCellCost > iNewPathCost) || ((iCurrentCellCost == iNewPathCost) && (iTurnCount < cNewCell.TurnCount))) {  			cNewCell.CurrentCost = c.CurrentCost + pcCellCosts [i].Cost;  			cNewCell.EstimatedCost = this.EstRemainingCost (pcCellCosts [i].P' ObjectSize);  			// If this cell is in the same direction as the previous cell' then  			// reuse the target cell's back pointer  			if (IsSameLine (pcCellCosts [i].P' c.Center' c.BackDirection)) {  				cNewCell.BackDirection = c.BackDirection;  				cNewCell.TurnCount = this [c.Center.X' c.Center.Y].TurnCount;  			}  			else {  				cNewCell.BackDirection = c.Center;  				cNewCell.TurnCount = this [c.Center.X' c.Center.Y].TurnCount + 1;  			}  			// test to see if this is a new cell or if we're reusing a cell  			if (iCurrentCellCost == int.MaxValue)  				m_asHeap.Add (cNewCell);  			else  				//DO REHEAPUP since the item is already in the heap  				m_asHeap.ReHeapUp (cNewCell.iHeapIndex);  		}  	}  }  
Magic Number,DaggerLib.UI.AStar,AStar,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\AStar\AStar.cs,DeterminePath,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	if ((pcCellCosts [i].Cost == int.MaxValue) || (!IsOnGrid (pcCellCosts [i].P.X' pcCellCosts [i].P.Y)))  		continue;  	cNewCell = this [pcCellCosts [i].P];  	// If that node is being used' check to see if the Current Cost of that  	// Node is greater than the cost of the current route to get there  	int iCurrentCellCost = this [pcCellCosts [i].P].CurrentCost;  	int iNewPathCost = c.CurrentCost + pcCellCosts [i].Cost;  	int iTurnCount = c.TurnCount;  	if (!IsSameLine (c.Center' c.BackDirection' pcCellCosts [i].P))  		iTurnCount++;  	// I needed to change this from >= to > in order to  	// only swap those where the turn count is actually less  	// if ((iCurrentCellCost >= iNewPathCost) ||  	if ((iCurrentCellCost > iNewPathCost) || ((iCurrentCellCost == iNewPathCost) && (iTurnCount < cNewCell.TurnCount))) {  		cNewCell.CurrentCost = c.CurrentCost + pcCellCosts [i].Cost;  		cNewCell.EstimatedCost = this.EstRemainingCost (pcCellCosts [i].P' ObjectSize);  		// If this cell is in the same direction as the previous cell' then  		// reuse the target cell's back pointer  		if (IsSameLine (pcCellCosts [i].P' c.Center' c.BackDirection)) {  			cNewCell.BackDirection = c.BackDirection;  			cNewCell.TurnCount = this [c.Center.X' c.Center.Y].TurnCount;  		}  		else {  			cNewCell.BackDirection = c.Center;  			cNewCell.TurnCount = this [c.Center.X' c.Center.Y].TurnCount + 1;  		}  		// test to see if this is a new cell or if we're reusing a cell  		if (iCurrentCellCost == int.MaxValue)  			m_asHeap.Add (cNewCell);  		else  			//DO REHEAPUP since the item is already in the heap  			m_asHeap.ReHeapUp (cNewCell.iHeapIndex);  	}  }  
Magic Number,DaggerLib.UI.AStar,Grid,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\AStar\Grid.cs,GetAdjacentCosts,The following statement contains a magic number: pcTemp [2].Cost = Math.Max (iLeft' Math.Max (iBottom' iLL));  
Magic Number,DaggerLib.UI.AStar,Grid,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\AStar\Grid.cs,GetAdjacentCosts,The following statement contains a magic number: if (pcTemp [2].Cost != int.MaxValue)  	pcTemp [2].Cost = (pcTemp [2].Cost * this.m_iDiagonalCost) / m_iCost;  
Magic Number,DaggerLib.UI.AStar,Grid,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\AStar\Grid.cs,GetAdjacentCosts,The following statement contains a magic number: if (pcTemp [2].Cost != int.MaxValue)  	pcTemp [2].Cost = (pcTemp [2].Cost * this.m_iDiagonalCost) / m_iCost;  
Magic Number,DaggerLib.UI.AStar,Grid,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\AStar\Grid.cs,GetAdjacentCosts,The following statement contains a magic number: if (pcTemp [2].Cost != int.MaxValue)  	pcTemp [2].Cost = (pcTemp [2].Cost * this.m_iDiagonalCost) / m_iCost;  
Magic Number,DaggerLib.UI.AStar,Grid,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\AStar\Grid.cs,GetAdjacentCosts,The following statement contains a magic number: pcTemp [2].Cost = (pcTemp [2].Cost * this.m_iDiagonalCost) / m_iCost;  
Magic Number,DaggerLib.UI.AStar,Grid,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\AStar\Grid.cs,GetAdjacentCosts,The following statement contains a magic number: pcTemp [2].Cost = (pcTemp [2].Cost * this.m_iDiagonalCost) / m_iCost;  
Magic Number,DaggerLib.UI.AStar,Grid,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\AStar\Grid.cs,GetAdjacentCosts,The following statement contains a magic number: pcTemp [3].Cost = iTop;  
Magic Number,DaggerLib.UI.AStar,Grid,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\AStar\Grid.cs,GetAdjacentCosts,The following statement contains a magic number: pcTemp [4].Cost = iBottom;  
Magic Number,DaggerLib.UI.AStar,Grid,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\AStar\Grid.cs,GetAdjacentCosts,The following statement contains a magic number: pcTemp [5].Cost = Math.Max (iRight' Math.Max (iTop' iUR));  
Magic Number,DaggerLib.UI.AStar,Grid,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\AStar\Grid.cs,GetAdjacentCosts,The following statement contains a magic number: if (pcTemp [5].Cost != int.MaxValue)  	pcTemp [5].Cost = (pcTemp [5].Cost * this.m_iDiagonalCost) / m_iCost;  
Magic Number,DaggerLib.UI.AStar,Grid,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\AStar\Grid.cs,GetAdjacentCosts,The following statement contains a magic number: if (pcTemp [5].Cost != int.MaxValue)  	pcTemp [5].Cost = (pcTemp [5].Cost * this.m_iDiagonalCost) / m_iCost;  
Magic Number,DaggerLib.UI.AStar,Grid,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\AStar\Grid.cs,GetAdjacentCosts,The following statement contains a magic number: if (pcTemp [5].Cost != int.MaxValue)  	pcTemp [5].Cost = (pcTemp [5].Cost * this.m_iDiagonalCost) / m_iCost;  
Magic Number,DaggerLib.UI.AStar,Grid,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\AStar\Grid.cs,GetAdjacentCosts,The following statement contains a magic number: pcTemp [5].Cost = (pcTemp [5].Cost * this.m_iDiagonalCost) / m_iCost;  
Magic Number,DaggerLib.UI.AStar,Grid,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\AStar\Grid.cs,GetAdjacentCosts,The following statement contains a magic number: pcTemp [5].Cost = (pcTemp [5].Cost * this.m_iDiagonalCost) / m_iCost;  
Magic Number,DaggerLib.UI.AStar,Grid,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\AStar\Grid.cs,GetAdjacentCosts,The following statement contains a magic number: pcTemp [6].Cost = iRight;  
Magic Number,DaggerLib.UI.AStar,Grid,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\AStar\Grid.cs,GetAdjacentCosts,The following statement contains a magic number: pcTemp [7].Cost = Math.Max (iRight' Math.Max (iBottom' iLR));  
Magic Number,DaggerLib.UI.AStar,Grid,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\AStar\Grid.cs,GetAdjacentCosts,The following statement contains a magic number: if (pcTemp [7].Cost != int.MaxValue)  	pcTemp [7].Cost = (pcTemp [7].Cost * this.m_iDiagonalCost) / m_iCost;  
Magic Number,DaggerLib.UI.AStar,Grid,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\AStar\Grid.cs,GetAdjacentCosts,The following statement contains a magic number: if (pcTemp [7].Cost != int.MaxValue)  	pcTemp [7].Cost = (pcTemp [7].Cost * this.m_iDiagonalCost) / m_iCost;  
Magic Number,DaggerLib.UI.AStar,Grid,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\AStar\Grid.cs,GetAdjacentCosts,The following statement contains a magic number: if (pcTemp [7].Cost != int.MaxValue)  	pcTemp [7].Cost = (pcTemp [7].Cost * this.m_iDiagonalCost) / m_iCost;  
Magic Number,DaggerLib.UI.AStar,Grid,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\AStar\Grid.cs,GetAdjacentCosts,The following statement contains a magic number: pcTemp [7].Cost = (pcTemp [7].Cost * this.m_iDiagonalCost) / m_iCost;  
Magic Number,DaggerLib.UI.AStar,Grid,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\AStar\Grid.cs,GetAdjacentCosts,The following statement contains a magic number: pcTemp [7].Cost = (pcTemp [7].Cost * this.m_iDiagonalCost) / m_iCost;  
Magic Number,DaggerLib.UI.AStar,AStarHeap,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\AStar\Heap.cs,ReHeapUp,The following statement contains a magic number: for (int i = m_cArray.Count; i > 1; i = i / 2) {  	if (IsLower (m_cArray [i - 1]' m_cArray [i / 2 - 1])) {  		Cell pTemp = m_cArray [i - 1];  		m_cArray [i - 1] = m_cArray [i / 2 - 1];  		m_cArray [i / 2 - 1] = pTemp;  		// Set the Heap Indexes  		m_cArray [i - 1].iHeapIndex = i - 1;  		m_cArray [i / 2 - 1].iHeapIndex = i / 2 - 1;  	}  	else  		break;  }  
Magic Number,DaggerLib.UI.AStar,AStarHeap,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\AStar\Heap.cs,ReHeapUp,The following statement contains a magic number: for (int i = m_cArray.Count; i > 1; i = i / 2) {  	if (IsLower (m_cArray [i - 1]' m_cArray [i / 2 - 1])) {  		Cell pTemp = m_cArray [i - 1];  		m_cArray [i - 1] = m_cArray [i / 2 - 1];  		m_cArray [i / 2 - 1] = pTemp;  		// Set the Heap Indexes  		m_cArray [i - 1].iHeapIndex = i - 1;  		m_cArray [i / 2 - 1].iHeapIndex = i / 2 - 1;  	}  	else  		break;  }  
Magic Number,DaggerLib.UI.AStar,AStarHeap,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\AStar\Heap.cs,ReHeapUp,The following statement contains a magic number: for (int i = m_cArray.Count; i > 1; i = i / 2) {  	if (IsLower (m_cArray [i - 1]' m_cArray [i / 2 - 1])) {  		Cell pTemp = m_cArray [i - 1];  		m_cArray [i - 1] = m_cArray [i / 2 - 1];  		m_cArray [i / 2 - 1] = pTemp;  		// Set the Heap Indexes  		m_cArray [i - 1].iHeapIndex = i - 1;  		m_cArray [i / 2 - 1].iHeapIndex = i / 2 - 1;  	}  	else  		break;  }  
Magic Number,DaggerLib.UI.AStar,AStarHeap,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\AStar\Heap.cs,ReHeapUp,The following statement contains a magic number: for (int i = m_cArray.Count; i > 1; i = i / 2) {  	if (IsLower (m_cArray [i - 1]' m_cArray [i / 2 - 1])) {  		Cell pTemp = m_cArray [i - 1];  		m_cArray [i - 1] = m_cArray [i / 2 - 1];  		m_cArray [i / 2 - 1] = pTemp;  		// Set the Heap Indexes  		m_cArray [i - 1].iHeapIndex = i - 1;  		m_cArray [i / 2 - 1].iHeapIndex = i / 2 - 1;  	}  	else  		break;  }  
Magic Number,DaggerLib.UI.AStar,AStarHeap,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\AStar\Heap.cs,ReHeapUp,The following statement contains a magic number: for (int i = m_cArray.Count; i > 1; i = i / 2) {  	if (IsLower (m_cArray [i - 1]' m_cArray [i / 2 - 1])) {  		Cell pTemp = m_cArray [i - 1];  		m_cArray [i - 1] = m_cArray [i / 2 - 1];  		m_cArray [i / 2 - 1] = pTemp;  		// Set the Heap Indexes  		m_cArray [i - 1].iHeapIndex = i - 1;  		m_cArray [i / 2 - 1].iHeapIndex = i / 2 - 1;  	}  	else  		break;  }  
Magic Number,DaggerLib.UI.AStar,AStarHeap,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\AStar\Heap.cs,ReHeapUp,The following statement contains a magic number: for (int i = m_cArray.Count; i > 1; i = i / 2) {  	if (IsLower (m_cArray [i - 1]' m_cArray [i / 2 - 1])) {  		Cell pTemp = m_cArray [i - 1];  		m_cArray [i - 1] = m_cArray [i / 2 - 1];  		m_cArray [i / 2 - 1] = pTemp;  		// Set the Heap Indexes  		m_cArray [i - 1].iHeapIndex = i - 1;  		m_cArray [i / 2 - 1].iHeapIndex = i / 2 - 1;  	}  	else  		break;  }  
Magic Number,DaggerLib.UI.AStar,AStarHeap,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\AStar\Heap.cs,ReHeapUp,The following statement contains a magic number: i = i / 2
Magic Number,DaggerLib.UI.AStar,AStarHeap,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\AStar\Heap.cs,ReHeapUp,The following statement contains a magic number: if (IsLower (m_cArray [i - 1]' m_cArray [i / 2 - 1])) {  	Cell pTemp = m_cArray [i - 1];  	m_cArray [i - 1] = m_cArray [i / 2 - 1];  	m_cArray [i / 2 - 1] = pTemp;  	// Set the Heap Indexes  	m_cArray [i - 1].iHeapIndex = i - 1;  	m_cArray [i / 2 - 1].iHeapIndex = i / 2 - 1;  }  else  	break;  
Magic Number,DaggerLib.UI.AStar,AStarHeap,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\AStar\Heap.cs,ReHeapUp,The following statement contains a magic number: if (IsLower (m_cArray [i - 1]' m_cArray [i / 2 - 1])) {  	Cell pTemp = m_cArray [i - 1];  	m_cArray [i - 1] = m_cArray [i / 2 - 1];  	m_cArray [i / 2 - 1] = pTemp;  	// Set the Heap Indexes  	m_cArray [i - 1].iHeapIndex = i - 1;  	m_cArray [i / 2 - 1].iHeapIndex = i / 2 - 1;  }  else  	break;  
Magic Number,DaggerLib.UI.AStar,AStarHeap,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\AStar\Heap.cs,ReHeapUp,The following statement contains a magic number: if (IsLower (m_cArray [i - 1]' m_cArray [i / 2 - 1])) {  	Cell pTemp = m_cArray [i - 1];  	m_cArray [i - 1] = m_cArray [i / 2 - 1];  	m_cArray [i / 2 - 1] = pTemp;  	// Set the Heap Indexes  	m_cArray [i - 1].iHeapIndex = i - 1;  	m_cArray [i / 2 - 1].iHeapIndex = i / 2 - 1;  }  else  	break;  
Magic Number,DaggerLib.UI.AStar,AStarHeap,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\AStar\Heap.cs,ReHeapUp,The following statement contains a magic number: if (IsLower (m_cArray [i - 1]' m_cArray [i / 2 - 1])) {  	Cell pTemp = m_cArray [i - 1];  	m_cArray [i - 1] = m_cArray [i / 2 - 1];  	m_cArray [i / 2 - 1] = pTemp;  	// Set the Heap Indexes  	m_cArray [i - 1].iHeapIndex = i - 1;  	m_cArray [i / 2 - 1].iHeapIndex = i / 2 - 1;  }  else  	break;  
Magic Number,DaggerLib.UI.AStar,AStarHeap,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\AStar\Heap.cs,ReHeapUp,The following statement contains a magic number: if (IsLower (m_cArray [i - 1]' m_cArray [i / 2 - 1])) {  	Cell pTemp = m_cArray [i - 1];  	m_cArray [i - 1] = m_cArray [i / 2 - 1];  	m_cArray [i / 2 - 1] = pTemp;  	// Set the Heap Indexes  	m_cArray [i - 1].iHeapIndex = i - 1;  	m_cArray [i / 2 - 1].iHeapIndex = i / 2 - 1;  }  else  	break;  
Magic Number,DaggerLib.UI.AStar,AStarHeap,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\AStar\Heap.cs,ReHeapUp,The following statement contains a magic number: m_cArray [i - 1] = m_cArray [i / 2 - 1];  
Magic Number,DaggerLib.UI.AStar,AStarHeap,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\AStar\Heap.cs,ReHeapUp,The following statement contains a magic number: m_cArray [i / 2 - 1] = pTemp;  
Magic Number,DaggerLib.UI.AStar,AStarHeap,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\AStar\Heap.cs,ReHeapUp,The following statement contains a magic number: m_cArray [i / 2 - 1].iHeapIndex = i / 2 - 1;  
Magic Number,DaggerLib.UI.AStar,AStarHeap,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\AStar\Heap.cs,ReHeapUp,The following statement contains a magic number: m_cArray [i / 2 - 1].iHeapIndex = i / 2 - 1;  
Magic Number,DaggerLib.UI.AStar,AStarHeap,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\AStar\Heap.cs,ReHeapUp,The following statement contains a magic number: for (int i = iStartAt + 1; i > 1; i = i / 2) {  	if (IsLower (m_cArray [i - 1]' m_cArray [i / 2 - 1])) {  		Cell pTemp = m_cArray [i - 1];  		m_cArray [i - 1] = m_cArray [i / 2 - 1];  		m_cArray [i / 2 - 1] = pTemp;  		// Set the Heap Indexes  		m_cArray [i - 1].iHeapIndex = i - 1;  		m_cArray [i / 2 - 1].iHeapIndex = i / 2 - 1;  	}  	else  		break;  }  
Magic Number,DaggerLib.UI.AStar,AStarHeap,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\AStar\Heap.cs,ReHeapUp,The following statement contains a magic number: for (int i = iStartAt + 1; i > 1; i = i / 2) {  	if (IsLower (m_cArray [i - 1]' m_cArray [i / 2 - 1])) {  		Cell pTemp = m_cArray [i - 1];  		m_cArray [i - 1] = m_cArray [i / 2 - 1];  		m_cArray [i / 2 - 1] = pTemp;  		// Set the Heap Indexes  		m_cArray [i - 1].iHeapIndex = i - 1;  		m_cArray [i / 2 - 1].iHeapIndex = i / 2 - 1;  	}  	else  		break;  }  
Magic Number,DaggerLib.UI.AStar,AStarHeap,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\AStar\Heap.cs,ReHeapUp,The following statement contains a magic number: for (int i = iStartAt + 1; i > 1; i = i / 2) {  	if (IsLower (m_cArray [i - 1]' m_cArray [i / 2 - 1])) {  		Cell pTemp = m_cArray [i - 1];  		m_cArray [i - 1] = m_cArray [i / 2 - 1];  		m_cArray [i / 2 - 1] = pTemp;  		// Set the Heap Indexes  		m_cArray [i - 1].iHeapIndex = i - 1;  		m_cArray [i / 2 - 1].iHeapIndex = i / 2 - 1;  	}  	else  		break;  }  
Magic Number,DaggerLib.UI.AStar,AStarHeap,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\AStar\Heap.cs,ReHeapUp,The following statement contains a magic number: for (int i = iStartAt + 1; i > 1; i = i / 2) {  	if (IsLower (m_cArray [i - 1]' m_cArray [i / 2 - 1])) {  		Cell pTemp = m_cArray [i - 1];  		m_cArray [i - 1] = m_cArray [i / 2 - 1];  		m_cArray [i / 2 - 1] = pTemp;  		// Set the Heap Indexes  		m_cArray [i - 1].iHeapIndex = i - 1;  		m_cArray [i / 2 - 1].iHeapIndex = i / 2 - 1;  	}  	else  		break;  }  
Magic Number,DaggerLib.UI.AStar,AStarHeap,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\AStar\Heap.cs,ReHeapUp,The following statement contains a magic number: for (int i = iStartAt + 1; i > 1; i = i / 2) {  	if (IsLower (m_cArray [i - 1]' m_cArray [i / 2 - 1])) {  		Cell pTemp = m_cArray [i - 1];  		m_cArray [i - 1] = m_cArray [i / 2 - 1];  		m_cArray [i / 2 - 1] = pTemp;  		// Set the Heap Indexes  		m_cArray [i - 1].iHeapIndex = i - 1;  		m_cArray [i / 2 - 1].iHeapIndex = i / 2 - 1;  	}  	else  		break;  }  
Magic Number,DaggerLib.UI.AStar,AStarHeap,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\AStar\Heap.cs,ReHeapUp,The following statement contains a magic number: for (int i = iStartAt + 1; i > 1; i = i / 2) {  	if (IsLower (m_cArray [i - 1]' m_cArray [i / 2 - 1])) {  		Cell pTemp = m_cArray [i - 1];  		m_cArray [i - 1] = m_cArray [i / 2 - 1];  		m_cArray [i / 2 - 1] = pTemp;  		// Set the Heap Indexes  		m_cArray [i - 1].iHeapIndex = i - 1;  		m_cArray [i / 2 - 1].iHeapIndex = i / 2 - 1;  	}  	else  		break;  }  
Magic Number,DaggerLib.UI.AStar,AStarHeap,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\AStar\Heap.cs,ReHeapUp,The following statement contains a magic number: i = i / 2
Magic Number,DaggerLib.UI.AStar,AStarHeap,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\AStar\Heap.cs,ReHeapUp,The following statement contains a magic number: if (IsLower (m_cArray [i - 1]' m_cArray [i / 2 - 1])) {  	Cell pTemp = m_cArray [i - 1];  	m_cArray [i - 1] = m_cArray [i / 2 - 1];  	m_cArray [i / 2 - 1] = pTemp;  	// Set the Heap Indexes  	m_cArray [i - 1].iHeapIndex = i - 1;  	m_cArray [i / 2 - 1].iHeapIndex = i / 2 - 1;  }  else  	break;  
Magic Number,DaggerLib.UI.AStar,AStarHeap,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\AStar\Heap.cs,ReHeapUp,The following statement contains a magic number: if (IsLower (m_cArray [i - 1]' m_cArray [i / 2 - 1])) {  	Cell pTemp = m_cArray [i - 1];  	m_cArray [i - 1] = m_cArray [i / 2 - 1];  	m_cArray [i / 2 - 1] = pTemp;  	// Set the Heap Indexes  	m_cArray [i - 1].iHeapIndex = i - 1;  	m_cArray [i / 2 - 1].iHeapIndex = i / 2 - 1;  }  else  	break;  
Magic Number,DaggerLib.UI.AStar,AStarHeap,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\AStar\Heap.cs,ReHeapUp,The following statement contains a magic number: if (IsLower (m_cArray [i - 1]' m_cArray [i / 2 - 1])) {  	Cell pTemp = m_cArray [i - 1];  	m_cArray [i - 1] = m_cArray [i / 2 - 1];  	m_cArray [i / 2 - 1] = pTemp;  	// Set the Heap Indexes  	m_cArray [i - 1].iHeapIndex = i - 1;  	m_cArray [i / 2 - 1].iHeapIndex = i / 2 - 1;  }  else  	break;  
Magic Number,DaggerLib.UI.AStar,AStarHeap,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\AStar\Heap.cs,ReHeapUp,The following statement contains a magic number: if (IsLower (m_cArray [i - 1]' m_cArray [i / 2 - 1])) {  	Cell pTemp = m_cArray [i - 1];  	m_cArray [i - 1] = m_cArray [i / 2 - 1];  	m_cArray [i / 2 - 1] = pTemp;  	// Set the Heap Indexes  	m_cArray [i - 1].iHeapIndex = i - 1;  	m_cArray [i / 2 - 1].iHeapIndex = i / 2 - 1;  }  else  	break;  
Magic Number,DaggerLib.UI.AStar,AStarHeap,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\AStar\Heap.cs,ReHeapUp,The following statement contains a magic number: if (IsLower (m_cArray [i - 1]' m_cArray [i / 2 - 1])) {  	Cell pTemp = m_cArray [i - 1];  	m_cArray [i - 1] = m_cArray [i / 2 - 1];  	m_cArray [i / 2 - 1] = pTemp;  	// Set the Heap Indexes  	m_cArray [i - 1].iHeapIndex = i - 1;  	m_cArray [i / 2 - 1].iHeapIndex = i / 2 - 1;  }  else  	break;  
Magic Number,DaggerLib.UI.AStar,AStarHeap,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\AStar\Heap.cs,ReHeapUp,The following statement contains a magic number: m_cArray [i - 1] = m_cArray [i / 2 - 1];  
Magic Number,DaggerLib.UI.AStar,AStarHeap,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\AStar\Heap.cs,ReHeapUp,The following statement contains a magic number: m_cArray [i / 2 - 1] = pTemp;  
Magic Number,DaggerLib.UI.AStar,AStarHeap,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\AStar\Heap.cs,ReHeapUp,The following statement contains a magic number: m_cArray [i / 2 - 1].iHeapIndex = i / 2 - 1;  
Magic Number,DaggerLib.UI.AStar,AStarHeap,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\AStar\Heap.cs,ReHeapUp,The following statement contains a magic number: m_cArray [i / 2 - 1].iHeapIndex = i / 2 - 1;  
Magic Number,DaggerLib.UI.Windows,BasePinContextMenuStrip,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\BasePinContextMenuStrip.cs,BasePinContextMenuStrip,The following statement contains a magic number: _attachToPinMenuItem.DropDown.Opacity = 0.5;  
Magic Number,DaggerLib.UI.Windows,BasePinContextMenuStrip,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\BasePinContextMenuStrip.cs,_attachToPinMenuItem_DropDownOpened,The following statement contains a magic number: Opacity = 0.5;  
Magic Number,DaggerLib.UI.Windows,DaggerNodeTreeView,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNodeTreeView.cs,InitializeComponent,The following statement contains a magic number: this._subNodeContextMenuStrip.Size = new System.Drawing.Size (153' 26);  
Magic Number,DaggerLib.UI.Windows,DaggerNodeTreeView,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNodeTreeView.cs,InitializeComponent,The following statement contains a magic number: this._subNodeContextMenuStrip.Size = new System.Drawing.Size (153' 26);  
Magic Number,DaggerLib.UI.Windows,DaggerNodeTreeView,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNodeTreeView.cs,InitializeComponent,The following statement contains a magic number: this._exportSubNodeMenuItem.Size = new System.Drawing.Size (152' 22);  
Magic Number,DaggerLib.UI.Windows,DaggerNodeTreeView,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNodeTreeView.cs,InitializeComponent,The following statement contains a magic number: this._exportSubNodeMenuItem.Size = new System.Drawing.Size (152' 22);  
Magic Number,DaggerLib.UI.Windows,DaggerNodeTreeView,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNodeTreeView.cs,InitializeComponent,The following statement contains a magic number: this._categoryContextMenuStrip.Size = new System.Drawing.Size (153' 26);  
Magic Number,DaggerLib.UI.Windows,DaggerNodeTreeView,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNodeTreeView.cs,InitializeComponent,The following statement contains a magic number: this._categoryContextMenuStrip.Size = new System.Drawing.Size (153' 26);  
Magic Number,DaggerLib.UI.Windows,DaggerNodeTreeView,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNodeTreeView.cs,InitializeComponent,The following statement contains a magic number: this._importSubNodeMenuItem.Size = new System.Drawing.Size (152' 22);  
Magic Number,DaggerLib.UI.Windows,DaggerNodeTreeView,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNodeTreeView.cs,InitializeComponent,The following statement contains a magic number: this._importSubNodeMenuItem.Size = new System.Drawing.Size (152' 22);  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodlePath,The following statement contains a magic number: if (_outputPin.ParentNode != null) {  	if (_outputPin.ParentUIGraph != null) {  		_outputPoint = (_outputPin.ParentUIGraph as DaggerUIGraph).PointToClient ((_outputPin.ParentNode.UINode as DaggerUINode).PointToScreen ((_outputPin.PinUIElements as PinUI).PinLocation));  		_outputPoint.X += (_outputPin.ParentNode.UINode.PinSize / 2) - (_outputPin.ParentUIGraph as DaggerUIGraph).AutoScrollPosition.X;  		_outputPoint.Y += (_outputPin.ParentNode.UINode.PinSize / 2) - (_outputPin.ParentUIGraph as DaggerUIGraph).AutoScrollPosition.Y;  	}  }  else {  	//it's an imported pin  	_outputPoint = (_outputPin.PinUIElements as PinUI).PinLocation;  	if (_outputPin.ParentUIGraph != null) {  		_outputPoint.X += (_outputPin.ParentUIGraph.PinSize / 2);  		_outputPoint.Y += (_outputPin.ParentUIGraph.PinSize / 2);  	}  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodlePath,The following statement contains a magic number: if (_outputPin.ParentNode != null) {  	if (_outputPin.ParentUIGraph != null) {  		_outputPoint = (_outputPin.ParentUIGraph as DaggerUIGraph).PointToClient ((_outputPin.ParentNode.UINode as DaggerUINode).PointToScreen ((_outputPin.PinUIElements as PinUI).PinLocation));  		_outputPoint.X += (_outputPin.ParentNode.UINode.PinSize / 2) - (_outputPin.ParentUIGraph as DaggerUIGraph).AutoScrollPosition.X;  		_outputPoint.Y += (_outputPin.ParentNode.UINode.PinSize / 2) - (_outputPin.ParentUIGraph as DaggerUIGraph).AutoScrollPosition.Y;  	}  }  else {  	//it's an imported pin  	_outputPoint = (_outputPin.PinUIElements as PinUI).PinLocation;  	if (_outputPin.ParentUIGraph != null) {  		_outputPoint.X += (_outputPin.ParentUIGraph.PinSize / 2);  		_outputPoint.Y += (_outputPin.ParentUIGraph.PinSize / 2);  	}  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodlePath,The following statement contains a magic number: if (_outputPin.ParentNode != null) {  	if (_outputPin.ParentUIGraph != null) {  		_outputPoint = (_outputPin.ParentUIGraph as DaggerUIGraph).PointToClient ((_outputPin.ParentNode.UINode as DaggerUINode).PointToScreen ((_outputPin.PinUIElements as PinUI).PinLocation));  		_outputPoint.X += (_outputPin.ParentNode.UINode.PinSize / 2) - (_outputPin.ParentUIGraph as DaggerUIGraph).AutoScrollPosition.X;  		_outputPoint.Y += (_outputPin.ParentNode.UINode.PinSize / 2) - (_outputPin.ParentUIGraph as DaggerUIGraph).AutoScrollPosition.Y;  	}  }  else {  	//it's an imported pin  	_outputPoint = (_outputPin.PinUIElements as PinUI).PinLocation;  	if (_outputPin.ParentUIGraph != null) {  		_outputPoint.X += (_outputPin.ParentUIGraph.PinSize / 2);  		_outputPoint.Y += (_outputPin.ParentUIGraph.PinSize / 2);  	}  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodlePath,The following statement contains a magic number: if (_outputPin.ParentNode != null) {  	if (_outputPin.ParentUIGraph != null) {  		_outputPoint = (_outputPin.ParentUIGraph as DaggerUIGraph).PointToClient ((_outputPin.ParentNode.UINode as DaggerUINode).PointToScreen ((_outputPin.PinUIElements as PinUI).PinLocation));  		_outputPoint.X += (_outputPin.ParentNode.UINode.PinSize / 2) - (_outputPin.ParentUIGraph as DaggerUIGraph).AutoScrollPosition.X;  		_outputPoint.Y += (_outputPin.ParentNode.UINode.PinSize / 2) - (_outputPin.ParentUIGraph as DaggerUIGraph).AutoScrollPosition.Y;  	}  }  else {  	//it's an imported pin  	_outputPoint = (_outputPin.PinUIElements as PinUI).PinLocation;  	if (_outputPin.ParentUIGraph != null) {  		_outputPoint.X += (_outputPin.ParentUIGraph.PinSize / 2);  		_outputPoint.Y += (_outputPin.ParentUIGraph.PinSize / 2);  	}  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodlePath,The following statement contains a magic number: if (_outputPin.ParentUIGraph != null) {  	_outputPoint = (_outputPin.ParentUIGraph as DaggerUIGraph).PointToClient ((_outputPin.ParentNode.UINode as DaggerUINode).PointToScreen ((_outputPin.PinUIElements as PinUI).PinLocation));  	_outputPoint.X += (_outputPin.ParentNode.UINode.PinSize / 2) - (_outputPin.ParentUIGraph as DaggerUIGraph).AutoScrollPosition.X;  	_outputPoint.Y += (_outputPin.ParentNode.UINode.PinSize / 2) - (_outputPin.ParentUIGraph as DaggerUIGraph).AutoScrollPosition.Y;  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodlePath,The following statement contains a magic number: if (_outputPin.ParentUIGraph != null) {  	_outputPoint = (_outputPin.ParentUIGraph as DaggerUIGraph).PointToClient ((_outputPin.ParentNode.UINode as DaggerUINode).PointToScreen ((_outputPin.PinUIElements as PinUI).PinLocation));  	_outputPoint.X += (_outputPin.ParentNode.UINode.PinSize / 2) - (_outputPin.ParentUIGraph as DaggerUIGraph).AutoScrollPosition.X;  	_outputPoint.Y += (_outputPin.ParentNode.UINode.PinSize / 2) - (_outputPin.ParentUIGraph as DaggerUIGraph).AutoScrollPosition.Y;  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodlePath,The following statement contains a magic number: _outputPoint.X += (_outputPin.ParentNode.UINode.PinSize / 2) - (_outputPin.ParentUIGraph as DaggerUIGraph).AutoScrollPosition.X;  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodlePath,The following statement contains a magic number: _outputPoint.Y += (_outputPin.ParentNode.UINode.PinSize / 2) - (_outputPin.ParentUIGraph as DaggerUIGraph).AutoScrollPosition.Y;  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodlePath,The following statement contains a magic number: if (_outputPin.ParentUIGraph != null) {  	_outputPoint.X += (_outputPin.ParentUIGraph.PinSize / 2);  	_outputPoint.Y += (_outputPin.ParentUIGraph.PinSize / 2);  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodlePath,The following statement contains a magic number: if (_outputPin.ParentUIGraph != null) {  	_outputPoint.X += (_outputPin.ParentUIGraph.PinSize / 2);  	_outputPoint.Y += (_outputPin.ParentUIGraph.PinSize / 2);  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodlePath,The following statement contains a magic number: _outputPoint.X += (_outputPin.ParentUIGraph.PinSize / 2);  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodlePath,The following statement contains a magic number: _outputPoint.Y += (_outputPin.ParentUIGraph.PinSize / 2);  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodlePath,The following statement contains a magic number: if (_inputPin.ParentNode != null) {  	if (_inputPin.ParentUIGraph != null) {  		_inputPoint = (_inputPin.ParentUIGraph as DaggerUIGraph).PointToClient ((_inputPin.ParentNode.UINode as DaggerUINode).PointToScreen ((_inputPin.PinUIElements as PinUI).PinLocation));  		_inputPoint.X += (_inputPin.ParentNode.UINode.PinSize / 2) - (_inputPin.ParentUIGraph as DaggerUIGraph).AutoScrollPosition.X;  		_inputPoint.Y += (_inputPin.ParentNode.UINode.PinSize / 2) - (_inputPin.ParentUIGraph as DaggerUIGraph).AutoScrollPosition.Y;  	}  }  else {  	//it's an exported pin  	_inputPoint = (_inputPin.PinUIElements as PinUI).PinLocation;  	if (_inputPin.ParentUIGraph != null) {  		_inputPoint.X += (_inputPin.ParentUIGraph.PinSize / 2);  		_inputPoint.Y += (_inputPin.ParentUIGraph.PinSize / 2);  	}  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodlePath,The following statement contains a magic number: if (_inputPin.ParentNode != null) {  	if (_inputPin.ParentUIGraph != null) {  		_inputPoint = (_inputPin.ParentUIGraph as DaggerUIGraph).PointToClient ((_inputPin.ParentNode.UINode as DaggerUINode).PointToScreen ((_inputPin.PinUIElements as PinUI).PinLocation));  		_inputPoint.X += (_inputPin.ParentNode.UINode.PinSize / 2) - (_inputPin.ParentUIGraph as DaggerUIGraph).AutoScrollPosition.X;  		_inputPoint.Y += (_inputPin.ParentNode.UINode.PinSize / 2) - (_inputPin.ParentUIGraph as DaggerUIGraph).AutoScrollPosition.Y;  	}  }  else {  	//it's an exported pin  	_inputPoint = (_inputPin.PinUIElements as PinUI).PinLocation;  	if (_inputPin.ParentUIGraph != null) {  		_inputPoint.X += (_inputPin.ParentUIGraph.PinSize / 2);  		_inputPoint.Y += (_inputPin.ParentUIGraph.PinSize / 2);  	}  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodlePath,The following statement contains a magic number: if (_inputPin.ParentNode != null) {  	if (_inputPin.ParentUIGraph != null) {  		_inputPoint = (_inputPin.ParentUIGraph as DaggerUIGraph).PointToClient ((_inputPin.ParentNode.UINode as DaggerUINode).PointToScreen ((_inputPin.PinUIElements as PinUI).PinLocation));  		_inputPoint.X += (_inputPin.ParentNode.UINode.PinSize / 2) - (_inputPin.ParentUIGraph as DaggerUIGraph).AutoScrollPosition.X;  		_inputPoint.Y += (_inputPin.ParentNode.UINode.PinSize / 2) - (_inputPin.ParentUIGraph as DaggerUIGraph).AutoScrollPosition.Y;  	}  }  else {  	//it's an exported pin  	_inputPoint = (_inputPin.PinUIElements as PinUI).PinLocation;  	if (_inputPin.ParentUIGraph != null) {  		_inputPoint.X += (_inputPin.ParentUIGraph.PinSize / 2);  		_inputPoint.Y += (_inputPin.ParentUIGraph.PinSize / 2);  	}  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodlePath,The following statement contains a magic number: if (_inputPin.ParentNode != null) {  	if (_inputPin.ParentUIGraph != null) {  		_inputPoint = (_inputPin.ParentUIGraph as DaggerUIGraph).PointToClient ((_inputPin.ParentNode.UINode as DaggerUINode).PointToScreen ((_inputPin.PinUIElements as PinUI).PinLocation));  		_inputPoint.X += (_inputPin.ParentNode.UINode.PinSize / 2) - (_inputPin.ParentUIGraph as DaggerUIGraph).AutoScrollPosition.X;  		_inputPoint.Y += (_inputPin.ParentNode.UINode.PinSize / 2) - (_inputPin.ParentUIGraph as DaggerUIGraph).AutoScrollPosition.Y;  	}  }  else {  	//it's an exported pin  	_inputPoint = (_inputPin.PinUIElements as PinUI).PinLocation;  	if (_inputPin.ParentUIGraph != null) {  		_inputPoint.X += (_inputPin.ParentUIGraph.PinSize / 2);  		_inputPoint.Y += (_inputPin.ParentUIGraph.PinSize / 2);  	}  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodlePath,The following statement contains a magic number: if (_inputPin.ParentUIGraph != null) {  	_inputPoint = (_inputPin.ParentUIGraph as DaggerUIGraph).PointToClient ((_inputPin.ParentNode.UINode as DaggerUINode).PointToScreen ((_inputPin.PinUIElements as PinUI).PinLocation));  	_inputPoint.X += (_inputPin.ParentNode.UINode.PinSize / 2) - (_inputPin.ParentUIGraph as DaggerUIGraph).AutoScrollPosition.X;  	_inputPoint.Y += (_inputPin.ParentNode.UINode.PinSize / 2) - (_inputPin.ParentUIGraph as DaggerUIGraph).AutoScrollPosition.Y;  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodlePath,The following statement contains a magic number: if (_inputPin.ParentUIGraph != null) {  	_inputPoint = (_inputPin.ParentUIGraph as DaggerUIGraph).PointToClient ((_inputPin.ParentNode.UINode as DaggerUINode).PointToScreen ((_inputPin.PinUIElements as PinUI).PinLocation));  	_inputPoint.X += (_inputPin.ParentNode.UINode.PinSize / 2) - (_inputPin.ParentUIGraph as DaggerUIGraph).AutoScrollPosition.X;  	_inputPoint.Y += (_inputPin.ParentNode.UINode.PinSize / 2) - (_inputPin.ParentUIGraph as DaggerUIGraph).AutoScrollPosition.Y;  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodlePath,The following statement contains a magic number: _inputPoint.X += (_inputPin.ParentNode.UINode.PinSize / 2) - (_inputPin.ParentUIGraph as DaggerUIGraph).AutoScrollPosition.X;  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodlePath,The following statement contains a magic number: _inputPoint.Y += (_inputPin.ParentNode.UINode.PinSize / 2) - (_inputPin.ParentUIGraph as DaggerUIGraph).AutoScrollPosition.Y;  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodlePath,The following statement contains a magic number: if (_inputPin.ParentUIGraph != null) {  	_inputPoint.X += (_inputPin.ParentUIGraph.PinSize / 2);  	_inputPoint.Y += (_inputPin.ParentUIGraph.PinSize / 2);  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodlePath,The following statement contains a magic number: if (_inputPin.ParentUIGraph != null) {  	_inputPoint.X += (_inputPin.ParentUIGraph.PinSize / 2);  	_inputPoint.Y += (_inputPin.ParentUIGraph.PinSize / 2);  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodlePath,The following statement contains a magic number: _inputPoint.X += (_inputPin.ParentUIGraph.PinSize / 2);  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodlePath,The following statement contains a magic number: _inputPoint.Y += (_inputPin.ParentUIGraph.PinSize / 2);  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodlePath,The following statement contains a magic number: switch (style) {  case NoodleStyle.Bezier:  	_bezierStyle ();  	break;  case NoodleStyle.Lines:  	_lineStyle ();  	break;  case NoodleStyle.CircuitBoardFine:  case NoodleStyle.CircuitBoardCoarse:  	{  		AstarHelper bshelper = (AstarHelper)helper;  		path.AddLines (_pathFinder (bshelper.grid' bshelper.pathCost' bshelper.grain).ToArray ());  	}  	break;  case NoodleStyle.Ramen:  	{  		AstarHelper bshelper = (AstarHelper)helper;  		path.AddCurve (_pathFinder (bshelper.grid' bshelper.pathCost' bshelper.grain).ToArray ()' 0.75f);  		path.Flatten ();  	}  	break;  case NoodleStyle.BendyStraws:  	{  		AstarHelper bshelper = (AstarHelper)helper;  		// traverse the points of the pathfinder and create 90 degree ellipses  		List<Point> points = _pathFinder (bshelper.grid' bshelper.pathCost' bshelper.grain);  		int pcount = 0;  		Point lastpoint = points [0];  		while (pcount < points.Count - 2) {  			float yi = 0' xi = 0;  			float m1 = _slope (lastpoint' points [pcount + 1]' ref yi' ref xi);  			float m2 = _slope (points [pcount + 1]' points [pcount + 2]' ref yi' ref xi);  			if (m1 != m2) {  				// an angle  				// get the mid point of seg2 and create bezier curve  				Point mpoint = (m2 == 0) ? _hmidPoint (points [pcount + 1]' points [pcount + 2]) : _vmidPoint (points [pcount + 1]' points [pcount + 2]);  				path.AddBezier (lastpoint' points [pcount + 1]' points [pcount + 1]' mpoint);  				lastpoint = mpoint;  				pcount++;  			}  			else {  				// strait line  				pcount++;  			}  		}  		// add the last line  		path.AddLine (lastpoint' points [points.Count - 1]);  		path.Flatten ();  	}  	break;  default:  	break;  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodlePath,The following statement contains a magic number: switch (style) {  case NoodleStyle.Bezier:  	_bezierStyle ();  	break;  case NoodleStyle.Lines:  	_lineStyle ();  	break;  case NoodleStyle.CircuitBoardFine:  case NoodleStyle.CircuitBoardCoarse:  	{  		AstarHelper bshelper = (AstarHelper)helper;  		path.AddLines (_pathFinder (bshelper.grid' bshelper.pathCost' bshelper.grain).ToArray ());  	}  	break;  case NoodleStyle.Ramen:  	{  		AstarHelper bshelper = (AstarHelper)helper;  		path.AddCurve (_pathFinder (bshelper.grid' bshelper.pathCost' bshelper.grain).ToArray ()' 0.75f);  		path.Flatten ();  	}  	break;  case NoodleStyle.BendyStraws:  	{  		AstarHelper bshelper = (AstarHelper)helper;  		// traverse the points of the pathfinder and create 90 degree ellipses  		List<Point> points = _pathFinder (bshelper.grid' bshelper.pathCost' bshelper.grain);  		int pcount = 0;  		Point lastpoint = points [0];  		while (pcount < points.Count - 2) {  			float yi = 0' xi = 0;  			float m1 = _slope (lastpoint' points [pcount + 1]' ref yi' ref xi);  			float m2 = _slope (points [pcount + 1]' points [pcount + 2]' ref yi' ref xi);  			if (m1 != m2) {  				// an angle  				// get the mid point of seg2 and create bezier curve  				Point mpoint = (m2 == 0) ? _hmidPoint (points [pcount + 1]' points [pcount + 2]) : _vmidPoint (points [pcount + 1]' points [pcount + 2]);  				path.AddBezier (lastpoint' points [pcount + 1]' points [pcount + 1]' mpoint);  				lastpoint = mpoint;  				pcount++;  			}  			else {  				// strait line  				pcount++;  			}  		}  		// add the last line  		path.AddLine (lastpoint' points [points.Count - 1]);  		path.Flatten ();  	}  	break;  default:  	break;  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodlePath,The following statement contains a magic number: switch (style) {  case NoodleStyle.Bezier:  	_bezierStyle ();  	break;  case NoodleStyle.Lines:  	_lineStyle ();  	break;  case NoodleStyle.CircuitBoardFine:  case NoodleStyle.CircuitBoardCoarse:  	{  		AstarHelper bshelper = (AstarHelper)helper;  		path.AddLines (_pathFinder (bshelper.grid' bshelper.pathCost' bshelper.grain).ToArray ());  	}  	break;  case NoodleStyle.Ramen:  	{  		AstarHelper bshelper = (AstarHelper)helper;  		path.AddCurve (_pathFinder (bshelper.grid' bshelper.pathCost' bshelper.grain).ToArray ()' 0.75f);  		path.Flatten ();  	}  	break;  case NoodleStyle.BendyStraws:  	{  		AstarHelper bshelper = (AstarHelper)helper;  		// traverse the points of the pathfinder and create 90 degree ellipses  		List<Point> points = _pathFinder (bshelper.grid' bshelper.pathCost' bshelper.grain);  		int pcount = 0;  		Point lastpoint = points [0];  		while (pcount < points.Count - 2) {  			float yi = 0' xi = 0;  			float m1 = _slope (lastpoint' points [pcount + 1]' ref yi' ref xi);  			float m2 = _slope (points [pcount + 1]' points [pcount + 2]' ref yi' ref xi);  			if (m1 != m2) {  				// an angle  				// get the mid point of seg2 and create bezier curve  				Point mpoint = (m2 == 0) ? _hmidPoint (points [pcount + 1]' points [pcount + 2]) : _vmidPoint (points [pcount + 1]' points [pcount + 2]);  				path.AddBezier (lastpoint' points [pcount + 1]' points [pcount + 1]' mpoint);  				lastpoint = mpoint;  				pcount++;  			}  			else {  				// strait line  				pcount++;  			}  		}  		// add the last line  		path.AddLine (lastpoint' points [points.Count - 1]);  		path.Flatten ();  	}  	break;  default:  	break;  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodlePath,The following statement contains a magic number: switch (style) {  case NoodleStyle.Bezier:  	_bezierStyle ();  	break;  case NoodleStyle.Lines:  	_lineStyle ();  	break;  case NoodleStyle.CircuitBoardFine:  case NoodleStyle.CircuitBoardCoarse:  	{  		AstarHelper bshelper = (AstarHelper)helper;  		path.AddLines (_pathFinder (bshelper.grid' bshelper.pathCost' bshelper.grain).ToArray ());  	}  	break;  case NoodleStyle.Ramen:  	{  		AstarHelper bshelper = (AstarHelper)helper;  		path.AddCurve (_pathFinder (bshelper.grid' bshelper.pathCost' bshelper.grain).ToArray ()' 0.75f);  		path.Flatten ();  	}  	break;  case NoodleStyle.BendyStraws:  	{  		AstarHelper bshelper = (AstarHelper)helper;  		// traverse the points of the pathfinder and create 90 degree ellipses  		List<Point> points = _pathFinder (bshelper.grid' bshelper.pathCost' bshelper.grain);  		int pcount = 0;  		Point lastpoint = points [0];  		while (pcount < points.Count - 2) {  			float yi = 0' xi = 0;  			float m1 = _slope (lastpoint' points [pcount + 1]' ref yi' ref xi);  			float m2 = _slope (points [pcount + 1]' points [pcount + 2]' ref yi' ref xi);  			if (m1 != m2) {  				// an angle  				// get the mid point of seg2 and create bezier curve  				Point mpoint = (m2 == 0) ? _hmidPoint (points [pcount + 1]' points [pcount + 2]) : _vmidPoint (points [pcount + 1]' points [pcount + 2]);  				path.AddBezier (lastpoint' points [pcount + 1]' points [pcount + 1]' mpoint);  				lastpoint = mpoint;  				pcount++;  			}  			else {  				// strait line  				pcount++;  			}  		}  		// add the last line  		path.AddLine (lastpoint' points [points.Count - 1]);  		path.Flatten ();  	}  	break;  default:  	break;  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodlePath,The following statement contains a magic number: while (pcount < points.Count - 2) {  	float yi = 0' xi = 0;  	float m1 = _slope (lastpoint' points [pcount + 1]' ref yi' ref xi);  	float m2 = _slope (points [pcount + 1]' points [pcount + 2]' ref yi' ref xi);  	if (m1 != m2) {  		// an angle  		// get the mid point of seg2 and create bezier curve  		Point mpoint = (m2 == 0) ? _hmidPoint (points [pcount + 1]' points [pcount + 2]) : _vmidPoint (points [pcount + 1]' points [pcount + 2]);  		path.AddBezier (lastpoint' points [pcount + 1]' points [pcount + 1]' mpoint);  		lastpoint = mpoint;  		pcount++;  	}  	else {  		// strait line  		pcount++;  	}  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodlePath,The following statement contains a magic number: while (pcount < points.Count - 2) {  	float yi = 0' xi = 0;  	float m1 = _slope (lastpoint' points [pcount + 1]' ref yi' ref xi);  	float m2 = _slope (points [pcount + 1]' points [pcount + 2]' ref yi' ref xi);  	if (m1 != m2) {  		// an angle  		// get the mid point of seg2 and create bezier curve  		Point mpoint = (m2 == 0) ? _hmidPoint (points [pcount + 1]' points [pcount + 2]) : _vmidPoint (points [pcount + 1]' points [pcount + 2]);  		path.AddBezier (lastpoint' points [pcount + 1]' points [pcount + 1]' mpoint);  		lastpoint = mpoint;  		pcount++;  	}  	else {  		// strait line  		pcount++;  	}  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodlePath,The following statement contains a magic number: while (pcount < points.Count - 2) {  	float yi = 0' xi = 0;  	float m1 = _slope (lastpoint' points [pcount + 1]' ref yi' ref xi);  	float m2 = _slope (points [pcount + 1]' points [pcount + 2]' ref yi' ref xi);  	if (m1 != m2) {  		// an angle  		// get the mid point of seg2 and create bezier curve  		Point mpoint = (m2 == 0) ? _hmidPoint (points [pcount + 1]' points [pcount + 2]) : _vmidPoint (points [pcount + 1]' points [pcount + 2]);  		path.AddBezier (lastpoint' points [pcount + 1]' points [pcount + 1]' mpoint);  		lastpoint = mpoint;  		pcount++;  	}  	else {  		// strait line  		pcount++;  	}  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodlePath,The following statement contains a magic number: while (pcount < points.Count - 2) {  	float yi = 0' xi = 0;  	float m1 = _slope (lastpoint' points [pcount + 1]' ref yi' ref xi);  	float m2 = _slope (points [pcount + 1]' points [pcount + 2]' ref yi' ref xi);  	if (m1 != m2) {  		// an angle  		// get the mid point of seg2 and create bezier curve  		Point mpoint = (m2 == 0) ? _hmidPoint (points [pcount + 1]' points [pcount + 2]) : _vmidPoint (points [pcount + 1]' points [pcount + 2]);  		path.AddBezier (lastpoint' points [pcount + 1]' points [pcount + 1]' mpoint);  		lastpoint = mpoint;  		pcount++;  	}  	else {  		// strait line  		pcount++;  	}  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodlePath,The following statement contains a magic number: if (m1 != m2) {  	// an angle  	// get the mid point of seg2 and create bezier curve  	Point mpoint = (m2 == 0) ? _hmidPoint (points [pcount + 1]' points [pcount + 2]) : _vmidPoint (points [pcount + 1]' points [pcount + 2]);  	path.AddBezier (lastpoint' points [pcount + 1]' points [pcount + 1]' mpoint);  	lastpoint = mpoint;  	pcount++;  }  else {  	// strait line  	pcount++;  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodlePath,The following statement contains a magic number: if (m1 != m2) {  	// an angle  	// get the mid point of seg2 and create bezier curve  	Point mpoint = (m2 == 0) ? _hmidPoint (points [pcount + 1]' points [pcount + 2]) : _vmidPoint (points [pcount + 1]' points [pcount + 2]);  	path.AddBezier (lastpoint' points [pcount + 1]' points [pcount + 1]' mpoint);  	lastpoint = mpoint;  	pcount++;  }  else {  	// strait line  	pcount++;  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_pathFinder,The following statement contains a magic number: while ((ox + off) < grid.Size.Width) {  	if (c.CellCost < 500)  		break;  	off++;  	c = grid [ox + off' oy];  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_pathFinder,The following statement contains a magic number: if (c.CellCost < 500)  	break;  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_pathFinder,The following statement contains a magic number: while ((ix + off) > -1) {  	if (c.CellCost < 500)  		break;  	off--;  	c = grid [ix + off' iy];  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_pathFinder,The following statement contains a magic number: if (c.CellCost < 500)  	break;  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_pathFinder,The following statement contains a magic number: if (p == null || p.Length < 3) {  	List<Point> points = new List<Point> ();  	points.Add (_outputPoint);  	points.Add (_inputPoint);  	//make sure ix stays within the confines of the grid  	ix = Math.Max (0' ix);  	// increment the cost of the path  	grid.IncLine (new Point (ox' oy)' new Point (ix' iy)' pathCost);  	return points;  }  else {  	List<Point> points = new List<Point> ();  	// get the grain offset to properly build the line segments connecting the pins  	//int grainXOffset = _outputPoint.X - ((int)((float)_outputPoint.X / (float)grain) * grain);  	//int grainYOffset = _outputPoint.Y - ((int)((float)_outputPoint.Y / (float)grain) * grain);  	// add output pin point  	points.Add (_outputPoint);  	// build the initial path  	for (int i = 0; i < p.Length; i++) {  		points.Add (new Point (p [i].X * grain' p [i].Y * grain));  	}  	// add input pin point  	points.Add (_inputPoint);  	// cull identical points  	for (int i = points.Count - 1; i > 0; i--) {  		if (points [i].X == points [i - 1].X && points [i].Y == points [i - 1].Y) {  			points.Remove (points [i]);  		}  	}  	// coerce the first and last points to be flush with the pins  	if (points [1].Y == points [2].Y) {  		// it "L"s in  		points [1] = new Point (points [1].X' points [0].Y);  		points [2] = new Point (points [2].X' points [0].Y);  	}  	else {  		points [1] = new Point (points [1].X' points [0].Y);  	}  	if (points [points.Count - 2].Y == points [points.Count - 3].Y) {  		// it "L"s in  		points [points.Count - 2] = new Point (points [points.Count - 2].X' points [points.Count - 1].Y);  		points [points.Count - 3] = new Point (points [points.Count - 3].X' points [points.Count - 1].Y);  	}  	else {  		points [points.Count - 2] = new Point (points [points.Count - 2].X' points [points.Count - 1].Y);  	}  	// increment the cost of this path in the grid  	for (int i = 0; i < points.Count - 1; i++) {  		grid.IncLine (new Point (points [i].X / grain' points [i].Y / grain)' new Point (points [i + 1].X / grain' points [i + 1].Y / grain)' pathCost);  	}  	grid.IncLine (new Point (points [points.Count - 2].X / grain' points [points.Count - 2].Y / grain)' new Point (points [points.Count - 1].X / grain' points [points.Count - 1].Y / grain)' pathCost);  	return points;  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_pathFinder,The following statement contains a magic number: if (p == null || p.Length < 3) {  	List<Point> points = new List<Point> ();  	points.Add (_outputPoint);  	points.Add (_inputPoint);  	//make sure ix stays within the confines of the grid  	ix = Math.Max (0' ix);  	// increment the cost of the path  	grid.IncLine (new Point (ox' oy)' new Point (ix' iy)' pathCost);  	return points;  }  else {  	List<Point> points = new List<Point> ();  	// get the grain offset to properly build the line segments connecting the pins  	//int grainXOffset = _outputPoint.X - ((int)((float)_outputPoint.X / (float)grain) * grain);  	//int grainYOffset = _outputPoint.Y - ((int)((float)_outputPoint.Y / (float)grain) * grain);  	// add output pin point  	points.Add (_outputPoint);  	// build the initial path  	for (int i = 0; i < p.Length; i++) {  		points.Add (new Point (p [i].X * grain' p [i].Y * grain));  	}  	// add input pin point  	points.Add (_inputPoint);  	// cull identical points  	for (int i = points.Count - 1; i > 0; i--) {  		if (points [i].X == points [i - 1].X && points [i].Y == points [i - 1].Y) {  			points.Remove (points [i]);  		}  	}  	// coerce the first and last points to be flush with the pins  	if (points [1].Y == points [2].Y) {  		// it "L"s in  		points [1] = new Point (points [1].X' points [0].Y);  		points [2] = new Point (points [2].X' points [0].Y);  	}  	else {  		points [1] = new Point (points [1].X' points [0].Y);  	}  	if (points [points.Count - 2].Y == points [points.Count - 3].Y) {  		// it "L"s in  		points [points.Count - 2] = new Point (points [points.Count - 2].X' points [points.Count - 1].Y);  		points [points.Count - 3] = new Point (points [points.Count - 3].X' points [points.Count - 1].Y);  	}  	else {  		points [points.Count - 2] = new Point (points [points.Count - 2].X' points [points.Count - 1].Y);  	}  	// increment the cost of this path in the grid  	for (int i = 0; i < points.Count - 1; i++) {  		grid.IncLine (new Point (points [i].X / grain' points [i].Y / grain)' new Point (points [i + 1].X / grain' points [i + 1].Y / grain)' pathCost);  	}  	grid.IncLine (new Point (points [points.Count - 2].X / grain' points [points.Count - 2].Y / grain)' new Point (points [points.Count - 1].X / grain' points [points.Count - 1].Y / grain)' pathCost);  	return points;  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_pathFinder,The following statement contains a magic number: if (p == null || p.Length < 3) {  	List<Point> points = new List<Point> ();  	points.Add (_outputPoint);  	points.Add (_inputPoint);  	//make sure ix stays within the confines of the grid  	ix = Math.Max (0' ix);  	// increment the cost of the path  	grid.IncLine (new Point (ox' oy)' new Point (ix' iy)' pathCost);  	return points;  }  else {  	List<Point> points = new List<Point> ();  	// get the grain offset to properly build the line segments connecting the pins  	//int grainXOffset = _outputPoint.X - ((int)((float)_outputPoint.X / (float)grain) * grain);  	//int grainYOffset = _outputPoint.Y - ((int)((float)_outputPoint.Y / (float)grain) * grain);  	// add output pin point  	points.Add (_outputPoint);  	// build the initial path  	for (int i = 0; i < p.Length; i++) {  		points.Add (new Point (p [i].X * grain' p [i].Y * grain));  	}  	// add input pin point  	points.Add (_inputPoint);  	// cull identical points  	for (int i = points.Count - 1; i > 0; i--) {  		if (points [i].X == points [i - 1].X && points [i].Y == points [i - 1].Y) {  			points.Remove (points [i]);  		}  	}  	// coerce the first and last points to be flush with the pins  	if (points [1].Y == points [2].Y) {  		// it "L"s in  		points [1] = new Point (points [1].X' points [0].Y);  		points [2] = new Point (points [2].X' points [0].Y);  	}  	else {  		points [1] = new Point (points [1].X' points [0].Y);  	}  	if (points [points.Count - 2].Y == points [points.Count - 3].Y) {  		// it "L"s in  		points [points.Count - 2] = new Point (points [points.Count - 2].X' points [points.Count - 1].Y);  		points [points.Count - 3] = new Point (points [points.Count - 3].X' points [points.Count - 1].Y);  	}  	else {  		points [points.Count - 2] = new Point (points [points.Count - 2].X' points [points.Count - 1].Y);  	}  	// increment the cost of this path in the grid  	for (int i = 0; i < points.Count - 1; i++) {  		grid.IncLine (new Point (points [i].X / grain' points [i].Y / grain)' new Point (points [i + 1].X / grain' points [i + 1].Y / grain)' pathCost);  	}  	grid.IncLine (new Point (points [points.Count - 2].X / grain' points [points.Count - 2].Y / grain)' new Point (points [points.Count - 1].X / grain' points [points.Count - 1].Y / grain)' pathCost);  	return points;  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_pathFinder,The following statement contains a magic number: if (p == null || p.Length < 3) {  	List<Point> points = new List<Point> ();  	points.Add (_outputPoint);  	points.Add (_inputPoint);  	//make sure ix stays within the confines of the grid  	ix = Math.Max (0' ix);  	// increment the cost of the path  	grid.IncLine (new Point (ox' oy)' new Point (ix' iy)' pathCost);  	return points;  }  else {  	List<Point> points = new List<Point> ();  	// get the grain offset to properly build the line segments connecting the pins  	//int grainXOffset = _outputPoint.X - ((int)((float)_outputPoint.X / (float)grain) * grain);  	//int grainYOffset = _outputPoint.Y - ((int)((float)_outputPoint.Y / (float)grain) * grain);  	// add output pin point  	points.Add (_outputPoint);  	// build the initial path  	for (int i = 0; i < p.Length; i++) {  		points.Add (new Point (p [i].X * grain' p [i].Y * grain));  	}  	// add input pin point  	points.Add (_inputPoint);  	// cull identical points  	for (int i = points.Count - 1; i > 0; i--) {  		if (points [i].X == points [i - 1].X && points [i].Y == points [i - 1].Y) {  			points.Remove (points [i]);  		}  	}  	// coerce the first and last points to be flush with the pins  	if (points [1].Y == points [2].Y) {  		// it "L"s in  		points [1] = new Point (points [1].X' points [0].Y);  		points [2] = new Point (points [2].X' points [0].Y);  	}  	else {  		points [1] = new Point (points [1].X' points [0].Y);  	}  	if (points [points.Count - 2].Y == points [points.Count - 3].Y) {  		// it "L"s in  		points [points.Count - 2] = new Point (points [points.Count - 2].X' points [points.Count - 1].Y);  		points [points.Count - 3] = new Point (points [points.Count - 3].X' points [points.Count - 1].Y);  	}  	else {  		points [points.Count - 2] = new Point (points [points.Count - 2].X' points [points.Count - 1].Y);  	}  	// increment the cost of this path in the grid  	for (int i = 0; i < points.Count - 1; i++) {  		grid.IncLine (new Point (points [i].X / grain' points [i].Y / grain)' new Point (points [i + 1].X / grain' points [i + 1].Y / grain)' pathCost);  	}  	grid.IncLine (new Point (points [points.Count - 2].X / grain' points [points.Count - 2].Y / grain)' new Point (points [points.Count - 1].X / grain' points [points.Count - 1].Y / grain)' pathCost);  	return points;  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_pathFinder,The following statement contains a magic number: if (p == null || p.Length < 3) {  	List<Point> points = new List<Point> ();  	points.Add (_outputPoint);  	points.Add (_inputPoint);  	//make sure ix stays within the confines of the grid  	ix = Math.Max (0' ix);  	// increment the cost of the path  	grid.IncLine (new Point (ox' oy)' new Point (ix' iy)' pathCost);  	return points;  }  else {  	List<Point> points = new List<Point> ();  	// get the grain offset to properly build the line segments connecting the pins  	//int grainXOffset = _outputPoint.X - ((int)((float)_outputPoint.X / (float)grain) * grain);  	//int grainYOffset = _outputPoint.Y - ((int)((float)_outputPoint.Y / (float)grain) * grain);  	// add output pin point  	points.Add (_outputPoint);  	// build the initial path  	for (int i = 0; i < p.Length; i++) {  		points.Add (new Point (p [i].X * grain' p [i].Y * grain));  	}  	// add input pin point  	points.Add (_inputPoint);  	// cull identical points  	for (int i = points.Count - 1; i > 0; i--) {  		if (points [i].X == points [i - 1].X && points [i].Y == points [i - 1].Y) {  			points.Remove (points [i]);  		}  	}  	// coerce the first and last points to be flush with the pins  	if (points [1].Y == points [2].Y) {  		// it "L"s in  		points [1] = new Point (points [1].X' points [0].Y);  		points [2] = new Point (points [2].X' points [0].Y);  	}  	else {  		points [1] = new Point (points [1].X' points [0].Y);  	}  	if (points [points.Count - 2].Y == points [points.Count - 3].Y) {  		// it "L"s in  		points [points.Count - 2] = new Point (points [points.Count - 2].X' points [points.Count - 1].Y);  		points [points.Count - 3] = new Point (points [points.Count - 3].X' points [points.Count - 1].Y);  	}  	else {  		points [points.Count - 2] = new Point (points [points.Count - 2].X' points [points.Count - 1].Y);  	}  	// increment the cost of this path in the grid  	for (int i = 0; i < points.Count - 1; i++) {  		grid.IncLine (new Point (points [i].X / grain' points [i].Y / grain)' new Point (points [i + 1].X / grain' points [i + 1].Y / grain)' pathCost);  	}  	grid.IncLine (new Point (points [points.Count - 2].X / grain' points [points.Count - 2].Y / grain)' new Point (points [points.Count - 1].X / grain' points [points.Count - 1].Y / grain)' pathCost);  	return points;  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_pathFinder,The following statement contains a magic number: if (p == null || p.Length < 3) {  	List<Point> points = new List<Point> ();  	points.Add (_outputPoint);  	points.Add (_inputPoint);  	//make sure ix stays within the confines of the grid  	ix = Math.Max (0' ix);  	// increment the cost of the path  	grid.IncLine (new Point (ox' oy)' new Point (ix' iy)' pathCost);  	return points;  }  else {  	List<Point> points = new List<Point> ();  	// get the grain offset to properly build the line segments connecting the pins  	//int grainXOffset = _outputPoint.X - ((int)((float)_outputPoint.X / (float)grain) * grain);  	//int grainYOffset = _outputPoint.Y - ((int)((float)_outputPoint.Y / (float)grain) * grain);  	// add output pin point  	points.Add (_outputPoint);  	// build the initial path  	for (int i = 0; i < p.Length; i++) {  		points.Add (new Point (p [i].X * grain' p [i].Y * grain));  	}  	// add input pin point  	points.Add (_inputPoint);  	// cull identical points  	for (int i = points.Count - 1; i > 0; i--) {  		if (points [i].X == points [i - 1].X && points [i].Y == points [i - 1].Y) {  			points.Remove (points [i]);  		}  	}  	// coerce the first and last points to be flush with the pins  	if (points [1].Y == points [2].Y) {  		// it "L"s in  		points [1] = new Point (points [1].X' points [0].Y);  		points [2] = new Point (points [2].X' points [0].Y);  	}  	else {  		points [1] = new Point (points [1].X' points [0].Y);  	}  	if (points [points.Count - 2].Y == points [points.Count - 3].Y) {  		// it "L"s in  		points [points.Count - 2] = new Point (points [points.Count - 2].X' points [points.Count - 1].Y);  		points [points.Count - 3] = new Point (points [points.Count - 3].X' points [points.Count - 1].Y);  	}  	else {  		points [points.Count - 2] = new Point (points [points.Count - 2].X' points [points.Count - 1].Y);  	}  	// increment the cost of this path in the grid  	for (int i = 0; i < points.Count - 1; i++) {  		grid.IncLine (new Point (points [i].X / grain' points [i].Y / grain)' new Point (points [i + 1].X / grain' points [i + 1].Y / grain)' pathCost);  	}  	grid.IncLine (new Point (points [points.Count - 2].X / grain' points [points.Count - 2].Y / grain)' new Point (points [points.Count - 1].X / grain' points [points.Count - 1].Y / grain)' pathCost);  	return points;  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_pathFinder,The following statement contains a magic number: if (p == null || p.Length < 3) {  	List<Point> points = new List<Point> ();  	points.Add (_outputPoint);  	points.Add (_inputPoint);  	//make sure ix stays within the confines of the grid  	ix = Math.Max (0' ix);  	// increment the cost of the path  	grid.IncLine (new Point (ox' oy)' new Point (ix' iy)' pathCost);  	return points;  }  else {  	List<Point> points = new List<Point> ();  	// get the grain offset to properly build the line segments connecting the pins  	//int grainXOffset = _outputPoint.X - ((int)((float)_outputPoint.X / (float)grain) * grain);  	//int grainYOffset = _outputPoint.Y - ((int)((float)_outputPoint.Y / (float)grain) * grain);  	// add output pin point  	points.Add (_outputPoint);  	// build the initial path  	for (int i = 0; i < p.Length; i++) {  		points.Add (new Point (p [i].X * grain' p [i].Y * grain));  	}  	// add input pin point  	points.Add (_inputPoint);  	// cull identical points  	for (int i = points.Count - 1; i > 0; i--) {  		if (points [i].X == points [i - 1].X && points [i].Y == points [i - 1].Y) {  			points.Remove (points [i]);  		}  	}  	// coerce the first and last points to be flush with the pins  	if (points [1].Y == points [2].Y) {  		// it "L"s in  		points [1] = new Point (points [1].X' points [0].Y);  		points [2] = new Point (points [2].X' points [0].Y);  	}  	else {  		points [1] = new Point (points [1].X' points [0].Y);  	}  	if (points [points.Count - 2].Y == points [points.Count - 3].Y) {  		// it "L"s in  		points [points.Count - 2] = new Point (points [points.Count - 2].X' points [points.Count - 1].Y);  		points [points.Count - 3] = new Point (points [points.Count - 3].X' points [points.Count - 1].Y);  	}  	else {  		points [points.Count - 2] = new Point (points [points.Count - 2].X' points [points.Count - 1].Y);  	}  	// increment the cost of this path in the grid  	for (int i = 0; i < points.Count - 1; i++) {  		grid.IncLine (new Point (points [i].X / grain' points [i].Y / grain)' new Point (points [i + 1].X / grain' points [i + 1].Y / grain)' pathCost);  	}  	grid.IncLine (new Point (points [points.Count - 2].X / grain' points [points.Count - 2].Y / grain)' new Point (points [points.Count - 1].X / grain' points [points.Count - 1].Y / grain)' pathCost);  	return points;  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_pathFinder,The following statement contains a magic number: if (p == null || p.Length < 3) {  	List<Point> points = new List<Point> ();  	points.Add (_outputPoint);  	points.Add (_inputPoint);  	//make sure ix stays within the confines of the grid  	ix = Math.Max (0' ix);  	// increment the cost of the path  	grid.IncLine (new Point (ox' oy)' new Point (ix' iy)' pathCost);  	return points;  }  else {  	List<Point> points = new List<Point> ();  	// get the grain offset to properly build the line segments connecting the pins  	//int grainXOffset = _outputPoint.X - ((int)((float)_outputPoint.X / (float)grain) * grain);  	//int grainYOffset = _outputPoint.Y - ((int)((float)_outputPoint.Y / (float)grain) * grain);  	// add output pin point  	points.Add (_outputPoint);  	// build the initial path  	for (int i = 0; i < p.Length; i++) {  		points.Add (new Point (p [i].X * grain' p [i].Y * grain));  	}  	// add input pin point  	points.Add (_inputPoint);  	// cull identical points  	for (int i = points.Count - 1; i > 0; i--) {  		if (points [i].X == points [i - 1].X && points [i].Y == points [i - 1].Y) {  			points.Remove (points [i]);  		}  	}  	// coerce the first and last points to be flush with the pins  	if (points [1].Y == points [2].Y) {  		// it "L"s in  		points [1] = new Point (points [1].X' points [0].Y);  		points [2] = new Point (points [2].X' points [0].Y);  	}  	else {  		points [1] = new Point (points [1].X' points [0].Y);  	}  	if (points [points.Count - 2].Y == points [points.Count - 3].Y) {  		// it "L"s in  		points [points.Count - 2] = new Point (points [points.Count - 2].X' points [points.Count - 1].Y);  		points [points.Count - 3] = new Point (points [points.Count - 3].X' points [points.Count - 1].Y);  	}  	else {  		points [points.Count - 2] = new Point (points [points.Count - 2].X' points [points.Count - 1].Y);  	}  	// increment the cost of this path in the grid  	for (int i = 0; i < points.Count - 1; i++) {  		grid.IncLine (new Point (points [i].X / grain' points [i].Y / grain)' new Point (points [i + 1].X / grain' points [i + 1].Y / grain)' pathCost);  	}  	grid.IncLine (new Point (points [points.Count - 2].X / grain' points [points.Count - 2].Y / grain)' new Point (points [points.Count - 1].X / grain' points [points.Count - 1].Y / grain)' pathCost);  	return points;  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_pathFinder,The following statement contains a magic number: if (p == null || p.Length < 3) {  	List<Point> points = new List<Point> ();  	points.Add (_outputPoint);  	points.Add (_inputPoint);  	//make sure ix stays within the confines of the grid  	ix = Math.Max (0' ix);  	// increment the cost of the path  	grid.IncLine (new Point (ox' oy)' new Point (ix' iy)' pathCost);  	return points;  }  else {  	List<Point> points = new List<Point> ();  	// get the grain offset to properly build the line segments connecting the pins  	//int grainXOffset = _outputPoint.X - ((int)((float)_outputPoint.X / (float)grain) * grain);  	//int grainYOffset = _outputPoint.Y - ((int)((float)_outputPoint.Y / (float)grain) * grain);  	// add output pin point  	points.Add (_outputPoint);  	// build the initial path  	for (int i = 0; i < p.Length; i++) {  		points.Add (new Point (p [i].X * grain' p [i].Y * grain));  	}  	// add input pin point  	points.Add (_inputPoint);  	// cull identical points  	for (int i = points.Count - 1; i > 0; i--) {  		if (points [i].X == points [i - 1].X && points [i].Y == points [i - 1].Y) {  			points.Remove (points [i]);  		}  	}  	// coerce the first and last points to be flush with the pins  	if (points [1].Y == points [2].Y) {  		// it "L"s in  		points [1] = new Point (points [1].X' points [0].Y);  		points [2] = new Point (points [2].X' points [0].Y);  	}  	else {  		points [1] = new Point (points [1].X' points [0].Y);  	}  	if (points [points.Count - 2].Y == points [points.Count - 3].Y) {  		// it "L"s in  		points [points.Count - 2] = new Point (points [points.Count - 2].X' points [points.Count - 1].Y);  		points [points.Count - 3] = new Point (points [points.Count - 3].X' points [points.Count - 1].Y);  	}  	else {  		points [points.Count - 2] = new Point (points [points.Count - 2].X' points [points.Count - 1].Y);  	}  	// increment the cost of this path in the grid  	for (int i = 0; i < points.Count - 1; i++) {  		grid.IncLine (new Point (points [i].X / grain' points [i].Y / grain)' new Point (points [i + 1].X / grain' points [i + 1].Y / grain)' pathCost);  	}  	grid.IncLine (new Point (points [points.Count - 2].X / grain' points [points.Count - 2].Y / grain)' new Point (points [points.Count - 1].X / grain' points [points.Count - 1].Y / grain)' pathCost);  	return points;  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_pathFinder,The following statement contains a magic number: if (p == null || p.Length < 3) {  	List<Point> points = new List<Point> ();  	points.Add (_outputPoint);  	points.Add (_inputPoint);  	//make sure ix stays within the confines of the grid  	ix = Math.Max (0' ix);  	// increment the cost of the path  	grid.IncLine (new Point (ox' oy)' new Point (ix' iy)' pathCost);  	return points;  }  else {  	List<Point> points = new List<Point> ();  	// get the grain offset to properly build the line segments connecting the pins  	//int grainXOffset = _outputPoint.X - ((int)((float)_outputPoint.X / (float)grain) * grain);  	//int grainYOffset = _outputPoint.Y - ((int)((float)_outputPoint.Y / (float)grain) * grain);  	// add output pin point  	points.Add (_outputPoint);  	// build the initial path  	for (int i = 0; i < p.Length; i++) {  		points.Add (new Point (p [i].X * grain' p [i].Y * grain));  	}  	// add input pin point  	points.Add (_inputPoint);  	// cull identical points  	for (int i = points.Count - 1; i > 0; i--) {  		if (points [i].X == points [i - 1].X && points [i].Y == points [i - 1].Y) {  			points.Remove (points [i]);  		}  	}  	// coerce the first and last points to be flush with the pins  	if (points [1].Y == points [2].Y) {  		// it "L"s in  		points [1] = new Point (points [1].X' points [0].Y);  		points [2] = new Point (points [2].X' points [0].Y);  	}  	else {  		points [1] = new Point (points [1].X' points [0].Y);  	}  	if (points [points.Count - 2].Y == points [points.Count - 3].Y) {  		// it "L"s in  		points [points.Count - 2] = new Point (points [points.Count - 2].X' points [points.Count - 1].Y);  		points [points.Count - 3] = new Point (points [points.Count - 3].X' points [points.Count - 1].Y);  	}  	else {  		points [points.Count - 2] = new Point (points [points.Count - 2].X' points [points.Count - 1].Y);  	}  	// increment the cost of this path in the grid  	for (int i = 0; i < points.Count - 1; i++) {  		grid.IncLine (new Point (points [i].X / grain' points [i].Y / grain)' new Point (points [i + 1].X / grain' points [i + 1].Y / grain)' pathCost);  	}  	grid.IncLine (new Point (points [points.Count - 2].X / grain' points [points.Count - 2].Y / grain)' new Point (points [points.Count - 1].X / grain' points [points.Count - 1].Y / grain)' pathCost);  	return points;  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_pathFinder,The following statement contains a magic number: if (p == null || p.Length < 3) {  	List<Point> points = new List<Point> ();  	points.Add (_outputPoint);  	points.Add (_inputPoint);  	//make sure ix stays within the confines of the grid  	ix = Math.Max (0' ix);  	// increment the cost of the path  	grid.IncLine (new Point (ox' oy)' new Point (ix' iy)' pathCost);  	return points;  }  else {  	List<Point> points = new List<Point> ();  	// get the grain offset to properly build the line segments connecting the pins  	//int grainXOffset = _outputPoint.X - ((int)((float)_outputPoint.X / (float)grain) * grain);  	//int grainYOffset = _outputPoint.Y - ((int)((float)_outputPoint.Y / (float)grain) * grain);  	// add output pin point  	points.Add (_outputPoint);  	// build the initial path  	for (int i = 0; i < p.Length; i++) {  		points.Add (new Point (p [i].X * grain' p [i].Y * grain));  	}  	// add input pin point  	points.Add (_inputPoint);  	// cull identical points  	for (int i = points.Count - 1; i > 0; i--) {  		if (points [i].X == points [i - 1].X && points [i].Y == points [i - 1].Y) {  			points.Remove (points [i]);  		}  	}  	// coerce the first and last points to be flush with the pins  	if (points [1].Y == points [2].Y) {  		// it "L"s in  		points [1] = new Point (points [1].X' points [0].Y);  		points [2] = new Point (points [2].X' points [0].Y);  	}  	else {  		points [1] = new Point (points [1].X' points [0].Y);  	}  	if (points [points.Count - 2].Y == points [points.Count - 3].Y) {  		// it "L"s in  		points [points.Count - 2] = new Point (points [points.Count - 2].X' points [points.Count - 1].Y);  		points [points.Count - 3] = new Point (points [points.Count - 3].X' points [points.Count - 1].Y);  	}  	else {  		points [points.Count - 2] = new Point (points [points.Count - 2].X' points [points.Count - 1].Y);  	}  	// increment the cost of this path in the grid  	for (int i = 0; i < points.Count - 1; i++) {  		grid.IncLine (new Point (points [i].X / grain' points [i].Y / grain)' new Point (points [i + 1].X / grain' points [i + 1].Y / grain)' pathCost);  	}  	grid.IncLine (new Point (points [points.Count - 2].X / grain' points [points.Count - 2].Y / grain)' new Point (points [points.Count - 1].X / grain' points [points.Count - 1].Y / grain)' pathCost);  	return points;  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_pathFinder,The following statement contains a magic number: if (p == null || p.Length < 3) {  	List<Point> points = new List<Point> ();  	points.Add (_outputPoint);  	points.Add (_inputPoint);  	//make sure ix stays within the confines of the grid  	ix = Math.Max (0' ix);  	// increment the cost of the path  	grid.IncLine (new Point (ox' oy)' new Point (ix' iy)' pathCost);  	return points;  }  else {  	List<Point> points = new List<Point> ();  	// get the grain offset to properly build the line segments connecting the pins  	//int grainXOffset = _outputPoint.X - ((int)((float)_outputPoint.X / (float)grain) * grain);  	//int grainYOffset = _outputPoint.Y - ((int)((float)_outputPoint.Y / (float)grain) * grain);  	// add output pin point  	points.Add (_outputPoint);  	// build the initial path  	for (int i = 0; i < p.Length; i++) {  		points.Add (new Point (p [i].X * grain' p [i].Y * grain));  	}  	// add input pin point  	points.Add (_inputPoint);  	// cull identical points  	for (int i = points.Count - 1; i > 0; i--) {  		if (points [i].X == points [i - 1].X && points [i].Y == points [i - 1].Y) {  			points.Remove (points [i]);  		}  	}  	// coerce the first and last points to be flush with the pins  	if (points [1].Y == points [2].Y) {  		// it "L"s in  		points [1] = new Point (points [1].X' points [0].Y);  		points [2] = new Point (points [2].X' points [0].Y);  	}  	else {  		points [1] = new Point (points [1].X' points [0].Y);  	}  	if (points [points.Count - 2].Y == points [points.Count - 3].Y) {  		// it "L"s in  		points [points.Count - 2] = new Point (points [points.Count - 2].X' points [points.Count - 1].Y);  		points [points.Count - 3] = new Point (points [points.Count - 3].X' points [points.Count - 1].Y);  	}  	else {  		points [points.Count - 2] = new Point (points [points.Count - 2].X' points [points.Count - 1].Y);  	}  	// increment the cost of this path in the grid  	for (int i = 0; i < points.Count - 1; i++) {  		grid.IncLine (new Point (points [i].X / grain' points [i].Y / grain)' new Point (points [i + 1].X / grain' points [i + 1].Y / grain)' pathCost);  	}  	grid.IncLine (new Point (points [points.Count - 2].X / grain' points [points.Count - 2].Y / grain)' new Point (points [points.Count - 1].X / grain' points [points.Count - 1].Y / grain)' pathCost);  	return points;  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_pathFinder,The following statement contains a magic number: if (p == null || p.Length < 3) {  	List<Point> points = new List<Point> ();  	points.Add (_outputPoint);  	points.Add (_inputPoint);  	//make sure ix stays within the confines of the grid  	ix = Math.Max (0' ix);  	// increment the cost of the path  	grid.IncLine (new Point (ox' oy)' new Point (ix' iy)' pathCost);  	return points;  }  else {  	List<Point> points = new List<Point> ();  	// get the grain offset to properly build the line segments connecting the pins  	//int grainXOffset = _outputPoint.X - ((int)((float)_outputPoint.X / (float)grain) * grain);  	//int grainYOffset = _outputPoint.Y - ((int)((float)_outputPoint.Y / (float)grain) * grain);  	// add output pin point  	points.Add (_outputPoint);  	// build the initial path  	for (int i = 0; i < p.Length; i++) {  		points.Add (new Point (p [i].X * grain' p [i].Y * grain));  	}  	// add input pin point  	points.Add (_inputPoint);  	// cull identical points  	for (int i = points.Count - 1; i > 0; i--) {  		if (points [i].X == points [i - 1].X && points [i].Y == points [i - 1].Y) {  			points.Remove (points [i]);  		}  	}  	// coerce the first and last points to be flush with the pins  	if (points [1].Y == points [2].Y) {  		// it "L"s in  		points [1] = new Point (points [1].X' points [0].Y);  		points [2] = new Point (points [2].X' points [0].Y);  	}  	else {  		points [1] = new Point (points [1].X' points [0].Y);  	}  	if (points [points.Count - 2].Y == points [points.Count - 3].Y) {  		// it "L"s in  		points [points.Count - 2] = new Point (points [points.Count - 2].X' points [points.Count - 1].Y);  		points [points.Count - 3] = new Point (points [points.Count - 3].X' points [points.Count - 1].Y);  	}  	else {  		points [points.Count - 2] = new Point (points [points.Count - 2].X' points [points.Count - 1].Y);  	}  	// increment the cost of this path in the grid  	for (int i = 0; i < points.Count - 1; i++) {  		grid.IncLine (new Point (points [i].X / grain' points [i].Y / grain)' new Point (points [i + 1].X / grain' points [i + 1].Y / grain)' pathCost);  	}  	grid.IncLine (new Point (points [points.Count - 2].X / grain' points [points.Count - 2].Y / grain)' new Point (points [points.Count - 1].X / grain' points [points.Count - 1].Y / grain)' pathCost);  	return points;  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_pathFinder,The following statement contains a magic number: if (p == null || p.Length < 3) {  	List<Point> points = new List<Point> ();  	points.Add (_outputPoint);  	points.Add (_inputPoint);  	//make sure ix stays within the confines of the grid  	ix = Math.Max (0' ix);  	// increment the cost of the path  	grid.IncLine (new Point (ox' oy)' new Point (ix' iy)' pathCost);  	return points;  }  else {  	List<Point> points = new List<Point> ();  	// get the grain offset to properly build the line segments connecting the pins  	//int grainXOffset = _outputPoint.X - ((int)((float)_outputPoint.X / (float)grain) * grain);  	//int grainYOffset = _outputPoint.Y - ((int)((float)_outputPoint.Y / (float)grain) * grain);  	// add output pin point  	points.Add (_outputPoint);  	// build the initial path  	for (int i = 0; i < p.Length; i++) {  		points.Add (new Point (p [i].X * grain' p [i].Y * grain));  	}  	// add input pin point  	points.Add (_inputPoint);  	// cull identical points  	for (int i = points.Count - 1; i > 0; i--) {  		if (points [i].X == points [i - 1].X && points [i].Y == points [i - 1].Y) {  			points.Remove (points [i]);  		}  	}  	// coerce the first and last points to be flush with the pins  	if (points [1].Y == points [2].Y) {  		// it "L"s in  		points [1] = new Point (points [1].X' points [0].Y);  		points [2] = new Point (points [2].X' points [0].Y);  	}  	else {  		points [1] = new Point (points [1].X' points [0].Y);  	}  	if (points [points.Count - 2].Y == points [points.Count - 3].Y) {  		// it "L"s in  		points [points.Count - 2] = new Point (points [points.Count - 2].X' points [points.Count - 1].Y);  		points [points.Count - 3] = new Point (points [points.Count - 3].X' points [points.Count - 1].Y);  	}  	else {  		points [points.Count - 2] = new Point (points [points.Count - 2].X' points [points.Count - 1].Y);  	}  	// increment the cost of this path in the grid  	for (int i = 0; i < points.Count - 1; i++) {  		grid.IncLine (new Point (points [i].X / grain' points [i].Y / grain)' new Point (points [i + 1].X / grain' points [i + 1].Y / grain)' pathCost);  	}  	grid.IncLine (new Point (points [points.Count - 2].X / grain' points [points.Count - 2].Y / grain)' new Point (points [points.Count - 1].X / grain' points [points.Count - 1].Y / grain)' pathCost);  	return points;  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_pathFinder,The following statement contains a magic number: if (points [1].Y == points [2].Y) {  	// it "L"s in  	points [1] = new Point (points [1].X' points [0].Y);  	points [2] = new Point (points [2].X' points [0].Y);  }  else {  	points [1] = new Point (points [1].X' points [0].Y);  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_pathFinder,The following statement contains a magic number: if (points [1].Y == points [2].Y) {  	// it "L"s in  	points [1] = new Point (points [1].X' points [0].Y);  	points [2] = new Point (points [2].X' points [0].Y);  }  else {  	points [1] = new Point (points [1].X' points [0].Y);  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_pathFinder,The following statement contains a magic number: if (points [1].Y == points [2].Y) {  	// it "L"s in  	points [1] = new Point (points [1].X' points [0].Y);  	points [2] = new Point (points [2].X' points [0].Y);  }  else {  	points [1] = new Point (points [1].X' points [0].Y);  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_pathFinder,The following statement contains a magic number: points [2] = new Point (points [2].X' points [0].Y);  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_pathFinder,The following statement contains a magic number: points [2] = new Point (points [2].X' points [0].Y);  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_pathFinder,The following statement contains a magic number: if (points [points.Count - 2].Y == points [points.Count - 3].Y) {  	// it "L"s in  	points [points.Count - 2] = new Point (points [points.Count - 2].X' points [points.Count - 1].Y);  	points [points.Count - 3] = new Point (points [points.Count - 3].X' points [points.Count - 1].Y);  }  else {  	points [points.Count - 2] = new Point (points [points.Count - 2].X' points [points.Count - 1].Y);  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_pathFinder,The following statement contains a magic number: if (points [points.Count - 2].Y == points [points.Count - 3].Y) {  	// it "L"s in  	points [points.Count - 2] = new Point (points [points.Count - 2].X' points [points.Count - 1].Y);  	points [points.Count - 3] = new Point (points [points.Count - 3].X' points [points.Count - 1].Y);  }  else {  	points [points.Count - 2] = new Point (points [points.Count - 2].X' points [points.Count - 1].Y);  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_pathFinder,The following statement contains a magic number: if (points [points.Count - 2].Y == points [points.Count - 3].Y) {  	// it "L"s in  	points [points.Count - 2] = new Point (points [points.Count - 2].X' points [points.Count - 1].Y);  	points [points.Count - 3] = new Point (points [points.Count - 3].X' points [points.Count - 1].Y);  }  else {  	points [points.Count - 2] = new Point (points [points.Count - 2].X' points [points.Count - 1].Y);  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_pathFinder,The following statement contains a magic number: if (points [points.Count - 2].Y == points [points.Count - 3].Y) {  	// it "L"s in  	points [points.Count - 2] = new Point (points [points.Count - 2].X' points [points.Count - 1].Y);  	points [points.Count - 3] = new Point (points [points.Count - 3].X' points [points.Count - 1].Y);  }  else {  	points [points.Count - 2] = new Point (points [points.Count - 2].X' points [points.Count - 1].Y);  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_pathFinder,The following statement contains a magic number: if (points [points.Count - 2].Y == points [points.Count - 3].Y) {  	// it "L"s in  	points [points.Count - 2] = new Point (points [points.Count - 2].X' points [points.Count - 1].Y);  	points [points.Count - 3] = new Point (points [points.Count - 3].X' points [points.Count - 1].Y);  }  else {  	points [points.Count - 2] = new Point (points [points.Count - 2].X' points [points.Count - 1].Y);  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_pathFinder,The following statement contains a magic number: if (points [points.Count - 2].Y == points [points.Count - 3].Y) {  	// it "L"s in  	points [points.Count - 2] = new Point (points [points.Count - 2].X' points [points.Count - 1].Y);  	points [points.Count - 3] = new Point (points [points.Count - 3].X' points [points.Count - 1].Y);  }  else {  	points [points.Count - 2] = new Point (points [points.Count - 2].X' points [points.Count - 1].Y);  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_pathFinder,The following statement contains a magic number: if (points [points.Count - 2].Y == points [points.Count - 3].Y) {  	// it "L"s in  	points [points.Count - 2] = new Point (points [points.Count - 2].X' points [points.Count - 1].Y);  	points [points.Count - 3] = new Point (points [points.Count - 3].X' points [points.Count - 1].Y);  }  else {  	points [points.Count - 2] = new Point (points [points.Count - 2].X' points [points.Count - 1].Y);  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_pathFinder,The following statement contains a magic number: if (points [points.Count - 2].Y == points [points.Count - 3].Y) {  	// it "L"s in  	points [points.Count - 2] = new Point (points [points.Count - 2].X' points [points.Count - 1].Y);  	points [points.Count - 3] = new Point (points [points.Count - 3].X' points [points.Count - 1].Y);  }  else {  	points [points.Count - 2] = new Point (points [points.Count - 2].X' points [points.Count - 1].Y);  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_pathFinder,The following statement contains a magic number: points [points.Count - 2] = new Point (points [points.Count - 2].X' points [points.Count - 1].Y);  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_pathFinder,The following statement contains a magic number: points [points.Count - 2] = new Point (points [points.Count - 2].X' points [points.Count - 1].Y);  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_pathFinder,The following statement contains a magic number: points [points.Count - 3] = new Point (points [points.Count - 3].X' points [points.Count - 1].Y);  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_pathFinder,The following statement contains a magic number: points [points.Count - 3] = new Point (points [points.Count - 3].X' points [points.Count - 1].Y);  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_pathFinder,The following statement contains a magic number: points [points.Count - 2] = new Point (points [points.Count - 2].X' points [points.Count - 1].Y);  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_pathFinder,The following statement contains a magic number: points [points.Count - 2] = new Point (points [points.Count - 2].X' points [points.Count - 1].Y);  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_pathFinder,The following statement contains a magic number: grid.IncLine (new Point (points [points.Count - 2].X / grain' points [points.Count - 2].Y / grain)' new Point (points [points.Count - 1].X / grain' points [points.Count - 1].Y / grain)' pathCost);  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_pathFinder,The following statement contains a magic number: grid.IncLine (new Point (points [points.Count - 2].X / grain' points [points.Count - 2].Y / grain)' new Point (points [points.Count - 1].X / grain' points [points.Count - 1].Y / grain)' pathCost);  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_lineStyle,The following statement contains a magic number: if (dist < 40) {  	path.AddLine (_outputPoint' _inputPoint);  	return;  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_lineStyle,The following statement contains a magic number: if (_outputPin.ParentNode != null) {  	outputPins = _outputPin.ParentNode.OutputPins.MutexAvailablePins;  	outputPoints.Add (new Point (outputThrowPoint.X + outputPins.IndexOf (_outputPin) * 10 + 10' outputThrowPoint.Y));  }  else {  	outputPins = _outputPin.ParentUIGraph.Graph.ImportedPins.List;  	outputPoints.Add (new Point (outputThrowPoint.X + outputPins.IndexOf (_outputPin) * 10 + 10' outputThrowPoint.Y));  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_lineStyle,The following statement contains a magic number: if (_outputPin.ParentNode != null) {  	outputPins = _outputPin.ParentNode.OutputPins.MutexAvailablePins;  	outputPoints.Add (new Point (outputThrowPoint.X + outputPins.IndexOf (_outputPin) * 10 + 10' outputThrowPoint.Y));  }  else {  	outputPins = _outputPin.ParentUIGraph.Graph.ImportedPins.List;  	outputPoints.Add (new Point (outputThrowPoint.X + outputPins.IndexOf (_outputPin) * 10 + 10' outputThrowPoint.Y));  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_lineStyle,The following statement contains a magic number: if (_outputPin.ParentNode != null) {  	outputPins = _outputPin.ParentNode.OutputPins.MutexAvailablePins;  	outputPoints.Add (new Point (outputThrowPoint.X + outputPins.IndexOf (_outputPin) * 10 + 10' outputThrowPoint.Y));  }  else {  	outputPins = _outputPin.ParentUIGraph.Graph.ImportedPins.List;  	outputPoints.Add (new Point (outputThrowPoint.X + outputPins.IndexOf (_outputPin) * 10 + 10' outputThrowPoint.Y));  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_lineStyle,The following statement contains a magic number: if (_outputPin.ParentNode != null) {  	outputPins = _outputPin.ParentNode.OutputPins.MutexAvailablePins;  	outputPoints.Add (new Point (outputThrowPoint.X + outputPins.IndexOf (_outputPin) * 10 + 10' outputThrowPoint.Y));  }  else {  	outputPins = _outputPin.ParentUIGraph.Graph.ImportedPins.List;  	outputPoints.Add (new Point (outputThrowPoint.X + outputPins.IndexOf (_outputPin) * 10 + 10' outputThrowPoint.Y));  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_lineStyle,The following statement contains a magic number: outputPoints.Add (new Point (outputThrowPoint.X + outputPins.IndexOf (_outputPin) * 10 + 10' outputThrowPoint.Y));  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_lineStyle,The following statement contains a magic number: outputPoints.Add (new Point (outputThrowPoint.X + outputPins.IndexOf (_outputPin) * 10 + 10' outputThrowPoint.Y));  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_lineStyle,The following statement contains a magic number: outputPoints.Add (new Point (outputThrowPoint.X + outputPins.IndexOf (_outputPin) * 10 + 10' outputThrowPoint.Y));  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_lineStyle,The following statement contains a magic number: outputPoints.Add (new Point (outputThrowPoint.X + outputPins.IndexOf (_outputPin) * 10 + 10' outputThrowPoint.Y));  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_lineStyle,The following statement contains a magic number: if (_inputPin.ParentNode != null) {  	inputPins = _inputPin.ParentNode.InputPins.MutexAvailablePins;  	inputPoints.Add (new Point (inputThrowPoint.X - (inputPins.Count - inputPins.IndexOf (_inputPin)) * 10 - 10' inputThrowPoint.Y));  }  else {  	inputPins = _inputPin.ParentUIGraph.Graph.ExportedPins.List;  	inputPoints.Add (new Point (inputThrowPoint.X + inputPins.IndexOf (_inputPin) * -10 - 10' inputThrowPoint.Y));  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_lineStyle,The following statement contains a magic number: if (_inputPin.ParentNode != null) {  	inputPins = _inputPin.ParentNode.InputPins.MutexAvailablePins;  	inputPoints.Add (new Point (inputThrowPoint.X - (inputPins.Count - inputPins.IndexOf (_inputPin)) * 10 - 10' inputThrowPoint.Y));  }  else {  	inputPins = _inputPin.ParentUIGraph.Graph.ExportedPins.List;  	inputPoints.Add (new Point (inputThrowPoint.X + inputPins.IndexOf (_inputPin) * -10 - 10' inputThrowPoint.Y));  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_lineStyle,The following statement contains a magic number: if (_inputPin.ParentNode != null) {  	inputPins = _inputPin.ParentNode.InputPins.MutexAvailablePins;  	inputPoints.Add (new Point (inputThrowPoint.X - (inputPins.Count - inputPins.IndexOf (_inputPin)) * 10 - 10' inputThrowPoint.Y));  }  else {  	inputPins = _inputPin.ParentUIGraph.Graph.ExportedPins.List;  	inputPoints.Add (new Point (inputThrowPoint.X + inputPins.IndexOf (_inputPin) * -10 - 10' inputThrowPoint.Y));  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_lineStyle,The following statement contains a magic number: if (_inputPin.ParentNode != null) {  	inputPins = _inputPin.ParentNode.InputPins.MutexAvailablePins;  	inputPoints.Add (new Point (inputThrowPoint.X - (inputPins.Count - inputPins.IndexOf (_inputPin)) * 10 - 10' inputThrowPoint.Y));  }  else {  	inputPins = _inputPin.ParentUIGraph.Graph.ExportedPins.List;  	inputPoints.Add (new Point (inputThrowPoint.X + inputPins.IndexOf (_inputPin) * -10 - 10' inputThrowPoint.Y));  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_lineStyle,The following statement contains a magic number: inputPoints.Add (new Point (inputThrowPoint.X - (inputPins.Count - inputPins.IndexOf (_inputPin)) * 10 - 10' inputThrowPoint.Y));  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_lineStyle,The following statement contains a magic number: inputPoints.Add (new Point (inputThrowPoint.X - (inputPins.Count - inputPins.IndexOf (_inputPin)) * 10 - 10' inputThrowPoint.Y));  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_lineStyle,The following statement contains a magic number: inputPoints.Add (new Point (inputThrowPoint.X + inputPins.IndexOf (_inputPin) * -10 - 10' inputThrowPoint.Y));  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_lineStyle,The following statement contains a magic number: inputPoints.Add (new Point (inputThrowPoint.X + inputPins.IndexOf (_inputPin) * -10 - 10' inputThrowPoint.Y));  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_bezierStyle,The following statement contains a magic number: if (m < 0.1 && _outputPin.ParentNode != null && (OutputPoint.X > InputPoint.X)) {  	slopeOffset = _outputPin.ParentNode.OutputPins.MutexAvailablePins.IndexOf (_outputPin) * 10 + 50;  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_bezierStyle,The following statement contains a magic number: if (m < 0.1 && _outputPin.ParentNode != null && (OutputPoint.X > InputPoint.X)) {  	slopeOffset = _outputPin.ParentNode.OutputPins.MutexAvailablePins.IndexOf (_outputPin) * 10 + 50;  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_bezierStyle,The following statement contains a magic number: if (m < 0.1 && _outputPin.ParentNode != null && (OutputPoint.X > InputPoint.X)) {  	slopeOffset = _outputPin.ParentNode.OutputPins.MutexAvailablePins.IndexOf (_outputPin) * 10 + 50;  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_bezierStyle,The following statement contains a magic number: slopeOffset = _outputPin.ParentNode.OutputPins.MutexAvailablePins.IndexOf (_outputPin) * 10 + 50;  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_bezierStyle,The following statement contains a magic number: slopeOffset = _outputPin.ParentNode.OutputPins.MutexAvailablePins.IndexOf (_outputPin) * 10 + 50;  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_bezierStyle,The following statement contains a magic number: if (m < 0.1 && slopeOffset == 0) {  	path.AddLine (_outputPoint' _inputPoint);  }  else {  	// create a bezier curve  	if (OutputPoint.X <= InputPoint.X) {  		if (_outputPin.ParentNode != null) {  			bezcontroloffset += _outputPin.ParentNode.OutputPins.MutexAvailablePins.IndexOf (_outputPin) * 20;  		}  		path.AddBezier (OutputPoint' new Point (OutputPoint.X + bezcontroloffset' OutputPoint.Y + slopeOffset)' new Point (InputPoint.X - bezcontroloffset' InputPoint.Y + slopeOffset)' InputPoint);  	}  	else {  		if (_outputPin.ParentNode != null) {  			bezcontroloffset += _outputPin.ParentNode.OutputPins.MutexAvailablePins.IndexOf (_outputPin) * -20;  		}  		path.AddBezier (OutputPoint' new Point (OutputPoint.X - bezcontroloffset' OutputPoint.Y + slopeOffset)' new Point (InputPoint.X + bezcontroloffset' InputPoint.Y + slopeOffset)' InputPoint);  	}  	path.Flatten ();  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_bezierStyle,The following statement contains a magic number: if (m < 0.1 && slopeOffset == 0) {  	path.AddLine (_outputPoint' _inputPoint);  }  else {  	// create a bezier curve  	if (OutputPoint.X <= InputPoint.X) {  		if (_outputPin.ParentNode != null) {  			bezcontroloffset += _outputPin.ParentNode.OutputPins.MutexAvailablePins.IndexOf (_outputPin) * 20;  		}  		path.AddBezier (OutputPoint' new Point (OutputPoint.X + bezcontroloffset' OutputPoint.Y + slopeOffset)' new Point (InputPoint.X - bezcontroloffset' InputPoint.Y + slopeOffset)' InputPoint);  	}  	else {  		if (_outputPin.ParentNode != null) {  			bezcontroloffset += _outputPin.ParentNode.OutputPins.MutexAvailablePins.IndexOf (_outputPin) * -20;  		}  		path.AddBezier (OutputPoint' new Point (OutputPoint.X - bezcontroloffset' OutputPoint.Y + slopeOffset)' new Point (InputPoint.X + bezcontroloffset' InputPoint.Y + slopeOffset)' InputPoint);  	}  	path.Flatten ();  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_bezierStyle,The following statement contains a magic number: if (m < 0.1 && slopeOffset == 0) {  	path.AddLine (_outputPoint' _inputPoint);  }  else {  	// create a bezier curve  	if (OutputPoint.X <= InputPoint.X) {  		if (_outputPin.ParentNode != null) {  			bezcontroloffset += _outputPin.ParentNode.OutputPins.MutexAvailablePins.IndexOf (_outputPin) * 20;  		}  		path.AddBezier (OutputPoint' new Point (OutputPoint.X + bezcontroloffset' OutputPoint.Y + slopeOffset)' new Point (InputPoint.X - bezcontroloffset' InputPoint.Y + slopeOffset)' InputPoint);  	}  	else {  		if (_outputPin.ParentNode != null) {  			bezcontroloffset += _outputPin.ParentNode.OutputPins.MutexAvailablePins.IndexOf (_outputPin) * -20;  		}  		path.AddBezier (OutputPoint' new Point (OutputPoint.X - bezcontroloffset' OutputPoint.Y + slopeOffset)' new Point (InputPoint.X + bezcontroloffset' InputPoint.Y + slopeOffset)' InputPoint);  	}  	path.Flatten ();  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_bezierStyle,The following statement contains a magic number: if (OutputPoint.X <= InputPoint.X) {  	if (_outputPin.ParentNode != null) {  		bezcontroloffset += _outputPin.ParentNode.OutputPins.MutexAvailablePins.IndexOf (_outputPin) * 20;  	}  	path.AddBezier (OutputPoint' new Point (OutputPoint.X + bezcontroloffset' OutputPoint.Y + slopeOffset)' new Point (InputPoint.X - bezcontroloffset' InputPoint.Y + slopeOffset)' InputPoint);  }  else {  	if (_outputPin.ParentNode != null) {  		bezcontroloffset += _outputPin.ParentNode.OutputPins.MutexAvailablePins.IndexOf (_outputPin) * -20;  	}  	path.AddBezier (OutputPoint' new Point (OutputPoint.X - bezcontroloffset' OutputPoint.Y + slopeOffset)' new Point (InputPoint.X + bezcontroloffset' InputPoint.Y + slopeOffset)' InputPoint);  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_bezierStyle,The following statement contains a magic number: if (OutputPoint.X <= InputPoint.X) {  	if (_outputPin.ParentNode != null) {  		bezcontroloffset += _outputPin.ParentNode.OutputPins.MutexAvailablePins.IndexOf (_outputPin) * 20;  	}  	path.AddBezier (OutputPoint' new Point (OutputPoint.X + bezcontroloffset' OutputPoint.Y + slopeOffset)' new Point (InputPoint.X - bezcontroloffset' InputPoint.Y + slopeOffset)' InputPoint);  }  else {  	if (_outputPin.ParentNode != null) {  		bezcontroloffset += _outputPin.ParentNode.OutputPins.MutexAvailablePins.IndexOf (_outputPin) * -20;  	}  	path.AddBezier (OutputPoint' new Point (OutputPoint.X - bezcontroloffset' OutputPoint.Y + slopeOffset)' new Point (InputPoint.X + bezcontroloffset' InputPoint.Y + slopeOffset)' InputPoint);  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_bezierStyle,The following statement contains a magic number: if (_outputPin.ParentNode != null) {  	bezcontroloffset += _outputPin.ParentNode.OutputPins.MutexAvailablePins.IndexOf (_outputPin) * 20;  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_bezierStyle,The following statement contains a magic number: bezcontroloffset += _outputPin.ParentNode.OutputPins.MutexAvailablePins.IndexOf (_outputPin) * 20;  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_bezierStyle,The following statement contains a magic number: if (_outputPin.ParentNode != null) {  	bezcontroloffset += _outputPin.ParentNode.OutputPins.MutexAvailablePins.IndexOf (_outputPin) * -20;  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,_bezierStyle,The following statement contains a magic number: bezcontroloffset += _outputPin.ParentNode.OutputPins.MutexAvailablePins.IndexOf (_outputPin) * -20;  
Magic Number,DaggerLib.UI.Windows,DaggerNoodleContainer,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodles,The following statement contains a magic number: if (_updateRef == 0) {  	switch (_style) {  	case NoodleStyle.Default:  	case NoodleStyle.Bezier:  		{  			foreach (DaggerNoodle noodle in _noodles) {  				noodle.UpdateNoodlePath (NoodleStyle.Bezier' null);  			}  		}  		break;  	case NoodleStyle.Lines:  		{  			foreach (DaggerNoodle noodle in _noodles) {  				noodle.UpdateNoodlePath (NoodleStyle.Lines' null);  			}  		}  		break;  	case NoodleStyle.CircuitBoardCoarse:  		{  			// create the helper  			AstarHelper helper = new AstarHelper ();  			helper.grain = 24;  			helper.pathCost = 100;  			helper.diagonalCost = 50;  			// create the AStar path finder  			helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  			if (helper.grid == null)  				return;  			foreach (DaggerNoodle noodle in _noodles) {  				noodle.UpdateNoodlePath (NoodleStyle.CircuitBoardCoarse' helper);  				helper.grid.Reset ();  			}  		}  		break;  	case NoodleStyle.CircuitBoardFine:  		{  			// create the helper  			AstarHelper helper = new AstarHelper ();  			helper.grain = 16;  			helper.pathCost = 100;  			helper.diagonalCost = 20;  			// create the AStar path finder  			helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  			if (helper.grid == null)  				return;  			foreach (DaggerNoodle noodle in _noodles) {  				noodle.UpdateNoodlePath (NoodleStyle.CircuitBoardFine' helper);  				helper.grid.Reset ();  			}  		}  		break;  	case NoodleStyle.Ramen:  		{  			// create the helper  			AstarHelper helper = new AstarHelper ();  			helper.grain = 16;  			helper.pathCost = 100;  			helper.diagonalCost = 20;  			// create the AStar path finder  			helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  			if (helper.grid == null)  				return;  			foreach (DaggerNoodle noodle in _noodles) {  				noodle.UpdateNoodlePath (NoodleStyle.Ramen' helper);  				helper.grid.Reset ();  			}  		}  		break;  	case NoodleStyle.BendyStraws:  		{  			// create the helper  			AstarHelper helper = new AstarHelper ();  			helper.grain = 16;  			helper.pathCost = 200;  			helper.diagonalCost = 100;  			// create the AStar path finder  			helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  			if (helper.grid == null)  				return;  			foreach (DaggerNoodle noodle in _noodles) {  				noodle.UpdateNoodlePath (NoodleStyle.BendyStraws' helper);  				helper.grid.Reset ();  			}  		}  		break;  	default:  		break;  	}  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodleContainer,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodles,The following statement contains a magic number: if (_updateRef == 0) {  	switch (_style) {  	case NoodleStyle.Default:  	case NoodleStyle.Bezier:  		{  			foreach (DaggerNoodle noodle in _noodles) {  				noodle.UpdateNoodlePath (NoodleStyle.Bezier' null);  			}  		}  		break;  	case NoodleStyle.Lines:  		{  			foreach (DaggerNoodle noodle in _noodles) {  				noodle.UpdateNoodlePath (NoodleStyle.Lines' null);  			}  		}  		break;  	case NoodleStyle.CircuitBoardCoarse:  		{  			// create the helper  			AstarHelper helper = new AstarHelper ();  			helper.grain = 24;  			helper.pathCost = 100;  			helper.diagonalCost = 50;  			// create the AStar path finder  			helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  			if (helper.grid == null)  				return;  			foreach (DaggerNoodle noodle in _noodles) {  				noodle.UpdateNoodlePath (NoodleStyle.CircuitBoardCoarse' helper);  				helper.grid.Reset ();  			}  		}  		break;  	case NoodleStyle.CircuitBoardFine:  		{  			// create the helper  			AstarHelper helper = new AstarHelper ();  			helper.grain = 16;  			helper.pathCost = 100;  			helper.diagonalCost = 20;  			// create the AStar path finder  			helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  			if (helper.grid == null)  				return;  			foreach (DaggerNoodle noodle in _noodles) {  				noodle.UpdateNoodlePath (NoodleStyle.CircuitBoardFine' helper);  				helper.grid.Reset ();  			}  		}  		break;  	case NoodleStyle.Ramen:  		{  			// create the helper  			AstarHelper helper = new AstarHelper ();  			helper.grain = 16;  			helper.pathCost = 100;  			helper.diagonalCost = 20;  			// create the AStar path finder  			helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  			if (helper.grid == null)  				return;  			foreach (DaggerNoodle noodle in _noodles) {  				noodle.UpdateNoodlePath (NoodleStyle.Ramen' helper);  				helper.grid.Reset ();  			}  		}  		break;  	case NoodleStyle.BendyStraws:  		{  			// create the helper  			AstarHelper helper = new AstarHelper ();  			helper.grain = 16;  			helper.pathCost = 200;  			helper.diagonalCost = 100;  			// create the AStar path finder  			helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  			if (helper.grid == null)  				return;  			foreach (DaggerNoodle noodle in _noodles) {  				noodle.UpdateNoodlePath (NoodleStyle.BendyStraws' helper);  				helper.grid.Reset ();  			}  		}  		break;  	default:  		break;  	}  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodleContainer,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodles,The following statement contains a magic number: if (_updateRef == 0) {  	switch (_style) {  	case NoodleStyle.Default:  	case NoodleStyle.Bezier:  		{  			foreach (DaggerNoodle noodle in _noodles) {  				noodle.UpdateNoodlePath (NoodleStyle.Bezier' null);  			}  		}  		break;  	case NoodleStyle.Lines:  		{  			foreach (DaggerNoodle noodle in _noodles) {  				noodle.UpdateNoodlePath (NoodleStyle.Lines' null);  			}  		}  		break;  	case NoodleStyle.CircuitBoardCoarse:  		{  			// create the helper  			AstarHelper helper = new AstarHelper ();  			helper.grain = 24;  			helper.pathCost = 100;  			helper.diagonalCost = 50;  			// create the AStar path finder  			helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  			if (helper.grid == null)  				return;  			foreach (DaggerNoodle noodle in _noodles) {  				noodle.UpdateNoodlePath (NoodleStyle.CircuitBoardCoarse' helper);  				helper.grid.Reset ();  			}  		}  		break;  	case NoodleStyle.CircuitBoardFine:  		{  			// create the helper  			AstarHelper helper = new AstarHelper ();  			helper.grain = 16;  			helper.pathCost = 100;  			helper.diagonalCost = 20;  			// create the AStar path finder  			helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  			if (helper.grid == null)  				return;  			foreach (DaggerNoodle noodle in _noodles) {  				noodle.UpdateNoodlePath (NoodleStyle.CircuitBoardFine' helper);  				helper.grid.Reset ();  			}  		}  		break;  	case NoodleStyle.Ramen:  		{  			// create the helper  			AstarHelper helper = new AstarHelper ();  			helper.grain = 16;  			helper.pathCost = 100;  			helper.diagonalCost = 20;  			// create the AStar path finder  			helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  			if (helper.grid == null)  				return;  			foreach (DaggerNoodle noodle in _noodles) {  				noodle.UpdateNoodlePath (NoodleStyle.Ramen' helper);  				helper.grid.Reset ();  			}  		}  		break;  	case NoodleStyle.BendyStraws:  		{  			// create the helper  			AstarHelper helper = new AstarHelper ();  			helper.grain = 16;  			helper.pathCost = 200;  			helper.diagonalCost = 100;  			// create the AStar path finder  			helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  			if (helper.grid == null)  				return;  			foreach (DaggerNoodle noodle in _noodles) {  				noodle.UpdateNoodlePath (NoodleStyle.BendyStraws' helper);  				helper.grid.Reset ();  			}  		}  		break;  	default:  		break;  	}  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodleContainer,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodles,The following statement contains a magic number: if (_updateRef == 0) {  	switch (_style) {  	case NoodleStyle.Default:  	case NoodleStyle.Bezier:  		{  			foreach (DaggerNoodle noodle in _noodles) {  				noodle.UpdateNoodlePath (NoodleStyle.Bezier' null);  			}  		}  		break;  	case NoodleStyle.Lines:  		{  			foreach (DaggerNoodle noodle in _noodles) {  				noodle.UpdateNoodlePath (NoodleStyle.Lines' null);  			}  		}  		break;  	case NoodleStyle.CircuitBoardCoarse:  		{  			// create the helper  			AstarHelper helper = new AstarHelper ();  			helper.grain = 24;  			helper.pathCost = 100;  			helper.diagonalCost = 50;  			// create the AStar path finder  			helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  			if (helper.grid == null)  				return;  			foreach (DaggerNoodle noodle in _noodles) {  				noodle.UpdateNoodlePath (NoodleStyle.CircuitBoardCoarse' helper);  				helper.grid.Reset ();  			}  		}  		break;  	case NoodleStyle.CircuitBoardFine:  		{  			// create the helper  			AstarHelper helper = new AstarHelper ();  			helper.grain = 16;  			helper.pathCost = 100;  			helper.diagonalCost = 20;  			// create the AStar path finder  			helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  			if (helper.grid == null)  				return;  			foreach (DaggerNoodle noodle in _noodles) {  				noodle.UpdateNoodlePath (NoodleStyle.CircuitBoardFine' helper);  				helper.grid.Reset ();  			}  		}  		break;  	case NoodleStyle.Ramen:  		{  			// create the helper  			AstarHelper helper = new AstarHelper ();  			helper.grain = 16;  			helper.pathCost = 100;  			helper.diagonalCost = 20;  			// create the AStar path finder  			helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  			if (helper.grid == null)  				return;  			foreach (DaggerNoodle noodle in _noodles) {  				noodle.UpdateNoodlePath (NoodleStyle.Ramen' helper);  				helper.grid.Reset ();  			}  		}  		break;  	case NoodleStyle.BendyStraws:  		{  			// create the helper  			AstarHelper helper = new AstarHelper ();  			helper.grain = 16;  			helper.pathCost = 200;  			helper.diagonalCost = 100;  			// create the AStar path finder  			helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  			if (helper.grid == null)  				return;  			foreach (DaggerNoodle noodle in _noodles) {  				noodle.UpdateNoodlePath (NoodleStyle.BendyStraws' helper);  				helper.grid.Reset ();  			}  		}  		break;  	default:  		break;  	}  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodleContainer,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodles,The following statement contains a magic number: if (_updateRef == 0) {  	switch (_style) {  	case NoodleStyle.Default:  	case NoodleStyle.Bezier:  		{  			foreach (DaggerNoodle noodle in _noodles) {  				noodle.UpdateNoodlePath (NoodleStyle.Bezier' null);  			}  		}  		break;  	case NoodleStyle.Lines:  		{  			foreach (DaggerNoodle noodle in _noodles) {  				noodle.UpdateNoodlePath (NoodleStyle.Lines' null);  			}  		}  		break;  	case NoodleStyle.CircuitBoardCoarse:  		{  			// create the helper  			AstarHelper helper = new AstarHelper ();  			helper.grain = 24;  			helper.pathCost = 100;  			helper.diagonalCost = 50;  			// create the AStar path finder  			helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  			if (helper.grid == null)  				return;  			foreach (DaggerNoodle noodle in _noodles) {  				noodle.UpdateNoodlePath (NoodleStyle.CircuitBoardCoarse' helper);  				helper.grid.Reset ();  			}  		}  		break;  	case NoodleStyle.CircuitBoardFine:  		{  			// create the helper  			AstarHelper helper = new AstarHelper ();  			helper.grain = 16;  			helper.pathCost = 100;  			helper.diagonalCost = 20;  			// create the AStar path finder  			helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  			if (helper.grid == null)  				return;  			foreach (DaggerNoodle noodle in _noodles) {  				noodle.UpdateNoodlePath (NoodleStyle.CircuitBoardFine' helper);  				helper.grid.Reset ();  			}  		}  		break;  	case NoodleStyle.Ramen:  		{  			// create the helper  			AstarHelper helper = new AstarHelper ();  			helper.grain = 16;  			helper.pathCost = 100;  			helper.diagonalCost = 20;  			// create the AStar path finder  			helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  			if (helper.grid == null)  				return;  			foreach (DaggerNoodle noodle in _noodles) {  				noodle.UpdateNoodlePath (NoodleStyle.Ramen' helper);  				helper.grid.Reset ();  			}  		}  		break;  	case NoodleStyle.BendyStraws:  		{  			// create the helper  			AstarHelper helper = new AstarHelper ();  			helper.grain = 16;  			helper.pathCost = 200;  			helper.diagonalCost = 100;  			// create the AStar path finder  			helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  			if (helper.grid == null)  				return;  			foreach (DaggerNoodle noodle in _noodles) {  				noodle.UpdateNoodlePath (NoodleStyle.BendyStraws' helper);  				helper.grid.Reset ();  			}  		}  		break;  	default:  		break;  	}  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodleContainer,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodles,The following statement contains a magic number: if (_updateRef == 0) {  	switch (_style) {  	case NoodleStyle.Default:  	case NoodleStyle.Bezier:  		{  			foreach (DaggerNoodle noodle in _noodles) {  				noodle.UpdateNoodlePath (NoodleStyle.Bezier' null);  			}  		}  		break;  	case NoodleStyle.Lines:  		{  			foreach (DaggerNoodle noodle in _noodles) {  				noodle.UpdateNoodlePath (NoodleStyle.Lines' null);  			}  		}  		break;  	case NoodleStyle.CircuitBoardCoarse:  		{  			// create the helper  			AstarHelper helper = new AstarHelper ();  			helper.grain = 24;  			helper.pathCost = 100;  			helper.diagonalCost = 50;  			// create the AStar path finder  			helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  			if (helper.grid == null)  				return;  			foreach (DaggerNoodle noodle in _noodles) {  				noodle.UpdateNoodlePath (NoodleStyle.CircuitBoardCoarse' helper);  				helper.grid.Reset ();  			}  		}  		break;  	case NoodleStyle.CircuitBoardFine:  		{  			// create the helper  			AstarHelper helper = new AstarHelper ();  			helper.grain = 16;  			helper.pathCost = 100;  			helper.diagonalCost = 20;  			// create the AStar path finder  			helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  			if (helper.grid == null)  				return;  			foreach (DaggerNoodle noodle in _noodles) {  				noodle.UpdateNoodlePath (NoodleStyle.CircuitBoardFine' helper);  				helper.grid.Reset ();  			}  		}  		break;  	case NoodleStyle.Ramen:  		{  			// create the helper  			AstarHelper helper = new AstarHelper ();  			helper.grain = 16;  			helper.pathCost = 100;  			helper.diagonalCost = 20;  			// create the AStar path finder  			helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  			if (helper.grid == null)  				return;  			foreach (DaggerNoodle noodle in _noodles) {  				noodle.UpdateNoodlePath (NoodleStyle.Ramen' helper);  				helper.grid.Reset ();  			}  		}  		break;  	case NoodleStyle.BendyStraws:  		{  			// create the helper  			AstarHelper helper = new AstarHelper ();  			helper.grain = 16;  			helper.pathCost = 200;  			helper.diagonalCost = 100;  			// create the AStar path finder  			helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  			if (helper.grid == null)  				return;  			foreach (DaggerNoodle noodle in _noodles) {  				noodle.UpdateNoodlePath (NoodleStyle.BendyStraws' helper);  				helper.grid.Reset ();  			}  		}  		break;  	default:  		break;  	}  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodleContainer,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodles,The following statement contains a magic number: if (_updateRef == 0) {  	switch (_style) {  	case NoodleStyle.Default:  	case NoodleStyle.Bezier:  		{  			foreach (DaggerNoodle noodle in _noodles) {  				noodle.UpdateNoodlePath (NoodleStyle.Bezier' null);  			}  		}  		break;  	case NoodleStyle.Lines:  		{  			foreach (DaggerNoodle noodle in _noodles) {  				noodle.UpdateNoodlePath (NoodleStyle.Lines' null);  			}  		}  		break;  	case NoodleStyle.CircuitBoardCoarse:  		{  			// create the helper  			AstarHelper helper = new AstarHelper ();  			helper.grain = 24;  			helper.pathCost = 100;  			helper.diagonalCost = 50;  			// create the AStar path finder  			helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  			if (helper.grid == null)  				return;  			foreach (DaggerNoodle noodle in _noodles) {  				noodle.UpdateNoodlePath (NoodleStyle.CircuitBoardCoarse' helper);  				helper.grid.Reset ();  			}  		}  		break;  	case NoodleStyle.CircuitBoardFine:  		{  			// create the helper  			AstarHelper helper = new AstarHelper ();  			helper.grain = 16;  			helper.pathCost = 100;  			helper.diagonalCost = 20;  			// create the AStar path finder  			helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  			if (helper.grid == null)  				return;  			foreach (DaggerNoodle noodle in _noodles) {  				noodle.UpdateNoodlePath (NoodleStyle.CircuitBoardFine' helper);  				helper.grid.Reset ();  			}  		}  		break;  	case NoodleStyle.Ramen:  		{  			// create the helper  			AstarHelper helper = new AstarHelper ();  			helper.grain = 16;  			helper.pathCost = 100;  			helper.diagonalCost = 20;  			// create the AStar path finder  			helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  			if (helper.grid == null)  				return;  			foreach (DaggerNoodle noodle in _noodles) {  				noodle.UpdateNoodlePath (NoodleStyle.Ramen' helper);  				helper.grid.Reset ();  			}  		}  		break;  	case NoodleStyle.BendyStraws:  		{  			// create the helper  			AstarHelper helper = new AstarHelper ();  			helper.grain = 16;  			helper.pathCost = 200;  			helper.diagonalCost = 100;  			// create the AStar path finder  			helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  			if (helper.grid == null)  				return;  			foreach (DaggerNoodle noodle in _noodles) {  				noodle.UpdateNoodlePath (NoodleStyle.BendyStraws' helper);  				helper.grid.Reset ();  			}  		}  		break;  	default:  		break;  	}  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodleContainer,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodles,The following statement contains a magic number: if (_updateRef == 0) {  	switch (_style) {  	case NoodleStyle.Default:  	case NoodleStyle.Bezier:  		{  			foreach (DaggerNoodle noodle in _noodles) {  				noodle.UpdateNoodlePath (NoodleStyle.Bezier' null);  			}  		}  		break;  	case NoodleStyle.Lines:  		{  			foreach (DaggerNoodle noodle in _noodles) {  				noodle.UpdateNoodlePath (NoodleStyle.Lines' null);  			}  		}  		break;  	case NoodleStyle.CircuitBoardCoarse:  		{  			// create the helper  			AstarHelper helper = new AstarHelper ();  			helper.grain = 24;  			helper.pathCost = 100;  			helper.diagonalCost = 50;  			// create the AStar path finder  			helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  			if (helper.grid == null)  				return;  			foreach (DaggerNoodle noodle in _noodles) {  				noodle.UpdateNoodlePath (NoodleStyle.CircuitBoardCoarse' helper);  				helper.grid.Reset ();  			}  		}  		break;  	case NoodleStyle.CircuitBoardFine:  		{  			// create the helper  			AstarHelper helper = new AstarHelper ();  			helper.grain = 16;  			helper.pathCost = 100;  			helper.diagonalCost = 20;  			// create the AStar path finder  			helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  			if (helper.grid == null)  				return;  			foreach (DaggerNoodle noodle in _noodles) {  				noodle.UpdateNoodlePath (NoodleStyle.CircuitBoardFine' helper);  				helper.grid.Reset ();  			}  		}  		break;  	case NoodleStyle.Ramen:  		{  			// create the helper  			AstarHelper helper = new AstarHelper ();  			helper.grain = 16;  			helper.pathCost = 100;  			helper.diagonalCost = 20;  			// create the AStar path finder  			helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  			if (helper.grid == null)  				return;  			foreach (DaggerNoodle noodle in _noodles) {  				noodle.UpdateNoodlePath (NoodleStyle.Ramen' helper);  				helper.grid.Reset ();  			}  		}  		break;  	case NoodleStyle.BendyStraws:  		{  			// create the helper  			AstarHelper helper = new AstarHelper ();  			helper.grain = 16;  			helper.pathCost = 200;  			helper.diagonalCost = 100;  			// create the AStar path finder  			helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  			if (helper.grid == null)  				return;  			foreach (DaggerNoodle noodle in _noodles) {  				noodle.UpdateNoodlePath (NoodleStyle.BendyStraws' helper);  				helper.grid.Reset ();  			}  		}  		break;  	default:  		break;  	}  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodleContainer,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodles,The following statement contains a magic number: if (_updateRef == 0) {  	switch (_style) {  	case NoodleStyle.Default:  	case NoodleStyle.Bezier:  		{  			foreach (DaggerNoodle noodle in _noodles) {  				noodle.UpdateNoodlePath (NoodleStyle.Bezier' null);  			}  		}  		break;  	case NoodleStyle.Lines:  		{  			foreach (DaggerNoodle noodle in _noodles) {  				noodle.UpdateNoodlePath (NoodleStyle.Lines' null);  			}  		}  		break;  	case NoodleStyle.CircuitBoardCoarse:  		{  			// create the helper  			AstarHelper helper = new AstarHelper ();  			helper.grain = 24;  			helper.pathCost = 100;  			helper.diagonalCost = 50;  			// create the AStar path finder  			helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  			if (helper.grid == null)  				return;  			foreach (DaggerNoodle noodle in _noodles) {  				noodle.UpdateNoodlePath (NoodleStyle.CircuitBoardCoarse' helper);  				helper.grid.Reset ();  			}  		}  		break;  	case NoodleStyle.CircuitBoardFine:  		{  			// create the helper  			AstarHelper helper = new AstarHelper ();  			helper.grain = 16;  			helper.pathCost = 100;  			helper.diagonalCost = 20;  			// create the AStar path finder  			helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  			if (helper.grid == null)  				return;  			foreach (DaggerNoodle noodle in _noodles) {  				noodle.UpdateNoodlePath (NoodleStyle.CircuitBoardFine' helper);  				helper.grid.Reset ();  			}  		}  		break;  	case NoodleStyle.Ramen:  		{  			// create the helper  			AstarHelper helper = new AstarHelper ();  			helper.grain = 16;  			helper.pathCost = 100;  			helper.diagonalCost = 20;  			// create the AStar path finder  			helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  			if (helper.grid == null)  				return;  			foreach (DaggerNoodle noodle in _noodles) {  				noodle.UpdateNoodlePath (NoodleStyle.Ramen' helper);  				helper.grid.Reset ();  			}  		}  		break;  	case NoodleStyle.BendyStraws:  		{  			// create the helper  			AstarHelper helper = new AstarHelper ();  			helper.grain = 16;  			helper.pathCost = 200;  			helper.diagonalCost = 100;  			// create the AStar path finder  			helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  			if (helper.grid == null)  				return;  			foreach (DaggerNoodle noodle in _noodles) {  				noodle.UpdateNoodlePath (NoodleStyle.BendyStraws' helper);  				helper.grid.Reset ();  			}  		}  		break;  	default:  		break;  	}  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodleContainer,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodles,The following statement contains a magic number: if (_updateRef == 0) {  	switch (_style) {  	case NoodleStyle.Default:  	case NoodleStyle.Bezier:  		{  			foreach (DaggerNoodle noodle in _noodles) {  				noodle.UpdateNoodlePath (NoodleStyle.Bezier' null);  			}  		}  		break;  	case NoodleStyle.Lines:  		{  			foreach (DaggerNoodle noodle in _noodles) {  				noodle.UpdateNoodlePath (NoodleStyle.Lines' null);  			}  		}  		break;  	case NoodleStyle.CircuitBoardCoarse:  		{  			// create the helper  			AstarHelper helper = new AstarHelper ();  			helper.grain = 24;  			helper.pathCost = 100;  			helper.diagonalCost = 50;  			// create the AStar path finder  			helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  			if (helper.grid == null)  				return;  			foreach (DaggerNoodle noodle in _noodles) {  				noodle.UpdateNoodlePath (NoodleStyle.CircuitBoardCoarse' helper);  				helper.grid.Reset ();  			}  		}  		break;  	case NoodleStyle.CircuitBoardFine:  		{  			// create the helper  			AstarHelper helper = new AstarHelper ();  			helper.grain = 16;  			helper.pathCost = 100;  			helper.diagonalCost = 20;  			// create the AStar path finder  			helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  			if (helper.grid == null)  				return;  			foreach (DaggerNoodle noodle in _noodles) {  				noodle.UpdateNoodlePath (NoodleStyle.CircuitBoardFine' helper);  				helper.grid.Reset ();  			}  		}  		break;  	case NoodleStyle.Ramen:  		{  			// create the helper  			AstarHelper helper = new AstarHelper ();  			helper.grain = 16;  			helper.pathCost = 100;  			helper.diagonalCost = 20;  			// create the AStar path finder  			helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  			if (helper.grid == null)  				return;  			foreach (DaggerNoodle noodle in _noodles) {  				noodle.UpdateNoodlePath (NoodleStyle.Ramen' helper);  				helper.grid.Reset ();  			}  		}  		break;  	case NoodleStyle.BendyStraws:  		{  			// create the helper  			AstarHelper helper = new AstarHelper ();  			helper.grain = 16;  			helper.pathCost = 200;  			helper.diagonalCost = 100;  			// create the AStar path finder  			helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  			if (helper.grid == null)  				return;  			foreach (DaggerNoodle noodle in _noodles) {  				noodle.UpdateNoodlePath (NoodleStyle.BendyStraws' helper);  				helper.grid.Reset ();  			}  		}  		break;  	default:  		break;  	}  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodleContainer,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodles,The following statement contains a magic number: if (_updateRef == 0) {  	switch (_style) {  	case NoodleStyle.Default:  	case NoodleStyle.Bezier:  		{  			foreach (DaggerNoodle noodle in _noodles) {  				noodle.UpdateNoodlePath (NoodleStyle.Bezier' null);  			}  		}  		break;  	case NoodleStyle.Lines:  		{  			foreach (DaggerNoodle noodle in _noodles) {  				noodle.UpdateNoodlePath (NoodleStyle.Lines' null);  			}  		}  		break;  	case NoodleStyle.CircuitBoardCoarse:  		{  			// create the helper  			AstarHelper helper = new AstarHelper ();  			helper.grain = 24;  			helper.pathCost = 100;  			helper.diagonalCost = 50;  			// create the AStar path finder  			helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  			if (helper.grid == null)  				return;  			foreach (DaggerNoodle noodle in _noodles) {  				noodle.UpdateNoodlePath (NoodleStyle.CircuitBoardCoarse' helper);  				helper.grid.Reset ();  			}  		}  		break;  	case NoodleStyle.CircuitBoardFine:  		{  			// create the helper  			AstarHelper helper = new AstarHelper ();  			helper.grain = 16;  			helper.pathCost = 100;  			helper.diagonalCost = 20;  			// create the AStar path finder  			helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  			if (helper.grid == null)  				return;  			foreach (DaggerNoodle noodle in _noodles) {  				noodle.UpdateNoodlePath (NoodleStyle.CircuitBoardFine' helper);  				helper.grid.Reset ();  			}  		}  		break;  	case NoodleStyle.Ramen:  		{  			// create the helper  			AstarHelper helper = new AstarHelper ();  			helper.grain = 16;  			helper.pathCost = 100;  			helper.diagonalCost = 20;  			// create the AStar path finder  			helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  			if (helper.grid == null)  				return;  			foreach (DaggerNoodle noodle in _noodles) {  				noodle.UpdateNoodlePath (NoodleStyle.Ramen' helper);  				helper.grid.Reset ();  			}  		}  		break;  	case NoodleStyle.BendyStraws:  		{  			// create the helper  			AstarHelper helper = new AstarHelper ();  			helper.grain = 16;  			helper.pathCost = 200;  			helper.diagonalCost = 100;  			// create the AStar path finder  			helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  			if (helper.grid == null)  				return;  			foreach (DaggerNoodle noodle in _noodles) {  				noodle.UpdateNoodlePath (NoodleStyle.BendyStraws' helper);  				helper.grid.Reset ();  			}  		}  		break;  	default:  		break;  	}  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodleContainer,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodles,The following statement contains a magic number: if (_updateRef == 0) {  	switch (_style) {  	case NoodleStyle.Default:  	case NoodleStyle.Bezier:  		{  			foreach (DaggerNoodle noodle in _noodles) {  				noodle.UpdateNoodlePath (NoodleStyle.Bezier' null);  			}  		}  		break;  	case NoodleStyle.Lines:  		{  			foreach (DaggerNoodle noodle in _noodles) {  				noodle.UpdateNoodlePath (NoodleStyle.Lines' null);  			}  		}  		break;  	case NoodleStyle.CircuitBoardCoarse:  		{  			// create the helper  			AstarHelper helper = new AstarHelper ();  			helper.grain = 24;  			helper.pathCost = 100;  			helper.diagonalCost = 50;  			// create the AStar path finder  			helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  			if (helper.grid == null)  				return;  			foreach (DaggerNoodle noodle in _noodles) {  				noodle.UpdateNoodlePath (NoodleStyle.CircuitBoardCoarse' helper);  				helper.grid.Reset ();  			}  		}  		break;  	case NoodleStyle.CircuitBoardFine:  		{  			// create the helper  			AstarHelper helper = new AstarHelper ();  			helper.grain = 16;  			helper.pathCost = 100;  			helper.diagonalCost = 20;  			// create the AStar path finder  			helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  			if (helper.grid == null)  				return;  			foreach (DaggerNoodle noodle in _noodles) {  				noodle.UpdateNoodlePath (NoodleStyle.CircuitBoardFine' helper);  				helper.grid.Reset ();  			}  		}  		break;  	case NoodleStyle.Ramen:  		{  			// create the helper  			AstarHelper helper = new AstarHelper ();  			helper.grain = 16;  			helper.pathCost = 100;  			helper.diagonalCost = 20;  			// create the AStar path finder  			helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  			if (helper.grid == null)  				return;  			foreach (DaggerNoodle noodle in _noodles) {  				noodle.UpdateNoodlePath (NoodleStyle.Ramen' helper);  				helper.grid.Reset ();  			}  		}  		break;  	case NoodleStyle.BendyStraws:  		{  			// create the helper  			AstarHelper helper = new AstarHelper ();  			helper.grain = 16;  			helper.pathCost = 200;  			helper.diagonalCost = 100;  			// create the AStar path finder  			helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  			if (helper.grid == null)  				return;  			foreach (DaggerNoodle noodle in _noodles) {  				noodle.UpdateNoodlePath (NoodleStyle.BendyStraws' helper);  				helper.grid.Reset ();  			}  		}  		break;  	default:  		break;  	}  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodleContainer,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodles,The following statement contains a magic number: switch (_style) {  case NoodleStyle.Default:  case NoodleStyle.Bezier:  	{  		foreach (DaggerNoodle noodle in _noodles) {  			noodle.UpdateNoodlePath (NoodleStyle.Bezier' null);  		}  	}  	break;  case NoodleStyle.Lines:  	{  		foreach (DaggerNoodle noodle in _noodles) {  			noodle.UpdateNoodlePath (NoodleStyle.Lines' null);  		}  	}  	break;  case NoodleStyle.CircuitBoardCoarse:  	{  		// create the helper  		AstarHelper helper = new AstarHelper ();  		helper.grain = 24;  		helper.pathCost = 100;  		helper.diagonalCost = 50;  		// create the AStar path finder  		helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  		if (helper.grid == null)  			return;  		foreach (DaggerNoodle noodle in _noodles) {  			noodle.UpdateNoodlePath (NoodleStyle.CircuitBoardCoarse' helper);  			helper.grid.Reset ();  		}  	}  	break;  case NoodleStyle.CircuitBoardFine:  	{  		// create the helper  		AstarHelper helper = new AstarHelper ();  		helper.grain = 16;  		helper.pathCost = 100;  		helper.diagonalCost = 20;  		// create the AStar path finder  		helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  		if (helper.grid == null)  			return;  		foreach (DaggerNoodle noodle in _noodles) {  			noodle.UpdateNoodlePath (NoodleStyle.CircuitBoardFine' helper);  			helper.grid.Reset ();  		}  	}  	break;  case NoodleStyle.Ramen:  	{  		// create the helper  		AstarHelper helper = new AstarHelper ();  		helper.grain = 16;  		helper.pathCost = 100;  		helper.diagonalCost = 20;  		// create the AStar path finder  		helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  		if (helper.grid == null)  			return;  		foreach (DaggerNoodle noodle in _noodles) {  			noodle.UpdateNoodlePath (NoodleStyle.Ramen' helper);  			helper.grid.Reset ();  		}  	}  	break;  case NoodleStyle.BendyStraws:  	{  		// create the helper  		AstarHelper helper = new AstarHelper ();  		helper.grain = 16;  		helper.pathCost = 200;  		helper.diagonalCost = 100;  		// create the AStar path finder  		helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  		if (helper.grid == null)  			return;  		foreach (DaggerNoodle noodle in _noodles) {  			noodle.UpdateNoodlePath (NoodleStyle.BendyStraws' helper);  			helper.grid.Reset ();  		}  	}  	break;  default:  	break;  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodleContainer,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodles,The following statement contains a magic number: switch (_style) {  case NoodleStyle.Default:  case NoodleStyle.Bezier:  	{  		foreach (DaggerNoodle noodle in _noodles) {  			noodle.UpdateNoodlePath (NoodleStyle.Bezier' null);  		}  	}  	break;  case NoodleStyle.Lines:  	{  		foreach (DaggerNoodle noodle in _noodles) {  			noodle.UpdateNoodlePath (NoodleStyle.Lines' null);  		}  	}  	break;  case NoodleStyle.CircuitBoardCoarse:  	{  		// create the helper  		AstarHelper helper = new AstarHelper ();  		helper.grain = 24;  		helper.pathCost = 100;  		helper.diagonalCost = 50;  		// create the AStar path finder  		helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  		if (helper.grid == null)  			return;  		foreach (DaggerNoodle noodle in _noodles) {  			noodle.UpdateNoodlePath (NoodleStyle.CircuitBoardCoarse' helper);  			helper.grid.Reset ();  		}  	}  	break;  case NoodleStyle.CircuitBoardFine:  	{  		// create the helper  		AstarHelper helper = new AstarHelper ();  		helper.grain = 16;  		helper.pathCost = 100;  		helper.diagonalCost = 20;  		// create the AStar path finder  		helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  		if (helper.grid == null)  			return;  		foreach (DaggerNoodle noodle in _noodles) {  			noodle.UpdateNoodlePath (NoodleStyle.CircuitBoardFine' helper);  			helper.grid.Reset ();  		}  	}  	break;  case NoodleStyle.Ramen:  	{  		// create the helper  		AstarHelper helper = new AstarHelper ();  		helper.grain = 16;  		helper.pathCost = 100;  		helper.diagonalCost = 20;  		// create the AStar path finder  		helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  		if (helper.grid == null)  			return;  		foreach (DaggerNoodle noodle in _noodles) {  			noodle.UpdateNoodlePath (NoodleStyle.Ramen' helper);  			helper.grid.Reset ();  		}  	}  	break;  case NoodleStyle.BendyStraws:  	{  		// create the helper  		AstarHelper helper = new AstarHelper ();  		helper.grain = 16;  		helper.pathCost = 200;  		helper.diagonalCost = 100;  		// create the AStar path finder  		helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  		if (helper.grid == null)  			return;  		foreach (DaggerNoodle noodle in _noodles) {  			noodle.UpdateNoodlePath (NoodleStyle.BendyStraws' helper);  			helper.grid.Reset ();  		}  	}  	break;  default:  	break;  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodleContainer,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodles,The following statement contains a magic number: switch (_style) {  case NoodleStyle.Default:  case NoodleStyle.Bezier:  	{  		foreach (DaggerNoodle noodle in _noodles) {  			noodle.UpdateNoodlePath (NoodleStyle.Bezier' null);  		}  	}  	break;  case NoodleStyle.Lines:  	{  		foreach (DaggerNoodle noodle in _noodles) {  			noodle.UpdateNoodlePath (NoodleStyle.Lines' null);  		}  	}  	break;  case NoodleStyle.CircuitBoardCoarse:  	{  		// create the helper  		AstarHelper helper = new AstarHelper ();  		helper.grain = 24;  		helper.pathCost = 100;  		helper.diagonalCost = 50;  		// create the AStar path finder  		helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  		if (helper.grid == null)  			return;  		foreach (DaggerNoodle noodle in _noodles) {  			noodle.UpdateNoodlePath (NoodleStyle.CircuitBoardCoarse' helper);  			helper.grid.Reset ();  		}  	}  	break;  case NoodleStyle.CircuitBoardFine:  	{  		// create the helper  		AstarHelper helper = new AstarHelper ();  		helper.grain = 16;  		helper.pathCost = 100;  		helper.diagonalCost = 20;  		// create the AStar path finder  		helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  		if (helper.grid == null)  			return;  		foreach (DaggerNoodle noodle in _noodles) {  			noodle.UpdateNoodlePath (NoodleStyle.CircuitBoardFine' helper);  			helper.grid.Reset ();  		}  	}  	break;  case NoodleStyle.Ramen:  	{  		// create the helper  		AstarHelper helper = new AstarHelper ();  		helper.grain = 16;  		helper.pathCost = 100;  		helper.diagonalCost = 20;  		// create the AStar path finder  		helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  		if (helper.grid == null)  			return;  		foreach (DaggerNoodle noodle in _noodles) {  			noodle.UpdateNoodlePath (NoodleStyle.Ramen' helper);  			helper.grid.Reset ();  		}  	}  	break;  case NoodleStyle.BendyStraws:  	{  		// create the helper  		AstarHelper helper = new AstarHelper ();  		helper.grain = 16;  		helper.pathCost = 200;  		helper.diagonalCost = 100;  		// create the AStar path finder  		helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  		if (helper.grid == null)  			return;  		foreach (DaggerNoodle noodle in _noodles) {  			noodle.UpdateNoodlePath (NoodleStyle.BendyStraws' helper);  			helper.grid.Reset ();  		}  	}  	break;  default:  	break;  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodleContainer,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodles,The following statement contains a magic number: switch (_style) {  case NoodleStyle.Default:  case NoodleStyle.Bezier:  	{  		foreach (DaggerNoodle noodle in _noodles) {  			noodle.UpdateNoodlePath (NoodleStyle.Bezier' null);  		}  	}  	break;  case NoodleStyle.Lines:  	{  		foreach (DaggerNoodle noodle in _noodles) {  			noodle.UpdateNoodlePath (NoodleStyle.Lines' null);  		}  	}  	break;  case NoodleStyle.CircuitBoardCoarse:  	{  		// create the helper  		AstarHelper helper = new AstarHelper ();  		helper.grain = 24;  		helper.pathCost = 100;  		helper.diagonalCost = 50;  		// create the AStar path finder  		helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  		if (helper.grid == null)  			return;  		foreach (DaggerNoodle noodle in _noodles) {  			noodle.UpdateNoodlePath (NoodleStyle.CircuitBoardCoarse' helper);  			helper.grid.Reset ();  		}  	}  	break;  case NoodleStyle.CircuitBoardFine:  	{  		// create the helper  		AstarHelper helper = new AstarHelper ();  		helper.grain = 16;  		helper.pathCost = 100;  		helper.diagonalCost = 20;  		// create the AStar path finder  		helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  		if (helper.grid == null)  			return;  		foreach (DaggerNoodle noodle in _noodles) {  			noodle.UpdateNoodlePath (NoodleStyle.CircuitBoardFine' helper);  			helper.grid.Reset ();  		}  	}  	break;  case NoodleStyle.Ramen:  	{  		// create the helper  		AstarHelper helper = new AstarHelper ();  		helper.grain = 16;  		helper.pathCost = 100;  		helper.diagonalCost = 20;  		// create the AStar path finder  		helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  		if (helper.grid == null)  			return;  		foreach (DaggerNoodle noodle in _noodles) {  			noodle.UpdateNoodlePath (NoodleStyle.Ramen' helper);  			helper.grid.Reset ();  		}  	}  	break;  case NoodleStyle.BendyStraws:  	{  		// create the helper  		AstarHelper helper = new AstarHelper ();  		helper.grain = 16;  		helper.pathCost = 200;  		helper.diagonalCost = 100;  		// create the AStar path finder  		helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  		if (helper.grid == null)  			return;  		foreach (DaggerNoodle noodle in _noodles) {  			noodle.UpdateNoodlePath (NoodleStyle.BendyStraws' helper);  			helper.grid.Reset ();  		}  	}  	break;  default:  	break;  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodleContainer,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodles,The following statement contains a magic number: switch (_style) {  case NoodleStyle.Default:  case NoodleStyle.Bezier:  	{  		foreach (DaggerNoodle noodle in _noodles) {  			noodle.UpdateNoodlePath (NoodleStyle.Bezier' null);  		}  	}  	break;  case NoodleStyle.Lines:  	{  		foreach (DaggerNoodle noodle in _noodles) {  			noodle.UpdateNoodlePath (NoodleStyle.Lines' null);  		}  	}  	break;  case NoodleStyle.CircuitBoardCoarse:  	{  		// create the helper  		AstarHelper helper = new AstarHelper ();  		helper.grain = 24;  		helper.pathCost = 100;  		helper.diagonalCost = 50;  		// create the AStar path finder  		helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  		if (helper.grid == null)  			return;  		foreach (DaggerNoodle noodle in _noodles) {  			noodle.UpdateNoodlePath (NoodleStyle.CircuitBoardCoarse' helper);  			helper.grid.Reset ();  		}  	}  	break;  case NoodleStyle.CircuitBoardFine:  	{  		// create the helper  		AstarHelper helper = new AstarHelper ();  		helper.grain = 16;  		helper.pathCost = 100;  		helper.diagonalCost = 20;  		// create the AStar path finder  		helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  		if (helper.grid == null)  			return;  		foreach (DaggerNoodle noodle in _noodles) {  			noodle.UpdateNoodlePath (NoodleStyle.CircuitBoardFine' helper);  			helper.grid.Reset ();  		}  	}  	break;  case NoodleStyle.Ramen:  	{  		// create the helper  		AstarHelper helper = new AstarHelper ();  		helper.grain = 16;  		helper.pathCost = 100;  		helper.diagonalCost = 20;  		// create the AStar path finder  		helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  		if (helper.grid == null)  			return;  		foreach (DaggerNoodle noodle in _noodles) {  			noodle.UpdateNoodlePath (NoodleStyle.Ramen' helper);  			helper.grid.Reset ();  		}  	}  	break;  case NoodleStyle.BendyStraws:  	{  		// create the helper  		AstarHelper helper = new AstarHelper ();  		helper.grain = 16;  		helper.pathCost = 200;  		helper.diagonalCost = 100;  		// create the AStar path finder  		helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  		if (helper.grid == null)  			return;  		foreach (DaggerNoodle noodle in _noodles) {  			noodle.UpdateNoodlePath (NoodleStyle.BendyStraws' helper);  			helper.grid.Reset ();  		}  	}  	break;  default:  	break;  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodleContainer,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodles,The following statement contains a magic number: switch (_style) {  case NoodleStyle.Default:  case NoodleStyle.Bezier:  	{  		foreach (DaggerNoodle noodle in _noodles) {  			noodle.UpdateNoodlePath (NoodleStyle.Bezier' null);  		}  	}  	break;  case NoodleStyle.Lines:  	{  		foreach (DaggerNoodle noodle in _noodles) {  			noodle.UpdateNoodlePath (NoodleStyle.Lines' null);  		}  	}  	break;  case NoodleStyle.CircuitBoardCoarse:  	{  		// create the helper  		AstarHelper helper = new AstarHelper ();  		helper.grain = 24;  		helper.pathCost = 100;  		helper.diagonalCost = 50;  		// create the AStar path finder  		helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  		if (helper.grid == null)  			return;  		foreach (DaggerNoodle noodle in _noodles) {  			noodle.UpdateNoodlePath (NoodleStyle.CircuitBoardCoarse' helper);  			helper.grid.Reset ();  		}  	}  	break;  case NoodleStyle.CircuitBoardFine:  	{  		// create the helper  		AstarHelper helper = new AstarHelper ();  		helper.grain = 16;  		helper.pathCost = 100;  		helper.diagonalCost = 20;  		// create the AStar path finder  		helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  		if (helper.grid == null)  			return;  		foreach (DaggerNoodle noodle in _noodles) {  			noodle.UpdateNoodlePath (NoodleStyle.CircuitBoardFine' helper);  			helper.grid.Reset ();  		}  	}  	break;  case NoodleStyle.Ramen:  	{  		// create the helper  		AstarHelper helper = new AstarHelper ();  		helper.grain = 16;  		helper.pathCost = 100;  		helper.diagonalCost = 20;  		// create the AStar path finder  		helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  		if (helper.grid == null)  			return;  		foreach (DaggerNoodle noodle in _noodles) {  			noodle.UpdateNoodlePath (NoodleStyle.Ramen' helper);  			helper.grid.Reset ();  		}  	}  	break;  case NoodleStyle.BendyStraws:  	{  		// create the helper  		AstarHelper helper = new AstarHelper ();  		helper.grain = 16;  		helper.pathCost = 200;  		helper.diagonalCost = 100;  		// create the AStar path finder  		helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  		if (helper.grid == null)  			return;  		foreach (DaggerNoodle noodle in _noodles) {  			noodle.UpdateNoodlePath (NoodleStyle.BendyStraws' helper);  			helper.grid.Reset ();  		}  	}  	break;  default:  	break;  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodleContainer,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodles,The following statement contains a magic number: switch (_style) {  case NoodleStyle.Default:  case NoodleStyle.Bezier:  	{  		foreach (DaggerNoodle noodle in _noodles) {  			noodle.UpdateNoodlePath (NoodleStyle.Bezier' null);  		}  	}  	break;  case NoodleStyle.Lines:  	{  		foreach (DaggerNoodle noodle in _noodles) {  			noodle.UpdateNoodlePath (NoodleStyle.Lines' null);  		}  	}  	break;  case NoodleStyle.CircuitBoardCoarse:  	{  		// create the helper  		AstarHelper helper = new AstarHelper ();  		helper.grain = 24;  		helper.pathCost = 100;  		helper.diagonalCost = 50;  		// create the AStar path finder  		helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  		if (helper.grid == null)  			return;  		foreach (DaggerNoodle noodle in _noodles) {  			noodle.UpdateNoodlePath (NoodleStyle.CircuitBoardCoarse' helper);  			helper.grid.Reset ();  		}  	}  	break;  case NoodleStyle.CircuitBoardFine:  	{  		// create the helper  		AstarHelper helper = new AstarHelper ();  		helper.grain = 16;  		helper.pathCost = 100;  		helper.diagonalCost = 20;  		// create the AStar path finder  		helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  		if (helper.grid == null)  			return;  		foreach (DaggerNoodle noodle in _noodles) {  			noodle.UpdateNoodlePath (NoodleStyle.CircuitBoardFine' helper);  			helper.grid.Reset ();  		}  	}  	break;  case NoodleStyle.Ramen:  	{  		// create the helper  		AstarHelper helper = new AstarHelper ();  		helper.grain = 16;  		helper.pathCost = 100;  		helper.diagonalCost = 20;  		// create the AStar path finder  		helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  		if (helper.grid == null)  			return;  		foreach (DaggerNoodle noodle in _noodles) {  			noodle.UpdateNoodlePath (NoodleStyle.Ramen' helper);  			helper.grid.Reset ();  		}  	}  	break;  case NoodleStyle.BendyStraws:  	{  		// create the helper  		AstarHelper helper = new AstarHelper ();  		helper.grain = 16;  		helper.pathCost = 200;  		helper.diagonalCost = 100;  		// create the AStar path finder  		helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  		if (helper.grid == null)  			return;  		foreach (DaggerNoodle noodle in _noodles) {  			noodle.UpdateNoodlePath (NoodleStyle.BendyStraws' helper);  			helper.grid.Reset ();  		}  	}  	break;  default:  	break;  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodleContainer,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodles,The following statement contains a magic number: switch (_style) {  case NoodleStyle.Default:  case NoodleStyle.Bezier:  	{  		foreach (DaggerNoodle noodle in _noodles) {  			noodle.UpdateNoodlePath (NoodleStyle.Bezier' null);  		}  	}  	break;  case NoodleStyle.Lines:  	{  		foreach (DaggerNoodle noodle in _noodles) {  			noodle.UpdateNoodlePath (NoodleStyle.Lines' null);  		}  	}  	break;  case NoodleStyle.CircuitBoardCoarse:  	{  		// create the helper  		AstarHelper helper = new AstarHelper ();  		helper.grain = 24;  		helper.pathCost = 100;  		helper.diagonalCost = 50;  		// create the AStar path finder  		helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  		if (helper.grid == null)  			return;  		foreach (DaggerNoodle noodle in _noodles) {  			noodle.UpdateNoodlePath (NoodleStyle.CircuitBoardCoarse' helper);  			helper.grid.Reset ();  		}  	}  	break;  case NoodleStyle.CircuitBoardFine:  	{  		// create the helper  		AstarHelper helper = new AstarHelper ();  		helper.grain = 16;  		helper.pathCost = 100;  		helper.diagonalCost = 20;  		// create the AStar path finder  		helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  		if (helper.grid == null)  			return;  		foreach (DaggerNoodle noodle in _noodles) {  			noodle.UpdateNoodlePath (NoodleStyle.CircuitBoardFine' helper);  			helper.grid.Reset ();  		}  	}  	break;  case NoodleStyle.Ramen:  	{  		// create the helper  		AstarHelper helper = new AstarHelper ();  		helper.grain = 16;  		helper.pathCost = 100;  		helper.diagonalCost = 20;  		// create the AStar path finder  		helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  		if (helper.grid == null)  			return;  		foreach (DaggerNoodle noodle in _noodles) {  			noodle.UpdateNoodlePath (NoodleStyle.Ramen' helper);  			helper.grid.Reset ();  		}  	}  	break;  case NoodleStyle.BendyStraws:  	{  		// create the helper  		AstarHelper helper = new AstarHelper ();  		helper.grain = 16;  		helper.pathCost = 200;  		helper.diagonalCost = 100;  		// create the AStar path finder  		helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  		if (helper.grid == null)  			return;  		foreach (DaggerNoodle noodle in _noodles) {  			noodle.UpdateNoodlePath (NoodleStyle.BendyStraws' helper);  			helper.grid.Reset ();  		}  	}  	break;  default:  	break;  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodleContainer,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodles,The following statement contains a magic number: switch (_style) {  case NoodleStyle.Default:  case NoodleStyle.Bezier:  	{  		foreach (DaggerNoodle noodle in _noodles) {  			noodle.UpdateNoodlePath (NoodleStyle.Bezier' null);  		}  	}  	break;  case NoodleStyle.Lines:  	{  		foreach (DaggerNoodle noodle in _noodles) {  			noodle.UpdateNoodlePath (NoodleStyle.Lines' null);  		}  	}  	break;  case NoodleStyle.CircuitBoardCoarse:  	{  		// create the helper  		AstarHelper helper = new AstarHelper ();  		helper.grain = 24;  		helper.pathCost = 100;  		helper.diagonalCost = 50;  		// create the AStar path finder  		helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  		if (helper.grid == null)  			return;  		foreach (DaggerNoodle noodle in _noodles) {  			noodle.UpdateNoodlePath (NoodleStyle.CircuitBoardCoarse' helper);  			helper.grid.Reset ();  		}  	}  	break;  case NoodleStyle.CircuitBoardFine:  	{  		// create the helper  		AstarHelper helper = new AstarHelper ();  		helper.grain = 16;  		helper.pathCost = 100;  		helper.diagonalCost = 20;  		// create the AStar path finder  		helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  		if (helper.grid == null)  			return;  		foreach (DaggerNoodle noodle in _noodles) {  			noodle.UpdateNoodlePath (NoodleStyle.CircuitBoardFine' helper);  			helper.grid.Reset ();  		}  	}  	break;  case NoodleStyle.Ramen:  	{  		// create the helper  		AstarHelper helper = new AstarHelper ();  		helper.grain = 16;  		helper.pathCost = 100;  		helper.diagonalCost = 20;  		// create the AStar path finder  		helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  		if (helper.grid == null)  			return;  		foreach (DaggerNoodle noodle in _noodles) {  			noodle.UpdateNoodlePath (NoodleStyle.Ramen' helper);  			helper.grid.Reset ();  		}  	}  	break;  case NoodleStyle.BendyStraws:  	{  		// create the helper  		AstarHelper helper = new AstarHelper ();  		helper.grain = 16;  		helper.pathCost = 200;  		helper.diagonalCost = 100;  		// create the AStar path finder  		helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  		if (helper.grid == null)  			return;  		foreach (DaggerNoodle noodle in _noodles) {  			noodle.UpdateNoodlePath (NoodleStyle.BendyStraws' helper);  			helper.grid.Reset ();  		}  	}  	break;  default:  	break;  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodleContainer,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodles,The following statement contains a magic number: switch (_style) {  case NoodleStyle.Default:  case NoodleStyle.Bezier:  	{  		foreach (DaggerNoodle noodle in _noodles) {  			noodle.UpdateNoodlePath (NoodleStyle.Bezier' null);  		}  	}  	break;  case NoodleStyle.Lines:  	{  		foreach (DaggerNoodle noodle in _noodles) {  			noodle.UpdateNoodlePath (NoodleStyle.Lines' null);  		}  	}  	break;  case NoodleStyle.CircuitBoardCoarse:  	{  		// create the helper  		AstarHelper helper = new AstarHelper ();  		helper.grain = 24;  		helper.pathCost = 100;  		helper.diagonalCost = 50;  		// create the AStar path finder  		helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  		if (helper.grid == null)  			return;  		foreach (DaggerNoodle noodle in _noodles) {  			noodle.UpdateNoodlePath (NoodleStyle.CircuitBoardCoarse' helper);  			helper.grid.Reset ();  		}  	}  	break;  case NoodleStyle.CircuitBoardFine:  	{  		// create the helper  		AstarHelper helper = new AstarHelper ();  		helper.grain = 16;  		helper.pathCost = 100;  		helper.diagonalCost = 20;  		// create the AStar path finder  		helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  		if (helper.grid == null)  			return;  		foreach (DaggerNoodle noodle in _noodles) {  			noodle.UpdateNoodlePath (NoodleStyle.CircuitBoardFine' helper);  			helper.grid.Reset ();  		}  	}  	break;  case NoodleStyle.Ramen:  	{  		// create the helper  		AstarHelper helper = new AstarHelper ();  		helper.grain = 16;  		helper.pathCost = 100;  		helper.diagonalCost = 20;  		// create the AStar path finder  		helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  		if (helper.grid == null)  			return;  		foreach (DaggerNoodle noodle in _noodles) {  			noodle.UpdateNoodlePath (NoodleStyle.Ramen' helper);  			helper.grid.Reset ();  		}  	}  	break;  case NoodleStyle.BendyStraws:  	{  		// create the helper  		AstarHelper helper = new AstarHelper ();  		helper.grain = 16;  		helper.pathCost = 200;  		helper.diagonalCost = 100;  		// create the AStar path finder  		helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  		if (helper.grid == null)  			return;  		foreach (DaggerNoodle noodle in _noodles) {  			noodle.UpdateNoodlePath (NoodleStyle.BendyStraws' helper);  			helper.grid.Reset ();  		}  	}  	break;  default:  	break;  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodleContainer,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodles,The following statement contains a magic number: switch (_style) {  case NoodleStyle.Default:  case NoodleStyle.Bezier:  	{  		foreach (DaggerNoodle noodle in _noodles) {  			noodle.UpdateNoodlePath (NoodleStyle.Bezier' null);  		}  	}  	break;  case NoodleStyle.Lines:  	{  		foreach (DaggerNoodle noodle in _noodles) {  			noodle.UpdateNoodlePath (NoodleStyle.Lines' null);  		}  	}  	break;  case NoodleStyle.CircuitBoardCoarse:  	{  		// create the helper  		AstarHelper helper = new AstarHelper ();  		helper.grain = 24;  		helper.pathCost = 100;  		helper.diagonalCost = 50;  		// create the AStar path finder  		helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  		if (helper.grid == null)  			return;  		foreach (DaggerNoodle noodle in _noodles) {  			noodle.UpdateNoodlePath (NoodleStyle.CircuitBoardCoarse' helper);  			helper.grid.Reset ();  		}  	}  	break;  case NoodleStyle.CircuitBoardFine:  	{  		// create the helper  		AstarHelper helper = new AstarHelper ();  		helper.grain = 16;  		helper.pathCost = 100;  		helper.diagonalCost = 20;  		// create the AStar path finder  		helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  		if (helper.grid == null)  			return;  		foreach (DaggerNoodle noodle in _noodles) {  			noodle.UpdateNoodlePath (NoodleStyle.CircuitBoardFine' helper);  			helper.grid.Reset ();  		}  	}  	break;  case NoodleStyle.Ramen:  	{  		// create the helper  		AstarHelper helper = new AstarHelper ();  		helper.grain = 16;  		helper.pathCost = 100;  		helper.diagonalCost = 20;  		// create the AStar path finder  		helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  		if (helper.grid == null)  			return;  		foreach (DaggerNoodle noodle in _noodles) {  			noodle.UpdateNoodlePath (NoodleStyle.Ramen' helper);  			helper.grid.Reset ();  		}  	}  	break;  case NoodleStyle.BendyStraws:  	{  		// create the helper  		AstarHelper helper = new AstarHelper ();  		helper.grain = 16;  		helper.pathCost = 200;  		helper.diagonalCost = 100;  		// create the AStar path finder  		helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  		if (helper.grid == null)  			return;  		foreach (DaggerNoodle noodle in _noodles) {  			noodle.UpdateNoodlePath (NoodleStyle.BendyStraws' helper);  			helper.grid.Reset ();  		}  	}  	break;  default:  	break;  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodleContainer,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodles,The following statement contains a magic number: switch (_style) {  case NoodleStyle.Default:  case NoodleStyle.Bezier:  	{  		foreach (DaggerNoodle noodle in _noodles) {  			noodle.UpdateNoodlePath (NoodleStyle.Bezier' null);  		}  	}  	break;  case NoodleStyle.Lines:  	{  		foreach (DaggerNoodle noodle in _noodles) {  			noodle.UpdateNoodlePath (NoodleStyle.Lines' null);  		}  	}  	break;  case NoodleStyle.CircuitBoardCoarse:  	{  		// create the helper  		AstarHelper helper = new AstarHelper ();  		helper.grain = 24;  		helper.pathCost = 100;  		helper.diagonalCost = 50;  		// create the AStar path finder  		helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  		if (helper.grid == null)  			return;  		foreach (DaggerNoodle noodle in _noodles) {  			noodle.UpdateNoodlePath (NoodleStyle.CircuitBoardCoarse' helper);  			helper.grid.Reset ();  		}  	}  	break;  case NoodleStyle.CircuitBoardFine:  	{  		// create the helper  		AstarHelper helper = new AstarHelper ();  		helper.grain = 16;  		helper.pathCost = 100;  		helper.diagonalCost = 20;  		// create the AStar path finder  		helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  		if (helper.grid == null)  			return;  		foreach (DaggerNoodle noodle in _noodles) {  			noodle.UpdateNoodlePath (NoodleStyle.CircuitBoardFine' helper);  			helper.grid.Reset ();  		}  	}  	break;  case NoodleStyle.Ramen:  	{  		// create the helper  		AstarHelper helper = new AstarHelper ();  		helper.grain = 16;  		helper.pathCost = 100;  		helper.diagonalCost = 20;  		// create the AStar path finder  		helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  		if (helper.grid == null)  			return;  		foreach (DaggerNoodle noodle in _noodles) {  			noodle.UpdateNoodlePath (NoodleStyle.Ramen' helper);  			helper.grid.Reset ();  		}  	}  	break;  case NoodleStyle.BendyStraws:  	{  		// create the helper  		AstarHelper helper = new AstarHelper ();  		helper.grain = 16;  		helper.pathCost = 200;  		helper.diagonalCost = 100;  		// create the AStar path finder  		helper.grid = _createPathGrid (_uigraph' helper.grain' helper.diagonalCost);  		if (helper.grid == null)  			return;  		foreach (DaggerNoodle noodle in _noodles) {  			noodle.UpdateNoodlePath (NoodleStyle.BendyStraws' helper);  			helper.grid.Reset ();  		}  	}  	break;  default:  	break;  }  
Magic Number,DaggerLib.UI.Windows,DaggerNoodleContainer,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodles,The following statement contains a magic number: helper.grain = 24;  
Magic Number,DaggerLib.UI.Windows,DaggerNoodleContainer,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodles,The following statement contains a magic number: helper.pathCost = 100;  
Magic Number,DaggerLib.UI.Windows,DaggerNoodleContainer,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodles,The following statement contains a magic number: helper.diagonalCost = 50;  
Magic Number,DaggerLib.UI.Windows,DaggerNoodleContainer,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodles,The following statement contains a magic number: helper.grain = 16;  
Magic Number,DaggerLib.UI.Windows,DaggerNoodleContainer,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodles,The following statement contains a magic number: helper.pathCost = 100;  
Magic Number,DaggerLib.UI.Windows,DaggerNoodleContainer,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodles,The following statement contains a magic number: helper.diagonalCost = 20;  
Magic Number,DaggerLib.UI.Windows,DaggerNoodleContainer,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodles,The following statement contains a magic number: helper.grain = 16;  
Magic Number,DaggerLib.UI.Windows,DaggerNoodleContainer,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodles,The following statement contains a magic number: helper.pathCost = 100;  
Magic Number,DaggerLib.UI.Windows,DaggerNoodleContainer,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodles,The following statement contains a magic number: helper.diagonalCost = 20;  
Magic Number,DaggerLib.UI.Windows,DaggerNoodleContainer,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodles,The following statement contains a magic number: helper.grain = 16;  
Magic Number,DaggerLib.UI.Windows,DaggerNoodleContainer,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodles,The following statement contains a magic number: helper.pathCost = 200;  
Magic Number,DaggerLib.UI.Windows,DaggerNoodleContainer,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerNoodle.cs,UpdateNoodles,The following statement contains a magic number: helper.diagonalCost = 100;  
Magic Number,DaggerLib.UI.Windows,DaggerPinLegendElement,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerPinLegend.cs,DaggerPinLegendElement,The following statement contains a magic number: g.DrawRectangle (Pens.Black' center - 1' center - 1' 2' 2);  
Magic Number,DaggerLib.UI.Windows,DaggerPinLegendElement,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerPinLegend.cs,DaggerPinLegendElement,The following statement contains a magic number: g.DrawRectangle (Pens.Black' center - 1' center - 1' 2' 2);  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,InitializeComponent,The following statement contains a magic number: this.contextMenuStrip.Size = new System.Drawing.Size (146' 48);  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,InitializeComponent,The following statement contains a magic number: this.contextMenuStrip.Size = new System.Drawing.Size (146' 48);  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,contextMenuStrip_Opening,The following statement contains a magic number: if (_mouseOverPin != null) {  	// show the context menu for the pin instead  	e.Cancel = true;  	if ((_mouseOverPin.PinUIElements as PinUI).ContextMenuStrip != null) {  		(_mouseOverPin.PinUIElements as PinUI).ContextMenuStrip.Show ();  	}  }  else {  	// create context menu items based on state of graph  	contextMenuStrip.Items.Clear ();  	// edit items  	bool editAdded = false;  	if (_trackingSelector != null) {  		if (_trackingSelector.SelectedNodes.Count > 0) {  			ToolStripMenuItem cutMenuItem = new ToolStripMenuItem ("Cut");  			cutMenuItem.Click += new EventHandler (cutMenuItem_Click);  			contextMenuStrip.Items.Add (cutMenuItem);  			ToolStripMenuItem copyMenuItem = new ToolStripMenuItem ("Copy");  			copyMenuItem.Click += new EventHandler (copyMenuItem_Click);  			contextMenuStrip.Items.Add (copyMenuItem);  			editAdded = true;  		}  	}  	if (Clipboard.GetDataObject ().GetDataPresent (typeof(DaggerGraph))) {  		ToolStripMenuItem pasteMenuItem = new ToolStripMenuItem ("Paste");  		pasteMenuItem.Click += new EventHandler (pasteMenuItem_Click);  		contextMenuStrip.Items.Add (pasteMenuItem);  		editAdded = true;  	}  	if (editAdded) {  		contextMenuStrip.Items.Add (new ToolStripSeparator ());  	}  	if (AllowNodeProcessing && _graph.GraphScheduler != null) {  		ToolStripMenuItem processGraphMenuItem = new ToolStripMenuItem ("Process Graph");  		processGraphMenuItem.Click += new EventHandler (processGraphMenuItem_Click);  		contextMenuStrip.Items.Add (processGraphMenuItem);  	}  	if (_trackingSelector != null && _trackingSelector.SelectedNodes.Count != 0) {  		ToolStripMenuItem stackNodesMenuItem = new ToolStripMenuItem ("Stack Selected Nodes");  		stackNodesMenuItem.Click += new EventHandler (stackNodesMenuItem_Click);  		contextMenuStrip.Items.Add (stackNodesMenuItem);  	}  	if (AllNodes.Count > 0) {  		ToolStripMenuItem autoArrangeMenuItem = new ToolStripMenuItem ("Arrange Nodes");  		autoArrangeMenuItem.Click += new EventHandler (autoArrangeMenuItem_Click);  		contextMenuStrip.Items.Add (autoArrangeMenuItem);  	}  	ToolStripMenuItem noodleStyleMenuItem = new ToolStripMenuItem ("Noodle Style");  	contextMenuStrip.Items.Add (noodleStyleMenuItem);  	// noodle style items  	noodleStyleMenuItem.DropDown.Items.Clear ();  	for (int i = 0; i < 7; i++) {  		ToolStripMenuItem tmi = new ToolStripMenuItem (((NoodleStyle)i).ToString ());  		tmi.Tag = i;  		tmi.Click += new EventHandler (tmi_Click);  		if (i == (int)_noodleStyle)  			tmi.Checked = true;  		noodleStyleMenuItem.DropDown.Items.Add (tmi);  	}  }  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,contextMenuStrip_Opening,The following statement contains a magic number: for (int i = 0; i < 7; i++) {  	ToolStripMenuItem tmi = new ToolStripMenuItem (((NoodleStyle)i).ToString ());  	tmi.Tag = i;  	tmi.Click += new EventHandler (tmi_Click);  	if (i == (int)_noodleStyle)  		tmi.Checked = true;  	noodleStyleMenuItem.DropDown.Items.Add (tmi);  }  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,UpdateImportPins,The following statement contains a magic number: if (_graph.ParentSubNode != null) {  	DaggerUINode node = _graph.ParentSubNode.UINode as DaggerUINode;  	if (node._node.InputPins.Count > 0) {  		topOffset = PointToClient (node.PointToScreen ((node._node.InputPins [0].PinUIElements as PinUI).PinLocation)).Y - this._pinLegend.PinSize / 2;  	}  }  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,UpdateImportPins,The following statement contains a magic number: if (node._node.InputPins.Count > 0) {  	topOffset = PointToClient (node.PointToScreen ((node._node.InputPins [0].PinUIElements as PinUI).PinLocation)).Y - this._pinLegend.PinSize / 2;  }  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,UpdateImportPins,The following statement contains a magic number: topOffset = PointToClient (node.PointToScreen ((node._node.InputPins [0].PinUIElements as PinUI).PinLocation)).Y - this._pinLegend.PinSize / 2;  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,UpdateImportPins,The following statement contains a magic number: foreach (DaggerOutputPin pin in _graph.ImportedPins) {  	(pin.PinUIElements as PinUI).PinLocation = new Point ((int)_widestImportName + _pinSpacing' topOffset + (int)(_highestImportName / 2));  	(pin.PinUIElements as PinUI).TargetRegion = new Region (new Rectangle ((pin.PinUIElements as PinUI).PinLocation' new Size (_pinSize' _pinSize)));  	topOffset += (int)_highestImportName + _pinSpacing;  }  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,UpdateImportPins,The following statement contains a magic number: (pin.PinUIElements as PinUI).PinLocation = new Point ((int)_widestImportName + _pinSpacing' topOffset + (int)(_highestImportName / 2));  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,UpdateExportPins,The following statement contains a magic number: if (_graph.ParentSubNode != null) {  	DaggerUINode node = _graph.ParentSubNode.UINode as DaggerUINode;  	if (node._node.OutputPins.Count > 0) {  		topOffset = PointToClient (node.PointToScreen ((node._node.OutputPins [0].PinUIElements as PinUI).PinLocation)).Y - this._pinLegend.PinSize / 2;  	}  }  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,UpdateExportPins,The following statement contains a magic number: if (node._node.OutputPins.Count > 0) {  	topOffset = PointToClient (node.PointToScreen ((node._node.OutputPins [0].PinUIElements as PinUI).PinLocation)).Y - this._pinLegend.PinSize / 2;  }  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,UpdateExportPins,The following statement contains a magic number: topOffset = PointToClient (node.PointToScreen ((node._node.OutputPins [0].PinUIElements as PinUI).PinLocation)).Y - this._pinLegend.PinSize / 2;  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,UpdateExportPins,The following statement contains a magic number: foreach (DaggerInputPin pin in _graph.ExportedPins) {  	(pin.PinUIElements as PinUI).PinLocation = new Point (CanvasSize.Width - (int)_widestExportName - _pinSpacing - _pinSize' topOffset + (int)(_highestExportName / 2));  	(pin.PinUIElements as PinUI).TargetRegion = new Region (new Rectangle ((pin.PinUIElements as PinUI).PinLocation' new Size (_pinSize' _pinSize)));  	topOffset += (int)_highestExportName + _pinSpacing;  }  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,UpdateExportPins,The following statement contains a magic number: (pin.PinUIElements as PinUI).PinLocation = new Point (CanvasSize.Width - (int)_widestExportName - _pinSpacing - _pinSize' topOffset + (int)(_highestExportName / 2));  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,UpdateTrackingNoodle,The following statement contains a magic number: if (_trackingConnectPin != null) {  	Point startPoint = new Point (0' 0);  	//translate the pin locations to the uigraph client coords  	if (_trackingConnectPin.InputPin != null) {  		if (_trackingConnectPin.InputPin.ParentNode != null) {  			// Tracking pin is from a UI Node  			startPoint = (_trackingConnectPin.InputPin.ParentNode.UINode as DaggerUINode).PointToScreen ((_trackingConnectPin.InputPin.PinUIElements as PinUI).PinLocation);  			startPoint.X += _trackingConnectPin.InputPin.ParentNode.UINode.PinSize / 2;  			startPoint.Y += _trackingConnectPin.InputPin.ParentNode.UINode.PinSize / 2;  		}  		else {  			// Tracking pin is an exported pin  			startPoint = (_trackingConnectPin.InputPin.ParentGraph.ParentUIGraph as DaggerUIGraph).PointToScreen ((_trackingConnectPin.InputPin.PinUIElements as PinUI).PinLocation);  			startPoint.X += _trackingConnectPin.InputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.X;  			startPoint.Y += _trackingConnectPin.InputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.Y;  		}  	}  	else if (_trackingConnectPin.OutputPin != null) {  		if (_trackingConnectPin.OutputPin.ParentNode != null) {  			// Tracking pin is from a UI Node  			startPoint = (_trackingConnectPin.OutputPin.ParentNode.UINode as DaggerUINode).PointToScreen ((_trackingConnectPin.OutputPin.PinUIElements as PinUI).PinLocation);  			startPoint.X += _trackingConnectPin.OutputPin.ParentNode.UINode.PinSize / 2;  			startPoint.Y += _trackingConnectPin.OutputPin.ParentNode.UINode.PinSize / 2;  		}  		else {  			// Tracking pin is an imported pin  			startPoint = (_trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph as DaggerUIGraph).PointToScreen ((_trackingConnectPin.OutputPin.PinUIElements as PinUI).PinLocation);  			startPoint.X += _trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.X;  			startPoint.Y += _trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.Y;  		}  	}  	// update the start point  	_trackingConnectPin.StartPoint = PointToClient (new Point (startPoint.X + AutoScrollOffset.X' startPoint.Y + AutoScrollOffset.Y));  }  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,UpdateTrackingNoodle,The following statement contains a magic number: if (_trackingConnectPin != null) {  	Point startPoint = new Point (0' 0);  	//translate the pin locations to the uigraph client coords  	if (_trackingConnectPin.InputPin != null) {  		if (_trackingConnectPin.InputPin.ParentNode != null) {  			// Tracking pin is from a UI Node  			startPoint = (_trackingConnectPin.InputPin.ParentNode.UINode as DaggerUINode).PointToScreen ((_trackingConnectPin.InputPin.PinUIElements as PinUI).PinLocation);  			startPoint.X += _trackingConnectPin.InputPin.ParentNode.UINode.PinSize / 2;  			startPoint.Y += _trackingConnectPin.InputPin.ParentNode.UINode.PinSize / 2;  		}  		else {  			// Tracking pin is an exported pin  			startPoint = (_trackingConnectPin.InputPin.ParentGraph.ParentUIGraph as DaggerUIGraph).PointToScreen ((_trackingConnectPin.InputPin.PinUIElements as PinUI).PinLocation);  			startPoint.X += _trackingConnectPin.InputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.X;  			startPoint.Y += _trackingConnectPin.InputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.Y;  		}  	}  	else if (_trackingConnectPin.OutputPin != null) {  		if (_trackingConnectPin.OutputPin.ParentNode != null) {  			// Tracking pin is from a UI Node  			startPoint = (_trackingConnectPin.OutputPin.ParentNode.UINode as DaggerUINode).PointToScreen ((_trackingConnectPin.OutputPin.PinUIElements as PinUI).PinLocation);  			startPoint.X += _trackingConnectPin.OutputPin.ParentNode.UINode.PinSize / 2;  			startPoint.Y += _trackingConnectPin.OutputPin.ParentNode.UINode.PinSize / 2;  		}  		else {  			// Tracking pin is an imported pin  			startPoint = (_trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph as DaggerUIGraph).PointToScreen ((_trackingConnectPin.OutputPin.PinUIElements as PinUI).PinLocation);  			startPoint.X += _trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.X;  			startPoint.Y += _trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.Y;  		}  	}  	// update the start point  	_trackingConnectPin.StartPoint = PointToClient (new Point (startPoint.X + AutoScrollOffset.X' startPoint.Y + AutoScrollOffset.Y));  }  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,UpdateTrackingNoodle,The following statement contains a magic number: if (_trackingConnectPin != null) {  	Point startPoint = new Point (0' 0);  	//translate the pin locations to the uigraph client coords  	if (_trackingConnectPin.InputPin != null) {  		if (_trackingConnectPin.InputPin.ParentNode != null) {  			// Tracking pin is from a UI Node  			startPoint = (_trackingConnectPin.InputPin.ParentNode.UINode as DaggerUINode).PointToScreen ((_trackingConnectPin.InputPin.PinUIElements as PinUI).PinLocation);  			startPoint.X += _trackingConnectPin.InputPin.ParentNode.UINode.PinSize / 2;  			startPoint.Y += _trackingConnectPin.InputPin.ParentNode.UINode.PinSize / 2;  		}  		else {  			// Tracking pin is an exported pin  			startPoint = (_trackingConnectPin.InputPin.ParentGraph.ParentUIGraph as DaggerUIGraph).PointToScreen ((_trackingConnectPin.InputPin.PinUIElements as PinUI).PinLocation);  			startPoint.X += _trackingConnectPin.InputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.X;  			startPoint.Y += _trackingConnectPin.InputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.Y;  		}  	}  	else if (_trackingConnectPin.OutputPin != null) {  		if (_trackingConnectPin.OutputPin.ParentNode != null) {  			// Tracking pin is from a UI Node  			startPoint = (_trackingConnectPin.OutputPin.ParentNode.UINode as DaggerUINode).PointToScreen ((_trackingConnectPin.OutputPin.PinUIElements as PinUI).PinLocation);  			startPoint.X += _trackingConnectPin.OutputPin.ParentNode.UINode.PinSize / 2;  			startPoint.Y += _trackingConnectPin.OutputPin.ParentNode.UINode.PinSize / 2;  		}  		else {  			// Tracking pin is an imported pin  			startPoint = (_trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph as DaggerUIGraph).PointToScreen ((_trackingConnectPin.OutputPin.PinUIElements as PinUI).PinLocation);  			startPoint.X += _trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.X;  			startPoint.Y += _trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.Y;  		}  	}  	// update the start point  	_trackingConnectPin.StartPoint = PointToClient (new Point (startPoint.X + AutoScrollOffset.X' startPoint.Y + AutoScrollOffset.Y));  }  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,UpdateTrackingNoodle,The following statement contains a magic number: if (_trackingConnectPin != null) {  	Point startPoint = new Point (0' 0);  	//translate the pin locations to the uigraph client coords  	if (_trackingConnectPin.InputPin != null) {  		if (_trackingConnectPin.InputPin.ParentNode != null) {  			// Tracking pin is from a UI Node  			startPoint = (_trackingConnectPin.InputPin.ParentNode.UINode as DaggerUINode).PointToScreen ((_trackingConnectPin.InputPin.PinUIElements as PinUI).PinLocation);  			startPoint.X += _trackingConnectPin.InputPin.ParentNode.UINode.PinSize / 2;  			startPoint.Y += _trackingConnectPin.InputPin.ParentNode.UINode.PinSize / 2;  		}  		else {  			// Tracking pin is an exported pin  			startPoint = (_trackingConnectPin.InputPin.ParentGraph.ParentUIGraph as DaggerUIGraph).PointToScreen ((_trackingConnectPin.InputPin.PinUIElements as PinUI).PinLocation);  			startPoint.X += _trackingConnectPin.InputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.X;  			startPoint.Y += _trackingConnectPin.InputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.Y;  		}  	}  	else if (_trackingConnectPin.OutputPin != null) {  		if (_trackingConnectPin.OutputPin.ParentNode != null) {  			// Tracking pin is from a UI Node  			startPoint = (_trackingConnectPin.OutputPin.ParentNode.UINode as DaggerUINode).PointToScreen ((_trackingConnectPin.OutputPin.PinUIElements as PinUI).PinLocation);  			startPoint.X += _trackingConnectPin.OutputPin.ParentNode.UINode.PinSize / 2;  			startPoint.Y += _trackingConnectPin.OutputPin.ParentNode.UINode.PinSize / 2;  		}  		else {  			// Tracking pin is an imported pin  			startPoint = (_trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph as DaggerUIGraph).PointToScreen ((_trackingConnectPin.OutputPin.PinUIElements as PinUI).PinLocation);  			startPoint.X += _trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.X;  			startPoint.Y += _trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.Y;  		}  	}  	// update the start point  	_trackingConnectPin.StartPoint = PointToClient (new Point (startPoint.X + AutoScrollOffset.X' startPoint.Y + AutoScrollOffset.Y));  }  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,UpdateTrackingNoodle,The following statement contains a magic number: if (_trackingConnectPin != null) {  	Point startPoint = new Point (0' 0);  	//translate the pin locations to the uigraph client coords  	if (_trackingConnectPin.InputPin != null) {  		if (_trackingConnectPin.InputPin.ParentNode != null) {  			// Tracking pin is from a UI Node  			startPoint = (_trackingConnectPin.InputPin.ParentNode.UINode as DaggerUINode).PointToScreen ((_trackingConnectPin.InputPin.PinUIElements as PinUI).PinLocation);  			startPoint.X += _trackingConnectPin.InputPin.ParentNode.UINode.PinSize / 2;  			startPoint.Y += _trackingConnectPin.InputPin.ParentNode.UINode.PinSize / 2;  		}  		else {  			// Tracking pin is an exported pin  			startPoint = (_trackingConnectPin.InputPin.ParentGraph.ParentUIGraph as DaggerUIGraph).PointToScreen ((_trackingConnectPin.InputPin.PinUIElements as PinUI).PinLocation);  			startPoint.X += _trackingConnectPin.InputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.X;  			startPoint.Y += _trackingConnectPin.InputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.Y;  		}  	}  	else if (_trackingConnectPin.OutputPin != null) {  		if (_trackingConnectPin.OutputPin.ParentNode != null) {  			// Tracking pin is from a UI Node  			startPoint = (_trackingConnectPin.OutputPin.ParentNode.UINode as DaggerUINode).PointToScreen ((_trackingConnectPin.OutputPin.PinUIElements as PinUI).PinLocation);  			startPoint.X += _trackingConnectPin.OutputPin.ParentNode.UINode.PinSize / 2;  			startPoint.Y += _trackingConnectPin.OutputPin.ParentNode.UINode.PinSize / 2;  		}  		else {  			// Tracking pin is an imported pin  			startPoint = (_trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph as DaggerUIGraph).PointToScreen ((_trackingConnectPin.OutputPin.PinUIElements as PinUI).PinLocation);  			startPoint.X += _trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.X;  			startPoint.Y += _trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.Y;  		}  	}  	// update the start point  	_trackingConnectPin.StartPoint = PointToClient (new Point (startPoint.X + AutoScrollOffset.X' startPoint.Y + AutoScrollOffset.Y));  }  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,UpdateTrackingNoodle,The following statement contains a magic number: if (_trackingConnectPin != null) {  	Point startPoint = new Point (0' 0);  	//translate the pin locations to the uigraph client coords  	if (_trackingConnectPin.InputPin != null) {  		if (_trackingConnectPin.InputPin.ParentNode != null) {  			// Tracking pin is from a UI Node  			startPoint = (_trackingConnectPin.InputPin.ParentNode.UINode as DaggerUINode).PointToScreen ((_trackingConnectPin.InputPin.PinUIElements as PinUI).PinLocation);  			startPoint.X += _trackingConnectPin.InputPin.ParentNode.UINode.PinSize / 2;  			startPoint.Y += _trackingConnectPin.InputPin.ParentNode.UINode.PinSize / 2;  		}  		else {  			// Tracking pin is an exported pin  			startPoint = (_trackingConnectPin.InputPin.ParentGraph.ParentUIGraph as DaggerUIGraph).PointToScreen ((_trackingConnectPin.InputPin.PinUIElements as PinUI).PinLocation);  			startPoint.X += _trackingConnectPin.InputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.X;  			startPoint.Y += _trackingConnectPin.InputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.Y;  		}  	}  	else if (_trackingConnectPin.OutputPin != null) {  		if (_trackingConnectPin.OutputPin.ParentNode != null) {  			// Tracking pin is from a UI Node  			startPoint = (_trackingConnectPin.OutputPin.ParentNode.UINode as DaggerUINode).PointToScreen ((_trackingConnectPin.OutputPin.PinUIElements as PinUI).PinLocation);  			startPoint.X += _trackingConnectPin.OutputPin.ParentNode.UINode.PinSize / 2;  			startPoint.Y += _trackingConnectPin.OutputPin.ParentNode.UINode.PinSize / 2;  		}  		else {  			// Tracking pin is an imported pin  			startPoint = (_trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph as DaggerUIGraph).PointToScreen ((_trackingConnectPin.OutputPin.PinUIElements as PinUI).PinLocation);  			startPoint.X += _trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.X;  			startPoint.Y += _trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.Y;  		}  	}  	// update the start point  	_trackingConnectPin.StartPoint = PointToClient (new Point (startPoint.X + AutoScrollOffset.X' startPoint.Y + AutoScrollOffset.Y));  }  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,UpdateTrackingNoodle,The following statement contains a magic number: if (_trackingConnectPin != null) {  	Point startPoint = new Point (0' 0);  	//translate the pin locations to the uigraph client coords  	if (_trackingConnectPin.InputPin != null) {  		if (_trackingConnectPin.InputPin.ParentNode != null) {  			// Tracking pin is from a UI Node  			startPoint = (_trackingConnectPin.InputPin.ParentNode.UINode as DaggerUINode).PointToScreen ((_trackingConnectPin.InputPin.PinUIElements as PinUI).PinLocation);  			startPoint.X += _trackingConnectPin.InputPin.ParentNode.UINode.PinSize / 2;  			startPoint.Y += _trackingConnectPin.InputPin.ParentNode.UINode.PinSize / 2;  		}  		else {  			// Tracking pin is an exported pin  			startPoint = (_trackingConnectPin.InputPin.ParentGraph.ParentUIGraph as DaggerUIGraph).PointToScreen ((_trackingConnectPin.InputPin.PinUIElements as PinUI).PinLocation);  			startPoint.X += _trackingConnectPin.InputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.X;  			startPoint.Y += _trackingConnectPin.InputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.Y;  		}  	}  	else if (_trackingConnectPin.OutputPin != null) {  		if (_trackingConnectPin.OutputPin.ParentNode != null) {  			// Tracking pin is from a UI Node  			startPoint = (_trackingConnectPin.OutputPin.ParentNode.UINode as DaggerUINode).PointToScreen ((_trackingConnectPin.OutputPin.PinUIElements as PinUI).PinLocation);  			startPoint.X += _trackingConnectPin.OutputPin.ParentNode.UINode.PinSize / 2;  			startPoint.Y += _trackingConnectPin.OutputPin.ParentNode.UINode.PinSize / 2;  		}  		else {  			// Tracking pin is an imported pin  			startPoint = (_trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph as DaggerUIGraph).PointToScreen ((_trackingConnectPin.OutputPin.PinUIElements as PinUI).PinLocation);  			startPoint.X += _trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.X;  			startPoint.Y += _trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.Y;  		}  	}  	// update the start point  	_trackingConnectPin.StartPoint = PointToClient (new Point (startPoint.X + AutoScrollOffset.X' startPoint.Y + AutoScrollOffset.Y));  }  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,UpdateTrackingNoodle,The following statement contains a magic number: if (_trackingConnectPin != null) {  	Point startPoint = new Point (0' 0);  	//translate the pin locations to the uigraph client coords  	if (_trackingConnectPin.InputPin != null) {  		if (_trackingConnectPin.InputPin.ParentNode != null) {  			// Tracking pin is from a UI Node  			startPoint = (_trackingConnectPin.InputPin.ParentNode.UINode as DaggerUINode).PointToScreen ((_trackingConnectPin.InputPin.PinUIElements as PinUI).PinLocation);  			startPoint.X += _trackingConnectPin.InputPin.ParentNode.UINode.PinSize / 2;  			startPoint.Y += _trackingConnectPin.InputPin.ParentNode.UINode.PinSize / 2;  		}  		else {  			// Tracking pin is an exported pin  			startPoint = (_trackingConnectPin.InputPin.ParentGraph.ParentUIGraph as DaggerUIGraph).PointToScreen ((_trackingConnectPin.InputPin.PinUIElements as PinUI).PinLocation);  			startPoint.X += _trackingConnectPin.InputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.X;  			startPoint.Y += _trackingConnectPin.InputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.Y;  		}  	}  	else if (_trackingConnectPin.OutputPin != null) {  		if (_trackingConnectPin.OutputPin.ParentNode != null) {  			// Tracking pin is from a UI Node  			startPoint = (_trackingConnectPin.OutputPin.ParentNode.UINode as DaggerUINode).PointToScreen ((_trackingConnectPin.OutputPin.PinUIElements as PinUI).PinLocation);  			startPoint.X += _trackingConnectPin.OutputPin.ParentNode.UINode.PinSize / 2;  			startPoint.Y += _trackingConnectPin.OutputPin.ParentNode.UINode.PinSize / 2;  		}  		else {  			// Tracking pin is an imported pin  			startPoint = (_trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph as DaggerUIGraph).PointToScreen ((_trackingConnectPin.OutputPin.PinUIElements as PinUI).PinLocation);  			startPoint.X += _trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.X;  			startPoint.Y += _trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.Y;  		}  	}  	// update the start point  	_trackingConnectPin.StartPoint = PointToClient (new Point (startPoint.X + AutoScrollOffset.X' startPoint.Y + AutoScrollOffset.Y));  }  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,UpdateTrackingNoodle,The following statement contains a magic number: if (_trackingConnectPin.InputPin != null) {  	if (_trackingConnectPin.InputPin.ParentNode != null) {  		// Tracking pin is from a UI Node  		startPoint = (_trackingConnectPin.InputPin.ParentNode.UINode as DaggerUINode).PointToScreen ((_trackingConnectPin.InputPin.PinUIElements as PinUI).PinLocation);  		startPoint.X += _trackingConnectPin.InputPin.ParentNode.UINode.PinSize / 2;  		startPoint.Y += _trackingConnectPin.InputPin.ParentNode.UINode.PinSize / 2;  	}  	else {  		// Tracking pin is an exported pin  		startPoint = (_trackingConnectPin.InputPin.ParentGraph.ParentUIGraph as DaggerUIGraph).PointToScreen ((_trackingConnectPin.InputPin.PinUIElements as PinUI).PinLocation);  		startPoint.X += _trackingConnectPin.InputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.X;  		startPoint.Y += _trackingConnectPin.InputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.Y;  	}  }  else if (_trackingConnectPin.OutputPin != null) {  	if (_trackingConnectPin.OutputPin.ParentNode != null) {  		// Tracking pin is from a UI Node  		startPoint = (_trackingConnectPin.OutputPin.ParentNode.UINode as DaggerUINode).PointToScreen ((_trackingConnectPin.OutputPin.PinUIElements as PinUI).PinLocation);  		startPoint.X += _trackingConnectPin.OutputPin.ParentNode.UINode.PinSize / 2;  		startPoint.Y += _trackingConnectPin.OutputPin.ParentNode.UINode.PinSize / 2;  	}  	else {  		// Tracking pin is an imported pin  		startPoint = (_trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph as DaggerUIGraph).PointToScreen ((_trackingConnectPin.OutputPin.PinUIElements as PinUI).PinLocation);  		startPoint.X += _trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.X;  		startPoint.Y += _trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.Y;  	}  }  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,UpdateTrackingNoodle,The following statement contains a magic number: if (_trackingConnectPin.InputPin != null) {  	if (_trackingConnectPin.InputPin.ParentNode != null) {  		// Tracking pin is from a UI Node  		startPoint = (_trackingConnectPin.InputPin.ParentNode.UINode as DaggerUINode).PointToScreen ((_trackingConnectPin.InputPin.PinUIElements as PinUI).PinLocation);  		startPoint.X += _trackingConnectPin.InputPin.ParentNode.UINode.PinSize / 2;  		startPoint.Y += _trackingConnectPin.InputPin.ParentNode.UINode.PinSize / 2;  	}  	else {  		// Tracking pin is an exported pin  		startPoint = (_trackingConnectPin.InputPin.ParentGraph.ParentUIGraph as DaggerUIGraph).PointToScreen ((_trackingConnectPin.InputPin.PinUIElements as PinUI).PinLocation);  		startPoint.X += _trackingConnectPin.InputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.X;  		startPoint.Y += _trackingConnectPin.InputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.Y;  	}  }  else if (_trackingConnectPin.OutputPin != null) {  	if (_trackingConnectPin.OutputPin.ParentNode != null) {  		// Tracking pin is from a UI Node  		startPoint = (_trackingConnectPin.OutputPin.ParentNode.UINode as DaggerUINode).PointToScreen ((_trackingConnectPin.OutputPin.PinUIElements as PinUI).PinLocation);  		startPoint.X += _trackingConnectPin.OutputPin.ParentNode.UINode.PinSize / 2;  		startPoint.Y += _trackingConnectPin.OutputPin.ParentNode.UINode.PinSize / 2;  	}  	else {  		// Tracking pin is an imported pin  		startPoint = (_trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph as DaggerUIGraph).PointToScreen ((_trackingConnectPin.OutputPin.PinUIElements as PinUI).PinLocation);  		startPoint.X += _trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.X;  		startPoint.Y += _trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.Y;  	}  }  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,UpdateTrackingNoodle,The following statement contains a magic number: if (_trackingConnectPin.InputPin != null) {  	if (_trackingConnectPin.InputPin.ParentNode != null) {  		// Tracking pin is from a UI Node  		startPoint = (_trackingConnectPin.InputPin.ParentNode.UINode as DaggerUINode).PointToScreen ((_trackingConnectPin.InputPin.PinUIElements as PinUI).PinLocation);  		startPoint.X += _trackingConnectPin.InputPin.ParentNode.UINode.PinSize / 2;  		startPoint.Y += _trackingConnectPin.InputPin.ParentNode.UINode.PinSize / 2;  	}  	else {  		// Tracking pin is an exported pin  		startPoint = (_trackingConnectPin.InputPin.ParentGraph.ParentUIGraph as DaggerUIGraph).PointToScreen ((_trackingConnectPin.InputPin.PinUIElements as PinUI).PinLocation);  		startPoint.X += _trackingConnectPin.InputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.X;  		startPoint.Y += _trackingConnectPin.InputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.Y;  	}  }  else if (_trackingConnectPin.OutputPin != null) {  	if (_trackingConnectPin.OutputPin.ParentNode != null) {  		// Tracking pin is from a UI Node  		startPoint = (_trackingConnectPin.OutputPin.ParentNode.UINode as DaggerUINode).PointToScreen ((_trackingConnectPin.OutputPin.PinUIElements as PinUI).PinLocation);  		startPoint.X += _trackingConnectPin.OutputPin.ParentNode.UINode.PinSize / 2;  		startPoint.Y += _trackingConnectPin.OutputPin.ParentNode.UINode.PinSize / 2;  	}  	else {  		// Tracking pin is an imported pin  		startPoint = (_trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph as DaggerUIGraph).PointToScreen ((_trackingConnectPin.OutputPin.PinUIElements as PinUI).PinLocation);  		startPoint.X += _trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.X;  		startPoint.Y += _trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.Y;  	}  }  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,UpdateTrackingNoodle,The following statement contains a magic number: if (_trackingConnectPin.InputPin != null) {  	if (_trackingConnectPin.InputPin.ParentNode != null) {  		// Tracking pin is from a UI Node  		startPoint = (_trackingConnectPin.InputPin.ParentNode.UINode as DaggerUINode).PointToScreen ((_trackingConnectPin.InputPin.PinUIElements as PinUI).PinLocation);  		startPoint.X += _trackingConnectPin.InputPin.ParentNode.UINode.PinSize / 2;  		startPoint.Y += _trackingConnectPin.InputPin.ParentNode.UINode.PinSize / 2;  	}  	else {  		// Tracking pin is an exported pin  		startPoint = (_trackingConnectPin.InputPin.ParentGraph.ParentUIGraph as DaggerUIGraph).PointToScreen ((_trackingConnectPin.InputPin.PinUIElements as PinUI).PinLocation);  		startPoint.X += _trackingConnectPin.InputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.X;  		startPoint.Y += _trackingConnectPin.InputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.Y;  	}  }  else if (_trackingConnectPin.OutputPin != null) {  	if (_trackingConnectPin.OutputPin.ParentNode != null) {  		// Tracking pin is from a UI Node  		startPoint = (_trackingConnectPin.OutputPin.ParentNode.UINode as DaggerUINode).PointToScreen ((_trackingConnectPin.OutputPin.PinUIElements as PinUI).PinLocation);  		startPoint.X += _trackingConnectPin.OutputPin.ParentNode.UINode.PinSize / 2;  		startPoint.Y += _trackingConnectPin.OutputPin.ParentNode.UINode.PinSize / 2;  	}  	else {  		// Tracking pin is an imported pin  		startPoint = (_trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph as DaggerUIGraph).PointToScreen ((_trackingConnectPin.OutputPin.PinUIElements as PinUI).PinLocation);  		startPoint.X += _trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.X;  		startPoint.Y += _trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.Y;  	}  }  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,UpdateTrackingNoodle,The following statement contains a magic number: if (_trackingConnectPin.InputPin != null) {  	if (_trackingConnectPin.InputPin.ParentNode != null) {  		// Tracking pin is from a UI Node  		startPoint = (_trackingConnectPin.InputPin.ParentNode.UINode as DaggerUINode).PointToScreen ((_trackingConnectPin.InputPin.PinUIElements as PinUI).PinLocation);  		startPoint.X += _trackingConnectPin.InputPin.ParentNode.UINode.PinSize / 2;  		startPoint.Y += _trackingConnectPin.InputPin.ParentNode.UINode.PinSize / 2;  	}  	else {  		// Tracking pin is an exported pin  		startPoint = (_trackingConnectPin.InputPin.ParentGraph.ParentUIGraph as DaggerUIGraph).PointToScreen ((_trackingConnectPin.InputPin.PinUIElements as PinUI).PinLocation);  		startPoint.X += _trackingConnectPin.InputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.X;  		startPoint.Y += _trackingConnectPin.InputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.Y;  	}  }  else if (_trackingConnectPin.OutputPin != null) {  	if (_trackingConnectPin.OutputPin.ParentNode != null) {  		// Tracking pin is from a UI Node  		startPoint = (_trackingConnectPin.OutputPin.ParentNode.UINode as DaggerUINode).PointToScreen ((_trackingConnectPin.OutputPin.PinUIElements as PinUI).PinLocation);  		startPoint.X += _trackingConnectPin.OutputPin.ParentNode.UINode.PinSize / 2;  		startPoint.Y += _trackingConnectPin.OutputPin.ParentNode.UINode.PinSize / 2;  	}  	else {  		// Tracking pin is an imported pin  		startPoint = (_trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph as DaggerUIGraph).PointToScreen ((_trackingConnectPin.OutputPin.PinUIElements as PinUI).PinLocation);  		startPoint.X += _trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.X;  		startPoint.Y += _trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.Y;  	}  }  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,UpdateTrackingNoodle,The following statement contains a magic number: if (_trackingConnectPin.InputPin != null) {  	if (_trackingConnectPin.InputPin.ParentNode != null) {  		// Tracking pin is from a UI Node  		startPoint = (_trackingConnectPin.InputPin.ParentNode.UINode as DaggerUINode).PointToScreen ((_trackingConnectPin.InputPin.PinUIElements as PinUI).PinLocation);  		startPoint.X += _trackingConnectPin.InputPin.ParentNode.UINode.PinSize / 2;  		startPoint.Y += _trackingConnectPin.InputPin.ParentNode.UINode.PinSize / 2;  	}  	else {  		// Tracking pin is an exported pin  		startPoint = (_trackingConnectPin.InputPin.ParentGraph.ParentUIGraph as DaggerUIGraph).PointToScreen ((_trackingConnectPin.InputPin.PinUIElements as PinUI).PinLocation);  		startPoint.X += _trackingConnectPin.InputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.X;  		startPoint.Y += _trackingConnectPin.InputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.Y;  	}  }  else if (_trackingConnectPin.OutputPin != null) {  	if (_trackingConnectPin.OutputPin.ParentNode != null) {  		// Tracking pin is from a UI Node  		startPoint = (_trackingConnectPin.OutputPin.ParentNode.UINode as DaggerUINode).PointToScreen ((_trackingConnectPin.OutputPin.PinUIElements as PinUI).PinLocation);  		startPoint.X += _trackingConnectPin.OutputPin.ParentNode.UINode.PinSize / 2;  		startPoint.Y += _trackingConnectPin.OutputPin.ParentNode.UINode.PinSize / 2;  	}  	else {  		// Tracking pin is an imported pin  		startPoint = (_trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph as DaggerUIGraph).PointToScreen ((_trackingConnectPin.OutputPin.PinUIElements as PinUI).PinLocation);  		startPoint.X += _trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.X;  		startPoint.Y += _trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.Y;  	}  }  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,UpdateTrackingNoodle,The following statement contains a magic number: if (_trackingConnectPin.InputPin != null) {  	if (_trackingConnectPin.InputPin.ParentNode != null) {  		// Tracking pin is from a UI Node  		startPoint = (_trackingConnectPin.InputPin.ParentNode.UINode as DaggerUINode).PointToScreen ((_trackingConnectPin.InputPin.PinUIElements as PinUI).PinLocation);  		startPoint.X += _trackingConnectPin.InputPin.ParentNode.UINode.PinSize / 2;  		startPoint.Y += _trackingConnectPin.InputPin.ParentNode.UINode.PinSize / 2;  	}  	else {  		// Tracking pin is an exported pin  		startPoint = (_trackingConnectPin.InputPin.ParentGraph.ParentUIGraph as DaggerUIGraph).PointToScreen ((_trackingConnectPin.InputPin.PinUIElements as PinUI).PinLocation);  		startPoint.X += _trackingConnectPin.InputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.X;  		startPoint.Y += _trackingConnectPin.InputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.Y;  	}  }  else if (_trackingConnectPin.OutputPin != null) {  	if (_trackingConnectPin.OutputPin.ParentNode != null) {  		// Tracking pin is from a UI Node  		startPoint = (_trackingConnectPin.OutputPin.ParentNode.UINode as DaggerUINode).PointToScreen ((_trackingConnectPin.OutputPin.PinUIElements as PinUI).PinLocation);  		startPoint.X += _trackingConnectPin.OutputPin.ParentNode.UINode.PinSize / 2;  		startPoint.Y += _trackingConnectPin.OutputPin.ParentNode.UINode.PinSize / 2;  	}  	else {  		// Tracking pin is an imported pin  		startPoint = (_trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph as DaggerUIGraph).PointToScreen ((_trackingConnectPin.OutputPin.PinUIElements as PinUI).PinLocation);  		startPoint.X += _trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.X;  		startPoint.Y += _trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.Y;  	}  }  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,UpdateTrackingNoodle,The following statement contains a magic number: if (_trackingConnectPin.InputPin != null) {  	if (_trackingConnectPin.InputPin.ParentNode != null) {  		// Tracking pin is from a UI Node  		startPoint = (_trackingConnectPin.InputPin.ParentNode.UINode as DaggerUINode).PointToScreen ((_trackingConnectPin.InputPin.PinUIElements as PinUI).PinLocation);  		startPoint.X += _trackingConnectPin.InputPin.ParentNode.UINode.PinSize / 2;  		startPoint.Y += _trackingConnectPin.InputPin.ParentNode.UINode.PinSize / 2;  	}  	else {  		// Tracking pin is an exported pin  		startPoint = (_trackingConnectPin.InputPin.ParentGraph.ParentUIGraph as DaggerUIGraph).PointToScreen ((_trackingConnectPin.InputPin.PinUIElements as PinUI).PinLocation);  		startPoint.X += _trackingConnectPin.InputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.X;  		startPoint.Y += _trackingConnectPin.InputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.Y;  	}  }  else if (_trackingConnectPin.OutputPin != null) {  	if (_trackingConnectPin.OutputPin.ParentNode != null) {  		// Tracking pin is from a UI Node  		startPoint = (_trackingConnectPin.OutputPin.ParentNode.UINode as DaggerUINode).PointToScreen ((_trackingConnectPin.OutputPin.PinUIElements as PinUI).PinLocation);  		startPoint.X += _trackingConnectPin.OutputPin.ParentNode.UINode.PinSize / 2;  		startPoint.Y += _trackingConnectPin.OutputPin.ParentNode.UINode.PinSize / 2;  	}  	else {  		// Tracking pin is an imported pin  		startPoint = (_trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph as DaggerUIGraph).PointToScreen ((_trackingConnectPin.OutputPin.PinUIElements as PinUI).PinLocation);  		startPoint.X += _trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.X;  		startPoint.Y += _trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.Y;  	}  }  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,UpdateTrackingNoodle,The following statement contains a magic number: if (_trackingConnectPin.InputPin.ParentNode != null) {  	// Tracking pin is from a UI Node  	startPoint = (_trackingConnectPin.InputPin.ParentNode.UINode as DaggerUINode).PointToScreen ((_trackingConnectPin.InputPin.PinUIElements as PinUI).PinLocation);  	startPoint.X += _trackingConnectPin.InputPin.ParentNode.UINode.PinSize / 2;  	startPoint.Y += _trackingConnectPin.InputPin.ParentNode.UINode.PinSize / 2;  }  else {  	// Tracking pin is an exported pin  	startPoint = (_trackingConnectPin.InputPin.ParentGraph.ParentUIGraph as DaggerUIGraph).PointToScreen ((_trackingConnectPin.InputPin.PinUIElements as PinUI).PinLocation);  	startPoint.X += _trackingConnectPin.InputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.X;  	startPoint.Y += _trackingConnectPin.InputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.Y;  }  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,UpdateTrackingNoodle,The following statement contains a magic number: if (_trackingConnectPin.InputPin.ParentNode != null) {  	// Tracking pin is from a UI Node  	startPoint = (_trackingConnectPin.InputPin.ParentNode.UINode as DaggerUINode).PointToScreen ((_trackingConnectPin.InputPin.PinUIElements as PinUI).PinLocation);  	startPoint.X += _trackingConnectPin.InputPin.ParentNode.UINode.PinSize / 2;  	startPoint.Y += _trackingConnectPin.InputPin.ParentNode.UINode.PinSize / 2;  }  else {  	// Tracking pin is an exported pin  	startPoint = (_trackingConnectPin.InputPin.ParentGraph.ParentUIGraph as DaggerUIGraph).PointToScreen ((_trackingConnectPin.InputPin.PinUIElements as PinUI).PinLocation);  	startPoint.X += _trackingConnectPin.InputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.X;  	startPoint.Y += _trackingConnectPin.InputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.Y;  }  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,UpdateTrackingNoodle,The following statement contains a magic number: if (_trackingConnectPin.InputPin.ParentNode != null) {  	// Tracking pin is from a UI Node  	startPoint = (_trackingConnectPin.InputPin.ParentNode.UINode as DaggerUINode).PointToScreen ((_trackingConnectPin.InputPin.PinUIElements as PinUI).PinLocation);  	startPoint.X += _trackingConnectPin.InputPin.ParentNode.UINode.PinSize / 2;  	startPoint.Y += _trackingConnectPin.InputPin.ParentNode.UINode.PinSize / 2;  }  else {  	// Tracking pin is an exported pin  	startPoint = (_trackingConnectPin.InputPin.ParentGraph.ParentUIGraph as DaggerUIGraph).PointToScreen ((_trackingConnectPin.InputPin.PinUIElements as PinUI).PinLocation);  	startPoint.X += _trackingConnectPin.InputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.X;  	startPoint.Y += _trackingConnectPin.InputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.Y;  }  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,UpdateTrackingNoodle,The following statement contains a magic number: if (_trackingConnectPin.InputPin.ParentNode != null) {  	// Tracking pin is from a UI Node  	startPoint = (_trackingConnectPin.InputPin.ParentNode.UINode as DaggerUINode).PointToScreen ((_trackingConnectPin.InputPin.PinUIElements as PinUI).PinLocation);  	startPoint.X += _trackingConnectPin.InputPin.ParentNode.UINode.PinSize / 2;  	startPoint.Y += _trackingConnectPin.InputPin.ParentNode.UINode.PinSize / 2;  }  else {  	// Tracking pin is an exported pin  	startPoint = (_trackingConnectPin.InputPin.ParentGraph.ParentUIGraph as DaggerUIGraph).PointToScreen ((_trackingConnectPin.InputPin.PinUIElements as PinUI).PinLocation);  	startPoint.X += _trackingConnectPin.InputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.X;  	startPoint.Y += _trackingConnectPin.InputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.Y;  }  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,UpdateTrackingNoodle,The following statement contains a magic number: startPoint.X += _trackingConnectPin.InputPin.ParentNode.UINode.PinSize / 2;  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,UpdateTrackingNoodle,The following statement contains a magic number: startPoint.Y += _trackingConnectPin.InputPin.ParentNode.UINode.PinSize / 2;  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,UpdateTrackingNoodle,The following statement contains a magic number: startPoint.X += _trackingConnectPin.InputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.X;  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,UpdateTrackingNoodle,The following statement contains a magic number: startPoint.Y += _trackingConnectPin.InputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.Y;  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,UpdateTrackingNoodle,The following statement contains a magic number: if (_trackingConnectPin.OutputPin != null) {  	if (_trackingConnectPin.OutputPin.ParentNode != null) {  		// Tracking pin is from a UI Node  		startPoint = (_trackingConnectPin.OutputPin.ParentNode.UINode as DaggerUINode).PointToScreen ((_trackingConnectPin.OutputPin.PinUIElements as PinUI).PinLocation);  		startPoint.X += _trackingConnectPin.OutputPin.ParentNode.UINode.PinSize / 2;  		startPoint.Y += _trackingConnectPin.OutputPin.ParentNode.UINode.PinSize / 2;  	}  	else {  		// Tracking pin is an imported pin  		startPoint = (_trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph as DaggerUIGraph).PointToScreen ((_trackingConnectPin.OutputPin.PinUIElements as PinUI).PinLocation);  		startPoint.X += _trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.X;  		startPoint.Y += _trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.Y;  	}  }  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,UpdateTrackingNoodle,The following statement contains a magic number: if (_trackingConnectPin.OutputPin != null) {  	if (_trackingConnectPin.OutputPin.ParentNode != null) {  		// Tracking pin is from a UI Node  		startPoint = (_trackingConnectPin.OutputPin.ParentNode.UINode as DaggerUINode).PointToScreen ((_trackingConnectPin.OutputPin.PinUIElements as PinUI).PinLocation);  		startPoint.X += _trackingConnectPin.OutputPin.ParentNode.UINode.PinSize / 2;  		startPoint.Y += _trackingConnectPin.OutputPin.ParentNode.UINode.PinSize / 2;  	}  	else {  		// Tracking pin is an imported pin  		startPoint = (_trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph as DaggerUIGraph).PointToScreen ((_trackingConnectPin.OutputPin.PinUIElements as PinUI).PinLocation);  		startPoint.X += _trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.X;  		startPoint.Y += _trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.Y;  	}  }  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,UpdateTrackingNoodle,The following statement contains a magic number: if (_trackingConnectPin.OutputPin != null) {  	if (_trackingConnectPin.OutputPin.ParentNode != null) {  		// Tracking pin is from a UI Node  		startPoint = (_trackingConnectPin.OutputPin.ParentNode.UINode as DaggerUINode).PointToScreen ((_trackingConnectPin.OutputPin.PinUIElements as PinUI).PinLocation);  		startPoint.X += _trackingConnectPin.OutputPin.ParentNode.UINode.PinSize / 2;  		startPoint.Y += _trackingConnectPin.OutputPin.ParentNode.UINode.PinSize / 2;  	}  	else {  		// Tracking pin is an imported pin  		startPoint = (_trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph as DaggerUIGraph).PointToScreen ((_trackingConnectPin.OutputPin.PinUIElements as PinUI).PinLocation);  		startPoint.X += _trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.X;  		startPoint.Y += _trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.Y;  	}  }  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,UpdateTrackingNoodle,The following statement contains a magic number: if (_trackingConnectPin.OutputPin != null) {  	if (_trackingConnectPin.OutputPin.ParentNode != null) {  		// Tracking pin is from a UI Node  		startPoint = (_trackingConnectPin.OutputPin.ParentNode.UINode as DaggerUINode).PointToScreen ((_trackingConnectPin.OutputPin.PinUIElements as PinUI).PinLocation);  		startPoint.X += _trackingConnectPin.OutputPin.ParentNode.UINode.PinSize / 2;  		startPoint.Y += _trackingConnectPin.OutputPin.ParentNode.UINode.PinSize / 2;  	}  	else {  		// Tracking pin is an imported pin  		startPoint = (_trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph as DaggerUIGraph).PointToScreen ((_trackingConnectPin.OutputPin.PinUIElements as PinUI).PinLocation);  		startPoint.X += _trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.X;  		startPoint.Y += _trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.Y;  	}  }  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,UpdateTrackingNoodle,The following statement contains a magic number: if (_trackingConnectPin.OutputPin.ParentNode != null) {  	// Tracking pin is from a UI Node  	startPoint = (_trackingConnectPin.OutputPin.ParentNode.UINode as DaggerUINode).PointToScreen ((_trackingConnectPin.OutputPin.PinUIElements as PinUI).PinLocation);  	startPoint.X += _trackingConnectPin.OutputPin.ParentNode.UINode.PinSize / 2;  	startPoint.Y += _trackingConnectPin.OutputPin.ParentNode.UINode.PinSize / 2;  }  else {  	// Tracking pin is an imported pin  	startPoint = (_trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph as DaggerUIGraph).PointToScreen ((_trackingConnectPin.OutputPin.PinUIElements as PinUI).PinLocation);  	startPoint.X += _trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.X;  	startPoint.Y += _trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.Y;  }  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,UpdateTrackingNoodle,The following statement contains a magic number: if (_trackingConnectPin.OutputPin.ParentNode != null) {  	// Tracking pin is from a UI Node  	startPoint = (_trackingConnectPin.OutputPin.ParentNode.UINode as DaggerUINode).PointToScreen ((_trackingConnectPin.OutputPin.PinUIElements as PinUI).PinLocation);  	startPoint.X += _trackingConnectPin.OutputPin.ParentNode.UINode.PinSize / 2;  	startPoint.Y += _trackingConnectPin.OutputPin.ParentNode.UINode.PinSize / 2;  }  else {  	// Tracking pin is an imported pin  	startPoint = (_trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph as DaggerUIGraph).PointToScreen ((_trackingConnectPin.OutputPin.PinUIElements as PinUI).PinLocation);  	startPoint.X += _trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.X;  	startPoint.Y += _trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.Y;  }  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,UpdateTrackingNoodle,The following statement contains a magic number: if (_trackingConnectPin.OutputPin.ParentNode != null) {  	// Tracking pin is from a UI Node  	startPoint = (_trackingConnectPin.OutputPin.ParentNode.UINode as DaggerUINode).PointToScreen ((_trackingConnectPin.OutputPin.PinUIElements as PinUI).PinLocation);  	startPoint.X += _trackingConnectPin.OutputPin.ParentNode.UINode.PinSize / 2;  	startPoint.Y += _trackingConnectPin.OutputPin.ParentNode.UINode.PinSize / 2;  }  else {  	// Tracking pin is an imported pin  	startPoint = (_trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph as DaggerUIGraph).PointToScreen ((_trackingConnectPin.OutputPin.PinUIElements as PinUI).PinLocation);  	startPoint.X += _trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.X;  	startPoint.Y += _trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.Y;  }  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,UpdateTrackingNoodle,The following statement contains a magic number: if (_trackingConnectPin.OutputPin.ParentNode != null) {  	// Tracking pin is from a UI Node  	startPoint = (_trackingConnectPin.OutputPin.ParentNode.UINode as DaggerUINode).PointToScreen ((_trackingConnectPin.OutputPin.PinUIElements as PinUI).PinLocation);  	startPoint.X += _trackingConnectPin.OutputPin.ParentNode.UINode.PinSize / 2;  	startPoint.Y += _trackingConnectPin.OutputPin.ParentNode.UINode.PinSize / 2;  }  else {  	// Tracking pin is an imported pin  	startPoint = (_trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph as DaggerUIGraph).PointToScreen ((_trackingConnectPin.OutputPin.PinUIElements as PinUI).PinLocation);  	startPoint.X += _trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.X;  	startPoint.Y += _trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.Y;  }  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,UpdateTrackingNoodle,The following statement contains a magic number: startPoint.X += _trackingConnectPin.OutputPin.ParentNode.UINode.PinSize / 2;  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,UpdateTrackingNoodle,The following statement contains a magic number: startPoint.Y += _trackingConnectPin.OutputPin.ParentNode.UINode.PinSize / 2;  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,UpdateTrackingNoodle,The following statement contains a magic number: startPoint.X += _trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.X;  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,UpdateTrackingNoodle,The following statement contains a magic number: startPoint.Y += _trackingConnectPin.OutputPin.ParentGraph.ParentUIGraph.PinSize / 2 + AutoScrollPosition.Y;  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,ArrangeNodes,The following statement contains a magic number: for (int sgraph = 0; sgraph < _graph.SubGraphCount; sgraph++) {  	int maxPrcHeight = 0;  	int numOrdinals = _graph.OrdinalCount (sgraph);  	int ordOffset = 0;  	int[] precHeights = new int[numOrdinals];  	int[] precWidths = new int[numOrdinals];  	//find the width and height of each ordinal and the largest ordinal height  	for (int i = 0; i < numOrdinals; i++) {  		foreach (DaggerNode node in _graph [sgraph' i]) {  			if (node.UINode != null) {  				precHeights [i] += (node.UINode as DaggerUINode).AutoArrangeSize.Height + 10;  				precWidths [i] = Math.Max (precWidths [i]' (node.UINode as DaggerUINode).AutoArrangeSize.Width);  				maxPrcHeight = Math.Max (maxPrcHeight' precHeights [i]);  			}  		}  	}  	//go through each node and set it's new position  	for (int i = 0; i < numOrdinals; i++) {  		int ordTop = 0;  		List<DaggerNode> ordinalList = _graph [sgraph' i];  		//sort the ordinal list by thier vertical positions  		ordinalList.Sort (new NodePositionComparer ());  		foreach (DaggerNode node in ordinalList) {  			if (node.UINode != null) {  				Point loc = loc = new Point (ordOffset' node.UINode.Top);  				if (style == AutoArrangeStyle.All) {  					//Adjust for vertical positioning also  					loc.Y = subgraphoffset + ordTop;  					ordTop += node.UINode.Height + _autoArrangeHeightOffSet;  					// adjust for user defined offset  					loc.X += (node.UINode as DaggerUINode).AutoArrangeOffset.X;  					loc.Y += (node.UINode as DaggerUINode).AutoArrangeOffset.Y;  				}  				(node.UINode as DaggerUINode).Location = loc;  			}  		}  		ordOffset += precWidths [i] + _autoArrangeWidthOffset;  	}  	subgraphoffset += maxPrcHeight;  }  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,ArrangeNodes,The following statement contains a magic number: for (int i = 0; i < numOrdinals; i++) {  	foreach (DaggerNode node in _graph [sgraph' i]) {  		if (node.UINode != null) {  			precHeights [i] += (node.UINode as DaggerUINode).AutoArrangeSize.Height + 10;  			precWidths [i] = Math.Max (precWidths [i]' (node.UINode as DaggerUINode).AutoArrangeSize.Width);  			maxPrcHeight = Math.Max (maxPrcHeight' precHeights [i]);  		}  	}  }  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,ArrangeNodes,The following statement contains a magic number: foreach (DaggerNode node in _graph [sgraph' i]) {  	if (node.UINode != null) {  		precHeights [i] += (node.UINode as DaggerUINode).AutoArrangeSize.Height + 10;  		precWidths [i] = Math.Max (precWidths [i]' (node.UINode as DaggerUINode).AutoArrangeSize.Width);  		maxPrcHeight = Math.Max (maxPrcHeight' precHeights [i]);  	}  }  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,ArrangeNodes,The following statement contains a magic number: if (node.UINode != null) {  	precHeights [i] += (node.UINode as DaggerUINode).AutoArrangeSize.Height + 10;  	precWidths [i] = Math.Max (precWidths [i]' (node.UINode as DaggerUINode).AutoArrangeSize.Width);  	maxPrcHeight = Math.Max (maxPrcHeight' precHeights [i]);  }  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,ArrangeNodes,The following statement contains a magic number: precHeights [i] += (node.UINode as DaggerUINode).AutoArrangeSize.Height + 10;  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,CreateDropShadowImage,The following statement contains a magic number: blp.Width = 5;  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,CreateCanvasImage,The following statement contains a magic number: blp.Width = 5;  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,CreateCanvasImage,The following statement contains a magic number: wp.Width = 5;  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,CreateCanvasImage,The following statement contains a magic number: if (snodes.Count > 0) {  	GraphicsPath _selectedNodesPath = new GraphicsPath ();  	foreach (IDaggerUINode node in snodes) {  		Rectangle noderect = new Rectangle ((node as DaggerUINode).Left - AutoScrollPosition.X' (node as DaggerUINode).Top - AutoScrollPosition.Y' (node as DaggerUINode).Width' (node as DaggerUINode).Height);  		noderect.Inflate (new Size (2' 2));  		_selectedNodesPath.AddRectangle (noderect);  	}  	using (Pen selectpen = new Pen (Color.Black)) {  		selectpen.Width = 1;  		selectpen.DashStyle = DashStyle.Dash;  		using (Brush selectbrush = new SolidBrush (Color.FromArgb (100' ControlPaint.LightLight (BackColor)))) {  			g.FillPath (selectbrush' _selectedNodesPath);  			g.DrawPath (selectpen' _selectedNodesPath);  		}  	}  	_selectedNodesPath.Dispose ();  }  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,CreateCanvasImage,The following statement contains a magic number: if (snodes.Count > 0) {  	GraphicsPath _selectedNodesPath = new GraphicsPath ();  	foreach (IDaggerUINode node in snodes) {  		Rectangle noderect = new Rectangle ((node as DaggerUINode).Left - AutoScrollPosition.X' (node as DaggerUINode).Top - AutoScrollPosition.Y' (node as DaggerUINode).Width' (node as DaggerUINode).Height);  		noderect.Inflate (new Size (2' 2));  		_selectedNodesPath.AddRectangle (noderect);  	}  	using (Pen selectpen = new Pen (Color.Black)) {  		selectpen.Width = 1;  		selectpen.DashStyle = DashStyle.Dash;  		using (Brush selectbrush = new SolidBrush (Color.FromArgb (100' ControlPaint.LightLight (BackColor)))) {  			g.FillPath (selectbrush' _selectedNodesPath);  			g.DrawPath (selectpen' _selectedNodesPath);  		}  	}  	_selectedNodesPath.Dispose ();  }  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,CreateCanvasImage,The following statement contains a magic number: if (snodes.Count > 0) {  	GraphicsPath _selectedNodesPath = new GraphicsPath ();  	foreach (IDaggerUINode node in snodes) {  		Rectangle noderect = new Rectangle ((node as DaggerUINode).Left - AutoScrollPosition.X' (node as DaggerUINode).Top - AutoScrollPosition.Y' (node as DaggerUINode).Width' (node as DaggerUINode).Height);  		noderect.Inflate (new Size (2' 2));  		_selectedNodesPath.AddRectangle (noderect);  	}  	using (Pen selectpen = new Pen (Color.Black)) {  		selectpen.Width = 1;  		selectpen.DashStyle = DashStyle.Dash;  		using (Brush selectbrush = new SolidBrush (Color.FromArgb (100' ControlPaint.LightLight (BackColor)))) {  			g.FillPath (selectbrush' _selectedNodesPath);  			g.DrawPath (selectpen' _selectedNodesPath);  		}  	}  	_selectedNodesPath.Dispose ();  }  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,CreateCanvasImage,The following statement contains a magic number: foreach (IDaggerUINode node in snodes) {  	Rectangle noderect = new Rectangle ((node as DaggerUINode).Left - AutoScrollPosition.X' (node as DaggerUINode).Top - AutoScrollPosition.Y' (node as DaggerUINode).Width' (node as DaggerUINode).Height);  	noderect.Inflate (new Size (2' 2));  	_selectedNodesPath.AddRectangle (noderect);  }  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,CreateCanvasImage,The following statement contains a magic number: foreach (IDaggerUINode node in snodes) {  	Rectangle noderect = new Rectangle ((node as DaggerUINode).Left - AutoScrollPosition.X' (node as DaggerUINode).Top - AutoScrollPosition.Y' (node as DaggerUINode).Width' (node as DaggerUINode).Height);  	noderect.Inflate (new Size (2' 2));  	_selectedNodesPath.AddRectangle (noderect);  }  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,CreateCanvasImage,The following statement contains a magic number: noderect.Inflate (new Size (2' 2));  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,CreateCanvasImage,The following statement contains a magic number: noderect.Inflate (new Size (2' 2));  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,CreateCanvasImage,The following statement contains a magic number: using (Pen selectpen = new Pen (Color.Black)) {  	selectpen.Width = 1;  	selectpen.DashStyle = DashStyle.Dash;  	using (Brush selectbrush = new SolidBrush (Color.FromArgb (100' ControlPaint.LightLight (BackColor)))) {  		g.FillPath (selectbrush' _selectedNodesPath);  		g.DrawPath (selectpen' _selectedNodesPath);  	}  }  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,CreateCanvasImage,The following statement contains a magic number: using (Brush selectbrush = new SolidBrush (Color.FromArgb (100' ControlPaint.LightLight (BackColor)))) {  	g.FillPath (selectbrush' _selectedNodesPath);  	g.DrawPath (selectpen' _selectedNodesPath);  }  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,CreateCanvasImage,The following statement contains a magic number: if (_graph.ImportedPins.Count > 0 || _graph.ExportedPins.Count > 0) {  	Brush backB = new SolidBrush (Color.FromArgb (100' Color.Blue));  	Brush fontB = new SolidBrush (ForeColor);  	//draw imported pins  	if (_graph.ImportedPins.Count > 0) {  		g.FillRectangle (backB' 0' 0' _widestImportName + _pinSpacing' ActualCanvasSize.Height);  		foreach (DaggerOutputPin pin in _graph.ImportedPins) {  			if (pin.PinUIElements != null) {  				g.DrawString (pin.Name' Font' fontB' new RectangleF (0' (pin.PinUIElements as PinUI).PinLocation.Y' _widestImportName' 20));  				ImageAttributes att = new ImageAttributes ();  				Color alphakey = (pin.PinUIElements as PinUI).PinImageConnectedTransparent;  				att.SetColorKey (alphakey' alphakey);  				g.DrawImage ((pin.PinUIElements as PinUI).PinImageConnected' new Rectangle ((pin.PinUIElements as PinUI).PinLocation.X' (pin.PinUIElements as PinUI).PinLocation.Y' _pinLegend.PinSize' _pinLegend.PinSize)' 0' 0' _pinLegend.PinSize' _pinLegend.PinSize' GraphicsUnit.Pixel' att);  			}  		}  	}  	//draw exported pins  	if (_graph.ExportedPins.Count > 0) {  		g.FillRectangle (backB' CanvasSize.Width - _widestExportName - _pinSpacing' 0' _widestExportName' ActualCanvasSize.Height);  		foreach (DaggerInputPin pin in _graph.ExportedPins) {  			if (pin.PinUIElements != null) {  				g.DrawString (pin.Name' Font' fontB' new RectangleF (CanvasSize.Width - _widestExportName - _pinSpacing' (pin.PinUIElements as PinUI).PinLocation.Y' _widestExportName' 20));  				ImageAttributes att = new ImageAttributes ();  				Color alphakey = (pin.PinUIElements as PinUI).PinImageConnectedTransparent;  				att.SetColorKey (alphakey' alphakey);  				g.DrawImage ((pin.PinUIElements as PinUI).PinImageConnected' new Rectangle ((pin.PinUIElements as PinUI).PinLocation.X' (pin.PinUIElements as PinUI).PinLocation.Y' _pinLegend.PinSize' _pinLegend.PinSize)' 0' 0' _pinLegend.PinSize' _pinLegend.PinSize' GraphicsUnit.Pixel' att);  			}  		}  	}  	backB.Dispose ();  }  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,CreateCanvasImage,The following statement contains a magic number: if (_graph.ImportedPins.Count > 0 || _graph.ExportedPins.Count > 0) {  	Brush backB = new SolidBrush (Color.FromArgb (100' Color.Blue));  	Brush fontB = new SolidBrush (ForeColor);  	//draw imported pins  	if (_graph.ImportedPins.Count > 0) {  		g.FillRectangle (backB' 0' 0' _widestImportName + _pinSpacing' ActualCanvasSize.Height);  		foreach (DaggerOutputPin pin in _graph.ImportedPins) {  			if (pin.PinUIElements != null) {  				g.DrawString (pin.Name' Font' fontB' new RectangleF (0' (pin.PinUIElements as PinUI).PinLocation.Y' _widestImportName' 20));  				ImageAttributes att = new ImageAttributes ();  				Color alphakey = (pin.PinUIElements as PinUI).PinImageConnectedTransparent;  				att.SetColorKey (alphakey' alphakey);  				g.DrawImage ((pin.PinUIElements as PinUI).PinImageConnected' new Rectangle ((pin.PinUIElements as PinUI).PinLocation.X' (pin.PinUIElements as PinUI).PinLocation.Y' _pinLegend.PinSize' _pinLegend.PinSize)' 0' 0' _pinLegend.PinSize' _pinLegend.PinSize' GraphicsUnit.Pixel' att);  			}  		}  	}  	//draw exported pins  	if (_graph.ExportedPins.Count > 0) {  		g.FillRectangle (backB' CanvasSize.Width - _widestExportName - _pinSpacing' 0' _widestExportName' ActualCanvasSize.Height);  		foreach (DaggerInputPin pin in _graph.ExportedPins) {  			if (pin.PinUIElements != null) {  				g.DrawString (pin.Name' Font' fontB' new RectangleF (CanvasSize.Width - _widestExportName - _pinSpacing' (pin.PinUIElements as PinUI).PinLocation.Y' _widestExportName' 20));  				ImageAttributes att = new ImageAttributes ();  				Color alphakey = (pin.PinUIElements as PinUI).PinImageConnectedTransparent;  				att.SetColorKey (alphakey' alphakey);  				g.DrawImage ((pin.PinUIElements as PinUI).PinImageConnected' new Rectangle ((pin.PinUIElements as PinUI).PinLocation.X' (pin.PinUIElements as PinUI).PinLocation.Y' _pinLegend.PinSize' _pinLegend.PinSize)' 0' 0' _pinLegend.PinSize' _pinLegend.PinSize' GraphicsUnit.Pixel' att);  			}  		}  	}  	backB.Dispose ();  }  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,CreateCanvasImage,The following statement contains a magic number: if (_graph.ImportedPins.Count > 0 || _graph.ExportedPins.Count > 0) {  	Brush backB = new SolidBrush (Color.FromArgb (100' Color.Blue));  	Brush fontB = new SolidBrush (ForeColor);  	//draw imported pins  	if (_graph.ImportedPins.Count > 0) {  		g.FillRectangle (backB' 0' 0' _widestImportName + _pinSpacing' ActualCanvasSize.Height);  		foreach (DaggerOutputPin pin in _graph.ImportedPins) {  			if (pin.PinUIElements != null) {  				g.DrawString (pin.Name' Font' fontB' new RectangleF (0' (pin.PinUIElements as PinUI).PinLocation.Y' _widestImportName' 20));  				ImageAttributes att = new ImageAttributes ();  				Color alphakey = (pin.PinUIElements as PinUI).PinImageConnectedTransparent;  				att.SetColorKey (alphakey' alphakey);  				g.DrawImage ((pin.PinUIElements as PinUI).PinImageConnected' new Rectangle ((pin.PinUIElements as PinUI).PinLocation.X' (pin.PinUIElements as PinUI).PinLocation.Y' _pinLegend.PinSize' _pinLegend.PinSize)' 0' 0' _pinLegend.PinSize' _pinLegend.PinSize' GraphicsUnit.Pixel' att);  			}  		}  	}  	//draw exported pins  	if (_graph.ExportedPins.Count > 0) {  		g.FillRectangle (backB' CanvasSize.Width - _widestExportName - _pinSpacing' 0' _widestExportName' ActualCanvasSize.Height);  		foreach (DaggerInputPin pin in _graph.ExportedPins) {  			if (pin.PinUIElements != null) {  				g.DrawString (pin.Name' Font' fontB' new RectangleF (CanvasSize.Width - _widestExportName - _pinSpacing' (pin.PinUIElements as PinUI).PinLocation.Y' _widestExportName' 20));  				ImageAttributes att = new ImageAttributes ();  				Color alphakey = (pin.PinUIElements as PinUI).PinImageConnectedTransparent;  				att.SetColorKey (alphakey' alphakey);  				g.DrawImage ((pin.PinUIElements as PinUI).PinImageConnected' new Rectangle ((pin.PinUIElements as PinUI).PinLocation.X' (pin.PinUIElements as PinUI).PinLocation.Y' _pinLegend.PinSize' _pinLegend.PinSize)' 0' 0' _pinLegend.PinSize' _pinLegend.PinSize' GraphicsUnit.Pixel' att);  			}  		}  	}  	backB.Dispose ();  }  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,CreateCanvasImage,The following statement contains a magic number: if (_graph.ImportedPins.Count > 0) {  	g.FillRectangle (backB' 0' 0' _widestImportName + _pinSpacing' ActualCanvasSize.Height);  	foreach (DaggerOutputPin pin in _graph.ImportedPins) {  		if (pin.PinUIElements != null) {  			g.DrawString (pin.Name' Font' fontB' new RectangleF (0' (pin.PinUIElements as PinUI).PinLocation.Y' _widestImportName' 20));  			ImageAttributes att = new ImageAttributes ();  			Color alphakey = (pin.PinUIElements as PinUI).PinImageConnectedTransparent;  			att.SetColorKey (alphakey' alphakey);  			g.DrawImage ((pin.PinUIElements as PinUI).PinImageConnected' new Rectangle ((pin.PinUIElements as PinUI).PinLocation.X' (pin.PinUIElements as PinUI).PinLocation.Y' _pinLegend.PinSize' _pinLegend.PinSize)' 0' 0' _pinLegend.PinSize' _pinLegend.PinSize' GraphicsUnit.Pixel' att);  		}  	}  }  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,CreateCanvasImage,The following statement contains a magic number: foreach (DaggerOutputPin pin in _graph.ImportedPins) {  	if (pin.PinUIElements != null) {  		g.DrawString (pin.Name' Font' fontB' new RectangleF (0' (pin.PinUIElements as PinUI).PinLocation.Y' _widestImportName' 20));  		ImageAttributes att = new ImageAttributes ();  		Color alphakey = (pin.PinUIElements as PinUI).PinImageConnectedTransparent;  		att.SetColorKey (alphakey' alphakey);  		g.DrawImage ((pin.PinUIElements as PinUI).PinImageConnected' new Rectangle ((pin.PinUIElements as PinUI).PinLocation.X' (pin.PinUIElements as PinUI).PinLocation.Y' _pinLegend.PinSize' _pinLegend.PinSize)' 0' 0' _pinLegend.PinSize' _pinLegend.PinSize' GraphicsUnit.Pixel' att);  	}  }  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,CreateCanvasImage,The following statement contains a magic number: if (pin.PinUIElements != null) {  	g.DrawString (pin.Name' Font' fontB' new RectangleF (0' (pin.PinUIElements as PinUI).PinLocation.Y' _widestImportName' 20));  	ImageAttributes att = new ImageAttributes ();  	Color alphakey = (pin.PinUIElements as PinUI).PinImageConnectedTransparent;  	att.SetColorKey (alphakey' alphakey);  	g.DrawImage ((pin.PinUIElements as PinUI).PinImageConnected' new Rectangle ((pin.PinUIElements as PinUI).PinLocation.X' (pin.PinUIElements as PinUI).PinLocation.Y' _pinLegend.PinSize' _pinLegend.PinSize)' 0' 0' _pinLegend.PinSize' _pinLegend.PinSize' GraphicsUnit.Pixel' att);  }  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,CreateCanvasImage,The following statement contains a magic number: g.DrawString (pin.Name' Font' fontB' new RectangleF (0' (pin.PinUIElements as PinUI).PinLocation.Y' _widestImportName' 20));  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,CreateCanvasImage,The following statement contains a magic number: if (_graph.ExportedPins.Count > 0) {  	g.FillRectangle (backB' CanvasSize.Width - _widestExportName - _pinSpacing' 0' _widestExportName' ActualCanvasSize.Height);  	foreach (DaggerInputPin pin in _graph.ExportedPins) {  		if (pin.PinUIElements != null) {  			g.DrawString (pin.Name' Font' fontB' new RectangleF (CanvasSize.Width - _widestExportName - _pinSpacing' (pin.PinUIElements as PinUI).PinLocation.Y' _widestExportName' 20));  			ImageAttributes att = new ImageAttributes ();  			Color alphakey = (pin.PinUIElements as PinUI).PinImageConnectedTransparent;  			att.SetColorKey (alphakey' alphakey);  			g.DrawImage ((pin.PinUIElements as PinUI).PinImageConnected' new Rectangle ((pin.PinUIElements as PinUI).PinLocation.X' (pin.PinUIElements as PinUI).PinLocation.Y' _pinLegend.PinSize' _pinLegend.PinSize)' 0' 0' _pinLegend.PinSize' _pinLegend.PinSize' GraphicsUnit.Pixel' att);  		}  	}  }  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,CreateCanvasImage,The following statement contains a magic number: foreach (DaggerInputPin pin in _graph.ExportedPins) {  	if (pin.PinUIElements != null) {  		g.DrawString (pin.Name' Font' fontB' new RectangleF (CanvasSize.Width - _widestExportName - _pinSpacing' (pin.PinUIElements as PinUI).PinLocation.Y' _widestExportName' 20));  		ImageAttributes att = new ImageAttributes ();  		Color alphakey = (pin.PinUIElements as PinUI).PinImageConnectedTransparent;  		att.SetColorKey (alphakey' alphakey);  		g.DrawImage ((pin.PinUIElements as PinUI).PinImageConnected' new Rectangle ((pin.PinUIElements as PinUI).PinLocation.X' (pin.PinUIElements as PinUI).PinLocation.Y' _pinLegend.PinSize' _pinLegend.PinSize)' 0' 0' _pinLegend.PinSize' _pinLegend.PinSize' GraphicsUnit.Pixel' att);  	}  }  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,CreateCanvasImage,The following statement contains a magic number: if (pin.PinUIElements != null) {  	g.DrawString (pin.Name' Font' fontB' new RectangleF (CanvasSize.Width - _widestExportName - _pinSpacing' (pin.PinUIElements as PinUI).PinLocation.Y' _widestExportName' 20));  	ImageAttributes att = new ImageAttributes ();  	Color alphakey = (pin.PinUIElements as PinUI).PinImageConnectedTransparent;  	att.SetColorKey (alphakey' alphakey);  	g.DrawImage ((pin.PinUIElements as PinUI).PinImageConnected' new Rectangle ((pin.PinUIElements as PinUI).PinLocation.X' (pin.PinUIElements as PinUI).PinLocation.Y' _pinLegend.PinSize' _pinLegend.PinSize)' 0' 0' _pinLegend.PinSize' _pinLegend.PinSize' GraphicsUnit.Pixel' att);  }  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,CreateCanvasImage,The following statement contains a magic number: g.DrawString (pin.Name' Font' fontB' new RectangleF (CanvasSize.Width - _widestExportName - _pinSpacing' (pin.PinUIElements as PinUI).PinLocation.Y' _widestExportName' 20));  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,OnPaint,The following statement contains a magic number: if (_trackingConnectPin != null) {  	Pen bp = new Pen (Color.Black);  	bp.Width = 5;  	bp.StartCap = LineCap.Round;  	bp.EndCap = LineCap.Round;  	Pen np = new Pen ((_trackingConnectPin.OutputPin != null) ? (_trackingConnectPin.OutputPin.PinUIElements as PinUI).NoodleColor : (_trackingConnectPin.InputPin.PinUIElements as PinUI).NoodleColor);  	np.DashStyle = DashStyle.Dash;  	np.Width = 3;  	np.StartCap = LineCap.Round;  	np.EndCap = LineCap.Round;  	e.Graphics.DrawPath (bp' _trackingConnectPin.Path);  	e.Graphics.DrawPath (np' _trackingConnectPin.Path);  	bp.Dispose ();  	np.Dispose ();  }  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,OnPaint,The following statement contains a magic number: if (_trackingConnectPin != null) {  	Pen bp = new Pen (Color.Black);  	bp.Width = 5;  	bp.StartCap = LineCap.Round;  	bp.EndCap = LineCap.Round;  	Pen np = new Pen ((_trackingConnectPin.OutputPin != null) ? (_trackingConnectPin.OutputPin.PinUIElements as PinUI).NoodleColor : (_trackingConnectPin.InputPin.PinUIElements as PinUI).NoodleColor);  	np.DashStyle = DashStyle.Dash;  	np.Width = 3;  	np.StartCap = LineCap.Round;  	np.EndCap = LineCap.Round;  	e.Graphics.DrawPath (bp' _trackingConnectPin.Path);  	e.Graphics.DrawPath (np' _trackingConnectPin.Path);  	bp.Dispose ();  	np.Dispose ();  }  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,OnPaint,The following statement contains a magic number: bp.Width = 5;  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,OnPaint,The following statement contains a magic number: np.Width = 3;  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,OnDragDrop,The following statement contains a magic number: if (snode != null) {  	// record the node that was dropped and add it to the graph  	_droppedNode = snode;  	Graph.AddNode (snode);  	_droppedNode = null;  	DaggerUINode uinode = (DaggerUINode)Controls [Controls.Count - 1];  	if (_noodleBisector == null) {  		// find that node and move it to the DragDrop coords  		uinode.Location = PointToClient (new Point (drgevent.X' drgevent.Y));  		uinode.Visible = true;  	}  	else {  		// we bisected' so center the node on the drop position  		uinode.Location = PointToClient (new Point (drgevent.X - (uinode.Width / 2)' drgevent.Y - (uinode.Height / 2)));  		// perform the bisection  		BisectNoodle (snode' _noodleBisector.Noodle);  		_noodleBisector = null;  		RefreshGraph ();  	}  	// mark the node visible  	uinode.Visible = true;  }  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,OnDragDrop,The following statement contains a magic number: if (snode != null) {  	// record the node that was dropped and add it to the graph  	_droppedNode = snode;  	Graph.AddNode (snode);  	_droppedNode = null;  	DaggerUINode uinode = (DaggerUINode)Controls [Controls.Count - 1];  	if (_noodleBisector == null) {  		// find that node and move it to the DragDrop coords  		uinode.Location = PointToClient (new Point (drgevent.X' drgevent.Y));  		uinode.Visible = true;  	}  	else {  		// we bisected' so center the node on the drop position  		uinode.Location = PointToClient (new Point (drgevent.X - (uinode.Width / 2)' drgevent.Y - (uinode.Height / 2)));  		// perform the bisection  		BisectNoodle (snode' _noodleBisector.Noodle);  		_noodleBisector = null;  		RefreshGraph ();  	}  	// mark the node visible  	uinode.Visible = true;  }  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,OnDragDrop,The following statement contains a magic number: if (_noodleBisector == null) {  	// find that node and move it to the DragDrop coords  	uinode.Location = PointToClient (new Point (drgevent.X' drgevent.Y));  	uinode.Visible = true;  }  else {  	// we bisected' so center the node on the drop position  	uinode.Location = PointToClient (new Point (drgevent.X - (uinode.Width / 2)' drgevent.Y - (uinode.Height / 2)));  	// perform the bisection  	BisectNoodle (snode' _noodleBisector.Noodle);  	_noodleBisector = null;  	RefreshGraph ();  }  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,OnDragDrop,The following statement contains a magic number: if (_noodleBisector == null) {  	// find that node and move it to the DragDrop coords  	uinode.Location = PointToClient (new Point (drgevent.X' drgevent.Y));  	uinode.Visible = true;  }  else {  	// we bisected' so center the node on the drop position  	uinode.Location = PointToClient (new Point (drgevent.X - (uinode.Width / 2)' drgevent.Y - (uinode.Height / 2)));  	// perform the bisection  	BisectNoodle (snode' _noodleBisector.Noodle);  	_noodleBisector = null;  	RefreshGraph ();  }  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,OnDragDrop,The following statement contains a magic number: uinode.Location = PointToClient (new Point (drgevent.X - (uinode.Width / 2)' drgevent.Y - (uinode.Height / 2)));  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,OnDragDrop,The following statement contains a magic number: uinode.Location = PointToClient (new Point (drgevent.X - (uinode.Width / 2)' drgevent.Y - (uinode.Height / 2)));  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,WndProc,The following statement contains a magic number: if (m.Msg == 0x114 || m.Msg == 0x115) {  	if ((int)m.WParam == 2 || (int)m.WParam == 3) {  		// page up/down/left/right  		_noodles.BeginUpdate ();  		_isScrolling = true;  		base.WndProc (ref m);  	}  	else if ((int)m.WParam == 8) {  		// end scroll  		_noodles.EndUpdate ();  		_isScrolling = false;  		base.WndProc (ref m);  	}  	else {  		// dragging the scroll thumb  		_isScrolling = true;  		_noodles.BeginUpdate ();  		base.WndProc (ref m);  		_noodles.EndUpdate ();  		_isScrolling = false;  	}  	if (ViewportChanged != null) {  		ViewportChanged (this' new EventArgs ());  	}  }  else if (m.Msg == 0x7d)// WM_STYLECHANGED   {  	// Scroll bars are being shown/hidden  	BeginCanvasUpdate ();  	_noodles.BeginUpdate ();  	base.WndProc (ref m);  	_noodles.EndUpdate ();  	EndCanvasUpdate ();  }  else {  	base.WndProc (ref m);  }  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,WndProc,The following statement contains a magic number: if (m.Msg == 0x114 || m.Msg == 0x115) {  	if ((int)m.WParam == 2 || (int)m.WParam == 3) {  		// page up/down/left/right  		_noodles.BeginUpdate ();  		_isScrolling = true;  		base.WndProc (ref m);  	}  	else if ((int)m.WParam == 8) {  		// end scroll  		_noodles.EndUpdate ();  		_isScrolling = false;  		base.WndProc (ref m);  	}  	else {  		// dragging the scroll thumb  		_isScrolling = true;  		_noodles.BeginUpdate ();  		base.WndProc (ref m);  		_noodles.EndUpdate ();  		_isScrolling = false;  	}  	if (ViewportChanged != null) {  		ViewportChanged (this' new EventArgs ());  	}  }  else if (m.Msg == 0x7d)// WM_STYLECHANGED   {  	// Scroll bars are being shown/hidden  	BeginCanvasUpdate ();  	_noodles.BeginUpdate ();  	base.WndProc (ref m);  	_noodles.EndUpdate ();  	EndCanvasUpdate ();  }  else {  	base.WndProc (ref m);  }  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,WndProc,The following statement contains a magic number: if (m.Msg == 0x114 || m.Msg == 0x115) {  	if ((int)m.WParam == 2 || (int)m.WParam == 3) {  		// page up/down/left/right  		_noodles.BeginUpdate ();  		_isScrolling = true;  		base.WndProc (ref m);  	}  	else if ((int)m.WParam == 8) {  		// end scroll  		_noodles.EndUpdate ();  		_isScrolling = false;  		base.WndProc (ref m);  	}  	else {  		// dragging the scroll thumb  		_isScrolling = true;  		_noodles.BeginUpdate ();  		base.WndProc (ref m);  		_noodles.EndUpdate ();  		_isScrolling = false;  	}  	if (ViewportChanged != null) {  		ViewportChanged (this' new EventArgs ());  	}  }  else if (m.Msg == 0x7d)// WM_STYLECHANGED   {  	// Scroll bars are being shown/hidden  	BeginCanvasUpdate ();  	_noodles.BeginUpdate ();  	base.WndProc (ref m);  	_noodles.EndUpdate ();  	EndCanvasUpdate ();  }  else {  	base.WndProc (ref m);  }  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,WndProc,The following statement contains a magic number: if ((int)m.WParam == 2 || (int)m.WParam == 3) {  	// page up/down/left/right  	_noodles.BeginUpdate ();  	_isScrolling = true;  	base.WndProc (ref m);  }  else if ((int)m.WParam == 8) {  	// end scroll  	_noodles.EndUpdate ();  	_isScrolling = false;  	base.WndProc (ref m);  }  else {  	// dragging the scroll thumb  	_isScrolling = true;  	_noodles.BeginUpdate ();  	base.WndProc (ref m);  	_noodles.EndUpdate ();  	_isScrolling = false;  }  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,WndProc,The following statement contains a magic number: if ((int)m.WParam == 2 || (int)m.WParam == 3) {  	// page up/down/left/right  	_noodles.BeginUpdate ();  	_isScrolling = true;  	base.WndProc (ref m);  }  else if ((int)m.WParam == 8) {  	// end scroll  	_noodles.EndUpdate ();  	_isScrolling = false;  	base.WndProc (ref m);  }  else {  	// dragging the scroll thumb  	_isScrolling = true;  	_noodles.BeginUpdate ();  	base.WndProc (ref m);  	_noodles.EndUpdate ();  	_isScrolling = false;  }  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,WndProc,The following statement contains a magic number: if ((int)m.WParam == 2 || (int)m.WParam == 3) {  	// page up/down/left/right  	_noodles.BeginUpdate ();  	_isScrolling = true;  	base.WndProc (ref m);  }  else if ((int)m.WParam == 8) {  	// end scroll  	_noodles.EndUpdate ();  	_isScrolling = false;  	base.WndProc (ref m);  }  else {  	// dragging the scroll thumb  	_isScrolling = true;  	_noodles.BeginUpdate ();  	base.WndProc (ref m);  	_noodles.EndUpdate ();  	_isScrolling = false;  }  
Magic Number,DaggerLib.UI.Windows,DaggerUIGraph,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,WndProc,The following statement contains a magic number: if ((int)m.WParam == 8) {  	// end scroll  	_noodles.EndUpdate ();  	_isScrolling = false;  	base.WndProc (ref m);  }  else {  	// dragging the scroll thumb  	_isScrolling = true;  	_noodles.BeginUpdate ();  	base.WndProc (ref m);  	_noodles.EndUpdate ();  	_isScrolling = false;  }  
Magic Number,DaggerLib.UI.Windows,DraggingNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,DraggingNoodle,The following statement contains a magic number: StartPoint.X += InputPin.ParentNode.UINode.PinSize / 2;  
Magic Number,DaggerLib.UI.Windows,DraggingNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,DraggingNoodle,The following statement contains a magic number: StartPoint.Y += InputPin.ParentNode.UINode.PinSize / 2;  
Magic Number,DaggerLib.UI.Windows,DraggingNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,DraggingNoodle,The following statement contains a magic number: _trackPoint.X += OutputPin.ParentNode.UINode.PinSize / 2;  
Magic Number,DaggerLib.UI.Windows,DraggingNoodle,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIGraph.cs,DraggingNoodle,The following statement contains a magic number: _trackPoint.Y += OutputPin.ParentNode.UINode.PinSize / 2;  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,DaggerUINode,The following statement contains a magic number: _wndToolTip.AutomaticDelay = 500;  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,DaggerUINode,The following statement contains a magic number: _wndToolTip.ReshowDelay = 100;  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,InitializeComponent,The following statement contains a magic number: this._internalControl.Size = new System.Drawing.Size (611' 418);  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,InitializeComponent,The following statement contains a magic number: this._internalControl.Size = new System.Drawing.Size (611' 418);  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,InitializeComponent,The following statement contains a magic number: this.Size = new System.Drawing.Size (103' 72);  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,InitializeComponent,The following statement contains a magic number: this.Size = new System.Drawing.Size (103' 72);  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,m_wndToolTip_Popup,The following statement contains a magic number: using (Font f = new Font ("Tahoma"' 9)) {  	if (_mouseOverPin != null) {  		//if the user has defined PinToolTipPopup' call that instead  		if ((_mouseOverPin.PinUIElements as PinUI).UserDefinedToolTipPopup) {  			(_mouseOverPin.PinUIElements as PinUI).InvokeToolTipPopup (_mouseOverPin' e);  		}  		else {  			//measure the strings for pin name and pin data type  			Size tts = TextRenderer.MeasureText (_mouseOverPin.Name' f);  			Size typeSize = new Size ();  			switch ((_mouseOverPin.PinUIElements as PinUI).PinToolTipStyle) {  			case PinToolTipStyle.Name:  				break;  			case PinToolTipStyle.NameShortType:  				typeSize = TextRenderer.MeasureText (_mouseOverPin.DataType.Name' f);  				tts.Width = Math.Max (tts.Width' typeSize.Width);  				tts.Height = tts.Height * 2 + 5;  				break;  			case PinToolTipStyle.NameLongType:  				typeSize = TextRenderer.MeasureText (_mouseOverPin.DataType.FullName' f);  				tts.Width = Math.Max (tts.Width' typeSize.Width);  				tts.Height = tts.Height * 2 + 5;  				break;  			default:  				break;  			}  			e.ToolTipSize = tts;  		}  	}  	else if (_tooltiptext != "") {  		e.ToolTipSize = TextRenderer.MeasureText (_tooltiptext + (_parentGraph.ShowOrdinal ? ": Ordinal " + _node.Ordinal.ToString () : "")' f);  	}  	else {  		e.ToolTipSize = TextRenderer.MeasureText (_captionText + (_parentGraph.ShowOrdinal ? ": Ordinal " + _node.Ordinal.ToString () : "")' f);  	}  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,m_wndToolTip_Popup,The following statement contains a magic number: using (Font f = new Font ("Tahoma"' 9)) {  	if (_mouseOverPin != null) {  		//if the user has defined PinToolTipPopup' call that instead  		if ((_mouseOverPin.PinUIElements as PinUI).UserDefinedToolTipPopup) {  			(_mouseOverPin.PinUIElements as PinUI).InvokeToolTipPopup (_mouseOverPin' e);  		}  		else {  			//measure the strings for pin name and pin data type  			Size tts = TextRenderer.MeasureText (_mouseOverPin.Name' f);  			Size typeSize = new Size ();  			switch ((_mouseOverPin.PinUIElements as PinUI).PinToolTipStyle) {  			case PinToolTipStyle.Name:  				break;  			case PinToolTipStyle.NameShortType:  				typeSize = TextRenderer.MeasureText (_mouseOverPin.DataType.Name' f);  				tts.Width = Math.Max (tts.Width' typeSize.Width);  				tts.Height = tts.Height * 2 + 5;  				break;  			case PinToolTipStyle.NameLongType:  				typeSize = TextRenderer.MeasureText (_mouseOverPin.DataType.FullName' f);  				tts.Width = Math.Max (tts.Width' typeSize.Width);  				tts.Height = tts.Height * 2 + 5;  				break;  			default:  				break;  			}  			e.ToolTipSize = tts;  		}  	}  	else if (_tooltiptext != "") {  		e.ToolTipSize = TextRenderer.MeasureText (_tooltiptext + (_parentGraph.ShowOrdinal ? ": Ordinal " + _node.Ordinal.ToString () : "")' f);  	}  	else {  		e.ToolTipSize = TextRenderer.MeasureText (_captionText + (_parentGraph.ShowOrdinal ? ": Ordinal " + _node.Ordinal.ToString () : "")' f);  	}  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,m_wndToolTip_Popup,The following statement contains a magic number: using (Font f = new Font ("Tahoma"' 9)) {  	if (_mouseOverPin != null) {  		//if the user has defined PinToolTipPopup' call that instead  		if ((_mouseOverPin.PinUIElements as PinUI).UserDefinedToolTipPopup) {  			(_mouseOverPin.PinUIElements as PinUI).InvokeToolTipPopup (_mouseOverPin' e);  		}  		else {  			//measure the strings for pin name and pin data type  			Size tts = TextRenderer.MeasureText (_mouseOverPin.Name' f);  			Size typeSize = new Size ();  			switch ((_mouseOverPin.PinUIElements as PinUI).PinToolTipStyle) {  			case PinToolTipStyle.Name:  				break;  			case PinToolTipStyle.NameShortType:  				typeSize = TextRenderer.MeasureText (_mouseOverPin.DataType.Name' f);  				tts.Width = Math.Max (tts.Width' typeSize.Width);  				tts.Height = tts.Height * 2 + 5;  				break;  			case PinToolTipStyle.NameLongType:  				typeSize = TextRenderer.MeasureText (_mouseOverPin.DataType.FullName' f);  				tts.Width = Math.Max (tts.Width' typeSize.Width);  				tts.Height = tts.Height * 2 + 5;  				break;  			default:  				break;  			}  			e.ToolTipSize = tts;  		}  	}  	else if (_tooltiptext != "") {  		e.ToolTipSize = TextRenderer.MeasureText (_tooltiptext + (_parentGraph.ShowOrdinal ? ": Ordinal " + _node.Ordinal.ToString () : "")' f);  	}  	else {  		e.ToolTipSize = TextRenderer.MeasureText (_captionText + (_parentGraph.ShowOrdinal ? ": Ordinal " + _node.Ordinal.ToString () : "")' f);  	}  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,m_wndToolTip_Popup,The following statement contains a magic number: using (Font f = new Font ("Tahoma"' 9)) {  	if (_mouseOverPin != null) {  		//if the user has defined PinToolTipPopup' call that instead  		if ((_mouseOverPin.PinUIElements as PinUI).UserDefinedToolTipPopup) {  			(_mouseOverPin.PinUIElements as PinUI).InvokeToolTipPopup (_mouseOverPin' e);  		}  		else {  			//measure the strings for pin name and pin data type  			Size tts = TextRenderer.MeasureText (_mouseOverPin.Name' f);  			Size typeSize = new Size ();  			switch ((_mouseOverPin.PinUIElements as PinUI).PinToolTipStyle) {  			case PinToolTipStyle.Name:  				break;  			case PinToolTipStyle.NameShortType:  				typeSize = TextRenderer.MeasureText (_mouseOverPin.DataType.Name' f);  				tts.Width = Math.Max (tts.Width' typeSize.Width);  				tts.Height = tts.Height * 2 + 5;  				break;  			case PinToolTipStyle.NameLongType:  				typeSize = TextRenderer.MeasureText (_mouseOverPin.DataType.FullName' f);  				tts.Width = Math.Max (tts.Width' typeSize.Width);  				tts.Height = tts.Height * 2 + 5;  				break;  			default:  				break;  			}  			e.ToolTipSize = tts;  		}  	}  	else if (_tooltiptext != "") {  		e.ToolTipSize = TextRenderer.MeasureText (_tooltiptext + (_parentGraph.ShowOrdinal ? ": Ordinal " + _node.Ordinal.ToString () : "")' f);  	}  	else {  		e.ToolTipSize = TextRenderer.MeasureText (_captionText + (_parentGraph.ShowOrdinal ? ": Ordinal " + _node.Ordinal.ToString () : "")' f);  	}  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,m_wndToolTip_Popup,The following statement contains a magic number: using (Font f = new Font ("Tahoma"' 9)) {  	if (_mouseOverPin != null) {  		//if the user has defined PinToolTipPopup' call that instead  		if ((_mouseOverPin.PinUIElements as PinUI).UserDefinedToolTipPopup) {  			(_mouseOverPin.PinUIElements as PinUI).InvokeToolTipPopup (_mouseOverPin' e);  		}  		else {  			//measure the strings for pin name and pin data type  			Size tts = TextRenderer.MeasureText (_mouseOverPin.Name' f);  			Size typeSize = new Size ();  			switch ((_mouseOverPin.PinUIElements as PinUI).PinToolTipStyle) {  			case PinToolTipStyle.Name:  				break;  			case PinToolTipStyle.NameShortType:  				typeSize = TextRenderer.MeasureText (_mouseOverPin.DataType.Name' f);  				tts.Width = Math.Max (tts.Width' typeSize.Width);  				tts.Height = tts.Height * 2 + 5;  				break;  			case PinToolTipStyle.NameLongType:  				typeSize = TextRenderer.MeasureText (_mouseOverPin.DataType.FullName' f);  				tts.Width = Math.Max (tts.Width' typeSize.Width);  				tts.Height = tts.Height * 2 + 5;  				break;  			default:  				break;  			}  			e.ToolTipSize = tts;  		}  	}  	else if (_tooltiptext != "") {  		e.ToolTipSize = TextRenderer.MeasureText (_tooltiptext + (_parentGraph.ShowOrdinal ? ": Ordinal " + _node.Ordinal.ToString () : "")' f);  	}  	else {  		e.ToolTipSize = TextRenderer.MeasureText (_captionText + (_parentGraph.ShowOrdinal ? ": Ordinal " + _node.Ordinal.ToString () : "")' f);  	}  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,m_wndToolTip_Popup,The following statement contains a magic number: if (_mouseOverPin != null) {  	//if the user has defined PinToolTipPopup' call that instead  	if ((_mouseOverPin.PinUIElements as PinUI).UserDefinedToolTipPopup) {  		(_mouseOverPin.PinUIElements as PinUI).InvokeToolTipPopup (_mouseOverPin' e);  	}  	else {  		//measure the strings for pin name and pin data type  		Size tts = TextRenderer.MeasureText (_mouseOverPin.Name' f);  		Size typeSize = new Size ();  		switch ((_mouseOverPin.PinUIElements as PinUI).PinToolTipStyle) {  		case PinToolTipStyle.Name:  			break;  		case PinToolTipStyle.NameShortType:  			typeSize = TextRenderer.MeasureText (_mouseOverPin.DataType.Name' f);  			tts.Width = Math.Max (tts.Width' typeSize.Width);  			tts.Height = tts.Height * 2 + 5;  			break;  		case PinToolTipStyle.NameLongType:  			typeSize = TextRenderer.MeasureText (_mouseOverPin.DataType.FullName' f);  			tts.Width = Math.Max (tts.Width' typeSize.Width);  			tts.Height = tts.Height * 2 + 5;  			break;  		default:  			break;  		}  		e.ToolTipSize = tts;  	}  }  else if (_tooltiptext != "") {  	e.ToolTipSize = TextRenderer.MeasureText (_tooltiptext + (_parentGraph.ShowOrdinal ? ": Ordinal " + _node.Ordinal.ToString () : "")' f);  }  else {  	e.ToolTipSize = TextRenderer.MeasureText (_captionText + (_parentGraph.ShowOrdinal ? ": Ordinal " + _node.Ordinal.ToString () : "")' f);  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,m_wndToolTip_Popup,The following statement contains a magic number: if (_mouseOverPin != null) {  	//if the user has defined PinToolTipPopup' call that instead  	if ((_mouseOverPin.PinUIElements as PinUI).UserDefinedToolTipPopup) {  		(_mouseOverPin.PinUIElements as PinUI).InvokeToolTipPopup (_mouseOverPin' e);  	}  	else {  		//measure the strings for pin name and pin data type  		Size tts = TextRenderer.MeasureText (_mouseOverPin.Name' f);  		Size typeSize = new Size ();  		switch ((_mouseOverPin.PinUIElements as PinUI).PinToolTipStyle) {  		case PinToolTipStyle.Name:  			break;  		case PinToolTipStyle.NameShortType:  			typeSize = TextRenderer.MeasureText (_mouseOverPin.DataType.Name' f);  			tts.Width = Math.Max (tts.Width' typeSize.Width);  			tts.Height = tts.Height * 2 + 5;  			break;  		case PinToolTipStyle.NameLongType:  			typeSize = TextRenderer.MeasureText (_mouseOverPin.DataType.FullName' f);  			tts.Width = Math.Max (tts.Width' typeSize.Width);  			tts.Height = tts.Height * 2 + 5;  			break;  		default:  			break;  		}  		e.ToolTipSize = tts;  	}  }  else if (_tooltiptext != "") {  	e.ToolTipSize = TextRenderer.MeasureText (_tooltiptext + (_parentGraph.ShowOrdinal ? ": Ordinal " + _node.Ordinal.ToString () : "")' f);  }  else {  	e.ToolTipSize = TextRenderer.MeasureText (_captionText + (_parentGraph.ShowOrdinal ? ": Ordinal " + _node.Ordinal.ToString () : "")' f);  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,m_wndToolTip_Popup,The following statement contains a magic number: if (_mouseOverPin != null) {  	//if the user has defined PinToolTipPopup' call that instead  	if ((_mouseOverPin.PinUIElements as PinUI).UserDefinedToolTipPopup) {  		(_mouseOverPin.PinUIElements as PinUI).InvokeToolTipPopup (_mouseOverPin' e);  	}  	else {  		//measure the strings for pin name and pin data type  		Size tts = TextRenderer.MeasureText (_mouseOverPin.Name' f);  		Size typeSize = new Size ();  		switch ((_mouseOverPin.PinUIElements as PinUI).PinToolTipStyle) {  		case PinToolTipStyle.Name:  			break;  		case PinToolTipStyle.NameShortType:  			typeSize = TextRenderer.MeasureText (_mouseOverPin.DataType.Name' f);  			tts.Width = Math.Max (tts.Width' typeSize.Width);  			tts.Height = tts.Height * 2 + 5;  			break;  		case PinToolTipStyle.NameLongType:  			typeSize = TextRenderer.MeasureText (_mouseOverPin.DataType.FullName' f);  			tts.Width = Math.Max (tts.Width' typeSize.Width);  			tts.Height = tts.Height * 2 + 5;  			break;  		default:  			break;  		}  		e.ToolTipSize = tts;  	}  }  else if (_tooltiptext != "") {  	e.ToolTipSize = TextRenderer.MeasureText (_tooltiptext + (_parentGraph.ShowOrdinal ? ": Ordinal " + _node.Ordinal.ToString () : "")' f);  }  else {  	e.ToolTipSize = TextRenderer.MeasureText (_captionText + (_parentGraph.ShowOrdinal ? ": Ordinal " + _node.Ordinal.ToString () : "")' f);  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,m_wndToolTip_Popup,The following statement contains a magic number: if (_mouseOverPin != null) {  	//if the user has defined PinToolTipPopup' call that instead  	if ((_mouseOverPin.PinUIElements as PinUI).UserDefinedToolTipPopup) {  		(_mouseOverPin.PinUIElements as PinUI).InvokeToolTipPopup (_mouseOverPin' e);  	}  	else {  		//measure the strings for pin name and pin data type  		Size tts = TextRenderer.MeasureText (_mouseOverPin.Name' f);  		Size typeSize = new Size ();  		switch ((_mouseOverPin.PinUIElements as PinUI).PinToolTipStyle) {  		case PinToolTipStyle.Name:  			break;  		case PinToolTipStyle.NameShortType:  			typeSize = TextRenderer.MeasureText (_mouseOverPin.DataType.Name' f);  			tts.Width = Math.Max (tts.Width' typeSize.Width);  			tts.Height = tts.Height * 2 + 5;  			break;  		case PinToolTipStyle.NameLongType:  			typeSize = TextRenderer.MeasureText (_mouseOverPin.DataType.FullName' f);  			tts.Width = Math.Max (tts.Width' typeSize.Width);  			tts.Height = tts.Height * 2 + 5;  			break;  		default:  			break;  		}  		e.ToolTipSize = tts;  	}  }  else if (_tooltiptext != "") {  	e.ToolTipSize = TextRenderer.MeasureText (_tooltiptext + (_parentGraph.ShowOrdinal ? ": Ordinal " + _node.Ordinal.ToString () : "")' f);  }  else {  	e.ToolTipSize = TextRenderer.MeasureText (_captionText + (_parentGraph.ShowOrdinal ? ": Ordinal " + _node.Ordinal.ToString () : "")' f);  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,m_wndToolTip_Popup,The following statement contains a magic number: if ((_mouseOverPin.PinUIElements as PinUI).UserDefinedToolTipPopup) {  	(_mouseOverPin.PinUIElements as PinUI).InvokeToolTipPopup (_mouseOverPin' e);  }  else {  	//measure the strings for pin name and pin data type  	Size tts = TextRenderer.MeasureText (_mouseOverPin.Name' f);  	Size typeSize = new Size ();  	switch ((_mouseOverPin.PinUIElements as PinUI).PinToolTipStyle) {  	case PinToolTipStyle.Name:  		break;  	case PinToolTipStyle.NameShortType:  		typeSize = TextRenderer.MeasureText (_mouseOverPin.DataType.Name' f);  		tts.Width = Math.Max (tts.Width' typeSize.Width);  		tts.Height = tts.Height * 2 + 5;  		break;  	case PinToolTipStyle.NameLongType:  		typeSize = TextRenderer.MeasureText (_mouseOverPin.DataType.FullName' f);  		tts.Width = Math.Max (tts.Width' typeSize.Width);  		tts.Height = tts.Height * 2 + 5;  		break;  	default:  		break;  	}  	e.ToolTipSize = tts;  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,m_wndToolTip_Popup,The following statement contains a magic number: if ((_mouseOverPin.PinUIElements as PinUI).UserDefinedToolTipPopup) {  	(_mouseOverPin.PinUIElements as PinUI).InvokeToolTipPopup (_mouseOverPin' e);  }  else {  	//measure the strings for pin name and pin data type  	Size tts = TextRenderer.MeasureText (_mouseOverPin.Name' f);  	Size typeSize = new Size ();  	switch ((_mouseOverPin.PinUIElements as PinUI).PinToolTipStyle) {  	case PinToolTipStyle.Name:  		break;  	case PinToolTipStyle.NameShortType:  		typeSize = TextRenderer.MeasureText (_mouseOverPin.DataType.Name' f);  		tts.Width = Math.Max (tts.Width' typeSize.Width);  		tts.Height = tts.Height * 2 + 5;  		break;  	case PinToolTipStyle.NameLongType:  		typeSize = TextRenderer.MeasureText (_mouseOverPin.DataType.FullName' f);  		tts.Width = Math.Max (tts.Width' typeSize.Width);  		tts.Height = tts.Height * 2 + 5;  		break;  	default:  		break;  	}  	e.ToolTipSize = tts;  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,m_wndToolTip_Popup,The following statement contains a magic number: if ((_mouseOverPin.PinUIElements as PinUI).UserDefinedToolTipPopup) {  	(_mouseOverPin.PinUIElements as PinUI).InvokeToolTipPopup (_mouseOverPin' e);  }  else {  	//measure the strings for pin name and pin data type  	Size tts = TextRenderer.MeasureText (_mouseOverPin.Name' f);  	Size typeSize = new Size ();  	switch ((_mouseOverPin.PinUIElements as PinUI).PinToolTipStyle) {  	case PinToolTipStyle.Name:  		break;  	case PinToolTipStyle.NameShortType:  		typeSize = TextRenderer.MeasureText (_mouseOverPin.DataType.Name' f);  		tts.Width = Math.Max (tts.Width' typeSize.Width);  		tts.Height = tts.Height * 2 + 5;  		break;  	case PinToolTipStyle.NameLongType:  		typeSize = TextRenderer.MeasureText (_mouseOverPin.DataType.FullName' f);  		tts.Width = Math.Max (tts.Width' typeSize.Width);  		tts.Height = tts.Height * 2 + 5;  		break;  	default:  		break;  	}  	e.ToolTipSize = tts;  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,m_wndToolTip_Popup,The following statement contains a magic number: if ((_mouseOverPin.PinUIElements as PinUI).UserDefinedToolTipPopup) {  	(_mouseOverPin.PinUIElements as PinUI).InvokeToolTipPopup (_mouseOverPin' e);  }  else {  	//measure the strings for pin name and pin data type  	Size tts = TextRenderer.MeasureText (_mouseOverPin.Name' f);  	Size typeSize = new Size ();  	switch ((_mouseOverPin.PinUIElements as PinUI).PinToolTipStyle) {  	case PinToolTipStyle.Name:  		break;  	case PinToolTipStyle.NameShortType:  		typeSize = TextRenderer.MeasureText (_mouseOverPin.DataType.Name' f);  		tts.Width = Math.Max (tts.Width' typeSize.Width);  		tts.Height = tts.Height * 2 + 5;  		break;  	case PinToolTipStyle.NameLongType:  		typeSize = TextRenderer.MeasureText (_mouseOverPin.DataType.FullName' f);  		tts.Width = Math.Max (tts.Width' typeSize.Width);  		tts.Height = tts.Height * 2 + 5;  		break;  	default:  		break;  	}  	e.ToolTipSize = tts;  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,m_wndToolTip_Popup,The following statement contains a magic number: switch ((_mouseOverPin.PinUIElements as PinUI).PinToolTipStyle) {  case PinToolTipStyle.Name:  	break;  case PinToolTipStyle.NameShortType:  	typeSize = TextRenderer.MeasureText (_mouseOverPin.DataType.Name' f);  	tts.Width = Math.Max (tts.Width' typeSize.Width);  	tts.Height = tts.Height * 2 + 5;  	break;  case PinToolTipStyle.NameLongType:  	typeSize = TextRenderer.MeasureText (_mouseOverPin.DataType.FullName' f);  	tts.Width = Math.Max (tts.Width' typeSize.Width);  	tts.Height = tts.Height * 2 + 5;  	break;  default:  	break;  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,m_wndToolTip_Popup,The following statement contains a magic number: switch ((_mouseOverPin.PinUIElements as PinUI).PinToolTipStyle) {  case PinToolTipStyle.Name:  	break;  case PinToolTipStyle.NameShortType:  	typeSize = TextRenderer.MeasureText (_mouseOverPin.DataType.Name' f);  	tts.Width = Math.Max (tts.Width' typeSize.Width);  	tts.Height = tts.Height * 2 + 5;  	break;  case PinToolTipStyle.NameLongType:  	typeSize = TextRenderer.MeasureText (_mouseOverPin.DataType.FullName' f);  	tts.Width = Math.Max (tts.Width' typeSize.Width);  	tts.Height = tts.Height * 2 + 5;  	break;  default:  	break;  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,m_wndToolTip_Popup,The following statement contains a magic number: switch ((_mouseOverPin.PinUIElements as PinUI).PinToolTipStyle) {  case PinToolTipStyle.Name:  	break;  case PinToolTipStyle.NameShortType:  	typeSize = TextRenderer.MeasureText (_mouseOverPin.DataType.Name' f);  	tts.Width = Math.Max (tts.Width' typeSize.Width);  	tts.Height = tts.Height * 2 + 5;  	break;  case PinToolTipStyle.NameLongType:  	typeSize = TextRenderer.MeasureText (_mouseOverPin.DataType.FullName' f);  	tts.Width = Math.Max (tts.Width' typeSize.Width);  	tts.Height = tts.Height * 2 + 5;  	break;  default:  	break;  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,m_wndToolTip_Popup,The following statement contains a magic number: switch ((_mouseOverPin.PinUIElements as PinUI).PinToolTipStyle) {  case PinToolTipStyle.Name:  	break;  case PinToolTipStyle.NameShortType:  	typeSize = TextRenderer.MeasureText (_mouseOverPin.DataType.Name' f);  	tts.Width = Math.Max (tts.Width' typeSize.Width);  	tts.Height = tts.Height * 2 + 5;  	break;  case PinToolTipStyle.NameLongType:  	typeSize = TextRenderer.MeasureText (_mouseOverPin.DataType.FullName' f);  	tts.Width = Math.Max (tts.Width' typeSize.Width);  	tts.Height = tts.Height * 2 + 5;  	break;  default:  	break;  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,m_wndToolTip_Popup,The following statement contains a magic number: tts.Height = tts.Height * 2 + 5;  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,m_wndToolTip_Popup,The following statement contains a magic number: tts.Height = tts.Height * 2 + 5;  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,m_wndToolTip_Popup,The following statement contains a magic number: tts.Height = tts.Height * 2 + 5;  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,m_wndToolTip_Popup,The following statement contains a magic number: tts.Height = tts.Height * 2 + 5;  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,m_wndToolTip_Draw,The following statement contains a magic number: if (_mouseOverPin != null && (_mouseOverPin.PinUIElements as PinUI).UserDefinedToolTipDraw) {  	(_mouseOverPin.PinUIElements as PinUI).InvokeToolTipDraw (_mouseOverPin' e);  }  else {  	// what text shall we draw?  	string theText = (_mouseOverPin != null) ? _mouseOverPin.Name : ((_tooltiptext == "") ? _captionText : _tooltiptext) + (_parentGraph.ShowOrdinal ? ": Ordinal " + _node.Ordinal.ToString () : "");  	Color textColor = SystemColors.ActiveCaptionText;  	if (_mouseOverPin != null) {  		textColor = ControlPaint.Light ((_mouseOverPin.PinUIElements as PinUI).NoodleColor);  		using (Pen ddp = new Pen ((_mouseOverPin.PinUIElements as PinUI).NoodleColor)) {  			using (Brush ddb = new SolidBrush (ControlPaint.Dark ((_mouseOverPin.PinUIElements as PinUI).NoodleColor))) {  				e.Graphics.FillRectangle (ddb' e.Bounds);  				switch ((_mouseOverPin.PinUIElements as PinUI).PinToolTipStyle) {  				case PinToolTipStyle.Name:  					break;  				case PinToolTipStyle.NameShortType:  					theText += "\n" + _mouseOverPin.DataType.Name;  					//draw serperator line  					e.Graphics.DrawLine (ddp' 0' e.Bounds.Height / 2' e.Bounds.Width' e.Bounds.Height / 2);  					break;  				case PinToolTipStyle.NameLongType:  					theText += "\n" + _mouseOverPin.DataType.FullName;  					//draw serperator line  					e.Graphics.DrawLine (ddp' 0' e.Bounds.Height / 2' e.Bounds.Width' e.Bounds.Height / 2);  					break;  				default:  					break;  				}  			}  		}  	}  	else {  		// Draw the custom background.  		e.Graphics.FillRectangle (SystemBrushes.ActiveCaption' e.Bounds);  	}  	// Draw the standard border.  	e.DrawBorder ();  	// Draw the custom text.  	using (StringFormat sf = new StringFormat ()) {  		sf.Alignment = StringAlignment.Center;  		sf.LineAlignment = StringAlignment.Center;  		sf.HotkeyPrefix = System.Drawing.Text.HotkeyPrefix.None;  		using (Font f = new Font ("Tahoma"' 9)) {  			using (Brush textBrush = new SolidBrush (textColor)) {  				e.Graphics.DrawString (theText' f' textBrush' e.Bounds' sf);  			}  		}  	}  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,m_wndToolTip_Draw,The following statement contains a magic number: if (_mouseOverPin != null && (_mouseOverPin.PinUIElements as PinUI).UserDefinedToolTipDraw) {  	(_mouseOverPin.PinUIElements as PinUI).InvokeToolTipDraw (_mouseOverPin' e);  }  else {  	// what text shall we draw?  	string theText = (_mouseOverPin != null) ? _mouseOverPin.Name : ((_tooltiptext == "") ? _captionText : _tooltiptext) + (_parentGraph.ShowOrdinal ? ": Ordinal " + _node.Ordinal.ToString () : "");  	Color textColor = SystemColors.ActiveCaptionText;  	if (_mouseOverPin != null) {  		textColor = ControlPaint.Light ((_mouseOverPin.PinUIElements as PinUI).NoodleColor);  		using (Pen ddp = new Pen ((_mouseOverPin.PinUIElements as PinUI).NoodleColor)) {  			using (Brush ddb = new SolidBrush (ControlPaint.Dark ((_mouseOverPin.PinUIElements as PinUI).NoodleColor))) {  				e.Graphics.FillRectangle (ddb' e.Bounds);  				switch ((_mouseOverPin.PinUIElements as PinUI).PinToolTipStyle) {  				case PinToolTipStyle.Name:  					break;  				case PinToolTipStyle.NameShortType:  					theText += "\n" + _mouseOverPin.DataType.Name;  					//draw serperator line  					e.Graphics.DrawLine (ddp' 0' e.Bounds.Height / 2' e.Bounds.Width' e.Bounds.Height / 2);  					break;  				case PinToolTipStyle.NameLongType:  					theText += "\n" + _mouseOverPin.DataType.FullName;  					//draw serperator line  					e.Graphics.DrawLine (ddp' 0' e.Bounds.Height / 2' e.Bounds.Width' e.Bounds.Height / 2);  					break;  				default:  					break;  				}  			}  		}  	}  	else {  		// Draw the custom background.  		e.Graphics.FillRectangle (SystemBrushes.ActiveCaption' e.Bounds);  	}  	// Draw the standard border.  	e.DrawBorder ();  	// Draw the custom text.  	using (StringFormat sf = new StringFormat ()) {  		sf.Alignment = StringAlignment.Center;  		sf.LineAlignment = StringAlignment.Center;  		sf.HotkeyPrefix = System.Drawing.Text.HotkeyPrefix.None;  		using (Font f = new Font ("Tahoma"' 9)) {  			using (Brush textBrush = new SolidBrush (textColor)) {  				e.Graphics.DrawString (theText' f' textBrush' e.Bounds' sf);  			}  		}  	}  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,m_wndToolTip_Draw,The following statement contains a magic number: if (_mouseOverPin != null && (_mouseOverPin.PinUIElements as PinUI).UserDefinedToolTipDraw) {  	(_mouseOverPin.PinUIElements as PinUI).InvokeToolTipDraw (_mouseOverPin' e);  }  else {  	// what text shall we draw?  	string theText = (_mouseOverPin != null) ? _mouseOverPin.Name : ((_tooltiptext == "") ? _captionText : _tooltiptext) + (_parentGraph.ShowOrdinal ? ": Ordinal " + _node.Ordinal.ToString () : "");  	Color textColor = SystemColors.ActiveCaptionText;  	if (_mouseOverPin != null) {  		textColor = ControlPaint.Light ((_mouseOverPin.PinUIElements as PinUI).NoodleColor);  		using (Pen ddp = new Pen ((_mouseOverPin.PinUIElements as PinUI).NoodleColor)) {  			using (Brush ddb = new SolidBrush (ControlPaint.Dark ((_mouseOverPin.PinUIElements as PinUI).NoodleColor))) {  				e.Graphics.FillRectangle (ddb' e.Bounds);  				switch ((_mouseOverPin.PinUIElements as PinUI).PinToolTipStyle) {  				case PinToolTipStyle.Name:  					break;  				case PinToolTipStyle.NameShortType:  					theText += "\n" + _mouseOverPin.DataType.Name;  					//draw serperator line  					e.Graphics.DrawLine (ddp' 0' e.Bounds.Height / 2' e.Bounds.Width' e.Bounds.Height / 2);  					break;  				case PinToolTipStyle.NameLongType:  					theText += "\n" + _mouseOverPin.DataType.FullName;  					//draw serperator line  					e.Graphics.DrawLine (ddp' 0' e.Bounds.Height / 2' e.Bounds.Width' e.Bounds.Height / 2);  					break;  				default:  					break;  				}  			}  		}  	}  	else {  		// Draw the custom background.  		e.Graphics.FillRectangle (SystemBrushes.ActiveCaption' e.Bounds);  	}  	// Draw the standard border.  	e.DrawBorder ();  	// Draw the custom text.  	using (StringFormat sf = new StringFormat ()) {  		sf.Alignment = StringAlignment.Center;  		sf.LineAlignment = StringAlignment.Center;  		sf.HotkeyPrefix = System.Drawing.Text.HotkeyPrefix.None;  		using (Font f = new Font ("Tahoma"' 9)) {  			using (Brush textBrush = new SolidBrush (textColor)) {  				e.Graphics.DrawString (theText' f' textBrush' e.Bounds' sf);  			}  		}  	}  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,m_wndToolTip_Draw,The following statement contains a magic number: if (_mouseOverPin != null && (_mouseOverPin.PinUIElements as PinUI).UserDefinedToolTipDraw) {  	(_mouseOverPin.PinUIElements as PinUI).InvokeToolTipDraw (_mouseOverPin' e);  }  else {  	// what text shall we draw?  	string theText = (_mouseOverPin != null) ? _mouseOverPin.Name : ((_tooltiptext == "") ? _captionText : _tooltiptext) + (_parentGraph.ShowOrdinal ? ": Ordinal " + _node.Ordinal.ToString () : "");  	Color textColor = SystemColors.ActiveCaptionText;  	if (_mouseOverPin != null) {  		textColor = ControlPaint.Light ((_mouseOverPin.PinUIElements as PinUI).NoodleColor);  		using (Pen ddp = new Pen ((_mouseOverPin.PinUIElements as PinUI).NoodleColor)) {  			using (Brush ddb = new SolidBrush (ControlPaint.Dark ((_mouseOverPin.PinUIElements as PinUI).NoodleColor))) {  				e.Graphics.FillRectangle (ddb' e.Bounds);  				switch ((_mouseOverPin.PinUIElements as PinUI).PinToolTipStyle) {  				case PinToolTipStyle.Name:  					break;  				case PinToolTipStyle.NameShortType:  					theText += "\n" + _mouseOverPin.DataType.Name;  					//draw serperator line  					e.Graphics.DrawLine (ddp' 0' e.Bounds.Height / 2' e.Bounds.Width' e.Bounds.Height / 2);  					break;  				case PinToolTipStyle.NameLongType:  					theText += "\n" + _mouseOverPin.DataType.FullName;  					//draw serperator line  					e.Graphics.DrawLine (ddp' 0' e.Bounds.Height / 2' e.Bounds.Width' e.Bounds.Height / 2);  					break;  				default:  					break;  				}  			}  		}  	}  	else {  		// Draw the custom background.  		e.Graphics.FillRectangle (SystemBrushes.ActiveCaption' e.Bounds);  	}  	// Draw the standard border.  	e.DrawBorder ();  	// Draw the custom text.  	using (StringFormat sf = new StringFormat ()) {  		sf.Alignment = StringAlignment.Center;  		sf.LineAlignment = StringAlignment.Center;  		sf.HotkeyPrefix = System.Drawing.Text.HotkeyPrefix.None;  		using (Font f = new Font ("Tahoma"' 9)) {  			using (Brush textBrush = new SolidBrush (textColor)) {  				e.Graphics.DrawString (theText' f' textBrush' e.Bounds' sf);  			}  		}  	}  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,m_wndToolTip_Draw,The following statement contains a magic number: if (_mouseOverPin != null && (_mouseOverPin.PinUIElements as PinUI).UserDefinedToolTipDraw) {  	(_mouseOverPin.PinUIElements as PinUI).InvokeToolTipDraw (_mouseOverPin' e);  }  else {  	// what text shall we draw?  	string theText = (_mouseOverPin != null) ? _mouseOverPin.Name : ((_tooltiptext == "") ? _captionText : _tooltiptext) + (_parentGraph.ShowOrdinal ? ": Ordinal " + _node.Ordinal.ToString () : "");  	Color textColor = SystemColors.ActiveCaptionText;  	if (_mouseOverPin != null) {  		textColor = ControlPaint.Light ((_mouseOverPin.PinUIElements as PinUI).NoodleColor);  		using (Pen ddp = new Pen ((_mouseOverPin.PinUIElements as PinUI).NoodleColor)) {  			using (Brush ddb = new SolidBrush (ControlPaint.Dark ((_mouseOverPin.PinUIElements as PinUI).NoodleColor))) {  				e.Graphics.FillRectangle (ddb' e.Bounds);  				switch ((_mouseOverPin.PinUIElements as PinUI).PinToolTipStyle) {  				case PinToolTipStyle.Name:  					break;  				case PinToolTipStyle.NameShortType:  					theText += "\n" + _mouseOverPin.DataType.Name;  					//draw serperator line  					e.Graphics.DrawLine (ddp' 0' e.Bounds.Height / 2' e.Bounds.Width' e.Bounds.Height / 2);  					break;  				case PinToolTipStyle.NameLongType:  					theText += "\n" + _mouseOverPin.DataType.FullName;  					//draw serperator line  					e.Graphics.DrawLine (ddp' 0' e.Bounds.Height / 2' e.Bounds.Width' e.Bounds.Height / 2);  					break;  				default:  					break;  				}  			}  		}  	}  	else {  		// Draw the custom background.  		e.Graphics.FillRectangle (SystemBrushes.ActiveCaption' e.Bounds);  	}  	// Draw the standard border.  	e.DrawBorder ();  	// Draw the custom text.  	using (StringFormat sf = new StringFormat ()) {  		sf.Alignment = StringAlignment.Center;  		sf.LineAlignment = StringAlignment.Center;  		sf.HotkeyPrefix = System.Drawing.Text.HotkeyPrefix.None;  		using (Font f = new Font ("Tahoma"' 9)) {  			using (Brush textBrush = new SolidBrush (textColor)) {  				e.Graphics.DrawString (theText' f' textBrush' e.Bounds' sf);  			}  		}  	}  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,m_wndToolTip_Draw,The following statement contains a magic number: if (_mouseOverPin != null) {  	textColor = ControlPaint.Light ((_mouseOverPin.PinUIElements as PinUI).NoodleColor);  	using (Pen ddp = new Pen ((_mouseOverPin.PinUIElements as PinUI).NoodleColor)) {  		using (Brush ddb = new SolidBrush (ControlPaint.Dark ((_mouseOverPin.PinUIElements as PinUI).NoodleColor))) {  			e.Graphics.FillRectangle (ddb' e.Bounds);  			switch ((_mouseOverPin.PinUIElements as PinUI).PinToolTipStyle) {  			case PinToolTipStyle.Name:  				break;  			case PinToolTipStyle.NameShortType:  				theText += "\n" + _mouseOverPin.DataType.Name;  				//draw serperator line  				e.Graphics.DrawLine (ddp' 0' e.Bounds.Height / 2' e.Bounds.Width' e.Bounds.Height / 2);  				break;  			case PinToolTipStyle.NameLongType:  				theText += "\n" + _mouseOverPin.DataType.FullName;  				//draw serperator line  				e.Graphics.DrawLine (ddp' 0' e.Bounds.Height / 2' e.Bounds.Width' e.Bounds.Height / 2);  				break;  			default:  				break;  			}  		}  	}  }  else {  	// Draw the custom background.  	e.Graphics.FillRectangle (SystemBrushes.ActiveCaption' e.Bounds);  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,m_wndToolTip_Draw,The following statement contains a magic number: if (_mouseOverPin != null) {  	textColor = ControlPaint.Light ((_mouseOverPin.PinUIElements as PinUI).NoodleColor);  	using (Pen ddp = new Pen ((_mouseOverPin.PinUIElements as PinUI).NoodleColor)) {  		using (Brush ddb = new SolidBrush (ControlPaint.Dark ((_mouseOverPin.PinUIElements as PinUI).NoodleColor))) {  			e.Graphics.FillRectangle (ddb' e.Bounds);  			switch ((_mouseOverPin.PinUIElements as PinUI).PinToolTipStyle) {  			case PinToolTipStyle.Name:  				break;  			case PinToolTipStyle.NameShortType:  				theText += "\n" + _mouseOverPin.DataType.Name;  				//draw serperator line  				e.Graphics.DrawLine (ddp' 0' e.Bounds.Height / 2' e.Bounds.Width' e.Bounds.Height / 2);  				break;  			case PinToolTipStyle.NameLongType:  				theText += "\n" + _mouseOverPin.DataType.FullName;  				//draw serperator line  				e.Graphics.DrawLine (ddp' 0' e.Bounds.Height / 2' e.Bounds.Width' e.Bounds.Height / 2);  				break;  			default:  				break;  			}  		}  	}  }  else {  	// Draw the custom background.  	e.Graphics.FillRectangle (SystemBrushes.ActiveCaption' e.Bounds);  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,m_wndToolTip_Draw,The following statement contains a magic number: if (_mouseOverPin != null) {  	textColor = ControlPaint.Light ((_mouseOverPin.PinUIElements as PinUI).NoodleColor);  	using (Pen ddp = new Pen ((_mouseOverPin.PinUIElements as PinUI).NoodleColor)) {  		using (Brush ddb = new SolidBrush (ControlPaint.Dark ((_mouseOverPin.PinUIElements as PinUI).NoodleColor))) {  			e.Graphics.FillRectangle (ddb' e.Bounds);  			switch ((_mouseOverPin.PinUIElements as PinUI).PinToolTipStyle) {  			case PinToolTipStyle.Name:  				break;  			case PinToolTipStyle.NameShortType:  				theText += "\n" + _mouseOverPin.DataType.Name;  				//draw serperator line  				e.Graphics.DrawLine (ddp' 0' e.Bounds.Height / 2' e.Bounds.Width' e.Bounds.Height / 2);  				break;  			case PinToolTipStyle.NameLongType:  				theText += "\n" + _mouseOverPin.DataType.FullName;  				//draw serperator line  				e.Graphics.DrawLine (ddp' 0' e.Bounds.Height / 2' e.Bounds.Width' e.Bounds.Height / 2);  				break;  			default:  				break;  			}  		}  	}  }  else {  	// Draw the custom background.  	e.Graphics.FillRectangle (SystemBrushes.ActiveCaption' e.Bounds);  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,m_wndToolTip_Draw,The following statement contains a magic number: if (_mouseOverPin != null) {  	textColor = ControlPaint.Light ((_mouseOverPin.PinUIElements as PinUI).NoodleColor);  	using (Pen ddp = new Pen ((_mouseOverPin.PinUIElements as PinUI).NoodleColor)) {  		using (Brush ddb = new SolidBrush (ControlPaint.Dark ((_mouseOverPin.PinUIElements as PinUI).NoodleColor))) {  			e.Graphics.FillRectangle (ddb' e.Bounds);  			switch ((_mouseOverPin.PinUIElements as PinUI).PinToolTipStyle) {  			case PinToolTipStyle.Name:  				break;  			case PinToolTipStyle.NameShortType:  				theText += "\n" + _mouseOverPin.DataType.Name;  				//draw serperator line  				e.Graphics.DrawLine (ddp' 0' e.Bounds.Height / 2' e.Bounds.Width' e.Bounds.Height / 2);  				break;  			case PinToolTipStyle.NameLongType:  				theText += "\n" + _mouseOverPin.DataType.FullName;  				//draw serperator line  				e.Graphics.DrawLine (ddp' 0' e.Bounds.Height / 2' e.Bounds.Width' e.Bounds.Height / 2);  				break;  			default:  				break;  			}  		}  	}  }  else {  	// Draw the custom background.  	e.Graphics.FillRectangle (SystemBrushes.ActiveCaption' e.Bounds);  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,m_wndToolTip_Draw,The following statement contains a magic number: using (Pen ddp = new Pen ((_mouseOverPin.PinUIElements as PinUI).NoodleColor)) {  	using (Brush ddb = new SolidBrush (ControlPaint.Dark ((_mouseOverPin.PinUIElements as PinUI).NoodleColor))) {  		e.Graphics.FillRectangle (ddb' e.Bounds);  		switch ((_mouseOverPin.PinUIElements as PinUI).PinToolTipStyle) {  		case PinToolTipStyle.Name:  			break;  		case PinToolTipStyle.NameShortType:  			theText += "\n" + _mouseOverPin.DataType.Name;  			//draw serperator line  			e.Graphics.DrawLine (ddp' 0' e.Bounds.Height / 2' e.Bounds.Width' e.Bounds.Height / 2);  			break;  		case PinToolTipStyle.NameLongType:  			theText += "\n" + _mouseOverPin.DataType.FullName;  			//draw serperator line  			e.Graphics.DrawLine (ddp' 0' e.Bounds.Height / 2' e.Bounds.Width' e.Bounds.Height / 2);  			break;  		default:  			break;  		}  	}  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,m_wndToolTip_Draw,The following statement contains a magic number: using (Pen ddp = new Pen ((_mouseOverPin.PinUIElements as PinUI).NoodleColor)) {  	using (Brush ddb = new SolidBrush (ControlPaint.Dark ((_mouseOverPin.PinUIElements as PinUI).NoodleColor))) {  		e.Graphics.FillRectangle (ddb' e.Bounds);  		switch ((_mouseOverPin.PinUIElements as PinUI).PinToolTipStyle) {  		case PinToolTipStyle.Name:  			break;  		case PinToolTipStyle.NameShortType:  			theText += "\n" + _mouseOverPin.DataType.Name;  			//draw serperator line  			e.Graphics.DrawLine (ddp' 0' e.Bounds.Height / 2' e.Bounds.Width' e.Bounds.Height / 2);  			break;  		case PinToolTipStyle.NameLongType:  			theText += "\n" + _mouseOverPin.DataType.FullName;  			//draw serperator line  			e.Graphics.DrawLine (ddp' 0' e.Bounds.Height / 2' e.Bounds.Width' e.Bounds.Height / 2);  			break;  		default:  			break;  		}  	}  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,m_wndToolTip_Draw,The following statement contains a magic number: using (Pen ddp = new Pen ((_mouseOverPin.PinUIElements as PinUI).NoodleColor)) {  	using (Brush ddb = new SolidBrush (ControlPaint.Dark ((_mouseOverPin.PinUIElements as PinUI).NoodleColor))) {  		e.Graphics.FillRectangle (ddb' e.Bounds);  		switch ((_mouseOverPin.PinUIElements as PinUI).PinToolTipStyle) {  		case PinToolTipStyle.Name:  			break;  		case PinToolTipStyle.NameShortType:  			theText += "\n" + _mouseOverPin.DataType.Name;  			//draw serperator line  			e.Graphics.DrawLine (ddp' 0' e.Bounds.Height / 2' e.Bounds.Width' e.Bounds.Height / 2);  			break;  		case PinToolTipStyle.NameLongType:  			theText += "\n" + _mouseOverPin.DataType.FullName;  			//draw serperator line  			e.Graphics.DrawLine (ddp' 0' e.Bounds.Height / 2' e.Bounds.Width' e.Bounds.Height / 2);  			break;  		default:  			break;  		}  	}  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,m_wndToolTip_Draw,The following statement contains a magic number: using (Pen ddp = new Pen ((_mouseOverPin.PinUIElements as PinUI).NoodleColor)) {  	using (Brush ddb = new SolidBrush (ControlPaint.Dark ((_mouseOverPin.PinUIElements as PinUI).NoodleColor))) {  		e.Graphics.FillRectangle (ddb' e.Bounds);  		switch ((_mouseOverPin.PinUIElements as PinUI).PinToolTipStyle) {  		case PinToolTipStyle.Name:  			break;  		case PinToolTipStyle.NameShortType:  			theText += "\n" + _mouseOverPin.DataType.Name;  			//draw serperator line  			e.Graphics.DrawLine (ddp' 0' e.Bounds.Height / 2' e.Bounds.Width' e.Bounds.Height / 2);  			break;  		case PinToolTipStyle.NameLongType:  			theText += "\n" + _mouseOverPin.DataType.FullName;  			//draw serperator line  			e.Graphics.DrawLine (ddp' 0' e.Bounds.Height / 2' e.Bounds.Width' e.Bounds.Height / 2);  			break;  		default:  			break;  		}  	}  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,m_wndToolTip_Draw,The following statement contains a magic number: using (Brush ddb = new SolidBrush (ControlPaint.Dark ((_mouseOverPin.PinUIElements as PinUI).NoodleColor))) {  	e.Graphics.FillRectangle (ddb' e.Bounds);  	switch ((_mouseOverPin.PinUIElements as PinUI).PinToolTipStyle) {  	case PinToolTipStyle.Name:  		break;  	case PinToolTipStyle.NameShortType:  		theText += "\n" + _mouseOverPin.DataType.Name;  		//draw serperator line  		e.Graphics.DrawLine (ddp' 0' e.Bounds.Height / 2' e.Bounds.Width' e.Bounds.Height / 2);  		break;  	case PinToolTipStyle.NameLongType:  		theText += "\n" + _mouseOverPin.DataType.FullName;  		//draw serperator line  		e.Graphics.DrawLine (ddp' 0' e.Bounds.Height / 2' e.Bounds.Width' e.Bounds.Height / 2);  		break;  	default:  		break;  	}  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,m_wndToolTip_Draw,The following statement contains a magic number: using (Brush ddb = new SolidBrush (ControlPaint.Dark ((_mouseOverPin.PinUIElements as PinUI).NoodleColor))) {  	e.Graphics.FillRectangle (ddb' e.Bounds);  	switch ((_mouseOverPin.PinUIElements as PinUI).PinToolTipStyle) {  	case PinToolTipStyle.Name:  		break;  	case PinToolTipStyle.NameShortType:  		theText += "\n" + _mouseOverPin.DataType.Name;  		//draw serperator line  		e.Graphics.DrawLine (ddp' 0' e.Bounds.Height / 2' e.Bounds.Width' e.Bounds.Height / 2);  		break;  	case PinToolTipStyle.NameLongType:  		theText += "\n" + _mouseOverPin.DataType.FullName;  		//draw serperator line  		e.Graphics.DrawLine (ddp' 0' e.Bounds.Height / 2' e.Bounds.Width' e.Bounds.Height / 2);  		break;  	default:  		break;  	}  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,m_wndToolTip_Draw,The following statement contains a magic number: using (Brush ddb = new SolidBrush (ControlPaint.Dark ((_mouseOverPin.PinUIElements as PinUI).NoodleColor))) {  	e.Graphics.FillRectangle (ddb' e.Bounds);  	switch ((_mouseOverPin.PinUIElements as PinUI).PinToolTipStyle) {  	case PinToolTipStyle.Name:  		break;  	case PinToolTipStyle.NameShortType:  		theText += "\n" + _mouseOverPin.DataType.Name;  		//draw serperator line  		e.Graphics.DrawLine (ddp' 0' e.Bounds.Height / 2' e.Bounds.Width' e.Bounds.Height / 2);  		break;  	case PinToolTipStyle.NameLongType:  		theText += "\n" + _mouseOverPin.DataType.FullName;  		//draw serperator line  		e.Graphics.DrawLine (ddp' 0' e.Bounds.Height / 2' e.Bounds.Width' e.Bounds.Height / 2);  		break;  	default:  		break;  	}  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,m_wndToolTip_Draw,The following statement contains a magic number: using (Brush ddb = new SolidBrush (ControlPaint.Dark ((_mouseOverPin.PinUIElements as PinUI).NoodleColor))) {  	e.Graphics.FillRectangle (ddb' e.Bounds);  	switch ((_mouseOverPin.PinUIElements as PinUI).PinToolTipStyle) {  	case PinToolTipStyle.Name:  		break;  	case PinToolTipStyle.NameShortType:  		theText += "\n" + _mouseOverPin.DataType.Name;  		//draw serperator line  		e.Graphics.DrawLine (ddp' 0' e.Bounds.Height / 2' e.Bounds.Width' e.Bounds.Height / 2);  		break;  	case PinToolTipStyle.NameLongType:  		theText += "\n" + _mouseOverPin.DataType.FullName;  		//draw serperator line  		e.Graphics.DrawLine (ddp' 0' e.Bounds.Height / 2' e.Bounds.Width' e.Bounds.Height / 2);  		break;  	default:  		break;  	}  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,m_wndToolTip_Draw,The following statement contains a magic number: switch ((_mouseOverPin.PinUIElements as PinUI).PinToolTipStyle) {  case PinToolTipStyle.Name:  	break;  case PinToolTipStyle.NameShortType:  	theText += "\n" + _mouseOverPin.DataType.Name;  	//draw serperator line  	e.Graphics.DrawLine (ddp' 0' e.Bounds.Height / 2' e.Bounds.Width' e.Bounds.Height / 2);  	break;  case PinToolTipStyle.NameLongType:  	theText += "\n" + _mouseOverPin.DataType.FullName;  	//draw serperator line  	e.Graphics.DrawLine (ddp' 0' e.Bounds.Height / 2' e.Bounds.Width' e.Bounds.Height / 2);  	break;  default:  	break;  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,m_wndToolTip_Draw,The following statement contains a magic number: switch ((_mouseOverPin.PinUIElements as PinUI).PinToolTipStyle) {  case PinToolTipStyle.Name:  	break;  case PinToolTipStyle.NameShortType:  	theText += "\n" + _mouseOverPin.DataType.Name;  	//draw serperator line  	e.Graphics.DrawLine (ddp' 0' e.Bounds.Height / 2' e.Bounds.Width' e.Bounds.Height / 2);  	break;  case PinToolTipStyle.NameLongType:  	theText += "\n" + _mouseOverPin.DataType.FullName;  	//draw serperator line  	e.Graphics.DrawLine (ddp' 0' e.Bounds.Height / 2' e.Bounds.Width' e.Bounds.Height / 2);  	break;  default:  	break;  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,m_wndToolTip_Draw,The following statement contains a magic number: switch ((_mouseOverPin.PinUIElements as PinUI).PinToolTipStyle) {  case PinToolTipStyle.Name:  	break;  case PinToolTipStyle.NameShortType:  	theText += "\n" + _mouseOverPin.DataType.Name;  	//draw serperator line  	e.Graphics.DrawLine (ddp' 0' e.Bounds.Height / 2' e.Bounds.Width' e.Bounds.Height / 2);  	break;  case PinToolTipStyle.NameLongType:  	theText += "\n" + _mouseOverPin.DataType.FullName;  	//draw serperator line  	e.Graphics.DrawLine (ddp' 0' e.Bounds.Height / 2' e.Bounds.Width' e.Bounds.Height / 2);  	break;  default:  	break;  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,m_wndToolTip_Draw,The following statement contains a magic number: switch ((_mouseOverPin.PinUIElements as PinUI).PinToolTipStyle) {  case PinToolTipStyle.Name:  	break;  case PinToolTipStyle.NameShortType:  	theText += "\n" + _mouseOverPin.DataType.Name;  	//draw serperator line  	e.Graphics.DrawLine (ddp' 0' e.Bounds.Height / 2' e.Bounds.Width' e.Bounds.Height / 2);  	break;  case PinToolTipStyle.NameLongType:  	theText += "\n" + _mouseOverPin.DataType.FullName;  	//draw serperator line  	e.Graphics.DrawLine (ddp' 0' e.Bounds.Height / 2' e.Bounds.Width' e.Bounds.Height / 2);  	break;  default:  	break;  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,m_wndToolTip_Draw,The following statement contains a magic number: e.Graphics.DrawLine (ddp' 0' e.Bounds.Height / 2' e.Bounds.Width' e.Bounds.Height / 2);  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,m_wndToolTip_Draw,The following statement contains a magic number: e.Graphics.DrawLine (ddp' 0' e.Bounds.Height / 2' e.Bounds.Width' e.Bounds.Height / 2);  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,m_wndToolTip_Draw,The following statement contains a magic number: e.Graphics.DrawLine (ddp' 0' e.Bounds.Height / 2' e.Bounds.Width' e.Bounds.Height / 2);  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,m_wndToolTip_Draw,The following statement contains a magic number: e.Graphics.DrawLine (ddp' 0' e.Bounds.Height / 2' e.Bounds.Width' e.Bounds.Height / 2);  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,m_wndToolTip_Draw,The following statement contains a magic number: using (StringFormat sf = new StringFormat ()) {  	sf.Alignment = StringAlignment.Center;  	sf.LineAlignment = StringAlignment.Center;  	sf.HotkeyPrefix = System.Drawing.Text.HotkeyPrefix.None;  	using (Font f = new Font ("Tahoma"' 9)) {  		using (Brush textBrush = new SolidBrush (textColor)) {  			e.Graphics.DrawString (theText' f' textBrush' e.Bounds' sf);  		}  	}  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,m_wndToolTip_Draw,The following statement contains a magic number: using (Font f = new Font ("Tahoma"' 9)) {  	using (Brush textBrush = new SolidBrush (textColor)) {  		e.Graphics.DrawString (theText' f' textBrush' e.Bounds' sf);  	}  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,ArrangeCaptionButtons,The following statement contains a magic number: if (_pinPlacement == DaggerNodePinPlacement.Outset) {  	if (_parentGraph != null) {  		offset -= _parentGraph.PinLegend.PinSize;  	}  	else {  		offset -= 11;  	}  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,ArrangeCaptionButtons,The following statement contains a magic number: if (_parentGraph != null) {  	offset -= _parentGraph.PinLegend.PinSize;  }  else {  	offset -= 11;  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,ArrangeCaptionButtons,The following statement contains a magic number: offset -= 11;  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,CreateBackImage,The following statement contains a magic number: if ((_node.InputPins != null) && (_node.OutputPins != null)) {  	int inputpintop = (Height - ((_node.InputPins.MutexAvailablePins.Count * PinSize) + ((_node.InputPins.MutexAvailablePins.Count - 1) * _pinSpacing))) / 2;  	int outputpintop = (Height - ((_node.OutputPins.MutexAvailablePins.Count * PinSize) + ((_node.OutputPins.MutexAvailablePins.Count - 1) * _pinSpacing))) / 2;  	for (int i = 0; i < _node.InputPins.MutexAvailablePins.Count; i++) {  		Image pinimage = _node.InputPins.MutexAvailablePins [i].IsConnected ? (_node.InputPins.MutexAvailablePins [i].PinUIElements as PinUI).PinImageConnected : (_node.InputPins.MutexAvailablePins [i].PinUIElements as PinUI).PinImageDisconnected;  		ImageAttributes att = new ImageAttributes ();  		Color alphakey = _node.InputPins.MutexAvailablePins [i].IsConnected ? (_node.InputPins.MutexAvailablePins [i].PinUIElements as PinUI).PinImageConnectedTransparent : (_node.InputPins.MutexAvailablePins [i].PinUIElements as PinUI).PinImageDisconnectedTransparent;  		att.SetColorKey (alphakey' alphakey);  		g.DrawImage (pinimage' new Rectangle (0' inputpintop' PinSize' PinSize)' 0' 0' PinSize' PinSize' GraphicsUnit.Pixel' att);  		inputpintop += PinSize + _pinSpacing;  	}  	for (int i = 0; i < _node.OutputPins.MutexAvailablePins.Count; i++) {  		Image pinimage = _node.OutputPins.MutexAvailablePins [i].IsConnected ? (_node.OutputPins.MutexAvailablePins [i].PinUIElements as PinUI).PinImageConnected : (_node.OutputPins.MutexAvailablePins [i].PinUIElements as PinUI).PinImageDisconnected;  		ImageAttributes att = new ImageAttributes ();  		Color alphakey = _node.OutputPins.MutexAvailablePins [i].IsConnected ? (_node.OutputPins.MutexAvailablePins [i].PinUIElements as PinUI).PinImageConnectedTransparent : (_node.OutputPins.MutexAvailablePins [i].PinUIElements as PinUI).PinImageDisconnectedTransparent;  		att.SetColorKey (alphakey' alphakey);  		g.DrawImage (pinimage' new Rectangle (Width - PinSize' outputpintop' PinSize' PinSize)' 0' 0' PinSize' PinSize' GraphicsUnit.Pixel' att);  		outputpintop += PinSize + _pinSpacing;  	}  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,CreateBackImage,The following statement contains a magic number: if ((_node.InputPins != null) && (_node.OutputPins != null)) {  	int inputpintop = (Height - ((_node.InputPins.MutexAvailablePins.Count * PinSize) + ((_node.InputPins.MutexAvailablePins.Count - 1) * _pinSpacing))) / 2;  	int outputpintop = (Height - ((_node.OutputPins.MutexAvailablePins.Count * PinSize) + ((_node.OutputPins.MutexAvailablePins.Count - 1) * _pinSpacing))) / 2;  	for (int i = 0; i < _node.InputPins.MutexAvailablePins.Count; i++) {  		Image pinimage = _node.InputPins.MutexAvailablePins [i].IsConnected ? (_node.InputPins.MutexAvailablePins [i].PinUIElements as PinUI).PinImageConnected : (_node.InputPins.MutexAvailablePins [i].PinUIElements as PinUI).PinImageDisconnected;  		ImageAttributes att = new ImageAttributes ();  		Color alphakey = _node.InputPins.MutexAvailablePins [i].IsConnected ? (_node.InputPins.MutexAvailablePins [i].PinUIElements as PinUI).PinImageConnectedTransparent : (_node.InputPins.MutexAvailablePins [i].PinUIElements as PinUI).PinImageDisconnectedTransparent;  		att.SetColorKey (alphakey' alphakey);  		g.DrawImage (pinimage' new Rectangle (0' inputpintop' PinSize' PinSize)' 0' 0' PinSize' PinSize' GraphicsUnit.Pixel' att);  		inputpintop += PinSize + _pinSpacing;  	}  	for (int i = 0; i < _node.OutputPins.MutexAvailablePins.Count; i++) {  		Image pinimage = _node.OutputPins.MutexAvailablePins [i].IsConnected ? (_node.OutputPins.MutexAvailablePins [i].PinUIElements as PinUI).PinImageConnected : (_node.OutputPins.MutexAvailablePins [i].PinUIElements as PinUI).PinImageDisconnected;  		ImageAttributes att = new ImageAttributes ();  		Color alphakey = _node.OutputPins.MutexAvailablePins [i].IsConnected ? (_node.OutputPins.MutexAvailablePins [i].PinUIElements as PinUI).PinImageConnectedTransparent : (_node.OutputPins.MutexAvailablePins [i].PinUIElements as PinUI).PinImageDisconnectedTransparent;  		att.SetColorKey (alphakey' alphakey);  		g.DrawImage (pinimage' new Rectangle (Width - PinSize' outputpintop' PinSize' PinSize)' 0' 0' PinSize' PinSize' GraphicsUnit.Pixel' att);  		outputpintop += PinSize + _pinSpacing;  	}  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,DrawCaption,The following statement contains a magic number: g.DrawString (_captionText' this.Font' new SolidBrush (ForeColor)' new PointF (xAxis + 3' yAxis)' stringFormat);  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,DrawCaption,The following statement contains a magic number: if (_panelIcon != null) {  	Rectangle iconDest = new Rectangle ((int)(xAxis - _captionSize + 3)' 0' _captionSize' _captionSize);  	Rectangle iconSrc = new Rectangle (0' 0' _panelIcon.Width' _panelIcon.Height);  	g.DrawImage (_panelIcon' iconDest' iconSrc' GraphicsUnit.Pixel);  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,UpdatePaths,The following statement contains a magic number: if (_pinPlacement == DaggerNodePinPlacement.Outset) {  	//we want the pins completely outside the panel' so make the client rectangle a little smaller  	r = new RectangleF (PinSize' 0' (Width - 1) - PinSize * 2' Height - 1);  }  else {  	r = new RectangleF (0' 0' Width - 1' Height - 1);  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,UpdatePaths,The following statement contains a magic number: r = new RectangleF (PinSize' 0' (Width - 1) - PinSize * 2' Height - 1);  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,UpdatePaths,The following statement contains a magic number: if (_resizable) {  	Point lr = new Point ();  	//get the lower right point based on pin placement  	switch (_pinPlacement) {  	case DaggerNodePinPlacement.Indent:  	case DaggerNodePinPlacement.Inset:  		lr = new Point (Width - 1' Height - 1);  		break;  	case DaggerNodePinPlacement.Outset:  		if (_parentGraph != null) {  			lr = new Point (Width - 1 - _parentGraph.PinLegend.PinSize' Height - 1);  		}  		else {  			lr = new Point (Width - 11' Height - 1);  		}  		break;  	default:  		break;  	}  	//create a small triangle in lower right corner  	_resizePath = new GraphicsPath ();  	_resizePath.StartFigure ();  	_resizePath.AddLine (lr.X' lr.Y' lr.X - 12' lr.Y);  	_resizePath.AddLine (lr.X - 12' lr.Y' lr.X' lr.Y - 12);  	_resizePath.CloseFigure ();  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,UpdatePaths,The following statement contains a magic number: if (_resizable) {  	Point lr = new Point ();  	//get the lower right point based on pin placement  	switch (_pinPlacement) {  	case DaggerNodePinPlacement.Indent:  	case DaggerNodePinPlacement.Inset:  		lr = new Point (Width - 1' Height - 1);  		break;  	case DaggerNodePinPlacement.Outset:  		if (_parentGraph != null) {  			lr = new Point (Width - 1 - _parentGraph.PinLegend.PinSize' Height - 1);  		}  		else {  			lr = new Point (Width - 11' Height - 1);  		}  		break;  	default:  		break;  	}  	//create a small triangle in lower right corner  	_resizePath = new GraphicsPath ();  	_resizePath.StartFigure ();  	_resizePath.AddLine (lr.X' lr.Y' lr.X - 12' lr.Y);  	_resizePath.AddLine (lr.X - 12' lr.Y' lr.X' lr.Y - 12);  	_resizePath.CloseFigure ();  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,UpdatePaths,The following statement contains a magic number: if (_resizable) {  	Point lr = new Point ();  	//get the lower right point based on pin placement  	switch (_pinPlacement) {  	case DaggerNodePinPlacement.Indent:  	case DaggerNodePinPlacement.Inset:  		lr = new Point (Width - 1' Height - 1);  		break;  	case DaggerNodePinPlacement.Outset:  		if (_parentGraph != null) {  			lr = new Point (Width - 1 - _parentGraph.PinLegend.PinSize' Height - 1);  		}  		else {  			lr = new Point (Width - 11' Height - 1);  		}  		break;  	default:  		break;  	}  	//create a small triangle in lower right corner  	_resizePath = new GraphicsPath ();  	_resizePath.StartFigure ();  	_resizePath.AddLine (lr.X' lr.Y' lr.X - 12' lr.Y);  	_resizePath.AddLine (lr.X - 12' lr.Y' lr.X' lr.Y - 12);  	_resizePath.CloseFigure ();  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,UpdatePaths,The following statement contains a magic number: if (_resizable) {  	Point lr = new Point ();  	//get the lower right point based on pin placement  	switch (_pinPlacement) {  	case DaggerNodePinPlacement.Indent:  	case DaggerNodePinPlacement.Inset:  		lr = new Point (Width - 1' Height - 1);  		break;  	case DaggerNodePinPlacement.Outset:  		if (_parentGraph != null) {  			lr = new Point (Width - 1 - _parentGraph.PinLegend.PinSize' Height - 1);  		}  		else {  			lr = new Point (Width - 11' Height - 1);  		}  		break;  	default:  		break;  	}  	//create a small triangle in lower right corner  	_resizePath = new GraphicsPath ();  	_resizePath.StartFigure ();  	_resizePath.AddLine (lr.X' lr.Y' lr.X - 12' lr.Y);  	_resizePath.AddLine (lr.X - 12' lr.Y' lr.X' lr.Y - 12);  	_resizePath.CloseFigure ();  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,UpdatePaths,The following statement contains a magic number: switch (_pinPlacement) {  case DaggerNodePinPlacement.Indent:  case DaggerNodePinPlacement.Inset:  	lr = new Point (Width - 1' Height - 1);  	break;  case DaggerNodePinPlacement.Outset:  	if (_parentGraph != null) {  		lr = new Point (Width - 1 - _parentGraph.PinLegend.PinSize' Height - 1);  	}  	else {  		lr = new Point (Width - 11' Height - 1);  	}  	break;  default:  	break;  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,UpdatePaths,The following statement contains a magic number: if (_parentGraph != null) {  	lr = new Point (Width - 1 - _parentGraph.PinLegend.PinSize' Height - 1);  }  else {  	lr = new Point (Width - 11' Height - 1);  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,UpdatePaths,The following statement contains a magic number: lr = new Point (Width - 11' Height - 1);  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,UpdatePaths,The following statement contains a magic number: _resizePath.AddLine (lr.X' lr.Y' lr.X - 12' lr.Y);  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,UpdatePaths,The following statement contains a magic number: _resizePath.AddLine (lr.X - 12' lr.Y' lr.X' lr.Y - 12);  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,UpdatePaths,The following statement contains a magic number: _resizePath.AddLine (lr.X - 12' lr.Y' lr.X' lr.Y - 12);  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,UpdateTargetRegions,The following statement contains a magic number: if ((_node.InputPins != null) && (_node.OutputPins != null)) {  	int inputpintop = (Height - ((_node.InputPins.MutexAvailablePins.Count * PinSize) + ((_node.InputPins.MutexAvailablePins.Count - 1) * _pinSpacing))) / 2;  	int outputpintop = (Height - ((_node.OutputPins.MutexAvailablePins.Count * PinSize) + ((_node.OutputPins.MutexAvailablePins.Count - 1) * _pinSpacing))) / 2;  	for (int i = 0; i < _node.InputPins.MutexAvailablePins.Count; i++) {  		if ((_node.InputPins.MutexAvailablePins [i].PinUIElements as PinUI).TargetRegion != null) {  			(_node.InputPins.MutexAvailablePins [i].PinUIElements as PinUI).TargetRegion.Dispose ();  			(_node.InputPins.MutexAvailablePins [i].PinUIElements as PinUI).TargetRegion = null;  		}  		(_node.InputPins.MutexAvailablePins [i].PinUIElements as PinUI).TargetRegion = new Region (new Rectangle (0' inputpintop' PinSize' PinSize));  		(_node.InputPins.MutexAvailablePins [i].PinUIElements as PinUI).PinLocation = new Point (0' inputpintop);  		inputpintop += PinSize + _pinSpacing;  	}  	for (int i = 0; i < _node.OutputPins.MutexAvailablePins.Count; i++) {  		if ((_node.OutputPins.MutexAvailablePins [i].PinUIElements as PinUI).TargetRegion != null) {  			(_node.OutputPins.MutexAvailablePins [i].PinUIElements as PinUI).TargetRegion.Dispose ();  			(_node.OutputPins.MutexAvailablePins [i].PinUIElements as PinUI).TargetRegion = null;  		}  		(_node.OutputPins.MutexAvailablePins [i].PinUIElements as PinUI).TargetRegion = new Region (new Rectangle (Width - PinSize' outputpintop' PinSize' PinSize));  		(OutputPins.MutexAvailablePins [i].PinUIElements as PinUI).PinLocation = new Point (Width - PinSize' outputpintop);  		outputpintop += PinSize + _pinSpacing;  	}  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,UpdateTargetRegions,The following statement contains a magic number: if ((_node.InputPins != null) && (_node.OutputPins != null)) {  	int inputpintop = (Height - ((_node.InputPins.MutexAvailablePins.Count * PinSize) + ((_node.InputPins.MutexAvailablePins.Count - 1) * _pinSpacing))) / 2;  	int outputpintop = (Height - ((_node.OutputPins.MutexAvailablePins.Count * PinSize) + ((_node.OutputPins.MutexAvailablePins.Count - 1) * _pinSpacing))) / 2;  	for (int i = 0; i < _node.InputPins.MutexAvailablePins.Count; i++) {  		if ((_node.InputPins.MutexAvailablePins [i].PinUIElements as PinUI).TargetRegion != null) {  			(_node.InputPins.MutexAvailablePins [i].PinUIElements as PinUI).TargetRegion.Dispose ();  			(_node.InputPins.MutexAvailablePins [i].PinUIElements as PinUI).TargetRegion = null;  		}  		(_node.InputPins.MutexAvailablePins [i].PinUIElements as PinUI).TargetRegion = new Region (new Rectangle (0' inputpintop' PinSize' PinSize));  		(_node.InputPins.MutexAvailablePins [i].PinUIElements as PinUI).PinLocation = new Point (0' inputpintop);  		inputpintop += PinSize + _pinSpacing;  	}  	for (int i = 0; i < _node.OutputPins.MutexAvailablePins.Count; i++) {  		if ((_node.OutputPins.MutexAvailablePins [i].PinUIElements as PinUI).TargetRegion != null) {  			(_node.OutputPins.MutexAvailablePins [i].PinUIElements as PinUI).TargetRegion.Dispose ();  			(_node.OutputPins.MutexAvailablePins [i].PinUIElements as PinUI).TargetRegion = null;  		}  		(_node.OutputPins.MutexAvailablePins [i].PinUIElements as PinUI).TargetRegion = new Region (new Rectangle (Width - PinSize' outputpintop' PinSize' PinSize));  		(OutputPins.MutexAvailablePins [i].PinUIElements as PinUI).PinLocation = new Point (Width - PinSize' outputpintop);  		outputpintop += PinSize + _pinSpacing;  	}  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,GetTopClippedRoundedRect,The following statement contains a magic number: gp.AddLine (0' captionSize / 2' baseRect.Width' captionSize / 2);  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,GetTopClippedRoundedRect,The following statement contains a magic number: gp.AddLine (0' captionSize / 2' baseRect.Width' captionSize / 2);  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,GetTopClippedRoundedRect,The following statement contains a magic number: if (_pinPlacement == DaggerNodePinPlacement.Indent) {  	//indent right if any output pins  	if ((_node.OutputPins != null) && (_node.OutputPins.Count > 0)) {  		gp.AddLine (baseRect.Width' captionSize / 2' baseRect.Width' captionSize);  		PointF point1 = new PointF (baseRect.Width' captionSize);  		PointF point2 = new PointF (baseRect.Width - PinSize * _pinIndent' captionSize + PinSize);  		PointF point3 = new PointF (baseRect.Width - PinSize * _pinIndent' baseRect.Height - radius - PinSize);  		PointF point4 = new PointF (baseRect.Width' baseRect.Height - radius);  		gp.AddBezier (point1' point2' point3' point4);  	}  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,GetTopClippedRoundedRect,The following statement contains a magic number: if ((_node.OutputPins != null) && (_node.OutputPins.Count > 0)) {  	gp.AddLine (baseRect.Width' captionSize / 2' baseRect.Width' captionSize);  	PointF point1 = new PointF (baseRect.Width' captionSize);  	PointF point2 = new PointF (baseRect.Width - PinSize * _pinIndent' captionSize + PinSize);  	PointF point3 = new PointF (baseRect.Width - PinSize * _pinIndent' baseRect.Height - radius - PinSize);  	PointF point4 = new PointF (baseRect.Width' baseRect.Height - radius);  	gp.AddBezier (point1' point2' point3' point4);  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,GetTopClippedRoundedRect,The following statement contains a magic number: gp.AddLine (baseRect.Width' captionSize / 2' baseRect.Width' captionSize);  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,GetTopClippedRoundedRect,The following statement contains a magic number: gp.AddArc (baseRect.Width - radius' baseRect.Height - radius' radius' radius' 0' 90);  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,GetTopClippedRoundedRect,The following statement contains a magic number: gp.AddArc (0' baseRect.Height - radius' radius' radius' 90' 90);  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,GetTopClippedRoundedRect,The following statement contains a magic number: gp.AddArc (0' baseRect.Height - radius' radius' radius' 90' 90);  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,GetTopClippedRoundedRect,The following statement contains a magic number: if (_pinPlacement == DaggerNodePinPlacement.Indent) {  	//indent left if any input pins  	if ((_node.InputPins != null) && (_node.InputPins.Count > 0)) {  		PointF point4 = new PointF (0' captionSize);  		PointF point3 = new PointF (PinSize * _pinIndent' captionSize + PinSize);  		PointF point2 = new PointF (PinSize * _pinIndent' baseRect.Height - radius - PinSize);  		PointF point1 = new PointF (0' baseRect.Height - radius);  		gp.AddBezier (point1' point2' point3' point4);  		gp.AddLine (0' captionSize' 0' captionSize / 2);  	}  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,GetTopClippedRoundedRect,The following statement contains a magic number: if ((_node.InputPins != null) && (_node.InputPins.Count > 0)) {  	PointF point4 = new PointF (0' captionSize);  	PointF point3 = new PointF (PinSize * _pinIndent' captionSize + PinSize);  	PointF point2 = new PointF (PinSize * _pinIndent' baseRect.Height - radius - PinSize);  	PointF point1 = new PointF (0' baseRect.Height - radius);  	gp.AddBezier (point1' point2' point3' point4);  	gp.AddLine (0' captionSize' 0' captionSize / 2);  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,GetTopClippedRoundedRect,The following statement contains a magic number: gp.AddLine (0' captionSize' 0' captionSize / 2);  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,GetRoundedRect,The following statement contains a magic number: if (radius >= (Math.Min (baseRect.Width' baseRect.Height)) / 2.5)  	return GetCapsule (baseRect);  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,GetRoundedRect,The following statement contains a magic number: gp.AddArc (baseRect.X' baseRect.Y' radius' radius' 180' 90);  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,GetRoundedRect,The following statement contains a magic number: gp.AddArc (baseRect.X' baseRect.Y' radius' radius' 180' 90);  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,GetRoundedRect,The following statement contains a magic number: gp.AddArc (baseRect.X + baseRect.Width - radius' baseRect.Y' radius' radius' 270' 90);  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,GetRoundedRect,The following statement contains a magic number: gp.AddArc (baseRect.X + baseRect.Width - radius' baseRect.Y' radius' radius' 270' 90);  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,GetRoundedRect,The following statement contains a magic number: gp.AddArc (baseRect.X + baseRect.Width - radius' baseRect.Y + baseRect.Height - radius' radius' radius' 0' 90);  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,GetRoundedRect,The following statement contains a magic number: gp.AddArc (baseRect.X' baseRect.Y + baseRect.Height - radius' radius' radius' 90' 90);  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,GetRoundedRect,The following statement contains a magic number: gp.AddArc (baseRect.X' baseRect.Y + baseRect.Height - radius' radius' radius' 90' 90);  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,GetCapsule,The following statement contains a magic number: try {  	if (baseRect.Width > baseRect.Height) {  		// return horizontal capsule   		diameter = baseRect.Height;  		SizeF sizeF = new SizeF (diameter' diameter);  		arc = new RectangleF (baseRect.Location' sizeF);  		path.AddArc (arc' 90' 180);  		arc.X = baseRect.Right - diameter;  		path.AddArc (arc' 270' 180);  	}  	else if (baseRect.Width < baseRect.Height) {  		// return vertical capsule   		diameter = baseRect.Width;  		SizeF sizeF = new SizeF (diameter' diameter);  		arc = new RectangleF (baseRect.Location' sizeF);  		path.AddArc (arc' 180' 180);  		arc.Y = baseRect.Bottom - diameter;  		path.AddArc (arc' 0' 180);  	}  	else {  		// return circle   		path.AddEllipse (baseRect);  	}  }  catch (Exception) {  	path.AddEllipse (baseRect);  }  finally {  	path.CloseFigure ();  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,GetCapsule,The following statement contains a magic number: try {  	if (baseRect.Width > baseRect.Height) {  		// return horizontal capsule   		diameter = baseRect.Height;  		SizeF sizeF = new SizeF (diameter' diameter);  		arc = new RectangleF (baseRect.Location' sizeF);  		path.AddArc (arc' 90' 180);  		arc.X = baseRect.Right - diameter;  		path.AddArc (arc' 270' 180);  	}  	else if (baseRect.Width < baseRect.Height) {  		// return vertical capsule   		diameter = baseRect.Width;  		SizeF sizeF = new SizeF (diameter' diameter);  		arc = new RectangleF (baseRect.Location' sizeF);  		path.AddArc (arc' 180' 180);  		arc.Y = baseRect.Bottom - diameter;  		path.AddArc (arc' 0' 180);  	}  	else {  		// return circle   		path.AddEllipse (baseRect);  	}  }  catch (Exception) {  	path.AddEllipse (baseRect);  }  finally {  	path.CloseFigure ();  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,GetCapsule,The following statement contains a magic number: try {  	if (baseRect.Width > baseRect.Height) {  		// return horizontal capsule   		diameter = baseRect.Height;  		SizeF sizeF = new SizeF (diameter' diameter);  		arc = new RectangleF (baseRect.Location' sizeF);  		path.AddArc (arc' 90' 180);  		arc.X = baseRect.Right - diameter;  		path.AddArc (arc' 270' 180);  	}  	else if (baseRect.Width < baseRect.Height) {  		// return vertical capsule   		diameter = baseRect.Width;  		SizeF sizeF = new SizeF (diameter' diameter);  		arc = new RectangleF (baseRect.Location' sizeF);  		path.AddArc (arc' 180' 180);  		arc.Y = baseRect.Bottom - diameter;  		path.AddArc (arc' 0' 180);  	}  	else {  		// return circle   		path.AddEllipse (baseRect);  	}  }  catch (Exception) {  	path.AddEllipse (baseRect);  }  finally {  	path.CloseFigure ();  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,GetCapsule,The following statement contains a magic number: try {  	if (baseRect.Width > baseRect.Height) {  		// return horizontal capsule   		diameter = baseRect.Height;  		SizeF sizeF = new SizeF (diameter' diameter);  		arc = new RectangleF (baseRect.Location' sizeF);  		path.AddArc (arc' 90' 180);  		arc.X = baseRect.Right - diameter;  		path.AddArc (arc' 270' 180);  	}  	else if (baseRect.Width < baseRect.Height) {  		// return vertical capsule   		diameter = baseRect.Width;  		SizeF sizeF = new SizeF (diameter' diameter);  		arc = new RectangleF (baseRect.Location' sizeF);  		path.AddArc (arc' 180' 180);  		arc.Y = baseRect.Bottom - diameter;  		path.AddArc (arc' 0' 180);  	}  	else {  		// return circle   		path.AddEllipse (baseRect);  	}  }  catch (Exception) {  	path.AddEllipse (baseRect);  }  finally {  	path.CloseFigure ();  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,GetCapsule,The following statement contains a magic number: try {  	if (baseRect.Width > baseRect.Height) {  		// return horizontal capsule   		diameter = baseRect.Height;  		SizeF sizeF = new SizeF (diameter' diameter);  		arc = new RectangleF (baseRect.Location' sizeF);  		path.AddArc (arc' 90' 180);  		arc.X = baseRect.Right - diameter;  		path.AddArc (arc' 270' 180);  	}  	else if (baseRect.Width < baseRect.Height) {  		// return vertical capsule   		diameter = baseRect.Width;  		SizeF sizeF = new SizeF (diameter' diameter);  		arc = new RectangleF (baseRect.Location' sizeF);  		path.AddArc (arc' 180' 180);  		arc.Y = baseRect.Bottom - diameter;  		path.AddArc (arc' 0' 180);  	}  	else {  		// return circle   		path.AddEllipse (baseRect);  	}  }  catch (Exception) {  	path.AddEllipse (baseRect);  }  finally {  	path.CloseFigure ();  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,GetCapsule,The following statement contains a magic number: try {  	if (baseRect.Width > baseRect.Height) {  		// return horizontal capsule   		diameter = baseRect.Height;  		SizeF sizeF = new SizeF (diameter' diameter);  		arc = new RectangleF (baseRect.Location' sizeF);  		path.AddArc (arc' 90' 180);  		arc.X = baseRect.Right - diameter;  		path.AddArc (arc' 270' 180);  	}  	else if (baseRect.Width < baseRect.Height) {  		// return vertical capsule   		diameter = baseRect.Width;  		SizeF sizeF = new SizeF (diameter' diameter);  		arc = new RectangleF (baseRect.Location' sizeF);  		path.AddArc (arc' 180' 180);  		arc.Y = baseRect.Bottom - diameter;  		path.AddArc (arc' 0' 180);  	}  	else {  		// return circle   		path.AddEllipse (baseRect);  	}  }  catch (Exception) {  	path.AddEllipse (baseRect);  }  finally {  	path.CloseFigure ();  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,GetCapsule,The following statement contains a magic number: try {  	if (baseRect.Width > baseRect.Height) {  		// return horizontal capsule   		diameter = baseRect.Height;  		SizeF sizeF = new SizeF (diameter' diameter);  		arc = new RectangleF (baseRect.Location' sizeF);  		path.AddArc (arc' 90' 180);  		arc.X = baseRect.Right - diameter;  		path.AddArc (arc' 270' 180);  	}  	else if (baseRect.Width < baseRect.Height) {  		// return vertical capsule   		diameter = baseRect.Width;  		SizeF sizeF = new SizeF (diameter' diameter);  		arc = new RectangleF (baseRect.Location' sizeF);  		path.AddArc (arc' 180' 180);  		arc.Y = baseRect.Bottom - diameter;  		path.AddArc (arc' 0' 180);  	}  	else {  		// return circle   		path.AddEllipse (baseRect);  	}  }  catch (Exception) {  	path.AddEllipse (baseRect);  }  finally {  	path.CloseFigure ();  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,GetCapsule,The following statement contains a magic number: if (baseRect.Width > baseRect.Height) {  	// return horizontal capsule   	diameter = baseRect.Height;  	SizeF sizeF = new SizeF (diameter' diameter);  	arc = new RectangleF (baseRect.Location' sizeF);  	path.AddArc (arc' 90' 180);  	arc.X = baseRect.Right - diameter;  	path.AddArc (arc' 270' 180);  }  else if (baseRect.Width < baseRect.Height) {  	// return vertical capsule   	diameter = baseRect.Width;  	SizeF sizeF = new SizeF (diameter' diameter);  	arc = new RectangleF (baseRect.Location' sizeF);  	path.AddArc (arc' 180' 180);  	arc.Y = baseRect.Bottom - diameter;  	path.AddArc (arc' 0' 180);  }  else {  	// return circle   	path.AddEllipse (baseRect);  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,GetCapsule,The following statement contains a magic number: if (baseRect.Width > baseRect.Height) {  	// return horizontal capsule   	diameter = baseRect.Height;  	SizeF sizeF = new SizeF (diameter' diameter);  	arc = new RectangleF (baseRect.Location' sizeF);  	path.AddArc (arc' 90' 180);  	arc.X = baseRect.Right - diameter;  	path.AddArc (arc' 270' 180);  }  else if (baseRect.Width < baseRect.Height) {  	// return vertical capsule   	diameter = baseRect.Width;  	SizeF sizeF = new SizeF (diameter' diameter);  	arc = new RectangleF (baseRect.Location' sizeF);  	path.AddArc (arc' 180' 180);  	arc.Y = baseRect.Bottom - diameter;  	path.AddArc (arc' 0' 180);  }  else {  	// return circle   	path.AddEllipse (baseRect);  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,GetCapsule,The following statement contains a magic number: if (baseRect.Width > baseRect.Height) {  	// return horizontal capsule   	diameter = baseRect.Height;  	SizeF sizeF = new SizeF (diameter' diameter);  	arc = new RectangleF (baseRect.Location' sizeF);  	path.AddArc (arc' 90' 180);  	arc.X = baseRect.Right - diameter;  	path.AddArc (arc' 270' 180);  }  else if (baseRect.Width < baseRect.Height) {  	// return vertical capsule   	diameter = baseRect.Width;  	SizeF sizeF = new SizeF (diameter' diameter);  	arc = new RectangleF (baseRect.Location' sizeF);  	path.AddArc (arc' 180' 180);  	arc.Y = baseRect.Bottom - diameter;  	path.AddArc (arc' 0' 180);  }  else {  	// return circle   	path.AddEllipse (baseRect);  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,GetCapsule,The following statement contains a magic number: if (baseRect.Width > baseRect.Height) {  	// return horizontal capsule   	diameter = baseRect.Height;  	SizeF sizeF = new SizeF (diameter' diameter);  	arc = new RectangleF (baseRect.Location' sizeF);  	path.AddArc (arc' 90' 180);  	arc.X = baseRect.Right - diameter;  	path.AddArc (arc' 270' 180);  }  else if (baseRect.Width < baseRect.Height) {  	// return vertical capsule   	diameter = baseRect.Width;  	SizeF sizeF = new SizeF (diameter' diameter);  	arc = new RectangleF (baseRect.Location' sizeF);  	path.AddArc (arc' 180' 180);  	arc.Y = baseRect.Bottom - diameter;  	path.AddArc (arc' 0' 180);  }  else {  	// return circle   	path.AddEllipse (baseRect);  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,GetCapsule,The following statement contains a magic number: if (baseRect.Width > baseRect.Height) {  	// return horizontal capsule   	diameter = baseRect.Height;  	SizeF sizeF = new SizeF (diameter' diameter);  	arc = new RectangleF (baseRect.Location' sizeF);  	path.AddArc (arc' 90' 180);  	arc.X = baseRect.Right - diameter;  	path.AddArc (arc' 270' 180);  }  else if (baseRect.Width < baseRect.Height) {  	// return vertical capsule   	diameter = baseRect.Width;  	SizeF sizeF = new SizeF (diameter' diameter);  	arc = new RectangleF (baseRect.Location' sizeF);  	path.AddArc (arc' 180' 180);  	arc.Y = baseRect.Bottom - diameter;  	path.AddArc (arc' 0' 180);  }  else {  	// return circle   	path.AddEllipse (baseRect);  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,GetCapsule,The following statement contains a magic number: if (baseRect.Width > baseRect.Height) {  	// return horizontal capsule   	diameter = baseRect.Height;  	SizeF sizeF = new SizeF (diameter' diameter);  	arc = new RectangleF (baseRect.Location' sizeF);  	path.AddArc (arc' 90' 180);  	arc.X = baseRect.Right - diameter;  	path.AddArc (arc' 270' 180);  }  else if (baseRect.Width < baseRect.Height) {  	// return vertical capsule   	diameter = baseRect.Width;  	SizeF sizeF = new SizeF (diameter' diameter);  	arc = new RectangleF (baseRect.Location' sizeF);  	path.AddArc (arc' 180' 180);  	arc.Y = baseRect.Bottom - diameter;  	path.AddArc (arc' 0' 180);  }  else {  	// return circle   	path.AddEllipse (baseRect);  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,GetCapsule,The following statement contains a magic number: if (baseRect.Width > baseRect.Height) {  	// return horizontal capsule   	diameter = baseRect.Height;  	SizeF sizeF = new SizeF (diameter' diameter);  	arc = new RectangleF (baseRect.Location' sizeF);  	path.AddArc (arc' 90' 180);  	arc.X = baseRect.Right - diameter;  	path.AddArc (arc' 270' 180);  }  else if (baseRect.Width < baseRect.Height) {  	// return vertical capsule   	diameter = baseRect.Width;  	SizeF sizeF = new SizeF (diameter' diameter);  	arc = new RectangleF (baseRect.Location' sizeF);  	path.AddArc (arc' 180' 180);  	arc.Y = baseRect.Bottom - diameter;  	path.AddArc (arc' 0' 180);  }  else {  	// return circle   	path.AddEllipse (baseRect);  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,GetCapsule,The following statement contains a magic number: path.AddArc (arc' 90' 180);  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,GetCapsule,The following statement contains a magic number: path.AddArc (arc' 90' 180);  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,GetCapsule,The following statement contains a magic number: path.AddArc (arc' 270' 180);  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,GetCapsule,The following statement contains a magic number: path.AddArc (arc' 270' 180);  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,GetCapsule,The following statement contains a magic number: if (baseRect.Width < baseRect.Height) {  	// return vertical capsule   	diameter = baseRect.Width;  	SizeF sizeF = new SizeF (diameter' diameter);  	arc = new RectangleF (baseRect.Location' sizeF);  	path.AddArc (arc' 180' 180);  	arc.Y = baseRect.Bottom - diameter;  	path.AddArc (arc' 0' 180);  }  else {  	// return circle   	path.AddEllipse (baseRect);  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,GetCapsule,The following statement contains a magic number: if (baseRect.Width < baseRect.Height) {  	// return vertical capsule   	diameter = baseRect.Width;  	SizeF sizeF = new SizeF (diameter' diameter);  	arc = new RectangleF (baseRect.Location' sizeF);  	path.AddArc (arc' 180' 180);  	arc.Y = baseRect.Bottom - diameter;  	path.AddArc (arc' 0' 180);  }  else {  	// return circle   	path.AddEllipse (baseRect);  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,GetCapsule,The following statement contains a magic number: if (baseRect.Width < baseRect.Height) {  	// return vertical capsule   	diameter = baseRect.Width;  	SizeF sizeF = new SizeF (diameter' diameter);  	arc = new RectangleF (baseRect.Location' sizeF);  	path.AddArc (arc' 180' 180);  	arc.Y = baseRect.Bottom - diameter;  	path.AddArc (arc' 0' 180);  }  else {  	// return circle   	path.AddEllipse (baseRect);  }  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,GetCapsule,The following statement contains a magic number: path.AddArc (arc' 180' 180);  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,GetCapsule,The following statement contains a magic number: path.AddArc (arc' 180' 180);  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,GetCapsule,The following statement contains a magic number: path.AddArc (arc' 0' 180);  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,CalculateLayout,The following statement contains a magic number: _internalControl.Size = new Size (this.Width - (_internalControlPadding * 2) - (PinSize * 2)' this.Height - (_internalControlPadding * 2) - _captionSize);  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,CalculateLayout,The following statement contains a magic number: _internalControl.Size = new Size (this.Width - (_internalControlPadding * 2) - (PinSize * 2)' this.Height - (_internalControlPadding * 2) - _captionSize);  
Magic Number,DaggerLib.UI.Windows,DaggerUINode,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUINode.cs,CalculateLayout,The following statement contains a magic number: _internalControl.Size = new Size (this.Width - (_internalControlPadding * 2) - (PinSize * 2)' this.Height - (_internalControlPadding * 2) - _captionSize);  
Magic Number,DaggerLib.UI.Windows,DaggerOverlay,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIOverlay.cs,OnShown,The following statement contains a magic number: this.Opacity = 0.55;  
Magic Number,DaggerLib.UI.Windows,DaggerOverlay,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIOverlay.cs,OnMouseMove,The following statement contains a magic number: switch (editstate) {  case DaggerNodeAlterState.Move:  	{  		Point oldPos = PointToScreen (e.Location);  		Point newPos = new Point (oldPos.X - origin.X' oldPos.Y - origin.Y);  		this.Location = newPos;  	}  	break;  case DaggerNodeAlterState.SouthEast:  	{  		int neww = Math.Max (e.X' _minWidth) + _resizeOffsetX;  		int newh = Math.Max (e.Y' _minHeight) + _resizeOffsetY;  		//transform the region to new size  		int pinSize = (_control as DaggerUINode).PinSize;  		switch ((_control as DaggerUINode).PinPlacement) {  		case DaggerNodePinPlacement.Indent:  		case DaggerNodePinPlacement.Inset:  			break;  		case DaggerNodePinPlacement.Outset:  			{  				Region = new Region (new Rectangle (pinSize' 0' neww - pinSize * 2' newh));  			}  			break;  		default:  			break;  		}  		this.Width = neww;  		this.Height = newh;  	}  	break;  default:  	break;  }  
Magic Number,DaggerLib.UI.Windows,DaggerOverlay,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIOverlay.cs,OnMouseMove,The following statement contains a magic number: switch ((_control as DaggerUINode).PinPlacement) {  case DaggerNodePinPlacement.Indent:  case DaggerNodePinPlacement.Inset:  	break;  case DaggerNodePinPlacement.Outset:  	{  		Region = new Region (new Rectangle (pinSize' 0' neww - pinSize * 2' newh));  	}  	break;  default:  	break;  }  
Magic Number,DaggerLib.UI.Windows,DaggerOverlay,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerUIOverlay.cs,OnMouseMove,The following statement contains a magic number: Region = new Region (new Rectangle (pinSize' 0' neww - pinSize * 2' newh));  
Magic Number,DaggerLib.UI.Windows,GenericValueEditor,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,LayoutSubControls,The following statement contains a magic number: if (paintValueSupported)  	previewControl.SetBounds (cRect.X + 1' cRect.Y + 1' ShowPreviewOnly ? Math.Max (0' cRect.Width - buttonWidth - 2) : Math.Min (PAINT_VALUE_WIDTH' Math.Max (0' cRect.Width - buttonWidth - 2))' Math.Max (0' cRect.Height - 2));  
Magic Number,DaggerLib.UI.Windows,GenericValueEditor,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,LayoutSubControls,The following statement contains a magic number: if (paintValueSupported)  	previewControl.SetBounds (cRect.X + 1' cRect.Y + 1' ShowPreviewOnly ? Math.Max (0' cRect.Width - buttonWidth - 2) : Math.Min (PAINT_VALUE_WIDTH' Math.Max (0' cRect.Width - buttonWidth - 2))' Math.Max (0' cRect.Height - 2));  
Magic Number,DaggerLib.UI.Windows,GenericValueEditor,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,LayoutSubControls,The following statement contains a magic number: if (paintValueSupported)  	previewControl.SetBounds (cRect.X + 1' cRect.Y + 1' ShowPreviewOnly ? Math.Max (0' cRect.Width - buttonWidth - 2) : Math.Min (PAINT_VALUE_WIDTH' Math.Max (0' cRect.Width - buttonWidth - 2))' Math.Max (0' cRect.Height - 2));  
Magic Number,DaggerLib.UI.Windows,GenericValueEditor,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,LayoutSubControls,The following statement contains a magic number: previewControl.SetBounds (cRect.X + 1' cRect.Y + 1' ShowPreviewOnly ? Math.Max (0' cRect.Width - buttonWidth - 2) : Math.Min (PAINT_VALUE_WIDTH' Math.Max (0' cRect.Width - buttonWidth - 2))' Math.Max (0' cRect.Height - 2));  
Magic Number,DaggerLib.UI.Windows,GenericValueEditor,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,LayoutSubControls,The following statement contains a magic number: previewControl.SetBounds (cRect.X + 1' cRect.Y + 1' ShowPreviewOnly ? Math.Max (0' cRect.Width - buttonWidth - 2) : Math.Min (PAINT_VALUE_WIDTH' Math.Max (0' cRect.Width - buttonWidth - 2))' Math.Max (0' cRect.Height - 2));  
Magic Number,DaggerLib.UI.Windows,GenericValueEditor,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,LayoutSubControls,The following statement contains a magic number: previewControl.SetBounds (cRect.X + 1' cRect.Y + 1' ShowPreviewOnly ? Math.Max (0' cRect.Width - buttonWidth - 2) : Math.Min (PAINT_VALUE_WIDTH' Math.Max (0' cRect.Width - buttonWidth - 2))' Math.Max (0' cRect.Height - 2));  
Magic Number,DaggerLib.UI.Windows,GenericValueEditor,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,LayoutSubControls,The following statement contains a magic number: if (!(ShowPreviewOnly && paintValueSupported)) {  	int leftMargin = paintValueSupported ? PAINT_VALUE_WIDTH + 5 : 1;  	int topMargin = 0;  	switch (BorderStyle) {  	case BorderStyle.Fixed3D:  		topMargin = 1;  		break;  	case BorderStyle.FixedSingle:  		topMargin = 2;  		break;  	}  	textBox.SetBounds (cRect.X + leftMargin' cRect.Y + topMargin' Math.Max (0' cRect.Width - buttonWidth - leftMargin)' Math.Max (0' cRect.Height));  }  else  	textBox.Width = 0;  
Magic Number,DaggerLib.UI.Windows,GenericValueEditor,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,LayoutSubControls,The following statement contains a magic number: if (!(ShowPreviewOnly && paintValueSupported)) {  	int leftMargin = paintValueSupported ? PAINT_VALUE_WIDTH + 5 : 1;  	int topMargin = 0;  	switch (BorderStyle) {  	case BorderStyle.Fixed3D:  		topMargin = 1;  		break;  	case BorderStyle.FixedSingle:  		topMargin = 2;  		break;  	}  	textBox.SetBounds (cRect.X + leftMargin' cRect.Y + topMargin' Math.Max (0' cRect.Width - buttonWidth - leftMargin)' Math.Max (0' cRect.Height));  }  else  	textBox.Width = 0;  
Magic Number,DaggerLib.UI.Windows,GenericValueEditor,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,LayoutSubControls,The following statement contains a magic number: switch (BorderStyle) {  case BorderStyle.Fixed3D:  	topMargin = 1;  	break;  case BorderStyle.FixedSingle:  	topMargin = 2;  	break;  }  
Magic Number,DaggerLib.UI.Windows,GenericValueEditor,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,LayoutSubControls,The following statement contains a magic number: topMargin = 2;  
Magic Number,DaggerLib.UI.Windows,GenericValueEditor,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,OnKeyPress,The following statement contains a magic number: if (!(IsTextEditable ()))  	ke.Handled = true;  else if (ke.KeyChar == (char)13 || ke.KeyChar == (char)27) {  	ke.Handled = true;  	// avoid beep done by TextBox when  	// multiline is not allowed  }  
Magic Number,DaggerLib.UI.Windows,GenericValueEditor,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,OnKeyPress,The following statement contains a magic number: if (!(IsTextEditable ()))  	ke.Handled = true;  else if (ke.KeyChar == (char)13 || ke.KeyChar == (char)27) {  	ke.Handled = true;  	// avoid beep done by TextBox when  	// multiline is not allowed  }  
Magic Number,DaggerLib.UI.Windows,GenericValueEditor,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,OnKeyPress,The following statement contains a magic number: if (ke.KeyChar == (char)13 || ke.KeyChar == (char)27) {  	ke.Handled = true;  	// avoid beep done by TextBox when  	// multiline is not allowed  }  
Magic Number,DaggerLib.UI.Windows,GenericValueEditor,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,OnKeyPress,The following statement contains a magic number: if (ke.KeyChar == (char)13 || ke.KeyChar == (char)27) {  	ke.Handled = true;  	// avoid beep done by TextBox when  	// multiline is not allowed  }  
Magic Number,DaggerLib.UI.Windows,EditorButton,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,OnPaint,The following statement contains a magic number: if (dialog) {  	base.OnPaint (pe);  	// draws dot dot dot.  	int x = r.X + r.Width / 2 - 5;  	int y = r.Bottom - 5;  	Brush brush = new SolidBrush (Enabled ? SystemColors.ControlText : SystemColors.GrayText);  	g.FillRectangle (brush' x' y' 2' 2);  	g.FillRectangle (brush' x + 4' y' 2' 2);  	g.FillRectangle (brush' x + 8' y' 2' 2);  	brush.Dispose ();  }  else  	ControlPaint.DrawComboButton (g' ClientRectangle' !Enabled ? ButtonState.Inactive : (pushed ? ButtonState.Pushed : ButtonState.Normal));  
Magic Number,DaggerLib.UI.Windows,EditorButton,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,OnPaint,The following statement contains a magic number: if (dialog) {  	base.OnPaint (pe);  	// draws dot dot dot.  	int x = r.X + r.Width / 2 - 5;  	int y = r.Bottom - 5;  	Brush brush = new SolidBrush (Enabled ? SystemColors.ControlText : SystemColors.GrayText);  	g.FillRectangle (brush' x' y' 2' 2);  	g.FillRectangle (brush' x + 4' y' 2' 2);  	g.FillRectangle (brush' x + 8' y' 2' 2);  	brush.Dispose ();  }  else  	ControlPaint.DrawComboButton (g' ClientRectangle' !Enabled ? ButtonState.Inactive : (pushed ? ButtonState.Pushed : ButtonState.Normal));  
Magic Number,DaggerLib.UI.Windows,EditorButton,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,OnPaint,The following statement contains a magic number: if (dialog) {  	base.OnPaint (pe);  	// draws dot dot dot.  	int x = r.X + r.Width / 2 - 5;  	int y = r.Bottom - 5;  	Brush brush = new SolidBrush (Enabled ? SystemColors.ControlText : SystemColors.GrayText);  	g.FillRectangle (brush' x' y' 2' 2);  	g.FillRectangle (brush' x + 4' y' 2' 2);  	g.FillRectangle (brush' x + 8' y' 2' 2);  	brush.Dispose ();  }  else  	ControlPaint.DrawComboButton (g' ClientRectangle' !Enabled ? ButtonState.Inactive : (pushed ? ButtonState.Pushed : ButtonState.Normal));  
Magic Number,DaggerLib.UI.Windows,EditorButton,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,OnPaint,The following statement contains a magic number: if (dialog) {  	base.OnPaint (pe);  	// draws dot dot dot.  	int x = r.X + r.Width / 2 - 5;  	int y = r.Bottom - 5;  	Brush brush = new SolidBrush (Enabled ? SystemColors.ControlText : SystemColors.GrayText);  	g.FillRectangle (brush' x' y' 2' 2);  	g.FillRectangle (brush' x + 4' y' 2' 2);  	g.FillRectangle (brush' x + 8' y' 2' 2);  	brush.Dispose ();  }  else  	ControlPaint.DrawComboButton (g' ClientRectangle' !Enabled ? ButtonState.Inactive : (pushed ? ButtonState.Pushed : ButtonState.Normal));  
Magic Number,DaggerLib.UI.Windows,EditorButton,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,OnPaint,The following statement contains a magic number: if (dialog) {  	base.OnPaint (pe);  	// draws dot dot dot.  	int x = r.X + r.Width / 2 - 5;  	int y = r.Bottom - 5;  	Brush brush = new SolidBrush (Enabled ? SystemColors.ControlText : SystemColors.GrayText);  	g.FillRectangle (brush' x' y' 2' 2);  	g.FillRectangle (brush' x + 4' y' 2' 2);  	g.FillRectangle (brush' x + 8' y' 2' 2);  	brush.Dispose ();  }  else  	ControlPaint.DrawComboButton (g' ClientRectangle' !Enabled ? ButtonState.Inactive : (pushed ? ButtonState.Pushed : ButtonState.Normal));  
Magic Number,DaggerLib.UI.Windows,EditorButton,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,OnPaint,The following statement contains a magic number: if (dialog) {  	base.OnPaint (pe);  	// draws dot dot dot.  	int x = r.X + r.Width / 2 - 5;  	int y = r.Bottom - 5;  	Brush brush = new SolidBrush (Enabled ? SystemColors.ControlText : SystemColors.GrayText);  	g.FillRectangle (brush' x' y' 2' 2);  	g.FillRectangle (brush' x + 4' y' 2' 2);  	g.FillRectangle (brush' x + 8' y' 2' 2);  	brush.Dispose ();  }  else  	ControlPaint.DrawComboButton (g' ClientRectangle' !Enabled ? ButtonState.Inactive : (pushed ? ButtonState.Pushed : ButtonState.Normal));  
Magic Number,DaggerLib.UI.Windows,EditorButton,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,OnPaint,The following statement contains a magic number: if (dialog) {  	base.OnPaint (pe);  	// draws dot dot dot.  	int x = r.X + r.Width / 2 - 5;  	int y = r.Bottom - 5;  	Brush brush = new SolidBrush (Enabled ? SystemColors.ControlText : SystemColors.GrayText);  	g.FillRectangle (brush' x' y' 2' 2);  	g.FillRectangle (brush' x + 4' y' 2' 2);  	g.FillRectangle (brush' x + 8' y' 2' 2);  	brush.Dispose ();  }  else  	ControlPaint.DrawComboButton (g' ClientRectangle' !Enabled ? ButtonState.Inactive : (pushed ? ButtonState.Pushed : ButtonState.Normal));  
Magic Number,DaggerLib.UI.Windows,EditorButton,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,OnPaint,The following statement contains a magic number: if (dialog) {  	base.OnPaint (pe);  	// draws dot dot dot.  	int x = r.X + r.Width / 2 - 5;  	int y = r.Bottom - 5;  	Brush brush = new SolidBrush (Enabled ? SystemColors.ControlText : SystemColors.GrayText);  	g.FillRectangle (brush' x' y' 2' 2);  	g.FillRectangle (brush' x + 4' y' 2' 2);  	g.FillRectangle (brush' x + 8' y' 2' 2);  	brush.Dispose ();  }  else  	ControlPaint.DrawComboButton (g' ClientRectangle' !Enabled ? ButtonState.Inactive : (pushed ? ButtonState.Pushed : ButtonState.Normal));  
Magic Number,DaggerLib.UI.Windows,EditorButton,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,OnPaint,The following statement contains a magic number: if (dialog) {  	base.OnPaint (pe);  	// draws dot dot dot.  	int x = r.X + r.Width / 2 - 5;  	int y = r.Bottom - 5;  	Brush brush = new SolidBrush (Enabled ? SystemColors.ControlText : SystemColors.GrayText);  	g.FillRectangle (brush' x' y' 2' 2);  	g.FillRectangle (brush' x + 4' y' 2' 2);  	g.FillRectangle (brush' x + 8' y' 2' 2);  	brush.Dispose ();  }  else  	ControlPaint.DrawComboButton (g' ClientRectangle' !Enabled ? ButtonState.Inactive : (pushed ? ButtonState.Pushed : ButtonState.Normal));  
Magic Number,DaggerLib.UI.Windows,EditorButton,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,OnPaint,The following statement contains a magic number: if (dialog) {  	base.OnPaint (pe);  	// draws dot dot dot.  	int x = r.X + r.Width / 2 - 5;  	int y = r.Bottom - 5;  	Brush brush = new SolidBrush (Enabled ? SystemColors.ControlText : SystemColors.GrayText);  	g.FillRectangle (brush' x' y' 2' 2);  	g.FillRectangle (brush' x + 4' y' 2' 2);  	g.FillRectangle (brush' x + 8' y' 2' 2);  	brush.Dispose ();  }  else  	ControlPaint.DrawComboButton (g' ClientRectangle' !Enabled ? ButtonState.Inactive : (pushed ? ButtonState.Pushed : ButtonState.Normal));  
Magic Number,DaggerLib.UI.Windows,EditorButton,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,OnPaint,The following statement contains a magic number: if (dialog) {  	base.OnPaint (pe);  	// draws dot dot dot.  	int x = r.X + r.Width / 2 - 5;  	int y = r.Bottom - 5;  	Brush brush = new SolidBrush (Enabled ? SystemColors.ControlText : SystemColors.GrayText);  	g.FillRectangle (brush' x' y' 2' 2);  	g.FillRectangle (brush' x + 4' y' 2' 2);  	g.FillRectangle (brush' x + 8' y' 2' 2);  	brush.Dispose ();  }  else  	ControlPaint.DrawComboButton (g' ClientRectangle' !Enabled ? ButtonState.Inactive : (pushed ? ButtonState.Pushed : ButtonState.Normal));  
Magic Number,DaggerLib.UI.Windows,EditorButton,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,OnPaint,The following statement contains a magic number: g.FillRectangle (brush' x' y' 2' 2);  
Magic Number,DaggerLib.UI.Windows,EditorButton,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,OnPaint,The following statement contains a magic number: g.FillRectangle (brush' x' y' 2' 2);  
Magic Number,DaggerLib.UI.Windows,EditorButton,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,OnPaint,The following statement contains a magic number: g.FillRectangle (brush' x + 4' y' 2' 2);  
Magic Number,DaggerLib.UI.Windows,EditorButton,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,OnPaint,The following statement contains a magic number: g.FillRectangle (brush' x + 4' y' 2' 2);  
Magic Number,DaggerLib.UI.Windows,EditorButton,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,OnPaint,The following statement contains a magic number: g.FillRectangle (brush' x + 4' y' 2' 2);  
Magic Number,DaggerLib.UI.Windows,EditorButton,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,OnPaint,The following statement contains a magic number: g.FillRectangle (brush' x + 8' y' 2' 2);  
Magic Number,DaggerLib.UI.Windows,EditorButton,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,OnPaint,The following statement contains a magic number: g.FillRectangle (brush' x + 8' y' 2' 2);  
Magic Number,DaggerLib.UI.Windows,EditorButton,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,OnPaint,The following statement contains a magic number: g.FillRectangle (brush' x + 8' y' 2' 2);  
Magic Number,DaggerLib.UI.Windows,StandardValuesUIEditor,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,EditValue,The following statement contains a magic number: if (edSvc != null) {  	if (listbox == null) {  		listbox = new StandardValuesListBox (editor);  		listbox.SelectedIndexChanged += new EventHandler (OnListBoxChanged);  	}  	object[] values = editor.GetStandardValues ();  	listbox.Items.Clear ();  	int width = 0;  	Font font = listbox.Font;  	// Add the standard values in the list box and  	// measure the text at the same time.  	using (Graphics g = listbox.CreateGraphics ()) {  		foreach (object item in values) {  			if (!listbox.Items.Contains (item)) {  				string valueString = editor.GetValueAsText (item);  				if (!editor.ShowPreviewOnly)  					width = (int)Math.Max (width' g.MeasureString (valueString' font).Width);  				listbox.Items.Add (item);  			}  		}  	}  	if (editor.paintValueSupported)  		width += GenericValueEditor.PAINT_VALUE_WIDTH + 4;  	Rectangle bounds = editor.Bounds;  	listbox.SelectedItem = value;  	listbox.Height = Math.Max (font.Height + 2' Math.Min (200' listbox.PreferredHeight));  	listbox.Width = Math.Max (width' bounds.Width);  	edSvc.DropDownControl (listbox);  	if (listbox.SelectedItem != null)  		return listbox.SelectedItem;  	else  		return value;  }  
Magic Number,DaggerLib.UI.Windows,StandardValuesUIEditor,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,EditValue,The following statement contains a magic number: if (edSvc != null) {  	if (listbox == null) {  		listbox = new StandardValuesListBox (editor);  		listbox.SelectedIndexChanged += new EventHandler (OnListBoxChanged);  	}  	object[] values = editor.GetStandardValues ();  	listbox.Items.Clear ();  	int width = 0;  	Font font = listbox.Font;  	// Add the standard values in the list box and  	// measure the text at the same time.  	using (Graphics g = listbox.CreateGraphics ()) {  		foreach (object item in values) {  			if (!listbox.Items.Contains (item)) {  				string valueString = editor.GetValueAsText (item);  				if (!editor.ShowPreviewOnly)  					width = (int)Math.Max (width' g.MeasureString (valueString' font).Width);  				listbox.Items.Add (item);  			}  		}  	}  	if (editor.paintValueSupported)  		width += GenericValueEditor.PAINT_VALUE_WIDTH + 4;  	Rectangle bounds = editor.Bounds;  	listbox.SelectedItem = value;  	listbox.Height = Math.Max (font.Height + 2' Math.Min (200' listbox.PreferredHeight));  	listbox.Width = Math.Max (width' bounds.Width);  	edSvc.DropDownControl (listbox);  	if (listbox.SelectedItem != null)  		return listbox.SelectedItem;  	else  		return value;  }  
Magic Number,DaggerLib.UI.Windows,StandardValuesUIEditor,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,EditValue,The following statement contains a magic number: if (edSvc != null) {  	if (listbox == null) {  		listbox = new StandardValuesListBox (editor);  		listbox.SelectedIndexChanged += new EventHandler (OnListBoxChanged);  	}  	object[] values = editor.GetStandardValues ();  	listbox.Items.Clear ();  	int width = 0;  	Font font = listbox.Font;  	// Add the standard values in the list box and  	// measure the text at the same time.  	using (Graphics g = listbox.CreateGraphics ()) {  		foreach (object item in values) {  			if (!listbox.Items.Contains (item)) {  				string valueString = editor.GetValueAsText (item);  				if (!editor.ShowPreviewOnly)  					width = (int)Math.Max (width' g.MeasureString (valueString' font).Width);  				listbox.Items.Add (item);  			}  		}  	}  	if (editor.paintValueSupported)  		width += GenericValueEditor.PAINT_VALUE_WIDTH + 4;  	Rectangle bounds = editor.Bounds;  	listbox.SelectedItem = value;  	listbox.Height = Math.Max (font.Height + 2' Math.Min (200' listbox.PreferredHeight));  	listbox.Width = Math.Max (width' bounds.Width);  	edSvc.DropDownControl (listbox);  	if (listbox.SelectedItem != null)  		return listbox.SelectedItem;  	else  		return value;  }  
Magic Number,DaggerLib.UI.Windows,StandardValuesUIEditor,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,EditValue,The following statement contains a magic number: if (editor.paintValueSupported)  	width += GenericValueEditor.PAINT_VALUE_WIDTH + 4;  
Magic Number,DaggerLib.UI.Windows,StandardValuesUIEditor,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,EditValue,The following statement contains a magic number: width += GenericValueEditor.PAINT_VALUE_WIDTH + 4;  
Magic Number,DaggerLib.UI.Windows,StandardValuesUIEditor,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,EditValue,The following statement contains a magic number: listbox.Height = Math.Max (font.Height + 2' Math.Min (200' listbox.PreferredHeight));  
Magic Number,DaggerLib.UI.Windows,StandardValuesUIEditor,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,EditValue,The following statement contains a magic number: listbox.Height = Math.Max (font.Height + 2' Math.Min (200' listbox.PreferredHeight));  
Magic Number,DaggerLib.UI.Windows,StandardValuesListBox,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,OnDrawItem,The following statement contains a magic number: if (editor.paintValueSupported) {  	Pen pen = new Pen (ForeColor);  	try {  		Rectangle r = e.Bounds;  		r.Height -= 1;  		if (editor.ShowPreviewOnly) {  			r.X += 2;  			r.Width -= 5;  		}  		else {  			r.Width = GenericValueEditor.PAINT_VALUE_WIDTH;  			r.X += 2;  			bounds.X += GenericValueEditor.PAINT_VALUE_WIDTH + 2;  			bounds.Width -= GenericValueEditor.PAINT_VALUE_WIDTH + 2;  		}  		editor.Editor.PaintValue (value' e.Graphics' r);  		e.Graphics.DrawRectangle (pen' r);  	}  	finally {  		pen.Dispose ();  	}  }  
Magic Number,DaggerLib.UI.Windows,StandardValuesListBox,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,OnDrawItem,The following statement contains a magic number: if (editor.paintValueSupported) {  	Pen pen = new Pen (ForeColor);  	try {  		Rectangle r = e.Bounds;  		r.Height -= 1;  		if (editor.ShowPreviewOnly) {  			r.X += 2;  			r.Width -= 5;  		}  		else {  			r.Width = GenericValueEditor.PAINT_VALUE_WIDTH;  			r.X += 2;  			bounds.X += GenericValueEditor.PAINT_VALUE_WIDTH + 2;  			bounds.Width -= GenericValueEditor.PAINT_VALUE_WIDTH + 2;  		}  		editor.Editor.PaintValue (value' e.Graphics' r);  		e.Graphics.DrawRectangle (pen' r);  	}  	finally {  		pen.Dispose ();  	}  }  
Magic Number,DaggerLib.UI.Windows,StandardValuesListBox,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,OnDrawItem,The following statement contains a magic number: if (editor.paintValueSupported) {  	Pen pen = new Pen (ForeColor);  	try {  		Rectangle r = e.Bounds;  		r.Height -= 1;  		if (editor.ShowPreviewOnly) {  			r.X += 2;  			r.Width -= 5;  		}  		else {  			r.Width = GenericValueEditor.PAINT_VALUE_WIDTH;  			r.X += 2;  			bounds.X += GenericValueEditor.PAINT_VALUE_WIDTH + 2;  			bounds.Width -= GenericValueEditor.PAINT_VALUE_WIDTH + 2;  		}  		editor.Editor.PaintValue (value' e.Graphics' r);  		e.Graphics.DrawRectangle (pen' r);  	}  	finally {  		pen.Dispose ();  	}  }  
Magic Number,DaggerLib.UI.Windows,StandardValuesListBox,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,OnDrawItem,The following statement contains a magic number: if (editor.paintValueSupported) {  	Pen pen = new Pen (ForeColor);  	try {  		Rectangle r = e.Bounds;  		r.Height -= 1;  		if (editor.ShowPreviewOnly) {  			r.X += 2;  			r.Width -= 5;  		}  		else {  			r.Width = GenericValueEditor.PAINT_VALUE_WIDTH;  			r.X += 2;  			bounds.X += GenericValueEditor.PAINT_VALUE_WIDTH + 2;  			bounds.Width -= GenericValueEditor.PAINT_VALUE_WIDTH + 2;  		}  		editor.Editor.PaintValue (value' e.Graphics' r);  		e.Graphics.DrawRectangle (pen' r);  	}  	finally {  		pen.Dispose ();  	}  }  
Magic Number,DaggerLib.UI.Windows,StandardValuesListBox,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,OnDrawItem,The following statement contains a magic number: if (editor.paintValueSupported) {  	Pen pen = new Pen (ForeColor);  	try {  		Rectangle r = e.Bounds;  		r.Height -= 1;  		if (editor.ShowPreviewOnly) {  			r.X += 2;  			r.Width -= 5;  		}  		else {  			r.Width = GenericValueEditor.PAINT_VALUE_WIDTH;  			r.X += 2;  			bounds.X += GenericValueEditor.PAINT_VALUE_WIDTH + 2;  			bounds.Width -= GenericValueEditor.PAINT_VALUE_WIDTH + 2;  		}  		editor.Editor.PaintValue (value' e.Graphics' r);  		e.Graphics.DrawRectangle (pen' r);  	}  	finally {  		pen.Dispose ();  	}  }  
Magic Number,DaggerLib.UI.Windows,StandardValuesListBox,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,OnDrawItem,The following statement contains a magic number: try {  	Rectangle r = e.Bounds;  	r.Height -= 1;  	if (editor.ShowPreviewOnly) {  		r.X += 2;  		r.Width -= 5;  	}  	else {  		r.Width = GenericValueEditor.PAINT_VALUE_WIDTH;  		r.X += 2;  		bounds.X += GenericValueEditor.PAINT_VALUE_WIDTH + 2;  		bounds.Width -= GenericValueEditor.PAINT_VALUE_WIDTH + 2;  	}  	editor.Editor.PaintValue (value' e.Graphics' r);  	e.Graphics.DrawRectangle (pen' r);  }  finally {  	pen.Dispose ();  }  
Magic Number,DaggerLib.UI.Windows,StandardValuesListBox,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,OnDrawItem,The following statement contains a magic number: try {  	Rectangle r = e.Bounds;  	r.Height -= 1;  	if (editor.ShowPreviewOnly) {  		r.X += 2;  		r.Width -= 5;  	}  	else {  		r.Width = GenericValueEditor.PAINT_VALUE_WIDTH;  		r.X += 2;  		bounds.X += GenericValueEditor.PAINT_VALUE_WIDTH + 2;  		bounds.Width -= GenericValueEditor.PAINT_VALUE_WIDTH + 2;  	}  	editor.Editor.PaintValue (value' e.Graphics' r);  	e.Graphics.DrawRectangle (pen' r);  }  finally {  	pen.Dispose ();  }  
Magic Number,DaggerLib.UI.Windows,StandardValuesListBox,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,OnDrawItem,The following statement contains a magic number: try {  	Rectangle r = e.Bounds;  	r.Height -= 1;  	if (editor.ShowPreviewOnly) {  		r.X += 2;  		r.Width -= 5;  	}  	else {  		r.Width = GenericValueEditor.PAINT_VALUE_WIDTH;  		r.X += 2;  		bounds.X += GenericValueEditor.PAINT_VALUE_WIDTH + 2;  		bounds.Width -= GenericValueEditor.PAINT_VALUE_WIDTH + 2;  	}  	editor.Editor.PaintValue (value' e.Graphics' r);  	e.Graphics.DrawRectangle (pen' r);  }  finally {  	pen.Dispose ();  }  
Magic Number,DaggerLib.UI.Windows,StandardValuesListBox,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,OnDrawItem,The following statement contains a magic number: try {  	Rectangle r = e.Bounds;  	r.Height -= 1;  	if (editor.ShowPreviewOnly) {  		r.X += 2;  		r.Width -= 5;  	}  	else {  		r.Width = GenericValueEditor.PAINT_VALUE_WIDTH;  		r.X += 2;  		bounds.X += GenericValueEditor.PAINT_VALUE_WIDTH + 2;  		bounds.Width -= GenericValueEditor.PAINT_VALUE_WIDTH + 2;  	}  	editor.Editor.PaintValue (value' e.Graphics' r);  	e.Graphics.DrawRectangle (pen' r);  }  finally {  	pen.Dispose ();  }  
Magic Number,DaggerLib.UI.Windows,StandardValuesListBox,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,OnDrawItem,The following statement contains a magic number: try {  	Rectangle r = e.Bounds;  	r.Height -= 1;  	if (editor.ShowPreviewOnly) {  		r.X += 2;  		r.Width -= 5;  	}  	else {  		r.Width = GenericValueEditor.PAINT_VALUE_WIDTH;  		r.X += 2;  		bounds.X += GenericValueEditor.PAINT_VALUE_WIDTH + 2;  		bounds.Width -= GenericValueEditor.PAINT_VALUE_WIDTH + 2;  	}  	editor.Editor.PaintValue (value' e.Graphics' r);  	e.Graphics.DrawRectangle (pen' r);  }  finally {  	pen.Dispose ();  }  
Magic Number,DaggerLib.UI.Windows,StandardValuesListBox,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,OnDrawItem,The following statement contains a magic number: if (editor.ShowPreviewOnly) {  	r.X += 2;  	r.Width -= 5;  }  else {  	r.Width = GenericValueEditor.PAINT_VALUE_WIDTH;  	r.X += 2;  	bounds.X += GenericValueEditor.PAINT_VALUE_WIDTH + 2;  	bounds.Width -= GenericValueEditor.PAINT_VALUE_WIDTH + 2;  }  
Magic Number,DaggerLib.UI.Windows,StandardValuesListBox,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,OnDrawItem,The following statement contains a magic number: if (editor.ShowPreviewOnly) {  	r.X += 2;  	r.Width -= 5;  }  else {  	r.Width = GenericValueEditor.PAINT_VALUE_WIDTH;  	r.X += 2;  	bounds.X += GenericValueEditor.PAINT_VALUE_WIDTH + 2;  	bounds.Width -= GenericValueEditor.PAINT_VALUE_WIDTH + 2;  }  
Magic Number,DaggerLib.UI.Windows,StandardValuesListBox,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,OnDrawItem,The following statement contains a magic number: if (editor.ShowPreviewOnly) {  	r.X += 2;  	r.Width -= 5;  }  else {  	r.Width = GenericValueEditor.PAINT_VALUE_WIDTH;  	r.X += 2;  	bounds.X += GenericValueEditor.PAINT_VALUE_WIDTH + 2;  	bounds.Width -= GenericValueEditor.PAINT_VALUE_WIDTH + 2;  }  
Magic Number,DaggerLib.UI.Windows,StandardValuesListBox,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,OnDrawItem,The following statement contains a magic number: if (editor.ShowPreviewOnly) {  	r.X += 2;  	r.Width -= 5;  }  else {  	r.Width = GenericValueEditor.PAINT_VALUE_WIDTH;  	r.X += 2;  	bounds.X += GenericValueEditor.PAINT_VALUE_WIDTH + 2;  	bounds.Width -= GenericValueEditor.PAINT_VALUE_WIDTH + 2;  }  
Magic Number,DaggerLib.UI.Windows,StandardValuesListBox,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,OnDrawItem,The following statement contains a magic number: if (editor.ShowPreviewOnly) {  	r.X += 2;  	r.Width -= 5;  }  else {  	r.Width = GenericValueEditor.PAINT_VALUE_WIDTH;  	r.X += 2;  	bounds.X += GenericValueEditor.PAINT_VALUE_WIDTH + 2;  	bounds.Width -= GenericValueEditor.PAINT_VALUE_WIDTH + 2;  }  
Magic Number,DaggerLib.UI.Windows,StandardValuesListBox,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,OnDrawItem,The following statement contains a magic number: r.X += 2;  
Magic Number,DaggerLib.UI.Windows,StandardValuesListBox,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,OnDrawItem,The following statement contains a magic number: r.Width -= 5;  
Magic Number,DaggerLib.UI.Windows,StandardValuesListBox,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,OnDrawItem,The following statement contains a magic number: r.X += 2;  
Magic Number,DaggerLib.UI.Windows,StandardValuesListBox,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,OnDrawItem,The following statement contains a magic number: bounds.X += GenericValueEditor.PAINT_VALUE_WIDTH + 2;  
Magic Number,DaggerLib.UI.Windows,StandardValuesListBox,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,OnDrawItem,The following statement contains a magic number: bounds.Width -= GenericValueEditor.PAINT_VALUE_WIDTH + 2;  
Magic Number,DaggerLib.UI.Windows,DropDownForm,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,OnCurrentControlResize,The following statement contains a magic number: if (currentControl != null) {  	width = Width;  	Size = new Size (2 + currentControl.Width' 2 + currentControl.Height);  	Left -= Width - width;  }  
Magic Number,DaggerLib.UI.Windows,DropDownForm,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,OnCurrentControlResize,The following statement contains a magic number: if (currentControl != null) {  	width = Width;  	Size = new Size (2 + currentControl.Width' 2 + currentControl.Height);  	Left -= Width - width;  }  
Magic Number,DaggerLib.UI.Windows,DropDownForm,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,OnCurrentControlResize,The following statement contains a magic number: Size = new Size (2 + currentControl.Width' 2 + currentControl.Height);  
Magic Number,DaggerLib.UI.Windows,DropDownForm,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,OnCurrentControlResize,The following statement contains a magic number: Size = new Size (2 + currentControl.Width' 2 + currentControl.Height);  
Magic Number,DaggerLib.UI.Windows,DropDownForm,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,SetBoundsCore,The following statement contains a magic number: if (currentControl != null) {  	currentControl.SetBounds (0' 0' width - 2' height - 2);  	width = currentControl.Width;  	height = currentControl.Height;  	if (height == 0 && currentControl is ListBox) {  		height = ((ListBox)currentControl).ItemHeight;  		currentControl.Height = height;  	}  	width = width + 2;  	height = height + 2;  }  
Magic Number,DaggerLib.UI.Windows,DropDownForm,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,SetBoundsCore,The following statement contains a magic number: if (currentControl != null) {  	currentControl.SetBounds (0' 0' width - 2' height - 2);  	width = currentControl.Width;  	height = currentControl.Height;  	if (height == 0 && currentControl is ListBox) {  		height = ((ListBox)currentControl).ItemHeight;  		currentControl.Height = height;  	}  	width = width + 2;  	height = height + 2;  }  
Magic Number,DaggerLib.UI.Windows,DropDownForm,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,SetBoundsCore,The following statement contains a magic number: if (currentControl != null) {  	currentControl.SetBounds (0' 0' width - 2' height - 2);  	width = currentControl.Width;  	height = currentControl.Height;  	if (height == 0 && currentControl is ListBox) {  		height = ((ListBox)currentControl).ItemHeight;  		currentControl.Height = height;  	}  	width = width + 2;  	height = height + 2;  }  
Magic Number,DaggerLib.UI.Windows,DropDownForm,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,SetBoundsCore,The following statement contains a magic number: if (currentControl != null) {  	currentControl.SetBounds (0' 0' width - 2' height - 2);  	width = currentControl.Width;  	height = currentControl.Height;  	if (height == 0 && currentControl is ListBox) {  		height = ((ListBox)currentControl).ItemHeight;  		currentControl.Height = height;  	}  	width = width + 2;  	height = height + 2;  }  
Magic Number,DaggerLib.UI.Windows,DropDownForm,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,SetBoundsCore,The following statement contains a magic number: currentControl.SetBounds (0' 0' width - 2' height - 2);  
Magic Number,DaggerLib.UI.Windows,DropDownForm,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,SetBoundsCore,The following statement contains a magic number: currentControl.SetBounds (0' 0' width - 2' height - 2);  
Magic Number,DaggerLib.UI.Windows,DropDownForm,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,SetBoundsCore,The following statement contains a magic number: width = width + 2;  
Magic Number,DaggerLib.UI.Windows,DropDownForm,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,SetBoundsCore,The following statement contains a magic number: height = height + 2;  
Magic Number,DaggerLib.UI.Windows,SimpleImageButton,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\SimpleImageButton.cs,SimpleImageButton,The following statement contains a magic number: m_wndToolTip.AutomaticDelay = 1000;  
Magic Number,DaggerLib.UI.Windows,SimpleImageButton,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\SimpleImageButton.cs,SimpleImageButton,The following statement contains a magic number: Width = 10;  
Magic Number,DaggerLib.UI.Windows,SimpleImageButton,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\SimpleImageButton.cs,SimpleImageButton,The following statement contains a magic number: Height = 10;  
Magic Number,DaggerLib.UI.Windows,UIGraphNavigator,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\UIGraphNavigator.cs,_uigraph_CanvasImageChanged,The following statement contains a magic number: if (_uigraph != null) {  	// get the Canvas Image  	Bitmap tempb = _uigraph.CanvasImage;  	// Calculate a new zoom rectangle  	if (((float)tempb.Height / (float)tempb.Width) < ((float)Height / (float)Width)) {  		_rzoom = new Rectangle (0' 0' Width' (int)((float)Width * ((float)tempb.Height / (float)tempb.Width)));  		_rzoom.Y = (Height - _rzoom.Height) / 2;  	}  	else {  		_rzoom = new Rectangle (0' 0' (int)((float)Height * ((float)tempb.Width / (float)tempb.Height))' Height);  		_rzoom.X = (Width - _rzoom.Width) / 2;  	}  	_rzoom.Width = Math.Max (1' _rzoom.Width);  	_rzoom.Height = Math.Max (1' _rzoom.Height);  	// stretch the image into the zoomed bitmap  	_canvasImage = new Bitmap (_rzoom.Width' _rzoom.Height);  	Graphics g = Graphics.FromImage (_canvasImage);  	g.InterpolationMode = System.Drawing.Drawing2D.InterpolationMode.Bilinear;  	g.DrawImage (tempb' new Rectangle (0' 0' _canvasImage.Width' _canvasImage.Height)' new Rectangle (0' 0' tempb.Width' tempb.Height)' GraphicsUnit.Pixel);  	g.Dispose ();  	tempb.Dispose ();  	// update the viewport position  	_uigraph_ViewportChanged (null' null);  	Invalidate (false);  }  
Magic Number,DaggerLib.UI.Windows,UIGraphNavigator,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\UIGraphNavigator.cs,_uigraph_CanvasImageChanged,The following statement contains a magic number: if (_uigraph != null) {  	// get the Canvas Image  	Bitmap tempb = _uigraph.CanvasImage;  	// Calculate a new zoom rectangle  	if (((float)tempb.Height / (float)tempb.Width) < ((float)Height / (float)Width)) {  		_rzoom = new Rectangle (0' 0' Width' (int)((float)Width * ((float)tempb.Height / (float)tempb.Width)));  		_rzoom.Y = (Height - _rzoom.Height) / 2;  	}  	else {  		_rzoom = new Rectangle (0' 0' (int)((float)Height * ((float)tempb.Width / (float)tempb.Height))' Height);  		_rzoom.X = (Width - _rzoom.Width) / 2;  	}  	_rzoom.Width = Math.Max (1' _rzoom.Width);  	_rzoom.Height = Math.Max (1' _rzoom.Height);  	// stretch the image into the zoomed bitmap  	_canvasImage = new Bitmap (_rzoom.Width' _rzoom.Height);  	Graphics g = Graphics.FromImage (_canvasImage);  	g.InterpolationMode = System.Drawing.Drawing2D.InterpolationMode.Bilinear;  	g.DrawImage (tempb' new Rectangle (0' 0' _canvasImage.Width' _canvasImage.Height)' new Rectangle (0' 0' tempb.Width' tempb.Height)' GraphicsUnit.Pixel);  	g.Dispose ();  	tempb.Dispose ();  	// update the viewport position  	_uigraph_ViewportChanged (null' null);  	Invalidate (false);  }  
Magic Number,DaggerLib.UI.Windows,UIGraphNavigator,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\UIGraphNavigator.cs,_uigraph_CanvasImageChanged,The following statement contains a magic number: if (((float)tempb.Height / (float)tempb.Width) < ((float)Height / (float)Width)) {  	_rzoom = new Rectangle (0' 0' Width' (int)((float)Width * ((float)tempb.Height / (float)tempb.Width)));  	_rzoom.Y = (Height - _rzoom.Height) / 2;  }  else {  	_rzoom = new Rectangle (0' 0' (int)((float)Height * ((float)tempb.Width / (float)tempb.Height))' Height);  	_rzoom.X = (Width - _rzoom.Width) / 2;  }  
Magic Number,DaggerLib.UI.Windows,UIGraphNavigator,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\UIGraphNavigator.cs,_uigraph_CanvasImageChanged,The following statement contains a magic number: if (((float)tempb.Height / (float)tempb.Width) < ((float)Height / (float)Width)) {  	_rzoom = new Rectangle (0' 0' Width' (int)((float)Width * ((float)tempb.Height / (float)tempb.Width)));  	_rzoom.Y = (Height - _rzoom.Height) / 2;  }  else {  	_rzoom = new Rectangle (0' 0' (int)((float)Height * ((float)tempb.Width / (float)tempb.Height))' Height);  	_rzoom.X = (Width - _rzoom.Width) / 2;  }  
Magic Number,DaggerLib.UI.Windows,UIGraphNavigator,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\UIGraphNavigator.cs,_uigraph_CanvasImageChanged,The following statement contains a magic number: _rzoom.Y = (Height - _rzoom.Height) / 2;  
Magic Number,DaggerLib.UI.Windows,UIGraphNavigator,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\UIGraphNavigator.cs,_uigraph_CanvasImageChanged,The following statement contains a magic number: _rzoom.X = (Width - _rzoom.Width) / 2;  
Magic Number,DaggerLib.UI.Windows,UIGraphNavigator,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\UIGraphNavigator.cs,OnPaintBackground,The following statement contains a magic number: if (_viewPort.X != 0f || _viewPort.Y != 0f || _viewPort.Width != 1f || _viewPort.Height != 1f) {  	// overlay the ViewPort Rectangle  	using (Brush pb = new SolidBrush (Color.FromArgb (100' _puckColor))) {  		e.Graphics.FillRectangle (pb' _viewPortRect);  	}  	using (Pen pp = new Pen (Color.FromArgb (175' _puckColor))) {  		e.Graphics.DrawRectangle (pp' _viewPortRect);  	}  }  
Magic Number,DaggerLib.UI.Windows,UIGraphNavigator,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\UIGraphNavigator.cs,OnPaintBackground,The following statement contains a magic number: if (_viewPort.X != 0f || _viewPort.Y != 0f || _viewPort.Width != 1f || _viewPort.Height != 1f) {  	// overlay the ViewPort Rectangle  	using (Brush pb = new SolidBrush (Color.FromArgb (100' _puckColor))) {  		e.Graphics.FillRectangle (pb' _viewPortRect);  	}  	using (Pen pp = new Pen (Color.FromArgb (175' _puckColor))) {  		e.Graphics.DrawRectangle (pp' _viewPortRect);  	}  }  
Magic Number,DaggerLib.UI.Windows,UIGraphNavigator,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\UIGraphNavigator.cs,OnPaintBackground,The following statement contains a magic number: using (Brush pb = new SolidBrush (Color.FromArgb (100' _puckColor))) {  	e.Graphics.FillRectangle (pb' _viewPortRect);  }  
Magic Number,DaggerLib.UI.Windows,UIGraphNavigator,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\UIGraphNavigator.cs,OnPaintBackground,The following statement contains a magic number: using (Pen pp = new Pen (Color.FromArgb (175' _puckColor))) {  	e.Graphics.DrawRectangle (pp' _viewPortRect);  }  
Magic Number,PropertyGridEx,PropertyGridEx,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerPropertyGrid\PropertyGridEx\PropertyGridEx.cs,Refresh,The following statement contains a magic number: if (bAutoSizeProperties) {  	AutoSizeSplitter (32);  }  
Magic Number,PropertyGridEx,PropertyGridEx,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerPropertyGrid\PropertyGridEx\PropertyGridEx.cs,Refresh,The following statement contains a magic number: AutoSizeSplitter (32);  
Magic Number,PropertyGridEx,PropertyGridEx,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerPropertyGrid\PropertyGridEx\PropertyGridEx.cs,OnResize,The following statement contains a magic number: if (bAutoSizeProperties) {  	AutoSizeSplitter (32);  }  
Magic Number,PropertyGridEx,PropertyGridEx,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerPropertyGrid\PropertyGridEx\PropertyGridEx.cs,OnResize,The following statement contains a magic number: AutoSizeSplitter (32);  
Missing Default,DaggerLib.UI.Windows,GenericValueEditor,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\GenericValueEditor.cs,LayoutSubControls,The following switch statement is missing a default case: switch (BorderStyle) {  case BorderStyle.Fixed3D:  	topMargin = 1;  	break;  case BorderStyle.FixedSingle:  	topMargin = 2;  	break;  }  
Missing Default,PropertyGridEx,BrowsableTypeConverter,C:\repos\FerozAhmed_DSGraphEdit\DaggerLib.UI.Windows\DaggerPropertyGrid\PropertyGridEx\BrowsableTypeConverter.cs,ConvertTo,The following switch statement is missing a default case: switch (attribute1.LabelStyle) {  case LabelStyle.lsNormal: {  	return base.ConvertTo (context' culture' RuntimeHelpers.GetObjectValue (value)' destinationType);  }  case LabelStyle.lsTypeName: {  	return ("(" + value.GetType ().Name + ")");  }  case LabelStyle.lsEllipsis: {  	return "(...)";  }  }  
