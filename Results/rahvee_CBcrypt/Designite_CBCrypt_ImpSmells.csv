Implementation smell,Namespace,Class,File,Method,Description
Long Statement,Org.CBCrypt,Challenge,C:\repos\rahvee_CBcrypt\CBcrypt\CBcrypt\Challenge.cs,TryValidateChallengeResponse,The length of the statement  "			if (response.ChallengeResponseBytes == null || (response.ChallengeResponseBytes.Length != challengeResponseCheck.Length)) { " is 123.
Long Statement,Org.CBCrypt,Challenge,C:\repos\rahvee_CBcrypt\CBcrypt\CBcrypt\Challenge.cs,TryObsoleteValidateChallengeResponse,The length of the statement  "			if (response.ChallengeResponseBytes == null || (response.ChallengeResponseBytes.Length != challengeResponseCheck.Length)) { " is 123.
Long Statement,Org.CBCrypt,ChallengeResponse,C:\repos\rahvee_CBcrypt\CBcrypt\CBcrypt\ChallengeResponse.cs,GetObsoleteChallengeResponse,The length of the statement  "			response.ChallengeResponseBytes = Challenge.GenerateChallengeResponseBytes(challengeFromServer.ChallengeBytes' obsoleteSharedSecret); " is 133.
Magic Number,Org.CBCrypt,CBCrypt,C:\repos\rahvee_CBcrypt\CBcrypt\CBcrypt\CBCrypt.cs,DoRateLimitingFunction,The following statement contains a magic number: const int dkLength = 32;
Magic Number,Org.CBCrypt,CBCrypt,C:\repos\rahvee_CBcrypt\CBcrypt\CBcrypt\CBCrypt.cs,DoRateLimitingFunction,The following statement contains a magic number: byte[] retVal = CryptSharp.Utility.SCrypt.ComputeDerivedKey  				(  				key: LowCostSecret'         // scrypt will transform this into a high cost secret  				salt: new byte[16]'         // zero salt  				cost: 4096'                 // To scale the cost' scale this parameter.  Scale is approximately linear.  				blockSize: 8'               // this is a recommended default by the scrypt authors  				parallel: 1'                // this is a recommended default by the scrypt authors  				maxThreads: null'  				derivedKeyLength: dkLength  // 32 is surely large enough not to lose any entropy of the user supplied password  				);
Magic Number,Org.CBCrypt,CBCrypt,C:\repos\rahvee_CBcrypt\CBcrypt\CBcrypt\CBCrypt.cs,DoRateLimitingFunction,The following statement contains a magic number: byte[] retVal = CryptSharp.Utility.SCrypt.ComputeDerivedKey  				(  				key: LowCostSecret'         // scrypt will transform this into a high cost secret  				salt: new byte[16]'         // zero salt  				cost: 4096'                 // To scale the cost' scale this parameter.  Scale is approximately linear.  				blockSize: 8'               // this is a recommended default by the scrypt authors  				parallel: 1'                // this is a recommended default by the scrypt authors  				maxThreads: null'  				derivedKeyLength: dkLength  // 32 is surely large enough not to lose any entropy of the user supplied password  				);
Magic Number,Org.CBCrypt,CBCrypt,C:\repos\rahvee_CBcrypt\CBcrypt\CBcrypt\CBCrypt.cs,DoRateLimitingFunction,The following statement contains a magic number: byte[] retVal = CryptSharp.Utility.SCrypt.ComputeDerivedKey  				(  				key: LowCostSecret'         // scrypt will transform this into a high cost secret  				salt: new byte[16]'         // zero salt  				cost: 4096'                 // To scale the cost' scale this parameter.  Scale is approximately linear.  				blockSize: 8'               // this is a recommended default by the scrypt authors  				parallel: 1'                // this is a recommended default by the scrypt authors  				maxThreads: null'  				derivedKeyLength: dkLength  // 32 is surely large enough not to lose any entropy of the user supplied password  				);
Magic Number,Org.CBCrypt,CBCrypt,C:\repos\rahvee_CBcrypt\CBcrypt\CBcrypt\CBCrypt.cs,GetLowCostSecret,The following statement contains a magic number: using (var hashFunction = System.Security.Cryptography.SHA256.Create()) {  				// factorHashes : byte array that will contain the concatenated hashes of all the inputFactors  				int hashSizeInBytes = hashFunction.HashSize / 8;  				const int thisArgc = 3;  				var factorHashes = new byte[hashSizeInBytes * thisArgc];  				int factorHashesPos = 0;  				byte[] factorHash;    				factorHash = hashFunction.ComputeHash(CBCryptHostIdBytes);  				Array.Clear(CBCryptHostIdBytes' 0' CBCryptHostIdBytes.Length);  				Array.Copy(factorHash' 0' factorHashes' factorHashesPos' factorHash.Length);  				Array.Clear(factorHash' 0' factorHash.Length);  				factorHashesPos += hashSizeInBytes;    				factorHash = hashFunction.ComputeHash(usernameBytes);  				Array.Clear(usernameBytes' 0' usernameBytes.Length);  				Array.Copy(factorHash' 0' factorHashes' factorHashesPos' factorHash.Length);  				Array.Clear(factorHash' 0' factorHash.Length);  				factorHashesPos += hashSizeInBytes;    				factorHash = hashFunction.ComputeHash(passwordBytes);  				Array.Clear(passwordBytes' 0' passwordBytes.Length);  				Array.Copy(factorHash' 0' factorHashes' factorHashesPos' factorHash.Length);  				Array.Clear(factorHash' 0' factorHash.Length);  				// factorHashesPos += hashSizeInBytes;      // this is actually unnecessary cuz it's the last one    				byte[] output = hashFunction.ComputeHash(factorHashes);  				Array.Clear(factorHashes' 0' factorHashes.Length);  				return output;  			}
Magic Number,Org.CBCrypt,CBCrypt,C:\repos\rahvee_CBcrypt\CBcrypt\CBcrypt\CBCrypt.cs,GetLowCostSecret,The following statement contains a magic number: using (var hashFunction = System.Security.Cryptography.SHA256.Create()) {  				// factorHashes : byte array that will contain the concatenated hashes of all the inputFactors  				int hashSizeInBytes = hashFunction.HashSize / 8;  				const int thisArgc = 3;  				var factorHashes = new byte[hashSizeInBytes * thisArgc];  				int factorHashesPos = 0;  				byte[] factorHash;    				factorHash = hashFunction.ComputeHash(CBCryptHostIdBytes);  				Array.Clear(CBCryptHostIdBytes' 0' CBCryptHostIdBytes.Length);  				Array.Copy(factorHash' 0' factorHashes' factorHashesPos' factorHash.Length);  				Array.Clear(factorHash' 0' factorHash.Length);  				factorHashesPos += hashSizeInBytes;    				factorHash = hashFunction.ComputeHash(usernameBytes);  				Array.Clear(usernameBytes' 0' usernameBytes.Length);  				Array.Copy(factorHash' 0' factorHashes' factorHashesPos' factorHash.Length);  				Array.Clear(factorHash' 0' factorHash.Length);  				factorHashesPos += hashSizeInBytes;    				factorHash = hashFunction.ComputeHash(passwordBytes);  				Array.Clear(passwordBytes' 0' passwordBytes.Length);  				Array.Copy(factorHash' 0' factorHashes' factorHashesPos' factorHash.Length);  				Array.Clear(factorHash' 0' factorHash.Length);  				// factorHashesPos += hashSizeInBytes;      // this is actually unnecessary cuz it's the last one    				byte[] output = hashFunction.ComputeHash(factorHashes);  				Array.Clear(factorHashes' 0' factorHashes.Length);  				return output;  			}
Magic Number,Org.CBCrypt,CBCrypt,C:\repos\rahvee_CBcrypt\CBcrypt\CBcrypt\CBCrypt.cs,GenerateKeyPair,The following statement contains a magic number: var keyGenParams = new KeyGenerationParameters(seededPRNG' 256);
Magic Number,Org.CBCrypt,CBCryptKey,C:\repos\rahvee_CBcrypt\CBcrypt\CBcrypt\CBCryptKey.cs,GenerateKeys,The following statement contains a magic number: this.SymmetricKey = new byte[32];
