Implementation smell,Namespace,Class,File,Method,Description
Long Method,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The method has 201 lines of code.
Long Parameter List,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The method has 18 parameters.
Long Statement,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,MousePosition,The length of the statement  "	Vector2 vecMousePos = new Vector2 (((mX) / (float)game.Width - 0.5f) * game.Width * 2 * ZoomMulti - ViewPointV.X * game.Width * ZoomMulti' 0 - ((mY) / (float)game.Height - 0.5f) * game.Height * 2 * ZoomMulti - ViewPointV.Y * game.Height * ZoomMulti); " is 250.
Long Statement,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,LoadTexture,The length of the statement  "	BitmapData data = bitmap.LockBits (new Rectangle (0' 0' bitmap.Width' bitmap.Height)' ImageLockMode.ReadOnly' System.Drawing.Imaging.PixelFormat.Format32bppArgb); " is 162.
Long Statement,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,LoadTexture,The length of the statement  "	GL.TexImage2D (TextureTarget.Texture2D' 0' PixelInternalFormat.Rgba' data.Width' data.Height' 0' OpenTK.Graphics.OpenGL.PixelFormat.Bgra' PixelType.UnsignedByte' data.Scan0); " is 174.
Long Statement,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The length of the statement  "				ViewPointV = new Vector3 ((MoCdvec - MoCinitialvec).X / (game.Width * ZoomMulti)' (MoCdvec - MoCinitialvec).Y / (game.Height * ZoomMulti)' 0) + PrevViewpoint; " is 158.
Long Statement,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The length of the statement  "			GL.Ortho (-game.Width * ZoomMulti' game.Width * ZoomMulti' -game.Height * ZoomMulti' game.Height * ZoomMulti' 0.0' 4.0); " is 120.
Complex Conditional,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The conditional expression  "arrAlive [x' y] == 1 && x > 1 && y > 1 && x < iSizeOfGrid - 1 && y < iSizeOfGrid - 1"  is complex.
Empty Catch Block,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The method has an empty catch block.
Magic Number,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following statement contains a magic number: using (var game = new GameWindow (700' 500' new GraphicsMode (32' 24' 0' 8))) {  	//seed array  	Random rand = new Random ();  	for (int i = 200; i < iSizeOfGrid - 200; i++) {  		for (int z = 200; z < iSizeOfGrid - 200; z++) {  			arrAlive [i' z] = rand.Next (3);  		}  	}  	//Console.WriteLine (arrAlive.ToString ());  	//run at 60fps  	game.TargetRenderFrequency = 20;  	Matrix4 matrix = Matrix4.CreateTranslation (0' 0' 0);  	game.Load += (sender' e) =>  {  		// setup settings' load textures' sounds  		game.VSync = VSyncMode.On;  		game.Title = "LIFE";  	};  	game.Resize += (sender' e) =>  {  		GL.Viewport (0' 0' game.Width' game.Height);  	};  	//mouse click to add logic  	Vector2 MoCinitialvec = new Vector2 (0f' 0f);  	Vector2 MoCdvec = new Vector2 (0f' 0f);  	bool MoCdraw = false;  	Vector3 PrevViewpoint = new Vector3 (0f' 0f' 0f);  	//enable textures  	GL.Enable (EnableCap.Texture2D);  	GL.BlendFunc (BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);  	//mouse click event  	game.Mouse.ButtonDown += (sender' e) =>  {  		MoCinitialvec = MousePosition (e.X' e.Y' game);  		MoCdvec = MoCinitialvec;  		//start adding an object  		if (e.Button == MouseButton.Left) {  			MoCdraw = true;  		}  		//start moving viewpoint  		if (e.Button == MouseButton.Right) {  			PrevViewpoint = ViewPointV;  		}  	};  	game.Mouse.ButtonUp += (sender' e) =>  {  		//if left click - add object  		if (e.Button == MouseButton.Left) {  			MoCdraw = false;  		}  	};  	//scroll wheel - zoom in / out  	game.Mouse.WheelChanged += (sender' e) =>  {  		if (ZoomMulti - e.DeltaPrecise * 0.001f > 0) {  			ZoomMulti -= e.DeltaPrecise * 0.001f;  		}  	};  	//moving mouse  	game.Mouse.Move += (sender' e) =>  {  		//for adding object  		MoCdvec = MousePosition (e.X' e.Y' game);  		if (e.X < 5 && e.Y < 5) {  			if (SimulationSpeed == 0)  				SimulationSpeed = 20;  			else  				SimulationSpeed = 0;  		}  		if (e.Mouse.LeftButton == ButtonState.Pressed) {  			try {  				arrAlive [(int)MoCdvec.X' (int)MoCdvec.Y] = 1;  			}  			catch {  			}  		}  		//for moving viewpoint  		if (e.Mouse.RightButton == ButtonState.Pressed) {  			ViewPointV = new Vector3 ((MoCdvec - MoCinitialvec).X / (game.Width * ZoomMulti)' (MoCdvec - MoCinitialvec).Y / (game.Height * ZoomMulti)' 0) + PrevViewpoint;  		}  	};  	//keyboard input  	game.KeyPress += (sender' e) =>  {  		switch (e.KeyChar) {  		case 'f':  			game.WindowState = WindowState.Fullscreen;  			break;  		case 'p':  			if (SimulationSpeed == 0)  				SimulationSpeed = 20;  			else  				SimulationSpeed = 0;  			break;  		case 'c':  			//seed array  			for (int i = 0; i < iSizeOfGrid; i++) {  				for (int z = 0; z < iSizeOfGrid; z++) {  					arrAlive [i' z] = 0;  				}  			}  			break;  		}  	};  	//more keyboard input  	game.UpdateFrame += (sender' e) =>  {  		if (game.Keyboard [Key.Escape]) {  			game.Exit ();  		}  		if (game.Keyboard [Key.A]) {  			ViewPointV.X += 0.01f;  		}  		if (game.Keyboard [Key.D]) {  			ViewPointV.X -= 0.01f;  		}  		if (game.Keyboard [Key.W]) {  			ViewPointV.Y -= 0.01f;  		}  		if (game.Keyboard [Key.S]) {  			ViewPointV.Y += 0.01f;  		}  		if (game.Keyboard [Key.Z]) {  			ZoomMulti += 0.0001f;  		}  		if (game.Keyboard [Key.X] && ZoomMulti > 0.001f) {  			ZoomMulti -= 0.0001f;  		}  	};  	//for slowing down simulation  	int SimulationSlowDownStep = 0;  	game.RenderFrame += (sender' e) =>  {  		// render graphics  		//clears screen  		GL.Clear (ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);  		GL.MatrixMode (MatrixMode.Projection);  		Vector2 followPosition = new Vector2 (0' 0);  		matrix = Matrix4.CreateTranslation (ViewPointV);  		GL.LoadMatrix (ref matrix);  		GL.Ortho (-game.Width * ZoomMulti' game.Width * ZoomMulti' -game.Height * ZoomMulti' game.Height * ZoomMulti' 0.0' 4.0);  		//speedup / slowdown  		//slowdown?  		if (SimulationSpeed < 20) {  			//Stop simulation when sim speed = 0  			if (SimulationSpeed == 0)  				SimulationSlowDownStep = 1;  			SimulationSlowDownStep += SimulationSpeed;  			if (SimulationSlowDownStep > 20)  				SimulationSlowDownStep = 0;  		}  		else  			SimulationSlowDownStep = 0;  		Console.WriteLine (SimulationSpeed);  		for (int zx = 20; (zx < SimulationSpeed || zx == 20) && SimulationSlowDownStep == 0; zx++) {  			int['] arrNextTo = new int[iSizeOfGrid' iSizeOfGrid];  			//calculate neighbours  			for (int x = 0; x < iSizeOfGrid; x++) {  				for (int y = 0; y < iSizeOfGrid; y++) {  					if (arrAlive [x' y] == 1 && x > 1 && y > 1 && x < iSizeOfGrid - 1 && y < iSizeOfGrid - 1) {  						arrNextTo [x - 1' y - 1]++;  						arrNextTo [x - 1' y]++;  						arrNextTo [x - 1' y + 1]++;  						arrNextTo [x' y + 1]++;  						arrNextTo [x' y - 1]++;  						arrNextTo [x + 1' y - 1]++;  						arrNextTo [x + 1' y]++;  						arrNextTo [x + 1' y + 1]++;  					}  				}  			}  			//kill / revive  			for (int x = 0; x < iSizeOfGrid; x++) {  				for (int y = 0; y < iSizeOfGrid; y++) {  					if (arrNextTo [x' y] < 2 || arrNextTo [x' y] > 3) {  						arrAlive [x' y] = 0;  					}  					if (arrNextTo [x' y] == 3) {  						arrAlive [x' y] = 1;  					}  				}  			}  		}  		//Now draw the objects to the gamewindow  		GL.Color3 (Color.Yellow);  		GL.Begin (PrimitiveType.Quads);  		//Draw Cells  		for (int x = 0; x < iSizeOfGrid; x++) {  			//Console.WriteLine('n');  			for (int y = 0; y < iSizeOfGrid; y++) {  				//	Console.Write(arrAlive[x'y]);  				if (arrAlive [x' y] == 1) {  					GL.Vertex2 (x' y);  					GL.Vertex2 (x' y + 1);  					GL.Vertex2 (x + 1' y + 1);  					GL.Vertex2 (x + 1' y);  				}  			}  		}  		GL.End ();  		DrawCircle (30' ViewPointV.X' ViewPointV.Y' 1);  		Console.WriteLine (game.RenderFrequency);  		//load onto screen  		game.SwapBuffers ();  	};  	//run the game loop  	game.Run ();  }  
Magic Number,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following statement contains a magic number: using (var game = new GameWindow (700' 500' new GraphicsMode (32' 24' 0' 8))) {  	//seed array  	Random rand = new Random ();  	for (int i = 200; i < iSizeOfGrid - 200; i++) {  		for (int z = 200; z < iSizeOfGrid - 200; z++) {  			arrAlive [i' z] = rand.Next (3);  		}  	}  	//Console.WriteLine (arrAlive.ToString ());  	//run at 60fps  	game.TargetRenderFrequency = 20;  	Matrix4 matrix = Matrix4.CreateTranslation (0' 0' 0);  	game.Load += (sender' e) =>  {  		// setup settings' load textures' sounds  		game.VSync = VSyncMode.On;  		game.Title = "LIFE";  	};  	game.Resize += (sender' e) =>  {  		GL.Viewport (0' 0' game.Width' game.Height);  	};  	//mouse click to add logic  	Vector2 MoCinitialvec = new Vector2 (0f' 0f);  	Vector2 MoCdvec = new Vector2 (0f' 0f);  	bool MoCdraw = false;  	Vector3 PrevViewpoint = new Vector3 (0f' 0f' 0f);  	//enable textures  	GL.Enable (EnableCap.Texture2D);  	GL.BlendFunc (BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);  	//mouse click event  	game.Mouse.ButtonDown += (sender' e) =>  {  		MoCinitialvec = MousePosition (e.X' e.Y' game);  		MoCdvec = MoCinitialvec;  		//start adding an object  		if (e.Button == MouseButton.Left) {  			MoCdraw = true;  		}  		//start moving viewpoint  		if (e.Button == MouseButton.Right) {  			PrevViewpoint = ViewPointV;  		}  	};  	game.Mouse.ButtonUp += (sender' e) =>  {  		//if left click - add object  		if (e.Button == MouseButton.Left) {  			MoCdraw = false;  		}  	};  	//scroll wheel - zoom in / out  	game.Mouse.WheelChanged += (sender' e) =>  {  		if (ZoomMulti - e.DeltaPrecise * 0.001f > 0) {  			ZoomMulti -= e.DeltaPrecise * 0.001f;  		}  	};  	//moving mouse  	game.Mouse.Move += (sender' e) =>  {  		//for adding object  		MoCdvec = MousePosition (e.X' e.Y' game);  		if (e.X < 5 && e.Y < 5) {  			if (SimulationSpeed == 0)  				SimulationSpeed = 20;  			else  				SimulationSpeed = 0;  		}  		if (e.Mouse.LeftButton == ButtonState.Pressed) {  			try {  				arrAlive [(int)MoCdvec.X' (int)MoCdvec.Y] = 1;  			}  			catch {  			}  		}  		//for moving viewpoint  		if (e.Mouse.RightButton == ButtonState.Pressed) {  			ViewPointV = new Vector3 ((MoCdvec - MoCinitialvec).X / (game.Width * ZoomMulti)' (MoCdvec - MoCinitialvec).Y / (game.Height * ZoomMulti)' 0) + PrevViewpoint;  		}  	};  	//keyboard input  	game.KeyPress += (sender' e) =>  {  		switch (e.KeyChar) {  		case 'f':  			game.WindowState = WindowState.Fullscreen;  			break;  		case 'p':  			if (SimulationSpeed == 0)  				SimulationSpeed = 20;  			else  				SimulationSpeed = 0;  			break;  		case 'c':  			//seed array  			for (int i = 0; i < iSizeOfGrid; i++) {  				for (int z = 0; z < iSizeOfGrid; z++) {  					arrAlive [i' z] = 0;  				}  			}  			break;  		}  	};  	//more keyboard input  	game.UpdateFrame += (sender' e) =>  {  		if (game.Keyboard [Key.Escape]) {  			game.Exit ();  		}  		if (game.Keyboard [Key.A]) {  			ViewPointV.X += 0.01f;  		}  		if (game.Keyboard [Key.D]) {  			ViewPointV.X -= 0.01f;  		}  		if (game.Keyboard [Key.W]) {  			ViewPointV.Y -= 0.01f;  		}  		if (game.Keyboard [Key.S]) {  			ViewPointV.Y += 0.01f;  		}  		if (game.Keyboard [Key.Z]) {  			ZoomMulti += 0.0001f;  		}  		if (game.Keyboard [Key.X] && ZoomMulti > 0.001f) {  			ZoomMulti -= 0.0001f;  		}  	};  	//for slowing down simulation  	int SimulationSlowDownStep = 0;  	game.RenderFrame += (sender' e) =>  {  		// render graphics  		//clears screen  		GL.Clear (ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);  		GL.MatrixMode (MatrixMode.Projection);  		Vector2 followPosition = new Vector2 (0' 0);  		matrix = Matrix4.CreateTranslation (ViewPointV);  		GL.LoadMatrix (ref matrix);  		GL.Ortho (-game.Width * ZoomMulti' game.Width * ZoomMulti' -game.Height * ZoomMulti' game.Height * ZoomMulti' 0.0' 4.0);  		//speedup / slowdown  		//slowdown?  		if (SimulationSpeed < 20) {  			//Stop simulation when sim speed = 0  			if (SimulationSpeed == 0)  				SimulationSlowDownStep = 1;  			SimulationSlowDownStep += SimulationSpeed;  			if (SimulationSlowDownStep > 20)  				SimulationSlowDownStep = 0;  		}  		else  			SimulationSlowDownStep = 0;  		Console.WriteLine (SimulationSpeed);  		for (int zx = 20; (zx < SimulationSpeed || zx == 20) && SimulationSlowDownStep == 0; zx++) {  			int['] arrNextTo = new int[iSizeOfGrid' iSizeOfGrid];  			//calculate neighbours  			for (int x = 0; x < iSizeOfGrid; x++) {  				for (int y = 0; y < iSizeOfGrid; y++) {  					if (arrAlive [x' y] == 1 && x > 1 && y > 1 && x < iSizeOfGrid - 1 && y < iSizeOfGrid - 1) {  						arrNextTo [x - 1' y - 1]++;  						arrNextTo [x - 1' y]++;  						arrNextTo [x - 1' y + 1]++;  						arrNextTo [x' y + 1]++;  						arrNextTo [x' y - 1]++;  						arrNextTo [x + 1' y - 1]++;  						arrNextTo [x + 1' y]++;  						arrNextTo [x + 1' y + 1]++;  					}  				}  			}  			//kill / revive  			for (int x = 0; x < iSizeOfGrid; x++) {  				for (int y = 0; y < iSizeOfGrid; y++) {  					if (arrNextTo [x' y] < 2 || arrNextTo [x' y] > 3) {  						arrAlive [x' y] = 0;  					}  					if (arrNextTo [x' y] == 3) {  						arrAlive [x' y] = 1;  					}  				}  			}  		}  		//Now draw the objects to the gamewindow  		GL.Color3 (Color.Yellow);  		GL.Begin (PrimitiveType.Quads);  		//Draw Cells  		for (int x = 0; x < iSizeOfGrid; x++) {  			//Console.WriteLine('n');  			for (int y = 0; y < iSizeOfGrid; y++) {  				//	Console.Write(arrAlive[x'y]);  				if (arrAlive [x' y] == 1) {  					GL.Vertex2 (x' y);  					GL.Vertex2 (x' y + 1);  					GL.Vertex2 (x + 1' y + 1);  					GL.Vertex2 (x + 1' y);  				}  			}  		}  		GL.End ();  		DrawCircle (30' ViewPointV.X' ViewPointV.Y' 1);  		Console.WriteLine (game.RenderFrequency);  		//load onto screen  		game.SwapBuffers ();  	};  	//run the game loop  	game.Run ();  }  
Magic Number,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following statement contains a magic number: using (var game = new GameWindow (700' 500' new GraphicsMode (32' 24' 0' 8))) {  	//seed array  	Random rand = new Random ();  	for (int i = 200; i < iSizeOfGrid - 200; i++) {  		for (int z = 200; z < iSizeOfGrid - 200; z++) {  			arrAlive [i' z] = rand.Next (3);  		}  	}  	//Console.WriteLine (arrAlive.ToString ());  	//run at 60fps  	game.TargetRenderFrequency = 20;  	Matrix4 matrix = Matrix4.CreateTranslation (0' 0' 0);  	game.Load += (sender' e) =>  {  		// setup settings' load textures' sounds  		game.VSync = VSyncMode.On;  		game.Title = "LIFE";  	};  	game.Resize += (sender' e) =>  {  		GL.Viewport (0' 0' game.Width' game.Height);  	};  	//mouse click to add logic  	Vector2 MoCinitialvec = new Vector2 (0f' 0f);  	Vector2 MoCdvec = new Vector2 (0f' 0f);  	bool MoCdraw = false;  	Vector3 PrevViewpoint = new Vector3 (0f' 0f' 0f);  	//enable textures  	GL.Enable (EnableCap.Texture2D);  	GL.BlendFunc (BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);  	//mouse click event  	game.Mouse.ButtonDown += (sender' e) =>  {  		MoCinitialvec = MousePosition (e.X' e.Y' game);  		MoCdvec = MoCinitialvec;  		//start adding an object  		if (e.Button == MouseButton.Left) {  			MoCdraw = true;  		}  		//start moving viewpoint  		if (e.Button == MouseButton.Right) {  			PrevViewpoint = ViewPointV;  		}  	};  	game.Mouse.ButtonUp += (sender' e) =>  {  		//if left click - add object  		if (e.Button == MouseButton.Left) {  			MoCdraw = false;  		}  	};  	//scroll wheel - zoom in / out  	game.Mouse.WheelChanged += (sender' e) =>  {  		if (ZoomMulti - e.DeltaPrecise * 0.001f > 0) {  			ZoomMulti -= e.DeltaPrecise * 0.001f;  		}  	};  	//moving mouse  	game.Mouse.Move += (sender' e) =>  {  		//for adding object  		MoCdvec = MousePosition (e.X' e.Y' game);  		if (e.X < 5 && e.Y < 5) {  			if (SimulationSpeed == 0)  				SimulationSpeed = 20;  			else  				SimulationSpeed = 0;  		}  		if (e.Mouse.LeftButton == ButtonState.Pressed) {  			try {  				arrAlive [(int)MoCdvec.X' (int)MoCdvec.Y] = 1;  			}  			catch {  			}  		}  		//for moving viewpoint  		if (e.Mouse.RightButton == ButtonState.Pressed) {  			ViewPointV = new Vector3 ((MoCdvec - MoCinitialvec).X / (game.Width * ZoomMulti)' (MoCdvec - MoCinitialvec).Y / (game.Height * ZoomMulti)' 0) + PrevViewpoint;  		}  	};  	//keyboard input  	game.KeyPress += (sender' e) =>  {  		switch (e.KeyChar) {  		case 'f':  			game.WindowState = WindowState.Fullscreen;  			break;  		case 'p':  			if (SimulationSpeed == 0)  				SimulationSpeed = 20;  			else  				SimulationSpeed = 0;  			break;  		case 'c':  			//seed array  			for (int i = 0; i < iSizeOfGrid; i++) {  				for (int z = 0; z < iSizeOfGrid; z++) {  					arrAlive [i' z] = 0;  				}  			}  			break;  		}  	};  	//more keyboard input  	game.UpdateFrame += (sender' e) =>  {  		if (game.Keyboard [Key.Escape]) {  			game.Exit ();  		}  		if (game.Keyboard [Key.A]) {  			ViewPointV.X += 0.01f;  		}  		if (game.Keyboard [Key.D]) {  			ViewPointV.X -= 0.01f;  		}  		if (game.Keyboard [Key.W]) {  			ViewPointV.Y -= 0.01f;  		}  		if (game.Keyboard [Key.S]) {  			ViewPointV.Y += 0.01f;  		}  		if (game.Keyboard [Key.Z]) {  			ZoomMulti += 0.0001f;  		}  		if (game.Keyboard [Key.X] && ZoomMulti > 0.001f) {  			ZoomMulti -= 0.0001f;  		}  	};  	//for slowing down simulation  	int SimulationSlowDownStep = 0;  	game.RenderFrame += (sender' e) =>  {  		// render graphics  		//clears screen  		GL.Clear (ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);  		GL.MatrixMode (MatrixMode.Projection);  		Vector2 followPosition = new Vector2 (0' 0);  		matrix = Matrix4.CreateTranslation (ViewPointV);  		GL.LoadMatrix (ref matrix);  		GL.Ortho (-game.Width * ZoomMulti' game.Width * ZoomMulti' -game.Height * ZoomMulti' game.Height * ZoomMulti' 0.0' 4.0);  		//speedup / slowdown  		//slowdown?  		if (SimulationSpeed < 20) {  			//Stop simulation when sim speed = 0  			if (SimulationSpeed == 0)  				SimulationSlowDownStep = 1;  			SimulationSlowDownStep += SimulationSpeed;  			if (SimulationSlowDownStep > 20)  				SimulationSlowDownStep = 0;  		}  		else  			SimulationSlowDownStep = 0;  		Console.WriteLine (SimulationSpeed);  		for (int zx = 20; (zx < SimulationSpeed || zx == 20) && SimulationSlowDownStep == 0; zx++) {  			int['] arrNextTo = new int[iSizeOfGrid' iSizeOfGrid];  			//calculate neighbours  			for (int x = 0; x < iSizeOfGrid; x++) {  				for (int y = 0; y < iSizeOfGrid; y++) {  					if (arrAlive [x' y] == 1 && x > 1 && y > 1 && x < iSizeOfGrid - 1 && y < iSizeOfGrid - 1) {  						arrNextTo [x - 1' y - 1]++;  						arrNextTo [x - 1' y]++;  						arrNextTo [x - 1' y + 1]++;  						arrNextTo [x' y + 1]++;  						arrNextTo [x' y - 1]++;  						arrNextTo [x + 1' y - 1]++;  						arrNextTo [x + 1' y]++;  						arrNextTo [x + 1' y + 1]++;  					}  				}  			}  			//kill / revive  			for (int x = 0; x < iSizeOfGrid; x++) {  				for (int y = 0; y < iSizeOfGrid; y++) {  					if (arrNextTo [x' y] < 2 || arrNextTo [x' y] > 3) {  						arrAlive [x' y] = 0;  					}  					if (arrNextTo [x' y] == 3) {  						arrAlive [x' y] = 1;  					}  				}  			}  		}  		//Now draw the objects to the gamewindow  		GL.Color3 (Color.Yellow);  		GL.Begin (PrimitiveType.Quads);  		//Draw Cells  		for (int x = 0; x < iSizeOfGrid; x++) {  			//Console.WriteLine('n');  			for (int y = 0; y < iSizeOfGrid; y++) {  				//	Console.Write(arrAlive[x'y]);  				if (arrAlive [x' y] == 1) {  					GL.Vertex2 (x' y);  					GL.Vertex2 (x' y + 1);  					GL.Vertex2 (x + 1' y + 1);  					GL.Vertex2 (x + 1' y);  				}  			}  		}  		GL.End ();  		DrawCircle (30' ViewPointV.X' ViewPointV.Y' 1);  		Console.WriteLine (game.RenderFrequency);  		//load onto screen  		game.SwapBuffers ();  	};  	//run the game loop  	game.Run ();  }  
Magic Number,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following statement contains a magic number: using (var game = new GameWindow (700' 500' new GraphicsMode (32' 24' 0' 8))) {  	//seed array  	Random rand = new Random ();  	for (int i = 200; i < iSizeOfGrid - 200; i++) {  		for (int z = 200; z < iSizeOfGrid - 200; z++) {  			arrAlive [i' z] = rand.Next (3);  		}  	}  	//Console.WriteLine (arrAlive.ToString ());  	//run at 60fps  	game.TargetRenderFrequency = 20;  	Matrix4 matrix = Matrix4.CreateTranslation (0' 0' 0);  	game.Load += (sender' e) =>  {  		// setup settings' load textures' sounds  		game.VSync = VSyncMode.On;  		game.Title = "LIFE";  	};  	game.Resize += (sender' e) =>  {  		GL.Viewport (0' 0' game.Width' game.Height);  	};  	//mouse click to add logic  	Vector2 MoCinitialvec = new Vector2 (0f' 0f);  	Vector2 MoCdvec = new Vector2 (0f' 0f);  	bool MoCdraw = false;  	Vector3 PrevViewpoint = new Vector3 (0f' 0f' 0f);  	//enable textures  	GL.Enable (EnableCap.Texture2D);  	GL.BlendFunc (BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);  	//mouse click event  	game.Mouse.ButtonDown += (sender' e) =>  {  		MoCinitialvec = MousePosition (e.X' e.Y' game);  		MoCdvec = MoCinitialvec;  		//start adding an object  		if (e.Button == MouseButton.Left) {  			MoCdraw = true;  		}  		//start moving viewpoint  		if (e.Button == MouseButton.Right) {  			PrevViewpoint = ViewPointV;  		}  	};  	game.Mouse.ButtonUp += (sender' e) =>  {  		//if left click - add object  		if (e.Button == MouseButton.Left) {  			MoCdraw = false;  		}  	};  	//scroll wheel - zoom in / out  	game.Mouse.WheelChanged += (sender' e) =>  {  		if (ZoomMulti - e.DeltaPrecise * 0.001f > 0) {  			ZoomMulti -= e.DeltaPrecise * 0.001f;  		}  	};  	//moving mouse  	game.Mouse.Move += (sender' e) =>  {  		//for adding object  		MoCdvec = MousePosition (e.X' e.Y' game);  		if (e.X < 5 && e.Y < 5) {  			if (SimulationSpeed == 0)  				SimulationSpeed = 20;  			else  				SimulationSpeed = 0;  		}  		if (e.Mouse.LeftButton == ButtonState.Pressed) {  			try {  				arrAlive [(int)MoCdvec.X' (int)MoCdvec.Y] = 1;  			}  			catch {  			}  		}  		//for moving viewpoint  		if (e.Mouse.RightButton == ButtonState.Pressed) {  			ViewPointV = new Vector3 ((MoCdvec - MoCinitialvec).X / (game.Width * ZoomMulti)' (MoCdvec - MoCinitialvec).Y / (game.Height * ZoomMulti)' 0) + PrevViewpoint;  		}  	};  	//keyboard input  	game.KeyPress += (sender' e) =>  {  		switch (e.KeyChar) {  		case 'f':  			game.WindowState = WindowState.Fullscreen;  			break;  		case 'p':  			if (SimulationSpeed == 0)  				SimulationSpeed = 20;  			else  				SimulationSpeed = 0;  			break;  		case 'c':  			//seed array  			for (int i = 0; i < iSizeOfGrid; i++) {  				for (int z = 0; z < iSizeOfGrid; z++) {  					arrAlive [i' z] = 0;  				}  			}  			break;  		}  	};  	//more keyboard input  	game.UpdateFrame += (sender' e) =>  {  		if (game.Keyboard [Key.Escape]) {  			game.Exit ();  		}  		if (game.Keyboard [Key.A]) {  			ViewPointV.X += 0.01f;  		}  		if (game.Keyboard [Key.D]) {  			ViewPointV.X -= 0.01f;  		}  		if (game.Keyboard [Key.W]) {  			ViewPointV.Y -= 0.01f;  		}  		if (game.Keyboard [Key.S]) {  			ViewPointV.Y += 0.01f;  		}  		if (game.Keyboard [Key.Z]) {  			ZoomMulti += 0.0001f;  		}  		if (game.Keyboard [Key.X] && ZoomMulti > 0.001f) {  			ZoomMulti -= 0.0001f;  		}  	};  	//for slowing down simulation  	int SimulationSlowDownStep = 0;  	game.RenderFrame += (sender' e) =>  {  		// render graphics  		//clears screen  		GL.Clear (ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);  		GL.MatrixMode (MatrixMode.Projection);  		Vector2 followPosition = new Vector2 (0' 0);  		matrix = Matrix4.CreateTranslation (ViewPointV);  		GL.LoadMatrix (ref matrix);  		GL.Ortho (-game.Width * ZoomMulti' game.Width * ZoomMulti' -game.Height * ZoomMulti' game.Height * ZoomMulti' 0.0' 4.0);  		//speedup / slowdown  		//slowdown?  		if (SimulationSpeed < 20) {  			//Stop simulation when sim speed = 0  			if (SimulationSpeed == 0)  				SimulationSlowDownStep = 1;  			SimulationSlowDownStep += SimulationSpeed;  			if (SimulationSlowDownStep > 20)  				SimulationSlowDownStep = 0;  		}  		else  			SimulationSlowDownStep = 0;  		Console.WriteLine (SimulationSpeed);  		for (int zx = 20; (zx < SimulationSpeed || zx == 20) && SimulationSlowDownStep == 0; zx++) {  			int['] arrNextTo = new int[iSizeOfGrid' iSizeOfGrid];  			//calculate neighbours  			for (int x = 0; x < iSizeOfGrid; x++) {  				for (int y = 0; y < iSizeOfGrid; y++) {  					if (arrAlive [x' y] == 1 && x > 1 && y > 1 && x < iSizeOfGrid - 1 && y < iSizeOfGrid - 1) {  						arrNextTo [x - 1' y - 1]++;  						arrNextTo [x - 1' y]++;  						arrNextTo [x - 1' y + 1]++;  						arrNextTo [x' y + 1]++;  						arrNextTo [x' y - 1]++;  						arrNextTo [x + 1' y - 1]++;  						arrNextTo [x + 1' y]++;  						arrNextTo [x + 1' y + 1]++;  					}  				}  			}  			//kill / revive  			for (int x = 0; x < iSizeOfGrid; x++) {  				for (int y = 0; y < iSizeOfGrid; y++) {  					if (arrNextTo [x' y] < 2 || arrNextTo [x' y] > 3) {  						arrAlive [x' y] = 0;  					}  					if (arrNextTo [x' y] == 3) {  						arrAlive [x' y] = 1;  					}  				}  			}  		}  		//Now draw the objects to the gamewindow  		GL.Color3 (Color.Yellow);  		GL.Begin (PrimitiveType.Quads);  		//Draw Cells  		for (int x = 0; x < iSizeOfGrid; x++) {  			//Console.WriteLine('n');  			for (int y = 0; y < iSizeOfGrid; y++) {  				//	Console.Write(arrAlive[x'y]);  				if (arrAlive [x' y] == 1) {  					GL.Vertex2 (x' y);  					GL.Vertex2 (x' y + 1);  					GL.Vertex2 (x + 1' y + 1);  					GL.Vertex2 (x + 1' y);  				}  			}  		}  		GL.End ();  		DrawCircle (30' ViewPointV.X' ViewPointV.Y' 1);  		Console.WriteLine (game.RenderFrequency);  		//load onto screen  		game.SwapBuffers ();  	};  	//run the game loop  	game.Run ();  }  
Magic Number,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following statement contains a magic number: using (var game = new GameWindow (700' 500' new GraphicsMode (32' 24' 0' 8))) {  	//seed array  	Random rand = new Random ();  	for (int i = 200; i < iSizeOfGrid - 200; i++) {  		for (int z = 200; z < iSizeOfGrid - 200; z++) {  			arrAlive [i' z] = rand.Next (3);  		}  	}  	//Console.WriteLine (arrAlive.ToString ());  	//run at 60fps  	game.TargetRenderFrequency = 20;  	Matrix4 matrix = Matrix4.CreateTranslation (0' 0' 0);  	game.Load += (sender' e) =>  {  		// setup settings' load textures' sounds  		game.VSync = VSyncMode.On;  		game.Title = "LIFE";  	};  	game.Resize += (sender' e) =>  {  		GL.Viewport (0' 0' game.Width' game.Height);  	};  	//mouse click to add logic  	Vector2 MoCinitialvec = new Vector2 (0f' 0f);  	Vector2 MoCdvec = new Vector2 (0f' 0f);  	bool MoCdraw = false;  	Vector3 PrevViewpoint = new Vector3 (0f' 0f' 0f);  	//enable textures  	GL.Enable (EnableCap.Texture2D);  	GL.BlendFunc (BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);  	//mouse click event  	game.Mouse.ButtonDown += (sender' e) =>  {  		MoCinitialvec = MousePosition (e.X' e.Y' game);  		MoCdvec = MoCinitialvec;  		//start adding an object  		if (e.Button == MouseButton.Left) {  			MoCdraw = true;  		}  		//start moving viewpoint  		if (e.Button == MouseButton.Right) {  			PrevViewpoint = ViewPointV;  		}  	};  	game.Mouse.ButtonUp += (sender' e) =>  {  		//if left click - add object  		if (e.Button == MouseButton.Left) {  			MoCdraw = false;  		}  	};  	//scroll wheel - zoom in / out  	game.Mouse.WheelChanged += (sender' e) =>  {  		if (ZoomMulti - e.DeltaPrecise * 0.001f > 0) {  			ZoomMulti -= e.DeltaPrecise * 0.001f;  		}  	};  	//moving mouse  	game.Mouse.Move += (sender' e) =>  {  		//for adding object  		MoCdvec = MousePosition (e.X' e.Y' game);  		if (e.X < 5 && e.Y < 5) {  			if (SimulationSpeed == 0)  				SimulationSpeed = 20;  			else  				SimulationSpeed = 0;  		}  		if (e.Mouse.LeftButton == ButtonState.Pressed) {  			try {  				arrAlive [(int)MoCdvec.X' (int)MoCdvec.Y] = 1;  			}  			catch {  			}  		}  		//for moving viewpoint  		if (e.Mouse.RightButton == ButtonState.Pressed) {  			ViewPointV = new Vector3 ((MoCdvec - MoCinitialvec).X / (game.Width * ZoomMulti)' (MoCdvec - MoCinitialvec).Y / (game.Height * ZoomMulti)' 0) + PrevViewpoint;  		}  	};  	//keyboard input  	game.KeyPress += (sender' e) =>  {  		switch (e.KeyChar) {  		case 'f':  			game.WindowState = WindowState.Fullscreen;  			break;  		case 'p':  			if (SimulationSpeed == 0)  				SimulationSpeed = 20;  			else  				SimulationSpeed = 0;  			break;  		case 'c':  			//seed array  			for (int i = 0; i < iSizeOfGrid; i++) {  				for (int z = 0; z < iSizeOfGrid; z++) {  					arrAlive [i' z] = 0;  				}  			}  			break;  		}  	};  	//more keyboard input  	game.UpdateFrame += (sender' e) =>  {  		if (game.Keyboard [Key.Escape]) {  			game.Exit ();  		}  		if (game.Keyboard [Key.A]) {  			ViewPointV.X += 0.01f;  		}  		if (game.Keyboard [Key.D]) {  			ViewPointV.X -= 0.01f;  		}  		if (game.Keyboard [Key.W]) {  			ViewPointV.Y -= 0.01f;  		}  		if (game.Keyboard [Key.S]) {  			ViewPointV.Y += 0.01f;  		}  		if (game.Keyboard [Key.Z]) {  			ZoomMulti += 0.0001f;  		}  		if (game.Keyboard [Key.X] && ZoomMulti > 0.001f) {  			ZoomMulti -= 0.0001f;  		}  	};  	//for slowing down simulation  	int SimulationSlowDownStep = 0;  	game.RenderFrame += (sender' e) =>  {  		// render graphics  		//clears screen  		GL.Clear (ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);  		GL.MatrixMode (MatrixMode.Projection);  		Vector2 followPosition = new Vector2 (0' 0);  		matrix = Matrix4.CreateTranslation (ViewPointV);  		GL.LoadMatrix (ref matrix);  		GL.Ortho (-game.Width * ZoomMulti' game.Width * ZoomMulti' -game.Height * ZoomMulti' game.Height * ZoomMulti' 0.0' 4.0);  		//speedup / slowdown  		//slowdown?  		if (SimulationSpeed < 20) {  			//Stop simulation when sim speed = 0  			if (SimulationSpeed == 0)  				SimulationSlowDownStep = 1;  			SimulationSlowDownStep += SimulationSpeed;  			if (SimulationSlowDownStep > 20)  				SimulationSlowDownStep = 0;  		}  		else  			SimulationSlowDownStep = 0;  		Console.WriteLine (SimulationSpeed);  		for (int zx = 20; (zx < SimulationSpeed || zx == 20) && SimulationSlowDownStep == 0; zx++) {  			int['] arrNextTo = new int[iSizeOfGrid' iSizeOfGrid];  			//calculate neighbours  			for (int x = 0; x < iSizeOfGrid; x++) {  				for (int y = 0; y < iSizeOfGrid; y++) {  					if (arrAlive [x' y] == 1 && x > 1 && y > 1 && x < iSizeOfGrid - 1 && y < iSizeOfGrid - 1) {  						arrNextTo [x - 1' y - 1]++;  						arrNextTo [x - 1' y]++;  						arrNextTo [x - 1' y + 1]++;  						arrNextTo [x' y + 1]++;  						arrNextTo [x' y - 1]++;  						arrNextTo [x + 1' y - 1]++;  						arrNextTo [x + 1' y]++;  						arrNextTo [x + 1' y + 1]++;  					}  				}  			}  			//kill / revive  			for (int x = 0; x < iSizeOfGrid; x++) {  				for (int y = 0; y < iSizeOfGrid; y++) {  					if (arrNextTo [x' y] < 2 || arrNextTo [x' y] > 3) {  						arrAlive [x' y] = 0;  					}  					if (arrNextTo [x' y] == 3) {  						arrAlive [x' y] = 1;  					}  				}  			}  		}  		//Now draw the objects to the gamewindow  		GL.Color3 (Color.Yellow);  		GL.Begin (PrimitiveType.Quads);  		//Draw Cells  		for (int x = 0; x < iSizeOfGrid; x++) {  			//Console.WriteLine('n');  			for (int y = 0; y < iSizeOfGrid; y++) {  				//	Console.Write(arrAlive[x'y]);  				if (arrAlive [x' y] == 1) {  					GL.Vertex2 (x' y);  					GL.Vertex2 (x' y + 1);  					GL.Vertex2 (x + 1' y + 1);  					GL.Vertex2 (x + 1' y);  				}  			}  		}  		GL.End ();  		DrawCircle (30' ViewPointV.X' ViewPointV.Y' 1);  		Console.WriteLine (game.RenderFrequency);  		//load onto screen  		game.SwapBuffers ();  	};  	//run the game loop  	game.Run ();  }  
Magic Number,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following statement contains a magic number: using (var game = new GameWindow (700' 500' new GraphicsMode (32' 24' 0' 8))) {  	//seed array  	Random rand = new Random ();  	for (int i = 200; i < iSizeOfGrid - 200; i++) {  		for (int z = 200; z < iSizeOfGrid - 200; z++) {  			arrAlive [i' z] = rand.Next (3);  		}  	}  	//Console.WriteLine (arrAlive.ToString ());  	//run at 60fps  	game.TargetRenderFrequency = 20;  	Matrix4 matrix = Matrix4.CreateTranslation (0' 0' 0);  	game.Load += (sender' e) =>  {  		// setup settings' load textures' sounds  		game.VSync = VSyncMode.On;  		game.Title = "LIFE";  	};  	game.Resize += (sender' e) =>  {  		GL.Viewport (0' 0' game.Width' game.Height);  	};  	//mouse click to add logic  	Vector2 MoCinitialvec = new Vector2 (0f' 0f);  	Vector2 MoCdvec = new Vector2 (0f' 0f);  	bool MoCdraw = false;  	Vector3 PrevViewpoint = new Vector3 (0f' 0f' 0f);  	//enable textures  	GL.Enable (EnableCap.Texture2D);  	GL.BlendFunc (BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);  	//mouse click event  	game.Mouse.ButtonDown += (sender' e) =>  {  		MoCinitialvec = MousePosition (e.X' e.Y' game);  		MoCdvec = MoCinitialvec;  		//start adding an object  		if (e.Button == MouseButton.Left) {  			MoCdraw = true;  		}  		//start moving viewpoint  		if (e.Button == MouseButton.Right) {  			PrevViewpoint = ViewPointV;  		}  	};  	game.Mouse.ButtonUp += (sender' e) =>  {  		//if left click - add object  		if (e.Button == MouseButton.Left) {  			MoCdraw = false;  		}  	};  	//scroll wheel - zoom in / out  	game.Mouse.WheelChanged += (sender' e) =>  {  		if (ZoomMulti - e.DeltaPrecise * 0.001f > 0) {  			ZoomMulti -= e.DeltaPrecise * 0.001f;  		}  	};  	//moving mouse  	game.Mouse.Move += (sender' e) =>  {  		//for adding object  		MoCdvec = MousePosition (e.X' e.Y' game);  		if (e.X < 5 && e.Y < 5) {  			if (SimulationSpeed == 0)  				SimulationSpeed = 20;  			else  				SimulationSpeed = 0;  		}  		if (e.Mouse.LeftButton == ButtonState.Pressed) {  			try {  				arrAlive [(int)MoCdvec.X' (int)MoCdvec.Y] = 1;  			}  			catch {  			}  		}  		//for moving viewpoint  		if (e.Mouse.RightButton == ButtonState.Pressed) {  			ViewPointV = new Vector3 ((MoCdvec - MoCinitialvec).X / (game.Width * ZoomMulti)' (MoCdvec - MoCinitialvec).Y / (game.Height * ZoomMulti)' 0) + PrevViewpoint;  		}  	};  	//keyboard input  	game.KeyPress += (sender' e) =>  {  		switch (e.KeyChar) {  		case 'f':  			game.WindowState = WindowState.Fullscreen;  			break;  		case 'p':  			if (SimulationSpeed == 0)  				SimulationSpeed = 20;  			else  				SimulationSpeed = 0;  			break;  		case 'c':  			//seed array  			for (int i = 0; i < iSizeOfGrid; i++) {  				for (int z = 0; z < iSizeOfGrid; z++) {  					arrAlive [i' z] = 0;  				}  			}  			break;  		}  	};  	//more keyboard input  	game.UpdateFrame += (sender' e) =>  {  		if (game.Keyboard [Key.Escape]) {  			game.Exit ();  		}  		if (game.Keyboard [Key.A]) {  			ViewPointV.X += 0.01f;  		}  		if (game.Keyboard [Key.D]) {  			ViewPointV.X -= 0.01f;  		}  		if (game.Keyboard [Key.W]) {  			ViewPointV.Y -= 0.01f;  		}  		if (game.Keyboard [Key.S]) {  			ViewPointV.Y += 0.01f;  		}  		if (game.Keyboard [Key.Z]) {  			ZoomMulti += 0.0001f;  		}  		if (game.Keyboard [Key.X] && ZoomMulti > 0.001f) {  			ZoomMulti -= 0.0001f;  		}  	};  	//for slowing down simulation  	int SimulationSlowDownStep = 0;  	game.RenderFrame += (sender' e) =>  {  		// render graphics  		//clears screen  		GL.Clear (ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);  		GL.MatrixMode (MatrixMode.Projection);  		Vector2 followPosition = new Vector2 (0' 0);  		matrix = Matrix4.CreateTranslation (ViewPointV);  		GL.LoadMatrix (ref matrix);  		GL.Ortho (-game.Width * ZoomMulti' game.Width * ZoomMulti' -game.Height * ZoomMulti' game.Height * ZoomMulti' 0.0' 4.0);  		//speedup / slowdown  		//slowdown?  		if (SimulationSpeed < 20) {  			//Stop simulation when sim speed = 0  			if (SimulationSpeed == 0)  				SimulationSlowDownStep = 1;  			SimulationSlowDownStep += SimulationSpeed;  			if (SimulationSlowDownStep > 20)  				SimulationSlowDownStep = 0;  		}  		else  			SimulationSlowDownStep = 0;  		Console.WriteLine (SimulationSpeed);  		for (int zx = 20; (zx < SimulationSpeed || zx == 20) && SimulationSlowDownStep == 0; zx++) {  			int['] arrNextTo = new int[iSizeOfGrid' iSizeOfGrid];  			//calculate neighbours  			for (int x = 0; x < iSizeOfGrid; x++) {  				for (int y = 0; y < iSizeOfGrid; y++) {  					if (arrAlive [x' y] == 1 && x > 1 && y > 1 && x < iSizeOfGrid - 1 && y < iSizeOfGrid - 1) {  						arrNextTo [x - 1' y - 1]++;  						arrNextTo [x - 1' y]++;  						arrNextTo [x - 1' y + 1]++;  						arrNextTo [x' y + 1]++;  						arrNextTo [x' y - 1]++;  						arrNextTo [x + 1' y - 1]++;  						arrNextTo [x + 1' y]++;  						arrNextTo [x + 1' y + 1]++;  					}  				}  			}  			//kill / revive  			for (int x = 0; x < iSizeOfGrid; x++) {  				for (int y = 0; y < iSizeOfGrid; y++) {  					if (arrNextTo [x' y] < 2 || arrNextTo [x' y] > 3) {  						arrAlive [x' y] = 0;  					}  					if (arrNextTo [x' y] == 3) {  						arrAlive [x' y] = 1;  					}  				}  			}  		}  		//Now draw the objects to the gamewindow  		GL.Color3 (Color.Yellow);  		GL.Begin (PrimitiveType.Quads);  		//Draw Cells  		for (int x = 0; x < iSizeOfGrid; x++) {  			//Console.WriteLine('n');  			for (int y = 0; y < iSizeOfGrid; y++) {  				//	Console.Write(arrAlive[x'y]);  				if (arrAlive [x' y] == 1) {  					GL.Vertex2 (x' y);  					GL.Vertex2 (x' y + 1);  					GL.Vertex2 (x + 1' y + 1);  					GL.Vertex2 (x + 1' y);  				}  			}  		}  		GL.End ();  		DrawCircle (30' ViewPointV.X' ViewPointV.Y' 1);  		Console.WriteLine (game.RenderFrequency);  		//load onto screen  		game.SwapBuffers ();  	};  	//run the game loop  	game.Run ();  }  
Magic Number,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following statement contains a magic number: using (var game = new GameWindow (700' 500' new GraphicsMode (32' 24' 0' 8))) {  	//seed array  	Random rand = new Random ();  	for (int i = 200; i < iSizeOfGrid - 200; i++) {  		for (int z = 200; z < iSizeOfGrid - 200; z++) {  			arrAlive [i' z] = rand.Next (3);  		}  	}  	//Console.WriteLine (arrAlive.ToString ());  	//run at 60fps  	game.TargetRenderFrequency = 20;  	Matrix4 matrix = Matrix4.CreateTranslation (0' 0' 0);  	game.Load += (sender' e) =>  {  		// setup settings' load textures' sounds  		game.VSync = VSyncMode.On;  		game.Title = "LIFE";  	};  	game.Resize += (sender' e) =>  {  		GL.Viewport (0' 0' game.Width' game.Height);  	};  	//mouse click to add logic  	Vector2 MoCinitialvec = new Vector2 (0f' 0f);  	Vector2 MoCdvec = new Vector2 (0f' 0f);  	bool MoCdraw = false;  	Vector3 PrevViewpoint = new Vector3 (0f' 0f' 0f);  	//enable textures  	GL.Enable (EnableCap.Texture2D);  	GL.BlendFunc (BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);  	//mouse click event  	game.Mouse.ButtonDown += (sender' e) =>  {  		MoCinitialvec = MousePosition (e.X' e.Y' game);  		MoCdvec = MoCinitialvec;  		//start adding an object  		if (e.Button == MouseButton.Left) {  			MoCdraw = true;  		}  		//start moving viewpoint  		if (e.Button == MouseButton.Right) {  			PrevViewpoint = ViewPointV;  		}  	};  	game.Mouse.ButtonUp += (sender' e) =>  {  		//if left click - add object  		if (e.Button == MouseButton.Left) {  			MoCdraw = false;  		}  	};  	//scroll wheel - zoom in / out  	game.Mouse.WheelChanged += (sender' e) =>  {  		if (ZoomMulti - e.DeltaPrecise * 0.001f > 0) {  			ZoomMulti -= e.DeltaPrecise * 0.001f;  		}  	};  	//moving mouse  	game.Mouse.Move += (sender' e) =>  {  		//for adding object  		MoCdvec = MousePosition (e.X' e.Y' game);  		if (e.X < 5 && e.Y < 5) {  			if (SimulationSpeed == 0)  				SimulationSpeed = 20;  			else  				SimulationSpeed = 0;  		}  		if (e.Mouse.LeftButton == ButtonState.Pressed) {  			try {  				arrAlive [(int)MoCdvec.X' (int)MoCdvec.Y] = 1;  			}  			catch {  			}  		}  		//for moving viewpoint  		if (e.Mouse.RightButton == ButtonState.Pressed) {  			ViewPointV = new Vector3 ((MoCdvec - MoCinitialvec).X / (game.Width * ZoomMulti)' (MoCdvec - MoCinitialvec).Y / (game.Height * ZoomMulti)' 0) + PrevViewpoint;  		}  	};  	//keyboard input  	game.KeyPress += (sender' e) =>  {  		switch (e.KeyChar) {  		case 'f':  			game.WindowState = WindowState.Fullscreen;  			break;  		case 'p':  			if (SimulationSpeed == 0)  				SimulationSpeed = 20;  			else  				SimulationSpeed = 0;  			break;  		case 'c':  			//seed array  			for (int i = 0; i < iSizeOfGrid; i++) {  				for (int z = 0; z < iSizeOfGrid; z++) {  					arrAlive [i' z] = 0;  				}  			}  			break;  		}  	};  	//more keyboard input  	game.UpdateFrame += (sender' e) =>  {  		if (game.Keyboard [Key.Escape]) {  			game.Exit ();  		}  		if (game.Keyboard [Key.A]) {  			ViewPointV.X += 0.01f;  		}  		if (game.Keyboard [Key.D]) {  			ViewPointV.X -= 0.01f;  		}  		if (game.Keyboard [Key.W]) {  			ViewPointV.Y -= 0.01f;  		}  		if (game.Keyboard [Key.S]) {  			ViewPointV.Y += 0.01f;  		}  		if (game.Keyboard [Key.Z]) {  			ZoomMulti += 0.0001f;  		}  		if (game.Keyboard [Key.X] && ZoomMulti > 0.001f) {  			ZoomMulti -= 0.0001f;  		}  	};  	//for slowing down simulation  	int SimulationSlowDownStep = 0;  	game.RenderFrame += (sender' e) =>  {  		// render graphics  		//clears screen  		GL.Clear (ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);  		GL.MatrixMode (MatrixMode.Projection);  		Vector2 followPosition = new Vector2 (0' 0);  		matrix = Matrix4.CreateTranslation (ViewPointV);  		GL.LoadMatrix (ref matrix);  		GL.Ortho (-game.Width * ZoomMulti' game.Width * ZoomMulti' -game.Height * ZoomMulti' game.Height * ZoomMulti' 0.0' 4.0);  		//speedup / slowdown  		//slowdown?  		if (SimulationSpeed < 20) {  			//Stop simulation when sim speed = 0  			if (SimulationSpeed == 0)  				SimulationSlowDownStep = 1;  			SimulationSlowDownStep += SimulationSpeed;  			if (SimulationSlowDownStep > 20)  				SimulationSlowDownStep = 0;  		}  		else  			SimulationSlowDownStep = 0;  		Console.WriteLine (SimulationSpeed);  		for (int zx = 20; (zx < SimulationSpeed || zx == 20) && SimulationSlowDownStep == 0; zx++) {  			int['] arrNextTo = new int[iSizeOfGrid' iSizeOfGrid];  			//calculate neighbours  			for (int x = 0; x < iSizeOfGrid; x++) {  				for (int y = 0; y < iSizeOfGrid; y++) {  					if (arrAlive [x' y] == 1 && x > 1 && y > 1 && x < iSizeOfGrid - 1 && y < iSizeOfGrid - 1) {  						arrNextTo [x - 1' y - 1]++;  						arrNextTo [x - 1' y]++;  						arrNextTo [x - 1' y + 1]++;  						arrNextTo [x' y + 1]++;  						arrNextTo [x' y - 1]++;  						arrNextTo [x + 1' y - 1]++;  						arrNextTo [x + 1' y]++;  						arrNextTo [x + 1' y + 1]++;  					}  				}  			}  			//kill / revive  			for (int x = 0; x < iSizeOfGrid; x++) {  				for (int y = 0; y < iSizeOfGrid; y++) {  					if (arrNextTo [x' y] < 2 || arrNextTo [x' y] > 3) {  						arrAlive [x' y] = 0;  					}  					if (arrNextTo [x' y] == 3) {  						arrAlive [x' y] = 1;  					}  				}  			}  		}  		//Now draw the objects to the gamewindow  		GL.Color3 (Color.Yellow);  		GL.Begin (PrimitiveType.Quads);  		//Draw Cells  		for (int x = 0; x < iSizeOfGrid; x++) {  			//Console.WriteLine('n');  			for (int y = 0; y < iSizeOfGrid; y++) {  				//	Console.Write(arrAlive[x'y]);  				if (arrAlive [x' y] == 1) {  					GL.Vertex2 (x' y);  					GL.Vertex2 (x' y + 1);  					GL.Vertex2 (x + 1' y + 1);  					GL.Vertex2 (x + 1' y);  				}  			}  		}  		GL.End ();  		DrawCircle (30' ViewPointV.X' ViewPointV.Y' 1);  		Console.WriteLine (game.RenderFrequency);  		//load onto screen  		game.SwapBuffers ();  	};  	//run the game loop  	game.Run ();  }  
Magic Number,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following statement contains a magic number: using (var game = new GameWindow (700' 500' new GraphicsMode (32' 24' 0' 8))) {  	//seed array  	Random rand = new Random ();  	for (int i = 200; i < iSizeOfGrid - 200; i++) {  		for (int z = 200; z < iSizeOfGrid - 200; z++) {  			arrAlive [i' z] = rand.Next (3);  		}  	}  	//Console.WriteLine (arrAlive.ToString ());  	//run at 60fps  	game.TargetRenderFrequency = 20;  	Matrix4 matrix = Matrix4.CreateTranslation (0' 0' 0);  	game.Load += (sender' e) =>  {  		// setup settings' load textures' sounds  		game.VSync = VSyncMode.On;  		game.Title = "LIFE";  	};  	game.Resize += (sender' e) =>  {  		GL.Viewport (0' 0' game.Width' game.Height);  	};  	//mouse click to add logic  	Vector2 MoCinitialvec = new Vector2 (0f' 0f);  	Vector2 MoCdvec = new Vector2 (0f' 0f);  	bool MoCdraw = false;  	Vector3 PrevViewpoint = new Vector3 (0f' 0f' 0f);  	//enable textures  	GL.Enable (EnableCap.Texture2D);  	GL.BlendFunc (BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);  	//mouse click event  	game.Mouse.ButtonDown += (sender' e) =>  {  		MoCinitialvec = MousePosition (e.X' e.Y' game);  		MoCdvec = MoCinitialvec;  		//start adding an object  		if (e.Button == MouseButton.Left) {  			MoCdraw = true;  		}  		//start moving viewpoint  		if (e.Button == MouseButton.Right) {  			PrevViewpoint = ViewPointV;  		}  	};  	game.Mouse.ButtonUp += (sender' e) =>  {  		//if left click - add object  		if (e.Button == MouseButton.Left) {  			MoCdraw = false;  		}  	};  	//scroll wheel - zoom in / out  	game.Mouse.WheelChanged += (sender' e) =>  {  		if (ZoomMulti - e.DeltaPrecise * 0.001f > 0) {  			ZoomMulti -= e.DeltaPrecise * 0.001f;  		}  	};  	//moving mouse  	game.Mouse.Move += (sender' e) =>  {  		//for adding object  		MoCdvec = MousePosition (e.X' e.Y' game);  		if (e.X < 5 && e.Y < 5) {  			if (SimulationSpeed == 0)  				SimulationSpeed = 20;  			else  				SimulationSpeed = 0;  		}  		if (e.Mouse.LeftButton == ButtonState.Pressed) {  			try {  				arrAlive [(int)MoCdvec.X' (int)MoCdvec.Y] = 1;  			}  			catch {  			}  		}  		//for moving viewpoint  		if (e.Mouse.RightButton == ButtonState.Pressed) {  			ViewPointV = new Vector3 ((MoCdvec - MoCinitialvec).X / (game.Width * ZoomMulti)' (MoCdvec - MoCinitialvec).Y / (game.Height * ZoomMulti)' 0) + PrevViewpoint;  		}  	};  	//keyboard input  	game.KeyPress += (sender' e) =>  {  		switch (e.KeyChar) {  		case 'f':  			game.WindowState = WindowState.Fullscreen;  			break;  		case 'p':  			if (SimulationSpeed == 0)  				SimulationSpeed = 20;  			else  				SimulationSpeed = 0;  			break;  		case 'c':  			//seed array  			for (int i = 0; i < iSizeOfGrid; i++) {  				for (int z = 0; z < iSizeOfGrid; z++) {  					arrAlive [i' z] = 0;  				}  			}  			break;  		}  	};  	//more keyboard input  	game.UpdateFrame += (sender' e) =>  {  		if (game.Keyboard [Key.Escape]) {  			game.Exit ();  		}  		if (game.Keyboard [Key.A]) {  			ViewPointV.X += 0.01f;  		}  		if (game.Keyboard [Key.D]) {  			ViewPointV.X -= 0.01f;  		}  		if (game.Keyboard [Key.W]) {  			ViewPointV.Y -= 0.01f;  		}  		if (game.Keyboard [Key.S]) {  			ViewPointV.Y += 0.01f;  		}  		if (game.Keyboard [Key.Z]) {  			ZoomMulti += 0.0001f;  		}  		if (game.Keyboard [Key.X] && ZoomMulti > 0.001f) {  			ZoomMulti -= 0.0001f;  		}  	};  	//for slowing down simulation  	int SimulationSlowDownStep = 0;  	game.RenderFrame += (sender' e) =>  {  		// render graphics  		//clears screen  		GL.Clear (ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);  		GL.MatrixMode (MatrixMode.Projection);  		Vector2 followPosition = new Vector2 (0' 0);  		matrix = Matrix4.CreateTranslation (ViewPointV);  		GL.LoadMatrix (ref matrix);  		GL.Ortho (-game.Width * ZoomMulti' game.Width * ZoomMulti' -game.Height * ZoomMulti' game.Height * ZoomMulti' 0.0' 4.0);  		//speedup / slowdown  		//slowdown?  		if (SimulationSpeed < 20) {  			//Stop simulation when sim speed = 0  			if (SimulationSpeed == 0)  				SimulationSlowDownStep = 1;  			SimulationSlowDownStep += SimulationSpeed;  			if (SimulationSlowDownStep > 20)  				SimulationSlowDownStep = 0;  		}  		else  			SimulationSlowDownStep = 0;  		Console.WriteLine (SimulationSpeed);  		for (int zx = 20; (zx < SimulationSpeed || zx == 20) && SimulationSlowDownStep == 0; zx++) {  			int['] arrNextTo = new int[iSizeOfGrid' iSizeOfGrid];  			//calculate neighbours  			for (int x = 0; x < iSizeOfGrid; x++) {  				for (int y = 0; y < iSizeOfGrid; y++) {  					if (arrAlive [x' y] == 1 && x > 1 && y > 1 && x < iSizeOfGrid - 1 && y < iSizeOfGrid - 1) {  						arrNextTo [x - 1' y - 1]++;  						arrNextTo [x - 1' y]++;  						arrNextTo [x - 1' y + 1]++;  						arrNextTo [x' y + 1]++;  						arrNextTo [x' y - 1]++;  						arrNextTo [x + 1' y - 1]++;  						arrNextTo [x + 1' y]++;  						arrNextTo [x + 1' y + 1]++;  					}  				}  			}  			//kill / revive  			for (int x = 0; x < iSizeOfGrid; x++) {  				for (int y = 0; y < iSizeOfGrid; y++) {  					if (arrNextTo [x' y] < 2 || arrNextTo [x' y] > 3) {  						arrAlive [x' y] = 0;  					}  					if (arrNextTo [x' y] == 3) {  						arrAlive [x' y] = 1;  					}  				}  			}  		}  		//Now draw the objects to the gamewindow  		GL.Color3 (Color.Yellow);  		GL.Begin (PrimitiveType.Quads);  		//Draw Cells  		for (int x = 0; x < iSizeOfGrid; x++) {  			//Console.WriteLine('n');  			for (int y = 0; y < iSizeOfGrid; y++) {  				//	Console.Write(arrAlive[x'y]);  				if (arrAlive [x' y] == 1) {  					GL.Vertex2 (x' y);  					GL.Vertex2 (x' y + 1);  					GL.Vertex2 (x + 1' y + 1);  					GL.Vertex2 (x + 1' y);  				}  			}  		}  		GL.End ();  		DrawCircle (30' ViewPointV.X' ViewPointV.Y' 1);  		Console.WriteLine (game.RenderFrequency);  		//load onto screen  		game.SwapBuffers ();  	};  	//run the game loop  	game.Run ();  }  
Magic Number,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following statement contains a magic number: using (var game = new GameWindow (700' 500' new GraphicsMode (32' 24' 0' 8))) {  	//seed array  	Random rand = new Random ();  	for (int i = 200; i < iSizeOfGrid - 200; i++) {  		for (int z = 200; z < iSizeOfGrid - 200; z++) {  			arrAlive [i' z] = rand.Next (3);  		}  	}  	//Console.WriteLine (arrAlive.ToString ());  	//run at 60fps  	game.TargetRenderFrequency = 20;  	Matrix4 matrix = Matrix4.CreateTranslation (0' 0' 0);  	game.Load += (sender' e) =>  {  		// setup settings' load textures' sounds  		game.VSync = VSyncMode.On;  		game.Title = "LIFE";  	};  	game.Resize += (sender' e) =>  {  		GL.Viewport (0' 0' game.Width' game.Height);  	};  	//mouse click to add logic  	Vector2 MoCinitialvec = new Vector2 (0f' 0f);  	Vector2 MoCdvec = new Vector2 (0f' 0f);  	bool MoCdraw = false;  	Vector3 PrevViewpoint = new Vector3 (0f' 0f' 0f);  	//enable textures  	GL.Enable (EnableCap.Texture2D);  	GL.BlendFunc (BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);  	//mouse click event  	game.Mouse.ButtonDown += (sender' e) =>  {  		MoCinitialvec = MousePosition (e.X' e.Y' game);  		MoCdvec = MoCinitialvec;  		//start adding an object  		if (e.Button == MouseButton.Left) {  			MoCdraw = true;  		}  		//start moving viewpoint  		if (e.Button == MouseButton.Right) {  			PrevViewpoint = ViewPointV;  		}  	};  	game.Mouse.ButtonUp += (sender' e) =>  {  		//if left click - add object  		if (e.Button == MouseButton.Left) {  			MoCdraw = false;  		}  	};  	//scroll wheel - zoom in / out  	game.Mouse.WheelChanged += (sender' e) =>  {  		if (ZoomMulti - e.DeltaPrecise * 0.001f > 0) {  			ZoomMulti -= e.DeltaPrecise * 0.001f;  		}  	};  	//moving mouse  	game.Mouse.Move += (sender' e) =>  {  		//for adding object  		MoCdvec = MousePosition (e.X' e.Y' game);  		if (e.X < 5 && e.Y < 5) {  			if (SimulationSpeed == 0)  				SimulationSpeed = 20;  			else  				SimulationSpeed = 0;  		}  		if (e.Mouse.LeftButton == ButtonState.Pressed) {  			try {  				arrAlive [(int)MoCdvec.X' (int)MoCdvec.Y] = 1;  			}  			catch {  			}  		}  		//for moving viewpoint  		if (e.Mouse.RightButton == ButtonState.Pressed) {  			ViewPointV = new Vector3 ((MoCdvec - MoCinitialvec).X / (game.Width * ZoomMulti)' (MoCdvec - MoCinitialvec).Y / (game.Height * ZoomMulti)' 0) + PrevViewpoint;  		}  	};  	//keyboard input  	game.KeyPress += (sender' e) =>  {  		switch (e.KeyChar) {  		case 'f':  			game.WindowState = WindowState.Fullscreen;  			break;  		case 'p':  			if (SimulationSpeed == 0)  				SimulationSpeed = 20;  			else  				SimulationSpeed = 0;  			break;  		case 'c':  			//seed array  			for (int i = 0; i < iSizeOfGrid; i++) {  				for (int z = 0; z < iSizeOfGrid; z++) {  					arrAlive [i' z] = 0;  				}  			}  			break;  		}  	};  	//more keyboard input  	game.UpdateFrame += (sender' e) =>  {  		if (game.Keyboard [Key.Escape]) {  			game.Exit ();  		}  		if (game.Keyboard [Key.A]) {  			ViewPointV.X += 0.01f;  		}  		if (game.Keyboard [Key.D]) {  			ViewPointV.X -= 0.01f;  		}  		if (game.Keyboard [Key.W]) {  			ViewPointV.Y -= 0.01f;  		}  		if (game.Keyboard [Key.S]) {  			ViewPointV.Y += 0.01f;  		}  		if (game.Keyboard [Key.Z]) {  			ZoomMulti += 0.0001f;  		}  		if (game.Keyboard [Key.X] && ZoomMulti > 0.001f) {  			ZoomMulti -= 0.0001f;  		}  	};  	//for slowing down simulation  	int SimulationSlowDownStep = 0;  	game.RenderFrame += (sender' e) =>  {  		// render graphics  		//clears screen  		GL.Clear (ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);  		GL.MatrixMode (MatrixMode.Projection);  		Vector2 followPosition = new Vector2 (0' 0);  		matrix = Matrix4.CreateTranslation (ViewPointV);  		GL.LoadMatrix (ref matrix);  		GL.Ortho (-game.Width * ZoomMulti' game.Width * ZoomMulti' -game.Height * ZoomMulti' game.Height * ZoomMulti' 0.0' 4.0);  		//speedup / slowdown  		//slowdown?  		if (SimulationSpeed < 20) {  			//Stop simulation when sim speed = 0  			if (SimulationSpeed == 0)  				SimulationSlowDownStep = 1;  			SimulationSlowDownStep += SimulationSpeed;  			if (SimulationSlowDownStep > 20)  				SimulationSlowDownStep = 0;  		}  		else  			SimulationSlowDownStep = 0;  		Console.WriteLine (SimulationSpeed);  		for (int zx = 20; (zx < SimulationSpeed || zx == 20) && SimulationSlowDownStep == 0; zx++) {  			int['] arrNextTo = new int[iSizeOfGrid' iSizeOfGrid];  			//calculate neighbours  			for (int x = 0; x < iSizeOfGrid; x++) {  				for (int y = 0; y < iSizeOfGrid; y++) {  					if (arrAlive [x' y] == 1 && x > 1 && y > 1 && x < iSizeOfGrid - 1 && y < iSizeOfGrid - 1) {  						arrNextTo [x - 1' y - 1]++;  						arrNextTo [x - 1' y]++;  						arrNextTo [x - 1' y + 1]++;  						arrNextTo [x' y + 1]++;  						arrNextTo [x' y - 1]++;  						arrNextTo [x + 1' y - 1]++;  						arrNextTo [x + 1' y]++;  						arrNextTo [x + 1' y + 1]++;  					}  				}  			}  			//kill / revive  			for (int x = 0; x < iSizeOfGrid; x++) {  				for (int y = 0; y < iSizeOfGrid; y++) {  					if (arrNextTo [x' y] < 2 || arrNextTo [x' y] > 3) {  						arrAlive [x' y] = 0;  					}  					if (arrNextTo [x' y] == 3) {  						arrAlive [x' y] = 1;  					}  				}  			}  		}  		//Now draw the objects to the gamewindow  		GL.Color3 (Color.Yellow);  		GL.Begin (PrimitiveType.Quads);  		//Draw Cells  		for (int x = 0; x < iSizeOfGrid; x++) {  			//Console.WriteLine('n');  			for (int y = 0; y < iSizeOfGrid; y++) {  				//	Console.Write(arrAlive[x'y]);  				if (arrAlive [x' y] == 1) {  					GL.Vertex2 (x' y);  					GL.Vertex2 (x' y + 1);  					GL.Vertex2 (x + 1' y + 1);  					GL.Vertex2 (x + 1' y);  				}  			}  		}  		GL.End ();  		DrawCircle (30' ViewPointV.X' ViewPointV.Y' 1);  		Console.WriteLine (game.RenderFrequency);  		//load onto screen  		game.SwapBuffers ();  	};  	//run the game loop  	game.Run ();  }  
Magic Number,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following statement contains a magic number: using (var game = new GameWindow (700' 500' new GraphicsMode (32' 24' 0' 8))) {  	//seed array  	Random rand = new Random ();  	for (int i = 200; i < iSizeOfGrid - 200; i++) {  		for (int z = 200; z < iSizeOfGrid - 200; z++) {  			arrAlive [i' z] = rand.Next (3);  		}  	}  	//Console.WriteLine (arrAlive.ToString ());  	//run at 60fps  	game.TargetRenderFrequency = 20;  	Matrix4 matrix = Matrix4.CreateTranslation (0' 0' 0);  	game.Load += (sender' e) =>  {  		// setup settings' load textures' sounds  		game.VSync = VSyncMode.On;  		game.Title = "LIFE";  	};  	game.Resize += (sender' e) =>  {  		GL.Viewport (0' 0' game.Width' game.Height);  	};  	//mouse click to add logic  	Vector2 MoCinitialvec = new Vector2 (0f' 0f);  	Vector2 MoCdvec = new Vector2 (0f' 0f);  	bool MoCdraw = false;  	Vector3 PrevViewpoint = new Vector3 (0f' 0f' 0f);  	//enable textures  	GL.Enable (EnableCap.Texture2D);  	GL.BlendFunc (BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);  	//mouse click event  	game.Mouse.ButtonDown += (sender' e) =>  {  		MoCinitialvec = MousePosition (e.X' e.Y' game);  		MoCdvec = MoCinitialvec;  		//start adding an object  		if (e.Button == MouseButton.Left) {  			MoCdraw = true;  		}  		//start moving viewpoint  		if (e.Button == MouseButton.Right) {  			PrevViewpoint = ViewPointV;  		}  	};  	game.Mouse.ButtonUp += (sender' e) =>  {  		//if left click - add object  		if (e.Button == MouseButton.Left) {  			MoCdraw = false;  		}  	};  	//scroll wheel - zoom in / out  	game.Mouse.WheelChanged += (sender' e) =>  {  		if (ZoomMulti - e.DeltaPrecise * 0.001f > 0) {  			ZoomMulti -= e.DeltaPrecise * 0.001f;  		}  	};  	//moving mouse  	game.Mouse.Move += (sender' e) =>  {  		//for adding object  		MoCdvec = MousePosition (e.X' e.Y' game);  		if (e.X < 5 && e.Y < 5) {  			if (SimulationSpeed == 0)  				SimulationSpeed = 20;  			else  				SimulationSpeed = 0;  		}  		if (e.Mouse.LeftButton == ButtonState.Pressed) {  			try {  				arrAlive [(int)MoCdvec.X' (int)MoCdvec.Y] = 1;  			}  			catch {  			}  		}  		//for moving viewpoint  		if (e.Mouse.RightButton == ButtonState.Pressed) {  			ViewPointV = new Vector3 ((MoCdvec - MoCinitialvec).X / (game.Width * ZoomMulti)' (MoCdvec - MoCinitialvec).Y / (game.Height * ZoomMulti)' 0) + PrevViewpoint;  		}  	};  	//keyboard input  	game.KeyPress += (sender' e) =>  {  		switch (e.KeyChar) {  		case 'f':  			game.WindowState = WindowState.Fullscreen;  			break;  		case 'p':  			if (SimulationSpeed == 0)  				SimulationSpeed = 20;  			else  				SimulationSpeed = 0;  			break;  		case 'c':  			//seed array  			for (int i = 0; i < iSizeOfGrid; i++) {  				for (int z = 0; z < iSizeOfGrid; z++) {  					arrAlive [i' z] = 0;  				}  			}  			break;  		}  	};  	//more keyboard input  	game.UpdateFrame += (sender' e) =>  {  		if (game.Keyboard [Key.Escape]) {  			game.Exit ();  		}  		if (game.Keyboard [Key.A]) {  			ViewPointV.X += 0.01f;  		}  		if (game.Keyboard [Key.D]) {  			ViewPointV.X -= 0.01f;  		}  		if (game.Keyboard [Key.W]) {  			ViewPointV.Y -= 0.01f;  		}  		if (game.Keyboard [Key.S]) {  			ViewPointV.Y += 0.01f;  		}  		if (game.Keyboard [Key.Z]) {  			ZoomMulti += 0.0001f;  		}  		if (game.Keyboard [Key.X] && ZoomMulti > 0.001f) {  			ZoomMulti -= 0.0001f;  		}  	};  	//for slowing down simulation  	int SimulationSlowDownStep = 0;  	game.RenderFrame += (sender' e) =>  {  		// render graphics  		//clears screen  		GL.Clear (ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);  		GL.MatrixMode (MatrixMode.Projection);  		Vector2 followPosition = new Vector2 (0' 0);  		matrix = Matrix4.CreateTranslation (ViewPointV);  		GL.LoadMatrix (ref matrix);  		GL.Ortho (-game.Width * ZoomMulti' game.Width * ZoomMulti' -game.Height * ZoomMulti' game.Height * ZoomMulti' 0.0' 4.0);  		//speedup / slowdown  		//slowdown?  		if (SimulationSpeed < 20) {  			//Stop simulation when sim speed = 0  			if (SimulationSpeed == 0)  				SimulationSlowDownStep = 1;  			SimulationSlowDownStep += SimulationSpeed;  			if (SimulationSlowDownStep > 20)  				SimulationSlowDownStep = 0;  		}  		else  			SimulationSlowDownStep = 0;  		Console.WriteLine (SimulationSpeed);  		for (int zx = 20; (zx < SimulationSpeed || zx == 20) && SimulationSlowDownStep == 0; zx++) {  			int['] arrNextTo = new int[iSizeOfGrid' iSizeOfGrid];  			//calculate neighbours  			for (int x = 0; x < iSizeOfGrid; x++) {  				for (int y = 0; y < iSizeOfGrid; y++) {  					if (arrAlive [x' y] == 1 && x > 1 && y > 1 && x < iSizeOfGrid - 1 && y < iSizeOfGrid - 1) {  						arrNextTo [x - 1' y - 1]++;  						arrNextTo [x - 1' y]++;  						arrNextTo [x - 1' y + 1]++;  						arrNextTo [x' y + 1]++;  						arrNextTo [x' y - 1]++;  						arrNextTo [x + 1' y - 1]++;  						arrNextTo [x + 1' y]++;  						arrNextTo [x + 1' y + 1]++;  					}  				}  			}  			//kill / revive  			for (int x = 0; x < iSizeOfGrid; x++) {  				for (int y = 0; y < iSizeOfGrid; y++) {  					if (arrNextTo [x' y] < 2 || arrNextTo [x' y] > 3) {  						arrAlive [x' y] = 0;  					}  					if (arrNextTo [x' y] == 3) {  						arrAlive [x' y] = 1;  					}  				}  			}  		}  		//Now draw the objects to the gamewindow  		GL.Color3 (Color.Yellow);  		GL.Begin (PrimitiveType.Quads);  		//Draw Cells  		for (int x = 0; x < iSizeOfGrid; x++) {  			//Console.WriteLine('n');  			for (int y = 0; y < iSizeOfGrid; y++) {  				//	Console.Write(arrAlive[x'y]);  				if (arrAlive [x' y] == 1) {  					GL.Vertex2 (x' y);  					GL.Vertex2 (x' y + 1);  					GL.Vertex2 (x + 1' y + 1);  					GL.Vertex2 (x + 1' y);  				}  			}  		}  		GL.End ();  		DrawCircle (30' ViewPointV.X' ViewPointV.Y' 1);  		Console.WriteLine (game.RenderFrequency);  		//load onto screen  		game.SwapBuffers ();  	};  	//run the game loop  	game.Run ();  }  
Magic Number,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following statement contains a magic number: using (var game = new GameWindow (700' 500' new GraphicsMode (32' 24' 0' 8))) {  	//seed array  	Random rand = new Random ();  	for (int i = 200; i < iSizeOfGrid - 200; i++) {  		for (int z = 200; z < iSizeOfGrid - 200; z++) {  			arrAlive [i' z] = rand.Next (3);  		}  	}  	//Console.WriteLine (arrAlive.ToString ());  	//run at 60fps  	game.TargetRenderFrequency = 20;  	Matrix4 matrix = Matrix4.CreateTranslation (0' 0' 0);  	game.Load += (sender' e) =>  {  		// setup settings' load textures' sounds  		game.VSync = VSyncMode.On;  		game.Title = "LIFE";  	};  	game.Resize += (sender' e) =>  {  		GL.Viewport (0' 0' game.Width' game.Height);  	};  	//mouse click to add logic  	Vector2 MoCinitialvec = new Vector2 (0f' 0f);  	Vector2 MoCdvec = new Vector2 (0f' 0f);  	bool MoCdraw = false;  	Vector3 PrevViewpoint = new Vector3 (0f' 0f' 0f);  	//enable textures  	GL.Enable (EnableCap.Texture2D);  	GL.BlendFunc (BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);  	//mouse click event  	game.Mouse.ButtonDown += (sender' e) =>  {  		MoCinitialvec = MousePosition (e.X' e.Y' game);  		MoCdvec = MoCinitialvec;  		//start adding an object  		if (e.Button == MouseButton.Left) {  			MoCdraw = true;  		}  		//start moving viewpoint  		if (e.Button == MouseButton.Right) {  			PrevViewpoint = ViewPointV;  		}  	};  	game.Mouse.ButtonUp += (sender' e) =>  {  		//if left click - add object  		if (e.Button == MouseButton.Left) {  			MoCdraw = false;  		}  	};  	//scroll wheel - zoom in / out  	game.Mouse.WheelChanged += (sender' e) =>  {  		if (ZoomMulti - e.DeltaPrecise * 0.001f > 0) {  			ZoomMulti -= e.DeltaPrecise * 0.001f;  		}  	};  	//moving mouse  	game.Mouse.Move += (sender' e) =>  {  		//for adding object  		MoCdvec = MousePosition (e.X' e.Y' game);  		if (e.X < 5 && e.Y < 5) {  			if (SimulationSpeed == 0)  				SimulationSpeed = 20;  			else  				SimulationSpeed = 0;  		}  		if (e.Mouse.LeftButton == ButtonState.Pressed) {  			try {  				arrAlive [(int)MoCdvec.X' (int)MoCdvec.Y] = 1;  			}  			catch {  			}  		}  		//for moving viewpoint  		if (e.Mouse.RightButton == ButtonState.Pressed) {  			ViewPointV = new Vector3 ((MoCdvec - MoCinitialvec).X / (game.Width * ZoomMulti)' (MoCdvec - MoCinitialvec).Y / (game.Height * ZoomMulti)' 0) + PrevViewpoint;  		}  	};  	//keyboard input  	game.KeyPress += (sender' e) =>  {  		switch (e.KeyChar) {  		case 'f':  			game.WindowState = WindowState.Fullscreen;  			break;  		case 'p':  			if (SimulationSpeed == 0)  				SimulationSpeed = 20;  			else  				SimulationSpeed = 0;  			break;  		case 'c':  			//seed array  			for (int i = 0; i < iSizeOfGrid; i++) {  				for (int z = 0; z < iSizeOfGrid; z++) {  					arrAlive [i' z] = 0;  				}  			}  			break;  		}  	};  	//more keyboard input  	game.UpdateFrame += (sender' e) =>  {  		if (game.Keyboard [Key.Escape]) {  			game.Exit ();  		}  		if (game.Keyboard [Key.A]) {  			ViewPointV.X += 0.01f;  		}  		if (game.Keyboard [Key.D]) {  			ViewPointV.X -= 0.01f;  		}  		if (game.Keyboard [Key.W]) {  			ViewPointV.Y -= 0.01f;  		}  		if (game.Keyboard [Key.S]) {  			ViewPointV.Y += 0.01f;  		}  		if (game.Keyboard [Key.Z]) {  			ZoomMulti += 0.0001f;  		}  		if (game.Keyboard [Key.X] && ZoomMulti > 0.001f) {  			ZoomMulti -= 0.0001f;  		}  	};  	//for slowing down simulation  	int SimulationSlowDownStep = 0;  	game.RenderFrame += (sender' e) =>  {  		// render graphics  		//clears screen  		GL.Clear (ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);  		GL.MatrixMode (MatrixMode.Projection);  		Vector2 followPosition = new Vector2 (0' 0);  		matrix = Matrix4.CreateTranslation (ViewPointV);  		GL.LoadMatrix (ref matrix);  		GL.Ortho (-game.Width * ZoomMulti' game.Width * ZoomMulti' -game.Height * ZoomMulti' game.Height * ZoomMulti' 0.0' 4.0);  		//speedup / slowdown  		//slowdown?  		if (SimulationSpeed < 20) {  			//Stop simulation when sim speed = 0  			if (SimulationSpeed == 0)  				SimulationSlowDownStep = 1;  			SimulationSlowDownStep += SimulationSpeed;  			if (SimulationSlowDownStep > 20)  				SimulationSlowDownStep = 0;  		}  		else  			SimulationSlowDownStep = 0;  		Console.WriteLine (SimulationSpeed);  		for (int zx = 20; (zx < SimulationSpeed || zx == 20) && SimulationSlowDownStep == 0; zx++) {  			int['] arrNextTo = new int[iSizeOfGrid' iSizeOfGrid];  			//calculate neighbours  			for (int x = 0; x < iSizeOfGrid; x++) {  				for (int y = 0; y < iSizeOfGrid; y++) {  					if (arrAlive [x' y] == 1 && x > 1 && y > 1 && x < iSizeOfGrid - 1 && y < iSizeOfGrid - 1) {  						arrNextTo [x - 1' y - 1]++;  						arrNextTo [x - 1' y]++;  						arrNextTo [x - 1' y + 1]++;  						arrNextTo [x' y + 1]++;  						arrNextTo [x' y - 1]++;  						arrNextTo [x + 1' y - 1]++;  						arrNextTo [x + 1' y]++;  						arrNextTo [x + 1' y + 1]++;  					}  				}  			}  			//kill / revive  			for (int x = 0; x < iSizeOfGrid; x++) {  				for (int y = 0; y < iSizeOfGrid; y++) {  					if (arrNextTo [x' y] < 2 || arrNextTo [x' y] > 3) {  						arrAlive [x' y] = 0;  					}  					if (arrNextTo [x' y] == 3) {  						arrAlive [x' y] = 1;  					}  				}  			}  		}  		//Now draw the objects to the gamewindow  		GL.Color3 (Color.Yellow);  		GL.Begin (PrimitiveType.Quads);  		//Draw Cells  		for (int x = 0; x < iSizeOfGrid; x++) {  			//Console.WriteLine('n');  			for (int y = 0; y < iSizeOfGrid; y++) {  				//	Console.Write(arrAlive[x'y]);  				if (arrAlive [x' y] == 1) {  					GL.Vertex2 (x' y);  					GL.Vertex2 (x' y + 1);  					GL.Vertex2 (x + 1' y + 1);  					GL.Vertex2 (x + 1' y);  				}  			}  		}  		GL.End ();  		DrawCircle (30' ViewPointV.X' ViewPointV.Y' 1);  		Console.WriteLine (game.RenderFrequency);  		//load onto screen  		game.SwapBuffers ();  	};  	//run the game loop  	game.Run ();  }  
Magic Number,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following statement contains a magic number: using (var game = new GameWindow (700' 500' new GraphicsMode (32' 24' 0' 8))) {  	//seed array  	Random rand = new Random ();  	for (int i = 200; i < iSizeOfGrid - 200; i++) {  		for (int z = 200; z < iSizeOfGrid - 200; z++) {  			arrAlive [i' z] = rand.Next (3);  		}  	}  	//Console.WriteLine (arrAlive.ToString ());  	//run at 60fps  	game.TargetRenderFrequency = 20;  	Matrix4 matrix = Matrix4.CreateTranslation (0' 0' 0);  	game.Load += (sender' e) =>  {  		// setup settings' load textures' sounds  		game.VSync = VSyncMode.On;  		game.Title = "LIFE";  	};  	game.Resize += (sender' e) =>  {  		GL.Viewport (0' 0' game.Width' game.Height);  	};  	//mouse click to add logic  	Vector2 MoCinitialvec = new Vector2 (0f' 0f);  	Vector2 MoCdvec = new Vector2 (0f' 0f);  	bool MoCdraw = false;  	Vector3 PrevViewpoint = new Vector3 (0f' 0f' 0f);  	//enable textures  	GL.Enable (EnableCap.Texture2D);  	GL.BlendFunc (BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);  	//mouse click event  	game.Mouse.ButtonDown += (sender' e) =>  {  		MoCinitialvec = MousePosition (e.X' e.Y' game);  		MoCdvec = MoCinitialvec;  		//start adding an object  		if (e.Button == MouseButton.Left) {  			MoCdraw = true;  		}  		//start moving viewpoint  		if (e.Button == MouseButton.Right) {  			PrevViewpoint = ViewPointV;  		}  	};  	game.Mouse.ButtonUp += (sender' e) =>  {  		//if left click - add object  		if (e.Button == MouseButton.Left) {  			MoCdraw = false;  		}  	};  	//scroll wheel - zoom in / out  	game.Mouse.WheelChanged += (sender' e) =>  {  		if (ZoomMulti - e.DeltaPrecise * 0.001f > 0) {  			ZoomMulti -= e.DeltaPrecise * 0.001f;  		}  	};  	//moving mouse  	game.Mouse.Move += (sender' e) =>  {  		//for adding object  		MoCdvec = MousePosition (e.X' e.Y' game);  		if (e.X < 5 && e.Y < 5) {  			if (SimulationSpeed == 0)  				SimulationSpeed = 20;  			else  				SimulationSpeed = 0;  		}  		if (e.Mouse.LeftButton == ButtonState.Pressed) {  			try {  				arrAlive [(int)MoCdvec.X' (int)MoCdvec.Y] = 1;  			}  			catch {  			}  		}  		//for moving viewpoint  		if (e.Mouse.RightButton == ButtonState.Pressed) {  			ViewPointV = new Vector3 ((MoCdvec - MoCinitialvec).X / (game.Width * ZoomMulti)' (MoCdvec - MoCinitialvec).Y / (game.Height * ZoomMulti)' 0) + PrevViewpoint;  		}  	};  	//keyboard input  	game.KeyPress += (sender' e) =>  {  		switch (e.KeyChar) {  		case 'f':  			game.WindowState = WindowState.Fullscreen;  			break;  		case 'p':  			if (SimulationSpeed == 0)  				SimulationSpeed = 20;  			else  				SimulationSpeed = 0;  			break;  		case 'c':  			//seed array  			for (int i = 0; i < iSizeOfGrid; i++) {  				for (int z = 0; z < iSizeOfGrid; z++) {  					arrAlive [i' z] = 0;  				}  			}  			break;  		}  	};  	//more keyboard input  	game.UpdateFrame += (sender' e) =>  {  		if (game.Keyboard [Key.Escape]) {  			game.Exit ();  		}  		if (game.Keyboard [Key.A]) {  			ViewPointV.X += 0.01f;  		}  		if (game.Keyboard [Key.D]) {  			ViewPointV.X -= 0.01f;  		}  		if (game.Keyboard [Key.W]) {  			ViewPointV.Y -= 0.01f;  		}  		if (game.Keyboard [Key.S]) {  			ViewPointV.Y += 0.01f;  		}  		if (game.Keyboard [Key.Z]) {  			ZoomMulti += 0.0001f;  		}  		if (game.Keyboard [Key.X] && ZoomMulti > 0.001f) {  			ZoomMulti -= 0.0001f;  		}  	};  	//for slowing down simulation  	int SimulationSlowDownStep = 0;  	game.RenderFrame += (sender' e) =>  {  		// render graphics  		//clears screen  		GL.Clear (ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);  		GL.MatrixMode (MatrixMode.Projection);  		Vector2 followPosition = new Vector2 (0' 0);  		matrix = Matrix4.CreateTranslation (ViewPointV);  		GL.LoadMatrix (ref matrix);  		GL.Ortho (-game.Width * ZoomMulti' game.Width * ZoomMulti' -game.Height * ZoomMulti' game.Height * ZoomMulti' 0.0' 4.0);  		//speedup / slowdown  		//slowdown?  		if (SimulationSpeed < 20) {  			//Stop simulation when sim speed = 0  			if (SimulationSpeed == 0)  				SimulationSlowDownStep = 1;  			SimulationSlowDownStep += SimulationSpeed;  			if (SimulationSlowDownStep > 20)  				SimulationSlowDownStep = 0;  		}  		else  			SimulationSlowDownStep = 0;  		Console.WriteLine (SimulationSpeed);  		for (int zx = 20; (zx < SimulationSpeed || zx == 20) && SimulationSlowDownStep == 0; zx++) {  			int['] arrNextTo = new int[iSizeOfGrid' iSizeOfGrid];  			//calculate neighbours  			for (int x = 0; x < iSizeOfGrid; x++) {  				for (int y = 0; y < iSizeOfGrid; y++) {  					if (arrAlive [x' y] == 1 && x > 1 && y > 1 && x < iSizeOfGrid - 1 && y < iSizeOfGrid - 1) {  						arrNextTo [x - 1' y - 1]++;  						arrNextTo [x - 1' y]++;  						arrNextTo [x - 1' y + 1]++;  						arrNextTo [x' y + 1]++;  						arrNextTo [x' y - 1]++;  						arrNextTo [x + 1' y - 1]++;  						arrNextTo [x + 1' y]++;  						arrNextTo [x + 1' y + 1]++;  					}  				}  			}  			//kill / revive  			for (int x = 0; x < iSizeOfGrid; x++) {  				for (int y = 0; y < iSizeOfGrid; y++) {  					if (arrNextTo [x' y] < 2 || arrNextTo [x' y] > 3) {  						arrAlive [x' y] = 0;  					}  					if (arrNextTo [x' y] == 3) {  						arrAlive [x' y] = 1;  					}  				}  			}  		}  		//Now draw the objects to the gamewindow  		GL.Color3 (Color.Yellow);  		GL.Begin (PrimitiveType.Quads);  		//Draw Cells  		for (int x = 0; x < iSizeOfGrid; x++) {  			//Console.WriteLine('n');  			for (int y = 0; y < iSizeOfGrid; y++) {  				//	Console.Write(arrAlive[x'y]);  				if (arrAlive [x' y] == 1) {  					GL.Vertex2 (x' y);  					GL.Vertex2 (x' y + 1);  					GL.Vertex2 (x + 1' y + 1);  					GL.Vertex2 (x + 1' y);  				}  			}  		}  		GL.End ();  		DrawCircle (30' ViewPointV.X' ViewPointV.Y' 1);  		Console.WriteLine (game.RenderFrequency);  		//load onto screen  		game.SwapBuffers ();  	};  	//run the game loop  	game.Run ();  }  
Magic Number,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following statement contains a magic number: using (var game = new GameWindow (700' 500' new GraphicsMode (32' 24' 0' 8))) {  	//seed array  	Random rand = new Random ();  	for (int i = 200; i < iSizeOfGrid - 200; i++) {  		for (int z = 200; z < iSizeOfGrid - 200; z++) {  			arrAlive [i' z] = rand.Next (3);  		}  	}  	//Console.WriteLine (arrAlive.ToString ());  	//run at 60fps  	game.TargetRenderFrequency = 20;  	Matrix4 matrix = Matrix4.CreateTranslation (0' 0' 0);  	game.Load += (sender' e) =>  {  		// setup settings' load textures' sounds  		game.VSync = VSyncMode.On;  		game.Title = "LIFE";  	};  	game.Resize += (sender' e) =>  {  		GL.Viewport (0' 0' game.Width' game.Height);  	};  	//mouse click to add logic  	Vector2 MoCinitialvec = new Vector2 (0f' 0f);  	Vector2 MoCdvec = new Vector2 (0f' 0f);  	bool MoCdraw = false;  	Vector3 PrevViewpoint = new Vector3 (0f' 0f' 0f);  	//enable textures  	GL.Enable (EnableCap.Texture2D);  	GL.BlendFunc (BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);  	//mouse click event  	game.Mouse.ButtonDown += (sender' e) =>  {  		MoCinitialvec = MousePosition (e.X' e.Y' game);  		MoCdvec = MoCinitialvec;  		//start adding an object  		if (e.Button == MouseButton.Left) {  			MoCdraw = true;  		}  		//start moving viewpoint  		if (e.Button == MouseButton.Right) {  			PrevViewpoint = ViewPointV;  		}  	};  	game.Mouse.ButtonUp += (sender' e) =>  {  		//if left click - add object  		if (e.Button == MouseButton.Left) {  			MoCdraw = false;  		}  	};  	//scroll wheel - zoom in / out  	game.Mouse.WheelChanged += (sender' e) =>  {  		if (ZoomMulti - e.DeltaPrecise * 0.001f > 0) {  			ZoomMulti -= e.DeltaPrecise * 0.001f;  		}  	};  	//moving mouse  	game.Mouse.Move += (sender' e) =>  {  		//for adding object  		MoCdvec = MousePosition (e.X' e.Y' game);  		if (e.X < 5 && e.Y < 5) {  			if (SimulationSpeed == 0)  				SimulationSpeed = 20;  			else  				SimulationSpeed = 0;  		}  		if (e.Mouse.LeftButton == ButtonState.Pressed) {  			try {  				arrAlive [(int)MoCdvec.X' (int)MoCdvec.Y] = 1;  			}  			catch {  			}  		}  		//for moving viewpoint  		if (e.Mouse.RightButton == ButtonState.Pressed) {  			ViewPointV = new Vector3 ((MoCdvec - MoCinitialvec).X / (game.Width * ZoomMulti)' (MoCdvec - MoCinitialvec).Y / (game.Height * ZoomMulti)' 0) + PrevViewpoint;  		}  	};  	//keyboard input  	game.KeyPress += (sender' e) =>  {  		switch (e.KeyChar) {  		case 'f':  			game.WindowState = WindowState.Fullscreen;  			break;  		case 'p':  			if (SimulationSpeed == 0)  				SimulationSpeed = 20;  			else  				SimulationSpeed = 0;  			break;  		case 'c':  			//seed array  			for (int i = 0; i < iSizeOfGrid; i++) {  				for (int z = 0; z < iSizeOfGrid; z++) {  					arrAlive [i' z] = 0;  				}  			}  			break;  		}  	};  	//more keyboard input  	game.UpdateFrame += (sender' e) =>  {  		if (game.Keyboard [Key.Escape]) {  			game.Exit ();  		}  		if (game.Keyboard [Key.A]) {  			ViewPointV.X += 0.01f;  		}  		if (game.Keyboard [Key.D]) {  			ViewPointV.X -= 0.01f;  		}  		if (game.Keyboard [Key.W]) {  			ViewPointV.Y -= 0.01f;  		}  		if (game.Keyboard [Key.S]) {  			ViewPointV.Y += 0.01f;  		}  		if (game.Keyboard [Key.Z]) {  			ZoomMulti += 0.0001f;  		}  		if (game.Keyboard [Key.X] && ZoomMulti > 0.001f) {  			ZoomMulti -= 0.0001f;  		}  	};  	//for slowing down simulation  	int SimulationSlowDownStep = 0;  	game.RenderFrame += (sender' e) =>  {  		// render graphics  		//clears screen  		GL.Clear (ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);  		GL.MatrixMode (MatrixMode.Projection);  		Vector2 followPosition = new Vector2 (0' 0);  		matrix = Matrix4.CreateTranslation (ViewPointV);  		GL.LoadMatrix (ref matrix);  		GL.Ortho (-game.Width * ZoomMulti' game.Width * ZoomMulti' -game.Height * ZoomMulti' game.Height * ZoomMulti' 0.0' 4.0);  		//speedup / slowdown  		//slowdown?  		if (SimulationSpeed < 20) {  			//Stop simulation when sim speed = 0  			if (SimulationSpeed == 0)  				SimulationSlowDownStep = 1;  			SimulationSlowDownStep += SimulationSpeed;  			if (SimulationSlowDownStep > 20)  				SimulationSlowDownStep = 0;  		}  		else  			SimulationSlowDownStep = 0;  		Console.WriteLine (SimulationSpeed);  		for (int zx = 20; (zx < SimulationSpeed || zx == 20) && SimulationSlowDownStep == 0; zx++) {  			int['] arrNextTo = new int[iSizeOfGrid' iSizeOfGrid];  			//calculate neighbours  			for (int x = 0; x < iSizeOfGrid; x++) {  				for (int y = 0; y < iSizeOfGrid; y++) {  					if (arrAlive [x' y] == 1 && x > 1 && y > 1 && x < iSizeOfGrid - 1 && y < iSizeOfGrid - 1) {  						arrNextTo [x - 1' y - 1]++;  						arrNextTo [x - 1' y]++;  						arrNextTo [x - 1' y + 1]++;  						arrNextTo [x' y + 1]++;  						arrNextTo [x' y - 1]++;  						arrNextTo [x + 1' y - 1]++;  						arrNextTo [x + 1' y]++;  						arrNextTo [x + 1' y + 1]++;  					}  				}  			}  			//kill / revive  			for (int x = 0; x < iSizeOfGrid; x++) {  				for (int y = 0; y < iSizeOfGrid; y++) {  					if (arrNextTo [x' y] < 2 || arrNextTo [x' y] > 3) {  						arrAlive [x' y] = 0;  					}  					if (arrNextTo [x' y] == 3) {  						arrAlive [x' y] = 1;  					}  				}  			}  		}  		//Now draw the objects to the gamewindow  		GL.Color3 (Color.Yellow);  		GL.Begin (PrimitiveType.Quads);  		//Draw Cells  		for (int x = 0; x < iSizeOfGrid; x++) {  			//Console.WriteLine('n');  			for (int y = 0; y < iSizeOfGrid; y++) {  				//	Console.Write(arrAlive[x'y]);  				if (arrAlive [x' y] == 1) {  					GL.Vertex2 (x' y);  					GL.Vertex2 (x' y + 1);  					GL.Vertex2 (x + 1' y + 1);  					GL.Vertex2 (x + 1' y);  				}  			}  		}  		GL.End ();  		DrawCircle (30' ViewPointV.X' ViewPointV.Y' 1);  		Console.WriteLine (game.RenderFrequency);  		//load onto screen  		game.SwapBuffers ();  	};  	//run the game loop  	game.Run ();  }  
Magic Number,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following statement contains a magic number: using (var game = new GameWindow (700' 500' new GraphicsMode (32' 24' 0' 8))) {  	//seed array  	Random rand = new Random ();  	for (int i = 200; i < iSizeOfGrid - 200; i++) {  		for (int z = 200; z < iSizeOfGrid - 200; z++) {  			arrAlive [i' z] = rand.Next (3);  		}  	}  	//Console.WriteLine (arrAlive.ToString ());  	//run at 60fps  	game.TargetRenderFrequency = 20;  	Matrix4 matrix = Matrix4.CreateTranslation (0' 0' 0);  	game.Load += (sender' e) =>  {  		// setup settings' load textures' sounds  		game.VSync = VSyncMode.On;  		game.Title = "LIFE";  	};  	game.Resize += (sender' e) =>  {  		GL.Viewport (0' 0' game.Width' game.Height);  	};  	//mouse click to add logic  	Vector2 MoCinitialvec = new Vector2 (0f' 0f);  	Vector2 MoCdvec = new Vector2 (0f' 0f);  	bool MoCdraw = false;  	Vector3 PrevViewpoint = new Vector3 (0f' 0f' 0f);  	//enable textures  	GL.Enable (EnableCap.Texture2D);  	GL.BlendFunc (BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);  	//mouse click event  	game.Mouse.ButtonDown += (sender' e) =>  {  		MoCinitialvec = MousePosition (e.X' e.Y' game);  		MoCdvec = MoCinitialvec;  		//start adding an object  		if (e.Button == MouseButton.Left) {  			MoCdraw = true;  		}  		//start moving viewpoint  		if (e.Button == MouseButton.Right) {  			PrevViewpoint = ViewPointV;  		}  	};  	game.Mouse.ButtonUp += (sender' e) =>  {  		//if left click - add object  		if (e.Button == MouseButton.Left) {  			MoCdraw = false;  		}  	};  	//scroll wheel - zoom in / out  	game.Mouse.WheelChanged += (sender' e) =>  {  		if (ZoomMulti - e.DeltaPrecise * 0.001f > 0) {  			ZoomMulti -= e.DeltaPrecise * 0.001f;  		}  	};  	//moving mouse  	game.Mouse.Move += (sender' e) =>  {  		//for adding object  		MoCdvec = MousePosition (e.X' e.Y' game);  		if (e.X < 5 && e.Y < 5) {  			if (SimulationSpeed == 0)  				SimulationSpeed = 20;  			else  				SimulationSpeed = 0;  		}  		if (e.Mouse.LeftButton == ButtonState.Pressed) {  			try {  				arrAlive [(int)MoCdvec.X' (int)MoCdvec.Y] = 1;  			}  			catch {  			}  		}  		//for moving viewpoint  		if (e.Mouse.RightButton == ButtonState.Pressed) {  			ViewPointV = new Vector3 ((MoCdvec - MoCinitialvec).X / (game.Width * ZoomMulti)' (MoCdvec - MoCinitialvec).Y / (game.Height * ZoomMulti)' 0) + PrevViewpoint;  		}  	};  	//keyboard input  	game.KeyPress += (sender' e) =>  {  		switch (e.KeyChar) {  		case 'f':  			game.WindowState = WindowState.Fullscreen;  			break;  		case 'p':  			if (SimulationSpeed == 0)  				SimulationSpeed = 20;  			else  				SimulationSpeed = 0;  			break;  		case 'c':  			//seed array  			for (int i = 0; i < iSizeOfGrid; i++) {  				for (int z = 0; z < iSizeOfGrid; z++) {  					arrAlive [i' z] = 0;  				}  			}  			break;  		}  	};  	//more keyboard input  	game.UpdateFrame += (sender' e) =>  {  		if (game.Keyboard [Key.Escape]) {  			game.Exit ();  		}  		if (game.Keyboard [Key.A]) {  			ViewPointV.X += 0.01f;  		}  		if (game.Keyboard [Key.D]) {  			ViewPointV.X -= 0.01f;  		}  		if (game.Keyboard [Key.W]) {  			ViewPointV.Y -= 0.01f;  		}  		if (game.Keyboard [Key.S]) {  			ViewPointV.Y += 0.01f;  		}  		if (game.Keyboard [Key.Z]) {  			ZoomMulti += 0.0001f;  		}  		if (game.Keyboard [Key.X] && ZoomMulti > 0.001f) {  			ZoomMulti -= 0.0001f;  		}  	};  	//for slowing down simulation  	int SimulationSlowDownStep = 0;  	game.RenderFrame += (sender' e) =>  {  		// render graphics  		//clears screen  		GL.Clear (ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);  		GL.MatrixMode (MatrixMode.Projection);  		Vector2 followPosition = new Vector2 (0' 0);  		matrix = Matrix4.CreateTranslation (ViewPointV);  		GL.LoadMatrix (ref matrix);  		GL.Ortho (-game.Width * ZoomMulti' game.Width * ZoomMulti' -game.Height * ZoomMulti' game.Height * ZoomMulti' 0.0' 4.0);  		//speedup / slowdown  		//slowdown?  		if (SimulationSpeed < 20) {  			//Stop simulation when sim speed = 0  			if (SimulationSpeed == 0)  				SimulationSlowDownStep = 1;  			SimulationSlowDownStep += SimulationSpeed;  			if (SimulationSlowDownStep > 20)  				SimulationSlowDownStep = 0;  		}  		else  			SimulationSlowDownStep = 0;  		Console.WriteLine (SimulationSpeed);  		for (int zx = 20; (zx < SimulationSpeed || zx == 20) && SimulationSlowDownStep == 0; zx++) {  			int['] arrNextTo = new int[iSizeOfGrid' iSizeOfGrid];  			//calculate neighbours  			for (int x = 0; x < iSizeOfGrid; x++) {  				for (int y = 0; y < iSizeOfGrid; y++) {  					if (arrAlive [x' y] == 1 && x > 1 && y > 1 && x < iSizeOfGrid - 1 && y < iSizeOfGrid - 1) {  						arrNextTo [x - 1' y - 1]++;  						arrNextTo [x - 1' y]++;  						arrNextTo [x - 1' y + 1]++;  						arrNextTo [x' y + 1]++;  						arrNextTo [x' y - 1]++;  						arrNextTo [x + 1' y - 1]++;  						arrNextTo [x + 1' y]++;  						arrNextTo [x + 1' y + 1]++;  					}  				}  			}  			//kill / revive  			for (int x = 0; x < iSizeOfGrid; x++) {  				for (int y = 0; y < iSizeOfGrid; y++) {  					if (arrNextTo [x' y] < 2 || arrNextTo [x' y] > 3) {  						arrAlive [x' y] = 0;  					}  					if (arrNextTo [x' y] == 3) {  						arrAlive [x' y] = 1;  					}  				}  			}  		}  		//Now draw the objects to the gamewindow  		GL.Color3 (Color.Yellow);  		GL.Begin (PrimitiveType.Quads);  		//Draw Cells  		for (int x = 0; x < iSizeOfGrid; x++) {  			//Console.WriteLine('n');  			for (int y = 0; y < iSizeOfGrid; y++) {  				//	Console.Write(arrAlive[x'y]);  				if (arrAlive [x' y] == 1) {  					GL.Vertex2 (x' y);  					GL.Vertex2 (x' y + 1);  					GL.Vertex2 (x + 1' y + 1);  					GL.Vertex2 (x + 1' y);  				}  			}  		}  		GL.End ();  		DrawCircle (30' ViewPointV.X' ViewPointV.Y' 1);  		Console.WriteLine (game.RenderFrequency);  		//load onto screen  		game.SwapBuffers ();  	};  	//run the game loop  	game.Run ();  }  
Magic Number,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following statement contains a magic number: using (var game = new GameWindow (700' 500' new GraphicsMode (32' 24' 0' 8))) {  	//seed array  	Random rand = new Random ();  	for (int i = 200; i < iSizeOfGrid - 200; i++) {  		for (int z = 200; z < iSizeOfGrid - 200; z++) {  			arrAlive [i' z] = rand.Next (3);  		}  	}  	//Console.WriteLine (arrAlive.ToString ());  	//run at 60fps  	game.TargetRenderFrequency = 20;  	Matrix4 matrix = Matrix4.CreateTranslation (0' 0' 0);  	game.Load += (sender' e) =>  {  		// setup settings' load textures' sounds  		game.VSync = VSyncMode.On;  		game.Title = "LIFE";  	};  	game.Resize += (sender' e) =>  {  		GL.Viewport (0' 0' game.Width' game.Height);  	};  	//mouse click to add logic  	Vector2 MoCinitialvec = new Vector2 (0f' 0f);  	Vector2 MoCdvec = new Vector2 (0f' 0f);  	bool MoCdraw = false;  	Vector3 PrevViewpoint = new Vector3 (0f' 0f' 0f);  	//enable textures  	GL.Enable (EnableCap.Texture2D);  	GL.BlendFunc (BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);  	//mouse click event  	game.Mouse.ButtonDown += (sender' e) =>  {  		MoCinitialvec = MousePosition (e.X' e.Y' game);  		MoCdvec = MoCinitialvec;  		//start adding an object  		if (e.Button == MouseButton.Left) {  			MoCdraw = true;  		}  		//start moving viewpoint  		if (e.Button == MouseButton.Right) {  			PrevViewpoint = ViewPointV;  		}  	};  	game.Mouse.ButtonUp += (sender' e) =>  {  		//if left click - add object  		if (e.Button == MouseButton.Left) {  			MoCdraw = false;  		}  	};  	//scroll wheel - zoom in / out  	game.Mouse.WheelChanged += (sender' e) =>  {  		if (ZoomMulti - e.DeltaPrecise * 0.001f > 0) {  			ZoomMulti -= e.DeltaPrecise * 0.001f;  		}  	};  	//moving mouse  	game.Mouse.Move += (sender' e) =>  {  		//for adding object  		MoCdvec = MousePosition (e.X' e.Y' game);  		if (e.X < 5 && e.Y < 5) {  			if (SimulationSpeed == 0)  				SimulationSpeed = 20;  			else  				SimulationSpeed = 0;  		}  		if (e.Mouse.LeftButton == ButtonState.Pressed) {  			try {  				arrAlive [(int)MoCdvec.X' (int)MoCdvec.Y] = 1;  			}  			catch {  			}  		}  		//for moving viewpoint  		if (e.Mouse.RightButton == ButtonState.Pressed) {  			ViewPointV = new Vector3 ((MoCdvec - MoCinitialvec).X / (game.Width * ZoomMulti)' (MoCdvec - MoCinitialvec).Y / (game.Height * ZoomMulti)' 0) + PrevViewpoint;  		}  	};  	//keyboard input  	game.KeyPress += (sender' e) =>  {  		switch (e.KeyChar) {  		case 'f':  			game.WindowState = WindowState.Fullscreen;  			break;  		case 'p':  			if (SimulationSpeed == 0)  				SimulationSpeed = 20;  			else  				SimulationSpeed = 0;  			break;  		case 'c':  			//seed array  			for (int i = 0; i < iSizeOfGrid; i++) {  				for (int z = 0; z < iSizeOfGrid; z++) {  					arrAlive [i' z] = 0;  				}  			}  			break;  		}  	};  	//more keyboard input  	game.UpdateFrame += (sender' e) =>  {  		if (game.Keyboard [Key.Escape]) {  			game.Exit ();  		}  		if (game.Keyboard [Key.A]) {  			ViewPointV.X += 0.01f;  		}  		if (game.Keyboard [Key.D]) {  			ViewPointV.X -= 0.01f;  		}  		if (game.Keyboard [Key.W]) {  			ViewPointV.Y -= 0.01f;  		}  		if (game.Keyboard [Key.S]) {  			ViewPointV.Y += 0.01f;  		}  		if (game.Keyboard [Key.Z]) {  			ZoomMulti += 0.0001f;  		}  		if (game.Keyboard [Key.X] && ZoomMulti > 0.001f) {  			ZoomMulti -= 0.0001f;  		}  	};  	//for slowing down simulation  	int SimulationSlowDownStep = 0;  	game.RenderFrame += (sender' e) =>  {  		// render graphics  		//clears screen  		GL.Clear (ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);  		GL.MatrixMode (MatrixMode.Projection);  		Vector2 followPosition = new Vector2 (0' 0);  		matrix = Matrix4.CreateTranslation (ViewPointV);  		GL.LoadMatrix (ref matrix);  		GL.Ortho (-game.Width * ZoomMulti' game.Width * ZoomMulti' -game.Height * ZoomMulti' game.Height * ZoomMulti' 0.0' 4.0);  		//speedup / slowdown  		//slowdown?  		if (SimulationSpeed < 20) {  			//Stop simulation when sim speed = 0  			if (SimulationSpeed == 0)  				SimulationSlowDownStep = 1;  			SimulationSlowDownStep += SimulationSpeed;  			if (SimulationSlowDownStep > 20)  				SimulationSlowDownStep = 0;  		}  		else  			SimulationSlowDownStep = 0;  		Console.WriteLine (SimulationSpeed);  		for (int zx = 20; (zx < SimulationSpeed || zx == 20) && SimulationSlowDownStep == 0; zx++) {  			int['] arrNextTo = new int[iSizeOfGrid' iSizeOfGrid];  			//calculate neighbours  			for (int x = 0; x < iSizeOfGrid; x++) {  				for (int y = 0; y < iSizeOfGrid; y++) {  					if (arrAlive [x' y] == 1 && x > 1 && y > 1 && x < iSizeOfGrid - 1 && y < iSizeOfGrid - 1) {  						arrNextTo [x - 1' y - 1]++;  						arrNextTo [x - 1' y]++;  						arrNextTo [x - 1' y + 1]++;  						arrNextTo [x' y + 1]++;  						arrNextTo [x' y - 1]++;  						arrNextTo [x + 1' y - 1]++;  						arrNextTo [x + 1' y]++;  						arrNextTo [x + 1' y + 1]++;  					}  				}  			}  			//kill / revive  			for (int x = 0; x < iSizeOfGrid; x++) {  				for (int y = 0; y < iSizeOfGrid; y++) {  					if (arrNextTo [x' y] < 2 || arrNextTo [x' y] > 3) {  						arrAlive [x' y] = 0;  					}  					if (arrNextTo [x' y] == 3) {  						arrAlive [x' y] = 1;  					}  				}  			}  		}  		//Now draw the objects to the gamewindow  		GL.Color3 (Color.Yellow);  		GL.Begin (PrimitiveType.Quads);  		//Draw Cells  		for (int x = 0; x < iSizeOfGrid; x++) {  			//Console.WriteLine('n');  			for (int y = 0; y < iSizeOfGrid; y++) {  				//	Console.Write(arrAlive[x'y]);  				if (arrAlive [x' y] == 1) {  					GL.Vertex2 (x' y);  					GL.Vertex2 (x' y + 1);  					GL.Vertex2 (x + 1' y + 1);  					GL.Vertex2 (x + 1' y);  				}  			}  		}  		GL.End ();  		DrawCircle (30' ViewPointV.X' ViewPointV.Y' 1);  		Console.WriteLine (game.RenderFrequency);  		//load onto screen  		game.SwapBuffers ();  	};  	//run the game loop  	game.Run ();  }  
Magic Number,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following statement contains a magic number: using (var game = new GameWindow (700' 500' new GraphicsMode (32' 24' 0' 8))) {  	//seed array  	Random rand = new Random ();  	for (int i = 200; i < iSizeOfGrid - 200; i++) {  		for (int z = 200; z < iSizeOfGrid - 200; z++) {  			arrAlive [i' z] = rand.Next (3);  		}  	}  	//Console.WriteLine (arrAlive.ToString ());  	//run at 60fps  	game.TargetRenderFrequency = 20;  	Matrix4 matrix = Matrix4.CreateTranslation (0' 0' 0);  	game.Load += (sender' e) =>  {  		// setup settings' load textures' sounds  		game.VSync = VSyncMode.On;  		game.Title = "LIFE";  	};  	game.Resize += (sender' e) =>  {  		GL.Viewport (0' 0' game.Width' game.Height);  	};  	//mouse click to add logic  	Vector2 MoCinitialvec = new Vector2 (0f' 0f);  	Vector2 MoCdvec = new Vector2 (0f' 0f);  	bool MoCdraw = false;  	Vector3 PrevViewpoint = new Vector3 (0f' 0f' 0f);  	//enable textures  	GL.Enable (EnableCap.Texture2D);  	GL.BlendFunc (BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);  	//mouse click event  	game.Mouse.ButtonDown += (sender' e) =>  {  		MoCinitialvec = MousePosition (e.X' e.Y' game);  		MoCdvec = MoCinitialvec;  		//start adding an object  		if (e.Button == MouseButton.Left) {  			MoCdraw = true;  		}  		//start moving viewpoint  		if (e.Button == MouseButton.Right) {  			PrevViewpoint = ViewPointV;  		}  	};  	game.Mouse.ButtonUp += (sender' e) =>  {  		//if left click - add object  		if (e.Button == MouseButton.Left) {  			MoCdraw = false;  		}  	};  	//scroll wheel - zoom in / out  	game.Mouse.WheelChanged += (sender' e) =>  {  		if (ZoomMulti - e.DeltaPrecise * 0.001f > 0) {  			ZoomMulti -= e.DeltaPrecise * 0.001f;  		}  	};  	//moving mouse  	game.Mouse.Move += (sender' e) =>  {  		//for adding object  		MoCdvec = MousePosition (e.X' e.Y' game);  		if (e.X < 5 && e.Y < 5) {  			if (SimulationSpeed == 0)  				SimulationSpeed = 20;  			else  				SimulationSpeed = 0;  		}  		if (e.Mouse.LeftButton == ButtonState.Pressed) {  			try {  				arrAlive [(int)MoCdvec.X' (int)MoCdvec.Y] = 1;  			}  			catch {  			}  		}  		//for moving viewpoint  		if (e.Mouse.RightButton == ButtonState.Pressed) {  			ViewPointV = new Vector3 ((MoCdvec - MoCinitialvec).X / (game.Width * ZoomMulti)' (MoCdvec - MoCinitialvec).Y / (game.Height * ZoomMulti)' 0) + PrevViewpoint;  		}  	};  	//keyboard input  	game.KeyPress += (sender' e) =>  {  		switch (e.KeyChar) {  		case 'f':  			game.WindowState = WindowState.Fullscreen;  			break;  		case 'p':  			if (SimulationSpeed == 0)  				SimulationSpeed = 20;  			else  				SimulationSpeed = 0;  			break;  		case 'c':  			//seed array  			for (int i = 0; i < iSizeOfGrid; i++) {  				for (int z = 0; z < iSizeOfGrid; z++) {  					arrAlive [i' z] = 0;  				}  			}  			break;  		}  	};  	//more keyboard input  	game.UpdateFrame += (sender' e) =>  {  		if (game.Keyboard [Key.Escape]) {  			game.Exit ();  		}  		if (game.Keyboard [Key.A]) {  			ViewPointV.X += 0.01f;  		}  		if (game.Keyboard [Key.D]) {  			ViewPointV.X -= 0.01f;  		}  		if (game.Keyboard [Key.W]) {  			ViewPointV.Y -= 0.01f;  		}  		if (game.Keyboard [Key.S]) {  			ViewPointV.Y += 0.01f;  		}  		if (game.Keyboard [Key.Z]) {  			ZoomMulti += 0.0001f;  		}  		if (game.Keyboard [Key.X] && ZoomMulti > 0.001f) {  			ZoomMulti -= 0.0001f;  		}  	};  	//for slowing down simulation  	int SimulationSlowDownStep = 0;  	game.RenderFrame += (sender' e) =>  {  		// render graphics  		//clears screen  		GL.Clear (ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);  		GL.MatrixMode (MatrixMode.Projection);  		Vector2 followPosition = new Vector2 (0' 0);  		matrix = Matrix4.CreateTranslation (ViewPointV);  		GL.LoadMatrix (ref matrix);  		GL.Ortho (-game.Width * ZoomMulti' game.Width * ZoomMulti' -game.Height * ZoomMulti' game.Height * ZoomMulti' 0.0' 4.0);  		//speedup / slowdown  		//slowdown?  		if (SimulationSpeed < 20) {  			//Stop simulation when sim speed = 0  			if (SimulationSpeed == 0)  				SimulationSlowDownStep = 1;  			SimulationSlowDownStep += SimulationSpeed;  			if (SimulationSlowDownStep > 20)  				SimulationSlowDownStep = 0;  		}  		else  			SimulationSlowDownStep = 0;  		Console.WriteLine (SimulationSpeed);  		for (int zx = 20; (zx < SimulationSpeed || zx == 20) && SimulationSlowDownStep == 0; zx++) {  			int['] arrNextTo = new int[iSizeOfGrid' iSizeOfGrid];  			//calculate neighbours  			for (int x = 0; x < iSizeOfGrid; x++) {  				for (int y = 0; y < iSizeOfGrid; y++) {  					if (arrAlive [x' y] == 1 && x > 1 && y > 1 && x < iSizeOfGrid - 1 && y < iSizeOfGrid - 1) {  						arrNextTo [x - 1' y - 1]++;  						arrNextTo [x - 1' y]++;  						arrNextTo [x - 1' y + 1]++;  						arrNextTo [x' y + 1]++;  						arrNextTo [x' y - 1]++;  						arrNextTo [x + 1' y - 1]++;  						arrNextTo [x + 1' y]++;  						arrNextTo [x + 1' y + 1]++;  					}  				}  			}  			//kill / revive  			for (int x = 0; x < iSizeOfGrid; x++) {  				for (int y = 0; y < iSizeOfGrid; y++) {  					if (arrNextTo [x' y] < 2 || arrNextTo [x' y] > 3) {  						arrAlive [x' y] = 0;  					}  					if (arrNextTo [x' y] == 3) {  						arrAlive [x' y] = 1;  					}  				}  			}  		}  		//Now draw the objects to the gamewindow  		GL.Color3 (Color.Yellow);  		GL.Begin (PrimitiveType.Quads);  		//Draw Cells  		for (int x = 0; x < iSizeOfGrid; x++) {  			//Console.WriteLine('n');  			for (int y = 0; y < iSizeOfGrid; y++) {  				//	Console.Write(arrAlive[x'y]);  				if (arrAlive [x' y] == 1) {  					GL.Vertex2 (x' y);  					GL.Vertex2 (x' y + 1);  					GL.Vertex2 (x + 1' y + 1);  					GL.Vertex2 (x + 1' y);  				}  			}  		}  		GL.End ();  		DrawCircle (30' ViewPointV.X' ViewPointV.Y' 1);  		Console.WriteLine (game.RenderFrequency);  		//load onto screen  		game.SwapBuffers ();  	};  	//run the game loop  	game.Run ();  }  
Magic Number,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following statement contains a magic number: using (var game = new GameWindow (700' 500' new GraphicsMode (32' 24' 0' 8))) {  	//seed array  	Random rand = new Random ();  	for (int i = 200; i < iSizeOfGrid - 200; i++) {  		for (int z = 200; z < iSizeOfGrid - 200; z++) {  			arrAlive [i' z] = rand.Next (3);  		}  	}  	//Console.WriteLine (arrAlive.ToString ());  	//run at 60fps  	game.TargetRenderFrequency = 20;  	Matrix4 matrix = Matrix4.CreateTranslation (0' 0' 0);  	game.Load += (sender' e) =>  {  		// setup settings' load textures' sounds  		game.VSync = VSyncMode.On;  		game.Title = "LIFE";  	};  	game.Resize += (sender' e) =>  {  		GL.Viewport (0' 0' game.Width' game.Height);  	};  	//mouse click to add logic  	Vector2 MoCinitialvec = new Vector2 (0f' 0f);  	Vector2 MoCdvec = new Vector2 (0f' 0f);  	bool MoCdraw = false;  	Vector3 PrevViewpoint = new Vector3 (0f' 0f' 0f);  	//enable textures  	GL.Enable (EnableCap.Texture2D);  	GL.BlendFunc (BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);  	//mouse click event  	game.Mouse.ButtonDown += (sender' e) =>  {  		MoCinitialvec = MousePosition (e.X' e.Y' game);  		MoCdvec = MoCinitialvec;  		//start adding an object  		if (e.Button == MouseButton.Left) {  			MoCdraw = true;  		}  		//start moving viewpoint  		if (e.Button == MouseButton.Right) {  			PrevViewpoint = ViewPointV;  		}  	};  	game.Mouse.ButtonUp += (sender' e) =>  {  		//if left click - add object  		if (e.Button == MouseButton.Left) {  			MoCdraw = false;  		}  	};  	//scroll wheel - zoom in / out  	game.Mouse.WheelChanged += (sender' e) =>  {  		if (ZoomMulti - e.DeltaPrecise * 0.001f > 0) {  			ZoomMulti -= e.DeltaPrecise * 0.001f;  		}  	};  	//moving mouse  	game.Mouse.Move += (sender' e) =>  {  		//for adding object  		MoCdvec = MousePosition (e.X' e.Y' game);  		if (e.X < 5 && e.Y < 5) {  			if (SimulationSpeed == 0)  				SimulationSpeed = 20;  			else  				SimulationSpeed = 0;  		}  		if (e.Mouse.LeftButton == ButtonState.Pressed) {  			try {  				arrAlive [(int)MoCdvec.X' (int)MoCdvec.Y] = 1;  			}  			catch {  			}  		}  		//for moving viewpoint  		if (e.Mouse.RightButton == ButtonState.Pressed) {  			ViewPointV = new Vector3 ((MoCdvec - MoCinitialvec).X / (game.Width * ZoomMulti)' (MoCdvec - MoCinitialvec).Y / (game.Height * ZoomMulti)' 0) + PrevViewpoint;  		}  	};  	//keyboard input  	game.KeyPress += (sender' e) =>  {  		switch (e.KeyChar) {  		case 'f':  			game.WindowState = WindowState.Fullscreen;  			break;  		case 'p':  			if (SimulationSpeed == 0)  				SimulationSpeed = 20;  			else  				SimulationSpeed = 0;  			break;  		case 'c':  			//seed array  			for (int i = 0; i < iSizeOfGrid; i++) {  				for (int z = 0; z < iSizeOfGrid; z++) {  					arrAlive [i' z] = 0;  				}  			}  			break;  		}  	};  	//more keyboard input  	game.UpdateFrame += (sender' e) =>  {  		if (game.Keyboard [Key.Escape]) {  			game.Exit ();  		}  		if (game.Keyboard [Key.A]) {  			ViewPointV.X += 0.01f;  		}  		if (game.Keyboard [Key.D]) {  			ViewPointV.X -= 0.01f;  		}  		if (game.Keyboard [Key.W]) {  			ViewPointV.Y -= 0.01f;  		}  		if (game.Keyboard [Key.S]) {  			ViewPointV.Y += 0.01f;  		}  		if (game.Keyboard [Key.Z]) {  			ZoomMulti += 0.0001f;  		}  		if (game.Keyboard [Key.X] && ZoomMulti > 0.001f) {  			ZoomMulti -= 0.0001f;  		}  	};  	//for slowing down simulation  	int SimulationSlowDownStep = 0;  	game.RenderFrame += (sender' e) =>  {  		// render graphics  		//clears screen  		GL.Clear (ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);  		GL.MatrixMode (MatrixMode.Projection);  		Vector2 followPosition = new Vector2 (0' 0);  		matrix = Matrix4.CreateTranslation (ViewPointV);  		GL.LoadMatrix (ref matrix);  		GL.Ortho (-game.Width * ZoomMulti' game.Width * ZoomMulti' -game.Height * ZoomMulti' game.Height * ZoomMulti' 0.0' 4.0);  		//speedup / slowdown  		//slowdown?  		if (SimulationSpeed < 20) {  			//Stop simulation when sim speed = 0  			if (SimulationSpeed == 0)  				SimulationSlowDownStep = 1;  			SimulationSlowDownStep += SimulationSpeed;  			if (SimulationSlowDownStep > 20)  				SimulationSlowDownStep = 0;  		}  		else  			SimulationSlowDownStep = 0;  		Console.WriteLine (SimulationSpeed);  		for (int zx = 20; (zx < SimulationSpeed || zx == 20) && SimulationSlowDownStep == 0; zx++) {  			int['] arrNextTo = new int[iSizeOfGrid' iSizeOfGrid];  			//calculate neighbours  			for (int x = 0; x < iSizeOfGrid; x++) {  				for (int y = 0; y < iSizeOfGrid; y++) {  					if (arrAlive [x' y] == 1 && x > 1 && y > 1 && x < iSizeOfGrid - 1 && y < iSizeOfGrid - 1) {  						arrNextTo [x - 1' y - 1]++;  						arrNextTo [x - 1' y]++;  						arrNextTo [x - 1' y + 1]++;  						arrNextTo [x' y + 1]++;  						arrNextTo [x' y - 1]++;  						arrNextTo [x + 1' y - 1]++;  						arrNextTo [x + 1' y]++;  						arrNextTo [x + 1' y + 1]++;  					}  				}  			}  			//kill / revive  			for (int x = 0; x < iSizeOfGrid; x++) {  				for (int y = 0; y < iSizeOfGrid; y++) {  					if (arrNextTo [x' y] < 2 || arrNextTo [x' y] > 3) {  						arrAlive [x' y] = 0;  					}  					if (arrNextTo [x' y] == 3) {  						arrAlive [x' y] = 1;  					}  				}  			}  		}  		//Now draw the objects to the gamewindow  		GL.Color3 (Color.Yellow);  		GL.Begin (PrimitiveType.Quads);  		//Draw Cells  		for (int x = 0; x < iSizeOfGrid; x++) {  			//Console.WriteLine('n');  			for (int y = 0; y < iSizeOfGrid; y++) {  				//	Console.Write(arrAlive[x'y]);  				if (arrAlive [x' y] == 1) {  					GL.Vertex2 (x' y);  					GL.Vertex2 (x' y + 1);  					GL.Vertex2 (x + 1' y + 1);  					GL.Vertex2 (x + 1' y);  				}  			}  		}  		GL.End ();  		DrawCircle (30' ViewPointV.X' ViewPointV.Y' 1);  		Console.WriteLine (game.RenderFrequency);  		//load onto screen  		game.SwapBuffers ();  	};  	//run the game loop  	game.Run ();  }  
Magic Number,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following statement contains a magic number: using (var game = new GameWindow (700' 500' new GraphicsMode (32' 24' 0' 8))) {  	//seed array  	Random rand = new Random ();  	for (int i = 200; i < iSizeOfGrid - 200; i++) {  		for (int z = 200; z < iSizeOfGrid - 200; z++) {  			arrAlive [i' z] = rand.Next (3);  		}  	}  	//Console.WriteLine (arrAlive.ToString ());  	//run at 60fps  	game.TargetRenderFrequency = 20;  	Matrix4 matrix = Matrix4.CreateTranslation (0' 0' 0);  	game.Load += (sender' e) =>  {  		// setup settings' load textures' sounds  		game.VSync = VSyncMode.On;  		game.Title = "LIFE";  	};  	game.Resize += (sender' e) =>  {  		GL.Viewport (0' 0' game.Width' game.Height);  	};  	//mouse click to add logic  	Vector2 MoCinitialvec = new Vector2 (0f' 0f);  	Vector2 MoCdvec = new Vector2 (0f' 0f);  	bool MoCdraw = false;  	Vector3 PrevViewpoint = new Vector3 (0f' 0f' 0f);  	//enable textures  	GL.Enable (EnableCap.Texture2D);  	GL.BlendFunc (BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);  	//mouse click event  	game.Mouse.ButtonDown += (sender' e) =>  {  		MoCinitialvec = MousePosition (e.X' e.Y' game);  		MoCdvec = MoCinitialvec;  		//start adding an object  		if (e.Button == MouseButton.Left) {  			MoCdraw = true;  		}  		//start moving viewpoint  		if (e.Button == MouseButton.Right) {  			PrevViewpoint = ViewPointV;  		}  	};  	game.Mouse.ButtonUp += (sender' e) =>  {  		//if left click - add object  		if (e.Button == MouseButton.Left) {  			MoCdraw = false;  		}  	};  	//scroll wheel - zoom in / out  	game.Mouse.WheelChanged += (sender' e) =>  {  		if (ZoomMulti - e.DeltaPrecise * 0.001f > 0) {  			ZoomMulti -= e.DeltaPrecise * 0.001f;  		}  	};  	//moving mouse  	game.Mouse.Move += (sender' e) =>  {  		//for adding object  		MoCdvec = MousePosition (e.X' e.Y' game);  		if (e.X < 5 && e.Y < 5) {  			if (SimulationSpeed == 0)  				SimulationSpeed = 20;  			else  				SimulationSpeed = 0;  		}  		if (e.Mouse.LeftButton == ButtonState.Pressed) {  			try {  				arrAlive [(int)MoCdvec.X' (int)MoCdvec.Y] = 1;  			}  			catch {  			}  		}  		//for moving viewpoint  		if (e.Mouse.RightButton == ButtonState.Pressed) {  			ViewPointV = new Vector3 ((MoCdvec - MoCinitialvec).X / (game.Width * ZoomMulti)' (MoCdvec - MoCinitialvec).Y / (game.Height * ZoomMulti)' 0) + PrevViewpoint;  		}  	};  	//keyboard input  	game.KeyPress += (sender' e) =>  {  		switch (e.KeyChar) {  		case 'f':  			game.WindowState = WindowState.Fullscreen;  			break;  		case 'p':  			if (SimulationSpeed == 0)  				SimulationSpeed = 20;  			else  				SimulationSpeed = 0;  			break;  		case 'c':  			//seed array  			for (int i = 0; i < iSizeOfGrid; i++) {  				for (int z = 0; z < iSizeOfGrid; z++) {  					arrAlive [i' z] = 0;  				}  			}  			break;  		}  	};  	//more keyboard input  	game.UpdateFrame += (sender' e) =>  {  		if (game.Keyboard [Key.Escape]) {  			game.Exit ();  		}  		if (game.Keyboard [Key.A]) {  			ViewPointV.X += 0.01f;  		}  		if (game.Keyboard [Key.D]) {  			ViewPointV.X -= 0.01f;  		}  		if (game.Keyboard [Key.W]) {  			ViewPointV.Y -= 0.01f;  		}  		if (game.Keyboard [Key.S]) {  			ViewPointV.Y += 0.01f;  		}  		if (game.Keyboard [Key.Z]) {  			ZoomMulti += 0.0001f;  		}  		if (game.Keyboard [Key.X] && ZoomMulti > 0.001f) {  			ZoomMulti -= 0.0001f;  		}  	};  	//for slowing down simulation  	int SimulationSlowDownStep = 0;  	game.RenderFrame += (sender' e) =>  {  		// render graphics  		//clears screen  		GL.Clear (ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);  		GL.MatrixMode (MatrixMode.Projection);  		Vector2 followPosition = new Vector2 (0' 0);  		matrix = Matrix4.CreateTranslation (ViewPointV);  		GL.LoadMatrix (ref matrix);  		GL.Ortho (-game.Width * ZoomMulti' game.Width * ZoomMulti' -game.Height * ZoomMulti' game.Height * ZoomMulti' 0.0' 4.0);  		//speedup / slowdown  		//slowdown?  		if (SimulationSpeed < 20) {  			//Stop simulation when sim speed = 0  			if (SimulationSpeed == 0)  				SimulationSlowDownStep = 1;  			SimulationSlowDownStep += SimulationSpeed;  			if (SimulationSlowDownStep > 20)  				SimulationSlowDownStep = 0;  		}  		else  			SimulationSlowDownStep = 0;  		Console.WriteLine (SimulationSpeed);  		for (int zx = 20; (zx < SimulationSpeed || zx == 20) && SimulationSlowDownStep == 0; zx++) {  			int['] arrNextTo = new int[iSizeOfGrid' iSizeOfGrid];  			//calculate neighbours  			for (int x = 0; x < iSizeOfGrid; x++) {  				for (int y = 0; y < iSizeOfGrid; y++) {  					if (arrAlive [x' y] == 1 && x > 1 && y > 1 && x < iSizeOfGrid - 1 && y < iSizeOfGrid - 1) {  						arrNextTo [x - 1' y - 1]++;  						arrNextTo [x - 1' y]++;  						arrNextTo [x - 1' y + 1]++;  						arrNextTo [x' y + 1]++;  						arrNextTo [x' y - 1]++;  						arrNextTo [x + 1' y - 1]++;  						arrNextTo [x + 1' y]++;  						arrNextTo [x + 1' y + 1]++;  					}  				}  			}  			//kill / revive  			for (int x = 0; x < iSizeOfGrid; x++) {  				for (int y = 0; y < iSizeOfGrid; y++) {  					if (arrNextTo [x' y] < 2 || arrNextTo [x' y] > 3) {  						arrAlive [x' y] = 0;  					}  					if (arrNextTo [x' y] == 3) {  						arrAlive [x' y] = 1;  					}  				}  			}  		}  		//Now draw the objects to the gamewindow  		GL.Color3 (Color.Yellow);  		GL.Begin (PrimitiveType.Quads);  		//Draw Cells  		for (int x = 0; x < iSizeOfGrid; x++) {  			//Console.WriteLine('n');  			for (int y = 0; y < iSizeOfGrid; y++) {  				//	Console.Write(arrAlive[x'y]);  				if (arrAlive [x' y] == 1) {  					GL.Vertex2 (x' y);  					GL.Vertex2 (x' y + 1);  					GL.Vertex2 (x + 1' y + 1);  					GL.Vertex2 (x + 1' y);  				}  			}  		}  		GL.End ();  		DrawCircle (30' ViewPointV.X' ViewPointV.Y' 1);  		Console.WriteLine (game.RenderFrequency);  		//load onto screen  		game.SwapBuffers ();  	};  	//run the game loop  	game.Run ();  }  
Magic Number,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following statement contains a magic number: using (var game = new GameWindow (700' 500' new GraphicsMode (32' 24' 0' 8))) {  	//seed array  	Random rand = new Random ();  	for (int i = 200; i < iSizeOfGrid - 200; i++) {  		for (int z = 200; z < iSizeOfGrid - 200; z++) {  			arrAlive [i' z] = rand.Next (3);  		}  	}  	//Console.WriteLine (arrAlive.ToString ());  	//run at 60fps  	game.TargetRenderFrequency = 20;  	Matrix4 matrix = Matrix4.CreateTranslation (0' 0' 0);  	game.Load += (sender' e) =>  {  		// setup settings' load textures' sounds  		game.VSync = VSyncMode.On;  		game.Title = "LIFE";  	};  	game.Resize += (sender' e) =>  {  		GL.Viewport (0' 0' game.Width' game.Height);  	};  	//mouse click to add logic  	Vector2 MoCinitialvec = new Vector2 (0f' 0f);  	Vector2 MoCdvec = new Vector2 (0f' 0f);  	bool MoCdraw = false;  	Vector3 PrevViewpoint = new Vector3 (0f' 0f' 0f);  	//enable textures  	GL.Enable (EnableCap.Texture2D);  	GL.BlendFunc (BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);  	//mouse click event  	game.Mouse.ButtonDown += (sender' e) =>  {  		MoCinitialvec = MousePosition (e.X' e.Y' game);  		MoCdvec = MoCinitialvec;  		//start adding an object  		if (e.Button == MouseButton.Left) {  			MoCdraw = true;  		}  		//start moving viewpoint  		if (e.Button == MouseButton.Right) {  			PrevViewpoint = ViewPointV;  		}  	};  	game.Mouse.ButtonUp += (sender' e) =>  {  		//if left click - add object  		if (e.Button == MouseButton.Left) {  			MoCdraw = false;  		}  	};  	//scroll wheel - zoom in / out  	game.Mouse.WheelChanged += (sender' e) =>  {  		if (ZoomMulti - e.DeltaPrecise * 0.001f > 0) {  			ZoomMulti -= e.DeltaPrecise * 0.001f;  		}  	};  	//moving mouse  	game.Mouse.Move += (sender' e) =>  {  		//for adding object  		MoCdvec = MousePosition (e.X' e.Y' game);  		if (e.X < 5 && e.Y < 5) {  			if (SimulationSpeed == 0)  				SimulationSpeed = 20;  			else  				SimulationSpeed = 0;  		}  		if (e.Mouse.LeftButton == ButtonState.Pressed) {  			try {  				arrAlive [(int)MoCdvec.X' (int)MoCdvec.Y] = 1;  			}  			catch {  			}  		}  		//for moving viewpoint  		if (e.Mouse.RightButton == ButtonState.Pressed) {  			ViewPointV = new Vector3 ((MoCdvec - MoCinitialvec).X / (game.Width * ZoomMulti)' (MoCdvec - MoCinitialvec).Y / (game.Height * ZoomMulti)' 0) + PrevViewpoint;  		}  	};  	//keyboard input  	game.KeyPress += (sender' e) =>  {  		switch (e.KeyChar) {  		case 'f':  			game.WindowState = WindowState.Fullscreen;  			break;  		case 'p':  			if (SimulationSpeed == 0)  				SimulationSpeed = 20;  			else  				SimulationSpeed = 0;  			break;  		case 'c':  			//seed array  			for (int i = 0; i < iSizeOfGrid; i++) {  				for (int z = 0; z < iSizeOfGrid; z++) {  					arrAlive [i' z] = 0;  				}  			}  			break;  		}  	};  	//more keyboard input  	game.UpdateFrame += (sender' e) =>  {  		if (game.Keyboard [Key.Escape]) {  			game.Exit ();  		}  		if (game.Keyboard [Key.A]) {  			ViewPointV.X += 0.01f;  		}  		if (game.Keyboard [Key.D]) {  			ViewPointV.X -= 0.01f;  		}  		if (game.Keyboard [Key.W]) {  			ViewPointV.Y -= 0.01f;  		}  		if (game.Keyboard [Key.S]) {  			ViewPointV.Y += 0.01f;  		}  		if (game.Keyboard [Key.Z]) {  			ZoomMulti += 0.0001f;  		}  		if (game.Keyboard [Key.X] && ZoomMulti > 0.001f) {  			ZoomMulti -= 0.0001f;  		}  	};  	//for slowing down simulation  	int SimulationSlowDownStep = 0;  	game.RenderFrame += (sender' e) =>  {  		// render graphics  		//clears screen  		GL.Clear (ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);  		GL.MatrixMode (MatrixMode.Projection);  		Vector2 followPosition = new Vector2 (0' 0);  		matrix = Matrix4.CreateTranslation (ViewPointV);  		GL.LoadMatrix (ref matrix);  		GL.Ortho (-game.Width * ZoomMulti' game.Width * ZoomMulti' -game.Height * ZoomMulti' game.Height * ZoomMulti' 0.0' 4.0);  		//speedup / slowdown  		//slowdown?  		if (SimulationSpeed < 20) {  			//Stop simulation when sim speed = 0  			if (SimulationSpeed == 0)  				SimulationSlowDownStep = 1;  			SimulationSlowDownStep += SimulationSpeed;  			if (SimulationSlowDownStep > 20)  				SimulationSlowDownStep = 0;  		}  		else  			SimulationSlowDownStep = 0;  		Console.WriteLine (SimulationSpeed);  		for (int zx = 20; (zx < SimulationSpeed || zx == 20) && SimulationSlowDownStep == 0; zx++) {  			int['] arrNextTo = new int[iSizeOfGrid' iSizeOfGrid];  			//calculate neighbours  			for (int x = 0; x < iSizeOfGrid; x++) {  				for (int y = 0; y < iSizeOfGrid; y++) {  					if (arrAlive [x' y] == 1 && x > 1 && y > 1 && x < iSizeOfGrid - 1 && y < iSizeOfGrid - 1) {  						arrNextTo [x - 1' y - 1]++;  						arrNextTo [x - 1' y]++;  						arrNextTo [x - 1' y + 1]++;  						arrNextTo [x' y + 1]++;  						arrNextTo [x' y - 1]++;  						arrNextTo [x + 1' y - 1]++;  						arrNextTo [x + 1' y]++;  						arrNextTo [x + 1' y + 1]++;  					}  				}  			}  			//kill / revive  			for (int x = 0; x < iSizeOfGrid; x++) {  				for (int y = 0; y < iSizeOfGrid; y++) {  					if (arrNextTo [x' y] < 2 || arrNextTo [x' y] > 3) {  						arrAlive [x' y] = 0;  					}  					if (arrNextTo [x' y] == 3) {  						arrAlive [x' y] = 1;  					}  				}  			}  		}  		//Now draw the objects to the gamewindow  		GL.Color3 (Color.Yellow);  		GL.Begin (PrimitiveType.Quads);  		//Draw Cells  		for (int x = 0; x < iSizeOfGrid; x++) {  			//Console.WriteLine('n');  			for (int y = 0; y < iSizeOfGrid; y++) {  				//	Console.Write(arrAlive[x'y]);  				if (arrAlive [x' y] == 1) {  					GL.Vertex2 (x' y);  					GL.Vertex2 (x' y + 1);  					GL.Vertex2 (x + 1' y + 1);  					GL.Vertex2 (x + 1' y);  				}  			}  		}  		GL.End ();  		DrawCircle (30' ViewPointV.X' ViewPointV.Y' 1);  		Console.WriteLine (game.RenderFrequency);  		//load onto screen  		game.SwapBuffers ();  	};  	//run the game loop  	game.Run ();  }  
Magic Number,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following statement contains a magic number: using (var game = new GameWindow (700' 500' new GraphicsMode (32' 24' 0' 8))) {  	//seed array  	Random rand = new Random ();  	for (int i = 200; i < iSizeOfGrid - 200; i++) {  		for (int z = 200; z < iSizeOfGrid - 200; z++) {  			arrAlive [i' z] = rand.Next (3);  		}  	}  	//Console.WriteLine (arrAlive.ToString ());  	//run at 60fps  	game.TargetRenderFrequency = 20;  	Matrix4 matrix = Matrix4.CreateTranslation (0' 0' 0);  	game.Load += (sender' e) =>  {  		// setup settings' load textures' sounds  		game.VSync = VSyncMode.On;  		game.Title = "LIFE";  	};  	game.Resize += (sender' e) =>  {  		GL.Viewport (0' 0' game.Width' game.Height);  	};  	//mouse click to add logic  	Vector2 MoCinitialvec = new Vector2 (0f' 0f);  	Vector2 MoCdvec = new Vector2 (0f' 0f);  	bool MoCdraw = false;  	Vector3 PrevViewpoint = new Vector3 (0f' 0f' 0f);  	//enable textures  	GL.Enable (EnableCap.Texture2D);  	GL.BlendFunc (BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);  	//mouse click event  	game.Mouse.ButtonDown += (sender' e) =>  {  		MoCinitialvec = MousePosition (e.X' e.Y' game);  		MoCdvec = MoCinitialvec;  		//start adding an object  		if (e.Button == MouseButton.Left) {  			MoCdraw = true;  		}  		//start moving viewpoint  		if (e.Button == MouseButton.Right) {  			PrevViewpoint = ViewPointV;  		}  	};  	game.Mouse.ButtonUp += (sender' e) =>  {  		//if left click - add object  		if (e.Button == MouseButton.Left) {  			MoCdraw = false;  		}  	};  	//scroll wheel - zoom in / out  	game.Mouse.WheelChanged += (sender' e) =>  {  		if (ZoomMulti - e.DeltaPrecise * 0.001f > 0) {  			ZoomMulti -= e.DeltaPrecise * 0.001f;  		}  	};  	//moving mouse  	game.Mouse.Move += (sender' e) =>  {  		//for adding object  		MoCdvec = MousePosition (e.X' e.Y' game);  		if (e.X < 5 && e.Y < 5) {  			if (SimulationSpeed == 0)  				SimulationSpeed = 20;  			else  				SimulationSpeed = 0;  		}  		if (e.Mouse.LeftButton == ButtonState.Pressed) {  			try {  				arrAlive [(int)MoCdvec.X' (int)MoCdvec.Y] = 1;  			}  			catch {  			}  		}  		//for moving viewpoint  		if (e.Mouse.RightButton == ButtonState.Pressed) {  			ViewPointV = new Vector3 ((MoCdvec - MoCinitialvec).X / (game.Width * ZoomMulti)' (MoCdvec - MoCinitialvec).Y / (game.Height * ZoomMulti)' 0) + PrevViewpoint;  		}  	};  	//keyboard input  	game.KeyPress += (sender' e) =>  {  		switch (e.KeyChar) {  		case 'f':  			game.WindowState = WindowState.Fullscreen;  			break;  		case 'p':  			if (SimulationSpeed == 0)  				SimulationSpeed = 20;  			else  				SimulationSpeed = 0;  			break;  		case 'c':  			//seed array  			for (int i = 0; i < iSizeOfGrid; i++) {  				for (int z = 0; z < iSizeOfGrid; z++) {  					arrAlive [i' z] = 0;  				}  			}  			break;  		}  	};  	//more keyboard input  	game.UpdateFrame += (sender' e) =>  {  		if (game.Keyboard [Key.Escape]) {  			game.Exit ();  		}  		if (game.Keyboard [Key.A]) {  			ViewPointV.X += 0.01f;  		}  		if (game.Keyboard [Key.D]) {  			ViewPointV.X -= 0.01f;  		}  		if (game.Keyboard [Key.W]) {  			ViewPointV.Y -= 0.01f;  		}  		if (game.Keyboard [Key.S]) {  			ViewPointV.Y += 0.01f;  		}  		if (game.Keyboard [Key.Z]) {  			ZoomMulti += 0.0001f;  		}  		if (game.Keyboard [Key.X] && ZoomMulti > 0.001f) {  			ZoomMulti -= 0.0001f;  		}  	};  	//for slowing down simulation  	int SimulationSlowDownStep = 0;  	game.RenderFrame += (sender' e) =>  {  		// render graphics  		//clears screen  		GL.Clear (ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);  		GL.MatrixMode (MatrixMode.Projection);  		Vector2 followPosition = new Vector2 (0' 0);  		matrix = Matrix4.CreateTranslation (ViewPointV);  		GL.LoadMatrix (ref matrix);  		GL.Ortho (-game.Width * ZoomMulti' game.Width * ZoomMulti' -game.Height * ZoomMulti' game.Height * ZoomMulti' 0.0' 4.0);  		//speedup / slowdown  		//slowdown?  		if (SimulationSpeed < 20) {  			//Stop simulation when sim speed = 0  			if (SimulationSpeed == 0)  				SimulationSlowDownStep = 1;  			SimulationSlowDownStep += SimulationSpeed;  			if (SimulationSlowDownStep > 20)  				SimulationSlowDownStep = 0;  		}  		else  			SimulationSlowDownStep = 0;  		Console.WriteLine (SimulationSpeed);  		for (int zx = 20; (zx < SimulationSpeed || zx == 20) && SimulationSlowDownStep == 0; zx++) {  			int['] arrNextTo = new int[iSizeOfGrid' iSizeOfGrid];  			//calculate neighbours  			for (int x = 0; x < iSizeOfGrid; x++) {  				for (int y = 0; y < iSizeOfGrid; y++) {  					if (arrAlive [x' y] == 1 && x > 1 && y > 1 && x < iSizeOfGrid - 1 && y < iSizeOfGrid - 1) {  						arrNextTo [x - 1' y - 1]++;  						arrNextTo [x - 1' y]++;  						arrNextTo [x - 1' y + 1]++;  						arrNextTo [x' y + 1]++;  						arrNextTo [x' y - 1]++;  						arrNextTo [x + 1' y - 1]++;  						arrNextTo [x + 1' y]++;  						arrNextTo [x + 1' y + 1]++;  					}  				}  			}  			//kill / revive  			for (int x = 0; x < iSizeOfGrid; x++) {  				for (int y = 0; y < iSizeOfGrid; y++) {  					if (arrNextTo [x' y] < 2 || arrNextTo [x' y] > 3) {  						arrAlive [x' y] = 0;  					}  					if (arrNextTo [x' y] == 3) {  						arrAlive [x' y] = 1;  					}  				}  			}  		}  		//Now draw the objects to the gamewindow  		GL.Color3 (Color.Yellow);  		GL.Begin (PrimitiveType.Quads);  		//Draw Cells  		for (int x = 0; x < iSizeOfGrid; x++) {  			//Console.WriteLine('n');  			for (int y = 0; y < iSizeOfGrid; y++) {  				//	Console.Write(arrAlive[x'y]);  				if (arrAlive [x' y] == 1) {  					GL.Vertex2 (x' y);  					GL.Vertex2 (x' y + 1);  					GL.Vertex2 (x + 1' y + 1);  					GL.Vertex2 (x + 1' y);  				}  			}  		}  		GL.End ();  		DrawCircle (30' ViewPointV.X' ViewPointV.Y' 1);  		Console.WriteLine (game.RenderFrequency);  		//load onto screen  		game.SwapBuffers ();  	};  	//run the game loop  	game.Run ();  }  
Magic Number,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following statement contains a magic number: using (var game = new GameWindow (700' 500' new GraphicsMode (32' 24' 0' 8))) {  	//seed array  	Random rand = new Random ();  	for (int i = 200; i < iSizeOfGrid - 200; i++) {  		for (int z = 200; z < iSizeOfGrid - 200; z++) {  			arrAlive [i' z] = rand.Next (3);  		}  	}  	//Console.WriteLine (arrAlive.ToString ());  	//run at 60fps  	game.TargetRenderFrequency = 20;  	Matrix4 matrix = Matrix4.CreateTranslation (0' 0' 0);  	game.Load += (sender' e) =>  {  		// setup settings' load textures' sounds  		game.VSync = VSyncMode.On;  		game.Title = "LIFE";  	};  	game.Resize += (sender' e) =>  {  		GL.Viewport (0' 0' game.Width' game.Height);  	};  	//mouse click to add logic  	Vector2 MoCinitialvec = new Vector2 (0f' 0f);  	Vector2 MoCdvec = new Vector2 (0f' 0f);  	bool MoCdraw = false;  	Vector3 PrevViewpoint = new Vector3 (0f' 0f' 0f);  	//enable textures  	GL.Enable (EnableCap.Texture2D);  	GL.BlendFunc (BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);  	//mouse click event  	game.Mouse.ButtonDown += (sender' e) =>  {  		MoCinitialvec = MousePosition (e.X' e.Y' game);  		MoCdvec = MoCinitialvec;  		//start adding an object  		if (e.Button == MouseButton.Left) {  			MoCdraw = true;  		}  		//start moving viewpoint  		if (e.Button == MouseButton.Right) {  			PrevViewpoint = ViewPointV;  		}  	};  	game.Mouse.ButtonUp += (sender' e) =>  {  		//if left click - add object  		if (e.Button == MouseButton.Left) {  			MoCdraw = false;  		}  	};  	//scroll wheel - zoom in / out  	game.Mouse.WheelChanged += (sender' e) =>  {  		if (ZoomMulti - e.DeltaPrecise * 0.001f > 0) {  			ZoomMulti -= e.DeltaPrecise * 0.001f;  		}  	};  	//moving mouse  	game.Mouse.Move += (sender' e) =>  {  		//for adding object  		MoCdvec = MousePosition (e.X' e.Y' game);  		if (e.X < 5 && e.Y < 5) {  			if (SimulationSpeed == 0)  				SimulationSpeed = 20;  			else  				SimulationSpeed = 0;  		}  		if (e.Mouse.LeftButton == ButtonState.Pressed) {  			try {  				arrAlive [(int)MoCdvec.X' (int)MoCdvec.Y] = 1;  			}  			catch {  			}  		}  		//for moving viewpoint  		if (e.Mouse.RightButton == ButtonState.Pressed) {  			ViewPointV = new Vector3 ((MoCdvec - MoCinitialvec).X / (game.Width * ZoomMulti)' (MoCdvec - MoCinitialvec).Y / (game.Height * ZoomMulti)' 0) + PrevViewpoint;  		}  	};  	//keyboard input  	game.KeyPress += (sender' e) =>  {  		switch (e.KeyChar) {  		case 'f':  			game.WindowState = WindowState.Fullscreen;  			break;  		case 'p':  			if (SimulationSpeed == 0)  				SimulationSpeed = 20;  			else  				SimulationSpeed = 0;  			break;  		case 'c':  			//seed array  			for (int i = 0; i < iSizeOfGrid; i++) {  				for (int z = 0; z < iSizeOfGrid; z++) {  					arrAlive [i' z] = 0;  				}  			}  			break;  		}  	};  	//more keyboard input  	game.UpdateFrame += (sender' e) =>  {  		if (game.Keyboard [Key.Escape]) {  			game.Exit ();  		}  		if (game.Keyboard [Key.A]) {  			ViewPointV.X += 0.01f;  		}  		if (game.Keyboard [Key.D]) {  			ViewPointV.X -= 0.01f;  		}  		if (game.Keyboard [Key.W]) {  			ViewPointV.Y -= 0.01f;  		}  		if (game.Keyboard [Key.S]) {  			ViewPointV.Y += 0.01f;  		}  		if (game.Keyboard [Key.Z]) {  			ZoomMulti += 0.0001f;  		}  		if (game.Keyboard [Key.X] && ZoomMulti > 0.001f) {  			ZoomMulti -= 0.0001f;  		}  	};  	//for slowing down simulation  	int SimulationSlowDownStep = 0;  	game.RenderFrame += (sender' e) =>  {  		// render graphics  		//clears screen  		GL.Clear (ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);  		GL.MatrixMode (MatrixMode.Projection);  		Vector2 followPosition = new Vector2 (0' 0);  		matrix = Matrix4.CreateTranslation (ViewPointV);  		GL.LoadMatrix (ref matrix);  		GL.Ortho (-game.Width * ZoomMulti' game.Width * ZoomMulti' -game.Height * ZoomMulti' game.Height * ZoomMulti' 0.0' 4.0);  		//speedup / slowdown  		//slowdown?  		if (SimulationSpeed < 20) {  			//Stop simulation when sim speed = 0  			if (SimulationSpeed == 0)  				SimulationSlowDownStep = 1;  			SimulationSlowDownStep += SimulationSpeed;  			if (SimulationSlowDownStep > 20)  				SimulationSlowDownStep = 0;  		}  		else  			SimulationSlowDownStep = 0;  		Console.WriteLine (SimulationSpeed);  		for (int zx = 20; (zx < SimulationSpeed || zx == 20) && SimulationSlowDownStep == 0; zx++) {  			int['] arrNextTo = new int[iSizeOfGrid' iSizeOfGrid];  			//calculate neighbours  			for (int x = 0; x < iSizeOfGrid; x++) {  				for (int y = 0; y < iSizeOfGrid; y++) {  					if (arrAlive [x' y] == 1 && x > 1 && y > 1 && x < iSizeOfGrid - 1 && y < iSizeOfGrid - 1) {  						arrNextTo [x - 1' y - 1]++;  						arrNextTo [x - 1' y]++;  						arrNextTo [x - 1' y + 1]++;  						arrNextTo [x' y + 1]++;  						arrNextTo [x' y - 1]++;  						arrNextTo [x + 1' y - 1]++;  						arrNextTo [x + 1' y]++;  						arrNextTo [x + 1' y + 1]++;  					}  				}  			}  			//kill / revive  			for (int x = 0; x < iSizeOfGrid; x++) {  				for (int y = 0; y < iSizeOfGrid; y++) {  					if (arrNextTo [x' y] < 2 || arrNextTo [x' y] > 3) {  						arrAlive [x' y] = 0;  					}  					if (arrNextTo [x' y] == 3) {  						arrAlive [x' y] = 1;  					}  				}  			}  		}  		//Now draw the objects to the gamewindow  		GL.Color3 (Color.Yellow);  		GL.Begin (PrimitiveType.Quads);  		//Draw Cells  		for (int x = 0; x < iSizeOfGrid; x++) {  			//Console.WriteLine('n');  			for (int y = 0; y < iSizeOfGrid; y++) {  				//	Console.Write(arrAlive[x'y]);  				if (arrAlive [x' y] == 1) {  					GL.Vertex2 (x' y);  					GL.Vertex2 (x' y + 1);  					GL.Vertex2 (x + 1' y + 1);  					GL.Vertex2 (x + 1' y);  				}  			}  		}  		GL.End ();  		DrawCircle (30' ViewPointV.X' ViewPointV.Y' 1);  		Console.WriteLine (game.RenderFrequency);  		//load onto screen  		game.SwapBuffers ();  	};  	//run the game loop  	game.Run ();  }  
Magic Number,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following statement contains a magic number: using (var game = new GameWindow (700' 500' new GraphicsMode (32' 24' 0' 8))) {  	//seed array  	Random rand = new Random ();  	for (int i = 200; i < iSizeOfGrid - 200; i++) {  		for (int z = 200; z < iSizeOfGrid - 200; z++) {  			arrAlive [i' z] = rand.Next (3);  		}  	}  	//Console.WriteLine (arrAlive.ToString ());  	//run at 60fps  	game.TargetRenderFrequency = 20;  	Matrix4 matrix = Matrix4.CreateTranslation (0' 0' 0);  	game.Load += (sender' e) =>  {  		// setup settings' load textures' sounds  		game.VSync = VSyncMode.On;  		game.Title = "LIFE";  	};  	game.Resize += (sender' e) =>  {  		GL.Viewport (0' 0' game.Width' game.Height);  	};  	//mouse click to add logic  	Vector2 MoCinitialvec = new Vector2 (0f' 0f);  	Vector2 MoCdvec = new Vector2 (0f' 0f);  	bool MoCdraw = false;  	Vector3 PrevViewpoint = new Vector3 (0f' 0f' 0f);  	//enable textures  	GL.Enable (EnableCap.Texture2D);  	GL.BlendFunc (BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);  	//mouse click event  	game.Mouse.ButtonDown += (sender' e) =>  {  		MoCinitialvec = MousePosition (e.X' e.Y' game);  		MoCdvec = MoCinitialvec;  		//start adding an object  		if (e.Button == MouseButton.Left) {  			MoCdraw = true;  		}  		//start moving viewpoint  		if (e.Button == MouseButton.Right) {  			PrevViewpoint = ViewPointV;  		}  	};  	game.Mouse.ButtonUp += (sender' e) =>  {  		//if left click - add object  		if (e.Button == MouseButton.Left) {  			MoCdraw = false;  		}  	};  	//scroll wheel - zoom in / out  	game.Mouse.WheelChanged += (sender' e) =>  {  		if (ZoomMulti - e.DeltaPrecise * 0.001f > 0) {  			ZoomMulti -= e.DeltaPrecise * 0.001f;  		}  	};  	//moving mouse  	game.Mouse.Move += (sender' e) =>  {  		//for adding object  		MoCdvec = MousePosition (e.X' e.Y' game);  		if (e.X < 5 && e.Y < 5) {  			if (SimulationSpeed == 0)  				SimulationSpeed = 20;  			else  				SimulationSpeed = 0;  		}  		if (e.Mouse.LeftButton == ButtonState.Pressed) {  			try {  				arrAlive [(int)MoCdvec.X' (int)MoCdvec.Y] = 1;  			}  			catch {  			}  		}  		//for moving viewpoint  		if (e.Mouse.RightButton == ButtonState.Pressed) {  			ViewPointV = new Vector3 ((MoCdvec - MoCinitialvec).X / (game.Width * ZoomMulti)' (MoCdvec - MoCinitialvec).Y / (game.Height * ZoomMulti)' 0) + PrevViewpoint;  		}  	};  	//keyboard input  	game.KeyPress += (sender' e) =>  {  		switch (e.KeyChar) {  		case 'f':  			game.WindowState = WindowState.Fullscreen;  			break;  		case 'p':  			if (SimulationSpeed == 0)  				SimulationSpeed = 20;  			else  				SimulationSpeed = 0;  			break;  		case 'c':  			//seed array  			for (int i = 0; i < iSizeOfGrid; i++) {  				for (int z = 0; z < iSizeOfGrid; z++) {  					arrAlive [i' z] = 0;  				}  			}  			break;  		}  	};  	//more keyboard input  	game.UpdateFrame += (sender' e) =>  {  		if (game.Keyboard [Key.Escape]) {  			game.Exit ();  		}  		if (game.Keyboard [Key.A]) {  			ViewPointV.X += 0.01f;  		}  		if (game.Keyboard [Key.D]) {  			ViewPointV.X -= 0.01f;  		}  		if (game.Keyboard [Key.W]) {  			ViewPointV.Y -= 0.01f;  		}  		if (game.Keyboard [Key.S]) {  			ViewPointV.Y += 0.01f;  		}  		if (game.Keyboard [Key.Z]) {  			ZoomMulti += 0.0001f;  		}  		if (game.Keyboard [Key.X] && ZoomMulti > 0.001f) {  			ZoomMulti -= 0.0001f;  		}  	};  	//for slowing down simulation  	int SimulationSlowDownStep = 0;  	game.RenderFrame += (sender' e) =>  {  		// render graphics  		//clears screen  		GL.Clear (ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);  		GL.MatrixMode (MatrixMode.Projection);  		Vector2 followPosition = new Vector2 (0' 0);  		matrix = Matrix4.CreateTranslation (ViewPointV);  		GL.LoadMatrix (ref matrix);  		GL.Ortho (-game.Width * ZoomMulti' game.Width * ZoomMulti' -game.Height * ZoomMulti' game.Height * ZoomMulti' 0.0' 4.0);  		//speedup / slowdown  		//slowdown?  		if (SimulationSpeed < 20) {  			//Stop simulation when sim speed = 0  			if (SimulationSpeed == 0)  				SimulationSlowDownStep = 1;  			SimulationSlowDownStep += SimulationSpeed;  			if (SimulationSlowDownStep > 20)  				SimulationSlowDownStep = 0;  		}  		else  			SimulationSlowDownStep = 0;  		Console.WriteLine (SimulationSpeed);  		for (int zx = 20; (zx < SimulationSpeed || zx == 20) && SimulationSlowDownStep == 0; zx++) {  			int['] arrNextTo = new int[iSizeOfGrid' iSizeOfGrid];  			//calculate neighbours  			for (int x = 0; x < iSizeOfGrid; x++) {  				for (int y = 0; y < iSizeOfGrid; y++) {  					if (arrAlive [x' y] == 1 && x > 1 && y > 1 && x < iSizeOfGrid - 1 && y < iSizeOfGrid - 1) {  						arrNextTo [x - 1' y - 1]++;  						arrNextTo [x - 1' y]++;  						arrNextTo [x - 1' y + 1]++;  						arrNextTo [x' y + 1]++;  						arrNextTo [x' y - 1]++;  						arrNextTo [x + 1' y - 1]++;  						arrNextTo [x + 1' y]++;  						arrNextTo [x + 1' y + 1]++;  					}  				}  			}  			//kill / revive  			for (int x = 0; x < iSizeOfGrid; x++) {  				for (int y = 0; y < iSizeOfGrid; y++) {  					if (arrNextTo [x' y] < 2 || arrNextTo [x' y] > 3) {  						arrAlive [x' y] = 0;  					}  					if (arrNextTo [x' y] == 3) {  						arrAlive [x' y] = 1;  					}  				}  			}  		}  		//Now draw the objects to the gamewindow  		GL.Color3 (Color.Yellow);  		GL.Begin (PrimitiveType.Quads);  		//Draw Cells  		for (int x = 0; x < iSizeOfGrid; x++) {  			//Console.WriteLine('n');  			for (int y = 0; y < iSizeOfGrid; y++) {  				//	Console.Write(arrAlive[x'y]);  				if (arrAlive [x' y] == 1) {  					GL.Vertex2 (x' y);  					GL.Vertex2 (x' y + 1);  					GL.Vertex2 (x + 1' y + 1);  					GL.Vertex2 (x + 1' y);  				}  			}  		}  		GL.End ();  		DrawCircle (30' ViewPointV.X' ViewPointV.Y' 1);  		Console.WriteLine (game.RenderFrequency);  		//load onto screen  		game.SwapBuffers ();  	};  	//run the game loop  	game.Run ();  }  
Magic Number,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following statement contains a magic number: using (var game = new GameWindow (700' 500' new GraphicsMode (32' 24' 0' 8))) {  	//seed array  	Random rand = new Random ();  	for (int i = 200; i < iSizeOfGrid - 200; i++) {  		for (int z = 200; z < iSizeOfGrid - 200; z++) {  			arrAlive [i' z] = rand.Next (3);  		}  	}  	//Console.WriteLine (arrAlive.ToString ());  	//run at 60fps  	game.TargetRenderFrequency = 20;  	Matrix4 matrix = Matrix4.CreateTranslation (0' 0' 0);  	game.Load += (sender' e) =>  {  		// setup settings' load textures' sounds  		game.VSync = VSyncMode.On;  		game.Title = "LIFE";  	};  	game.Resize += (sender' e) =>  {  		GL.Viewport (0' 0' game.Width' game.Height);  	};  	//mouse click to add logic  	Vector2 MoCinitialvec = new Vector2 (0f' 0f);  	Vector2 MoCdvec = new Vector2 (0f' 0f);  	bool MoCdraw = false;  	Vector3 PrevViewpoint = new Vector3 (0f' 0f' 0f);  	//enable textures  	GL.Enable (EnableCap.Texture2D);  	GL.BlendFunc (BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);  	//mouse click event  	game.Mouse.ButtonDown += (sender' e) =>  {  		MoCinitialvec = MousePosition (e.X' e.Y' game);  		MoCdvec = MoCinitialvec;  		//start adding an object  		if (e.Button == MouseButton.Left) {  			MoCdraw = true;  		}  		//start moving viewpoint  		if (e.Button == MouseButton.Right) {  			PrevViewpoint = ViewPointV;  		}  	};  	game.Mouse.ButtonUp += (sender' e) =>  {  		//if left click - add object  		if (e.Button == MouseButton.Left) {  			MoCdraw = false;  		}  	};  	//scroll wheel - zoom in / out  	game.Mouse.WheelChanged += (sender' e) =>  {  		if (ZoomMulti - e.DeltaPrecise * 0.001f > 0) {  			ZoomMulti -= e.DeltaPrecise * 0.001f;  		}  	};  	//moving mouse  	game.Mouse.Move += (sender' e) =>  {  		//for adding object  		MoCdvec = MousePosition (e.X' e.Y' game);  		if (e.X < 5 && e.Y < 5) {  			if (SimulationSpeed == 0)  				SimulationSpeed = 20;  			else  				SimulationSpeed = 0;  		}  		if (e.Mouse.LeftButton == ButtonState.Pressed) {  			try {  				arrAlive [(int)MoCdvec.X' (int)MoCdvec.Y] = 1;  			}  			catch {  			}  		}  		//for moving viewpoint  		if (e.Mouse.RightButton == ButtonState.Pressed) {  			ViewPointV = new Vector3 ((MoCdvec - MoCinitialvec).X / (game.Width * ZoomMulti)' (MoCdvec - MoCinitialvec).Y / (game.Height * ZoomMulti)' 0) + PrevViewpoint;  		}  	};  	//keyboard input  	game.KeyPress += (sender' e) =>  {  		switch (e.KeyChar) {  		case 'f':  			game.WindowState = WindowState.Fullscreen;  			break;  		case 'p':  			if (SimulationSpeed == 0)  				SimulationSpeed = 20;  			else  				SimulationSpeed = 0;  			break;  		case 'c':  			//seed array  			for (int i = 0; i < iSizeOfGrid; i++) {  				for (int z = 0; z < iSizeOfGrid; z++) {  					arrAlive [i' z] = 0;  				}  			}  			break;  		}  	};  	//more keyboard input  	game.UpdateFrame += (sender' e) =>  {  		if (game.Keyboard [Key.Escape]) {  			game.Exit ();  		}  		if (game.Keyboard [Key.A]) {  			ViewPointV.X += 0.01f;  		}  		if (game.Keyboard [Key.D]) {  			ViewPointV.X -= 0.01f;  		}  		if (game.Keyboard [Key.W]) {  			ViewPointV.Y -= 0.01f;  		}  		if (game.Keyboard [Key.S]) {  			ViewPointV.Y += 0.01f;  		}  		if (game.Keyboard [Key.Z]) {  			ZoomMulti += 0.0001f;  		}  		if (game.Keyboard [Key.X] && ZoomMulti > 0.001f) {  			ZoomMulti -= 0.0001f;  		}  	};  	//for slowing down simulation  	int SimulationSlowDownStep = 0;  	game.RenderFrame += (sender' e) =>  {  		// render graphics  		//clears screen  		GL.Clear (ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);  		GL.MatrixMode (MatrixMode.Projection);  		Vector2 followPosition = new Vector2 (0' 0);  		matrix = Matrix4.CreateTranslation (ViewPointV);  		GL.LoadMatrix (ref matrix);  		GL.Ortho (-game.Width * ZoomMulti' game.Width * ZoomMulti' -game.Height * ZoomMulti' game.Height * ZoomMulti' 0.0' 4.0);  		//speedup / slowdown  		//slowdown?  		if (SimulationSpeed < 20) {  			//Stop simulation when sim speed = 0  			if (SimulationSpeed == 0)  				SimulationSlowDownStep = 1;  			SimulationSlowDownStep += SimulationSpeed;  			if (SimulationSlowDownStep > 20)  				SimulationSlowDownStep = 0;  		}  		else  			SimulationSlowDownStep = 0;  		Console.WriteLine (SimulationSpeed);  		for (int zx = 20; (zx < SimulationSpeed || zx == 20) && SimulationSlowDownStep == 0; zx++) {  			int['] arrNextTo = new int[iSizeOfGrid' iSizeOfGrid];  			//calculate neighbours  			for (int x = 0; x < iSizeOfGrid; x++) {  				for (int y = 0; y < iSizeOfGrid; y++) {  					if (arrAlive [x' y] == 1 && x > 1 && y > 1 && x < iSizeOfGrid - 1 && y < iSizeOfGrid - 1) {  						arrNextTo [x - 1' y - 1]++;  						arrNextTo [x - 1' y]++;  						arrNextTo [x - 1' y + 1]++;  						arrNextTo [x' y + 1]++;  						arrNextTo [x' y - 1]++;  						arrNextTo [x + 1' y - 1]++;  						arrNextTo [x + 1' y]++;  						arrNextTo [x + 1' y + 1]++;  					}  				}  			}  			//kill / revive  			for (int x = 0; x < iSizeOfGrid; x++) {  				for (int y = 0; y < iSizeOfGrid; y++) {  					if (arrNextTo [x' y] < 2 || arrNextTo [x' y] > 3) {  						arrAlive [x' y] = 0;  					}  					if (arrNextTo [x' y] == 3) {  						arrAlive [x' y] = 1;  					}  				}  			}  		}  		//Now draw the objects to the gamewindow  		GL.Color3 (Color.Yellow);  		GL.Begin (PrimitiveType.Quads);  		//Draw Cells  		for (int x = 0; x < iSizeOfGrid; x++) {  			//Console.WriteLine('n');  			for (int y = 0; y < iSizeOfGrid; y++) {  				//	Console.Write(arrAlive[x'y]);  				if (arrAlive [x' y] == 1) {  					GL.Vertex2 (x' y);  					GL.Vertex2 (x' y + 1);  					GL.Vertex2 (x + 1' y + 1);  					GL.Vertex2 (x + 1' y);  				}  			}  		}  		GL.End ();  		DrawCircle (30' ViewPointV.X' ViewPointV.Y' 1);  		Console.WriteLine (game.RenderFrequency);  		//load onto screen  		game.SwapBuffers ();  	};  	//run the game loop  	game.Run ();  }  
Magic Number,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following statement contains a magic number: using (var game = new GameWindow (700' 500' new GraphicsMode (32' 24' 0' 8))) {  	//seed array  	Random rand = new Random ();  	for (int i = 200; i < iSizeOfGrid - 200; i++) {  		for (int z = 200; z < iSizeOfGrid - 200; z++) {  			arrAlive [i' z] = rand.Next (3);  		}  	}  	//Console.WriteLine (arrAlive.ToString ());  	//run at 60fps  	game.TargetRenderFrequency = 20;  	Matrix4 matrix = Matrix4.CreateTranslation (0' 0' 0);  	game.Load += (sender' e) =>  {  		// setup settings' load textures' sounds  		game.VSync = VSyncMode.On;  		game.Title = "LIFE";  	};  	game.Resize += (sender' e) =>  {  		GL.Viewport (0' 0' game.Width' game.Height);  	};  	//mouse click to add logic  	Vector2 MoCinitialvec = new Vector2 (0f' 0f);  	Vector2 MoCdvec = new Vector2 (0f' 0f);  	bool MoCdraw = false;  	Vector3 PrevViewpoint = new Vector3 (0f' 0f' 0f);  	//enable textures  	GL.Enable (EnableCap.Texture2D);  	GL.BlendFunc (BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);  	//mouse click event  	game.Mouse.ButtonDown += (sender' e) =>  {  		MoCinitialvec = MousePosition (e.X' e.Y' game);  		MoCdvec = MoCinitialvec;  		//start adding an object  		if (e.Button == MouseButton.Left) {  			MoCdraw = true;  		}  		//start moving viewpoint  		if (e.Button == MouseButton.Right) {  			PrevViewpoint = ViewPointV;  		}  	};  	game.Mouse.ButtonUp += (sender' e) =>  {  		//if left click - add object  		if (e.Button == MouseButton.Left) {  			MoCdraw = false;  		}  	};  	//scroll wheel - zoom in / out  	game.Mouse.WheelChanged += (sender' e) =>  {  		if (ZoomMulti - e.DeltaPrecise * 0.001f > 0) {  			ZoomMulti -= e.DeltaPrecise * 0.001f;  		}  	};  	//moving mouse  	game.Mouse.Move += (sender' e) =>  {  		//for adding object  		MoCdvec = MousePosition (e.X' e.Y' game);  		if (e.X < 5 && e.Y < 5) {  			if (SimulationSpeed == 0)  				SimulationSpeed = 20;  			else  				SimulationSpeed = 0;  		}  		if (e.Mouse.LeftButton == ButtonState.Pressed) {  			try {  				arrAlive [(int)MoCdvec.X' (int)MoCdvec.Y] = 1;  			}  			catch {  			}  		}  		//for moving viewpoint  		if (e.Mouse.RightButton == ButtonState.Pressed) {  			ViewPointV = new Vector3 ((MoCdvec - MoCinitialvec).X / (game.Width * ZoomMulti)' (MoCdvec - MoCinitialvec).Y / (game.Height * ZoomMulti)' 0) + PrevViewpoint;  		}  	};  	//keyboard input  	game.KeyPress += (sender' e) =>  {  		switch (e.KeyChar) {  		case 'f':  			game.WindowState = WindowState.Fullscreen;  			break;  		case 'p':  			if (SimulationSpeed == 0)  				SimulationSpeed = 20;  			else  				SimulationSpeed = 0;  			break;  		case 'c':  			//seed array  			for (int i = 0; i < iSizeOfGrid; i++) {  				for (int z = 0; z < iSizeOfGrid; z++) {  					arrAlive [i' z] = 0;  				}  			}  			break;  		}  	};  	//more keyboard input  	game.UpdateFrame += (sender' e) =>  {  		if (game.Keyboard [Key.Escape]) {  			game.Exit ();  		}  		if (game.Keyboard [Key.A]) {  			ViewPointV.X += 0.01f;  		}  		if (game.Keyboard [Key.D]) {  			ViewPointV.X -= 0.01f;  		}  		if (game.Keyboard [Key.W]) {  			ViewPointV.Y -= 0.01f;  		}  		if (game.Keyboard [Key.S]) {  			ViewPointV.Y += 0.01f;  		}  		if (game.Keyboard [Key.Z]) {  			ZoomMulti += 0.0001f;  		}  		if (game.Keyboard [Key.X] && ZoomMulti > 0.001f) {  			ZoomMulti -= 0.0001f;  		}  	};  	//for slowing down simulation  	int SimulationSlowDownStep = 0;  	game.RenderFrame += (sender' e) =>  {  		// render graphics  		//clears screen  		GL.Clear (ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);  		GL.MatrixMode (MatrixMode.Projection);  		Vector2 followPosition = new Vector2 (0' 0);  		matrix = Matrix4.CreateTranslation (ViewPointV);  		GL.LoadMatrix (ref matrix);  		GL.Ortho (-game.Width * ZoomMulti' game.Width * ZoomMulti' -game.Height * ZoomMulti' game.Height * ZoomMulti' 0.0' 4.0);  		//speedup / slowdown  		//slowdown?  		if (SimulationSpeed < 20) {  			//Stop simulation when sim speed = 0  			if (SimulationSpeed == 0)  				SimulationSlowDownStep = 1;  			SimulationSlowDownStep += SimulationSpeed;  			if (SimulationSlowDownStep > 20)  				SimulationSlowDownStep = 0;  		}  		else  			SimulationSlowDownStep = 0;  		Console.WriteLine (SimulationSpeed);  		for (int zx = 20; (zx < SimulationSpeed || zx == 20) && SimulationSlowDownStep == 0; zx++) {  			int['] arrNextTo = new int[iSizeOfGrid' iSizeOfGrid];  			//calculate neighbours  			for (int x = 0; x < iSizeOfGrid; x++) {  				for (int y = 0; y < iSizeOfGrid; y++) {  					if (arrAlive [x' y] == 1 && x > 1 && y > 1 && x < iSizeOfGrid - 1 && y < iSizeOfGrid - 1) {  						arrNextTo [x - 1' y - 1]++;  						arrNextTo [x - 1' y]++;  						arrNextTo [x - 1' y + 1]++;  						arrNextTo [x' y + 1]++;  						arrNextTo [x' y - 1]++;  						arrNextTo [x + 1' y - 1]++;  						arrNextTo [x + 1' y]++;  						arrNextTo [x + 1' y + 1]++;  					}  				}  			}  			//kill / revive  			for (int x = 0; x < iSizeOfGrid; x++) {  				for (int y = 0; y < iSizeOfGrid; y++) {  					if (arrNextTo [x' y] < 2 || arrNextTo [x' y] > 3) {  						arrAlive [x' y] = 0;  					}  					if (arrNextTo [x' y] == 3) {  						arrAlive [x' y] = 1;  					}  				}  			}  		}  		//Now draw the objects to the gamewindow  		GL.Color3 (Color.Yellow);  		GL.Begin (PrimitiveType.Quads);  		//Draw Cells  		for (int x = 0; x < iSizeOfGrid; x++) {  			//Console.WriteLine('n');  			for (int y = 0; y < iSizeOfGrid; y++) {  				//	Console.Write(arrAlive[x'y]);  				if (arrAlive [x' y] == 1) {  					GL.Vertex2 (x' y);  					GL.Vertex2 (x' y + 1);  					GL.Vertex2 (x + 1' y + 1);  					GL.Vertex2 (x + 1' y);  				}  			}  		}  		GL.End ();  		DrawCircle (30' ViewPointV.X' ViewPointV.Y' 1);  		Console.WriteLine (game.RenderFrequency);  		//load onto screen  		game.SwapBuffers ();  	};  	//run the game loop  	game.Run ();  }  
Magic Number,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following statement contains a magic number: for (int i = 200; i < iSizeOfGrid - 200; i++) {  	for (int z = 200; z < iSizeOfGrid - 200; z++) {  		arrAlive [i' z] = rand.Next (3);  	}  }  
Magic Number,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following statement contains a magic number: for (int i = 200; i < iSizeOfGrid - 200; i++) {  	for (int z = 200; z < iSizeOfGrid - 200; z++) {  		arrAlive [i' z] = rand.Next (3);  	}  }  
Magic Number,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following statement contains a magic number: for (int i = 200; i < iSizeOfGrid - 200; i++) {  	for (int z = 200; z < iSizeOfGrid - 200; z++) {  		arrAlive [i' z] = rand.Next (3);  	}  }  
Magic Number,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following statement contains a magic number: for (int i = 200; i < iSizeOfGrid - 200; i++) {  	for (int z = 200; z < iSizeOfGrid - 200; z++) {  		arrAlive [i' z] = rand.Next (3);  	}  }  
Magic Number,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following statement contains a magic number: for (int i = 200; i < iSizeOfGrid - 200; i++) {  	for (int z = 200; z < iSizeOfGrid - 200; z++) {  		arrAlive [i' z] = rand.Next (3);  	}  }  
Magic Number,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following statement contains a magic number: for (int z = 200; z < iSizeOfGrid - 200; z++) {  	arrAlive [i' z] = rand.Next (3);  }  
Magic Number,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following statement contains a magic number: for (int z = 200; z < iSizeOfGrid - 200; z++) {  	arrAlive [i' z] = rand.Next (3);  }  
Magic Number,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following statement contains a magic number: for (int z = 200; z < iSizeOfGrid - 200; z++) {  	arrAlive [i' z] = rand.Next (3);  }  
Magic Number,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following statement contains a magic number: arrAlive [i' z] = rand.Next (3);  
Magic Number,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following statement contains a magic number: game.TargetRenderFrequency = 20;  
Magic Number,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following statement contains a magic number: game.Mouse.Move += (sender' e) =>  {  	//for adding object  	MoCdvec = MousePosition (e.X' e.Y' game);  	if (e.X < 5 && e.Y < 5) {  		if (SimulationSpeed == 0)  			SimulationSpeed = 20;  		else  			SimulationSpeed = 0;  	}  	if (e.Mouse.LeftButton == ButtonState.Pressed) {  		try {  			arrAlive [(int)MoCdvec.X' (int)MoCdvec.Y] = 1;  		}  		catch {  		}  	}  	//for moving viewpoint  	if (e.Mouse.RightButton == ButtonState.Pressed) {  		ViewPointV = new Vector3 ((MoCdvec - MoCinitialvec).X / (game.Width * ZoomMulti)' (MoCdvec - MoCinitialvec).Y / (game.Height * ZoomMulti)' 0) + PrevViewpoint;  	}  };  
Magic Number,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following statement contains a magic number: game.Mouse.Move += (sender' e) =>  {  	//for adding object  	MoCdvec = MousePosition (e.X' e.Y' game);  	if (e.X < 5 && e.Y < 5) {  		if (SimulationSpeed == 0)  			SimulationSpeed = 20;  		else  			SimulationSpeed = 0;  	}  	if (e.Mouse.LeftButton == ButtonState.Pressed) {  		try {  			arrAlive [(int)MoCdvec.X' (int)MoCdvec.Y] = 1;  		}  		catch {  		}  	}  	//for moving viewpoint  	if (e.Mouse.RightButton == ButtonState.Pressed) {  		ViewPointV = new Vector3 ((MoCdvec - MoCinitialvec).X / (game.Width * ZoomMulti)' (MoCdvec - MoCinitialvec).Y / (game.Height * ZoomMulti)' 0) + PrevViewpoint;  	}  };  
Magic Number,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following statement contains a magic number: game.Mouse.Move += (sender' e) =>  {  	//for adding object  	MoCdvec = MousePosition (e.X' e.Y' game);  	if (e.X < 5 && e.Y < 5) {  		if (SimulationSpeed == 0)  			SimulationSpeed = 20;  		else  			SimulationSpeed = 0;  	}  	if (e.Mouse.LeftButton == ButtonState.Pressed) {  		try {  			arrAlive [(int)MoCdvec.X' (int)MoCdvec.Y] = 1;  		}  		catch {  		}  	}  	//for moving viewpoint  	if (e.Mouse.RightButton == ButtonState.Pressed) {  		ViewPointV = new Vector3 ((MoCdvec - MoCinitialvec).X / (game.Width * ZoomMulti)' (MoCdvec - MoCinitialvec).Y / (game.Height * ZoomMulti)' 0) + PrevViewpoint;  	}  };  
Magic Number,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following statement contains a magic number: if (e.X < 5 && e.Y < 5) {  	if (SimulationSpeed == 0)  		SimulationSpeed = 20;  	else  		SimulationSpeed = 0;  }  
Magic Number,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following statement contains a magic number: if (e.X < 5 && e.Y < 5) {  	if (SimulationSpeed == 0)  		SimulationSpeed = 20;  	else  		SimulationSpeed = 0;  }  
Magic Number,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following statement contains a magic number: if (e.X < 5 && e.Y < 5) {  	if (SimulationSpeed == 0)  		SimulationSpeed = 20;  	else  		SimulationSpeed = 0;  }  
Magic Number,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following statement contains a magic number: if (SimulationSpeed == 0)  	SimulationSpeed = 20;  else  	SimulationSpeed = 0;  
Magic Number,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following statement contains a magic number: SimulationSpeed = 20;  
Magic Number,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following statement contains a magic number: game.KeyPress += (sender' e) =>  {  	switch (e.KeyChar) {  	case 'f':  		game.WindowState = WindowState.Fullscreen;  		break;  	case 'p':  		if (SimulationSpeed == 0)  			SimulationSpeed = 20;  		else  			SimulationSpeed = 0;  		break;  	case 'c':  		//seed array  		for (int i = 0; i < iSizeOfGrid; i++) {  			for (int z = 0; z < iSizeOfGrid; z++) {  				arrAlive [i' z] = 0;  			}  		}  		break;  	}  };  
Magic Number,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following statement contains a magic number: switch (e.KeyChar) {  case 'f':  	game.WindowState = WindowState.Fullscreen;  	break;  case 'p':  	if (SimulationSpeed == 0)  		SimulationSpeed = 20;  	else  		SimulationSpeed = 0;  	break;  case 'c':  	//seed array  	for (int i = 0; i < iSizeOfGrid; i++) {  		for (int z = 0; z < iSizeOfGrid; z++) {  			arrAlive [i' z] = 0;  		}  	}  	break;  }  
Magic Number,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following statement contains a magic number: if (SimulationSpeed == 0)  	SimulationSpeed = 20;  else  	SimulationSpeed = 0;  
Magic Number,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following statement contains a magic number: SimulationSpeed = 20;  
Magic Number,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following statement contains a magic number: game.RenderFrame += (sender' e) =>  {  	// render graphics  	//clears screen  	GL.Clear (ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);  	GL.MatrixMode (MatrixMode.Projection);  	Vector2 followPosition = new Vector2 (0' 0);  	matrix = Matrix4.CreateTranslation (ViewPointV);  	GL.LoadMatrix (ref matrix);  	GL.Ortho (-game.Width * ZoomMulti' game.Width * ZoomMulti' -game.Height * ZoomMulti' game.Height * ZoomMulti' 0.0' 4.0);  	//speedup / slowdown  	//slowdown?  	if (SimulationSpeed < 20) {  		//Stop simulation when sim speed = 0  		if (SimulationSpeed == 0)  			SimulationSlowDownStep = 1;  		SimulationSlowDownStep += SimulationSpeed;  		if (SimulationSlowDownStep > 20)  			SimulationSlowDownStep = 0;  	}  	else  		SimulationSlowDownStep = 0;  	Console.WriteLine (SimulationSpeed);  	for (int zx = 20; (zx < SimulationSpeed || zx == 20) && SimulationSlowDownStep == 0; zx++) {  		int['] arrNextTo = new int[iSizeOfGrid' iSizeOfGrid];  		//calculate neighbours  		for (int x = 0; x < iSizeOfGrid; x++) {  			for (int y = 0; y < iSizeOfGrid; y++) {  				if (arrAlive [x' y] == 1 && x > 1 && y > 1 && x < iSizeOfGrid - 1 && y < iSizeOfGrid - 1) {  					arrNextTo [x - 1' y - 1]++;  					arrNextTo [x - 1' y]++;  					arrNextTo [x - 1' y + 1]++;  					arrNextTo [x' y + 1]++;  					arrNextTo [x' y - 1]++;  					arrNextTo [x + 1' y - 1]++;  					arrNextTo [x + 1' y]++;  					arrNextTo [x + 1' y + 1]++;  				}  			}  		}  		//kill / revive  		for (int x = 0; x < iSizeOfGrid; x++) {  			for (int y = 0; y < iSizeOfGrid; y++) {  				if (arrNextTo [x' y] < 2 || arrNextTo [x' y] > 3) {  					arrAlive [x' y] = 0;  				}  				if (arrNextTo [x' y] == 3) {  					arrAlive [x' y] = 1;  				}  			}  		}  	}  	//Now draw the objects to the gamewindow  	GL.Color3 (Color.Yellow);  	GL.Begin (PrimitiveType.Quads);  	//Draw Cells  	for (int x = 0; x < iSizeOfGrid; x++) {  		//Console.WriteLine('n');  		for (int y = 0; y < iSizeOfGrid; y++) {  			//	Console.Write(arrAlive[x'y]);  			if (arrAlive [x' y] == 1) {  				GL.Vertex2 (x' y);  				GL.Vertex2 (x' y + 1);  				GL.Vertex2 (x + 1' y + 1);  				GL.Vertex2 (x + 1' y);  			}  		}  	}  	GL.End ();  	DrawCircle (30' ViewPointV.X' ViewPointV.Y' 1);  	Console.WriteLine (game.RenderFrequency);  	//load onto screen  	game.SwapBuffers ();  };  
Magic Number,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following statement contains a magic number: game.RenderFrame += (sender' e) =>  {  	// render graphics  	//clears screen  	GL.Clear (ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);  	GL.MatrixMode (MatrixMode.Projection);  	Vector2 followPosition = new Vector2 (0' 0);  	matrix = Matrix4.CreateTranslation (ViewPointV);  	GL.LoadMatrix (ref matrix);  	GL.Ortho (-game.Width * ZoomMulti' game.Width * ZoomMulti' -game.Height * ZoomMulti' game.Height * ZoomMulti' 0.0' 4.0);  	//speedup / slowdown  	//slowdown?  	if (SimulationSpeed < 20) {  		//Stop simulation when sim speed = 0  		if (SimulationSpeed == 0)  			SimulationSlowDownStep = 1;  		SimulationSlowDownStep += SimulationSpeed;  		if (SimulationSlowDownStep > 20)  			SimulationSlowDownStep = 0;  	}  	else  		SimulationSlowDownStep = 0;  	Console.WriteLine (SimulationSpeed);  	for (int zx = 20; (zx < SimulationSpeed || zx == 20) && SimulationSlowDownStep == 0; zx++) {  		int['] arrNextTo = new int[iSizeOfGrid' iSizeOfGrid];  		//calculate neighbours  		for (int x = 0; x < iSizeOfGrid; x++) {  			for (int y = 0; y < iSizeOfGrid; y++) {  				if (arrAlive [x' y] == 1 && x > 1 && y > 1 && x < iSizeOfGrid - 1 && y < iSizeOfGrid - 1) {  					arrNextTo [x - 1' y - 1]++;  					arrNextTo [x - 1' y]++;  					arrNextTo [x - 1' y + 1]++;  					arrNextTo [x' y + 1]++;  					arrNextTo [x' y - 1]++;  					arrNextTo [x + 1' y - 1]++;  					arrNextTo [x + 1' y]++;  					arrNextTo [x + 1' y + 1]++;  				}  			}  		}  		//kill / revive  		for (int x = 0; x < iSizeOfGrid; x++) {  			for (int y = 0; y < iSizeOfGrid; y++) {  				if (arrNextTo [x' y] < 2 || arrNextTo [x' y] > 3) {  					arrAlive [x' y] = 0;  				}  				if (arrNextTo [x' y] == 3) {  					arrAlive [x' y] = 1;  				}  			}  		}  	}  	//Now draw the objects to the gamewindow  	GL.Color3 (Color.Yellow);  	GL.Begin (PrimitiveType.Quads);  	//Draw Cells  	for (int x = 0; x < iSizeOfGrid; x++) {  		//Console.WriteLine('n');  		for (int y = 0; y < iSizeOfGrid; y++) {  			//	Console.Write(arrAlive[x'y]);  			if (arrAlive [x' y] == 1) {  				GL.Vertex2 (x' y);  				GL.Vertex2 (x' y + 1);  				GL.Vertex2 (x + 1' y + 1);  				GL.Vertex2 (x + 1' y);  			}  		}  	}  	GL.End ();  	DrawCircle (30' ViewPointV.X' ViewPointV.Y' 1);  	Console.WriteLine (game.RenderFrequency);  	//load onto screen  	game.SwapBuffers ();  };  
Magic Number,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following statement contains a magic number: game.RenderFrame += (sender' e) =>  {  	// render graphics  	//clears screen  	GL.Clear (ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);  	GL.MatrixMode (MatrixMode.Projection);  	Vector2 followPosition = new Vector2 (0' 0);  	matrix = Matrix4.CreateTranslation (ViewPointV);  	GL.LoadMatrix (ref matrix);  	GL.Ortho (-game.Width * ZoomMulti' game.Width * ZoomMulti' -game.Height * ZoomMulti' game.Height * ZoomMulti' 0.0' 4.0);  	//speedup / slowdown  	//slowdown?  	if (SimulationSpeed < 20) {  		//Stop simulation when sim speed = 0  		if (SimulationSpeed == 0)  			SimulationSlowDownStep = 1;  		SimulationSlowDownStep += SimulationSpeed;  		if (SimulationSlowDownStep > 20)  			SimulationSlowDownStep = 0;  	}  	else  		SimulationSlowDownStep = 0;  	Console.WriteLine (SimulationSpeed);  	for (int zx = 20; (zx < SimulationSpeed || zx == 20) && SimulationSlowDownStep == 0; zx++) {  		int['] arrNextTo = new int[iSizeOfGrid' iSizeOfGrid];  		//calculate neighbours  		for (int x = 0; x < iSizeOfGrid; x++) {  			for (int y = 0; y < iSizeOfGrid; y++) {  				if (arrAlive [x' y] == 1 && x > 1 && y > 1 && x < iSizeOfGrid - 1 && y < iSizeOfGrid - 1) {  					arrNextTo [x - 1' y - 1]++;  					arrNextTo [x - 1' y]++;  					arrNextTo [x - 1' y + 1]++;  					arrNextTo [x' y + 1]++;  					arrNextTo [x' y - 1]++;  					arrNextTo [x + 1' y - 1]++;  					arrNextTo [x + 1' y]++;  					arrNextTo [x + 1' y + 1]++;  				}  			}  		}  		//kill / revive  		for (int x = 0; x < iSizeOfGrid; x++) {  			for (int y = 0; y < iSizeOfGrid; y++) {  				if (arrNextTo [x' y] < 2 || arrNextTo [x' y] > 3) {  					arrAlive [x' y] = 0;  				}  				if (arrNextTo [x' y] == 3) {  					arrAlive [x' y] = 1;  				}  			}  		}  	}  	//Now draw the objects to the gamewindow  	GL.Color3 (Color.Yellow);  	GL.Begin (PrimitiveType.Quads);  	//Draw Cells  	for (int x = 0; x < iSizeOfGrid; x++) {  		//Console.WriteLine('n');  		for (int y = 0; y < iSizeOfGrid; y++) {  			//	Console.Write(arrAlive[x'y]);  			if (arrAlive [x' y] == 1) {  				GL.Vertex2 (x' y);  				GL.Vertex2 (x' y + 1);  				GL.Vertex2 (x + 1' y + 1);  				GL.Vertex2 (x + 1' y);  			}  		}  	}  	GL.End ();  	DrawCircle (30' ViewPointV.X' ViewPointV.Y' 1);  	Console.WriteLine (game.RenderFrequency);  	//load onto screen  	game.SwapBuffers ();  };  
Magic Number,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following statement contains a magic number: game.RenderFrame += (sender' e) =>  {  	// render graphics  	//clears screen  	GL.Clear (ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);  	GL.MatrixMode (MatrixMode.Projection);  	Vector2 followPosition = new Vector2 (0' 0);  	matrix = Matrix4.CreateTranslation (ViewPointV);  	GL.LoadMatrix (ref matrix);  	GL.Ortho (-game.Width * ZoomMulti' game.Width * ZoomMulti' -game.Height * ZoomMulti' game.Height * ZoomMulti' 0.0' 4.0);  	//speedup / slowdown  	//slowdown?  	if (SimulationSpeed < 20) {  		//Stop simulation when sim speed = 0  		if (SimulationSpeed == 0)  			SimulationSlowDownStep = 1;  		SimulationSlowDownStep += SimulationSpeed;  		if (SimulationSlowDownStep > 20)  			SimulationSlowDownStep = 0;  	}  	else  		SimulationSlowDownStep = 0;  	Console.WriteLine (SimulationSpeed);  	for (int zx = 20; (zx < SimulationSpeed || zx == 20) && SimulationSlowDownStep == 0; zx++) {  		int['] arrNextTo = new int[iSizeOfGrid' iSizeOfGrid];  		//calculate neighbours  		for (int x = 0; x < iSizeOfGrid; x++) {  			for (int y = 0; y < iSizeOfGrid; y++) {  				if (arrAlive [x' y] == 1 && x > 1 && y > 1 && x < iSizeOfGrid - 1 && y < iSizeOfGrid - 1) {  					arrNextTo [x - 1' y - 1]++;  					arrNextTo [x - 1' y]++;  					arrNextTo [x - 1' y + 1]++;  					arrNextTo [x' y + 1]++;  					arrNextTo [x' y - 1]++;  					arrNextTo [x + 1' y - 1]++;  					arrNextTo [x + 1' y]++;  					arrNextTo [x + 1' y + 1]++;  				}  			}  		}  		//kill / revive  		for (int x = 0; x < iSizeOfGrid; x++) {  			for (int y = 0; y < iSizeOfGrid; y++) {  				if (arrNextTo [x' y] < 2 || arrNextTo [x' y] > 3) {  					arrAlive [x' y] = 0;  				}  				if (arrNextTo [x' y] == 3) {  					arrAlive [x' y] = 1;  				}  			}  		}  	}  	//Now draw the objects to the gamewindow  	GL.Color3 (Color.Yellow);  	GL.Begin (PrimitiveType.Quads);  	//Draw Cells  	for (int x = 0; x < iSizeOfGrid; x++) {  		//Console.WriteLine('n');  		for (int y = 0; y < iSizeOfGrid; y++) {  			//	Console.Write(arrAlive[x'y]);  			if (arrAlive [x' y] == 1) {  				GL.Vertex2 (x' y);  				GL.Vertex2 (x' y + 1);  				GL.Vertex2 (x + 1' y + 1);  				GL.Vertex2 (x + 1' y);  			}  		}  	}  	GL.End ();  	DrawCircle (30' ViewPointV.X' ViewPointV.Y' 1);  	Console.WriteLine (game.RenderFrequency);  	//load onto screen  	game.SwapBuffers ();  };  
Magic Number,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following statement contains a magic number: game.RenderFrame += (sender' e) =>  {  	// render graphics  	//clears screen  	GL.Clear (ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);  	GL.MatrixMode (MatrixMode.Projection);  	Vector2 followPosition = new Vector2 (0' 0);  	matrix = Matrix4.CreateTranslation (ViewPointV);  	GL.LoadMatrix (ref matrix);  	GL.Ortho (-game.Width * ZoomMulti' game.Width * ZoomMulti' -game.Height * ZoomMulti' game.Height * ZoomMulti' 0.0' 4.0);  	//speedup / slowdown  	//slowdown?  	if (SimulationSpeed < 20) {  		//Stop simulation when sim speed = 0  		if (SimulationSpeed == 0)  			SimulationSlowDownStep = 1;  		SimulationSlowDownStep += SimulationSpeed;  		if (SimulationSlowDownStep > 20)  			SimulationSlowDownStep = 0;  	}  	else  		SimulationSlowDownStep = 0;  	Console.WriteLine (SimulationSpeed);  	for (int zx = 20; (zx < SimulationSpeed || zx == 20) && SimulationSlowDownStep == 0; zx++) {  		int['] arrNextTo = new int[iSizeOfGrid' iSizeOfGrid];  		//calculate neighbours  		for (int x = 0; x < iSizeOfGrid; x++) {  			for (int y = 0; y < iSizeOfGrid; y++) {  				if (arrAlive [x' y] == 1 && x > 1 && y > 1 && x < iSizeOfGrid - 1 && y < iSizeOfGrid - 1) {  					arrNextTo [x - 1' y - 1]++;  					arrNextTo [x - 1' y]++;  					arrNextTo [x - 1' y + 1]++;  					arrNextTo [x' y + 1]++;  					arrNextTo [x' y - 1]++;  					arrNextTo [x + 1' y - 1]++;  					arrNextTo [x + 1' y]++;  					arrNextTo [x + 1' y + 1]++;  				}  			}  		}  		//kill / revive  		for (int x = 0; x < iSizeOfGrid; x++) {  			for (int y = 0; y < iSizeOfGrid; y++) {  				if (arrNextTo [x' y] < 2 || arrNextTo [x' y] > 3) {  					arrAlive [x' y] = 0;  				}  				if (arrNextTo [x' y] == 3) {  					arrAlive [x' y] = 1;  				}  			}  		}  	}  	//Now draw the objects to the gamewindow  	GL.Color3 (Color.Yellow);  	GL.Begin (PrimitiveType.Quads);  	//Draw Cells  	for (int x = 0; x < iSizeOfGrid; x++) {  		//Console.WriteLine('n');  		for (int y = 0; y < iSizeOfGrid; y++) {  			//	Console.Write(arrAlive[x'y]);  			if (arrAlive [x' y] == 1) {  				GL.Vertex2 (x' y);  				GL.Vertex2 (x' y + 1);  				GL.Vertex2 (x + 1' y + 1);  				GL.Vertex2 (x + 1' y);  			}  		}  	}  	GL.End ();  	DrawCircle (30' ViewPointV.X' ViewPointV.Y' 1);  	Console.WriteLine (game.RenderFrequency);  	//load onto screen  	game.SwapBuffers ();  };  
Magic Number,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following statement contains a magic number: game.RenderFrame += (sender' e) =>  {  	// render graphics  	//clears screen  	GL.Clear (ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);  	GL.MatrixMode (MatrixMode.Projection);  	Vector2 followPosition = new Vector2 (0' 0);  	matrix = Matrix4.CreateTranslation (ViewPointV);  	GL.LoadMatrix (ref matrix);  	GL.Ortho (-game.Width * ZoomMulti' game.Width * ZoomMulti' -game.Height * ZoomMulti' game.Height * ZoomMulti' 0.0' 4.0);  	//speedup / slowdown  	//slowdown?  	if (SimulationSpeed < 20) {  		//Stop simulation when sim speed = 0  		if (SimulationSpeed == 0)  			SimulationSlowDownStep = 1;  		SimulationSlowDownStep += SimulationSpeed;  		if (SimulationSlowDownStep > 20)  			SimulationSlowDownStep = 0;  	}  	else  		SimulationSlowDownStep = 0;  	Console.WriteLine (SimulationSpeed);  	for (int zx = 20; (zx < SimulationSpeed || zx == 20) && SimulationSlowDownStep == 0; zx++) {  		int['] arrNextTo = new int[iSizeOfGrid' iSizeOfGrid];  		//calculate neighbours  		for (int x = 0; x < iSizeOfGrid; x++) {  			for (int y = 0; y < iSizeOfGrid; y++) {  				if (arrAlive [x' y] == 1 && x > 1 && y > 1 && x < iSizeOfGrid - 1 && y < iSizeOfGrid - 1) {  					arrNextTo [x - 1' y - 1]++;  					arrNextTo [x - 1' y]++;  					arrNextTo [x - 1' y + 1]++;  					arrNextTo [x' y + 1]++;  					arrNextTo [x' y - 1]++;  					arrNextTo [x + 1' y - 1]++;  					arrNextTo [x + 1' y]++;  					arrNextTo [x + 1' y + 1]++;  				}  			}  		}  		//kill / revive  		for (int x = 0; x < iSizeOfGrid; x++) {  			for (int y = 0; y < iSizeOfGrid; y++) {  				if (arrNextTo [x' y] < 2 || arrNextTo [x' y] > 3) {  					arrAlive [x' y] = 0;  				}  				if (arrNextTo [x' y] == 3) {  					arrAlive [x' y] = 1;  				}  			}  		}  	}  	//Now draw the objects to the gamewindow  	GL.Color3 (Color.Yellow);  	GL.Begin (PrimitiveType.Quads);  	//Draw Cells  	for (int x = 0; x < iSizeOfGrid; x++) {  		//Console.WriteLine('n');  		for (int y = 0; y < iSizeOfGrid; y++) {  			//	Console.Write(arrAlive[x'y]);  			if (arrAlive [x' y] == 1) {  				GL.Vertex2 (x' y);  				GL.Vertex2 (x' y + 1);  				GL.Vertex2 (x + 1' y + 1);  				GL.Vertex2 (x + 1' y);  			}  		}  	}  	GL.End ();  	DrawCircle (30' ViewPointV.X' ViewPointV.Y' 1);  	Console.WriteLine (game.RenderFrequency);  	//load onto screen  	game.SwapBuffers ();  };  
Magic Number,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following statement contains a magic number: game.RenderFrame += (sender' e) =>  {  	// render graphics  	//clears screen  	GL.Clear (ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);  	GL.MatrixMode (MatrixMode.Projection);  	Vector2 followPosition = new Vector2 (0' 0);  	matrix = Matrix4.CreateTranslation (ViewPointV);  	GL.LoadMatrix (ref matrix);  	GL.Ortho (-game.Width * ZoomMulti' game.Width * ZoomMulti' -game.Height * ZoomMulti' game.Height * ZoomMulti' 0.0' 4.0);  	//speedup / slowdown  	//slowdown?  	if (SimulationSpeed < 20) {  		//Stop simulation when sim speed = 0  		if (SimulationSpeed == 0)  			SimulationSlowDownStep = 1;  		SimulationSlowDownStep += SimulationSpeed;  		if (SimulationSlowDownStep > 20)  			SimulationSlowDownStep = 0;  	}  	else  		SimulationSlowDownStep = 0;  	Console.WriteLine (SimulationSpeed);  	for (int zx = 20; (zx < SimulationSpeed || zx == 20) && SimulationSlowDownStep == 0; zx++) {  		int['] arrNextTo = new int[iSizeOfGrid' iSizeOfGrid];  		//calculate neighbours  		for (int x = 0; x < iSizeOfGrid; x++) {  			for (int y = 0; y < iSizeOfGrid; y++) {  				if (arrAlive [x' y] == 1 && x > 1 && y > 1 && x < iSizeOfGrid - 1 && y < iSizeOfGrid - 1) {  					arrNextTo [x - 1' y - 1]++;  					arrNextTo [x - 1' y]++;  					arrNextTo [x - 1' y + 1]++;  					arrNextTo [x' y + 1]++;  					arrNextTo [x' y - 1]++;  					arrNextTo [x + 1' y - 1]++;  					arrNextTo [x + 1' y]++;  					arrNextTo [x + 1' y + 1]++;  				}  			}  		}  		//kill / revive  		for (int x = 0; x < iSizeOfGrid; x++) {  			for (int y = 0; y < iSizeOfGrid; y++) {  				if (arrNextTo [x' y] < 2 || arrNextTo [x' y] > 3) {  					arrAlive [x' y] = 0;  				}  				if (arrNextTo [x' y] == 3) {  					arrAlive [x' y] = 1;  				}  			}  		}  	}  	//Now draw the objects to the gamewindow  	GL.Color3 (Color.Yellow);  	GL.Begin (PrimitiveType.Quads);  	//Draw Cells  	for (int x = 0; x < iSizeOfGrid; x++) {  		//Console.WriteLine('n');  		for (int y = 0; y < iSizeOfGrid; y++) {  			//	Console.Write(arrAlive[x'y]);  			if (arrAlive [x' y] == 1) {  				GL.Vertex2 (x' y);  				GL.Vertex2 (x' y + 1);  				GL.Vertex2 (x + 1' y + 1);  				GL.Vertex2 (x + 1' y);  			}  		}  	}  	GL.End ();  	DrawCircle (30' ViewPointV.X' ViewPointV.Y' 1);  	Console.WriteLine (game.RenderFrequency);  	//load onto screen  	game.SwapBuffers ();  };  
Magic Number,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following statement contains a magic number: game.RenderFrame += (sender' e) =>  {  	// render graphics  	//clears screen  	GL.Clear (ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);  	GL.MatrixMode (MatrixMode.Projection);  	Vector2 followPosition = new Vector2 (0' 0);  	matrix = Matrix4.CreateTranslation (ViewPointV);  	GL.LoadMatrix (ref matrix);  	GL.Ortho (-game.Width * ZoomMulti' game.Width * ZoomMulti' -game.Height * ZoomMulti' game.Height * ZoomMulti' 0.0' 4.0);  	//speedup / slowdown  	//slowdown?  	if (SimulationSpeed < 20) {  		//Stop simulation when sim speed = 0  		if (SimulationSpeed == 0)  			SimulationSlowDownStep = 1;  		SimulationSlowDownStep += SimulationSpeed;  		if (SimulationSlowDownStep > 20)  			SimulationSlowDownStep = 0;  	}  	else  		SimulationSlowDownStep = 0;  	Console.WriteLine (SimulationSpeed);  	for (int zx = 20; (zx < SimulationSpeed || zx == 20) && SimulationSlowDownStep == 0; zx++) {  		int['] arrNextTo = new int[iSizeOfGrid' iSizeOfGrid];  		//calculate neighbours  		for (int x = 0; x < iSizeOfGrid; x++) {  			for (int y = 0; y < iSizeOfGrid; y++) {  				if (arrAlive [x' y] == 1 && x > 1 && y > 1 && x < iSizeOfGrid - 1 && y < iSizeOfGrid - 1) {  					arrNextTo [x - 1' y - 1]++;  					arrNextTo [x - 1' y]++;  					arrNextTo [x - 1' y + 1]++;  					arrNextTo [x' y + 1]++;  					arrNextTo [x' y - 1]++;  					arrNextTo [x + 1' y - 1]++;  					arrNextTo [x + 1' y]++;  					arrNextTo [x + 1' y + 1]++;  				}  			}  		}  		//kill / revive  		for (int x = 0; x < iSizeOfGrid; x++) {  			for (int y = 0; y < iSizeOfGrid; y++) {  				if (arrNextTo [x' y] < 2 || arrNextTo [x' y] > 3) {  					arrAlive [x' y] = 0;  				}  				if (arrNextTo [x' y] == 3) {  					arrAlive [x' y] = 1;  				}  			}  		}  	}  	//Now draw the objects to the gamewindow  	GL.Color3 (Color.Yellow);  	GL.Begin (PrimitiveType.Quads);  	//Draw Cells  	for (int x = 0; x < iSizeOfGrid; x++) {  		//Console.WriteLine('n');  		for (int y = 0; y < iSizeOfGrid; y++) {  			//	Console.Write(arrAlive[x'y]);  			if (arrAlive [x' y] == 1) {  				GL.Vertex2 (x' y);  				GL.Vertex2 (x' y + 1);  				GL.Vertex2 (x + 1' y + 1);  				GL.Vertex2 (x + 1' y);  			}  		}  	}  	GL.End ();  	DrawCircle (30' ViewPointV.X' ViewPointV.Y' 1);  	Console.WriteLine (game.RenderFrequency);  	//load onto screen  	game.SwapBuffers ();  };  
Magic Number,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following statement contains a magic number: game.RenderFrame += (sender' e) =>  {  	// render graphics  	//clears screen  	GL.Clear (ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);  	GL.MatrixMode (MatrixMode.Projection);  	Vector2 followPosition = new Vector2 (0' 0);  	matrix = Matrix4.CreateTranslation (ViewPointV);  	GL.LoadMatrix (ref matrix);  	GL.Ortho (-game.Width * ZoomMulti' game.Width * ZoomMulti' -game.Height * ZoomMulti' game.Height * ZoomMulti' 0.0' 4.0);  	//speedup / slowdown  	//slowdown?  	if (SimulationSpeed < 20) {  		//Stop simulation when sim speed = 0  		if (SimulationSpeed == 0)  			SimulationSlowDownStep = 1;  		SimulationSlowDownStep += SimulationSpeed;  		if (SimulationSlowDownStep > 20)  			SimulationSlowDownStep = 0;  	}  	else  		SimulationSlowDownStep = 0;  	Console.WriteLine (SimulationSpeed);  	for (int zx = 20; (zx < SimulationSpeed || zx == 20) && SimulationSlowDownStep == 0; zx++) {  		int['] arrNextTo = new int[iSizeOfGrid' iSizeOfGrid];  		//calculate neighbours  		for (int x = 0; x < iSizeOfGrid; x++) {  			for (int y = 0; y < iSizeOfGrid; y++) {  				if (arrAlive [x' y] == 1 && x > 1 && y > 1 && x < iSizeOfGrid - 1 && y < iSizeOfGrid - 1) {  					arrNextTo [x - 1' y - 1]++;  					arrNextTo [x - 1' y]++;  					arrNextTo [x - 1' y + 1]++;  					arrNextTo [x' y + 1]++;  					arrNextTo [x' y - 1]++;  					arrNextTo [x + 1' y - 1]++;  					arrNextTo [x + 1' y]++;  					arrNextTo [x + 1' y + 1]++;  				}  			}  		}  		//kill / revive  		for (int x = 0; x < iSizeOfGrid; x++) {  			for (int y = 0; y < iSizeOfGrid; y++) {  				if (arrNextTo [x' y] < 2 || arrNextTo [x' y] > 3) {  					arrAlive [x' y] = 0;  				}  				if (arrNextTo [x' y] == 3) {  					arrAlive [x' y] = 1;  				}  			}  		}  	}  	//Now draw the objects to the gamewindow  	GL.Color3 (Color.Yellow);  	GL.Begin (PrimitiveType.Quads);  	//Draw Cells  	for (int x = 0; x < iSizeOfGrid; x++) {  		//Console.WriteLine('n');  		for (int y = 0; y < iSizeOfGrid; y++) {  			//	Console.Write(arrAlive[x'y]);  			if (arrAlive [x' y] == 1) {  				GL.Vertex2 (x' y);  				GL.Vertex2 (x' y + 1);  				GL.Vertex2 (x + 1' y + 1);  				GL.Vertex2 (x + 1' y);  			}  		}  	}  	GL.End ();  	DrawCircle (30' ViewPointV.X' ViewPointV.Y' 1);  	Console.WriteLine (game.RenderFrequency);  	//load onto screen  	game.SwapBuffers ();  };  
Magic Number,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following statement contains a magic number: GL.Ortho (-game.Width * ZoomMulti' game.Width * ZoomMulti' -game.Height * ZoomMulti' game.Height * ZoomMulti' 0.0' 4.0);  
Magic Number,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following statement contains a magic number: if (SimulationSpeed < 20) {  	//Stop simulation when sim speed = 0  	if (SimulationSpeed == 0)  		SimulationSlowDownStep = 1;  	SimulationSlowDownStep += SimulationSpeed;  	if (SimulationSlowDownStep > 20)  		SimulationSlowDownStep = 0;  }  else  	SimulationSlowDownStep = 0;  
Magic Number,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following statement contains a magic number: if (SimulationSpeed < 20) {  	//Stop simulation when sim speed = 0  	if (SimulationSpeed == 0)  		SimulationSlowDownStep = 1;  	SimulationSlowDownStep += SimulationSpeed;  	if (SimulationSlowDownStep > 20)  		SimulationSlowDownStep = 0;  }  else  	SimulationSlowDownStep = 0;  
Magic Number,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following statement contains a magic number: if (SimulationSlowDownStep > 20)  	SimulationSlowDownStep = 0;  
Magic Number,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following statement contains a magic number: for (int zx = 20; (zx < SimulationSpeed || zx == 20) && SimulationSlowDownStep == 0; zx++) {  	int['] arrNextTo = new int[iSizeOfGrid' iSizeOfGrid];  	//calculate neighbours  	for (int x = 0; x < iSizeOfGrid; x++) {  		for (int y = 0; y < iSizeOfGrid; y++) {  			if (arrAlive [x' y] == 1 && x > 1 && y > 1 && x < iSizeOfGrid - 1 && y < iSizeOfGrid - 1) {  				arrNextTo [x - 1' y - 1]++;  				arrNextTo [x - 1' y]++;  				arrNextTo [x - 1' y + 1]++;  				arrNextTo [x' y + 1]++;  				arrNextTo [x' y - 1]++;  				arrNextTo [x + 1' y - 1]++;  				arrNextTo [x + 1' y]++;  				arrNextTo [x + 1' y + 1]++;  			}  		}  	}  	//kill / revive  	for (int x = 0; x < iSizeOfGrid; x++) {  		for (int y = 0; y < iSizeOfGrid; y++) {  			if (arrNextTo [x' y] < 2 || arrNextTo [x' y] > 3) {  				arrAlive [x' y] = 0;  			}  			if (arrNextTo [x' y] == 3) {  				arrAlive [x' y] = 1;  			}  		}  	}  }  
Magic Number,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following statement contains a magic number: for (int zx = 20; (zx < SimulationSpeed || zx == 20) && SimulationSlowDownStep == 0; zx++) {  	int['] arrNextTo = new int[iSizeOfGrid' iSizeOfGrid];  	//calculate neighbours  	for (int x = 0; x < iSizeOfGrid; x++) {  		for (int y = 0; y < iSizeOfGrid; y++) {  			if (arrAlive [x' y] == 1 && x > 1 && y > 1 && x < iSizeOfGrid - 1 && y < iSizeOfGrid - 1) {  				arrNextTo [x - 1' y - 1]++;  				arrNextTo [x - 1' y]++;  				arrNextTo [x - 1' y + 1]++;  				arrNextTo [x' y + 1]++;  				arrNextTo [x' y - 1]++;  				arrNextTo [x + 1' y - 1]++;  				arrNextTo [x + 1' y]++;  				arrNextTo [x + 1' y + 1]++;  			}  		}  	}  	//kill / revive  	for (int x = 0; x < iSizeOfGrid; x++) {  		for (int y = 0; y < iSizeOfGrid; y++) {  			if (arrNextTo [x' y] < 2 || arrNextTo [x' y] > 3) {  				arrAlive [x' y] = 0;  			}  			if (arrNextTo [x' y] == 3) {  				arrAlive [x' y] = 1;  			}  		}  	}  }  
Magic Number,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following statement contains a magic number: for (int zx = 20; (zx < SimulationSpeed || zx == 20) && SimulationSlowDownStep == 0; zx++) {  	int['] arrNextTo = new int[iSizeOfGrid' iSizeOfGrid];  	//calculate neighbours  	for (int x = 0; x < iSizeOfGrid; x++) {  		for (int y = 0; y < iSizeOfGrid; y++) {  			if (arrAlive [x' y] == 1 && x > 1 && y > 1 && x < iSizeOfGrid - 1 && y < iSizeOfGrid - 1) {  				arrNextTo [x - 1' y - 1]++;  				arrNextTo [x - 1' y]++;  				arrNextTo [x - 1' y + 1]++;  				arrNextTo [x' y + 1]++;  				arrNextTo [x' y - 1]++;  				arrNextTo [x + 1' y - 1]++;  				arrNextTo [x + 1' y]++;  				arrNextTo [x + 1' y + 1]++;  			}  		}  	}  	//kill / revive  	for (int x = 0; x < iSizeOfGrid; x++) {  		for (int y = 0; y < iSizeOfGrid; y++) {  			if (arrNextTo [x' y] < 2 || arrNextTo [x' y] > 3) {  				arrAlive [x' y] = 0;  			}  			if (arrNextTo [x' y] == 3) {  				arrAlive [x' y] = 1;  			}  		}  	}  }  
Magic Number,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following statement contains a magic number: for (int zx = 20; (zx < SimulationSpeed || zx == 20) && SimulationSlowDownStep == 0; zx++) {  	int['] arrNextTo = new int[iSizeOfGrid' iSizeOfGrid];  	//calculate neighbours  	for (int x = 0; x < iSizeOfGrid; x++) {  		for (int y = 0; y < iSizeOfGrid; y++) {  			if (arrAlive [x' y] == 1 && x > 1 && y > 1 && x < iSizeOfGrid - 1 && y < iSizeOfGrid - 1) {  				arrNextTo [x - 1' y - 1]++;  				arrNextTo [x - 1' y]++;  				arrNextTo [x - 1' y + 1]++;  				arrNextTo [x' y + 1]++;  				arrNextTo [x' y - 1]++;  				arrNextTo [x + 1' y - 1]++;  				arrNextTo [x + 1' y]++;  				arrNextTo [x + 1' y + 1]++;  			}  		}  	}  	//kill / revive  	for (int x = 0; x < iSizeOfGrid; x++) {  		for (int y = 0; y < iSizeOfGrid; y++) {  			if (arrNextTo [x' y] < 2 || arrNextTo [x' y] > 3) {  				arrAlive [x' y] = 0;  			}  			if (arrNextTo [x' y] == 3) {  				arrAlive [x' y] = 1;  			}  		}  	}  }  
Magic Number,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following statement contains a magic number: for (int zx = 20; (zx < SimulationSpeed || zx == 20) && SimulationSlowDownStep == 0; zx++) {  	int['] arrNextTo = new int[iSizeOfGrid' iSizeOfGrid];  	//calculate neighbours  	for (int x = 0; x < iSizeOfGrid; x++) {  		for (int y = 0; y < iSizeOfGrid; y++) {  			if (arrAlive [x' y] == 1 && x > 1 && y > 1 && x < iSizeOfGrid - 1 && y < iSizeOfGrid - 1) {  				arrNextTo [x - 1' y - 1]++;  				arrNextTo [x - 1' y]++;  				arrNextTo [x - 1' y + 1]++;  				arrNextTo [x' y + 1]++;  				arrNextTo [x' y - 1]++;  				arrNextTo [x + 1' y - 1]++;  				arrNextTo [x + 1' y]++;  				arrNextTo [x + 1' y + 1]++;  			}  		}  	}  	//kill / revive  	for (int x = 0; x < iSizeOfGrid; x++) {  		for (int y = 0; y < iSizeOfGrid; y++) {  			if (arrNextTo [x' y] < 2 || arrNextTo [x' y] > 3) {  				arrAlive [x' y] = 0;  			}  			if (arrNextTo [x' y] == 3) {  				arrAlive [x' y] = 1;  			}  		}  	}  }  
Magic Number,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following statement contains a magic number: for (int x = 0; x < iSizeOfGrid; x++) {  	for (int y = 0; y < iSizeOfGrid; y++) {  		if (arrNextTo [x' y] < 2 || arrNextTo [x' y] > 3) {  			arrAlive [x' y] = 0;  		}  		if (arrNextTo [x' y] == 3) {  			arrAlive [x' y] = 1;  		}  	}  }  
Magic Number,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following statement contains a magic number: for (int x = 0; x < iSizeOfGrid; x++) {  	for (int y = 0; y < iSizeOfGrid; y++) {  		if (arrNextTo [x' y] < 2 || arrNextTo [x' y] > 3) {  			arrAlive [x' y] = 0;  		}  		if (arrNextTo [x' y] == 3) {  			arrAlive [x' y] = 1;  		}  	}  }  
Magic Number,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following statement contains a magic number: for (int x = 0; x < iSizeOfGrid; x++) {  	for (int y = 0; y < iSizeOfGrid; y++) {  		if (arrNextTo [x' y] < 2 || arrNextTo [x' y] > 3) {  			arrAlive [x' y] = 0;  		}  		if (arrNextTo [x' y] == 3) {  			arrAlive [x' y] = 1;  		}  	}  }  
Magic Number,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following statement contains a magic number: for (int y = 0; y < iSizeOfGrid; y++) {  	if (arrNextTo [x' y] < 2 || arrNextTo [x' y] > 3) {  		arrAlive [x' y] = 0;  	}  	if (arrNextTo [x' y] == 3) {  		arrAlive [x' y] = 1;  	}  }  
Magic Number,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following statement contains a magic number: for (int y = 0; y < iSizeOfGrid; y++) {  	if (arrNextTo [x' y] < 2 || arrNextTo [x' y] > 3) {  		arrAlive [x' y] = 0;  	}  	if (arrNextTo [x' y] == 3) {  		arrAlive [x' y] = 1;  	}  }  
Magic Number,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following statement contains a magic number: for (int y = 0; y < iSizeOfGrid; y++) {  	if (arrNextTo [x' y] < 2 || arrNextTo [x' y] > 3) {  		arrAlive [x' y] = 0;  	}  	if (arrNextTo [x' y] == 3) {  		arrAlive [x' y] = 1;  	}  }  
Magic Number,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following statement contains a magic number: if (arrNextTo [x' y] < 2 || arrNextTo [x' y] > 3) {  	arrAlive [x' y] = 0;  }  
Magic Number,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following statement contains a magic number: if (arrNextTo [x' y] < 2 || arrNextTo [x' y] > 3) {  	arrAlive [x' y] = 0;  }  
Magic Number,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following statement contains a magic number: if (arrNextTo [x' y] == 3) {  	arrAlive [x' y] = 1;  }  
Magic Number,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following statement contains a magic number: DrawCircle (30' ViewPointV.X' ViewPointV.Y' 1);  
Missing Default,life,tkui,C:\repos\xnbya_gameoflife\life\life\tkui.cs,Main,The following switch statement is missing a default case: switch (e.KeyChar) {  case 'f':  	game.WindowState = WindowState.Fullscreen;  	break;  case 'p':  	if (SimulationSpeed == 0)  		SimulationSpeed = 20;  	else  		SimulationSpeed = 0;  	break;  case 'c':  	//seed array  	for (int i = 0; i < iSizeOfGrid; i++) {  		for (int z = 0; z < iSizeOfGrid; z++) {  			arrAlive [i' z] = 0;  		}  	}  	break;  }  
