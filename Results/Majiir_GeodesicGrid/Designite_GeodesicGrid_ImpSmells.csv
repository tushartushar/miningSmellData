Implementation smell,Namespace,Class,File,Method,Description
Complex Method,GeodesicGrid.EnumerableExtensions,MinMaxBy,C:\repos\Majiir_GeodesicGrid\EnumerableExtensions\MinMaxBy.cs,minByImpl,Cyclomatic complexity of the method is 9
Complex Method,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,GetNeighbors,Cyclomatic complexity of the method is 8
Complex Method,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,GetFrontNeighbor,Cyclomatic complexity of the method is 14
Complex Method,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,getBackNeighbor,Cyclomatic complexity of the method is 11
Long Parameter List,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,Raycast,The method has 5 parameters.
Long Parameter List,GeodesicGrid,Triangle,C:\repos\Majiir_GeodesicGrid\Triangle.cs,Raycast,The method has 8 parameters.
Long Parameter List,GeodesicGrid,Triangle,C:\repos\Majiir_GeodesicGrid\Triangle.cs,intersectsCell,The method has 7 parameters.
Long Parameter List,GeodesicGrid,Triangle,C:\repos\Majiir_GeodesicGrid\Triangle.cs,intersectsFace,The method has 5 parameters.
Long Statement,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,GetVertices,The length of the statement  "	return this.GetNeighbors (level).Select (c => c.Position).EdgesCircular ().Select (p => (position + p.First + p.Second).normalized); " is 132.
Long Statement,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,GetVertices,The length of the statement  "		yield return (position + pair.First.Position + pair.Second.Position).normalized * (height + heightAt (pair.First) + heightAt (pair.Second)) / 3; " is 144.
Long Statement,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,approach,The length of the statement  "	return new Cell (this.index * a - (uint)((5 * (4 << (2 * this.Level)) * (a - (1 << (2 * levels))) - ((byte)direction - 4) * (a - 1)) / 2)); " is 139.
Long Statement,GeodesicGrid,LicenseSentinel,C:\repos\Majiir_GeodesicGrid\LicenseSentinel.cs,Run,The length of the statement  "	var text = new StreamReader (assembly.GetManifestResourceStream ("GeodesicGrid.GeodesicGrid-LICENSE.txt")).ReadToEnd (); " is 120.
Long Statement,GeodesicGrid,Triangle,C:\repos\Majiir_GeodesicGrid\Triangle.cs,Raycast,The length of the statement  "		ray = new Ray (gridTransform.InverseTransformPoint (ray.origin)' gridTransform.InverseTransformDirection (ray.direction)); " is 122.
Long Statement,GeodesicGrid,Triangle,C:\repos\Majiir_GeodesicGrid\Triangle.cs,Raycast,The length of the statement  "	return candidates.Select (t => t.Raycast (ray' level' heightAt)).Where (h => h.HasValue).MinByOrDefault (t => t.Value.Distance); " is 128.
Long Statement,GeodesicGrid,Triangle,C:\repos\Majiir_GeodesicGrid\Triangle.cs,intersectsCell,The length of the statement  "	return triangle.GetVertices (level).Select (c => c.Position).EdgesCircular ().Any (p => intersectsFace (ray' p.Second' p.First' min' max)); " is 139.
Complex Conditional,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,GetFrontNeighbor,The conditional expression  "(index % 2 == 0 && direction == ChildType.Up) || (index % 2 == 1 && direction == ChildType.Down)"  is complex.
Magic Number,GeodesicGrid,BoundsMap,C:\repos\Majiir_GeodesicGrid\BoundsMap.cs,BoundsMap,The following statement contains a magic number: foreach (var triangle in Triangle.AtLevel (level)) {  	maxs [triangle.Index] = triangle.GetVertices (level).Max (heightAt);  	var min = Mathf.Sqrt (triangle.GetVertices (level).EdgesCircular ().Min (e => (e.First.Position * heightAt (e.First) + e.Second.Position * heightAt (e.Second)).sqrMagnitude)) / 2;  	mins [triangle.Index] = Math.Min (min' triangle.GetVertices (level).Min (heightAt));  }  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,CountAtLevel,The following statement contains a magic number: return 10 * (1u << (level << 1)) + 2;  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,CountAtLevel,The following statement contains a magic number: return 10 * (1u << (level << 1)) + 2;  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,Raycast,The following statement contains a magic number: if ((barycentric.x >= barycentric.y) && (barycentric.x >= barycentric.z)) {  	return triangle.GetVertices (level).ElementAt (0);  }  else if ((barycentric.y >= barycentric.x) && (barycentric.y >= barycentric.z)) {  	return triangle.GetVertices (level).ElementAt (1);  }  else {  	return triangle.GetVertices (level).ElementAt (2);  }  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,Raycast,The following statement contains a magic number: if ((barycentric.y >= barycentric.x) && (barycentric.y >= barycentric.z)) {  	return triangle.GetVertices (level).ElementAt (1);  }  else {  	return triangle.GetVertices (level).ElementAt (2);  }  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,Raycast,The following statement contains a magic number: return triangle.GetVertices (level).ElementAt (2);  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,GetVertices,The following statement contains a magic number: foreach (var pair in this.GetNeighbors (level).EdgesCircular ()) {  	yield return (position + pair.First.Position + pair.Second.Position).normalized * (height + heightAt (pair.First) + heightAt (pair.Second)) / 3;  }  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,GetVertices,The following statement contains a magic number: yield return (position + pair.First.Position + pair.Second.Position).normalized * (height + heightAt (pair.First) + heightAt (pair.Second)) / 3;  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,GetNeighbors,The following statement contains a magic number: if (index == 0) {  	for (uint i = 10; i > 0; i -= 2) {  		yield return new Cell (i).approach (ChildType.Up' level);  	}  }  else if (index == 1) {  	for (uint i = 3; i < 12; i += 2) {  		yield return new Cell (i).approach (ChildType.Down' level);  	}  }  else {  	yield return this.GetFrontNeighbor (ChildType.Up' level);  	yield return this.GetFrontNeighbor (ChildType.Straight' level);  	yield return this.GetFrontNeighbor (ChildType.Down' level);  	var root = IsPentagon;  	if (!(root && index % 2 != 0)) {  		yield return this.getBackNeighbor (ChildType.Down' level);  	}  	yield return this.getBackNeighbor (ChildType.Straight' level);  	if (!(root && index % 2 == 0)) {  		yield return this.getBackNeighbor (ChildType.Up' level);  	}  }  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,GetNeighbors,The following statement contains a magic number: if (index == 0) {  	for (uint i = 10; i > 0; i -= 2) {  		yield return new Cell (i).approach (ChildType.Up' level);  	}  }  else if (index == 1) {  	for (uint i = 3; i < 12; i += 2) {  		yield return new Cell (i).approach (ChildType.Down' level);  	}  }  else {  	yield return this.GetFrontNeighbor (ChildType.Up' level);  	yield return this.GetFrontNeighbor (ChildType.Straight' level);  	yield return this.GetFrontNeighbor (ChildType.Down' level);  	var root = IsPentagon;  	if (!(root && index % 2 != 0)) {  		yield return this.getBackNeighbor (ChildType.Down' level);  	}  	yield return this.getBackNeighbor (ChildType.Straight' level);  	if (!(root && index % 2 == 0)) {  		yield return this.getBackNeighbor (ChildType.Up' level);  	}  }  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,GetNeighbors,The following statement contains a magic number: if (index == 0) {  	for (uint i = 10; i > 0; i -= 2) {  		yield return new Cell (i).approach (ChildType.Up' level);  	}  }  else if (index == 1) {  	for (uint i = 3; i < 12; i += 2) {  		yield return new Cell (i).approach (ChildType.Down' level);  	}  }  else {  	yield return this.GetFrontNeighbor (ChildType.Up' level);  	yield return this.GetFrontNeighbor (ChildType.Straight' level);  	yield return this.GetFrontNeighbor (ChildType.Down' level);  	var root = IsPentagon;  	if (!(root && index % 2 != 0)) {  		yield return this.getBackNeighbor (ChildType.Down' level);  	}  	yield return this.getBackNeighbor (ChildType.Straight' level);  	if (!(root && index % 2 == 0)) {  		yield return this.getBackNeighbor (ChildType.Up' level);  	}  }  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,GetNeighbors,The following statement contains a magic number: if (index == 0) {  	for (uint i = 10; i > 0; i -= 2) {  		yield return new Cell (i).approach (ChildType.Up' level);  	}  }  else if (index == 1) {  	for (uint i = 3; i < 12; i += 2) {  		yield return new Cell (i).approach (ChildType.Down' level);  	}  }  else {  	yield return this.GetFrontNeighbor (ChildType.Up' level);  	yield return this.GetFrontNeighbor (ChildType.Straight' level);  	yield return this.GetFrontNeighbor (ChildType.Down' level);  	var root = IsPentagon;  	if (!(root && index % 2 != 0)) {  		yield return this.getBackNeighbor (ChildType.Down' level);  	}  	yield return this.getBackNeighbor (ChildType.Straight' level);  	if (!(root && index % 2 == 0)) {  		yield return this.getBackNeighbor (ChildType.Up' level);  	}  }  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,GetNeighbors,The following statement contains a magic number: if (index == 0) {  	for (uint i = 10; i > 0; i -= 2) {  		yield return new Cell (i).approach (ChildType.Up' level);  	}  }  else if (index == 1) {  	for (uint i = 3; i < 12; i += 2) {  		yield return new Cell (i).approach (ChildType.Down' level);  	}  }  else {  	yield return this.GetFrontNeighbor (ChildType.Up' level);  	yield return this.GetFrontNeighbor (ChildType.Straight' level);  	yield return this.GetFrontNeighbor (ChildType.Down' level);  	var root = IsPentagon;  	if (!(root && index % 2 != 0)) {  		yield return this.getBackNeighbor (ChildType.Down' level);  	}  	yield return this.getBackNeighbor (ChildType.Straight' level);  	if (!(root && index % 2 == 0)) {  		yield return this.getBackNeighbor (ChildType.Up' level);  	}  }  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,GetNeighbors,The following statement contains a magic number: if (index == 0) {  	for (uint i = 10; i > 0; i -= 2) {  		yield return new Cell (i).approach (ChildType.Up' level);  	}  }  else if (index == 1) {  	for (uint i = 3; i < 12; i += 2) {  		yield return new Cell (i).approach (ChildType.Down' level);  	}  }  else {  	yield return this.GetFrontNeighbor (ChildType.Up' level);  	yield return this.GetFrontNeighbor (ChildType.Straight' level);  	yield return this.GetFrontNeighbor (ChildType.Down' level);  	var root = IsPentagon;  	if (!(root && index % 2 != 0)) {  		yield return this.getBackNeighbor (ChildType.Down' level);  	}  	yield return this.getBackNeighbor (ChildType.Straight' level);  	if (!(root && index % 2 == 0)) {  		yield return this.getBackNeighbor (ChildType.Up' level);  	}  }  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,GetNeighbors,The following statement contains a magic number: if (index == 0) {  	for (uint i = 10; i > 0; i -= 2) {  		yield return new Cell (i).approach (ChildType.Up' level);  	}  }  else if (index == 1) {  	for (uint i = 3; i < 12; i += 2) {  		yield return new Cell (i).approach (ChildType.Down' level);  	}  }  else {  	yield return this.GetFrontNeighbor (ChildType.Up' level);  	yield return this.GetFrontNeighbor (ChildType.Straight' level);  	yield return this.GetFrontNeighbor (ChildType.Down' level);  	var root = IsPentagon;  	if (!(root && index % 2 != 0)) {  		yield return this.getBackNeighbor (ChildType.Down' level);  	}  	yield return this.getBackNeighbor (ChildType.Straight' level);  	if (!(root && index % 2 == 0)) {  		yield return this.getBackNeighbor (ChildType.Up' level);  	}  }  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,GetNeighbors,The following statement contains a magic number: for (uint i = 10; i > 0; i -= 2) {  	yield return new Cell (i).approach (ChildType.Up' level);  }  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,GetNeighbors,The following statement contains a magic number: for (uint i = 10; i > 0; i -= 2) {  	yield return new Cell (i).approach (ChildType.Up' level);  }  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,GetNeighbors,The following statement contains a magic number: i -= 2
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,GetNeighbors,The following statement contains a magic number: if (index == 1) {  	for (uint i = 3; i < 12; i += 2) {  		yield return new Cell (i).approach (ChildType.Down' level);  	}  }  else {  	yield return this.GetFrontNeighbor (ChildType.Up' level);  	yield return this.GetFrontNeighbor (ChildType.Straight' level);  	yield return this.GetFrontNeighbor (ChildType.Down' level);  	var root = IsPentagon;  	if (!(root && index % 2 != 0)) {  		yield return this.getBackNeighbor (ChildType.Down' level);  	}  	yield return this.getBackNeighbor (ChildType.Straight' level);  	if (!(root && index % 2 == 0)) {  		yield return this.getBackNeighbor (ChildType.Up' level);  	}  }  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,GetNeighbors,The following statement contains a magic number: if (index == 1) {  	for (uint i = 3; i < 12; i += 2) {  		yield return new Cell (i).approach (ChildType.Down' level);  	}  }  else {  	yield return this.GetFrontNeighbor (ChildType.Up' level);  	yield return this.GetFrontNeighbor (ChildType.Straight' level);  	yield return this.GetFrontNeighbor (ChildType.Down' level);  	var root = IsPentagon;  	if (!(root && index % 2 != 0)) {  		yield return this.getBackNeighbor (ChildType.Down' level);  	}  	yield return this.getBackNeighbor (ChildType.Straight' level);  	if (!(root && index % 2 == 0)) {  		yield return this.getBackNeighbor (ChildType.Up' level);  	}  }  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,GetNeighbors,The following statement contains a magic number: if (index == 1) {  	for (uint i = 3; i < 12; i += 2) {  		yield return new Cell (i).approach (ChildType.Down' level);  	}  }  else {  	yield return this.GetFrontNeighbor (ChildType.Up' level);  	yield return this.GetFrontNeighbor (ChildType.Straight' level);  	yield return this.GetFrontNeighbor (ChildType.Down' level);  	var root = IsPentagon;  	if (!(root && index % 2 != 0)) {  		yield return this.getBackNeighbor (ChildType.Down' level);  	}  	yield return this.getBackNeighbor (ChildType.Straight' level);  	if (!(root && index % 2 == 0)) {  		yield return this.getBackNeighbor (ChildType.Up' level);  	}  }  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,GetNeighbors,The following statement contains a magic number: if (index == 1) {  	for (uint i = 3; i < 12; i += 2) {  		yield return new Cell (i).approach (ChildType.Down' level);  	}  }  else {  	yield return this.GetFrontNeighbor (ChildType.Up' level);  	yield return this.GetFrontNeighbor (ChildType.Straight' level);  	yield return this.GetFrontNeighbor (ChildType.Down' level);  	var root = IsPentagon;  	if (!(root && index % 2 != 0)) {  		yield return this.getBackNeighbor (ChildType.Down' level);  	}  	yield return this.getBackNeighbor (ChildType.Straight' level);  	if (!(root && index % 2 == 0)) {  		yield return this.getBackNeighbor (ChildType.Up' level);  	}  }  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,GetNeighbors,The following statement contains a magic number: if (index == 1) {  	for (uint i = 3; i < 12; i += 2) {  		yield return new Cell (i).approach (ChildType.Down' level);  	}  }  else {  	yield return this.GetFrontNeighbor (ChildType.Up' level);  	yield return this.GetFrontNeighbor (ChildType.Straight' level);  	yield return this.GetFrontNeighbor (ChildType.Down' level);  	var root = IsPentagon;  	if (!(root && index % 2 != 0)) {  		yield return this.getBackNeighbor (ChildType.Down' level);  	}  	yield return this.getBackNeighbor (ChildType.Straight' level);  	if (!(root && index % 2 == 0)) {  		yield return this.getBackNeighbor (ChildType.Up' level);  	}  }  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,GetNeighbors,The following statement contains a magic number: for (uint i = 3; i < 12; i += 2) {  	yield return new Cell (i).approach (ChildType.Down' level);  }  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,GetNeighbors,The following statement contains a magic number: for (uint i = 3; i < 12; i += 2) {  	yield return new Cell (i).approach (ChildType.Down' level);  }  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,GetNeighbors,The following statement contains a magic number: for (uint i = 3; i < 12; i += 2) {  	yield return new Cell (i).approach (ChildType.Down' level);  }  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,GetNeighbors,The following statement contains a magic number: i += 2
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,GetNeighbors,The following statement contains a magic number: if (!(root && index % 2 != 0)) {  	yield return this.getBackNeighbor (ChildType.Down' level);  }  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,GetNeighbors,The following statement contains a magic number: if (!(root && index % 2 == 0)) {  	yield return this.getBackNeighbor (ChildType.Up' level);  }  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,GetParent,The following statement contains a magic number: return new Cell (subindex / 3 + 2);  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,GetParent,The following statement contains a magic number: return new Cell (subindex / 3 + 2);  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,getChild,The following statement contains a magic number: return new Cell ((index - 2) * 3 + (byte)direction' level - 1);  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,getChild,The following statement contains a magic number: return new Cell ((index - 2) * 3 + (byte)direction' level - 1);  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,approach,The following statement contains a magic number: return new Cell (this.index * a - (uint)((5 * (4 << (2 * this.Level)) * (a - (1 << (2 * levels))) - ((byte)direction - 4) * (a - 1)) / 2));  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,approach,The following statement contains a magic number: return new Cell (this.index * a - (uint)((5 * (4 << (2 * this.Level)) * (a - (1 << (2 * levels))) - ((byte)direction - 4) * (a - 1)) / 2));  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,approach,The following statement contains a magic number: return new Cell (this.index * a - (uint)((5 * (4 << (2 * this.Level)) * (a - (1 << (2 * levels))) - ((byte)direction - 4) * (a - 1)) / 2));  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,approach,The following statement contains a magic number: return new Cell (this.index * a - (uint)((5 * (4 << (2 * this.Level)) * (a - (1 << (2 * levels))) - ((byte)direction - 4) * (a - 1)) / 2));  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,approach,The following statement contains a magic number: return new Cell (this.index * a - (uint)((5 * (4 << (2 * this.Level)) * (a - (1 << (2 * levels))) - ((byte)direction - 4) * (a - 1)) / 2));  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,approach,The following statement contains a magic number: return new Cell (this.index * a - (uint)((5 * (4 << (2 * this.Level)) * (a - (1 << (2 * levels))) - ((byte)direction - 4) * (a - 1)) / 2));  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,wrap,The following statement contains a magic number: return (index + 8) % 10 + 2;  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,wrap,The following statement contains a magic number: return (index + 8) % 10 + 2;  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,wrap,The following statement contains a magic number: return (index + 8) % 10 + 2;  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,GetFrontNeighbor,The following statement contains a magic number: if (level == 0) {  	if (isPolar) {  		throw new ArgumentException ("Cannot find neighbor of a polar cell");  	}  	if (direction == ChildType.Straight) {  		return new Cell (wrap (index + 2));  	}  	else if ((index % 2 == 0 && direction == ChildType.Up) || (index % 2 == 1 && direction == ChildType.Down)) {  		return new Cell (index % 2);  	}  	else {  		return new Cell (wrap (index + 1));  	}  }  else if (level == thisLevel) {  	for (var cacheLevel = neighborCache.Count + 1; cacheLevel <= thisLevel; cacheLevel++) {  		var cache = new Cell[30 << (2 * (cacheLevel - 1))' 3];  		var count = CountAtLevel (cacheLevel - 1);  		for (uint j = 0; j < cache.GetLength (0); j++) {  			for (byte k = 0; k < 3; k++) {  				var cell = new Cell (count + j);  				var dir = (ChildType)k;  				var thisDir = cell.direction;  				var first = cell.GetParent ();  				if (thisDir == dir) {  					cache [j' k] = first.GetFrontNeighbor (dir' cacheLevel - 1);  				}  				else if (thisDir == dir.Flip ()) {  					cache [j' k] = first.GetFrontNeighbor (ChildType.Straight' cacheLevel);  				}  				else {  					if (dir == ChildType.Straight) {  						dir = thisDir;  					}  					var other = first.GetFrontNeighbor (dir' cacheLevel - 1);  					if (other.isPolarSeam () && (first.getRoot () != other.getRoot ())) {  						cache [j' k] = first.GetFrontNeighbor (ChildType.Straight' cacheLevel - 1).GetFrontNeighbor (dir' cacheLevel);  					}  					else {  						cache [j' k] = other.GetFrontNeighbor (dir.Flip ()' cacheLevel);  					}  				}  			}  		}  		neighborCache.Add (cache);  	}  	return neighborCache [thisLevel - 1] [this.subindex' (byte)direction];  }  else {  	return getChild (direction' level);  }  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,GetFrontNeighbor,The following statement contains a magic number: if (level == 0) {  	if (isPolar) {  		throw new ArgumentException ("Cannot find neighbor of a polar cell");  	}  	if (direction == ChildType.Straight) {  		return new Cell (wrap (index + 2));  	}  	else if ((index % 2 == 0 && direction == ChildType.Up) || (index % 2 == 1 && direction == ChildType.Down)) {  		return new Cell (index % 2);  	}  	else {  		return new Cell (wrap (index + 1));  	}  }  else if (level == thisLevel) {  	for (var cacheLevel = neighborCache.Count + 1; cacheLevel <= thisLevel; cacheLevel++) {  		var cache = new Cell[30 << (2 * (cacheLevel - 1))' 3];  		var count = CountAtLevel (cacheLevel - 1);  		for (uint j = 0; j < cache.GetLength (0); j++) {  			for (byte k = 0; k < 3; k++) {  				var cell = new Cell (count + j);  				var dir = (ChildType)k;  				var thisDir = cell.direction;  				var first = cell.GetParent ();  				if (thisDir == dir) {  					cache [j' k] = first.GetFrontNeighbor (dir' cacheLevel - 1);  				}  				else if (thisDir == dir.Flip ()) {  					cache [j' k] = first.GetFrontNeighbor (ChildType.Straight' cacheLevel);  				}  				else {  					if (dir == ChildType.Straight) {  						dir = thisDir;  					}  					var other = first.GetFrontNeighbor (dir' cacheLevel - 1);  					if (other.isPolarSeam () && (first.getRoot () != other.getRoot ())) {  						cache [j' k] = first.GetFrontNeighbor (ChildType.Straight' cacheLevel - 1).GetFrontNeighbor (dir' cacheLevel);  					}  					else {  						cache [j' k] = other.GetFrontNeighbor (dir.Flip ()' cacheLevel);  					}  				}  			}  		}  		neighborCache.Add (cache);  	}  	return neighborCache [thisLevel - 1] [this.subindex' (byte)direction];  }  else {  	return getChild (direction' level);  }  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,GetFrontNeighbor,The following statement contains a magic number: if (level == 0) {  	if (isPolar) {  		throw new ArgumentException ("Cannot find neighbor of a polar cell");  	}  	if (direction == ChildType.Straight) {  		return new Cell (wrap (index + 2));  	}  	else if ((index % 2 == 0 && direction == ChildType.Up) || (index % 2 == 1 && direction == ChildType.Down)) {  		return new Cell (index % 2);  	}  	else {  		return new Cell (wrap (index + 1));  	}  }  else if (level == thisLevel) {  	for (var cacheLevel = neighborCache.Count + 1; cacheLevel <= thisLevel; cacheLevel++) {  		var cache = new Cell[30 << (2 * (cacheLevel - 1))' 3];  		var count = CountAtLevel (cacheLevel - 1);  		for (uint j = 0; j < cache.GetLength (0); j++) {  			for (byte k = 0; k < 3; k++) {  				var cell = new Cell (count + j);  				var dir = (ChildType)k;  				var thisDir = cell.direction;  				var first = cell.GetParent ();  				if (thisDir == dir) {  					cache [j' k] = first.GetFrontNeighbor (dir' cacheLevel - 1);  				}  				else if (thisDir == dir.Flip ()) {  					cache [j' k] = first.GetFrontNeighbor (ChildType.Straight' cacheLevel);  				}  				else {  					if (dir == ChildType.Straight) {  						dir = thisDir;  					}  					var other = first.GetFrontNeighbor (dir' cacheLevel - 1);  					if (other.isPolarSeam () && (first.getRoot () != other.getRoot ())) {  						cache [j' k] = first.GetFrontNeighbor (ChildType.Straight' cacheLevel - 1).GetFrontNeighbor (dir' cacheLevel);  					}  					else {  						cache [j' k] = other.GetFrontNeighbor (dir.Flip ()' cacheLevel);  					}  				}  			}  		}  		neighborCache.Add (cache);  	}  	return neighborCache [thisLevel - 1] [this.subindex' (byte)direction];  }  else {  	return getChild (direction' level);  }  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,GetFrontNeighbor,The following statement contains a magic number: if (level == 0) {  	if (isPolar) {  		throw new ArgumentException ("Cannot find neighbor of a polar cell");  	}  	if (direction == ChildType.Straight) {  		return new Cell (wrap (index + 2));  	}  	else if ((index % 2 == 0 && direction == ChildType.Up) || (index % 2 == 1 && direction == ChildType.Down)) {  		return new Cell (index % 2);  	}  	else {  		return new Cell (wrap (index + 1));  	}  }  else if (level == thisLevel) {  	for (var cacheLevel = neighborCache.Count + 1; cacheLevel <= thisLevel; cacheLevel++) {  		var cache = new Cell[30 << (2 * (cacheLevel - 1))' 3];  		var count = CountAtLevel (cacheLevel - 1);  		for (uint j = 0; j < cache.GetLength (0); j++) {  			for (byte k = 0; k < 3; k++) {  				var cell = new Cell (count + j);  				var dir = (ChildType)k;  				var thisDir = cell.direction;  				var first = cell.GetParent ();  				if (thisDir == dir) {  					cache [j' k] = first.GetFrontNeighbor (dir' cacheLevel - 1);  				}  				else if (thisDir == dir.Flip ()) {  					cache [j' k] = first.GetFrontNeighbor (ChildType.Straight' cacheLevel);  				}  				else {  					if (dir == ChildType.Straight) {  						dir = thisDir;  					}  					var other = first.GetFrontNeighbor (dir' cacheLevel - 1);  					if (other.isPolarSeam () && (first.getRoot () != other.getRoot ())) {  						cache [j' k] = first.GetFrontNeighbor (ChildType.Straight' cacheLevel - 1).GetFrontNeighbor (dir' cacheLevel);  					}  					else {  						cache [j' k] = other.GetFrontNeighbor (dir.Flip ()' cacheLevel);  					}  				}  			}  		}  		neighborCache.Add (cache);  	}  	return neighborCache [thisLevel - 1] [this.subindex' (byte)direction];  }  else {  	return getChild (direction' level);  }  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,GetFrontNeighbor,The following statement contains a magic number: if (level == 0) {  	if (isPolar) {  		throw new ArgumentException ("Cannot find neighbor of a polar cell");  	}  	if (direction == ChildType.Straight) {  		return new Cell (wrap (index + 2));  	}  	else if ((index % 2 == 0 && direction == ChildType.Up) || (index % 2 == 1 && direction == ChildType.Down)) {  		return new Cell (index % 2);  	}  	else {  		return new Cell (wrap (index + 1));  	}  }  else if (level == thisLevel) {  	for (var cacheLevel = neighborCache.Count + 1; cacheLevel <= thisLevel; cacheLevel++) {  		var cache = new Cell[30 << (2 * (cacheLevel - 1))' 3];  		var count = CountAtLevel (cacheLevel - 1);  		for (uint j = 0; j < cache.GetLength (0); j++) {  			for (byte k = 0; k < 3; k++) {  				var cell = new Cell (count + j);  				var dir = (ChildType)k;  				var thisDir = cell.direction;  				var first = cell.GetParent ();  				if (thisDir == dir) {  					cache [j' k] = first.GetFrontNeighbor (dir' cacheLevel - 1);  				}  				else if (thisDir == dir.Flip ()) {  					cache [j' k] = first.GetFrontNeighbor (ChildType.Straight' cacheLevel);  				}  				else {  					if (dir == ChildType.Straight) {  						dir = thisDir;  					}  					var other = first.GetFrontNeighbor (dir' cacheLevel - 1);  					if (other.isPolarSeam () && (first.getRoot () != other.getRoot ())) {  						cache [j' k] = first.GetFrontNeighbor (ChildType.Straight' cacheLevel - 1).GetFrontNeighbor (dir' cacheLevel);  					}  					else {  						cache [j' k] = other.GetFrontNeighbor (dir.Flip ()' cacheLevel);  					}  				}  			}  		}  		neighborCache.Add (cache);  	}  	return neighborCache [thisLevel - 1] [this.subindex' (byte)direction];  }  else {  	return getChild (direction' level);  }  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,GetFrontNeighbor,The following statement contains a magic number: if (level == 0) {  	if (isPolar) {  		throw new ArgumentException ("Cannot find neighbor of a polar cell");  	}  	if (direction == ChildType.Straight) {  		return new Cell (wrap (index + 2));  	}  	else if ((index % 2 == 0 && direction == ChildType.Up) || (index % 2 == 1 && direction == ChildType.Down)) {  		return new Cell (index % 2);  	}  	else {  		return new Cell (wrap (index + 1));  	}  }  else if (level == thisLevel) {  	for (var cacheLevel = neighborCache.Count + 1; cacheLevel <= thisLevel; cacheLevel++) {  		var cache = new Cell[30 << (2 * (cacheLevel - 1))' 3];  		var count = CountAtLevel (cacheLevel - 1);  		for (uint j = 0; j < cache.GetLength (0); j++) {  			for (byte k = 0; k < 3; k++) {  				var cell = new Cell (count + j);  				var dir = (ChildType)k;  				var thisDir = cell.direction;  				var first = cell.GetParent ();  				if (thisDir == dir) {  					cache [j' k] = first.GetFrontNeighbor (dir' cacheLevel - 1);  				}  				else if (thisDir == dir.Flip ()) {  					cache [j' k] = first.GetFrontNeighbor (ChildType.Straight' cacheLevel);  				}  				else {  					if (dir == ChildType.Straight) {  						dir = thisDir;  					}  					var other = first.GetFrontNeighbor (dir' cacheLevel - 1);  					if (other.isPolarSeam () && (first.getRoot () != other.getRoot ())) {  						cache [j' k] = first.GetFrontNeighbor (ChildType.Straight' cacheLevel - 1).GetFrontNeighbor (dir' cacheLevel);  					}  					else {  						cache [j' k] = other.GetFrontNeighbor (dir.Flip ()' cacheLevel);  					}  				}  			}  		}  		neighborCache.Add (cache);  	}  	return neighborCache [thisLevel - 1] [this.subindex' (byte)direction];  }  else {  	return getChild (direction' level);  }  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,GetFrontNeighbor,The following statement contains a magic number: if (level == 0) {  	if (isPolar) {  		throw new ArgumentException ("Cannot find neighbor of a polar cell");  	}  	if (direction == ChildType.Straight) {  		return new Cell (wrap (index + 2));  	}  	else if ((index % 2 == 0 && direction == ChildType.Up) || (index % 2 == 1 && direction == ChildType.Down)) {  		return new Cell (index % 2);  	}  	else {  		return new Cell (wrap (index + 1));  	}  }  else if (level == thisLevel) {  	for (var cacheLevel = neighborCache.Count + 1; cacheLevel <= thisLevel; cacheLevel++) {  		var cache = new Cell[30 << (2 * (cacheLevel - 1))' 3];  		var count = CountAtLevel (cacheLevel - 1);  		for (uint j = 0; j < cache.GetLength (0); j++) {  			for (byte k = 0; k < 3; k++) {  				var cell = new Cell (count + j);  				var dir = (ChildType)k;  				var thisDir = cell.direction;  				var first = cell.GetParent ();  				if (thisDir == dir) {  					cache [j' k] = first.GetFrontNeighbor (dir' cacheLevel - 1);  				}  				else if (thisDir == dir.Flip ()) {  					cache [j' k] = first.GetFrontNeighbor (ChildType.Straight' cacheLevel);  				}  				else {  					if (dir == ChildType.Straight) {  						dir = thisDir;  					}  					var other = first.GetFrontNeighbor (dir' cacheLevel - 1);  					if (other.isPolarSeam () && (first.getRoot () != other.getRoot ())) {  						cache [j' k] = first.GetFrontNeighbor (ChildType.Straight' cacheLevel - 1).GetFrontNeighbor (dir' cacheLevel);  					}  					else {  						cache [j' k] = other.GetFrontNeighbor (dir.Flip ()' cacheLevel);  					}  				}  			}  		}  		neighborCache.Add (cache);  	}  	return neighborCache [thisLevel - 1] [this.subindex' (byte)direction];  }  else {  	return getChild (direction' level);  }  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,GetFrontNeighbor,The following statement contains a magic number: if (level == 0) {  	if (isPolar) {  		throw new ArgumentException ("Cannot find neighbor of a polar cell");  	}  	if (direction == ChildType.Straight) {  		return new Cell (wrap (index + 2));  	}  	else if ((index % 2 == 0 && direction == ChildType.Up) || (index % 2 == 1 && direction == ChildType.Down)) {  		return new Cell (index % 2);  	}  	else {  		return new Cell (wrap (index + 1));  	}  }  else if (level == thisLevel) {  	for (var cacheLevel = neighborCache.Count + 1; cacheLevel <= thisLevel; cacheLevel++) {  		var cache = new Cell[30 << (2 * (cacheLevel - 1))' 3];  		var count = CountAtLevel (cacheLevel - 1);  		for (uint j = 0; j < cache.GetLength (0); j++) {  			for (byte k = 0; k < 3; k++) {  				var cell = new Cell (count + j);  				var dir = (ChildType)k;  				var thisDir = cell.direction;  				var first = cell.GetParent ();  				if (thisDir == dir) {  					cache [j' k] = first.GetFrontNeighbor (dir' cacheLevel - 1);  				}  				else if (thisDir == dir.Flip ()) {  					cache [j' k] = first.GetFrontNeighbor (ChildType.Straight' cacheLevel);  				}  				else {  					if (dir == ChildType.Straight) {  						dir = thisDir;  					}  					var other = first.GetFrontNeighbor (dir' cacheLevel - 1);  					if (other.isPolarSeam () && (first.getRoot () != other.getRoot ())) {  						cache [j' k] = first.GetFrontNeighbor (ChildType.Straight' cacheLevel - 1).GetFrontNeighbor (dir' cacheLevel);  					}  					else {  						cache [j' k] = other.GetFrontNeighbor (dir.Flip ()' cacheLevel);  					}  				}  			}  		}  		neighborCache.Add (cache);  	}  	return neighborCache [thisLevel - 1] [this.subindex' (byte)direction];  }  else {  	return getChild (direction' level);  }  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,GetFrontNeighbor,The following statement contains a magic number: if (direction == ChildType.Straight) {  	return new Cell (wrap (index + 2));  }  else if ((index % 2 == 0 && direction == ChildType.Up) || (index % 2 == 1 && direction == ChildType.Down)) {  	return new Cell (index % 2);  }  else {  	return new Cell (wrap (index + 1));  }  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,GetFrontNeighbor,The following statement contains a magic number: if (direction == ChildType.Straight) {  	return new Cell (wrap (index + 2));  }  else if ((index % 2 == 0 && direction == ChildType.Up) || (index % 2 == 1 && direction == ChildType.Down)) {  	return new Cell (index % 2);  }  else {  	return new Cell (wrap (index + 1));  }  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,GetFrontNeighbor,The following statement contains a magic number: if (direction == ChildType.Straight) {  	return new Cell (wrap (index + 2));  }  else if ((index % 2 == 0 && direction == ChildType.Up) || (index % 2 == 1 && direction == ChildType.Down)) {  	return new Cell (index % 2);  }  else {  	return new Cell (wrap (index + 1));  }  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,GetFrontNeighbor,The following statement contains a magic number: if (direction == ChildType.Straight) {  	return new Cell (wrap (index + 2));  }  else if ((index % 2 == 0 && direction == ChildType.Up) || (index % 2 == 1 && direction == ChildType.Down)) {  	return new Cell (index % 2);  }  else {  	return new Cell (wrap (index + 1));  }  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,GetFrontNeighbor,The following statement contains a magic number: return new Cell (wrap (index + 2));  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,GetFrontNeighbor,The following statement contains a magic number: if ((index % 2 == 0 && direction == ChildType.Up) || (index % 2 == 1 && direction == ChildType.Down)) {  	return new Cell (index % 2);  }  else {  	return new Cell (wrap (index + 1));  }  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,GetFrontNeighbor,The following statement contains a magic number: if ((index % 2 == 0 && direction == ChildType.Up) || (index % 2 == 1 && direction == ChildType.Down)) {  	return new Cell (index % 2);  }  else {  	return new Cell (wrap (index + 1));  }  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,GetFrontNeighbor,The following statement contains a magic number: if ((index % 2 == 0 && direction == ChildType.Up) || (index % 2 == 1 && direction == ChildType.Down)) {  	return new Cell (index % 2);  }  else {  	return new Cell (wrap (index + 1));  }  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,GetFrontNeighbor,The following statement contains a magic number: return new Cell (index % 2);  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,GetFrontNeighbor,The following statement contains a magic number: if (level == thisLevel) {  	for (var cacheLevel = neighborCache.Count + 1; cacheLevel <= thisLevel; cacheLevel++) {  		var cache = new Cell[30 << (2 * (cacheLevel - 1))' 3];  		var count = CountAtLevel (cacheLevel - 1);  		for (uint j = 0; j < cache.GetLength (0); j++) {  			for (byte k = 0; k < 3; k++) {  				var cell = new Cell (count + j);  				var dir = (ChildType)k;  				var thisDir = cell.direction;  				var first = cell.GetParent ();  				if (thisDir == dir) {  					cache [j' k] = first.GetFrontNeighbor (dir' cacheLevel - 1);  				}  				else if (thisDir == dir.Flip ()) {  					cache [j' k] = first.GetFrontNeighbor (ChildType.Straight' cacheLevel);  				}  				else {  					if (dir == ChildType.Straight) {  						dir = thisDir;  					}  					var other = first.GetFrontNeighbor (dir' cacheLevel - 1);  					if (other.isPolarSeam () && (first.getRoot () != other.getRoot ())) {  						cache [j' k] = first.GetFrontNeighbor (ChildType.Straight' cacheLevel - 1).GetFrontNeighbor (dir' cacheLevel);  					}  					else {  						cache [j' k] = other.GetFrontNeighbor (dir.Flip ()' cacheLevel);  					}  				}  			}  		}  		neighborCache.Add (cache);  	}  	return neighborCache [thisLevel - 1] [this.subindex' (byte)direction];  }  else {  	return getChild (direction' level);  }  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,GetFrontNeighbor,The following statement contains a magic number: if (level == thisLevel) {  	for (var cacheLevel = neighborCache.Count + 1; cacheLevel <= thisLevel; cacheLevel++) {  		var cache = new Cell[30 << (2 * (cacheLevel - 1))' 3];  		var count = CountAtLevel (cacheLevel - 1);  		for (uint j = 0; j < cache.GetLength (0); j++) {  			for (byte k = 0; k < 3; k++) {  				var cell = new Cell (count + j);  				var dir = (ChildType)k;  				var thisDir = cell.direction;  				var first = cell.GetParent ();  				if (thisDir == dir) {  					cache [j' k] = first.GetFrontNeighbor (dir' cacheLevel - 1);  				}  				else if (thisDir == dir.Flip ()) {  					cache [j' k] = first.GetFrontNeighbor (ChildType.Straight' cacheLevel);  				}  				else {  					if (dir == ChildType.Straight) {  						dir = thisDir;  					}  					var other = first.GetFrontNeighbor (dir' cacheLevel - 1);  					if (other.isPolarSeam () && (first.getRoot () != other.getRoot ())) {  						cache [j' k] = first.GetFrontNeighbor (ChildType.Straight' cacheLevel - 1).GetFrontNeighbor (dir' cacheLevel);  					}  					else {  						cache [j' k] = other.GetFrontNeighbor (dir.Flip ()' cacheLevel);  					}  				}  			}  		}  		neighborCache.Add (cache);  	}  	return neighborCache [thisLevel - 1] [this.subindex' (byte)direction];  }  else {  	return getChild (direction' level);  }  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,GetFrontNeighbor,The following statement contains a magic number: if (level == thisLevel) {  	for (var cacheLevel = neighborCache.Count + 1; cacheLevel <= thisLevel; cacheLevel++) {  		var cache = new Cell[30 << (2 * (cacheLevel - 1))' 3];  		var count = CountAtLevel (cacheLevel - 1);  		for (uint j = 0; j < cache.GetLength (0); j++) {  			for (byte k = 0; k < 3; k++) {  				var cell = new Cell (count + j);  				var dir = (ChildType)k;  				var thisDir = cell.direction;  				var first = cell.GetParent ();  				if (thisDir == dir) {  					cache [j' k] = first.GetFrontNeighbor (dir' cacheLevel - 1);  				}  				else if (thisDir == dir.Flip ()) {  					cache [j' k] = first.GetFrontNeighbor (ChildType.Straight' cacheLevel);  				}  				else {  					if (dir == ChildType.Straight) {  						dir = thisDir;  					}  					var other = first.GetFrontNeighbor (dir' cacheLevel - 1);  					if (other.isPolarSeam () && (first.getRoot () != other.getRoot ())) {  						cache [j' k] = first.GetFrontNeighbor (ChildType.Straight' cacheLevel - 1).GetFrontNeighbor (dir' cacheLevel);  					}  					else {  						cache [j' k] = other.GetFrontNeighbor (dir.Flip ()' cacheLevel);  					}  				}  			}  		}  		neighborCache.Add (cache);  	}  	return neighborCache [thisLevel - 1] [this.subindex' (byte)direction];  }  else {  	return getChild (direction' level);  }  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,GetFrontNeighbor,The following statement contains a magic number: if (level == thisLevel) {  	for (var cacheLevel = neighborCache.Count + 1; cacheLevel <= thisLevel; cacheLevel++) {  		var cache = new Cell[30 << (2 * (cacheLevel - 1))' 3];  		var count = CountAtLevel (cacheLevel - 1);  		for (uint j = 0; j < cache.GetLength (0); j++) {  			for (byte k = 0; k < 3; k++) {  				var cell = new Cell (count + j);  				var dir = (ChildType)k;  				var thisDir = cell.direction;  				var first = cell.GetParent ();  				if (thisDir == dir) {  					cache [j' k] = first.GetFrontNeighbor (dir' cacheLevel - 1);  				}  				else if (thisDir == dir.Flip ()) {  					cache [j' k] = first.GetFrontNeighbor (ChildType.Straight' cacheLevel);  				}  				else {  					if (dir == ChildType.Straight) {  						dir = thisDir;  					}  					var other = first.GetFrontNeighbor (dir' cacheLevel - 1);  					if (other.isPolarSeam () && (first.getRoot () != other.getRoot ())) {  						cache [j' k] = first.GetFrontNeighbor (ChildType.Straight' cacheLevel - 1).GetFrontNeighbor (dir' cacheLevel);  					}  					else {  						cache [j' k] = other.GetFrontNeighbor (dir.Flip ()' cacheLevel);  					}  				}  			}  		}  		neighborCache.Add (cache);  	}  	return neighborCache [thisLevel - 1] [this.subindex' (byte)direction];  }  else {  	return getChild (direction' level);  }  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,GetFrontNeighbor,The following statement contains a magic number: for (var cacheLevel = neighborCache.Count + 1; cacheLevel <= thisLevel; cacheLevel++) {  	var cache = new Cell[30 << (2 * (cacheLevel - 1))' 3];  	var count = CountAtLevel (cacheLevel - 1);  	for (uint j = 0; j < cache.GetLength (0); j++) {  		for (byte k = 0; k < 3; k++) {  			var cell = new Cell (count + j);  			var dir = (ChildType)k;  			var thisDir = cell.direction;  			var first = cell.GetParent ();  			if (thisDir == dir) {  				cache [j' k] = first.GetFrontNeighbor (dir' cacheLevel - 1);  			}  			else if (thisDir == dir.Flip ()) {  				cache [j' k] = first.GetFrontNeighbor (ChildType.Straight' cacheLevel);  			}  			else {  				if (dir == ChildType.Straight) {  					dir = thisDir;  				}  				var other = first.GetFrontNeighbor (dir' cacheLevel - 1);  				if (other.isPolarSeam () && (first.getRoot () != other.getRoot ())) {  					cache [j' k] = first.GetFrontNeighbor (ChildType.Straight' cacheLevel - 1).GetFrontNeighbor (dir' cacheLevel);  				}  				else {  					cache [j' k] = other.GetFrontNeighbor (dir.Flip ()' cacheLevel);  				}  			}  		}  	}  	neighborCache.Add (cache);  }  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,GetFrontNeighbor,The following statement contains a magic number: for (var cacheLevel = neighborCache.Count + 1; cacheLevel <= thisLevel; cacheLevel++) {  	var cache = new Cell[30 << (2 * (cacheLevel - 1))' 3];  	var count = CountAtLevel (cacheLevel - 1);  	for (uint j = 0; j < cache.GetLength (0); j++) {  		for (byte k = 0; k < 3; k++) {  			var cell = new Cell (count + j);  			var dir = (ChildType)k;  			var thisDir = cell.direction;  			var first = cell.GetParent ();  			if (thisDir == dir) {  				cache [j' k] = first.GetFrontNeighbor (dir' cacheLevel - 1);  			}  			else if (thisDir == dir.Flip ()) {  				cache [j' k] = first.GetFrontNeighbor (ChildType.Straight' cacheLevel);  			}  			else {  				if (dir == ChildType.Straight) {  					dir = thisDir;  				}  				var other = first.GetFrontNeighbor (dir' cacheLevel - 1);  				if (other.isPolarSeam () && (first.getRoot () != other.getRoot ())) {  					cache [j' k] = first.GetFrontNeighbor (ChildType.Straight' cacheLevel - 1).GetFrontNeighbor (dir' cacheLevel);  				}  				else {  					cache [j' k] = other.GetFrontNeighbor (dir.Flip ()' cacheLevel);  				}  			}  		}  	}  	neighborCache.Add (cache);  }  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,GetFrontNeighbor,The following statement contains a magic number: for (var cacheLevel = neighborCache.Count + 1; cacheLevel <= thisLevel; cacheLevel++) {  	var cache = new Cell[30 << (2 * (cacheLevel - 1))' 3];  	var count = CountAtLevel (cacheLevel - 1);  	for (uint j = 0; j < cache.GetLength (0); j++) {  		for (byte k = 0; k < 3; k++) {  			var cell = new Cell (count + j);  			var dir = (ChildType)k;  			var thisDir = cell.direction;  			var first = cell.GetParent ();  			if (thisDir == dir) {  				cache [j' k] = first.GetFrontNeighbor (dir' cacheLevel - 1);  			}  			else if (thisDir == dir.Flip ()) {  				cache [j' k] = first.GetFrontNeighbor (ChildType.Straight' cacheLevel);  			}  			else {  				if (dir == ChildType.Straight) {  					dir = thisDir;  				}  				var other = first.GetFrontNeighbor (dir' cacheLevel - 1);  				if (other.isPolarSeam () && (first.getRoot () != other.getRoot ())) {  					cache [j' k] = first.GetFrontNeighbor (ChildType.Straight' cacheLevel - 1).GetFrontNeighbor (dir' cacheLevel);  				}  				else {  					cache [j' k] = other.GetFrontNeighbor (dir.Flip ()' cacheLevel);  				}  			}  		}  	}  	neighborCache.Add (cache);  }  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,GetFrontNeighbor,The following statement contains a magic number: for (var cacheLevel = neighborCache.Count + 1; cacheLevel <= thisLevel; cacheLevel++) {  	var cache = new Cell[30 << (2 * (cacheLevel - 1))' 3];  	var count = CountAtLevel (cacheLevel - 1);  	for (uint j = 0; j < cache.GetLength (0); j++) {  		for (byte k = 0; k < 3; k++) {  			var cell = new Cell (count + j);  			var dir = (ChildType)k;  			var thisDir = cell.direction;  			var first = cell.GetParent ();  			if (thisDir == dir) {  				cache [j' k] = first.GetFrontNeighbor (dir' cacheLevel - 1);  			}  			else if (thisDir == dir.Flip ()) {  				cache [j' k] = first.GetFrontNeighbor (ChildType.Straight' cacheLevel);  			}  			else {  				if (dir == ChildType.Straight) {  					dir = thisDir;  				}  				var other = first.GetFrontNeighbor (dir' cacheLevel - 1);  				if (other.isPolarSeam () && (first.getRoot () != other.getRoot ())) {  					cache [j' k] = first.GetFrontNeighbor (ChildType.Straight' cacheLevel - 1).GetFrontNeighbor (dir' cacheLevel);  				}  				else {  					cache [j' k] = other.GetFrontNeighbor (dir.Flip ()' cacheLevel);  				}  			}  		}  	}  	neighborCache.Add (cache);  }  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,GetFrontNeighbor,The following statement contains a magic number: for (uint j = 0; j < cache.GetLength (0); j++) {  	for (byte k = 0; k < 3; k++) {  		var cell = new Cell (count + j);  		var dir = (ChildType)k;  		var thisDir = cell.direction;  		var first = cell.GetParent ();  		if (thisDir == dir) {  			cache [j' k] = first.GetFrontNeighbor (dir' cacheLevel - 1);  		}  		else if (thisDir == dir.Flip ()) {  			cache [j' k] = first.GetFrontNeighbor (ChildType.Straight' cacheLevel);  		}  		else {  			if (dir == ChildType.Straight) {  				dir = thisDir;  			}  			var other = first.GetFrontNeighbor (dir' cacheLevel - 1);  			if (other.isPolarSeam () && (first.getRoot () != other.getRoot ())) {  				cache [j' k] = first.GetFrontNeighbor (ChildType.Straight' cacheLevel - 1).GetFrontNeighbor (dir' cacheLevel);  			}  			else {  				cache [j' k] = other.GetFrontNeighbor (dir.Flip ()' cacheLevel);  			}  		}  	}  }  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,GetFrontNeighbor,The following statement contains a magic number: for (byte k = 0; k < 3; k++) {  	var cell = new Cell (count + j);  	var dir = (ChildType)k;  	var thisDir = cell.direction;  	var first = cell.GetParent ();  	if (thisDir == dir) {  		cache [j' k] = first.GetFrontNeighbor (dir' cacheLevel - 1);  	}  	else if (thisDir == dir.Flip ()) {  		cache [j' k] = first.GetFrontNeighbor (ChildType.Straight' cacheLevel);  	}  	else {  		if (dir == ChildType.Straight) {  			dir = thisDir;  		}  		var other = first.GetFrontNeighbor (dir' cacheLevel - 1);  		if (other.isPolarSeam () && (first.getRoot () != other.getRoot ())) {  			cache [j' k] = first.GetFrontNeighbor (ChildType.Straight' cacheLevel - 1).GetFrontNeighbor (dir' cacheLevel);  		}  		else {  			cache [j' k] = other.GetFrontNeighbor (dir.Flip ()' cacheLevel);  		}  	}  }  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,getBackNeighbor,The following statement contains a magic number: if (thisLevel == 0) {  	if (isPolar) {  		throw new ArgumentException ("Cannot find neighbor of a polar cell");  	}  	if (direction == ChildType.Straight) {  		return new Cell (wrap (index - 2)).approach (ChildType.Straight' level);  	}  	else {  		var north = index % 2 == 0;  		var down = direction == ChildType.Down;  		if (north != down) {  			throw new InvalidOperationException ();  		}  		// TODO: Exception text   		return new Cell (wrap (index - 1)).approach (direction.Flip ()' level);  	}  }  else {  	var thisDir = this.direction;  	var first = this.GetParent ();  	if (level != thisLevel) {  		first = first.getChild (thisDir' thisLevel + 1).approach (thisDir' level - thisLevel - 1);  	}  	if (thisDir == direction.Flip ()) {  		return first;  	}  	else if (thisDir == ChildType.Straight) {  		return first.GetFrontNeighbor (direction' level);  	}  	else {  		first = this.GetParent ();  		var other = thisDir.Flip ();  		var seam = this.isPolarSeam ();  		var commonDir = thisDir;  		if (first.IsPentagon && ((thisDir == ChildType.Down) != (first.index % 2 == 0))) {  			commonDir = ChildType.Straight;  		}  		var common = first.getBackNeighbor (commonDir' thisLevel - 1);  		if ((direction == ChildType.Straight) == seam) {  			return common.GetFrontNeighbor (ChildType.Straight' thisLevel).approach (seam ? thisDir : other' level - thisLevel);  		}  		else {  			return common.GetFrontNeighbor (seam ? thisDir : other' thisLevel).approach (ChildType.Straight' level - thisLevel);  		}  	}  }  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,getBackNeighbor,The following statement contains a magic number: if (thisLevel == 0) {  	if (isPolar) {  		throw new ArgumentException ("Cannot find neighbor of a polar cell");  	}  	if (direction == ChildType.Straight) {  		return new Cell (wrap (index - 2)).approach (ChildType.Straight' level);  	}  	else {  		var north = index % 2 == 0;  		var down = direction == ChildType.Down;  		if (north != down) {  			throw new InvalidOperationException ();  		}  		// TODO: Exception text   		return new Cell (wrap (index - 1)).approach (direction.Flip ()' level);  	}  }  else {  	var thisDir = this.direction;  	var first = this.GetParent ();  	if (level != thisLevel) {  		first = first.getChild (thisDir' thisLevel + 1).approach (thisDir' level - thisLevel - 1);  	}  	if (thisDir == direction.Flip ()) {  		return first;  	}  	else if (thisDir == ChildType.Straight) {  		return first.GetFrontNeighbor (direction' level);  	}  	else {  		first = this.GetParent ();  		var other = thisDir.Flip ();  		var seam = this.isPolarSeam ();  		var commonDir = thisDir;  		if (first.IsPentagon && ((thisDir == ChildType.Down) != (first.index % 2 == 0))) {  			commonDir = ChildType.Straight;  		}  		var common = first.getBackNeighbor (commonDir' thisLevel - 1);  		if ((direction == ChildType.Straight) == seam) {  			return common.GetFrontNeighbor (ChildType.Straight' thisLevel).approach (seam ? thisDir : other' level - thisLevel);  		}  		else {  			return common.GetFrontNeighbor (seam ? thisDir : other' thisLevel).approach (ChildType.Straight' level - thisLevel);  		}  	}  }  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,getBackNeighbor,The following statement contains a magic number: if (thisLevel == 0) {  	if (isPolar) {  		throw new ArgumentException ("Cannot find neighbor of a polar cell");  	}  	if (direction == ChildType.Straight) {  		return new Cell (wrap (index - 2)).approach (ChildType.Straight' level);  	}  	else {  		var north = index % 2 == 0;  		var down = direction == ChildType.Down;  		if (north != down) {  			throw new InvalidOperationException ();  		}  		// TODO: Exception text   		return new Cell (wrap (index - 1)).approach (direction.Flip ()' level);  	}  }  else {  	var thisDir = this.direction;  	var first = this.GetParent ();  	if (level != thisLevel) {  		first = first.getChild (thisDir' thisLevel + 1).approach (thisDir' level - thisLevel - 1);  	}  	if (thisDir == direction.Flip ()) {  		return first;  	}  	else if (thisDir == ChildType.Straight) {  		return first.GetFrontNeighbor (direction' level);  	}  	else {  		first = this.GetParent ();  		var other = thisDir.Flip ();  		var seam = this.isPolarSeam ();  		var commonDir = thisDir;  		if (first.IsPentagon && ((thisDir == ChildType.Down) != (first.index % 2 == 0))) {  			commonDir = ChildType.Straight;  		}  		var common = first.getBackNeighbor (commonDir' thisLevel - 1);  		if ((direction == ChildType.Straight) == seam) {  			return common.GetFrontNeighbor (ChildType.Straight' thisLevel).approach (seam ? thisDir : other' level - thisLevel);  		}  		else {  			return common.GetFrontNeighbor (seam ? thisDir : other' thisLevel).approach (ChildType.Straight' level - thisLevel);  		}  	}  }  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,getBackNeighbor,The following statement contains a magic number: if (direction == ChildType.Straight) {  	return new Cell (wrap (index - 2)).approach (ChildType.Straight' level);  }  else {  	var north = index % 2 == 0;  	var down = direction == ChildType.Down;  	if (north != down) {  		throw new InvalidOperationException ();  	}  	// TODO: Exception text   	return new Cell (wrap (index - 1)).approach (direction.Flip ()' level);  }  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,getBackNeighbor,The following statement contains a magic number: if (direction == ChildType.Straight) {  	return new Cell (wrap (index - 2)).approach (ChildType.Straight' level);  }  else {  	var north = index % 2 == 0;  	var down = direction == ChildType.Down;  	if (north != down) {  		throw new InvalidOperationException ();  	}  	// TODO: Exception text   	return new Cell (wrap (index - 1)).approach (direction.Flip ()' level);  }  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,getBackNeighbor,The following statement contains a magic number: return new Cell (wrap (index - 2)).approach (ChildType.Straight' level);  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,getBackNeighbor,The following statement contains a magic number: if (thisDir == direction.Flip ()) {  	return first;  }  else if (thisDir == ChildType.Straight) {  	return first.GetFrontNeighbor (direction' level);  }  else {  	first = this.GetParent ();  	var other = thisDir.Flip ();  	var seam = this.isPolarSeam ();  	var commonDir = thisDir;  	if (first.IsPentagon && ((thisDir == ChildType.Down) != (first.index % 2 == 0))) {  		commonDir = ChildType.Straight;  	}  	var common = first.getBackNeighbor (commonDir' thisLevel - 1);  	if ((direction == ChildType.Straight) == seam) {  		return common.GetFrontNeighbor (ChildType.Straight' thisLevel).approach (seam ? thisDir : other' level - thisLevel);  	}  	else {  		return common.GetFrontNeighbor (seam ? thisDir : other' thisLevel).approach (ChildType.Straight' level - thisLevel);  	}  }  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,getBackNeighbor,The following statement contains a magic number: if (thisDir == ChildType.Straight) {  	return first.GetFrontNeighbor (direction' level);  }  else {  	first = this.GetParent ();  	var other = thisDir.Flip ();  	var seam = this.isPolarSeam ();  	var commonDir = thisDir;  	if (first.IsPentagon && ((thisDir == ChildType.Down) != (first.index % 2 == 0))) {  		commonDir = ChildType.Straight;  	}  	var common = first.getBackNeighbor (commonDir' thisLevel - 1);  	if ((direction == ChildType.Straight) == seam) {  		return common.GetFrontNeighbor (ChildType.Straight' thisLevel).approach (seam ? thisDir : other' level - thisLevel);  	}  	else {  		return common.GetFrontNeighbor (seam ? thisDir : other' thisLevel).approach (ChildType.Straight' level - thisLevel);  	}  }  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,getBackNeighbor,The following statement contains a magic number: if (first.IsPentagon && ((thisDir == ChildType.Down) != (first.index % 2 == 0))) {  	commonDir = ChildType.Straight;  }  
Magic Number,GeodesicGrid,Cell,C:\repos\Majiir_GeodesicGrid\Cell.cs,GetHashCode,The following statement contains a magic number: return unchecked((int)index * 31);  
Magic Number,GeodesicGrid,IntMath,C:\repos\Majiir_GeodesicGrid\IntMath.cs,LogBase2,The following statement contains a magic number: v |= v >> 2;  
Magic Number,GeodesicGrid,IntMath,C:\repos\Majiir_GeodesicGrid\IntMath.cs,LogBase2,The following statement contains a magic number: v |= v >> 4;  
Magic Number,GeodesicGrid,IntMath,C:\repos\Majiir_GeodesicGrid\IntMath.cs,LogBase2,The following statement contains a magic number: v |= v >> 8;  
Magic Number,GeodesicGrid,IntMath,C:\repos\Majiir_GeodesicGrid\IntMath.cs,LogBase2,The following statement contains a magic number: v |= v >> 16;  
Magic Number,GeodesicGrid,IntMath,C:\repos\Majiir_GeodesicGrid\IntMath.cs,LogBase2,The following statement contains a magic number: return MultiplyDeBruijnBitPosition [(v * 0x7C4ACDDU) >> 27];  
Magic Number,GeodesicGrid,Triangle,C:\repos\Majiir_GeodesicGrid\Triangle.cs,Triangle,The following statement contains a magic number: if (cell.Index < 2) {  	throw new ArgumentException ("Cannot root a triangle at a polar cell");  }  
Magic Number,GeodesicGrid,Triangle,C:\repos\Majiir_GeodesicGrid\Triangle.cs,Triangle,The following statement contains a magic number: this.index = (cell.Index - 2) * 2 + (uint)direction;  
Magic Number,GeodesicGrid,Triangle,C:\repos\Majiir_GeodesicGrid\Triangle.cs,Triangle,The following statement contains a magic number: this.index = (cell.Index - 2) * 2 + (uint)direction;  
Magic Number,GeodesicGrid,Triangle,C:\repos\Majiir_GeodesicGrid\Triangle.cs,getRoot,The following statement contains a magic number: return new Cell (2 + this.index / 2);  
Magic Number,GeodesicGrid,Triangle,C:\repos\Majiir_GeodesicGrid\Triangle.cs,getRoot,The following statement contains a magic number: return new Cell (2 + this.index / 2);  
Magic Number,GeodesicGrid,Triangle,C:\repos\Majiir_GeodesicGrid\Triangle.cs,getDirection,The following statement contains a magic number: return (FaceDirection)(this.index % 2);  
Magic Number,GeodesicGrid,Triangle,C:\repos\Majiir_GeodesicGrid\Triangle.cs,CountAtLevel,The following statement contains a magic number: return (Cell.CountAtLevel (level) - 2) * 2;  
Magic Number,GeodesicGrid,Triangle,C:\repos\Majiir_GeodesicGrid\Triangle.cs,CountAtLevel,The following statement contains a magic number: return (Cell.CountAtLevel (level) - 2) * 2;  
