Implementation smell,Namespace,Class,File,Method,Description
Long Method,ILRepacking,RepackImporter,F:\newReposMay17\gluck_il-repack\ILRepack\RepackImporter.cs,CloneTo,The method has 128 lines of code.
Complex Method,ILRepacking,DocumentationMerger,F:\newReposMay17\gluck_il-repack\ILRepack\DocumentationMerger.cs,Process,Cyclomatic complexity of the method is 8
Complex Method,ILRepacking,IKVMLineIndexer,F:\newReposMay17\gluck_il-repack\ILRepack\IKVMLineIndexer.cs,ProcessMethodBodyInstruction,Cyclomatic complexity of the method is 8
Complex Method,ILRepacking,ILRepack,F:\newReposMay17\gluck_il-repack\ILRepack\ILRepack.cs,ParseTargetPlatform,Cyclomatic complexity of the method is 9
Complex Method,ILRepacking,ILRepack,F:\newReposMay17\gluck_il-repack\ILRepack\ILRepack.cs,Repack,Cyclomatic complexity of the method is 19
Complex Method,ILRepacking,PlatformFixer,F:\newReposMay17\gluck_il-repack\ILRepack\PlatformFixer.cs,FixPlatformVersion,Cyclomatic complexity of the method is 16
Complex Method,ILRepacking,PlatformFixer,F:\newReposMay17\gluck_il-repack\ILRepack\PlatformFixer.cs,FixPlatformVersion,Cyclomatic complexity of the method is 8
Complex Method,ILRepacking,PlatformFixer,F:\newReposMay17\gluck_il-repack\ILRepack\PlatformFixer.cs,FixPlatformVersion,Cyclomatic complexity of the method is 10
Complex Method,ILRepacking,PlatformFixer,F:\newReposMay17\gluck_il-repack\ILRepack\PlatformFixer.cs,FixPlatformVersion,Cyclomatic complexity of the method is 10
Complex Method,ILRepacking,ReferenceFixator,F:\newReposMay17\gluck_il-repack\ILRepack\ReferenceFixator.cs,FixReferences,Cyclomatic complexity of the method is 11
Complex Method,ILRepacking,ReferenceFixator,F:\newReposMay17\gluck_il-repack\ILRepack\ReferenceFixator.cs,FixReferences,Cyclomatic complexity of the method is 16
Complex Method,ILRepacking,ReferenceFixator,F:\newReposMay17\gluck_il-repack\ILRepack\ReferenceFixator.cs,Fix,Cyclomatic complexity of the method is 11
Complex Method,ILRepacking,RepackImporter,F:\newReposMay17\gluck_il-repack\ILRepack\RepackImporter.cs,Import,Cyclomatic complexity of the method is 15
Complex Method,ILRepacking,RepackImporter,F:\newReposMay17\gluck_il-repack\ILRepack\RepackImporter.cs,CloneTo,Cyclomatic complexity of the method is 8
Complex Method,ILRepacking,RepackImporter,F:\newReposMay17\gluck_il-repack\ILRepack\RepackImporter.cs,CloneTo,Cyclomatic complexity of the method is 10
Complex Method,ILRepacking,RepackImporter,F:\newReposMay17\gluck_il-repack\ILRepack\RepackImporter.cs,CloneTo,Cyclomatic complexity of the method is 12
Complex Method,ILRepacking,RepackImporter,F:\newReposMay17\gluck_il-repack\ILRepack\RepackImporter.cs,CloneTo,Cyclomatic complexity of the method is 22
Complex Method,ILRepacking,RepackImporter,F:\newReposMay17\gluck_il-repack\ILRepack\RepackImporter.cs,CopySecurityDeclarations,Cyclomatic complexity of the method is 9
Complex Method,ILRepacking,RepackOptions,F:\newReposMay17\gluck_il-repack\ILRepack\RepackOptions.cs,Parse,Cyclomatic complexity of the method is 22
Complex Method,ILRepacking,ResReader,F:\newReposMay17\gluck_il-repack\ILRepack\ResReader.cs,ResReader,Cyclomatic complexity of the method is 13
Complex Method,ILRepacking,SerReader,F:\newReposMay17\gluck_il-repack\ILRepack\SerReader.cs,ParseRecord,Cyclomatic complexity of the method is 64
Complex Method,ILRepacking,TypeHelper,F:\newReposMay17\gluck_il-repack\ILRepack\SerReader.cs,GetTypeAdditionalInfo,Cyclomatic complexity of the method is 24
Complex Method,ILRepacking,TypeHelper,F:\newReposMay17\gluck_il-repack\ILRepack\SerReader.cs,GetTypeValue,Cyclomatic complexity of the method is 24
Complex Method,ILRepacking.Steps,ResourcesRepackStep,F:\newReposMay17\gluck_il-repack\ILRepack\Steps\ResourcesRepackStep.cs,Perform,Cyclomatic complexity of the method is 20
Complex Method,ILRepacking.Steps,TypesRepackStep,F:\newReposMay17\gluck_il-repack\ILRepack\Steps\TypesRepackStep.cs,RepackExportedTypes,Cyclomatic complexity of the method is 8
Complex Method,ILRepacking.Steps.SourceServerData,HttpSourceServerDescriptor,F:\newReposMay17\gluck_il-repack\ILRepack\Steps\SourceServerData\HttpSourceServerDescriptor.cs,TryParse,Cyclomatic complexity of the method is 12
Long Parameter List,ILRepacking,Res,F:\newReposMay17\gluck_il-repack\ILRepack\ResReader.cs,Res,The method has 5 parameters.
Long Identifier,ILRepacking.Steps,ResourcesRepackStep,F:\newReposMay17\gluck_il-repack\ILRepack\Steps\ResourcesRepackStep.cs,Perform,The length of the parameter shouldWriteCollectedBamlStreams is 31.
Long Statement,ILRepacking,Application,F:\newReposMay17\gluck_il-repack\ILRepack\Application.cs,Usage,The length of the statement  "	Console.WriteLine (@" - /copyattrs         copy assembly attributes (by default only the primary assembly attributes are copied)"); " is 131.
Long Statement,ILRepacking,Application,F:\newReposMay17\gluck_il-repack\ILRepack\Application.cs,Usage,The length of the statement  "	Console.WriteLine (@" - /target:kind       specify target assembly kind (library' exe' winexe supported' default is same as first assembly)"); " is 142.
Long Statement,ILRepacking,Application,F:\newReposMay17\gluck_il-repack\ILRepack\Application.cs,Usage,The length of the statement  "	Console.WriteLine (@" - /lib:<path>        adds the path to the search directories for referenced assemblies (can be specified multiple times)"); " is 145.
Long Statement,ILRepacking,Application,F:\newReposMay17\gluck_il-repack\ILRepack\Application.cs,Usage,The length of the statement  "	Console.WriteLine (@" - /allowduplicateresources allows to duplicate resources in output assembly (by default they're ignored)"); " is 129.
Long Statement,ILRepacking,Application,F:\newReposMay17\gluck_il-repack\ILRepack\Application.cs,Usage,The length of the statement  "	Console.WriteLine (@" - /zeropekind        allows assemblies with Zero PeKind (but obviously only IL will get merged)"); " is 120.
Long Statement,ILRepacking,Application,F:\newReposMay17\gluck_il-repack\ILRepack\Application.cs,Usage,The length of the statement  "	Console.WriteLine (@" - /index             stores file:line debug information as type/method attributes (requires PDB)"); " is 121.
Long Statement,ILRepacking,Application,F:\newReposMay17\gluck_il-repack\ILRepack\Application.cs,Usage,The length of the statement  "	Console.WriteLine (@" - /out:<path>        target assembly path' symbol/config/doc files will be written here as well"); " is 120.
Long Statement,ILRepacking,Application,F:\newReposMay17\gluck_il-repack\ILRepack\Application.cs,Usage,The length of the statement  "	Console.WriteLine (@"Note: for compatibility purposes' all Options are case insensitive' and can be specified using '/'' '-' or '--' prefix."); " is 143.
Long Statement,ILRepacking,CommandLine,F:\newReposMay17\gluck_il-repack\ILRepack\CommandLine.cs,Modifier,The length of the statement  "	return parameters.RemoveAll (x => StringComparer.InvariantCultureIgnoreCase.Equals (x' "/" + modifier) || StringComparer.InvariantCultureIgnoreCase.Equals (x' "-" + modifier) || StringComparer.InvariantCultureIgnoreCase.Equals (x' "--" + modifier)) > 0; " is 253.
Long Statement,ILRepacking,CommandLine,F:\newReposMay17\gluck_il-repack\ILRepack\CommandLine.cs,HasOption,The length of the statement  "	return parameters.Any (x => x.ToLower ().StartsWith ("/" + name) || x.ToLower ().StartsWith ("-" + name) || x.ToLower ().StartsWith ("--" + name)); " is 147.
Long Statement,ILRepacking,DocumentationMerger,F:\newReposMay17\gluck_il-repack\ILRepack\DocumentationMerger.cs,Process,The length of the statement  "		using (var writer = XmlWriter.Create (Path.ChangeExtension (repack.Options.OutputFile' ".xml")' new XmlWriterSettings () { " is 122.
Long Statement,ILRepacking,IKVMLineIndexer,F:\newReposMay17\gluck_il-repack\ILRepack\IKVMLineIndexer.cs,PostMethodBodyRepack,The length of the statement  "					new CustomAttributeArgument (new ArrayType (TargetAssemblyMainModule.TypeSystem.Byte)' lineNumberWriter.ToArray ().Select (b => new CustomAttributeArgument (TargetAssemblyMainModule.TypeSystem.Byte' b)).ToArray ()) " is 214.
Long Statement,ILRepacking,IKVMLineIndexer,F:\newReposMay17\gluck_il-repack\ILRepack\IKVMLineIndexer.cs,PostRepackReferences,The length of the statement  "	IMetadataScope ikvmRuntimeReference = repack.TargetAssemblyMainModule.AssemblyReferences.FirstOrDefault (r => r.Name == "IKVM.Runtime"); " is 136.
Long Statement,ILRepacking,IKVMLineIndexer,F:\newReposMay17\gluck_il-repack\ILRepack\IKVMLineIndexer.cs,PostRepackReferences,The length of the statement  "		sourceFileAttributeTypeReference = new TypeReference ("IKVM.Attributes"' "SourceFileAttribute"' TargetAssemblyMainModule' ikvmRuntimeReference); " is 144.
Long Statement,ILRepacking,IKVMLineIndexer,F:\newReposMay17\gluck_il-repack\ILRepack\IKVMLineIndexer.cs,PostRepackReferences,The length of the statement  "		sourceFileAttributeConstructor = new MethodReference (".ctor"' TargetAssemblyMainModule.TypeSystem.Void' sourceFileAttributeTypeReference) { " is 140.
Long Statement,ILRepacking,IKVMLineIndexer,F:\newReposMay17\gluck_il-repack\ILRepack\IKVMLineIndexer.cs,PostRepackReferences,The length of the statement  "		lineNumberTableAttributeTypeReference = new TypeReference ("IKVM.Attributes"' "LineNumberTableAttribute"' TargetAssemblyMainModule' ikvmRuntimeReference); " is 154.
Long Statement,ILRepacking,IKVMLineIndexer,F:\newReposMay17\gluck_il-repack\ILRepack\IKVMLineIndexer.cs,PostRepackReferences,The length of the statement  "		lineNumberTableAttributeConstructor1 = new MethodReference (".ctor"' TargetAssemblyMainModule.TypeSystem.Void' lineNumberTableAttributeTypeReference) { " is 151.
Long Statement,ILRepacking,IKVMLineIndexer,F:\newReposMay17\gluck_il-repack\ILRepack\IKVMLineIndexer.cs,PostRepackReferences,The length of the statement  "		lineNumberTableAttributeConstructor2 = new MethodReference (".ctor"' TargetAssemblyMainModule.TypeSystem.Void' lineNumberTableAttributeTypeReference) { " is 151.
Long Statement,ILRepacking,MappingHandler,F:\newReposMay17\gluck_il-repack\ILRepack\MappingHandler.cs,GetExportedRemappedType,The length of the statement  "		// It should match the actual type (e.g.' Boolean for System.Boolean). But because of forwarded types' this is not known at read time' thus having to fix it here. " is 162.
Long Statement,ILRepacking,ILRepack,F:\newReposMay17\gluck_il-repack\ILRepack\ILRepack.cs,ReadInputAssembly,The length of the statement  "			throw new InvalidOperationException ("ILRepack does not support merging non-.NET libraries (e.g.: native libraries)"' e); " is 121.
Long Statement,ILRepacking,ILRepack,F:\newReposMay17\gluck_il-repack\ILRepack\ILRepack.cs,ReadInputAssembly,The length of the statement  "				throw new InvalidOperationException ("ILRepack does not support merging non-.NET libraries (e.g.: native libraries)"' e); " is 121.
Long Statement,ILRepacking,ILRepack,F:\newReposMay17\gluck_il-repack\ILRepack\ILRepack.cs,ResolveTargetPlatformDirectory,The length of the statement  "	var targetPlatformDirectory = platformDirectories.FirstOrDefault (x => Path.GetFileName (x).StartsWith (platformDir) || Path.GetFileName (x).StartsWith ()); " is 156.
Long Statement,ILRepacking,ILRepack,F:\newReposMay17\gluck_il-repack\ILRepack\ILRepack.cs,GetRepackAssemblyNames,The length of the statement  "		using (Stream stream = typeInRepackedAssembly.Assembly.GetManifestResourceStream (ResourcesRepackStep.ILRepackListResourceName)) " is 128.
Long Statement,ILRepacking,ILRepack,F:\newReposMay17\gluck_il-repack\ILRepack\ILRepack.cs,GetRepackAssemblyName,The length of the statement  "	return repackAssemblyNames.FirstOrDefault (name => name.Name == repackedAssemblyName) ?? fallbackType.Assembly.GetName (); " is 122.
Long Statement,ILRepacking,ILRepack,F:\newReposMay17\gluck_il-repack\ILRepack\ILRepack.cs,Repack,The length of the statement  "	TargetAssemblyMainModule.Win32ResourceDirectory = MergeWin32Resources (PrimaryAssemblyMainModule.Win32ResourceDirectory); " is 121.
Long Statement,ILRepacking,ILRepack,F:\newReposMay17\gluck_il-repack\ILRepack\ILRepack.cs,Repack,The length of the statement  "	var isUnixEnvironment = Environment.OSVersion.Platform == PlatformID.MacOSX || Environment.OSVersion.Platform == PlatformID.Unix; " is 129.
Long Statement,ILRepacking,ILRepack,F:\newReposMay17\gluck_il-repack\ILRepack\ILRepack.cs,ResolveSearchDirectories,The length of the statement  "	var targetPlatformDirectory = Options.TargetPlatformDirectory ?? ResolveTargetPlatformDirectory (Options.TargetPlatformVersion); " is 128.
Long Statement,ILRepacking,ILRepack,F:\newReposMay17\gluck_il-repack\ILRepack\ILRepack.cs,MergeEntry,The length of the statement  "			Logger.Warn (string.Format ("Duplicate Win32 resource with id={0}' parents=[{1}]' name={2} in assembly {3}' ignoring"' entry.Id' string.Join ("'"' parents.Select (p => p.Name ?? p.Id.ToString ()).ToArray ())' entry.Name' ass.Name)); " is 232.
Long Statement,ILRepacking,ILRepack,F:\newReposMay17\gluck_il-repack\ILRepack\ILRepack.cs,FixStr,The length of the statement  "	if (String.IsNullOrEmpty (content) || content.Length > 512 || content.IndexOf ("' ") == -1 || content.StartsWith ("System.")) " is 125.
Long Statement,ILRepacking,PermissionsetHelper,F:\newReposMay17\gluck_il-repack\ILRepack\PermissionsetHelper.cs,GetTypeRef,The length of the statement  "	TypeReference typeRef = targetModule.ImportReference (new TypeReference (nameSpace' name' targetModule' targetModule.AssemblyReferences.First (x => x.Name == assemblyName))); " is 174.
Long Statement,ILRepacking,PermissionsetHelper,F:\newReposMay17\gluck_il-repack\ILRepack\PermissionsetHelper.cs,Permission2XmlSet,The length of the statement  "	SecurityAttribute attribute = new SecurityAttribute (GetTypeRef ("System.Security.Permissions"' "PermissionSetAttribute"' "mscorlib"' targetModule)); " is 149.
Long Statement,ILRepacking,PermissionsetHelper,F:\newReposMay17\gluck_il-repack\ILRepack\PermissionsetHelper.cs,Permission2XmlSet,The length of the statement  "	attribute.Properties.Add (new CustomAttributeNamedArgument ("XML"' new CustomAttributeArgument (targetModule.TypeSystem.String' xmlDoc.InnerXml))); " is 147.
Long Statement,ILRepacking,PermissionsetHelper,F:\newReposMay17\gluck_il-repack\ILRepack\PermissionsetHelper.cs,Xml2PermissionSet,The length of the statement  "	SecurityAttribute attribute = new SecurityAttribute (GetTypeRef (string.Join ("."' classNamespace.ToArray ())' className' assemblyName' targetModule)); " is 151.
Long Statement,ILRepacking,PermissionsetHelper,F:\newReposMay17\gluck_il-repack\ILRepack\PermissionsetHelper.cs,Xml2PermissionSet,The length of the statement  "			attribute.Properties.Add (new CustomAttributeNamedArgument (xmlAttr.Name' new CustomAttributeArgument (targetModule.TypeSystem.String' xmlAttr.Value))); " is 152.
Long Statement,ILRepacking,ReferenceFixator,F:\newReposMay17\gluck_il-repack\ILRepack\ReferenceFixator.cs,Fix,The length of the statement  "	ModuleReference nmr = _repackContext.TargetAssemblyMainModule.ModuleReferences.FirstOrDefault (x => x.Name == moduleRef.Name); " is 126.
Long Statement,ILRepacking,ReferenceFixator,F:\newReposMay17\gluck_il-repack\ILRepack\ReferenceFixator.cs,FixMethodVisibility,The length of the statement  "	// this causes peverify issues with IKVM assemblies where java is more flexible such as: (A and B are classes' C interface' B extends A' C) " is 139.
Long Statement,ILRepacking,ReferenceFixator,F:\newReposMay17\gluck_il-repack\ILRepack\ReferenceFixator.cs,FixReferences,The length of the statement  "								CustomAttributeNamedArgument newProp = new CustomAttributeNamedArgument (prop.Name' new CustomAttributeArgument (prop.Argument.Type' targetAssemblyPublicKeyBlobString)); " is 169.
Long Statement,ILRepacking,ReferenceFixator,F:\newReposMay17\gluck_il-repack\ILRepack\ReferenceFixator.cs,FixReferences,The length of the statement  "		if ((_repackContext.TargetAssemblyMainModule.Runtime == TargetRuntime.Net_1_0) || (_repackContext.TargetAssemblyMainModule.Runtime == TargetRuntime.Net_1_1)) { " is 159.
Long Statement,ILRepacking,ReferenceFixator,F:\newReposMay17\gluck_il-repack\ILRepack\ReferenceFixator.cs,Fix,The length of the statement  "		MethodDefinition def = new ReflectionHelper (_repackContext).FindMethodDefinitionInType ((TypeDefinition)declaringType' method); " is 128.
Long Statement,ILRepacking,ReferenceFixator,F:\newReposMay17\gluck_il-repack\ILRepack\ReferenceFixator.cs,Fix,The length of the statement  "	if (!method.IsDefinition && !method.DeclaringType.IsGenericInstance && !method.DeclaringType.IsArray && (method.ReturnType.IsDefinition || method.Parameters.Any (x => x.ParameterType.IsDefinition))) { " is 200.
Long Statement,ILRepacking,ReferenceFixator,F:\newReposMay17\gluck_il-repack\ILRepack\ReferenceFixator.cs,Fix,The length of the statement  "		var culprit = method.ReturnType.IsDefinition ? method.ReturnType : method.Parameters.First (x => x.ParameterType.IsDefinition).ParameterType; " is 141.
Long Statement,ILRepacking,ReferenceFixator,F:\newReposMay17\gluck_il-repack\ILRepack\ReferenceFixator.cs,Fix,The length of the statement  "		_logger.Warn ("Method reference is used with definition return type / parameter. Indicates a likely invalid set of assemblies' consider one of the following"); " is 159.
Long Statement,ILRepacking,ReflectionHelper,F:\newReposMay17\gluck_il-repack\ILRepack\ReflectionHelper.cs,FindMethodDefinitionInType,The length of the statement  "	return type.Methods.FirstOrDefault (x => x.Name == method.Name && AreSame (x.Parameters' method.Parameters) && AreSame (x.ReturnType' method.ReturnType) && x.GenericParameters.Count == method.GenericParameters.Count); " is 217.
Long Statement,ILRepacking,RepackImporter,F:\newReposMay17\gluck_il-repack\ILRepack\RepackImporter.cs,Import,The length of the statement  "		if (_repackContext.MergedAssemblies.SelectMany (x => x.Modules).Any (x => x.Name == ((ModuleReference)type.Scope).Name)) { " is 122.
Long Statement,ILRepacking,RepackImporter,F:\newReposMay17\gluck_il-repack\ILRepack\RepackImporter.cs,Import,The length of the statement  "		throw new InvalidOperationException ("Duplicate type " + type + " from " + type.Scope + "' was also present in " + MappingHandler.GetScopeFullName (_repackContext.MappingHandler.GetOrigTypeScope<IMetadataScope> (nt))); " is 218.
Long Statement,ILRepacking,RepackImporter,F:\newReposMay17\gluck_il-repack\ILRepack\RepackImporter.cs,CloneTo,The length of the statement  "	if (!typeJustCreated && type.Methods.Count > 0 && type.Methods.Any (x => (x.Name == meth.Name) && (x.Parameters.Count == meth.Parameters.Count) && (x.ToString () == meth.ToString ())))// TODO: better/faster comparation of parameter types? " is 238.
Long Statement,ILRepacking,RepackImporter,F:\newReposMay17\gluck_il-repack\ILRepack\RepackImporter.cs,CloneTo,The length of the statement  "	MethodDefinition nm = new MethodDefinition (meth.Name' meth.Attributes' _repackContext.TargetAssemblyMainModule.TypeSystem.Void); " is 129.
Long Statement,ILRepacking,RepackImporter,F:\newReposMay17\gluck_il-repack\ILRepack\RepackImporter.cs,FixAspNetOffset,The length of the statement  "		if (fullName == "System.Void System.Web.UI.TemplateControl::WriteUTF8ResourceString(System.Web.UI.HtmlTextWriter'System.Int32'System.Int32'System.Boolean)" || fullName == "System.Web.UI.LiteralControl System.Web.UI.TemplateControl::CreateResourceBasedLiteralControl(System.Int32'System.Int32'System.Boolean)") { " is 311.
Long Statement,ILRepacking,RepackImporter,F:\newReposMay17\gluck_il-repack\ILRepack\RepackImporter.cs,DuplicateTypeAllowed,The length of the statement  "	// XAML helper class' identical in all assemblies' unused within the assembly' and instanciated through reflection from the outside " is 131.
Long Statement,ILRepacking,RepackImporter,F:\newReposMay17\gluck_il-repack\ILRepack\RepackImporter.cs,DuplicateTypeAllowed,The length of the statement  "	if (!String.IsNullOrEmpty (nameSpace) && _options.AllowedDuplicateNameSpaces.Any (s => s == nameSpace || nameSpace.StartsWith (s + "."))) " is 137.
Long Statement,ILRepacking,RepackImporter,F:\newReposMay17\gluck_il-repack\ILRepack\RepackImporter.cs,CopyCustomAttributes,The length of the statement  "			if (similarAttributes.Any (x => reflectionHelper.AreSame (x.ConstructorArguments' ca.ConstructorArguments) && reflectionHelper.AreSame (x.Fields' ca.Fields) && reflectionHelper.AreSame (x.Properties' ca.Properties))) " is 216.
Long Statement,ILRepacking,RepackImporter,F:\newReposMay17\gluck_il-repack\ILRepack\RepackImporter.cs,CustomAttributeTypeAllowsMultiple,The length of the statement  "	if (type.FullName == "IKVM.Attributes.JavaModuleAttribute" || type.FullName == "IKVM.Attributes.PackageListAttribute") { " is 120.
Long Statement,ILRepacking,RepackImporter,F:\newReposMay17\gluck_il-repack\ILRepack\RepackImporter.cs,CustomAttributeTypeAllowsMultiple,The length of the statement  "		// IKVM module attributes' although they don't allow multiple' IKVM supports the attribute being specified multiple times " is 121.
Long Statement,ILRepacking,ResReader,F:\newReposMay17\gluck_il-repack\ILRepack\ResReader.cs,GetResources,The length of the statement  "			dataPositionsAndNames [i] = new KeyValuePair<int' string> (_store.ReadInt32 ()' Encoding.Unicode.GetString (bytes' 0' byteLen)); " is 128.
Long Statement,ILRepacking,ResReader,F:\newReposMay17\gluck_il-repack\ILRepack\ResReader.cs,GetResources,The length of the statement  "			long nextData = (i < _numResources - 1) ? dataPositionsAndNames [i + 1].Key + _dataSectionOffset : _store.BaseStream.Length; " is 124.
Long Statement,ILRepacking,SerReader,F:\newReposMay17\gluck_il-repack\ILRepack\SerReader.cs,ParseRecord,The length of the statement  "			// -> this will overwrite the original values in the referenced object' but who cares - the values are trash anyway (for now). " is 126.
Long Statement,ILRepacking,SerReader,F:\newReposMay17\gluck_il-repack\ILRepack\SerReader.cs,ParseRecord,The length of the statement  "			si = new BinaryArray (BinaryTypeEnumeration.Primitive).ReadObjectId (this).ReadLengths (this).ReadPrimitiveType (this).ReadValues (this); " is 137.
Long Statement,ILRepacking,SerReader,F:\newReposMay17\gluck_il-repack\ILRepack\SerReader.cs,ParseRecord,The length of the statement  "			throw new Exception ("Parsing appears to have failed dramatically. Unknown record type' we must be lost in the bytestream!"); " is 125.
Long Statement,ILRepacking,BinaryArray,F:\newReposMay17\gluck_il-repack\ILRepack\SerReader.cs,ReadStruct,The length of the statement  "	if (arrayType == BinaryArrayTypeEnumeration.SingleOffset || arrayType == BinaryArrayTypeEnumeration.JaggedOffset || arrayType == BinaryArrayTypeEnumeration.RectangularOffset) { " is 176.
Long Statement,ILRepacking.Steps,AttributesRepackStep,F:\newReposMay17\gluck_il-repack\ILRepack\Steps\AttributesRepackStep.cs,Perform,The length of the statement  "			_repackCopier.CopyCustomAttributes (ass.CustomAttributes' targetAssemblyDefinition.CustomAttributes' _options.AllowMultipleAssemblyLevelAttributes' null); " is 154.
Long Statement,ILRepacking.Steps,AttributesRepackStep,F:\newReposMay17\gluck_il-repack\ILRepack\Steps\AttributesRepackStep.cs,Perform,The length of the statement  "			_repackCopier.CopyCustomAttributes (mod.CustomAttributes' targetAssemblyMainModule.CustomAttributes' _options.AllowMultipleAssemblyLevelAttributes' null); " is 154.
Long Statement,ILRepacking.Steps,AttributesRepackStep,F:\newReposMay17\gluck_il-repack\ILRepack\Steps\AttributesRepackStep.cs,Perform,The length of the statement  "		AssemblyDefinition attributeAsm = AssemblyDefinition.ReadAssembly (_options.AttributeFile' new ReaderParameters (ReadingMode.Immediate) { " is 137.
Long Statement,ILRepacking.Steps,AttributesRepackStep,F:\newReposMay17\gluck_il-repack\ILRepack\Steps\AttributesRepackStep.cs,Perform,The length of the statement  "		_repackCopier.CopyCustomAttributes (_repackContext.PrimaryAssemblyDefinition.CustomAttributes' targetAssemblyDefinition.CustomAttributes' null); " is 144.
Long Statement,ILRepacking.Steps,AttributesRepackStep,F:\newReposMay17\gluck_il-repack\ILRepack\Steps\AttributesRepackStep.cs,Perform,The length of the statement  "		_repackCopier.CopyCustomAttributes (_repackContext.PrimaryAssemblyMainModule.CustomAttributes' targetAssemblyMainModule.CustomAttributes' null); " is 144.
Long Statement,ILRepacking.Steps,AttributesRepackStep,F:\newReposMay17\gluck_il-repack\ILRepack\Steps\AttributesRepackStep.cs,Perform,The length of the statement  "	_repackCopier.CopySecurityDeclarations (_repackContext.PrimaryAssemblyDefinition.SecurityDeclarations' targetAssemblyDefinition.SecurityDeclarations' null); " is 156.
Long Statement,ILRepacking.Steps,AttributesRepackStep,F:\newReposMay17\gluck_il-repack\ILRepack\Steps\AttributesRepackStep.cs,CleanupAttributes,The length of the statement  "	CleanupAttributes (typeof(CompilationRelaxationsAttribute).FullName' x => x.ConstructorArguments.Count == 1/* TODO && x.ConstructorArguments[0].Value.Equals(1) */); " is 164.
Long Statement,ILRepacking.Steps,AttributesRepackStep,F:\newReposMay17\gluck_il-repack\ILRepack\Steps\AttributesRepackStep.cs,RemoveAttributes,The length of the statement  "		var targetIsSigned = (_repackContext.TargetAssemblyMainModule.Attributes & ModuleAttributes.StrongNameSigned) == ModuleAttributes.StrongNameSigned; " is 147.
Long Statement,ILRepacking.Steps,AttributesRepackStep,F:\newReposMay17\gluck_il-repack\ILRepack\Steps\AttributesRepackStep.cs,RemoveAttributes,The length of the statement  "		bool isSigned = name.IndexOf ("' PublicKey="' StringComparison.Ordinal) != -1 && name.IndexOf ("' PublicKey=null"' StringComparison.Ordinal) == -1; " is 147.
Long Statement,ILRepacking.Steps,AttributesRepackStep,F:\newReposMay17\gluck_il-repack\ILRepack\Steps\AttributesRepackStep.cs,CleanupAttributes,The length of the statement  "	if (!_repackContext.MergedAssemblies.All (ass => ass.CustomAttributes.Any (attr => attr.AttributeType.FullName == type && extra (attr)))) { " is 139.
Long Statement,ILRepacking.Steps,ReferencesFixStep,F:\newReposMay17\gluck_il-repack\ILRepack\Steps\ReferencesFixStep.cs,Perform,The length of the statement  "		_repackContext.TargetAssemblyMainModule.EntryPoint = fixator.Fix (_repackImporter.Import (_repackContext.PrimaryAssemblyDefinition.EntryPoint)).Resolve (); " is 155.
Long Statement,ILRepacking.Steps,ReferencesFixStep,F:\newReposMay17\gluck_il-repack\ILRepack\Steps\ReferencesFixStep.cs,Perform,The length of the statement  "			// in case we reference same assemblies with different versions' there might be prior errors if we don't merge the 'largest one' " is 128.
Long Statement,ILRepacking.Steps,ResourcesRepackStep,F:\newReposMay17\gluck_il-repack\ILRepack\Steps\ResourcesRepackStep.cs,Perform,The length of the statement  "						_logger.Warn ("AssemblyLinkedResource reference may need to be fixed (to link to newly created assembly)" + resource.Name); " is 123.
Long Statement,ILRepacking.Steps,ResourcesRepackStep,F:\newReposMay17\gluck_il-repack\ILRepack\Steps\ResourcesRepackStep.cs,Perform,The length of the statement  "							newResource = FixResxResource (assembly' er' assemblyProcessors' shouldWriteCollectedBamlStreams ? bamlStreamCollector : null); " is 127.
Long Statement,ILRepacking.Steps,TypesRepackStep,F:\newReposMay17\gluck_il-repack\ILRepack\Steps\TypesRepackStep.cs,CreateReference,The length of the statement  "	return new TypeReference (type.Namespace' type.Name' _repackContext.TargetAssemblyMainModule' _repackContext.MergeScope (type.Scope)) { " is 135.
Long Statement,ILRepacking.Steps,XamlResourcePathPatcherStep,F:\newReposMay17\gluck_il-repack\ILRepack\Steps\XamlResourcePathPatcherStep.cs,PatchWpfToolkitEndInitMethod,The length of the statement  "		stringInstruction.Operand = string.Format ("/{0};component/Xceed.Wpf.Toolkit/{{2}}"' _repackContext.PrimaryAssemblyDefinition.Name.Name); " is 137.
Long Statement,ILRepacking.Steps,XamlResourcePathPatcherStep,F:\newReposMay17\gluck_il-repack\ILRepack\Steps\XamlResourcePathPatcherStep.cs,PatchMethod,The length of the statement  "		stringInstruction.Operand = PatchPath (path' _repackContext.PrimaryAssemblyDefinition' originalScope.Assembly' _repackContext.OtherAssemblies); " is 143.
Long Statement,ILRepacking.Steps.ResourceProcessing,BamlGenerator,F:\newReposMay17\gluck_il-repack\ILRepack\Steps\ResourceProcessing\BamlGenerator.cs,AddMergedDictionaries,The length of the statement  "			_logger.Error (string.Format ("Existing 'Themes/generic.xaml' in {0} is *not* a ResourceDictionary. " + "This will prevent proper WPF application merging."' _mainAssemblyName)); " is 177.
Long Statement,ILRepacking.Steps.ResourceProcessing,BamlGenerator,F:\newReposMay17\gluck_il-repack\ILRepack\Steps\ResourceProcessing\BamlGenerator.cs,AdjustAttributeIds,The length of the statement  "		if (attributeId == null || record is AttributeInfoRecord || !existingAttributeInfoRecords.Any (r => r.AttributeId == attributeId)) { " is 132.
Long Statement,ILRepacking.Steps.ResourceProcessing,BamlGenerator,F:\newReposMay17\gluck_il-repack\ILRepack\Steps\ResourceProcessing\BamlGenerator.cs,HandleMergedDictionary,The length of the statement  "	int indexStart = document.FindIndex (r => r is PropertyListStartRecord && ((PropertyListStartRecord)r).AttributeId == mergedDictionariesRecord.AttributeId); " is 156.
Long Statement,ILRepacking.Steps.ResourceProcessing,BamlGenerator,F:\newReposMay17\gluck_il-repack\ILRepack\Steps\ResourceProcessing\BamlGenerator.cs,HandleMergedDictionary,The length of the statement  "	List<string> existingUris = document.Skip (indexStart).TakeWhile (r => !(r is PropertyListEndRecord)).OfType<PropertyWithConverterRecord> ().Select (GetFileNameFromPropertyRecord).ToList (); " is 190.
Long Statement,ILRepacking.Steps.ResourceProcessing,BamlResourcePatcher,F:\newReposMay17\gluck_il-repack\ILRepack\Steps\ResourceProcessing\BamlResourcePatcher.cs,ProcessRecord,The length of the statement  "	record.Value = XamlResourcePathPatcherStep.PatchPath (record.Value' _mainAssembly' containingAssembly' _otherAssemblies); " is 121.
Long Statement,ILRepacking.Steps.ResourceProcessing,BamlResourcePatcher,F:\newReposMay17\gluck_il-repack\ILRepack\Steps\ResourceProcessing\BamlResourcePatcher.cs,ProcessRecord,The length of the statement  "	var isMergedAssembly = _otherAssemblies.FirstOrDefault (asm => asm.Name.Name == assemblyName.Name || asm.Name.FullName == record.AssemblyFullName) != null; " is 155.
Long Statement,ILRepacking.Steps.ResourceProcessing,BamlResourcePatcher,F:\newReposMay17\gluck_il-repack\ILRepack\Steps\ResourceProcessing\BamlResourcePatcher.cs,RemoveTypeAssemblyInformation,The length of the statement  "	// ClassLibrary.GenericResourceKey`1[[ClassLibrary.ThemesResourceKey' ClassLibrary' Version=1.0.0.0' Culture=neutral' PublicKeyToken=null]] " is 139.
Long Statement,ILRepacking.Steps.ResourceProcessing,BamlStreamCollector,F:\newReposMay17\gluck_il-repack\ILRepack\Steps\ResourceProcessing\BamlStreamCollector.cs,WriteCollectedBamlStreams,The length of the statement  "		resourceWriter.AddResourceData (GetResourceName (bamlStream.Key' bamlStream.Value)' bamlStream.Key.type' bamlStream.Key.data); " is 126.
Long Statement,ILRepacking.Steps.ResourceProcessing,BamlStreamCollector,F:\newReposMay17\gluck_il-repack\ILRepack\Steps\ResourceProcessing\BamlStreamCollector.cs,PatchGenericThemesBaml,The length of the statement  "	var genericThemeResources = _bamlStreams.Where (e => e.Key.name.EndsWith (GenericThemesBamlName' StringComparison.OrdinalIgnoreCase)).Select (e => GetResourceName (e.Key' e.Value).Replace (".baml"' ".xaml")); " is 208.
Long Statement,ILRepacking.Steps.ResourceProcessing,BamlStreamCollector,F:\newReposMay17\gluck_il-repack\ILRepack\Steps\ResourceProcessing\BamlStreamCollector.cs,PatchGenericThemesBaml,The length of the statement  "		PatchExistingGenericThemesXaml (resourceWriter' BamlUtils.FromResourceBytes (existingGenericBaml)' genericThemeResources); " is 122.
Long Statement,ILRepacking.Steps.ResourceProcessing,BamlStreamCollector,F:\newReposMay17\gluck_il-repack\ILRepack\Steps\ResourceProcessing\BamlStreamCollector.cs,AddNewGenericThemesXaml,The length of the statement  "	resourceWriter.AddResourceData (GenericThemesBamlName' "ResourceTypeCode.Stream"' BamlUtils.ToResourceBytes (newBamlDocument)); " is 127.
Long Statement,ILRepacking.Steps.SourceServerData,HttpSourceServerDescriptor,F:\newReposMay17\gluck_il-repack\ILRepack\Steps\SourceServerData\HttpSourceServerDescriptor.cs,TryParse,The length of the statement  "	}.Contains (versionControl) ? new HttpSourceServerDescriptor (version' versionControl' target' sources.ToArray ()) : null; " is 122.
Long Statement,ILRepacking.Steps.SourceServerData,HttpSourceServerDescriptor,F:\newReposMay17\gluck_il-repack\ILRepack\Steps\SourceServerData\HttpSourceServerDescriptor.cs,MergeWith,The length of the statement  "	}.Concat (others.Where (descriptor => descriptor.VersionControl == VersionControl)).SelectMany (descriptor => descriptor.SourceFiles.Select (file => new { " is 154.
Long Statement,ILRepacking.Steps.SourceServerData,HttpSourceServerDescriptor,F:\newReposMay17\gluck_il-repack\ILRepack\Steps\SourceServerData\HttpSourceServerDescriptor.cs,MergeWith,The length of the statement  "		return new SourceFileDescriptor (tuple.Variables.FirstOrDefault () ?? ""' Enumerable.Range (1' tuple.Variables.Length - 1).Select (index => new { " is 145.
Long Statement,ILRepacking.Steps.SourceServerData,SourceServerDataRepackStep,F:\newReposMay17\gluck_il-repack\ILRepack\Steps\SourceServerData\SourceServerDataRepackStep.cs,Perform,The length of the statement  "	_srcSrv = descriptors.Any () ? descriptors.First ().MergeWith (descriptors.Skip (1)).ToString () : srcsrvValues.FirstOrDefault (); " is 130.
Long Statement,ILRepacking.Steps.SourceServerData,NullSourceServerStep,F:\newReposMay17\gluck_il-repack\ILRepack\Steps\SourceServerData\SourceServerDataRepackStep.cs,Write,The length of the statement  "	_logger.Warn ("Did not write source server data to output assembly. " + "Source server data is only writeable on Windows"); " is 123.
Complex Conditional,ILRepacking,ILRepack,F:\newReposMay17\gluck_il-repack\ILRepack\ILRepack.cs,FixStr,The conditional expression  "String.IsNullOrEmpty (content) || content.Length > 512 || content.IndexOf ("' ") == -1 || content.StartsWith ("System.")"  is complex.
Complex Conditional,ILRepacking,ReferenceFixator,F:\newReposMay17\gluck_il-repack\ILRepack\ReferenceFixator.cs,Fix,The conditional expression  "!method.IsDefinition && !method.DeclaringType.IsGenericInstance && !method.DeclaringType.IsArray && (method.ReturnType.IsDefinition || method.Parameters.Any (x => x.ParameterType.IsDefinition))"  is complex.
Complex Conditional,ILRepacking,RepackImporter,F:\newReposMay17\gluck_il-repack\ILRepack\RepackImporter.cs,CloneTo,The conditional expression  "!typeJustCreated && type.Methods.Count > 0 && type.Methods.Any (x => (x.Name == meth.Name) && (x.Parameters.Count == meth.Parameters.Count) && (x.ToString () == meth.ToString ()))"  is complex.
Empty Catch Block,ILRepacking,IKVMLineIndexer,F:\newReposMay17\gluck_il-repack\ILRepack\IKVMLineIndexer.cs,ProcessMethodBodyInstruction,The method has an empty catch block.
Empty Catch Block,ILRepacking,ILRepack,F:\newReposMay17\gluck_il-repack\ILRepack\ILRepack.cs,GetRepackAssemblyNames,The method has an empty catch block.
Empty Catch Block,ILRepacking.Steps.SourceServerData,PdbStr,F:\newReposMay17\gluck_il-repack\ILRepack\Steps\SourceServerData\PdbStr.cs,SafeDeleteFile,The method has an empty catch block.
Magic Number,ILRepacking,Application,F:\newReposMay17\gluck_il-repack\ILRepack\Application.cs,Main,The following statement contains a magic number: try {  	if (options.ShouldShowUsage) {  		Usage ();  		Exit (2);  	}  	logger.ShouldLogVerbose = options.LogVerbose;  	//TODO: Open the Logger before the parse  	if (logger.Open (options.LogFile)) {  		options.Log = true;  	}  	ILRepack repack = new ILRepack (options' logger);  	repack.Repack ();  	returnCode = 0;  } catch (RepackOptions.InvalidTargetKindException e) {  	Console.WriteLine (e.Message);  	Usage ();  	Exit (2);  } catch (Exception e) {  	logger.Log (e);  	returnCode = 1;  } finally {  	logger.Close ();  	if (options.PauseBeforeExit) {  		Console.WriteLine ("Press Any Key To Continue");  		Console.ReadKey (true);  	}  }  
Magic Number,ILRepacking,Application,F:\newReposMay17\gluck_il-repack\ILRepack\Application.cs,Main,The following statement contains a magic number: try {  	if (options.ShouldShowUsage) {  		Usage ();  		Exit (2);  	}  	logger.ShouldLogVerbose = options.LogVerbose;  	//TODO: Open the Logger before the parse  	if (logger.Open (options.LogFile)) {  		options.Log = true;  	}  	ILRepack repack = new ILRepack (options' logger);  	repack.Repack ();  	returnCode = 0;  } catch (RepackOptions.InvalidTargetKindException e) {  	Console.WriteLine (e.Message);  	Usage ();  	Exit (2);  } catch (Exception e) {  	logger.Log (e);  	returnCode = 1;  } finally {  	logger.Close ();  	if (options.PauseBeforeExit) {  		Console.WriteLine ("Press Any Key To Continue");  		Console.ReadKey (true);  	}  }  
Magic Number,ILRepacking,Application,F:\newReposMay17\gluck_il-repack\ILRepack\Application.cs,Main,The following statement contains a magic number: if (options.ShouldShowUsage) {  	Usage ();  	Exit (2);  }  
Magic Number,ILRepacking,Application,F:\newReposMay17\gluck_il-repack\ILRepack\Application.cs,Main,The following statement contains a magic number: Exit (2);  
Magic Number,ILRepacking,Application,F:\newReposMay17\gluck_il-repack\ILRepack\Application.cs,Main,The following statement contains a magic number: Exit (2);  
Magic Number,ILRepacking,IKVMLineIndexer,F:\newReposMay17\gluck_il-repack\ILRepack\IKVMLineIndexer.cs,PreMethodBodyRepack,The following statement contains a magic number: if (!parent.CustomAttributes.Any (x => x.Constructor.DeclaringType.Name == "LineNumberTableAttribute")) {  	lineNumberWriter = new LineNumberWriter (body.Instructions.Count / 4);  }  
Magic Number,ILRepacking,IKVMLineIndexer,F:\newReposMay17\gluck_il-repack\ILRepack\IKVMLineIndexer.cs,PreMethodBodyRepack,The following statement contains a magic number: lineNumberWriter = new LineNumberWriter (body.Instructions.Count / 4);  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,LineNumberWriter,The following statement contains a magic number: stream = new System.IO.MemoryStream (estimatedCount * 2);  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,AddMapping,The following statement contains a magic number: if (count == 0) {  	if (ilOffset == 0 && linenumber != 0) {  		prevLineNum = linenumber;  		count++;  		WritePackedInteger (linenumber - (64 + 50));  		return;  	} else {  		prevLineNum = linenumber & ~3;  		WritePackedInteger (((-prevLineNum / 4) - (64 + 50)));  	}  }  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,AddMapping,The following statement contains a magic number: if (count == 0) {  	if (ilOffset == 0 && linenumber != 0) {  		prevLineNum = linenumber;  		count++;  		WritePackedInteger (linenumber - (64 + 50));  		return;  	} else {  		prevLineNum = linenumber & ~3;  		WritePackedInteger (((-prevLineNum / 4) - (64 + 50)));  	}  }  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,AddMapping,The following statement contains a magic number: if (count == 0) {  	if (ilOffset == 0 && linenumber != 0) {  		prevLineNum = linenumber;  		count++;  		WritePackedInteger (linenumber - (64 + 50));  		return;  	} else {  		prevLineNum = linenumber & ~3;  		WritePackedInteger (((-prevLineNum / 4) - (64 + 50)));  	}  }  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,AddMapping,The following statement contains a magic number: if (count == 0) {  	if (ilOffset == 0 && linenumber != 0) {  		prevLineNum = linenumber;  		count++;  		WritePackedInteger (linenumber - (64 + 50));  		return;  	} else {  		prevLineNum = linenumber & ~3;  		WritePackedInteger (((-prevLineNum / 4) - (64 + 50)));  	}  }  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,AddMapping,The following statement contains a magic number: if (count == 0) {  	if (ilOffset == 0 && linenumber != 0) {  		prevLineNum = linenumber;  		count++;  		WritePackedInteger (linenumber - (64 + 50));  		return;  	} else {  		prevLineNum = linenumber & ~3;  		WritePackedInteger (((-prevLineNum / 4) - (64 + 50)));  	}  }  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,AddMapping,The following statement contains a magic number: if (count == 0) {  	if (ilOffset == 0 && linenumber != 0) {  		prevLineNum = linenumber;  		count++;  		WritePackedInteger (linenumber - (64 + 50));  		return;  	} else {  		prevLineNum = linenumber & ~3;  		WritePackedInteger (((-prevLineNum / 4) - (64 + 50)));  	}  }  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,AddMapping,The following statement contains a magic number: if (ilOffset == 0 && linenumber != 0) {  	prevLineNum = linenumber;  	count++;  	WritePackedInteger (linenumber - (64 + 50));  	return;  } else {  	prevLineNum = linenumber & ~3;  	WritePackedInteger (((-prevLineNum / 4) - (64 + 50)));  }  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,AddMapping,The following statement contains a magic number: if (ilOffset == 0 && linenumber != 0) {  	prevLineNum = linenumber;  	count++;  	WritePackedInteger (linenumber - (64 + 50));  	return;  } else {  	prevLineNum = linenumber & ~3;  	WritePackedInteger (((-prevLineNum / 4) - (64 + 50)));  }  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,AddMapping,The following statement contains a magic number: if (ilOffset == 0 && linenumber != 0) {  	prevLineNum = linenumber;  	count++;  	WritePackedInteger (linenumber - (64 + 50));  	return;  } else {  	prevLineNum = linenumber & ~3;  	WritePackedInteger (((-prevLineNum / 4) - (64 + 50)));  }  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,AddMapping,The following statement contains a magic number: if (ilOffset == 0 && linenumber != 0) {  	prevLineNum = linenumber;  	count++;  	WritePackedInteger (linenumber - (64 + 50));  	return;  } else {  	prevLineNum = linenumber & ~3;  	WritePackedInteger (((-prevLineNum / 4) - (64 + 50)));  }  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,AddMapping,The following statement contains a magic number: if (ilOffset == 0 && linenumber != 0) {  	prevLineNum = linenumber;  	count++;  	WritePackedInteger (linenumber - (64 + 50));  	return;  } else {  	prevLineNum = linenumber & ~3;  	WritePackedInteger (((-prevLineNum / 4) - (64 + 50)));  }  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,AddMapping,The following statement contains a magic number: if (ilOffset == 0 && linenumber != 0) {  	prevLineNum = linenumber;  	count++;  	WritePackedInteger (linenumber - (64 + 50));  	return;  } else {  	prevLineNum = linenumber & ~3;  	WritePackedInteger (((-prevLineNum / 4) - (64 + 50)));  }  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,AddMapping,The following statement contains a magic number: WritePackedInteger (linenumber - (64 + 50));  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,AddMapping,The following statement contains a magic number: WritePackedInteger (linenumber - (64 + 50));  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,AddMapping,The following statement contains a magic number: prevLineNum = linenumber & ~3;  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,AddMapping,The following statement contains a magic number: WritePackedInteger (((-prevLineNum / 4) - (64 + 50)));  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,AddMapping,The following statement contains a magic number: WritePackedInteger (((-prevLineNum / 4) - (64 + 50)));  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,AddMapping,The following statement contains a magic number: WritePackedInteger (((-prevLineNum / 4) - (64 + 50)));  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,AddMapping,The following statement contains a magic number: if (deltaPC >= 0 && deltaPC < 31) {  	lead = (byte)deltaPC;  	pc_overflow = false;  } else {  	lead = (byte)31;  	pc_overflow = true;  }  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,AddMapping,The following statement contains a magic number: if (deltaPC >= 0 && deltaPC < 31) {  	lead = (byte)deltaPC;  	pc_overflow = false;  } else {  	lead = (byte)31;  	pc_overflow = true;  }  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,AddMapping,The following statement contains a magic number: lead = (byte)31;  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,AddMapping,The following statement contains a magic number: if (deltaLineNo >= -bias && deltaLineNo < 7 - bias) {  	lead |= (byte)((deltaLineNo + bias) << 5);  	lineno_overflow = false;  } else {  	lead |= (byte)(7 << 5);  	lineno_overflow = true;  }  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,AddMapping,The following statement contains a magic number: if (deltaLineNo >= -bias && deltaLineNo < 7 - bias) {  	lead |= (byte)((deltaLineNo + bias) << 5);  	lineno_overflow = false;  } else {  	lead |= (byte)(7 << 5);  	lineno_overflow = true;  }  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,AddMapping,The following statement contains a magic number: if (deltaLineNo >= -bias && deltaLineNo < 7 - bias) {  	lead |= (byte)((deltaLineNo + bias) << 5);  	lineno_overflow = false;  } else {  	lead |= (byte)(7 << 5);  	lineno_overflow = true;  }  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,AddMapping,The following statement contains a magic number: if (deltaLineNo >= -bias && deltaLineNo < 7 - bias) {  	lead |= (byte)((deltaLineNo + bias) << 5);  	lineno_overflow = false;  } else {  	lead |= (byte)(7 << 5);  	lineno_overflow = true;  }  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,AddMapping,The following statement contains a magic number: lead |= (byte)((deltaLineNo + bias) << 5);  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,AddMapping,The following statement contains a magic number: lead |= (byte)(7 << 5);  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,AddMapping,The following statement contains a magic number: lead |= (byte)(7 << 5);  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,AddMapping,The following statement contains a magic number: if (pc_overflow) {  	WritePackedInteger (deltaPC - (64 + 31));  }  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,AddMapping,The following statement contains a magic number: if (pc_overflow) {  	WritePackedInteger (deltaPC - (64 + 31));  }  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,AddMapping,The following statement contains a magic number: WritePackedInteger (deltaPC - (64 + 31));  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,AddMapping,The following statement contains a magic number: WritePackedInteger (deltaPC - (64 + 31));  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,WritePackedInteger,The following statement contains a magic number: if (val >= -64 && val < 64) {  	val += 64;  	stream.WriteByte ((byte)val);  } else if (val >= -8192 && val < 8192) {  	val += 8192;  	stream.WriteByte ((byte)(0x80 + (val >> 8)));  	stream.WriteByte ((byte)val);  } else if (val >= -1048576 && val < 1048576) {  	val += 1048576;  	stream.WriteByte ((byte)(0xC0 + (val >> 16)));  	stream.WriteByte ((byte)(val >> 8));  	stream.WriteByte ((byte)val);  } else {  	stream.WriteByte (0xFF);  	stream.WriteByte ((byte)(val >> 24));  	stream.WriteByte ((byte)(val >> 16));  	stream.WriteByte ((byte)(val >> 8));  	stream.WriteByte ((byte)(val >> 0));  }  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,WritePackedInteger,The following statement contains a magic number: if (val >= -64 && val < 64) {  	val += 64;  	stream.WriteByte ((byte)val);  } else if (val >= -8192 && val < 8192) {  	val += 8192;  	stream.WriteByte ((byte)(0x80 + (val >> 8)));  	stream.WriteByte ((byte)val);  } else if (val >= -1048576 && val < 1048576) {  	val += 1048576;  	stream.WriteByte ((byte)(0xC0 + (val >> 16)));  	stream.WriteByte ((byte)(val >> 8));  	stream.WriteByte ((byte)val);  } else {  	stream.WriteByte (0xFF);  	stream.WriteByte ((byte)(val >> 24));  	stream.WriteByte ((byte)(val >> 16));  	stream.WriteByte ((byte)(val >> 8));  	stream.WriteByte ((byte)(val >> 0));  }  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,WritePackedInteger,The following statement contains a magic number: if (val >= -64 && val < 64) {  	val += 64;  	stream.WriteByte ((byte)val);  } else if (val >= -8192 && val < 8192) {  	val += 8192;  	stream.WriteByte ((byte)(0x80 + (val >> 8)));  	stream.WriteByte ((byte)val);  } else if (val >= -1048576 && val < 1048576) {  	val += 1048576;  	stream.WriteByte ((byte)(0xC0 + (val >> 16)));  	stream.WriteByte ((byte)(val >> 8));  	stream.WriteByte ((byte)val);  } else {  	stream.WriteByte (0xFF);  	stream.WriteByte ((byte)(val >> 24));  	stream.WriteByte ((byte)(val >> 16));  	stream.WriteByte ((byte)(val >> 8));  	stream.WriteByte ((byte)(val >> 0));  }  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,WritePackedInteger,The following statement contains a magic number: if (val >= -64 && val < 64) {  	val += 64;  	stream.WriteByte ((byte)val);  } else if (val >= -8192 && val < 8192) {  	val += 8192;  	stream.WriteByte ((byte)(0x80 + (val >> 8)));  	stream.WriteByte ((byte)val);  } else if (val >= -1048576 && val < 1048576) {  	val += 1048576;  	stream.WriteByte ((byte)(0xC0 + (val >> 16)));  	stream.WriteByte ((byte)(val >> 8));  	stream.WriteByte ((byte)val);  } else {  	stream.WriteByte (0xFF);  	stream.WriteByte ((byte)(val >> 24));  	stream.WriteByte ((byte)(val >> 16));  	stream.WriteByte ((byte)(val >> 8));  	stream.WriteByte ((byte)(val >> 0));  }  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,WritePackedInteger,The following statement contains a magic number: if (val >= -64 && val < 64) {  	val += 64;  	stream.WriteByte ((byte)val);  } else if (val >= -8192 && val < 8192) {  	val += 8192;  	stream.WriteByte ((byte)(0x80 + (val >> 8)));  	stream.WriteByte ((byte)val);  } else if (val >= -1048576 && val < 1048576) {  	val += 1048576;  	stream.WriteByte ((byte)(0xC0 + (val >> 16)));  	stream.WriteByte ((byte)(val >> 8));  	stream.WriteByte ((byte)val);  } else {  	stream.WriteByte (0xFF);  	stream.WriteByte ((byte)(val >> 24));  	stream.WriteByte ((byte)(val >> 16));  	stream.WriteByte ((byte)(val >> 8));  	stream.WriteByte ((byte)(val >> 0));  }  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,WritePackedInteger,The following statement contains a magic number: if (val >= -64 && val < 64) {  	val += 64;  	stream.WriteByte ((byte)val);  } else if (val >= -8192 && val < 8192) {  	val += 8192;  	stream.WriteByte ((byte)(0x80 + (val >> 8)));  	stream.WriteByte ((byte)val);  } else if (val >= -1048576 && val < 1048576) {  	val += 1048576;  	stream.WriteByte ((byte)(0xC0 + (val >> 16)));  	stream.WriteByte ((byte)(val >> 8));  	stream.WriteByte ((byte)val);  } else {  	stream.WriteByte (0xFF);  	stream.WriteByte ((byte)(val >> 24));  	stream.WriteByte ((byte)(val >> 16));  	stream.WriteByte ((byte)(val >> 8));  	stream.WriteByte ((byte)(val >> 0));  }  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,WritePackedInteger,The following statement contains a magic number: if (val >= -64 && val < 64) {  	val += 64;  	stream.WriteByte ((byte)val);  } else if (val >= -8192 && val < 8192) {  	val += 8192;  	stream.WriteByte ((byte)(0x80 + (val >> 8)));  	stream.WriteByte ((byte)val);  } else if (val >= -1048576 && val < 1048576) {  	val += 1048576;  	stream.WriteByte ((byte)(0xC0 + (val >> 16)));  	stream.WriteByte ((byte)(val >> 8));  	stream.WriteByte ((byte)val);  } else {  	stream.WriteByte (0xFF);  	stream.WriteByte ((byte)(val >> 24));  	stream.WriteByte ((byte)(val >> 16));  	stream.WriteByte ((byte)(val >> 8));  	stream.WriteByte ((byte)(val >> 0));  }  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,WritePackedInteger,The following statement contains a magic number: if (val >= -64 && val < 64) {  	val += 64;  	stream.WriteByte ((byte)val);  } else if (val >= -8192 && val < 8192) {  	val += 8192;  	stream.WriteByte ((byte)(0x80 + (val >> 8)));  	stream.WriteByte ((byte)val);  } else if (val >= -1048576 && val < 1048576) {  	val += 1048576;  	stream.WriteByte ((byte)(0xC0 + (val >> 16)));  	stream.WriteByte ((byte)(val >> 8));  	stream.WriteByte ((byte)val);  } else {  	stream.WriteByte (0xFF);  	stream.WriteByte ((byte)(val >> 24));  	stream.WriteByte ((byte)(val >> 16));  	stream.WriteByte ((byte)(val >> 8));  	stream.WriteByte ((byte)(val >> 0));  }  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,WritePackedInteger,The following statement contains a magic number: if (val >= -64 && val < 64) {  	val += 64;  	stream.WriteByte ((byte)val);  } else if (val >= -8192 && val < 8192) {  	val += 8192;  	stream.WriteByte ((byte)(0x80 + (val >> 8)));  	stream.WriteByte ((byte)val);  } else if (val >= -1048576 && val < 1048576) {  	val += 1048576;  	stream.WriteByte ((byte)(0xC0 + (val >> 16)));  	stream.WriteByte ((byte)(val >> 8));  	stream.WriteByte ((byte)val);  } else {  	stream.WriteByte (0xFF);  	stream.WriteByte ((byte)(val >> 24));  	stream.WriteByte ((byte)(val >> 16));  	stream.WriteByte ((byte)(val >> 8));  	stream.WriteByte ((byte)(val >> 0));  }  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,WritePackedInteger,The following statement contains a magic number: if (val >= -64 && val < 64) {  	val += 64;  	stream.WriteByte ((byte)val);  } else if (val >= -8192 && val < 8192) {  	val += 8192;  	stream.WriteByte ((byte)(0x80 + (val >> 8)));  	stream.WriteByte ((byte)val);  } else if (val >= -1048576 && val < 1048576) {  	val += 1048576;  	stream.WriteByte ((byte)(0xC0 + (val >> 16)));  	stream.WriteByte ((byte)(val >> 8));  	stream.WriteByte ((byte)val);  } else {  	stream.WriteByte (0xFF);  	stream.WriteByte ((byte)(val >> 24));  	stream.WriteByte ((byte)(val >> 16));  	stream.WriteByte ((byte)(val >> 8));  	stream.WriteByte ((byte)(val >> 0));  }  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,WritePackedInteger,The following statement contains a magic number: if (val >= -64 && val < 64) {  	val += 64;  	stream.WriteByte ((byte)val);  } else if (val >= -8192 && val < 8192) {  	val += 8192;  	stream.WriteByte ((byte)(0x80 + (val >> 8)));  	stream.WriteByte ((byte)val);  } else if (val >= -1048576 && val < 1048576) {  	val += 1048576;  	stream.WriteByte ((byte)(0xC0 + (val >> 16)));  	stream.WriteByte ((byte)(val >> 8));  	stream.WriteByte ((byte)val);  } else {  	stream.WriteByte (0xFF);  	stream.WriteByte ((byte)(val >> 24));  	stream.WriteByte ((byte)(val >> 16));  	stream.WriteByte ((byte)(val >> 8));  	stream.WriteByte ((byte)(val >> 0));  }  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,WritePackedInteger,The following statement contains a magic number: if (val >= -64 && val < 64) {  	val += 64;  	stream.WriteByte ((byte)val);  } else if (val >= -8192 && val < 8192) {  	val += 8192;  	stream.WriteByte ((byte)(0x80 + (val >> 8)));  	stream.WriteByte ((byte)val);  } else if (val >= -1048576 && val < 1048576) {  	val += 1048576;  	stream.WriteByte ((byte)(0xC0 + (val >> 16)));  	stream.WriteByte ((byte)(val >> 8));  	stream.WriteByte ((byte)val);  } else {  	stream.WriteByte (0xFF);  	stream.WriteByte ((byte)(val >> 24));  	stream.WriteByte ((byte)(val >> 16));  	stream.WriteByte ((byte)(val >> 8));  	stream.WriteByte ((byte)(val >> 0));  }  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,WritePackedInteger,The following statement contains a magic number: if (val >= -64 && val < 64) {  	val += 64;  	stream.WriteByte ((byte)val);  } else if (val >= -8192 && val < 8192) {  	val += 8192;  	stream.WriteByte ((byte)(0x80 + (val >> 8)));  	stream.WriteByte ((byte)val);  } else if (val >= -1048576 && val < 1048576) {  	val += 1048576;  	stream.WriteByte ((byte)(0xC0 + (val >> 16)));  	stream.WriteByte ((byte)(val >> 8));  	stream.WriteByte ((byte)val);  } else {  	stream.WriteByte (0xFF);  	stream.WriteByte ((byte)(val >> 24));  	stream.WriteByte ((byte)(val >> 16));  	stream.WriteByte ((byte)(val >> 8));  	stream.WriteByte ((byte)(val >> 0));  }  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,WritePackedInteger,The following statement contains a magic number: if (val >= -64 && val < 64) {  	val += 64;  	stream.WriteByte ((byte)val);  } else if (val >= -8192 && val < 8192) {  	val += 8192;  	stream.WriteByte ((byte)(0x80 + (val >> 8)));  	stream.WriteByte ((byte)val);  } else if (val >= -1048576 && val < 1048576) {  	val += 1048576;  	stream.WriteByte ((byte)(0xC0 + (val >> 16)));  	stream.WriteByte ((byte)(val >> 8));  	stream.WriteByte ((byte)val);  } else {  	stream.WriteByte (0xFF);  	stream.WriteByte ((byte)(val >> 24));  	stream.WriteByte ((byte)(val >> 16));  	stream.WriteByte ((byte)(val >> 8));  	stream.WriteByte ((byte)(val >> 0));  }  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,WritePackedInteger,The following statement contains a magic number: if (val >= -64 && val < 64) {  	val += 64;  	stream.WriteByte ((byte)val);  } else if (val >= -8192 && val < 8192) {  	val += 8192;  	stream.WriteByte ((byte)(0x80 + (val >> 8)));  	stream.WriteByte ((byte)val);  } else if (val >= -1048576 && val < 1048576) {  	val += 1048576;  	stream.WriteByte ((byte)(0xC0 + (val >> 16)));  	stream.WriteByte ((byte)(val >> 8));  	stream.WriteByte ((byte)val);  } else {  	stream.WriteByte (0xFF);  	stream.WriteByte ((byte)(val >> 24));  	stream.WriteByte ((byte)(val >> 16));  	stream.WriteByte ((byte)(val >> 8));  	stream.WriteByte ((byte)(val >> 0));  }  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,WritePackedInteger,The following statement contains a magic number: val += 64;  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,WritePackedInteger,The following statement contains a magic number: if (val >= -8192 && val < 8192) {  	val += 8192;  	stream.WriteByte ((byte)(0x80 + (val >> 8)));  	stream.WriteByte ((byte)val);  } else if (val >= -1048576 && val < 1048576) {  	val += 1048576;  	stream.WriteByte ((byte)(0xC0 + (val >> 16)));  	stream.WriteByte ((byte)(val >> 8));  	stream.WriteByte ((byte)val);  } else {  	stream.WriteByte (0xFF);  	stream.WriteByte ((byte)(val >> 24));  	stream.WriteByte ((byte)(val >> 16));  	stream.WriteByte ((byte)(val >> 8));  	stream.WriteByte ((byte)(val >> 0));  }  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,WritePackedInteger,The following statement contains a magic number: if (val >= -8192 && val < 8192) {  	val += 8192;  	stream.WriteByte ((byte)(0x80 + (val >> 8)));  	stream.WriteByte ((byte)val);  } else if (val >= -1048576 && val < 1048576) {  	val += 1048576;  	stream.WriteByte ((byte)(0xC0 + (val >> 16)));  	stream.WriteByte ((byte)(val >> 8));  	stream.WriteByte ((byte)val);  } else {  	stream.WriteByte (0xFF);  	stream.WriteByte ((byte)(val >> 24));  	stream.WriteByte ((byte)(val >> 16));  	stream.WriteByte ((byte)(val >> 8));  	stream.WriteByte ((byte)(val >> 0));  }  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,WritePackedInteger,The following statement contains a magic number: if (val >= -8192 && val < 8192) {  	val += 8192;  	stream.WriteByte ((byte)(0x80 + (val >> 8)));  	stream.WriteByte ((byte)val);  } else if (val >= -1048576 && val < 1048576) {  	val += 1048576;  	stream.WriteByte ((byte)(0xC0 + (val >> 16)));  	stream.WriteByte ((byte)(val >> 8));  	stream.WriteByte ((byte)val);  } else {  	stream.WriteByte (0xFF);  	stream.WriteByte ((byte)(val >> 24));  	stream.WriteByte ((byte)(val >> 16));  	stream.WriteByte ((byte)(val >> 8));  	stream.WriteByte ((byte)(val >> 0));  }  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,WritePackedInteger,The following statement contains a magic number: if (val >= -8192 && val < 8192) {  	val += 8192;  	stream.WriteByte ((byte)(0x80 + (val >> 8)));  	stream.WriteByte ((byte)val);  } else if (val >= -1048576 && val < 1048576) {  	val += 1048576;  	stream.WriteByte ((byte)(0xC0 + (val >> 16)));  	stream.WriteByte ((byte)(val >> 8));  	stream.WriteByte ((byte)val);  } else {  	stream.WriteByte (0xFF);  	stream.WriteByte ((byte)(val >> 24));  	stream.WriteByte ((byte)(val >> 16));  	stream.WriteByte ((byte)(val >> 8));  	stream.WriteByte ((byte)(val >> 0));  }  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,WritePackedInteger,The following statement contains a magic number: if (val >= -8192 && val < 8192) {  	val += 8192;  	stream.WriteByte ((byte)(0x80 + (val >> 8)));  	stream.WriteByte ((byte)val);  } else if (val >= -1048576 && val < 1048576) {  	val += 1048576;  	stream.WriteByte ((byte)(0xC0 + (val >> 16)));  	stream.WriteByte ((byte)(val >> 8));  	stream.WriteByte ((byte)val);  } else {  	stream.WriteByte (0xFF);  	stream.WriteByte ((byte)(val >> 24));  	stream.WriteByte ((byte)(val >> 16));  	stream.WriteByte ((byte)(val >> 8));  	stream.WriteByte ((byte)(val >> 0));  }  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,WritePackedInteger,The following statement contains a magic number: if (val >= -8192 && val < 8192) {  	val += 8192;  	stream.WriteByte ((byte)(0x80 + (val >> 8)));  	stream.WriteByte ((byte)val);  } else if (val >= -1048576 && val < 1048576) {  	val += 1048576;  	stream.WriteByte ((byte)(0xC0 + (val >> 16)));  	stream.WriteByte ((byte)(val >> 8));  	stream.WriteByte ((byte)val);  } else {  	stream.WriteByte (0xFF);  	stream.WriteByte ((byte)(val >> 24));  	stream.WriteByte ((byte)(val >> 16));  	stream.WriteByte ((byte)(val >> 8));  	stream.WriteByte ((byte)(val >> 0));  }  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,WritePackedInteger,The following statement contains a magic number: if (val >= -8192 && val < 8192) {  	val += 8192;  	stream.WriteByte ((byte)(0x80 + (val >> 8)));  	stream.WriteByte ((byte)val);  } else if (val >= -1048576 && val < 1048576) {  	val += 1048576;  	stream.WriteByte ((byte)(0xC0 + (val >> 16)));  	stream.WriteByte ((byte)(val >> 8));  	stream.WriteByte ((byte)val);  } else {  	stream.WriteByte (0xFF);  	stream.WriteByte ((byte)(val >> 24));  	stream.WriteByte ((byte)(val >> 16));  	stream.WriteByte ((byte)(val >> 8));  	stream.WriteByte ((byte)(val >> 0));  }  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,WritePackedInteger,The following statement contains a magic number: if (val >= -8192 && val < 8192) {  	val += 8192;  	stream.WriteByte ((byte)(0x80 + (val >> 8)));  	stream.WriteByte ((byte)val);  } else if (val >= -1048576 && val < 1048576) {  	val += 1048576;  	stream.WriteByte ((byte)(0xC0 + (val >> 16)));  	stream.WriteByte ((byte)(val >> 8));  	stream.WriteByte ((byte)val);  } else {  	stream.WriteByte (0xFF);  	stream.WriteByte ((byte)(val >> 24));  	stream.WriteByte ((byte)(val >> 16));  	stream.WriteByte ((byte)(val >> 8));  	stream.WriteByte ((byte)(val >> 0));  }  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,WritePackedInteger,The following statement contains a magic number: if (val >= -8192 && val < 8192) {  	val += 8192;  	stream.WriteByte ((byte)(0x80 + (val >> 8)));  	stream.WriteByte ((byte)val);  } else if (val >= -1048576 && val < 1048576) {  	val += 1048576;  	stream.WriteByte ((byte)(0xC0 + (val >> 16)));  	stream.WriteByte ((byte)(val >> 8));  	stream.WriteByte ((byte)val);  } else {  	stream.WriteByte (0xFF);  	stream.WriteByte ((byte)(val >> 24));  	stream.WriteByte ((byte)(val >> 16));  	stream.WriteByte ((byte)(val >> 8));  	stream.WriteByte ((byte)(val >> 0));  }  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,WritePackedInteger,The following statement contains a magic number: if (val >= -8192 && val < 8192) {  	val += 8192;  	stream.WriteByte ((byte)(0x80 + (val >> 8)));  	stream.WriteByte ((byte)val);  } else if (val >= -1048576 && val < 1048576) {  	val += 1048576;  	stream.WriteByte ((byte)(0xC0 + (val >> 16)));  	stream.WriteByte ((byte)(val >> 8));  	stream.WriteByte ((byte)val);  } else {  	stream.WriteByte (0xFF);  	stream.WriteByte ((byte)(val >> 24));  	stream.WriteByte ((byte)(val >> 16));  	stream.WriteByte ((byte)(val >> 8));  	stream.WriteByte ((byte)(val >> 0));  }  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,WritePackedInteger,The following statement contains a magic number: if (val >= -8192 && val < 8192) {  	val += 8192;  	stream.WriteByte ((byte)(0x80 + (val >> 8)));  	stream.WriteByte ((byte)val);  } else if (val >= -1048576 && val < 1048576) {  	val += 1048576;  	stream.WriteByte ((byte)(0xC0 + (val >> 16)));  	stream.WriteByte ((byte)(val >> 8));  	stream.WriteByte ((byte)val);  } else {  	stream.WriteByte (0xFF);  	stream.WriteByte ((byte)(val >> 24));  	stream.WriteByte ((byte)(val >> 16));  	stream.WriteByte ((byte)(val >> 8));  	stream.WriteByte ((byte)(val >> 0));  }  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,WritePackedInteger,The following statement contains a magic number: if (val >= -8192 && val < 8192) {  	val += 8192;  	stream.WriteByte ((byte)(0x80 + (val >> 8)));  	stream.WriteByte ((byte)val);  } else if (val >= -1048576 && val < 1048576) {  	val += 1048576;  	stream.WriteByte ((byte)(0xC0 + (val >> 16)));  	stream.WriteByte ((byte)(val >> 8));  	stream.WriteByte ((byte)val);  } else {  	stream.WriteByte (0xFF);  	stream.WriteByte ((byte)(val >> 24));  	stream.WriteByte ((byte)(val >> 16));  	stream.WriteByte ((byte)(val >> 8));  	stream.WriteByte ((byte)(val >> 0));  }  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,WritePackedInteger,The following statement contains a magic number: val += 8192;  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,WritePackedInteger,The following statement contains a magic number: stream.WriteByte ((byte)(0x80 + (val >> 8)));  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,WritePackedInteger,The following statement contains a magic number: if (val >= -1048576 && val < 1048576) {  	val += 1048576;  	stream.WriteByte ((byte)(0xC0 + (val >> 16)));  	stream.WriteByte ((byte)(val >> 8));  	stream.WriteByte ((byte)val);  } else {  	stream.WriteByte (0xFF);  	stream.WriteByte ((byte)(val >> 24));  	stream.WriteByte ((byte)(val >> 16));  	stream.WriteByte ((byte)(val >> 8));  	stream.WriteByte ((byte)(val >> 0));  }  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,WritePackedInteger,The following statement contains a magic number: if (val >= -1048576 && val < 1048576) {  	val += 1048576;  	stream.WriteByte ((byte)(0xC0 + (val >> 16)));  	stream.WriteByte ((byte)(val >> 8));  	stream.WriteByte ((byte)val);  } else {  	stream.WriteByte (0xFF);  	stream.WriteByte ((byte)(val >> 24));  	stream.WriteByte ((byte)(val >> 16));  	stream.WriteByte ((byte)(val >> 8));  	stream.WriteByte ((byte)(val >> 0));  }  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,WritePackedInteger,The following statement contains a magic number: if (val >= -1048576 && val < 1048576) {  	val += 1048576;  	stream.WriteByte ((byte)(0xC0 + (val >> 16)));  	stream.WriteByte ((byte)(val >> 8));  	stream.WriteByte ((byte)val);  } else {  	stream.WriteByte (0xFF);  	stream.WriteByte ((byte)(val >> 24));  	stream.WriteByte ((byte)(val >> 16));  	stream.WriteByte ((byte)(val >> 8));  	stream.WriteByte ((byte)(val >> 0));  }  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,WritePackedInteger,The following statement contains a magic number: if (val >= -1048576 && val < 1048576) {  	val += 1048576;  	stream.WriteByte ((byte)(0xC0 + (val >> 16)));  	stream.WriteByte ((byte)(val >> 8));  	stream.WriteByte ((byte)val);  } else {  	stream.WriteByte (0xFF);  	stream.WriteByte ((byte)(val >> 24));  	stream.WriteByte ((byte)(val >> 16));  	stream.WriteByte ((byte)(val >> 8));  	stream.WriteByte ((byte)(val >> 0));  }  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,WritePackedInteger,The following statement contains a magic number: if (val >= -1048576 && val < 1048576) {  	val += 1048576;  	stream.WriteByte ((byte)(0xC0 + (val >> 16)));  	stream.WriteByte ((byte)(val >> 8));  	stream.WriteByte ((byte)val);  } else {  	stream.WriteByte (0xFF);  	stream.WriteByte ((byte)(val >> 24));  	stream.WriteByte ((byte)(val >> 16));  	stream.WriteByte ((byte)(val >> 8));  	stream.WriteByte ((byte)(val >> 0));  }  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,WritePackedInteger,The following statement contains a magic number: if (val >= -1048576 && val < 1048576) {  	val += 1048576;  	stream.WriteByte ((byte)(0xC0 + (val >> 16)));  	stream.WriteByte ((byte)(val >> 8));  	stream.WriteByte ((byte)val);  } else {  	stream.WriteByte (0xFF);  	stream.WriteByte ((byte)(val >> 24));  	stream.WriteByte ((byte)(val >> 16));  	stream.WriteByte ((byte)(val >> 8));  	stream.WriteByte ((byte)(val >> 0));  }  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,WritePackedInteger,The following statement contains a magic number: if (val >= -1048576 && val < 1048576) {  	val += 1048576;  	stream.WriteByte ((byte)(0xC0 + (val >> 16)));  	stream.WriteByte ((byte)(val >> 8));  	stream.WriteByte ((byte)val);  } else {  	stream.WriteByte (0xFF);  	stream.WriteByte ((byte)(val >> 24));  	stream.WriteByte ((byte)(val >> 16));  	stream.WriteByte ((byte)(val >> 8));  	stream.WriteByte ((byte)(val >> 0));  }  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,WritePackedInteger,The following statement contains a magic number: if (val >= -1048576 && val < 1048576) {  	val += 1048576;  	stream.WriteByte ((byte)(0xC0 + (val >> 16)));  	stream.WriteByte ((byte)(val >> 8));  	stream.WriteByte ((byte)val);  } else {  	stream.WriteByte (0xFF);  	stream.WriteByte ((byte)(val >> 24));  	stream.WriteByte ((byte)(val >> 16));  	stream.WriteByte ((byte)(val >> 8));  	stream.WriteByte ((byte)(val >> 0));  }  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,WritePackedInteger,The following statement contains a magic number: val += 1048576;  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,WritePackedInteger,The following statement contains a magic number: stream.WriteByte ((byte)(0xC0 + (val >> 16)));  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,WritePackedInteger,The following statement contains a magic number: stream.WriteByte ((byte)(val >> 8));  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,WritePackedInteger,The following statement contains a magic number: stream.WriteByte ((byte)(val >> 24));  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,WritePackedInteger,The following statement contains a magic number: stream.WriteByte ((byte)(val >> 16));  
Magic Number,ILRepacking,LineNumberWriter,F:\newReposMay17\gluck_il-repack\ILRepack\LineNumberWriter.cs,WritePackedInteger,The following statement contains a magic number: stream.WriteByte ((byte)(val >> 8));  
Magic Number,ILRepacking,ILRepack,F:\newReposMay17\gluck_il-repack\ILRepack\ILRepack.cs,IsAspResourceEntry,The following statement contains a magic number: return exist.Id == 101 && parents.Count == 1 && parents [0].Id == 3771;  
Magic Number,ILRepacking,ILRepack,F:\newReposMay17\gluck_il-repack\ILRepack\ILRepack.cs,IsAspResourceEntry,The following statement contains a magic number: return exist.Id == 101 && parents.Count == 1 && parents [0].Id == 3771;  
Magic Number,ILRepacking,ILRepack,F:\newReposMay17\gluck_il-repack\ILRepack\ILRepack.cs,IsVersionInfoResource,The following statement contains a magic number: return exist.Id == 0 && parents.Count == 2 && parents [0].Id == 16 && parents [1].Id == 1;  
Magic Number,ILRepacking,ILRepack,F:\newReposMay17\gluck_il-repack\ILRepack\ILRepack.cs,IsVersionInfoResource,The following statement contains a magic number: return exist.Id == 0 && parents.Count == 2 && parents [0].Id == 16 && parents [1].Id == 1;  
Magic Number,ILRepacking,ILRepack,F:\newReposMay17\gluck_il-repack\ILRepack\ILRepack.cs,FixStr,The following statement contains a magic number: if (String.IsNullOrEmpty (content) || content.Length > 512 || content.IndexOf ("' ") == -1 || content.StartsWith ("System."))  	return content;  
Magic Number,ILRepacking,ILRepack,F:\newReposMay17\gluck_il-repack\ILRepack\ILRepack.cs,FixStr,The following statement contains a magic number: if (match.Success) {  	string type = match.Groups [1].Value;  	string targetAssemblyName = TargetAssemblyDefinition.FullName;  	if (javaAttribute)  		targetAssemblyName = targetAssemblyName.Replace ('.'' '/') + ";";  	if (MergedAssemblies.Any (x => x.Name.Name == match.Groups [2].Value)) {  		return type + "' " + targetAssemblyName;  	}  }  
Magic Number,ILRepacking,ILRepack,F:\newReposMay17\gluck_il-repack\ILRepack\ILRepack.cs,FixStr,The following statement contains a magic number: if (MergedAssemblies.Any (x => x.Name.Name == match.Groups [2].Value)) {  	return type + "' " + targetAssemblyName;  }  
Magic Number,ILRepacking,ReferenceFixator,F:\newReposMay17\gluck_il-repack\ILRepack\ReferenceFixator.cs,FixReferences,The following statement contains a magic number: if (securitydeclarations.Count > 0) {  	foreach (SecurityDeclaration sd in securitydeclarations) {  		foreach (SecurityAttribute sa in sd.SecurityAttributes) {  			sa.AttributeType = Fix (sa.AttributeType);  			FixReferences (sa.Fields);  			if (sa.HasFields)  				throw new NotSupportedException ();  			FixReferences (sa.Properties);  			if (sa.HasProperties) {  				foreach (var prop in sa.Properties.ToArray ()) {  					if (prop.Name == "PublicKeyBlob") {  						if (_repackContext.TargetAssemblyDefinition.Name.HasPublicKey) {  							if (targetAssemblyPublicKeyBlobString == null)  								foreach (byte b in _repackContext.TargetAssemblyDefinition.Name.PublicKey)  									targetAssemblyPublicKeyBlobString += b.ToString ("X").PadLeft (2' '0');  							if (prop.Argument.Type.FullName != "System.String")  								throw new NotSupportedException ("Invalid type of argument' expected string");  							CustomAttributeNamedArgument newProp = new CustomAttributeNamedArgument (prop.Name' new CustomAttributeArgument (prop.Argument.Type' targetAssemblyPublicKeyBlobString));  							sa.Properties.Remove (prop);  							sa.Properties.Add (newProp);  						} else {  							_logger.Warn ("SecurityPermission with PublicKeyBlob found but target has no strong name!");  						}  					}  				}  			}  		}  	}  	if ((_repackContext.TargetAssemblyMainModule.Runtime == TargetRuntime.Net_1_0) || (_repackContext.TargetAssemblyMainModule.Runtime == TargetRuntime.Net_1_1)) {  		SecurityDeclaration[] sdArray = securitydeclarations.ToArray ();  		securitydeclarations.Clear ();  		foreach (SecurityDeclaration sd in sdArray)  			securitydeclarations.Add (PermissionsetHelper.Permission2XmlSet (sd' _repackContext.TargetAssemblyMainModule));  	}  }  
Magic Number,ILRepacking,ReferenceFixator,F:\newReposMay17\gluck_il-repack\ILRepack\ReferenceFixator.cs,FixReferences,The following statement contains a magic number: foreach (SecurityDeclaration sd in securitydeclarations) {  	foreach (SecurityAttribute sa in sd.SecurityAttributes) {  		sa.AttributeType = Fix (sa.AttributeType);  		FixReferences (sa.Fields);  		if (sa.HasFields)  			throw new NotSupportedException ();  		FixReferences (sa.Properties);  		if (sa.HasProperties) {  			foreach (var prop in sa.Properties.ToArray ()) {  				if (prop.Name == "PublicKeyBlob") {  					if (_repackContext.TargetAssemblyDefinition.Name.HasPublicKey) {  						if (targetAssemblyPublicKeyBlobString == null)  							foreach (byte b in _repackContext.TargetAssemblyDefinition.Name.PublicKey)  								targetAssemblyPublicKeyBlobString += b.ToString ("X").PadLeft (2' '0');  						if (prop.Argument.Type.FullName != "System.String")  							throw new NotSupportedException ("Invalid type of argument' expected string");  						CustomAttributeNamedArgument newProp = new CustomAttributeNamedArgument (prop.Name' new CustomAttributeArgument (prop.Argument.Type' targetAssemblyPublicKeyBlobString));  						sa.Properties.Remove (prop);  						sa.Properties.Add (newProp);  					} else {  						_logger.Warn ("SecurityPermission with PublicKeyBlob found but target has no strong name!");  					}  				}  			}  		}  	}  }  
Magic Number,ILRepacking,ReferenceFixator,F:\newReposMay17\gluck_il-repack\ILRepack\ReferenceFixator.cs,FixReferences,The following statement contains a magic number: foreach (SecurityAttribute sa in sd.SecurityAttributes) {  	sa.AttributeType = Fix (sa.AttributeType);  	FixReferences (sa.Fields);  	if (sa.HasFields)  		throw new NotSupportedException ();  	FixReferences (sa.Properties);  	if (sa.HasProperties) {  		foreach (var prop in sa.Properties.ToArray ()) {  			if (prop.Name == "PublicKeyBlob") {  				if (_repackContext.TargetAssemblyDefinition.Name.HasPublicKey) {  					if (targetAssemblyPublicKeyBlobString == null)  						foreach (byte b in _repackContext.TargetAssemblyDefinition.Name.PublicKey)  							targetAssemblyPublicKeyBlobString += b.ToString ("X").PadLeft (2' '0');  					if (prop.Argument.Type.FullName != "System.String")  						throw new NotSupportedException ("Invalid type of argument' expected string");  					CustomAttributeNamedArgument newProp = new CustomAttributeNamedArgument (prop.Name' new CustomAttributeArgument (prop.Argument.Type' targetAssemblyPublicKeyBlobString));  					sa.Properties.Remove (prop);  					sa.Properties.Add (newProp);  				} else {  					_logger.Warn ("SecurityPermission with PublicKeyBlob found but target has no strong name!");  				}  			}  		}  	}  }  
Magic Number,ILRepacking,ReferenceFixator,F:\newReposMay17\gluck_il-repack\ILRepack\ReferenceFixator.cs,FixReferences,The following statement contains a magic number: if (sa.HasProperties) {  	foreach (var prop in sa.Properties.ToArray ()) {  		if (prop.Name == "PublicKeyBlob") {  			if (_repackContext.TargetAssemblyDefinition.Name.HasPublicKey) {  				if (targetAssemblyPublicKeyBlobString == null)  					foreach (byte b in _repackContext.TargetAssemblyDefinition.Name.PublicKey)  						targetAssemblyPublicKeyBlobString += b.ToString ("X").PadLeft (2' '0');  				if (prop.Argument.Type.FullName != "System.String")  					throw new NotSupportedException ("Invalid type of argument' expected string");  				CustomAttributeNamedArgument newProp = new CustomAttributeNamedArgument (prop.Name' new CustomAttributeArgument (prop.Argument.Type' targetAssemblyPublicKeyBlobString));  				sa.Properties.Remove (prop);  				sa.Properties.Add (newProp);  			} else {  				_logger.Warn ("SecurityPermission with PublicKeyBlob found but target has no strong name!");  			}  		}  	}  }  
Magic Number,ILRepacking,ReferenceFixator,F:\newReposMay17\gluck_il-repack\ILRepack\ReferenceFixator.cs,FixReferences,The following statement contains a magic number: foreach (var prop in sa.Properties.ToArray ()) {  	if (prop.Name == "PublicKeyBlob") {  		if (_repackContext.TargetAssemblyDefinition.Name.HasPublicKey) {  			if (targetAssemblyPublicKeyBlobString == null)  				foreach (byte b in _repackContext.TargetAssemblyDefinition.Name.PublicKey)  					targetAssemblyPublicKeyBlobString += b.ToString ("X").PadLeft (2' '0');  			if (prop.Argument.Type.FullName != "System.String")  				throw new NotSupportedException ("Invalid type of argument' expected string");  			CustomAttributeNamedArgument newProp = new CustomAttributeNamedArgument (prop.Name' new CustomAttributeArgument (prop.Argument.Type' targetAssemblyPublicKeyBlobString));  			sa.Properties.Remove (prop);  			sa.Properties.Add (newProp);  		} else {  			_logger.Warn ("SecurityPermission with PublicKeyBlob found but target has no strong name!");  		}  	}  }  
Magic Number,ILRepacking,ReferenceFixator,F:\newReposMay17\gluck_il-repack\ILRepack\ReferenceFixator.cs,FixReferences,The following statement contains a magic number: if (prop.Name == "PublicKeyBlob") {  	if (_repackContext.TargetAssemblyDefinition.Name.HasPublicKey) {  		if (targetAssemblyPublicKeyBlobString == null)  			foreach (byte b in _repackContext.TargetAssemblyDefinition.Name.PublicKey)  				targetAssemblyPublicKeyBlobString += b.ToString ("X").PadLeft (2' '0');  		if (prop.Argument.Type.FullName != "System.String")  			throw new NotSupportedException ("Invalid type of argument' expected string");  		CustomAttributeNamedArgument newProp = new CustomAttributeNamedArgument (prop.Name' new CustomAttributeArgument (prop.Argument.Type' targetAssemblyPublicKeyBlobString));  		sa.Properties.Remove (prop);  		sa.Properties.Add (newProp);  	} else {  		_logger.Warn ("SecurityPermission with PublicKeyBlob found but target has no strong name!");  	}  }  
Magic Number,ILRepacking,ReferenceFixator,F:\newReposMay17\gluck_il-repack\ILRepack\ReferenceFixator.cs,FixReferences,The following statement contains a magic number: if (_repackContext.TargetAssemblyDefinition.Name.HasPublicKey) {  	if (targetAssemblyPublicKeyBlobString == null)  		foreach (byte b in _repackContext.TargetAssemblyDefinition.Name.PublicKey)  			targetAssemblyPublicKeyBlobString += b.ToString ("X").PadLeft (2' '0');  	if (prop.Argument.Type.FullName != "System.String")  		throw new NotSupportedException ("Invalid type of argument' expected string");  	CustomAttributeNamedArgument newProp = new CustomAttributeNamedArgument (prop.Name' new CustomAttributeArgument (prop.Argument.Type' targetAssemblyPublicKeyBlobString));  	sa.Properties.Remove (prop);  	sa.Properties.Add (newProp);  } else {  	_logger.Warn ("SecurityPermission with PublicKeyBlob found but target has no strong name!");  }  
Magic Number,ILRepacking,ReferenceFixator,F:\newReposMay17\gluck_il-repack\ILRepack\ReferenceFixator.cs,FixReferences,The following statement contains a magic number: if (targetAssemblyPublicKeyBlobString == null)  	foreach (byte b in _repackContext.TargetAssemblyDefinition.Name.PublicKey)  		targetAssemblyPublicKeyBlobString += b.ToString ("X").PadLeft (2' '0');  
Magic Number,ILRepacking,ReferenceFixator,F:\newReposMay17\gluck_il-repack\ILRepack\ReferenceFixator.cs,FixReferences,The following statement contains a magic number: foreach (byte b in _repackContext.TargetAssemblyDefinition.Name.PublicKey)  	targetAssemblyPublicKeyBlobString += b.ToString ("X").PadLeft (2' '0');  
Magic Number,ILRepacking,ReferenceFixator,F:\newReposMay17\gluck_il-repack\ILRepack\ReferenceFixator.cs,FixReferences,The following statement contains a magic number: targetAssemblyPublicKeyBlobString += b.ToString ("X").PadLeft (2' '0');  
Magic Number,ILRepacking,RepackImporter,F:\newReposMay17\gluck_il-repack\ILRepack\RepackImporter.cs,FixAspNetOffset,The following statement contains a magic number: if (operand.Name == "WriteUTF8ResourceString" || operand.Name == "CreateResourceBasedLiteralControl") {  	var fullName = operand.FullName;  	if (fullName == "System.Void System.Web.UI.TemplateControl::WriteUTF8ResourceString(System.Web.UI.HtmlTextWriter'System.Int32'System.Int32'System.Boolean)" || fullName == "System.Web.UI.LiteralControl System.Web.UI.TemplateControl::CreateResourceBasedLiteralControl(System.Int32'System.Int32'System.Boolean)") {  		int offset;  		if (_aspOffsets.TryGetValue (parent.Module.Assembly' out offset)) {  			int prev = (int)instructions [instructions.Count - 4].Operand;  			instructions [instructions.Count - 4].Operand = prev + offset;  		}  	}  }  
Magic Number,ILRepacking,RepackImporter,F:\newReposMay17\gluck_il-repack\ILRepack\RepackImporter.cs,FixAspNetOffset,The following statement contains a magic number: if (operand.Name == "WriteUTF8ResourceString" || operand.Name == "CreateResourceBasedLiteralControl") {  	var fullName = operand.FullName;  	if (fullName == "System.Void System.Web.UI.TemplateControl::WriteUTF8ResourceString(System.Web.UI.HtmlTextWriter'System.Int32'System.Int32'System.Boolean)" || fullName == "System.Web.UI.LiteralControl System.Web.UI.TemplateControl::CreateResourceBasedLiteralControl(System.Int32'System.Int32'System.Boolean)") {  		int offset;  		if (_aspOffsets.TryGetValue (parent.Module.Assembly' out offset)) {  			int prev = (int)instructions [instructions.Count - 4].Operand;  			instructions [instructions.Count - 4].Operand = prev + offset;  		}  	}  }  
Magic Number,ILRepacking,RepackImporter,F:\newReposMay17\gluck_il-repack\ILRepack\RepackImporter.cs,FixAspNetOffset,The following statement contains a magic number: if (fullName == "System.Void System.Web.UI.TemplateControl::WriteUTF8ResourceString(System.Web.UI.HtmlTextWriter'System.Int32'System.Int32'System.Boolean)" || fullName == "System.Web.UI.LiteralControl System.Web.UI.TemplateControl::CreateResourceBasedLiteralControl(System.Int32'System.Int32'System.Boolean)") {  	int offset;  	if (_aspOffsets.TryGetValue (parent.Module.Assembly' out offset)) {  		int prev = (int)instructions [instructions.Count - 4].Operand;  		instructions [instructions.Count - 4].Operand = prev + offset;  	}  }  
Magic Number,ILRepacking,RepackImporter,F:\newReposMay17\gluck_il-repack\ILRepack\RepackImporter.cs,FixAspNetOffset,The following statement contains a magic number: if (fullName == "System.Void System.Web.UI.TemplateControl::WriteUTF8ResourceString(System.Web.UI.HtmlTextWriter'System.Int32'System.Int32'System.Boolean)" || fullName == "System.Web.UI.LiteralControl System.Web.UI.TemplateControl::CreateResourceBasedLiteralControl(System.Int32'System.Int32'System.Boolean)") {  	int offset;  	if (_aspOffsets.TryGetValue (parent.Module.Assembly' out offset)) {  		int prev = (int)instructions [instructions.Count - 4].Operand;  		instructions [instructions.Count - 4].Operand = prev + offset;  	}  }  
Magic Number,ILRepacking,RepackImporter,F:\newReposMay17\gluck_il-repack\ILRepack\RepackImporter.cs,FixAspNetOffset,The following statement contains a magic number: if (_aspOffsets.TryGetValue (parent.Module.Assembly' out offset)) {  	int prev = (int)instructions [instructions.Count - 4].Operand;  	instructions [instructions.Count - 4].Operand = prev + offset;  }  
Magic Number,ILRepacking,RepackImporter,F:\newReposMay17\gluck_il-repack\ILRepack\RepackImporter.cs,FixAspNetOffset,The following statement contains a magic number: if (_aspOffsets.TryGetValue (parent.Module.Assembly' out offset)) {  	int prev = (int)instructions [instructions.Count - 4].Operand;  	instructions [instructions.Count - 4].Operand = prev + offset;  }  
Magic Number,ILRepacking,RepackImporter,F:\newReposMay17\gluck_il-repack\ILRepack\RepackImporter.cs,FixAspNetOffset,The following statement contains a magic number: instructions [instructions.Count - 4].Operand = prev + offset;  
Magic Number,ILRepacking,RepackOptions,F:\newReposMay17\gluck_il-repack\ILRepack\RepackOptions.cs,AllowDuplicateType,The following statement contains a magic number: if (typeName.EndsWith (".*")) {  	allowedDuplicateNameSpaces.Add (typeName.Substring (0' typeName.Length - 2));  } else {  	allowedDuplicateTypes [typeName] = typeName;  }  
Magic Number,ILRepacking,RepackOptions,F:\newReposMay17\gluck_il-repack\ILRepack\RepackOptions.cs,AllowDuplicateType,The following statement contains a magic number: allowedDuplicateNameSpaces.Add (typeName.Substring (0' typeName.Length - 2));  
Magic Number,ILRepacking,ResReader,F:\newReposMay17\gluck_il-repack\ILRepack\ResReader.cs,ResReader,The following statement contains a magic number: try {  	// Read ResourceManager header  	// Check for magic number  	int magicNum = _store.ReadInt32 ();  	if (magicNum != ResourceManager.MagicNumber)  		throw new ArgumentException ("Resources_StreamNotValid");  	// Assuming this is ResourceManager header V1 or greater' hopefully  	// after the version number there is a number of bytes to skip  	// to bypass the rest of the ResMgr header.  	int resMgrHeaderVersion = _store.ReadInt32 ();  	if (resMgrHeaderVersion > 1) {  		int numBytesToSkip = _store.ReadInt32 ();  		_store.BaseStream.Seek (numBytesToSkip' SeekOrigin.Current);  	} else {  		SkipInt32 ();  		// We don't care about numBytesToSkip.  		// Read in type name for a suitable ResourceReader  		// Note ResourceWriter & InternalResGen use different Strings.  		String readerType = _store.ReadString ();  		// Skip over type name for a suitable ResourceSet  		SkipString ();  	}  	// Read RuntimeResourceSet header  	// Do file version check  	int version = _store.ReadInt32 ();  	if (version != 2 && version != 1)  		throw new ArgumentException ("Arg_ResourceFileUnsupportedVersion");  	_version = version;  	_numResources = _store.ReadInt32 ();  	// Read type positions into type positions array.  	// But delay initialize the type table.  	int numTypes = _store.ReadInt32 ();  	_typeNamePositions = new int[numTypes];  	for (int i = 0; i < numTypes; i++) {  		_typeNamePositions [i] = (int)_store.BaseStream.Position;  		// Skip over the Strings in the file.  Don't create types.  		SkipString ();  	}  	// Prepare to read in the array of name hashes  	//  Note that the name hashes array is aligned to 8 bytes so  	//  we can use pointers into it on 64 bit machines. (4 bytes  	//  may be sufficient' but let's plan for the future)  	//  Skip over alignment stuff.  All public .resources files  	//  should be aligned   No need to verify the byte values.  	long pos = _store.BaseStream.Position;  	int alignBytes = ((int)pos) & 7;  	if (alignBytes != 0) {  		for (int i = 0; i < 8 - alignBytes; i++) {  			_store.ReadByte ();  		}  	}  	// Read in the array of name hashes  	_nameHashes = new int[_numResources];  	for (int i = 0; i < _numResources; i++)  		_nameHashes [i] = _store.ReadInt32 ();  	// Read in the array of relative positions for all the names.  	_namePositions = new int[_numResources];  	for (int i = 0; i < _numResources; i++)  		_namePositions [i] = _store.ReadInt32 ();  	// Read location of data section.  	_dataSectionOffset = _store.ReadInt32 ();  	// Store current location as start of name section  	_nameSectionOffset = _store.BaseStream.Position;  } catch (EndOfStreamException) {  	throw new BadImageFormatException ("BadImageFormat_ResourcesHeaderCorrupted");  } catch (IndexOutOfRangeException) {  	throw new BadImageFormatException ("BadImageFormat_ResourcesHeaderCorrupted");  }  
Magic Number,ILRepacking,ResReader,F:\newReposMay17\gluck_il-repack\ILRepack\ResReader.cs,ResReader,The following statement contains a magic number: try {  	// Read ResourceManager header  	// Check for magic number  	int magicNum = _store.ReadInt32 ();  	if (magicNum != ResourceManager.MagicNumber)  		throw new ArgumentException ("Resources_StreamNotValid");  	// Assuming this is ResourceManager header V1 or greater' hopefully  	// after the version number there is a number of bytes to skip  	// to bypass the rest of the ResMgr header.  	int resMgrHeaderVersion = _store.ReadInt32 ();  	if (resMgrHeaderVersion > 1) {  		int numBytesToSkip = _store.ReadInt32 ();  		_store.BaseStream.Seek (numBytesToSkip' SeekOrigin.Current);  	} else {  		SkipInt32 ();  		// We don't care about numBytesToSkip.  		// Read in type name for a suitable ResourceReader  		// Note ResourceWriter & InternalResGen use different Strings.  		String readerType = _store.ReadString ();  		// Skip over type name for a suitable ResourceSet  		SkipString ();  	}  	// Read RuntimeResourceSet header  	// Do file version check  	int version = _store.ReadInt32 ();  	if (version != 2 && version != 1)  		throw new ArgumentException ("Arg_ResourceFileUnsupportedVersion");  	_version = version;  	_numResources = _store.ReadInt32 ();  	// Read type positions into type positions array.  	// But delay initialize the type table.  	int numTypes = _store.ReadInt32 ();  	_typeNamePositions = new int[numTypes];  	for (int i = 0; i < numTypes; i++) {  		_typeNamePositions [i] = (int)_store.BaseStream.Position;  		// Skip over the Strings in the file.  Don't create types.  		SkipString ();  	}  	// Prepare to read in the array of name hashes  	//  Note that the name hashes array is aligned to 8 bytes so  	//  we can use pointers into it on 64 bit machines. (4 bytes  	//  may be sufficient' but let's plan for the future)  	//  Skip over alignment stuff.  All public .resources files  	//  should be aligned   No need to verify the byte values.  	long pos = _store.BaseStream.Position;  	int alignBytes = ((int)pos) & 7;  	if (alignBytes != 0) {  		for (int i = 0; i < 8 - alignBytes; i++) {  			_store.ReadByte ();  		}  	}  	// Read in the array of name hashes  	_nameHashes = new int[_numResources];  	for (int i = 0; i < _numResources; i++)  		_nameHashes [i] = _store.ReadInt32 ();  	// Read in the array of relative positions for all the names.  	_namePositions = new int[_numResources];  	for (int i = 0; i < _numResources; i++)  		_namePositions [i] = _store.ReadInt32 ();  	// Read location of data section.  	_dataSectionOffset = _store.ReadInt32 ();  	// Store current location as start of name section  	_nameSectionOffset = _store.BaseStream.Position;  } catch (EndOfStreamException) {  	throw new BadImageFormatException ("BadImageFormat_ResourcesHeaderCorrupted");  } catch (IndexOutOfRangeException) {  	throw new BadImageFormatException ("BadImageFormat_ResourcesHeaderCorrupted");  }  
Magic Number,ILRepacking,ResReader,F:\newReposMay17\gluck_il-repack\ILRepack\ResReader.cs,ResReader,The following statement contains a magic number: try {  	// Read ResourceManager header  	// Check for magic number  	int magicNum = _store.ReadInt32 ();  	if (magicNum != ResourceManager.MagicNumber)  		throw new ArgumentException ("Resources_StreamNotValid");  	// Assuming this is ResourceManager header V1 or greater' hopefully  	// after the version number there is a number of bytes to skip  	// to bypass the rest of the ResMgr header.  	int resMgrHeaderVersion = _store.ReadInt32 ();  	if (resMgrHeaderVersion > 1) {  		int numBytesToSkip = _store.ReadInt32 ();  		_store.BaseStream.Seek (numBytesToSkip' SeekOrigin.Current);  	} else {  		SkipInt32 ();  		// We don't care about numBytesToSkip.  		// Read in type name for a suitable ResourceReader  		// Note ResourceWriter & InternalResGen use different Strings.  		String readerType = _store.ReadString ();  		// Skip over type name for a suitable ResourceSet  		SkipString ();  	}  	// Read RuntimeResourceSet header  	// Do file version check  	int version = _store.ReadInt32 ();  	if (version != 2 && version != 1)  		throw new ArgumentException ("Arg_ResourceFileUnsupportedVersion");  	_version = version;  	_numResources = _store.ReadInt32 ();  	// Read type positions into type positions array.  	// But delay initialize the type table.  	int numTypes = _store.ReadInt32 ();  	_typeNamePositions = new int[numTypes];  	for (int i = 0; i < numTypes; i++) {  		_typeNamePositions [i] = (int)_store.BaseStream.Position;  		// Skip over the Strings in the file.  Don't create types.  		SkipString ();  	}  	// Prepare to read in the array of name hashes  	//  Note that the name hashes array is aligned to 8 bytes so  	//  we can use pointers into it on 64 bit machines. (4 bytes  	//  may be sufficient' but let's plan for the future)  	//  Skip over alignment stuff.  All public .resources files  	//  should be aligned   No need to verify the byte values.  	long pos = _store.BaseStream.Position;  	int alignBytes = ((int)pos) & 7;  	if (alignBytes != 0) {  		for (int i = 0; i < 8 - alignBytes; i++) {  			_store.ReadByte ();  		}  	}  	// Read in the array of name hashes  	_nameHashes = new int[_numResources];  	for (int i = 0; i < _numResources; i++)  		_nameHashes [i] = _store.ReadInt32 ();  	// Read in the array of relative positions for all the names.  	_namePositions = new int[_numResources];  	for (int i = 0; i < _numResources; i++)  		_namePositions [i] = _store.ReadInt32 ();  	// Read location of data section.  	_dataSectionOffset = _store.ReadInt32 ();  	// Store current location as start of name section  	_nameSectionOffset = _store.BaseStream.Position;  } catch (EndOfStreamException) {  	throw new BadImageFormatException ("BadImageFormat_ResourcesHeaderCorrupted");  } catch (IndexOutOfRangeException) {  	throw new BadImageFormatException ("BadImageFormat_ResourcesHeaderCorrupted");  }  
Magic Number,ILRepacking,ResReader,F:\newReposMay17\gluck_il-repack\ILRepack\ResReader.cs,ResReader,The following statement contains a magic number: if (version != 2 && version != 1)  	throw new ArgumentException ("Arg_ResourceFileUnsupportedVersion");  
Magic Number,ILRepacking,ResReader,F:\newReposMay17\gluck_il-repack\ILRepack\ResReader.cs,ResReader,The following statement contains a magic number: if (alignBytes != 0) {  	for (int i = 0; i < 8 - alignBytes; i++) {  		_store.ReadByte ();  	}  }  
Magic Number,ILRepacking,ResReader,F:\newReposMay17\gluck_il-repack\ILRepack\ResReader.cs,ResReader,The following statement contains a magic number: for (int i = 0; i < 8 - alignBytes; i++) {  	_store.ReadByte ();  }  
Magic Number,ILRepacking,ResReader,F:\newReposMay17\gluck_il-repack\ILRepack\ResReader.cs,SkipInt32,The following statement contains a magic number: _store.BaseStream.Seek (4' SeekOrigin.Current);  
Magic Number,ILRepacking,ResReader,F:\newReposMay17\gluck_il-repack\ILRepack\ResReader.cs,GetObject_V1,The following statement contains a magic number: lock (this) {  	_store.BaseStream.Seek (_dataSectionOffset + res.dataPos' SeekOrigin.Begin);  	int typeIndex = Read7BitEncodedInt ();  	if (typeIndex == -1)  		return null;  	var typeName = TypeNameFromTypeIndex (typeIndex);  	var type = Type.GetType (typeName' true);  	if (type == typeof(string))  		return this._store.ReadString ();  	if (type == typeof(int))  		return this._store.ReadInt32 ();  	if (type == typeof(byte))  		return this._store.ReadByte ();  	if (type == typeof(sbyte))  		return this._store.ReadSByte ();  	if (type == typeof(short))  		return this._store.ReadInt16 ();  	if (type == typeof(long))  		return this._store.ReadInt64 ();  	if (type == typeof(ushort))  		return this._store.ReadUInt16 ();  	if (type == typeof(uint))  		return this._store.ReadUInt32 ();  	if (type == typeof(ulong))  		return this._store.ReadUInt64 ();  	if (type == typeof(float))  		return this._store.ReadSingle ();  	if (type == typeof(double))  		return this._store.ReadDouble ();  	if (type == typeof(DateTime))  		return new DateTime (this._store.ReadInt64 ());  	if (type == typeof(TimeSpan))  		return new TimeSpan (this._store.ReadInt64 ());  	if (type == typeof(decimal)) {  		int[] array = new int[4];  		for (int i = 0; i < array.Length; i++) {  			array [i] = this._store.ReadInt32 ();  		}  		return new decimal (array);  	}  	// Normal serialized objects  	return _bf.Deserialize (_store.BaseStream);  }  
Magic Number,ILRepacking,ResReader,F:\newReposMay17\gluck_il-repack\ILRepack\ResReader.cs,GetObject_V1,The following statement contains a magic number: if (type == typeof(decimal)) {  	int[] array = new int[4];  	for (int i = 0; i < array.Length; i++) {  		array [i] = this._store.ReadInt32 ();  	}  	return new decimal (array);  }  
Magic Number,ILRepacking,ResReader,F:\newReposMay17\gluck_il-repack\ILRepack\ResReader.cs,Read7BitEncodedInt,The following statement contains a magic number: do {  	// Check for a corrupted stream.  Read a max of 5 bytes.  	// In a future version' add a DataFormatException.  	if (shift == 5 * 7)  		// 5 bytes max per Int32' shift += 7  		throw new FormatException ("Format_Bad7BitInt32");  	// ReadByte handles end of stream cases for us.  	b = _store.ReadByte ();  	count |= (b & 0x7F) << shift;  	shift += 7;  } while ((b & 0x80) != 0);  
Magic Number,ILRepacking,ResReader,F:\newReposMay17\gluck_il-repack\ILRepack\ResReader.cs,Read7BitEncodedInt,The following statement contains a magic number: do {  	// Check for a corrupted stream.  Read a max of 5 bytes.  	// In a future version' add a DataFormatException.  	if (shift == 5 * 7)  		// 5 bytes max per Int32' shift += 7  		throw new FormatException ("Format_Bad7BitInt32");  	// ReadByte handles end of stream cases for us.  	b = _store.ReadByte ();  	count |= (b & 0x7F) << shift;  	shift += 7;  } while ((b & 0x80) != 0);  
Magic Number,ILRepacking,ResReader,F:\newReposMay17\gluck_il-repack\ILRepack\ResReader.cs,Read7BitEncodedInt,The following statement contains a magic number: do {  	// Check for a corrupted stream.  Read a max of 5 bytes.  	// In a future version' add a DataFormatException.  	if (shift == 5 * 7)  		// 5 bytes max per Int32' shift += 7  		throw new FormatException ("Format_Bad7BitInt32");  	// ReadByte handles end of stream cases for us.  	b = _store.ReadByte ();  	count |= (b & 0x7F) << shift;  	shift += 7;  } while ((b & 0x80) != 0);  
Magic Number,ILRepacking,ResReader,F:\newReposMay17\gluck_il-repack\ILRepack\ResReader.cs,Read7BitEncodedInt,The following statement contains a magic number: if (shift == 5 * 7)  	// 5 bytes max per Int32' shift += 7  	throw new FormatException ("Format_Bad7BitInt32");  
Magic Number,ILRepacking,ResReader,F:\newReposMay17\gluck_il-repack\ILRepack\ResReader.cs,Read7BitEncodedInt,The following statement contains a magic number: if (shift == 5 * 7)  	// 5 bytes max per Int32' shift += 7  	throw new FormatException ("Format_Bad7BitInt32");  
Magic Number,ILRepacking,ResReader,F:\newReposMay17\gluck_il-repack\ILRepack\ResReader.cs,Read7BitEncodedInt,The following statement contains a magic number: shift += 7;  
Magic Number,ILRepacking,SerReader,F:\newReposMay17\gluck_il-repack\ILRepack\SerReader.cs,ParseRecord,The following statement contains a magic number: if (PendingNullCounter == 0) {  	long startPosition = reader.BaseStream.Position;  	SerialObject si = null;  	RecordTypeEnumeration nextRecordType = (RecordTypeEnumeration)reader.ReadByte ();  	switch (nextRecordType) {  	case RecordTypeEnumeration.SerializedStreamHeader:  		//header is 4 values that I wouldn't know what to do with (what type of message' what version' etc) - trash.  		reader.ReadBytes (16);  		break;  	case RecordTypeEnumeration.ClassWithID:  		//just two ints' read directly  		si = new ClassInfo ().ReadObjectId (this);  		int refObj = reader.ReadInt32 ();  		//Use the referenced object definition for data retrieval rules  		// -> this will overwrite the original values in the referenced object' but who cares - the values are trash anyway (for now).  		((ClassInfo)SerialObjectsFound [refObj]).ReadValues (this);  		break;  	case RecordTypeEnumeration.SystemClassWithMembers:  		si = new ClassInfo ().ReadMembers (this).ReadValues (this);  		break;  	case RecordTypeEnumeration.ClassWithMembers:  		si = new ClassInfo ().ReadMembers (this).ReadLibraryId (this).ReadValues (this);  		break;  	case RecordTypeEnumeration.SystemClassWithMembersAndTypes:  		si = new ClassInfo ().ReadMembers (this).ReadTypeInfo (this).ReadValues (this);  		break;  	case RecordTypeEnumeration.ClassWithMembersAndTypes:  		si = new ClassInfo ().ReadMembers (this).ReadTypeInfo (this).ReadLibraryId (this).ReadValues (this);  		break;  	case RecordTypeEnumeration.BinaryObjectString:  		si = new ObjectString ().ReadObjectId (this).ReadString (this);  		break;  	case RecordTypeEnumeration.BinaryArray:  		si = new BinaryArray ().ReadStruct (this).ReadValues (this);  		break;  	case RecordTypeEnumeration.MemberPrimitiveTyped:  		//Don't know how this can happen - I think it's for messages/remoting only  		throw new NotImplementedException ();  	case RecordTypeEnumeration.MemberReference:  		//just return the ID that was referenced.  		serialObjectReferenceID = reader.ReadInt32 ();  		break;  	case RecordTypeEnumeration.ObjectNull:  		//a single null; do nothing' as null is the default return value.  		break;  	case RecordTypeEnumeration.MessageEnd:  		//do nothing' quit. Wasn't that fun?  		endRecordReached = true;  		break;  	case RecordTypeEnumeration.BinaryLibrary:  		int newLibraryID = reader.ReadInt32 ();  		LibrariesFound.Add (newLibraryID' new BinaryLibrary {  			LibraryID = newLibraryID'  			Name = ReadAssemblyName ()  		});  		break;  	case RecordTypeEnumeration.ObjectNullMultiple256:  		//a sequence of nulls; return null' and start a counter to continue returning N nulls over the next calls.  		PendingNullCounter = reader.ReadByte () - 1;  		break;  	case RecordTypeEnumeration.ObjectNullMultiple:  		//a sequence of nulls; return null' and start a counter to continue returning N nulls over the next calls.  		PendingNullCounter = reader.ReadInt32 () - 1;  		//not yet tested: if it happens' take a look around.  		throw new NotImplementedException ();  	case RecordTypeEnumeration.ArraySinglePrimitive:  		si = new BinaryArray (BinaryTypeEnumeration.Primitive).ReadObjectId (this).ReadLengths (this).ReadPrimitiveType (this).ReadValues (this);  		break;  	case RecordTypeEnumeration.ArraySingleObject:  		si = new BinaryArray (BinaryTypeEnumeration.Object).ReadObjectId (this).ReadLengths (this).ReadValues (this);  		//not yet tested: if it happens' take a look around.  		throw new NotImplementedException ();  	case RecordTypeEnumeration.ArraySingleString:  		si = new BinaryArray (BinaryTypeEnumeration.String).ReadObjectId (this).ReadLengths (this).ReadValues (this);  		//not yet tested: if it happens' take a look around.  		throw new NotImplementedException ();  	case RecordTypeEnumeration.MethodCall:  		//messages/remoting functionality not implemented  		throw new NotImplementedException ();  	case RecordTypeEnumeration.MethodReturn:  		//messages/remoting functionality not implemented  		throw new NotImplementedException ();  	default:  		throw new Exception ("Parsing appears to have failed dramatically. Unknown record type' we must be lost in the bytestream!");  	}  	//standard: if this was a serial object' add to list and record its length.  	if (si != null) {  		if (parentObject != null)  			si.ParentObjectID = parentObject.ObjectID;  		SerialObjectsFound.Add (si.ObjectID' si);  		return si.ObjectID;  	}  } else  	PendingNullCounter--;  
Magic Number,ILRepacking,SerReader,F:\newReposMay17\gluck_il-repack\ILRepack\SerReader.cs,ParseRecord,The following statement contains a magic number: switch (nextRecordType) {  case RecordTypeEnumeration.SerializedStreamHeader:  	//header is 4 values that I wouldn't know what to do with (what type of message' what version' etc) - trash.  	reader.ReadBytes (16);  	break;  case RecordTypeEnumeration.ClassWithID:  	//just two ints' read directly  	si = new ClassInfo ().ReadObjectId (this);  	int refObj = reader.ReadInt32 ();  	//Use the referenced object definition for data retrieval rules  	// -> this will overwrite the original values in the referenced object' but who cares - the values are trash anyway (for now).  	((ClassInfo)SerialObjectsFound [refObj]).ReadValues (this);  	break;  case RecordTypeEnumeration.SystemClassWithMembers:  	si = new ClassInfo ().ReadMembers (this).ReadValues (this);  	break;  case RecordTypeEnumeration.ClassWithMembers:  	si = new ClassInfo ().ReadMembers (this).ReadLibraryId (this).ReadValues (this);  	break;  case RecordTypeEnumeration.SystemClassWithMembersAndTypes:  	si = new ClassInfo ().ReadMembers (this).ReadTypeInfo (this).ReadValues (this);  	break;  case RecordTypeEnumeration.ClassWithMembersAndTypes:  	si = new ClassInfo ().ReadMembers (this).ReadTypeInfo (this).ReadLibraryId (this).ReadValues (this);  	break;  case RecordTypeEnumeration.BinaryObjectString:  	si = new ObjectString ().ReadObjectId (this).ReadString (this);  	break;  case RecordTypeEnumeration.BinaryArray:  	si = new BinaryArray ().ReadStruct (this).ReadValues (this);  	break;  case RecordTypeEnumeration.MemberPrimitiveTyped:  	//Don't know how this can happen - I think it's for messages/remoting only  	throw new NotImplementedException ();  case RecordTypeEnumeration.MemberReference:  	//just return the ID that was referenced.  	serialObjectReferenceID = reader.ReadInt32 ();  	break;  case RecordTypeEnumeration.ObjectNull:  	//a single null; do nothing' as null is the default return value.  	break;  case RecordTypeEnumeration.MessageEnd:  	//do nothing' quit. Wasn't that fun?  	endRecordReached = true;  	break;  case RecordTypeEnumeration.BinaryLibrary:  	int newLibraryID = reader.ReadInt32 ();  	LibrariesFound.Add (newLibraryID' new BinaryLibrary {  		LibraryID = newLibraryID'  		Name = ReadAssemblyName ()  	});  	break;  case RecordTypeEnumeration.ObjectNullMultiple256:  	//a sequence of nulls; return null' and start a counter to continue returning N nulls over the next calls.  	PendingNullCounter = reader.ReadByte () - 1;  	break;  case RecordTypeEnumeration.ObjectNullMultiple:  	//a sequence of nulls; return null' and start a counter to continue returning N nulls over the next calls.  	PendingNullCounter = reader.ReadInt32 () - 1;  	//not yet tested: if it happens' take a look around.  	throw new NotImplementedException ();  case RecordTypeEnumeration.ArraySinglePrimitive:  	si = new BinaryArray (BinaryTypeEnumeration.Primitive).ReadObjectId (this).ReadLengths (this).ReadPrimitiveType (this).ReadValues (this);  	break;  case RecordTypeEnumeration.ArraySingleObject:  	si = new BinaryArray (BinaryTypeEnumeration.Object).ReadObjectId (this).ReadLengths (this).ReadValues (this);  	//not yet tested: if it happens' take a look around.  	throw new NotImplementedException ();  case RecordTypeEnumeration.ArraySingleString:  	si = new BinaryArray (BinaryTypeEnumeration.String).ReadObjectId (this).ReadLengths (this).ReadValues (this);  	//not yet tested: if it happens' take a look around.  	throw new NotImplementedException ();  case RecordTypeEnumeration.MethodCall:  	//messages/remoting functionality not implemented  	throw new NotImplementedException ();  case RecordTypeEnumeration.MethodReturn:  	//messages/remoting functionality not implemented  	throw new NotImplementedException ();  default:  	throw new Exception ("Parsing appears to have failed dramatically. Unknown record type' we must be lost in the bytestream!");  }  
Magic Number,ILRepacking,SerReader,F:\newReposMay17\gluck_il-repack\ILRepack\SerReader.cs,ParseRecord,The following statement contains a magic number: reader.ReadBytes (16);  
Magic Number,ILRepacking.Steps.ResourceProcessing,BamlGenerator,F:\newReposMay17\gluck_il-repack\ILRepack\Steps\ResourceProcessing\BamlGenerator.cs,GetImportRecords,The following statement contains a magic number: foreach (string file in importedFiles) {  	records.Add (new ElementStartRecord {  		TypeId = ResourceDictionaryTypeId'  	});  	records.Add (new PropertyWithConverterRecord {  		AttributeId = 1'  		ConverterTypeId = 64831'  		Value = GetPackUri (file)  	});  	records.Add (new ElementEndRecord ());  }  
Magic Number,ILRepacking.Steps.ResourceProcessing,BamlGenerator,F:\newReposMay17\gluck_il-repack\ILRepack\Steps\ResourceProcessing\BamlGenerator.cs,GetImportRecords,The following statement contains a magic number: records.Add (new PropertyWithConverterRecord {  	AttributeId = 1'  	ConverterTypeId = 64831'  	Value = GetPackUri (file)  });  
Magic Number,ILRepacking.Steps.SourceServerData,HttpSourceServerDescriptor,F:\newReposMay17\gluck_il-repack\ILRepack\Steps\SourceServerData\HttpSourceServerDescriptor.cs,TryParse,The following statement contains a magic number: foreach (var line in rawSrcSrv.GetLines ()) {  	if (new[] {  		InitSection'  		VariablesSection'  		SourceFilesSection'  		EndSection  	}.Contains (line)) {  		currentSection = line;  	} else {  		switch (currentSection) {  		case InitSection:  		case VariablesSection:  			var groups = VariablesRegex.Match (line).Groups;  			var key = groups [1].Value;  			var value = groups [2].Value;  			switch (key) {  			case VersionKey:  				version = int.Parse (value);  				break;  			case VersionControlKey:  				versionControl = value;  				break;  			case TargetKey:  				target = value;  				break;  			}  			break;  		case SourceFilesSection:  			sources.Add (SourceFileDescriptor.Parse (line));  			break;  		}  	}  }  
Magic Number,ILRepacking.Steps.SourceServerData,HttpSourceServerDescriptor,F:\newReposMay17\gluck_il-repack\ILRepack\Steps\SourceServerData\HttpSourceServerDescriptor.cs,TryParse,The following statement contains a magic number: if (new[] {  	InitSection'  	VariablesSection'  	SourceFilesSection'  	EndSection  }.Contains (line)) {  	currentSection = line;  } else {  	switch (currentSection) {  	case InitSection:  	case VariablesSection:  		var groups = VariablesRegex.Match (line).Groups;  		var key = groups [1].Value;  		var value = groups [2].Value;  		switch (key) {  		case VersionKey:  			version = int.Parse (value);  			break;  		case VersionControlKey:  			versionControl = value;  			break;  		case TargetKey:  			target = value;  			break;  		}  		break;  	case SourceFilesSection:  		sources.Add (SourceFileDescriptor.Parse (line));  		break;  	}  }  
Magic Number,ILRepacking.Steps.SourceServerData,HttpSourceServerDescriptor,F:\newReposMay17\gluck_il-repack\ILRepack\Steps\SourceServerData\HttpSourceServerDescriptor.cs,TryParse,The following statement contains a magic number: switch (currentSection) {  case InitSection:  case VariablesSection:  	var groups = VariablesRegex.Match (line).Groups;  	var key = groups [1].Value;  	var value = groups [2].Value;  	switch (key) {  	case VersionKey:  		version = int.Parse (value);  		break;  	case VersionControlKey:  		versionControl = value;  		break;  	case TargetKey:  		target = value;  		break;  	}  	break;  case SourceFilesSection:  	sources.Add (SourceFileDescriptor.Parse (line));  	break;  }  
Magic Number,ILRepacking.Steps.SourceServerData,HttpSourceServerDescriptor,F:\newReposMay17\gluck_il-repack\ILRepack\Steps\SourceServerData\HttpSourceServerDescriptor.cs,MergeWith,The following statement contains a magic number: return new HttpSourceServerDescriptor (Version' VersionControl' VarName (2)' files.ToArray ());  
Magic Number,ILRepacking.Steps.SourceServerData,SourceFileDescriptor,F:\newReposMay17\gluck_il-repack\ILRepack\Steps\SourceServerData\SourceFileDescriptor.cs,Parse,The following statement contains a magic number: return new SourceFileDescriptor (new[] {  	groups [1].Value  }.Concat (groups [3].Captures.Cast<Capture> ().Select (capture => capture.Value)));  
Missing Default,ILRepacking,ILRepack,F:\newReposMay17\gluck_il-repack\ILRepack\ILRepack.cs,Repack,The following switch statement is missing a default case: switch (Options.TargetKind.Value) {  case Kind.Dll:  	kind = ModuleKind.Dll;  	break;  case Kind.Exe:  	kind = ModuleKind.Console;  	break;  case Kind.WinExe:  	kind = ModuleKind.Windows;  	break;  }  
Missing Default,ILRepacking,ReferenceFixator,F:\newReposMay17\gluck_il-repack\ILRepack\ReferenceFixator.cs,FixReferences,The following switch statement is missing a default case: switch (eh.HandlerType) {  case ExceptionHandlerType.Catch:  	eh.CatchType = Fix (eh.CatchType);  	break;  }  
Missing Default,ILRepacking,RepackImporter,F:\newReposMay17\gluck_il-repack\ILRepack\RepackImporter.cs,CloneTo,The following switch statement is missing a default case: switch (eh.HandlerType) {  case ExceptionHandlerType.Catch:  	neh.CatchType = Import (eh.CatchType' parent);  	break;  case ExceptionHandlerType.Filter:  	neh.FilterStart = GetInstruction (body' nb' eh.FilterStart);  	break;  }  
Missing Default,ILRepacking,ResReader,F:\newReposMay17\gluck_il-repack\ILRepack\ResReader.cs,GetObject_V2,The following switch statement is missing a default case: switch (typeCode) {  case ResourceTypeCode.Null:  	return null;  case ResourceTypeCode.String:  	return _store.ReadString ();  case ResourceTypeCode.Boolean:  	return _store.ReadBoolean ();  case ResourceTypeCode.Char:  	return (char)_store.ReadUInt16 ();  case ResourceTypeCode.Byte:  	return _store.ReadByte ();  case ResourceTypeCode.SByte:  	return _store.ReadSByte ();  case ResourceTypeCode.Int16:  	return _store.ReadInt16 ();  case ResourceTypeCode.UInt16:  	return _store.ReadUInt16 ();  case ResourceTypeCode.Int32:  	return _store.ReadInt32 ();  case ResourceTypeCode.UInt32:  	return _store.ReadUInt32 ();  case ResourceTypeCode.Int64:  	return _store.ReadInt64 ();  case ResourceTypeCode.UInt64:  	return _store.ReadUInt64 ();  case ResourceTypeCode.Single:  	return _store.ReadSingle ();  case ResourceTypeCode.Double:  	return _store.ReadDouble ();  case ResourceTypeCode.Decimal:  	return _store.ReadDecimal ();  case ResourceTypeCode.DateTime:  	// Use DateTime's ToBinary & FromBinary.  	Int64 data = _store.ReadInt64 ();  	return DateTime.FromBinary (data);  case ResourceTypeCode.TimeSpan:  	Int64 ticks = _store.ReadInt64 ();  	return new TimeSpan (ticks);  // Special types  case ResourceTypeCode.ByteArray: {  	int len = _store.ReadInt32 ();  	return _store.ReadBytes (len);  }  case ResourceTypeCode.Stream: {  	int len = _store.ReadInt32 ();  	byte[] bytes = _store.ReadBytes (len);  	// Lifetime of memory == lifetime of this stream.  	return new MemoryStream (bytes);  }  }  
Missing Default,ILRepacking,TypeHelper,F:\newReposMay17\gluck_il-repack\ILRepack\SerReader.cs,GetTypeAdditionalInfo,The following switch statement is missing a default case: switch (typeHolder.BinaryType) {  case BinaryTypeEnumeration.Primitive:  	typeHolder.PrimitiveType = (PrimitiveTypeEnumeration)analyzer.reader.ReadByte ();  	break;  case BinaryTypeEnumeration.String:  	break;  case BinaryTypeEnumeration.Object:  	break;  case BinaryTypeEnumeration.SystemClass:  	typeHolder.TypeInfo = new ClassTypeInfo ();  	typeHolder.TypeInfo.TypeName = analyzer.ReadMarkString ();  	break;  case BinaryTypeEnumeration.Class:  	typeHolder.TypeInfo = new ClassTypeInfo ();  	typeHolder.TypeInfo.TypeName = analyzer.ReadMarkString ();  	int libraryId = analyzer.reader.ReadInt32 ();  	analyzer.FixTypeName (analyzer.LibrariesFound [libraryId].Name' typeHolder.TypeInfo.TypeName);  	break;  case BinaryTypeEnumeration.ObjectArray:  	break;  case BinaryTypeEnumeration.StringArray:  	break;  case BinaryTypeEnumeration.PrimitiveArray:  	typeHolder.PrimitiveType = (PrimitiveTypeEnumeration)analyzer.reader.ReadByte ();  	break;  }  
Missing Default,ILRepacking,TypeHelper,F:\newReposMay17\gluck_il-repack\ILRepack\SerReader.cs,GetTypeValue,The following switch statement is missing a default case: switch (typeHolder.BinaryType) {  case BinaryTypeEnumeration.Primitive:  	switch (typeHolder.PrimitiveType) {  	case PrimitiveTypeEnumeration.Boolean:  		valueHolder.Value = analyzer.reader.ReadBoolean ();  		break;  	case PrimitiveTypeEnumeration.Byte:  		valueHolder.Value = analyzer.reader.ReadByte ();  		break;  	case PrimitiveTypeEnumeration.Char:  		valueHolder.Value = analyzer.reader.ReadChar ();  		break;  	case PrimitiveTypeEnumeration.DateTime:  		valueHolder.Value = DateTime.FromBinary (analyzer.reader.ReadInt64 ());  		break;  	case PrimitiveTypeEnumeration.Decimal:  		string decimalValue = analyzer.reader.ReadString ();  		valueHolder.Value = decimal.Parse (decimalValue);  		break;  	case PrimitiveTypeEnumeration.Double:  		valueHolder.Value = analyzer.reader.ReadDouble ();  		break;  	case PrimitiveTypeEnumeration.Int16:  		valueHolder.Value = analyzer.reader.ReadInt16 ();  		break;  	case PrimitiveTypeEnumeration.Int32:  		valueHolder.Value = analyzer.reader.ReadInt32 ();  		break;  	case PrimitiveTypeEnumeration.Int64:  		valueHolder.Value = analyzer.reader.ReadInt64 ();  		break;  	case PrimitiveTypeEnumeration.Null:  		valueHolder.Value = null;  		break;  	case PrimitiveTypeEnumeration.SByte:  		valueHolder.Value = analyzer.reader.ReadSByte ();  		break;  	case PrimitiveTypeEnumeration.Single:  		valueHolder.Value = analyzer.reader.ReadSingle ();  		break;  	case PrimitiveTypeEnumeration.String:  		valueHolder.Value = analyzer.ReadAndFixString ();  		break;  	case PrimitiveTypeEnumeration.TimeSpan:  		valueHolder.Value = TimeSpan.FromTicks (analyzer.reader.ReadInt64 ());  		break;  	case PrimitiveTypeEnumeration.UInt16:  		valueHolder.Value = analyzer.reader.ReadUInt16 ();  		break;  	case PrimitiveTypeEnumeration.UInt32:  		valueHolder.Value = analyzer.reader.ReadUInt32 ();  		break;  	case PrimitiveTypeEnumeration.UInt64:  		valueHolder.Value = analyzer.reader.ReadUInt64 ();  		break;  	}  	break;  case BinaryTypeEnumeration.String:  	valueHolder.ValueRefID = analyzer.ParseRecord (typeHolder.RelevantObject);  	break;  case BinaryTypeEnumeration.Object:  	valueHolder.ValueRefID = analyzer.ParseRecord (typeHolder.RelevantObject);  	break;  case BinaryTypeEnumeration.SystemClass:  	valueHolder.ValueRefID = analyzer.ParseRecord (typeHolder.RelevantObject);  	break;  case BinaryTypeEnumeration.Class:  	valueHolder.ValueRefID = analyzer.ParseRecord (typeHolder.RelevantObject);  	break;  case BinaryTypeEnumeration.ObjectArray:  	valueHolder.ValueRefID = analyzer.ParseRecord (typeHolder.RelevantObject);  	break;  case BinaryTypeEnumeration.StringArray:  	valueHolder.ValueRefID = analyzer.ParseRecord (typeHolder.RelevantObject);  	break;  case BinaryTypeEnumeration.PrimitiveArray:  	valueHolder.ValueRefID = analyzer.ParseRecord (typeHolder.RelevantObject);  	break;  }  
Missing Default,ILRepacking,TypeHelper,F:\newReposMay17\gluck_il-repack\ILRepack\SerReader.cs,GetTypeValue,The following switch statement is missing a default case: switch (typeHolder.PrimitiveType) {  case PrimitiveTypeEnumeration.Boolean:  	valueHolder.Value = analyzer.reader.ReadBoolean ();  	break;  case PrimitiveTypeEnumeration.Byte:  	valueHolder.Value = analyzer.reader.ReadByte ();  	break;  case PrimitiveTypeEnumeration.Char:  	valueHolder.Value = analyzer.reader.ReadChar ();  	break;  case PrimitiveTypeEnumeration.DateTime:  	valueHolder.Value = DateTime.FromBinary (analyzer.reader.ReadInt64 ());  	break;  case PrimitiveTypeEnumeration.Decimal:  	string decimalValue = analyzer.reader.ReadString ();  	valueHolder.Value = decimal.Parse (decimalValue);  	break;  case PrimitiveTypeEnumeration.Double:  	valueHolder.Value = analyzer.reader.ReadDouble ();  	break;  case PrimitiveTypeEnumeration.Int16:  	valueHolder.Value = analyzer.reader.ReadInt16 ();  	break;  case PrimitiveTypeEnumeration.Int32:  	valueHolder.Value = analyzer.reader.ReadInt32 ();  	break;  case PrimitiveTypeEnumeration.Int64:  	valueHolder.Value = analyzer.reader.ReadInt64 ();  	break;  case PrimitiveTypeEnumeration.Null:  	valueHolder.Value = null;  	break;  case PrimitiveTypeEnumeration.SByte:  	valueHolder.Value = analyzer.reader.ReadSByte ();  	break;  case PrimitiveTypeEnumeration.Single:  	valueHolder.Value = analyzer.reader.ReadSingle ();  	break;  case PrimitiveTypeEnumeration.String:  	valueHolder.Value = analyzer.ReadAndFixString ();  	break;  case PrimitiveTypeEnumeration.TimeSpan:  	valueHolder.Value = TimeSpan.FromTicks (analyzer.reader.ReadInt64 ());  	break;  case PrimitiveTypeEnumeration.UInt16:  	valueHolder.Value = analyzer.reader.ReadUInt16 ();  	break;  case PrimitiveTypeEnumeration.UInt32:  	valueHolder.Value = analyzer.reader.ReadUInt32 ();  	break;  case PrimitiveTypeEnumeration.UInt64:  	valueHolder.Value = analyzer.reader.ReadUInt64 ();  	break;  }  
Missing Default,ILRepacking.Steps,ResourcesRepackStep,F:\newReposMay17\gluck_il-repack\ILRepack\Steps\ResourcesRepackStep.cs,Perform,The following switch statement is missing a default case: switch (resource.ResourceType) {  case ResourceType.AssemblyLinked:  	// TODO  	_logger.Warn ("AssemblyLinkedResource reference may need to be fixed (to link to newly created assembly)" + resource.Name);  	break;  case ResourceType.Linked:  	// TODO ? (or not)  	break;  case ResourceType.Embedded:  	var er = (EmbeddedResource)resource;  	if (er.Name.EndsWith (".resources")) {  		// we don't want to write the bamls to other embedded resource files  		bool shouldWriteCollectedBamlStreams = isPrimaryAssembly && .Equals (er.Name);  		newResource = FixResxResource (assembly' er' assemblyProcessors' shouldWriteCollectedBamlStreams ? bamlStreamCollector : null);  	}  	break;  }  
Missing Default,ILRepacking.Steps.SourceServerData,HttpSourceServerDescriptor,F:\newReposMay17\gluck_il-repack\ILRepack\Steps\SourceServerData\HttpSourceServerDescriptor.cs,TryParse,The following switch statement is missing a default case: switch (currentSection) {  case InitSection:  case VariablesSection:  	var groups = VariablesRegex.Match (line).Groups;  	var key = groups [1].Value;  	var value = groups [2].Value;  	switch (key) {  	case VersionKey:  		version = int.Parse (value);  		break;  	case VersionControlKey:  		versionControl = value;  		break;  	case TargetKey:  		target = value;  		break;  	}  	break;  case SourceFilesSection:  	sources.Add (SourceFileDescriptor.Parse (line));  	break;  }  
Missing Default,ILRepacking.Steps.SourceServerData,HttpSourceServerDescriptor,F:\newReposMay17\gluck_il-repack\ILRepack\Steps\SourceServerData\HttpSourceServerDescriptor.cs,TryParse,The following switch statement is missing a default case: switch (key) {  case VersionKey:  	version = int.Parse (value);  	break;  case VersionControlKey:  	versionControl = value;  	break;  case TargetKey:  	target = value;  	break;  }  
