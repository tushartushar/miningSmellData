Implementation smell,Namespace,Class,File,Method,Description
Long Method,ILRepacking,ILRepack,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\ILRepack.cs,Repack,The method has 105 lines of code.
Long Method,ILRepacking,RepackImporter,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\RepackImporter.cs,CloneTo,The method has 140 lines of code.
Complex Method,ILRepacking,IKVMLineIndexer,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\IKVMLineIndexer.cs,ProcessMethodBodyInstruction,Cyclomatic complexity of the method is 8
Complex Method,ILRepacking,ILRepack,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\ILRepack.cs,Repack,Cyclomatic complexity of the method is 11
Complex Method,ILRepacking,PermissionsetHelper,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\PermissionsetHelper.cs,Xml2PermissionSet,Cyclomatic complexity of the method is 14
Complex Method,ILRepacking,PlatformFixer,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\PlatformFixer.cs,FixPlatformVersion,Cyclomatic complexity of the method is 16
Complex Method,ILRepacking,ReferenceFixator,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\ReferenceFixator.cs,Fix,Cyclomatic complexity of the method is 8
Complex Method,ILRepacking,ReferenceFixator,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\ReferenceFixator.cs,FixReferences,Cyclomatic complexity of the method is 14
Complex Method,ILRepacking,ReferenceFixator,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\ReferenceFixator.cs,FixReferences,Cyclomatic complexity of the method is 9
Complex Method,ILRepacking,ReferenceFixator,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\ReferenceFixator.cs,Fix,Cyclomatic complexity of the method is 15
Complex Method,ILRepacking,RepackImporter,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\RepackImporter.cs,Import,Cyclomatic complexity of the method is 17
Complex Method,ILRepacking,RepackImporter,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\RepackImporter.cs,CloneTo,Cyclomatic complexity of the method is 8
Complex Method,ILRepacking,RepackImporter,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\RepackImporter.cs,CloneTo,Cyclomatic complexity of the method is 10
Complex Method,ILRepacking,RepackImporter,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\RepackImporter.cs,CloneTo,Cyclomatic complexity of the method is 10
Complex Method,ILRepacking,RepackImporter,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\RepackImporter.cs,CloneTo,Cyclomatic complexity of the method is 30
Complex Method,ILRepacking,RepackImporter,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\RepackImporter.cs,CopySecurityDeclarations,Cyclomatic complexity of the method is 9
Complex Method,ILRepacking,RepackOptions,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\RepackOptions.cs,Parse,Cyclomatic complexity of the method is 16
Complex Method,ILRepacking,RepackOptions,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\RepackOptions.cs,Validate,Cyclomatic complexity of the method is 8
Complex Method,ILRepacking,ResReader,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\ResReader.cs,ResReader,Cyclomatic complexity of the method is 9
Complex Method,ILRepacking,ResReader,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\ResReader.cs,GetObject_V2,Cyclomatic complexity of the method is 19
Complex Method,ILRepacking,ResReader,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\ResReader.cs,GetObject_V1,Cyclomatic complexity of the method is 17
Complex Method,ILRepacking,SerReader,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\SerReader.cs,ParseRecord,Cyclomatic complexity of the method is 24
Complex Method,ILRepacking,TypeHelper,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\SerReader.cs,GetTypeAdditionalInfo,Cyclomatic complexity of the method is 8
Complex Method,ILRepacking,TypeHelper,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\SerReader.cs,GetTypeValue,Cyclomatic complexity of the method is 24
Complex Method,ILRepacking.Steps,ResourcesRepackStep,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\Steps\ResourcesRepackStep.cs,Perform,Cyclomatic complexity of the method is 15
Complex Method,ILRepacking.Steps,TypesRepackStep,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\Steps\TypesRepackStep.cs,RepackExportedTypes,Cyclomatic complexity of the method is 8
Long Parameter List,ILRepacking,Res,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\ResReader.cs,Res,The method has 5 parameters. Parameters: name' type' data' typeCode' dataPos
Long Parameter List,ILRepacking.Steps.ResourceProcessing,BamlResourcePatcher,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\Steps\ResourceProcessing\BamlResourcePatcher.cs,Process,The method has 5 parameters. Parameters: resource' containingAssembly' embeddedResource' resourceReader' resourceWriter
Long Parameter List,ILRepacking.Steps.ResourceProcessing,BamlStreamCollector,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\Steps\ResourceProcessing\BamlStreamCollector.cs,Process,The method has 5 parameters. Parameters: resource' containingAssembly' embeddedResource' resourceReader' resourceWriter
Long Parameter List,ILRepacking.Steps.ResourceProcessing,GenericResourceProcessor,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\Steps\ResourceProcessing\GenericResourceProcessor.cs,Process,The method has 5 parameters. Parameters: resource' containingAssembly' embeddedResource' resourceReader' resourceWriter
Long Parameter List,ILRepacking.Steps.ResourceProcessing,IResProcessor,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\Steps\ResourceProcessing\IResProcessor.cs,Process,The method has 5 parameters. Parameters: resource' containingAssembly' embeddedResource' resourceReader' resourceWriter
Long Parameter List,ILRepacking.Steps.ResourceProcessing,StringResourceProcessor,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\Steps\ResourceProcessing\StringResourceProcessor.cs,Process,The method has 5 parameters. Parameters: resource' containingAssembly' embeddedResource' resourceReader' resourceWriter
Long Identifier,ILRepacking,IKVMLineIndexer,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\IKVMLineIndexer.cs,,The length of the parameter sourceFileAttributeTypeReference is 32.
Long Identifier,ILRepacking,IKVMLineIndexer,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\IKVMLineIndexer.cs,,The length of the parameter lineNumberTableAttributeTypeReference is 37.
Long Identifier,ILRepacking,IKVMLineIndexer,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\IKVMLineIndexer.cs,,The length of the parameter lineNumberTableAttributeConstructor1 is 36.
Long Identifier,ILRepacking,IKVMLineIndexer,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\IKVMLineIndexer.cs,,The length of the parameter lineNumberTableAttributeConstructor2 is 36.
Long Identifier,ILRepacking,IKVMLineIndexer,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\IKVMLineIndexer.cs,,The length of the parameter sourceFileAttributeConstructor is 30.
Long Identifier,ILRepacking,ReferenceFixator,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\ReferenceFixator.cs,,The length of the parameter targetAssemblyPublicKeyBlobString is 33.
Long Identifier,ILRepacking.Steps,ResourcesRepackStep,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\Steps\ResourcesRepackStep.cs,Perform,The length of the parameter shouldWriteCollectedBamlStreams is 31.
Long Statement,ILRepacking,Application,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\Application.cs,Usage,The length of the statement  "            Console.WriteLine($"IL Repack - assembly merging using Mono.Cecil - Version {typeof(ILRepack).Assembly.GetName().Version.ToString(3)}"); " is 136.
Long Statement,ILRepacking,Application,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\Application.cs,Usage,The length of the statement  "            Console.WriteLine(@" - /copyattrs         copy assembly attributes (by default only the primary assembly attributes are copied)"); " is 130.
Long Statement,ILRepacking,Application,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\Application.cs,Usage,The length of the statement  "            Console.WriteLine(@" - /target:kind       specify target assembly kind (library' exe' winexe supported' default is same as first assembly)"); " is 141.
Long Statement,ILRepacking,Application,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\Application.cs,Usage,The length of the statement  "            Console.WriteLine(@" - /lib:<path>        adds the path to the search directories for referenced assemblies (can be specified multiple times)"); " is 144.
Long Statement,ILRepacking,Application,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\Application.cs,Usage,The length of the statement  "            Console.WriteLine($" - /noRepackRes       do not add the resource '{ResourcesRepackStep.ILRepackListResourceName}' with all merged assembly names"); " is 148.
Long Statement,ILRepacking,Application,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\Application.cs,Usage,The length of the statement  "            Console.WriteLine(@" - /repackdrop:RepackDropAttribute allows dropping members denoted by this attribute name when merging"); " is 125.
Long Statement,ILRepacking,Application,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\Application.cs,Usage,The length of the statement  "            Console.WriteLine(@" - /allowduplicateresources allows to duplicate resources in output assembly (by default they're ignored)"); " is 128.
Long Statement,ILRepacking,Application,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\Application.cs,Usage,The length of the statement  "            Console.WriteLine(@" - /index             stores file:line debug information as type/method attributes (requires PDB)"); " is 120.
Long Statement,ILRepacking,Application,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\Application.cs,Usage,The length of the statement  "            Console.WriteLine(@"Note: for compatibility purposes' all Options are case insensitive' and can be specified using '/'' '-' or '--' prefix."); " is 142.
Long Statement,ILRepacking,DocumentationMerger,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\DocumentationMerger.cs,Process,The length of the statement  "                using (var writer = XmlWriter.Create(Path.ChangeExtension(repack.Options.OutputFile' ".xml")' new XmlWriterSettings() { Indent = true' IndentChars = "    " })) " is 159.
Long Statement,ILRepacking,IKVMLineIndexer,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\IKVMLineIndexer.cs,PostMethodBodyRepack,The length of the statement  "                            ConstructorArguments = { new CustomAttributeArgument(TargetAssemblyMainModule.TypeSystem.UInt16' (ushort)lineNumberWriter.LineNo) } " is 131.
Long Statement,ILRepacking,IKVMLineIndexer,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\IKVMLineIndexer.cs,PostMethodBodyRepack,The length of the statement  "                            ConstructorArguments = { new CustomAttributeArgument(new ArrayType(TargetAssemblyMainModule.TypeSystem.Byte)' lineNumberWriter.ToArray().Select(b => new CustomAttributeArgument(TargetAssemblyMainModule.TypeSystem.Byte' b)).ToArray()) } " is 235.
Long Statement,ILRepacking,IKVMLineIndexer,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\IKVMLineIndexer.cs,PostRepackReferences,The length of the statement  "            IMetadataScope ikvmRuntimeReference = repack.TargetAssemblyMainModule.AssemblyReferences.FirstOrDefault(r => r.Name == "IKVM.Runtime"); " is 135.
Long Statement,ILRepacking,IKVMLineIndexer,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\IKVMLineIndexer.cs,PostRepackReferences,The length of the statement  "                sourceFileAttributeTypeReference = new TypeReference("IKVM.Attributes"' "SourceFileAttribute"' TargetAssemblyMainModule' ikvmRuntimeReference); " is 143.
Long Statement,ILRepacking,IKVMLineIndexer,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\IKVMLineIndexer.cs,PostRepackReferences,The length of the statement  "                sourceFileAttributeConstructor = new MethodReference(".ctor"' TargetAssemblyMainModule.TypeSystem.Void' sourceFileAttributeTypeReference) " is 137.
Long Statement,ILRepacking,IKVMLineIndexer,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\IKVMLineIndexer.cs,PostRepackReferences,The length of the statement  "                lineNumberTableAttributeTypeReference = new TypeReference("IKVM.Attributes"' "LineNumberTableAttribute"' TargetAssemblyMainModule' ikvmRuntimeReference); " is 153.
Long Statement,ILRepacking,IKVMLineIndexer,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\IKVMLineIndexer.cs,PostRepackReferences,The length of the statement  "                lineNumberTableAttributeConstructor1 = new MethodReference(".ctor"' TargetAssemblyMainModule.TypeSystem.Void' lineNumberTableAttributeTypeReference) " is 148.
Long Statement,ILRepacking,IKVMLineIndexer,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\IKVMLineIndexer.cs,PostRepackReferences,The length of the statement  "                lineNumberTableAttributeConstructor2 = new MethodReference(".ctor"' TargetAssemblyMainModule.TypeSystem.Void' lineNumberTableAttributeTypeReference) " is 148.
Long Statement,ILRepacking,MappingHandler,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\MappingHandler.cs,GetExportedRemappedType,The length of the statement  "                // It should match the actual type (e.g.' Boolean for System.Boolean). But because of forwarded types' this is not known at read time' thus having to fix it here. " is 162.
Long Statement,ILRepacking,ILRepack,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\ILRepack.cs,ResolveTargetPlatformDirectory,The length of the statement  "                throw new ArgumentException($"Failed to find target platform '{Options.TargetPlatformVersion}' in '{platformBasePath}'"); " is 121.
Long Statement,ILRepacking,ILRepack,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\ILRepack.cs,GetRepackAssemblyNames,The length of the statement  "                using (Stream stream = typeInRepackedAssembly.Assembly.GetManifestResourceStream(ResourcesRepackStep.ILRepackListResourceName)) " is 127.
Long Statement,ILRepacking,ILRepack,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\ILRepack.cs,GetRepackAssemblyName,The length of the statement  "            return repackAssemblyNames?.FirstOrDefault(name => name.Name == repackedAssemblyName) ?? fallbackType.Assembly.GetName(); " is 121.
Long Statement,ILRepacking,ILRepack,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\ILRepack.cs,Repack,The length of the statement  "            TargetAssemblyMainModule.Win32ResourceDirectory = MergeWin32Resources(PrimaryAssemblyMainModule.Win32ResourceDirectory); " is 120.
Long Statement,ILRepacking,ILRepack,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\ILRepack.cs,Repack,The length of the statement  "            var isUnixEnvironment = Environment.OSVersion.Platform == PlatformID.MacOSX || Environment.OSVersion.Platform == PlatformID.Unix; " is 129.
Long Statement,ILRepacking,ILRepack,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\ILRepack.cs,ResolveSearchDirectories,The length of the statement  "            var targetPlatformDirectory = Options.TargetPlatformDirectory ?? ResolveTargetPlatformDirectory(Options.TargetPlatformVersion); " is 127.
Long Statement,ILRepacking,ILRepack,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\ILRepack.cs,MergeEntry,The length of the statement  "                    Logger.Warn(string.Format("Duplicate Win32 resource with id={0}' parents=[{1}]' name={2} in assembly {3}' ignoring"' entry.Id' string.Join("'"' parents.Select(p => p.Name ?? p.Id.ToString()).ToArray())' entry.Name' ass.Name)); " is 226.
Long Statement,ILRepacking,ILRepack,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\ILRepack.cs,FixStr,The length of the statement  "            if (String.IsNullOrEmpty(content) || content.Length > 512 || content.IndexOf("' ") == -1 || content.StartsWith("System.")) " is 122.
Long Statement,ILRepacking,PermissionsetHelper,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\PermissionsetHelper.cs,Permission2XmlSet,The length of the statement  "            SecurityAttribute attribute = new SecurityAttribute(GetTypeRef("System.Security.Permissions"' "PermissionSetAttribute"' "mscorlib"' targetModule)); " is 147.
Long Statement,ILRepacking,PermissionsetHelper,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\PermissionsetHelper.cs,Xml2PermissionSet,The length of the statement  "            SecurityAttribute attribute = new SecurityAttribute(GetTypeRef(string.Join("."' classNamespace.ToArray())' className' assemblyName' targetModule)); " is 147.
Long Statement,ILRepacking,ReferenceFixator,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\ReferenceFixator.cs,Fix,The length of the statement  "            ModuleReference nmr = _repackContext.TargetAssemblyMainModule.ModuleReferences.FirstOrDefault(x => x.Name == moduleRef.Name); " is 125.
Long Statement,ILRepacking,ReferenceFixator,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\ReferenceFixator.cs,FixMethodVisibility,The length of the statement  "            // this causes peverify issues with IKVM assemblies where java is more flexible such as: (A and B are classes' C interface' B extends A' C) " is 139.
Long Statement,ILRepacking,ReferenceFixator,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\ReferenceFixator.cs,FixReferences,The length of the statement  "                if ((_repackContext.TargetAssemblyMainModule.Runtime == TargetRuntime.Net_1_0) || (_repackContext.TargetAssemblyMainModule.Runtime == TargetRuntime.Net_1_1)) " is 157.
Long Statement,ILRepacking,ReferenceFixator,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\ReferenceFixator.cs,Fix,The length of the statement  "                MethodDefinition def = new ReflectionHelper(_repackContext).FindMethodDefinitionInType((TypeDefinition)declaringType' method); " is 126.
Long Statement,ILRepacking,ReferenceFixator,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\ReferenceFixator.cs,Fix,The length of the statement  "                _logger.Warn("Method reference is used with definition return type / parameter. Indicates a likely invalid set of assemblies' consider one of the following"); " is 158.
Long Statement,ILRepacking,RepackImporter,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\RepackImporter.cs,ShouldDrop,The length of the statement  "                _logger.Log("Repack dropped " + typeof(TMember).Name + ": " + member.FullName + " as it was marked with " + _options.RepackDropAttribute); " is 138.
Long Statement,ILRepacking,RepackImporter,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\RepackImporter.cs,CloneTo,The length of the statement  "            MethodDefinition nm = new MethodDefinition(meth.Name' meth.Attributes' _repackContext.TargetAssemblyMainModule.TypeSystem.Void); " is 128.
Long Statement,ILRepacking,RepackImporter,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\RepackImporter.cs,FixAspNetOffset,The length of the statement  "                if (fullName == "System.Void System.Web.UI.TemplateControl::WriteUTF8ResourceString(System.Web.UI.HtmlTextWriter'System.Int32'System.Int32'System.Boolean)" || " is 158.
Long Statement,ILRepacking,RepackImporter,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\RepackImporter.cs,FixAspNetOffset,The length of the statement  "                    fullName == "System.Web.UI.LiteralControl System.Web.UI.TemplateControl::CreateResourceBasedLiteralControl(System.Int32'System.Int32'System.Boolean)") " is 150.
Long Statement,ILRepacking,RepackImporter,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\RepackImporter.cs,DuplicateTypeAllowed,The length of the statement  "            // XAML helper class' identical in all assemblies' unused within the assembly' and instanciated through reflection from the outside " is 131.
Long Statement,ILRepacking,RepackImporter,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\RepackImporter.cs,DuplicateTypeAllowed,The length of the statement  "            if (!String.IsNullOrEmpty(nameSpace) && _options.AllowedDuplicateNameSpaces.Any(s => s == nameSpace || nameSpace.StartsWith(s + "."))) " is 134.
Long Statement,ILRepacking,RepackImporter,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\RepackImporter.cs,CustomAttributeTypeAllowsMultiple,The length of the statement  "                // IKVM module attributes' although they don't allow multiple' IKVM supports the attribute being specified multiple times " is 121.
Long Statement,ILRepacking,ResReader,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\ResReader.cs,GetResources,The length of the statement  "                    dataPositionsAndNames[i] = new KeyValuePair<int' string>(_store.ReadInt32()' Encoding.Unicode.GetString(bytes' 0' byteLen)); " is 124.
Long Statement,ILRepacking,ResReader,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\ResReader.cs,GetResources,The length of the statement  "                    long nextData = (i < _numResources - 1) ? dataPositionsAndNames[i + 1].Key + _dataSectionOffset : _store.BaseStream.Length; " is 123.
Long Statement,ILRepacking,SerReader,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\SerReader.cs,ParseRecord,The length of the statement  "                        // -> this will overwrite the original values in the referenced object' but who cares - the values are trash anyway (for now). " is 126.
Long Statement,ILRepacking,SerReader,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\SerReader.cs,ParseRecord,The length of the statement  "                        si = new BinaryArray(BinaryTypeEnumeration.Primitive).ReadObjectId(this).ReadLengths(this).ReadPrimitiveType(this).ReadValues(this); " is 132.
Long Statement,ILRepacking,SerReader,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\SerReader.cs,ParseRecord,The length of the statement  "                        throw new Exception("Parsing appears to have failed dramatically. Unknown record type' we must be lost in the bytestream!"); " is 124.
Long Statement,ILRepacking.Steps,AttributesRepackStep,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\Steps\AttributesRepackStep.cs,Perform,The length of the statement  "                    _repackCopier.CopyCustomAttributes(ass.CustomAttributes' targetAssemblyDefinition.CustomAttributes' _options.AllowMultipleAssemblyLevelAttributes' null); " is 153.
Long Statement,ILRepacking.Steps,AttributesRepackStep,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\Steps\AttributesRepackStep.cs,Perform,The length of the statement  "                    _repackCopier.CopyCustomAttributes(mod.CustomAttributes' targetAssemblyMainModule.CustomAttributes' _options.AllowMultipleAssemblyLevelAttributes' null); " is 153.
Long Statement,ILRepacking.Steps,AttributesRepackStep,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\Steps\AttributesRepackStep.cs,Perform,The length of the statement  "                AssemblyDefinition attributeAsm = AssemblyDefinition.ReadAssembly(_options.AttributeFile' new ReaderParameters(ReadingMode.Immediate) { AssemblyResolver = _repackContext.GlobalAssemblyResolver }); " is 196.
Long Statement,ILRepacking.Steps,AttributesRepackStep,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\Steps\AttributesRepackStep.cs,Perform,The length of the statement  "                _repackCopier.CopyCustomAttributes(_repackContext.PrimaryAssemblyDefinition.CustomAttributes' targetAssemblyDefinition.CustomAttributes' null); " is 143.
Long Statement,ILRepacking.Steps,AttributesRepackStep,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\Steps\AttributesRepackStep.cs,Perform,The length of the statement  "                _repackCopier.CopyCustomAttributes(_repackContext.PrimaryAssemblyMainModule.CustomAttributes' targetAssemblyMainModule.CustomAttributes' null); " is 143.
Long Statement,ILRepacking.Steps,AttributesRepackStep,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\Steps\AttributesRepackStep.cs,Perform,The length of the statement  "            _repackCopier.CopySecurityDeclarations(_repackContext.PrimaryAssemblyDefinition.SecurityDeclarations' targetAssemblyDefinition.SecurityDeclarations' null); " is 155.
Long Statement,ILRepacking.Steps,AttributesRepackStep,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\Steps\AttributesRepackStep.cs,CleanupAttributes,The length of the statement  "            CleanupAttributes(typeof(CompilationRelaxationsAttribute).FullName' x => x.ConstructorArguments.Count == 1 /* TODO && x.ConstructorArguments[0].Value.Equals(1) */); " is 164.
Long Statement,ILRepacking.Steps,AttributesRepackStep,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\Steps\AttributesRepackStep.cs,RemoveAttributes,The length of the statement  "                var targetIsSigned = (_repackContext.TargetAssemblyMainModule.Attributes & ModuleAttributes.StrongNameSigned) == ModuleAttributes.StrongNameSigned; " is 147.
Long Statement,ILRepacking.Steps,AttributesRepackStep,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\Steps\AttributesRepackStep.cs,RemoveAttributes,The length of the statement  "                bool isSigned = name.IndexOf("' PublicKey="' StringComparison.Ordinal) != -1 && name.IndexOf("' PublicKey=null"' StringComparison.Ordinal) == -1; " is 145.
Long Statement,ILRepacking.Steps,AttributesRepackStep,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\Steps\AttributesRepackStep.cs,CleanupAttributes,The length of the statement  "            if (!_repackContext.MergedAssemblies.All(ass => ass.CustomAttributes.Any(attr => attr.AttributeType.FullName == type && extra(attr)))) " is 134.
Long Statement,ILRepacking.Steps,ReferencesFixStep,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\Steps\ReferencesFixStep.cs,Perform,The length of the statement  "                    // in case we reference same assemblies with different versions' there might be prior errors if we don't merge the 'largest one' " is 128.
Long Statement,ILRepacking.Steps,ResourcesRepackStep,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\Steps\ResourcesRepackStep.cs,Perform,The length of the statement  "                                    _logger.Warn("AssemblyLinkedResource reference may need to be fixed (to link to newly created assembly)" + resource.Name); " is 122.
Long Statement,ILRepacking.Steps,TypesRepackStep,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\Steps\TypesRepackStep.cs,CreateReference,The length of the statement  "            return new TypeReference(type.Namespace' type.Name' _repackContext.TargetAssemblyMainModule' _repackContext.MergeScope(type.Scope)) " is 131.
Long Statement,ILRepacking.Steps.ResourceProcessing,BamlResourcePatcher,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\Steps\ResourceProcessing\BamlResourcePatcher.cs,RemoveTypeAssemblyInformation,The length of the statement  "            // ClassLibrary.GenericResourceKey`1[[ClassLibrary.ThemesResourceKey' ClassLibrary' Version=1.0.0.0' Culture=neutral' PublicKeyToken=null]] " is 139.
Long Statement,ILRepacking.Steps.ResourceProcessing,BamlResourcePatcher,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\Steps\ResourceProcessing\BamlResourcePatcher.cs,RemoveTypeAssemblyInformation,The length of the statement  "            // DevExpress.Mvvm.UI.Interactivity.EventTriggerBase`1[[System.Windows.DependencyObject' WindowsBase' Version=4.0.0.0' Culture=neutral' PublicKeyToken=31bf3856ad364e35]] " is 169.
Complex Conditional,ILRepacking,ILRepack,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\ILRepack.cs,FixStr,The conditional expression  "String.IsNullOrEmpty(content) || content.Length > 512 || content.IndexOf("' ") == -1 || content.StartsWith("System.")"  is complex.
Complex Conditional,ILRepacking,ReferenceFixator,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\ReferenceFixator.cs,Fix,The conditional expression  "!method.IsDefinition &&                  !method.DeclaringType.IsGenericInstance &&                  !method.DeclaringType.IsArray &&                  (method.ReturnType.IsDefinition || method.Parameters.Any(x => x.ParameterType.IsDefinition))"  is complex.
Complex Conditional,ILRepacking,RepackImporter,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\RepackImporter.cs,CloneTo,The conditional expression  "!typeJustCreated &&                  type.Methods.Count > 0 &&                  type.Methods.Any(x =>                    (x.Name == meth.Name) &&                    (x.Parameters.Count == meth.Parameters.Count) &&                    (x.ToString() == meth.ToString()))"  is complex.
Empty Catch Block,ILRepacking,IKVMLineIndexer,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\IKVMLineIndexer.cs,ProcessMethodBodyInstruction,The method has an empty catch block.
Empty Catch Block,ILRepacking,ILRepack,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\ILRepack.cs,GetRepackAssemblyNames,The method has an empty catch block.
Empty Catch Block,ILRepacking.Steps.SourceServerData,PdbStr,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\Steps\SourceServerData\PdbStr.cs,SafeDeleteFile,The method has an empty catch block.
Magic Number,ILRepacking,Application,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\Application.cs,Main,The following statement contains a magic number: Exit(2);
Magic Number,ILRepacking,Application,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\Application.cs,Usage,The following statement contains a magic number: Console.WriteLine($"IL Repack - assembly merging using Mono.Cecil - Version {typeof(ILRepack).Assembly.GetName().Version.ToString(3)}");
Magic Number,ILRepacking,IKVMLineIndexer,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\IKVMLineIndexer.cs,PreMethodBodyRepack,The following statement contains a magic number: lineNumberWriter = new LineNumberWriter(body.Instructions.Count / 4);
Magic Number,ILRepacking,LineNumberWriter,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\LineNumberWriter.cs,LineNumberWriter,The following statement contains a magic number: stream = new System.IO.MemoryStream(estimatedCount * 2);
Magic Number,ILRepacking,LineNumberWriter,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\LineNumberWriter.cs,AddMapping,The following statement contains a magic number: WritePackedInteger(linenumber - (64 + 50));
Magic Number,ILRepacking,LineNumberWriter,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\LineNumberWriter.cs,AddMapping,The following statement contains a magic number: WritePackedInteger(linenumber - (64 + 50));
Magic Number,ILRepacking,LineNumberWriter,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\LineNumberWriter.cs,AddMapping,The following statement contains a magic number: deltaPC >= 0 && deltaPC < 31
Magic Number,ILRepacking,LineNumberWriter,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\LineNumberWriter.cs,AddMapping,The following statement contains a magic number: const int bias = 2;
Magic Number,ILRepacking,LineNumberWriter,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\LineNumberWriter.cs,AddMapping,The following statement contains a magic number: lead |= (byte)((deltaLineNo + bias) << 5);
Magic Number,ILRepacking,LineNumberWriter,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\LineNumberWriter.cs,AddMapping,The following statement contains a magic number: deltaLineNo >= -bias && deltaLineNo < 7 - bias
Magic Number,ILRepacking,LineNumberWriter,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\LineNumberWriter.cs,AddMapping,The following statement contains a magic number: WritePackedInteger(deltaPC - (64 + 31));
Magic Number,ILRepacking,LineNumberWriter,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\LineNumberWriter.cs,AddMapping,The following statement contains a magic number: WritePackedInteger(deltaPC - (64 + 31));
Magic Number,ILRepacking,LineNumberWriter,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\LineNumberWriter.cs,WritePackedInteger,The following statement contains a magic number: val += 64;
Magic Number,ILRepacking,LineNumberWriter,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\LineNumberWriter.cs,WritePackedInteger,The following statement contains a magic number: val >= -64 && val < 64
Magic Number,ILRepacking,LineNumberWriter,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\LineNumberWriter.cs,WritePackedInteger,The following statement contains a magic number: val >= -64 && val < 64
Magic Number,ILRepacking,ILRepack,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\ILRepack.cs,PrintRepackHeader,The following statement contains a magic number: Logger.Info($"IL Repack - Version {ilRepack.Version.ToString(3)}");
Magic Number,ILRepacking,ILRepack,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\ILRepack.cs,IsAspResourceEntry,The following statement contains a magic number: return exist.Id == 101 && parents.Count == 1 && parents[0].Id == 3771;
Magic Number,ILRepacking,ILRepack,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\ILRepack.cs,IsAspResourceEntry,The following statement contains a magic number: return exist.Id == 101 && parents.Count == 1 && parents[0].Id == 3771;
Magic Number,ILRepacking,ILRepack,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\ILRepack.cs,IsVersionInfoResource,The following statement contains a magic number: return exist.Id == 0 && parents.Count == 2 && parents[0].Id == 16 && parents[1].Id == 1;
Magic Number,ILRepacking,ILRepack,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\ILRepack.cs,IsVersionInfoResource,The following statement contains a magic number: return exist.Id == 0 && parents.Count == 2 && parents[0].Id == 16 && parents[1].Id == 1;
Magic Number,ILRepacking,ILRepack,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\ILRepack.cs,FixStr,The following statement contains a magic number: String.IsNullOrEmpty(content) || content.Length > 512 || content.IndexOf("' ") == -1 || content.StartsWith("System.")
Magic Number,ILRepacking,ILRepack,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\ILRepack.cs,FixStr,The following statement contains a magic number: MergedAssemblies.Any(x => x.Name.Name == match.Groups[2].Value)
Magic Number,ILRepacking,ReferenceFixator,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\ReferenceFixator.cs,FixReferences,The following statement contains a magic number: targetAssemblyPublicKeyBlobString += b.ToString("X").PadLeft(2' '0');
Magic Number,ILRepacking,RepackImporter,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\RepackImporter.cs,FixAspNetOffset,The following statement contains a magic number: int prev = (int)instructions[instructions.Count - 4].Operand;
Magic Number,ILRepacking,RepackImporter,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\RepackImporter.cs,FixAspNetOffset,The following statement contains a magic number: instructions[instructions.Count - 4].Operand = prev + offset;
Magic Number,ILRepacking,RepackOptions,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\RepackOptions.cs,AllowDuplicateType,The following statement contains a magic number: allowedDuplicateNameSpaces.Add(typeName.Substring(0' typeName.Length - 2));
Magic Number,ILRepacking,ResReader,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\ResReader.cs,ResReader,The following statement contains a magic number: version != 2 && version != 1
Magic Number,ILRepacking,ResReader,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\ResReader.cs,ResReader,The following statement contains a magic number: int alignBytes = ((int)pos) & 7;
Magic Number,ILRepacking,ResReader,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\ResReader.cs,ResReader,The following statement contains a magic number: i < 8 - alignBytes
Magic Number,ILRepacking,ResReader,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\ResReader.cs,SkipInt32,The following statement contains a magic number: _store.BaseStream.Seek(4' SeekOrigin.Current);
Magic Number,ILRepacking,ResReader,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\ResReader.cs,GetObject_V1,The following statement contains a magic number: int[] array = new int[4];
Magic Number,ILRepacking,ResReader,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\ResReader.cs,Read7BitEncodedInt,The following statement contains a magic number: shift == 5 * 7
Magic Number,ILRepacking,ResReader,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\ResReader.cs,Read7BitEncodedInt,The following statement contains a magic number: shift == 5 * 7
Magic Number,ILRepacking,ResReader,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\ResReader.cs,Read7BitEncodedInt,The following statement contains a magic number: shift += 7;
Magic Number,ILRepacking,SerReader,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\SerReader.cs,ParseRecord,The following statement contains a magic number: switch (nextRecordType)                  {                      case RecordTypeEnumeration.SerializedStreamHeader:                          //header is 4 values that I wouldn't know what to do with (what type of message' what version' etc) - trash.                          reader.ReadBytes(16);                          break;                      case RecordTypeEnumeration.ClassWithID:                          //just two ints' read directly                          si = new ClassInfo().ReadObjectId(this);                          int refObj = reader.ReadInt32();                          //Use the referenced object definition for data retrieval rules                          // -> this will overwrite the original values in the referenced object' but who cares - the values are trash anyway (for now).                          ((ClassInfo)SerialObjectsFound[refObj]).ReadValues(this);                          break;                      case RecordTypeEnumeration.SystemClassWithMembers:                          si = new ClassInfo().ReadMembers(this).ReadValues(this);                          break;                      case RecordTypeEnumeration.ClassWithMembers:                          si = new ClassInfo().ReadMembers(this).ReadLibraryId(this).ReadValues(this);                          break;                      case RecordTypeEnumeration.SystemClassWithMembersAndTypes:                          si = new ClassInfo().ReadMembers(this).ReadTypeInfo(this).ReadValues(this);                          break;                      case RecordTypeEnumeration.ClassWithMembersAndTypes:                          si = new ClassInfo().ReadMembers(this).ReadTypeInfo(this).ReadLibraryId(this).ReadValues(this);                          break;                      case RecordTypeEnumeration.BinaryObjectString:                          si = new ObjectString().ReadObjectId(this).ReadString(this);                          break;                      case RecordTypeEnumeration.BinaryArray:                          si = new BinaryArray().ReadStruct(this).ReadValues(this);                          break;                      case RecordTypeEnumeration.MemberPrimitiveTyped:                          //Don't know how this can happen - I think it's for messages/remoting only                          throw new NotImplementedException();                      case RecordTypeEnumeration.MemberReference:                          //just return the ID that was referenced.                          serialObjectReferenceID = reader.ReadInt32();                          break;                      case RecordTypeEnumeration.ObjectNull:                          //a single null; do nothing' as null is the default return value.                          break;                      case RecordTypeEnumeration.MessageEnd:                          //do nothing' quit. Wasn't that fun?                          endRecordReached = true;                          break;                      case RecordTypeEnumeration.BinaryLibrary:                          int newLibraryID = reader.ReadInt32();                          LibrariesFound.Add(newLibraryID' new BinaryLibrary { LibraryID = newLibraryID' Name = ReadAssemblyName() });                          break;                      case RecordTypeEnumeration.ObjectNullMultiple256:                          //a sequence of nulls; return null' and start a counter to continue returning N nulls over the next calls.                          PendingNullCounter = reader.ReadByte() - 1;                          break;                      case RecordTypeEnumeration.ObjectNullMultiple:                          //a sequence of nulls; return null' and start a counter to continue returning N nulls over the next calls.                          PendingNullCounter = reader.ReadInt32() - 1;                          //not yet tested: if it happens' take a look around.                          throw new NotImplementedException();                      case RecordTypeEnumeration.ArraySinglePrimitive:                          si = new BinaryArray(BinaryTypeEnumeration.Primitive).ReadObjectId(this).ReadLengths(this).ReadPrimitiveType(this).ReadValues(this);                          break;                      case RecordTypeEnumeration.ArraySingleObject:                          si = new BinaryArray(BinaryTypeEnumeration.Object).ReadObjectId(this).ReadLengths(this).ReadValues(this);                          //not yet tested: if it happens' take a look around.                          throw new NotImplementedException();                      case RecordTypeEnumeration.ArraySingleString:                          si = new BinaryArray(BinaryTypeEnumeration.String).ReadObjectId(this).ReadLengths(this).ReadValues(this);                          //not yet tested: if it happens' take a look around.                          throw new NotImplementedException();                      case RecordTypeEnumeration.MethodCall:                          //messages/remoting functionality not implemented                          throw new NotImplementedException();                      case RecordTypeEnumeration.MethodReturn:                          //messages/remoting functionality not implemented                          throw new NotImplementedException();                      default:                          throw new Exception("Parsing appears to have failed dramatically. Unknown record type' we must be lost in the bytestream!");                    }
Magic Number,ILRepacking.Steps.ResourceProcessing,BamlGenerator,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\Steps\ResourceProcessing\BamlGenerator.cs,GetImportRecords,The following statement contains a magic number: records.Add(new PropertyWithConverterRecord                  {                      AttributeId = 1'                      ConverterTypeId = 64831'                      Value = GetPackUri(file)                  });
Magic Number,ILRepacking.Steps.ResourceProcessing,BamlUtils,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\Steps\ResourceProcessing\BamlUtils.cs,FromResourceBytes,The following statement contains a magic number: byte[] streamBytes = rawResourceData.Skip(4).ToArray();
Magic Number,ILRepacking.Steps.SourceServerData,HttpSourceServerDescriptor,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\Steps\SourceServerData\HttpSourceServerDescriptor.cs,MergeWith,The following statement contains a magic number: return new HttpSourceServerDescriptor(Version' VersionControl' VarName(2)' files.ToArray());
Magic Number,ILRepacking.Steps.SourceServerData,SourceFileDescriptor,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\Steps\SourceServerData\SourceFileDescriptor.cs,Parse,The following statement contains a magic number: return new SourceFileDescriptor(                      new[] { groups[1].Value }                      .Concat(groups[3].Captures                          .Cast<Capture>()                          .Select(capture => capture.Value)));
Missing Default,ILRepacking,ILRepack,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\ILRepack.cs,Repack,The following switch statement is missing a default case: switch (Options.TargetKind.Value)                  {                      case Kind.Dll: kind = ModuleKind.Dll; break;                      case Kind.Exe: kind = ModuleKind.Console; break;                      case Kind.WinExe: kind = ModuleKind.Windows; break;                  }
Missing Default,ILRepacking,ReferenceFixator,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\ReferenceFixator.cs,FixReferences,The following switch statement is missing a default case: switch (eh.HandlerType)                  {                      case ExceptionHandlerType.Catch:                          eh.CatchType = Fix(eh.CatchType);                          break;                  }
Missing Default,ILRepacking,RepackImporter,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\RepackImporter.cs,CloneTo,The following switch statement is missing a default case: switch (eh.HandlerType)                  {                      case ExceptionHandlerType.Catch:                          neh.CatchType = Import(eh.CatchType' parent);                          break;                      case ExceptionHandlerType.Filter:                          neh.FilterStart = GetInstruction(body' nb' eh.FilterStart);                          break;                  }
Missing Default,ILRepacking,ResReader,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\ResReader.cs,GetObject_V2,The following switch statement is missing a default case: switch (typeCode)                  {                      case ResourceTypeCode.Null:                          return null;                        case ResourceTypeCode.String:                          return _store.ReadString();                        case ResourceTypeCode.Boolean:                          return _store.ReadBoolean();                        case ResourceTypeCode.Char:                          return (char)_store.ReadUInt16();                        case ResourceTypeCode.Byte:                          return _store.ReadByte();                        case ResourceTypeCode.SByte:                          return _store.ReadSByte();                        case ResourceTypeCode.Int16:                          return _store.ReadInt16();                        case ResourceTypeCode.UInt16:                          return _store.ReadUInt16();                        case ResourceTypeCode.Int32:                          return _store.ReadInt32();                        case ResourceTypeCode.UInt32:                          return _store.ReadUInt32();                        case ResourceTypeCode.Int64:                          return _store.ReadInt64();                        case ResourceTypeCode.UInt64:                          return _store.ReadUInt64();                        case ResourceTypeCode.Single:                          return _store.ReadSingle();                        case ResourceTypeCode.Double:                          return _store.ReadDouble();                        case ResourceTypeCode.Decimal:                          return _store.ReadDecimal();                        case ResourceTypeCode.DateTime:                          // Use DateTime's ToBinary & FromBinary.                          Int64 data = _store.ReadInt64();                          return DateTime.FromBinary(data);                        case ResourceTypeCode.TimeSpan:                          Int64 ticks = _store.ReadInt64();                          return new TimeSpan(ticks);                        // Special types                      case ResourceTypeCode.ByteArray:                          {                              int len = _store.ReadInt32();                              return _store.ReadBytes(len);                          }                      case ResourceTypeCode.Stream:                          {                              int len = _store.ReadInt32();                              byte[] bytes = _store.ReadBytes(len);                              // Lifetime of memory == lifetime of this stream.                              return new MemoryStream(bytes);                          }                  }
Missing Default,ILRepacking,TypeHelper,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\SerReader.cs,GetTypeAdditionalInfo,The following switch statement is missing a default case: switch (typeHolder.BinaryType)              {                  case BinaryTypeEnumeration.Primitive:                      typeHolder.PrimitiveType = (PrimitiveTypeEnumeration)analyzer.reader.ReadByte();                      break;                  case BinaryTypeEnumeration.String:                      break;                  case BinaryTypeEnumeration.Object:                      break;                  case BinaryTypeEnumeration.SystemClass:                      typeHolder.TypeInfo = new ClassTypeInfo();                      typeHolder.TypeInfo.TypeName = analyzer.ReadMarkString();                      break;                  case BinaryTypeEnumeration.Class:                      typeHolder.TypeInfo = new ClassTypeInfo();                      typeHolder.TypeInfo.TypeName = analyzer.ReadMarkString();                      int libraryId = analyzer.reader.ReadInt32();                      analyzer.FixTypeName(analyzer.LibrariesFound[libraryId].Name' typeHolder.TypeInfo.TypeName);                      break;                  case BinaryTypeEnumeration.ObjectArray:                      break;                  case BinaryTypeEnumeration.StringArray:                      break;                  case BinaryTypeEnumeration.PrimitiveArray:                      typeHolder.PrimitiveType = (PrimitiveTypeEnumeration)analyzer.reader.ReadByte();                      break;              }
Missing Default,ILRepacking,TypeHelper,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\SerReader.cs,GetTypeValue,The following switch statement is missing a default case: switch (typeHolder.BinaryType)              {                  case BinaryTypeEnumeration.Primitive:                      switch (typeHolder.PrimitiveType)                      {                          case PrimitiveTypeEnumeration.Boolean:                              valueHolder.Value = analyzer.reader.ReadBoolean();                              break;                          case PrimitiveTypeEnumeration.Byte:                              valueHolder.Value = analyzer.reader.ReadByte();                              break;                          case PrimitiveTypeEnumeration.Char:                              valueHolder.Value = analyzer.reader.ReadChar();                              break;                          case PrimitiveTypeEnumeration.DateTime:                              valueHolder.Value = DateTime.FromBinary(analyzer.reader.ReadInt64());                              break;                          case PrimitiveTypeEnumeration.Decimal:                              string decimalValue = analyzer.reader.ReadString();                              valueHolder.Value = decimal.Parse(decimalValue);                              break;                          case PrimitiveTypeEnumeration.Double:                              valueHolder.Value = analyzer.reader.ReadDouble();                              break;                          case PrimitiveTypeEnumeration.Int16:                              valueHolder.Value = analyzer.reader.ReadInt16();                              break;                          case PrimitiveTypeEnumeration.Int32:                              valueHolder.Value = analyzer.reader.ReadInt32();                              break;                          case PrimitiveTypeEnumeration.Int64:                              valueHolder.Value = analyzer.reader.ReadInt64();                              break;                          case PrimitiveTypeEnumeration.Null:                              valueHolder.Value = null;                              break;                          case PrimitiveTypeEnumeration.SByte:                              valueHolder.Value = analyzer.reader.ReadSByte();                              break;                          case PrimitiveTypeEnumeration.Single:                              valueHolder.Value = analyzer.reader.ReadSingle();                              break;                          case PrimitiveTypeEnumeration.String:                              valueHolder.Value = analyzer.ReadAndFixString();                              break;                          case PrimitiveTypeEnumeration.TimeSpan:                              valueHolder.Value = TimeSpan.FromTicks(analyzer.reader.ReadInt64());                              break;                          case PrimitiveTypeEnumeration.UInt16:                              valueHolder.Value = analyzer.reader.ReadUInt16();                              break;                          case PrimitiveTypeEnumeration.UInt32:                              valueHolder.Value = analyzer.reader.ReadUInt32();                              break;                          case PrimitiveTypeEnumeration.UInt64:                              valueHolder.Value = analyzer.reader.ReadUInt64();                              break;                      }                      break;                  case BinaryTypeEnumeration.String:                      valueHolder.ValueRefID = analyzer.ParseRecord(typeHolder.RelevantObject);                      break;                  case BinaryTypeEnumeration.Object:                      valueHolder.ValueRefID = analyzer.ParseRecord(typeHolder.RelevantObject);                      break;                  case BinaryTypeEnumeration.SystemClass:                      valueHolder.ValueRefID = analyzer.ParseRecord(typeHolder.RelevantObject);                      break;                  case BinaryTypeEnumeration.Class:                      valueHolder.ValueRefID = analyzer.ParseRecord(typeHolder.RelevantObject);                      break;                  case BinaryTypeEnumeration.ObjectArray:                      valueHolder.ValueRefID = analyzer.ParseRecord(typeHolder.RelevantObject);                      break;                  case BinaryTypeEnumeration.StringArray:                      valueHolder.ValueRefID = analyzer.ParseRecord(typeHolder.RelevantObject);                      break;                  case BinaryTypeEnumeration.PrimitiveArray:                      valueHolder.ValueRefID = analyzer.ParseRecord(typeHolder.RelevantObject);                      break;              }
Missing Default,ILRepacking,TypeHelper,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\SerReader.cs,GetTypeValue,The following switch statement is missing a default case: switch (typeHolder.PrimitiveType)                      {                          case PrimitiveTypeEnumeration.Boolean:                              valueHolder.Value = analyzer.reader.ReadBoolean();                              break;                          case PrimitiveTypeEnumeration.Byte:                              valueHolder.Value = analyzer.reader.ReadByte();                              break;                          case PrimitiveTypeEnumeration.Char:                              valueHolder.Value = analyzer.reader.ReadChar();                              break;                          case PrimitiveTypeEnumeration.DateTime:                              valueHolder.Value = DateTime.FromBinary(analyzer.reader.ReadInt64());                              break;                          case PrimitiveTypeEnumeration.Decimal:                              string decimalValue = analyzer.reader.ReadString();                              valueHolder.Value = decimal.Parse(decimalValue);                              break;                          case PrimitiveTypeEnumeration.Double:                              valueHolder.Value = analyzer.reader.ReadDouble();                              break;                          case PrimitiveTypeEnumeration.Int16:                              valueHolder.Value = analyzer.reader.ReadInt16();                              break;                          case PrimitiveTypeEnumeration.Int32:                              valueHolder.Value = analyzer.reader.ReadInt32();                              break;                          case PrimitiveTypeEnumeration.Int64:                              valueHolder.Value = analyzer.reader.ReadInt64();                              break;                          case PrimitiveTypeEnumeration.Null:                              valueHolder.Value = null;                              break;                          case PrimitiveTypeEnumeration.SByte:                              valueHolder.Value = analyzer.reader.ReadSByte();                              break;                          case PrimitiveTypeEnumeration.Single:                              valueHolder.Value = analyzer.reader.ReadSingle();                              break;                          case PrimitiveTypeEnumeration.String:                              valueHolder.Value = analyzer.ReadAndFixString();                              break;                          case PrimitiveTypeEnumeration.TimeSpan:                              valueHolder.Value = TimeSpan.FromTicks(analyzer.reader.ReadInt64());                              break;                          case PrimitiveTypeEnumeration.UInt16:                              valueHolder.Value = analyzer.reader.ReadUInt16();                              break;                          case PrimitiveTypeEnumeration.UInt32:                              valueHolder.Value = analyzer.reader.ReadUInt32();                              break;                          case PrimitiveTypeEnumeration.UInt64:                              valueHolder.Value = analyzer.reader.ReadUInt64();                              break;                      }
Missing Default,ILRepacking.Steps,ResourcesRepackStep,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\Steps\ResourcesRepackStep.cs,Perform,The following switch statement is missing a default case: switch (resource.ResourceType)                              {                                  case ResourceType.AssemblyLinked:                                      // TODO                                      _logger.Warn("AssemblyLinkedResource reference may need to be fixed (to link to newly created assembly)" + resource.Name);                                      break;                                    case ResourceType.Linked:                                      // TODO ? (or not)                                      break;                                    case ResourceType.Embedded:                                      var er = (EmbeddedResource)resource;                                      if (er.Name.EndsWith(".resources"))                                      {                                          // we don't want to write the bamls to other embedded resource files                                          bool shouldWriteCollectedBamlStreams =                                              isPrimaryAssembly &&                                              $"{assembly.Name.Name}.g.resources".Equals(er.Name);                                            if (shouldWriteCollectedBamlStreams)                                              areCollectedStreamsWritten = true;                                            newResource = FixResxResource(assembly' er' assemblyProcessors'                                              shouldWriteCollectedBamlStreams ? bamlStreamCollector : null);                                      }                                      break;                              }
Missing Default,ILRepacking.Steps.SourceServerData,HttpSourceServerDescriptor,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\Steps\SourceServerData\HttpSourceServerDescriptor.cs,TryParse,The following switch statement is missing a default case: switch (currentSection)                      {                          case InitSection:                          case VariablesSection:                              var groups = VariablesRegex.Match(line).Groups;                              var key = groups[1].Value;                              var value = groups[2].Value;                              switch (key)                              {                                  case VersionKey:                                      version = int.Parse(value);                                      break;                                  case VersionControlKey:                                      versionControl = value;                                      break;                                  case TargetKey:                                      target = value;                                      break;                              }                              break;                          case SourceFilesSection:                              sources.Add(SourceFileDescriptor.Parse(line));                              break;                      }
Missing Default,ILRepacking.Steps.SourceServerData,HttpSourceServerDescriptor,D:\research\architectureSmells\repos\gluck_il-repack\ILRepack\Steps\SourceServerData\HttpSourceServerDescriptor.cs,TryParse,The following switch statement is missing a default case: switch (key)                              {                                  case VersionKey:                                      version = int.Parse(value);                                      break;                                  case VersionControlKey:                                      versionControl = value;                                      break;                                  case TargetKey:                                      target = value;                                      break;                              }
