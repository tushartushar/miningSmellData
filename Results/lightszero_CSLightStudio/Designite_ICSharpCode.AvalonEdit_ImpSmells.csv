Implementation smell,Namespace,Class,File,Method,Description
Long Method,ICSharpCode.AvalonEdit.Indentation.CSharp,IndentationReformatter,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Indentation\CSharp\IndentationReformatter.cs,Step,The method has 281 lines of code.
Long Method,ICSharpCode.AvalonEdit.Xml,TagReader,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Xml\TagReader.cs,ReadTag,The method has 120 lines of code.
Long Method,ICSharpCode.AvalonEdit.Xml,TagReader,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Xml\TagReader.cs,ReadText,The method has 120 lines of code.
Long Method,ICSharpCode.AvalonEdit.Xml,TagReader,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Xml\TagReader.cs,Dereference,The method has 106 lines of code.
Complex Method,ICSharpCode.AvalonEdit,TextEditor,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\TextEditor.cs,ScrollTo,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,GetMatchQuality,Cyclomatic complexity of the method is 13
Complex Method,ICSharpCode.AvalonEdit.Document,TextUtilities,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,GetNextCaretPosition,Cyclomatic complexity of the method is 13
Complex Method,ICSharpCode.AvalonEdit.Document,TextSegmentCollection<T>,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,FindOverlappingSegments,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Document,TextSegmentCollection<T>,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,UpdateAugmentedData,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.AvalonEdit.Document,TextSegmentCollection<T>,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,RemoveNode,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Document,TextSegmentCollection<T>,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,FixTreeOnDelete,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.AvalonEdit.Document,TextAnchorTree,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Document\TextAnchorTree.cs,HandleTextChange,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.AvalonEdit.Document,TextAnchorTree,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Document\TextAnchorTree.cs,RemoveNode,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Document,TextAnchorTree,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Document\TextAnchorTree.cs,FixTreeOnDelete,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.AvalonEdit.Document,DocumentLineTree,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Document\DocumentLineTree.cs,RemoveNode,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Document,DocumentLineTree,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Document\DocumentLineTree.cs,FixTreeOnDelete,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,textArea_MouseLeftButtonDown,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.AvalonEdit.Folding,FoldingManager,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Folding\FoldingManager.cs,UpdateFoldings,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.AvalonEdit.Folding,FoldingMargin,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,CalculateFoldLinesForFoldingsActiveAtStart,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Highlighting,DocumentHighlighter,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Highlighting\DocumentHighlighter.cs,HighlightLineInternal,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.AvalonEdit.Highlighting,DocumentHighlighter,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Highlighting\DocumentHighlighter.cs,HighlightNonSpans,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Highlighting,HighlightedInlineBuilder,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Highlighting\HighlightedInlineBuilder.cs,SetHighlighting,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Highlighting,HighlightedLine,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Highlighting\HighlightedLine.cs,ToHtml,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.AvalonEdit.Highlighting,HtmlClipboard,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Highlighting\HtmlClipboard.cs,CreateHtmlFragment,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,ImportRuleSet,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,ImportRegex,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Indentation.CSharp,IndentationReformatter,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Indentation\CSharp\IndentationReformatter.cs,Step,Cyclomatic complexity of the method is 36
Complex Method,ICSharpCode.AvalonEdit.Rendering,BackgroundGeometryBuilder,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\BackgroundGeometryBuilder.cs,GetRectsForSegmentImpl,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Rendering,BackgroundGeometryBuilder,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\BackgroundGeometryBuilder.cs,ProcessTextLines,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Rendering,ColorizingTransformer,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\ColorizingTransformer.cs,ChangeVisualElements,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.AvalonEdit.Rendering,HeightTree,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\HeightTree.cs,MergeCollapsedSectionsIfPossible,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.AvalonEdit.Rendering,HeightTree,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\HeightTree.cs,RemoveNode,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Rendering,HeightTree,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\HeightTree.cs,FixTreeOnDelete,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.AvalonEdit.Rendering,HeightTree,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\HeightTree.cs,AddRemoveCollapsedSection,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,InsertLayer,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,MeasureOverride,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,CreateAndMeasureVisualLines,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,BuildVisualLine,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,ArrangeOverride,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,OnRender,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.AvalonEdit.Rendering,VisualLine,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLine.cs,PerformVisualElementConstruction,Cyclomatic complexity of the method is 13
Complex Method,ICSharpCode.AvalonEdit.Rendering,VisualLine,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLine.cs,GetNextCaretPosition,Cyclomatic complexity of the method is 13
Complex Method,ICSharpCode.AvalonEdit.Rendering,VisualLineTextSource,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLineTextSource.cs,GetTextRun,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Utils,CompressingTreeList<T>,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Utils\CompressingTreeList.cs,RemoveNode,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Utils,CompressingTreeList<T>,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Utils\CompressingTreeList.cs,FixTreeOnDelete,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.AvalonEdit.Utils,Rope<T>,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Utils\Rope.cs,FindNodeUsingCache,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.AvalonEdit.Xml,TagMatchingHeuristics,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Xml\TagMatchingHeuristics.cs,ReadDocument,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.AvalonEdit.Xml,TagReader,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Xml\TagReader.cs,ReadTag,Cyclomatic complexity of the method is 15
Complex Method,ICSharpCode.AvalonEdit.Xml,TagReader,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Xml\TagReader.cs,ReadContentOfDTD,Cyclomatic complexity of the method is 14
Complex Method,ICSharpCode.AvalonEdit.Xml,TagReader,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Xml\TagReader.cs,ReadAttribulte,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.AvalonEdit.Xml,TagReader,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Xml\TagReader.cs,ReadAttributeValue,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.AvalonEdit.Xml,TagReader,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Xml\TagReader.cs,ReadText,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.AvalonEdit.Xml,TagReader,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Xml\TagReader.cs,Dereference,Cyclomatic complexity of the method is 10
Long Parameter List,ICSharpCode.AvalonEdit.Document,OffsetChangeMapEntry,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Document\OffsetChangeMap.cs,OffsetChangeMapEntry,The method has 5 parameters. Parameters: offset' removalLength' insertionLength' removalNeverCausesAnchorDeletion' defaultAnchorMovementIsBeforeInsertion
Long Parameter List,ICSharpCode.AvalonEdit.Document,TextSegmentCollection<T>,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,CheckNodeProperties,The method has 5 parameters. Parameters: node' parentNode' parentColor' blackCount' expectedBlackCount
Long Parameter List,ICSharpCode.AvalonEdit.Document,TextAnchorTree,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Document\TextAnchorTree.cs,CheckNodeProperties,The method has 5 parameters. Parameters: node' parentNode' parentColor' blackCount' expectedBlackCount
Long Parameter List,ICSharpCode.AvalonEdit.Document,DocumentLineTree,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Document\DocumentLineTree.cs,CheckNodeProperties,The method has 5 parameters. Parameters: node' parentNode' parentColor' blackCount' expectedBlackCount
Long Parameter List,ICSharpCode.AvalonEdit.Editing,CaretNavigationCommandHandler,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Editing\CaretNavigationCommandHandler.cs,MoveCaretUpDown,The method has 5 parameters. Parameters: textArea' direction' visualLine' textLine' caretVisualColumn
Long Parameter List,ICSharpCode.AvalonEdit.Editing,CaretNavigationCommandHandler,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Editing\CaretNavigationCommandHandler.cs,SetCaretPosition,The method has 5 parameters. Parameters: textArea' targetVisualLine' targetLine' newVisualColumn' allowWrapToNextLine
Long Parameter List,ICSharpCode.AvalonEdit.Editing,ImeSupport,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Editing\ImeSupport.cs,WndProc,The method has 5 parameters. Parameters: hWnd' msg' wParam' lParam' handled
Long Parameter List,ICSharpCode.AvalonEdit.Rendering,HeightTree,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\HeightTree.cs,CheckNodeProperties,The method has 5 parameters. Parameters: node' parentNode' parentColor' blackCount' expectedBlackCount
Long Parameter List,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,BuildVisualLine,The method has 6 parameters. Parameters: documentLine' globalTextRunProperties' paragraphProperties' elementGeneratorsArray' lineTransformersArray' availableSize
Long Parameter List,ICSharpCode.AvalonEdit.Utils,CompressingTreeList<T>,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Utils\CompressingTreeList.cs,CheckNodeProperties,The method has 5 parameters. Parameters: node' parentNode' parentColor' blackCount' expectedBlackCount
Long Parameter List,ICSharpCode.AvalonEdit.Utils,TextFormatterFactory,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Utils\TextFormatterFactory.cs,CreateFormattedText,The method has 5 parameters. Parameters: element' text' typeface' emSize' foreground
Long Parameter List,ICSharpCode.AvalonEdit.Xml,TagReader,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Xml\TagReader.cs,OnSyntaxError,The method has 5 parameters. Parameters: obj' start' end' message' args
Long Identifier,ICSharpCode.AvalonEdit,TextEditor,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\TextEditor.cs,,The length of the parameter HorizontalScrollBarVisibilityProperty is 37.
Long Identifier,ICSharpCode.AvalonEdit,TextEditor,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\TextEditor.cs,,The length of the parameter VerticalScrollBarVisibilityProperty is 35.
Long Identifier,ICSharpCode.AvalonEdit,TextEditorOptions,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\TextEditorOptions.cs,,The length of the parameter requireControlModifierForHyperlinkClick is 39.
Long Identifier,ICSharpCode.AvalonEdit.Document,OffsetChangeMapEntry,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Document\OffsetChangeMap.cs,OffsetChangeMapEntry,The length of the parameter removalNeverCausesAnchorDeletion is 32.
Long Identifier,ICSharpCode.AvalonEdit.Document,OffsetChangeMapEntry,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Document\OffsetChangeMap.cs,OffsetChangeMapEntry,The length of the parameter defaultAnchorMovementIsBeforeInsertion is 38.
Long Identifier,ICSharpCode.AvalonEdit.Document,OffsetChangeMapEntry,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Document\OffsetChangeMap.cs,,The length of the parameter insertionLengthWithMovementFlag is 31.
Long Identifier,ICSharpCode.AvalonEdit.Document,TextAnchorTree,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Document\TextAnchorTree.cs,InsertText,The length of the parameter defaultAnchorMovementIsBeforeInsertion is 38.
Long Identifier,ICSharpCode.AvalonEdit.Document,TextAnchorTree,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Document\TextAnchorTree.cs,PerformInsertText,The length of the parameter defaultAnchorMovementIsBeforeInsertion is 38.
Long Identifier,ICSharpCode.AvalonEdit.Document,UndoStack,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Document\UndoStack.cs,,The length of the parameter elementsOnUndoUntilOriginalFile is 31.
Long Identifier,ICSharpCode.AvalonEdit.Editing,Caret,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Editing\Caret.cs,,The length of the parameter raisePositionChangedOnUpdateFinished is 36.
Long Identifier,ICSharpCode.AvalonEdit.Editing,ImeNativeWrapper,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Editing\ImeNativeWrapper.cs,,The length of the parameter textFrameworkThreadMgrInitialized is 33.
Long Identifier,ICSharpCode.AvalonEdit.Folding,FoldingMargin,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,,The length of the parameter FoldingMarkerBackgroundBrushProperty is 36.
Long Identifier,ICSharpCode.AvalonEdit.Folding,FoldingMargin,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,,The length of the parameter SelectedFoldingMarkerBrushProperty is 34.
Long Identifier,ICSharpCode.AvalonEdit.Folding,FoldingMargin,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,,The length of the parameter SelectedFoldingMarkerBackgroundBrushProperty is 44.
Long Identifier,ICSharpCode.AvalonEdit.Rendering,DocumentColorizingTransformer,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\DocumentColorizingTransformer.cs,,The length of the parameter currentDocumentLineStartOffset is 30.
Long Identifier,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,Redraw,The length of the parameter changedSomethingBeforeOrInLine is 30.
Long Identifier,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,,The length of the parameter singleCharacterElementGenerator is 31.
Long Identifier,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,,The length of the parameter visualLinesWithOutstandingInlineObjects is 39.
Long Identifier,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,,The length of the parameter NonPrintableCharacterBrushProperty is 34.
Long Identifier,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,,The length of the parameter LinkTextForegroundBrushProperty is 31.
Long Identifier,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,,The length of the parameter LinkTextBackgroundBrushProperty is 31.
Long Identifier,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,,The length of the parameter AdditionalHorizontalScrollAmount is 32.
Long Identifier,ICSharpCode.AvalonEdit.Rendering,VisualLineElement,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLineElement.cs,SplitHelper,The length of the parameter relativeSplitRelativeTextOffset is 31.
Long Identifier,ICSharpCode.AvalonEdit.Search,DropDownButton,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Search\DropDownButton.cs,,The length of the parameter IsDropDownContentOpenPropertyKey is 32.
Long Statement,ICSharpCode.AvalonEdit,TextEditor,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\TextEditor.cs,OnLineNumbersForegroundChanged,The length of the statement  "			var lineNumberMargin = editor.TextArea.LeftMargins.FirstOrDefault(margin => margin is LineNumberMargin) as LineNumberMargin;; " is 125.
Long Statement,ICSharpCode.AvalonEdit,TextEditor,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\TextEditor.cs,Load,The length of the statement  "				this.Encoding = reader.CurrentEncoding; // assign encoding after ReadToEnd() so that the StreamReader can autodetect the encoding " is 129.
Long Statement,ICSharpCode.AvalonEdit,TextEditor,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\TextEditor.cs,ScrollTo,The length of the statement  "				Point p = textArea.TextView.GetVisualPosition(new TextViewPosition(line' Math.Max(1' column))' VisualYPosition.LineMiddle); " is 123.
Long Statement,ICSharpCode.AvalonEdit.CodeCompletion,CompletionWindowBase,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\CompletionWindowBase.cs,TextViewScrollOffsetChanged,The length of the statement  "			Rect visibleRect = new Rect(scrollInfo.HorizontalOffset' scrollInfo.VerticalOffset' scrollInfo.ViewportWidth' scrollInfo.ViewportHeight); " is 137.
Long Statement,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,SelectItemFiltering,The length of the statement  "			var listToFilter = (this.currentList != null && (!string.IsNullOrEmpty(this.currentText)) && (!string.IsNullOrEmpty(query)) && " is 126.
Long Statement,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,SelectItemFiltering,The length of the statement  "			ICompletionData suggestedItem = listBox.SelectedIndex != -1 ? (ICompletionData)(listBox.Items[listBox.SelectedIndex]) : null; " is 125.
Long Statement,ICSharpCode.AvalonEdit.CodeCompletion,CompletionWindow,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\CompletionWindow.cs,completionList_InsertionRequested,The length of the statement  "				item.Complete(this.TextArea' new AnchorSegment(this.TextArea.Document' this.StartOffset' this.EndOffset - this.StartOffset)' e); " is 128.
Long Statement,ICSharpCode.AvalonEdit.CodeCompletion,InsightWindow,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\InsightWindow.cs,OnSourceInitialized,The length of the statement  "			Rect workingArea = System.Windows.Forms.Screen.FromPoint(pointOnScreen.ToSystemDrawing()).WorkingArea.ToWpf().TransformFromDevice(this); " is 136.
Long Statement,ICSharpCode.AvalonEdit.Document,SimpleSegment,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Document\ISegment.cs,ToString,The length of the statement  "			return "[Offset=" + Offset.ToString(CultureInfo.InvariantCulture) + "' Length=" + Length.ToString(CultureInfo.InvariantCulture) + "]"; " is 134.
Long Statement,ICSharpCode.AvalonEdit.Document,AnchorSegment,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Document\ISegment.cs,ToString,The length of the statement  "			return "[Offset=" + Offset.ToString(CultureInfo.InvariantCulture) + "' EndOffset=" + EndOffset.ToString(CultureInfo.InvariantCulture) + "]"; " is 140.
Long Statement,ICSharpCode.AvalonEdit.Document,OffsetChangeMapEntry,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Document\OffsetChangeMap.cs,Equals,The length of the statement  "			return offset == other.offset && insertionLengthWithMovementFlag == other.insertionLengthWithMovementFlag && removalLengthWithDeletionFlag == other.removalLengthWithDeletionFlag; " is 178.
Long Statement,ICSharpCode.AvalonEdit.Document,TextSegmentCollection<T>,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,UpdateOffsets,The length of the statement  "				throw new InvalidOperationException("This TextSegmentCollection will automatically update offsets; do not call UpdateOffsets manually!"); " is 137.
Long Statement,ICSharpCode.AvalonEdit.Document,TextSegmentCollection<T>,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,UpdateOffsets,The length of the statement  "				throw new InvalidOperationException("This TextSegmentCollection will automatically update offsets; do not call UpdateOffsets manually!"); " is 137.
Long Statement,ICSharpCode.AvalonEdit.Document,TextSegmentCollection<T>,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,UpdateOffsetsInternal,The length of the statement  "			// Special case pure insertions' because they don't always cause a text segment to increase in size when the replaced region " is 124.
Long Statement,ICSharpCode.AvalonEdit.Document,TextSegmentCollection<T>,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,CopyTo,The length of the statement  "				throw new ArgumentOutOfRangeException("arrayIndex"' arrayIndex' "Value must be between 0 and " + (array.Length - count)); " is 121.
Long Statement,ICSharpCode.AvalonEdit.Document,DocumentLineTree,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Document\DocumentLineTree.cs,CopyTo,The length of the statement  "				throw new ArgumentOutOfRangeException("arrayIndex"' arrayIndex' "Value must be between 0 and " + (array.Length - LineCount)); " is 125.
Long Statement,ICSharpCode.AvalonEdit.Document,TextDocument,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Document\TextDocument.cs,ThrowIfRangeInvalid,The length of the statement  "				throw new ArgumentOutOfRangeException("offset"' offset' "0 <= offset <= " + rope.Length.ToString(CultureInfo.InvariantCulture)); " is 128.
Long Statement,ICSharpCode.AvalonEdit.Document,TextDocument,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Document\TextDocument.cs,ThrowIfRangeInvalid,The length of the statement  "				throw new ArgumentOutOfRangeException("length"' length' "0 <= length' offset(" + offset + ")+length <= " + rope.Length.ToString(CultureInfo.InvariantCulture)); " is 159.
Long Statement,ICSharpCode.AvalonEdit.Document,TextDocument,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Document\TextDocument.cs,CreateAnchor,The length of the statement  "				throw new ArgumentOutOfRangeException("offset"' offset' "0 <= offset <= " + rope.Length.ToString(CultureInfo.InvariantCulture)); " is 128.
Long Statement,ICSharpCode.AvalonEdit.Editing,Caret,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Editing\Caret.cs,RevalidateVisualColumn,The length of the statement  "			int newVisualColumnForwards = visualLine.GetNextCaretPosition(position.VisualColumn - 1' LogicalDirection.Forward' CaretPositioningMode.Normal' textArea.Selection.EnableVirtualSpace); " is 183.
Long Statement,ICSharpCode.AvalonEdit.Editing,Caret,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Editing\Caret.cs,RevalidateVisualColumn,The length of the statement  "				int newVisualColumnBackwards = visualLine.GetNextCaretPosition(position.VisualColumn + 1' LogicalDirection.Backward' CaretPositioningMode.Normal' textArea.Selection.EnableVirtualSpace); " is 185.
Long Statement,ICSharpCode.AvalonEdit.Editing,CaretNavigationCommandHandler,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Editing\CaretNavigationCommandHandler.cs,OnMoveCaretExtendSelection,The length of the statement  "					if (!textArea.Document.IsInUpdate) // if we're inside a larger update (e.g. called by EditingCommandHandler.OnDelete())' avoid calculating the caret rectangle now " is 162.
Long Statement,ICSharpCode.AvalonEdit.Editing,CaretNavigationCommandHandler,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Editing\CaretNavigationCommandHandler.cs,MoveCaretToStartOfLine,The length of the statement  "			int newVC = visualLine.GetNextCaretPosition(-1' LogicalDirection.Forward' CaretPositioningMode.WordStart' textArea.Selection.EnableVirtualSpace); " is 145.
Long Statement,ICSharpCode.AvalonEdit.Editing,CaretNavigationCommandHandler,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Editing\CaretNavigationCommandHandler.cs,MoveCaretRight,The length of the statement  "			int pos = visualLine.GetNextCaretPosition(caretPosition.VisualColumn' LogicalDirection.Forward' mode' textArea.Selection.EnableVirtualSpace); " is 141.
Long Statement,ICSharpCode.AvalonEdit.Editing,CaretNavigationCommandHandler,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Editing\CaretNavigationCommandHandler.cs,MoveCaretRight,The length of the statement  "					Debug.Assert(visualLine.LastDocumentLine.Offset + visualLine.LastDocumentLine.TotalLength == textArea.Document.TextLength); " is 123.
Long Statement,ICSharpCode.AvalonEdit.Editing,CaretNavigationCommandHandler,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Editing\CaretNavigationCommandHandler.cs,MoveCaretLeft,The length of the statement  "			int pos = visualLine.GetNextCaretPosition(caretPosition.VisualColumn' LogicalDirection.Backward' mode' textArea.Selection.EnableVirtualSpace); " is 142.
Long Statement,ICSharpCode.AvalonEdit.Editing,CaretNavigationCommandHandler,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Editing\CaretNavigationCommandHandler.cs,MoveCaretLeft,The length of the statement  "					pos = previousLine.GetNextCaretPosition(previousLine.VisualLength + 1' LogicalDirection.Backward' mode' textArea.Selection.EnableVirtualSpace); " is 143.
Long Statement,ICSharpCode.AvalonEdit.Editing,EditingCommandHandler,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Editing\EditingCommandHandler.cs,OnTab,The length of the statement  "								textArea.Document.Replace(offset' 0' textArea.Options.IndentationString' OffsetChangeMappingType.KeepAnchorBeforeInsertion); " is 124.
Long Statement,ICSharpCode.AvalonEdit.Editing,EditingCommandHandler,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Editing\EditingCommandHandler.cs,OnCut,The length of the statement  "					ISegment[] segmentsToDelete = textArea.GetDeletableSegments(new SimpleSegment(currentLine.Offset' currentLine.TotalLength)); " is 124.
Long Statement,ICSharpCode.AvalonEdit.Editing,EditingCommandHandler,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Editing\EditingCommandHandler.cs,CopyWholeLine,The length of the statement  "			HtmlClipboard.SetHtml(data' HtmlClipboard.CreateHtmlFragment(textArea.Document' highlighter' wholeLine' new HtmlOptions(textArea.Options))); " is 140.
Long Statement,ICSharpCode.AvalonEdit.Editing,SelectionSegment,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Editing\SelectionSegment.cs,ToString,The length of the statement  "			return string.Format("[SelectionSegment StartOffset={0}' EndOffset={1}' StartVC={2}' EndVC={3}]"' startOffset' endOffset' startVC' endVC); " is 138.
Long Statement,ICSharpCode.AvalonEdit.Editing,RectangleSelection,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Editing\RectangleSelection.cs,UpdateOnDocumentChange,The length of the statement  "			TextLocation newStartLocation = textArea.Document.GetLocation(e.GetNewOffset(topLeftOffset' AnchorMovementType.AfterInsertion)); " is 128.
Long Statement,ICSharpCode.AvalonEdit.Editing,RectangleSelection,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Editing\RectangleSelection.cs,UpdateOnDocumentChange,The length of the statement  "			TextLocation newEndLocation = textArea.Document.GetLocation(e.GetNewOffset(bottomRightOffset' AnchorMovementType.BeforeInsertion)); " is 131.
Long Statement,ICSharpCode.AvalonEdit.Editing,RectangleSelection,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Editing\RectangleSelection.cs,ReplaceSelectionWithText,The length of the statement  "				TextViewPosition start = new TextViewPosition(document.GetLocation(topLeftOffset)' GetVisualColumnFromXPos(startLine' startXPos)); " is 130.
Long Statement,ICSharpCode.AvalonEdit.Editing,RectangleSelection,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Editing\RectangleSelection.cs,ReplaceSelectionWithText,The length of the statement  "				TextViewPosition end = new TextViewPosition(document.GetLocation(bottomRightOffset)' GetVisualColumnFromXPos(endLine' endXPos)); " is 128.
Long Statement,ICSharpCode.AvalonEdit.Editing,RectangleSelection,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Editing\RectangleSelection.cs,ReplaceSelectionWithText,The length of the statement  "				textArea.Caret.Position = textArea.TextView.GetPosition(new Point(GetXPos(textArea' pos)' textArea.TextView.GetVisualTopByDocumentLine(Math.Max(startLine' endLine)))).GetValueOrDefault(); " is 187.
Long Statement,ICSharpCode.AvalonEdit.Editing,RectangleSelection,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Editing\RectangleSelection.cs,ReplaceSingleLineText,The length of the statement  "					newText = AddSpacesIfRequired(newText' new TextViewPosition(document.GetLocation(lineSegment.StartOffset)' lineSegment.StartVisualColumn)' new TextViewPosition(document.GetLocation(lineSegment.EndOffset)' lineSegment.EndVisualColumn)); " is 235.
Long Statement,ICSharpCode.AvalonEdit.Editing,RectangleSelection,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Editing\RectangleSelection.cs,ReplaceSingleLineText,The length of the statement  "						if (segmentsToDelete[i].Offset == SurroundingSegment.Offset && segmentsToDelete[i].Length == SurroundingSegment.Length) { " is 121.
Long Statement,ICSharpCode.AvalonEdit.Editing,RectangleSelection,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Editing\RectangleSelection.cs,ReplaceSingleLineText,The length of the statement  "							newText = AddSpacesIfRequired(newText' new TextViewPosition(document.GetLocation(lineSegment.StartOffset)' lineSegment.StartVisualColumn)' new TextViewPosition(document.GetLocation(lineSegment.EndOffset)' lineSegment.EndVisualColumn)); " is 235.
Long Statement,ICSharpCode.AvalonEdit.Editing,RectangleSelection,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Editing\RectangleSelection.cs,PerformRectangularPaste,The length of the statement  "			int newLineCount = text.Count(c => c == '\n'); // TODO might not work in all cases' but single \r line endings are really rare today. " is 133.
Long Statement,ICSharpCode.AvalonEdit.Editing,RectangleSelection,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Editing\RectangleSelection.cs,PerformRectangularPaste,The length of the statement  "					RectangleSelection rsel = new RectangleSelection(textArea' startPosition' endLocation.Line' GetXPos(textArea' startPosition)); " is 126.
Long Statement,ICSharpCode.AvalonEdit.Editing,RectangleSelection,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Editing\RectangleSelection.cs,ToString,The length of the statement  "			return string.Format("[RectangleSelection {0} {1} {2} to {3} {4} {5}]"' startLine' topLeftOffset' startXPos' endLine' bottomRightOffset' endXPos); " is 146.
Long Statement,ICSharpCode.AvalonEdit.Editing,Selection,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Editing\Selection.cs,Create,The length of the statement  "			if (textArea.Document.GetOffset(start.Location) == textArea.Document.GetOffset(end.Location) && start.VisualColumn == end.VisualColumn) " is 135.
Long Statement,ICSharpCode.AvalonEdit.Editing,Selection,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Editing\Selection.cs,IsInVirtualSpace,The length of the statement  "			return pos.VisualColumn > textArea.TextView.GetOrConstructVisualLine(textArea.Document.GetLineByNumber(pos.Line)).VisualLength; " is 127.
Long Statement,ICSharpCode.AvalonEdit.Editing,SelectionColorizer,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Editing\SelectionColorizer.cs,Colorize,The length of the statement  "					startColumn = context.VisualLine.ValidateVisualColumn(segment.StartOffset' segment.StartVisualColumn' textArea.Selection.EnableVirtualSpace); " is 141.
Long Statement,ICSharpCode.AvalonEdit.Editing,SelectionColorizer,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Editing\SelectionColorizer.cs,Colorize,The length of the statement  "					endColumn = context.VisualLine.ValidateVisualColumn(segment.EndOffset' segment.EndVisualColumn' textArea.Selection.EnableVirtualSpace); " is 135.
Long Statement,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,StartDrag,The length of the statement  "			if (deleteOnMove != null && resultEffect == DragDropEffects.Move && (allowedEffects & DragDropEffects.Move) == DragDropEffects.Move) { " is 134.
Long Statement,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,textArea_MouseLeftButtonDown,The length of the statement  "								textArea.Selection = textArea.Selection.SetEndpoint(new TextViewPosition(textArea.Document.GetLocation(startWord.Offset))); " is 123.
Long Statement,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,textArea_MouseLeftButtonDown,The length of the statement  "								textArea.Selection = textArea.Selection.SetEndpoint(new TextViewPosition(textArea.Document.GetLocation(startWord.EndOffset))); " is 126.
Long Statement,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,GetWordAtMousePosition,The length of the statement  "				int wordStartVC = line.GetNextCaretPosition(visualColumn + 1' LogicalDirection.Backward' CaretPositioningMode.WordStartOrSymbol' textArea.Selection.EnableVirtualSpace); " is 168.
Long Statement,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,GetWordAtMousePosition,The length of the statement  "				int wordEndVC = line.GetNextCaretPosition(wordStartVC' LogicalDirection.Forward' CaretPositioningMode.WordBorderOrSymbol' textArea.Selection.EnableVirtualSpace); " is 161.
Long Statement,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,textArea_MouseMove,The length of the statement  "			if (mode == SelectionMode.Normal || mode == SelectionMode.WholeWord || mode == SelectionMode.WholeLine || mode == SelectionMode.Rectangular) { " is 142.
Long Statement,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,textArea_MouseLeftButtonUp,The length of the statement  "			} else if (mode == SelectionMode.Normal || mode == SelectionMode.WholeWord || mode == SelectionMode.WholeLine || mode == SelectionMode.Rectangular) { " is 149.
Long Statement,ICSharpCode.AvalonEdit.Editing,SimpleSelection,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Editing\SimpleSelection.cs,ReplaceSelectionWithText,The length of the statement  "						if (segmentsToDelete[i].Offset == SurroundingSegment.Offset && segmentsToDelete[i].Length == SurroundingSegment.Length) { " is 121.
Long Statement,ICSharpCode.AvalonEdit.Editing,SimpleSelection,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Editing\SimpleSelection.cs,UpdateOnDocumentChange,The length of the statement  "				new TextViewPosition(textArea.Document.GetLocation(e.GetNewOffset(startOffset' AnchorMovementType.Default))' start.VisualColumn)' " is 129.
Long Statement,ICSharpCode.AvalonEdit.Editing,SimpleSelection,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Editing\SimpleSelection.cs,UpdateOnDocumentChange,The length of the statement  "				new TextViewPosition(textArea.Document.GetLocation(e.GetNewOffset(endOffset' AnchorMovementType.Default))' end.VisualColumn) " is 124.
Long Statement,ICSharpCode.AvalonEdit.Editing,TextArea,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Editing\TextArea.cs,OnTextInput,The length of the statement  "			//Debug.WriteLine("TextInput: Text='" + e.Text + "' SystemText='" + e.SystemText + "' ControlText='" + e.ControlText + "'"); " is 124.
Long Statement,ICSharpCode.AvalonEdit.Editing,TextArea,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Editing\TextArea.cs,GetDeletableSegments,The length of the statement  "					throw new InvalidOperationException("ReadOnlySectionProvider returned incorrect segments (outside of input segment / wrong order)"); " is 132.
Long Statement,ICSharpCode.AvalonEdit.Editing,TextArea,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Editing\TextArea.cs,GetDeletableSegments,The length of the statement  "				throw new InvalidOperationException("ReadOnlySectionProvider returned incorrect segments (outside of input segment / wrong order)"); " is 132.
Long Statement,ICSharpCode.AvalonEdit.Folding,FoldingMargin,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,DrawFoldLines,The length of the statement  "						drawingContext.DrawLine(endMarker[tlNumber]' new Point(markerXPos - pixelSize.Width / 2' visualPos)' new Point(RenderSize.Width' visualPos)); " is 141.
Long Statement,ICSharpCode.AvalonEdit.Folding,FoldingMargin,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,DrawFoldLines,The length of the statement  "							drawingContext.DrawLine(currentPen' new Point(markerXPos' startY + pixelSize.Height / 2)' new Point(markerXPos' visualPos - pixelSize.Height / 2)); " is 147.
Long Statement,ICSharpCode.AvalonEdit.Folding,FoldingMargin,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,DrawFoldLines,The length of the statement  "				drawingContext.DrawLine(currentPen' new Point(markerXPos' startY + pixelSize.Height / 2)' new Point(markerXPos' RenderSize.Height)); " is 132.
Long Statement,ICSharpCode.AvalonEdit.Folding,FoldingSection,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Folding\FoldingSection.cs,ValidateCollapsedLineSections,The length of the statement  "							Debug.WriteLine("CollapsedLineSection validation - recreate collapsed section from " + startLinePlusOne + " to " + endLine); " is 124.
Long Statement,ICSharpCode.AvalonEdit.Folding,XmlFoldingStrategy,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Folding\XmlFoldingStrategy.cs,CreateElementFoldStart,The length of the statement  "			//XmlFoldStart newFoldStart = new XmlFoldStart(reader.Prefix' reader.LocalName' reader.LineNumber - 1' reader.LinePosition - 2); " is 128.
Long Statement,ICSharpCode.AvalonEdit.Highlighting,DocumentHighlighter,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Highlighting\DocumentHighlighter.cs,HighlightLineAndUpdateTreeList,The length of the statement  "				//Debug.WriteLine("Span stack in line " + lineNumber + " changed from " + storedSpanStacks[lineNumber] + " to " + spanStack); " is 125.
Long Statement,ICSharpCode.AvalonEdit.Highlighting,HighlightedLine,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Highlighting\HighlightedLine.cs,ToHtml,The length of the statement  "				throw new ArgumentOutOfRangeException("startOffset"' startOffset' "Value must be between " + documentLineStartOffset + " and " + documentLineEndOffset); " is 152.
Long Statement,ICSharpCode.AvalonEdit.Highlighting,HighlightedLine,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Highlighting\HighlightedLine.cs,ToHtml,The length of the statement  "				throw new ArgumentOutOfRangeException("endOffset"' endOffset' "Value must be between startOffset and " + documentLineEndOffset); " is 128.
Long Statement,ICSharpCode.AvalonEdit.Highlighting,HighlightingColorizer,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Highlighting\HighlightingColorizer.cs,textView_VisualLineConstructionStarting,The length of the statement  "				// This is necessary in case the document gets modified above the FirstLineInView so that the highlighting state changes. " is 121.
Long Statement,ICSharpCode.AvalonEdit.Highlighting,TextViewDocumentHighlighter,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Highlighting\HighlightingColorizer.cs,OnHighlightStateChanged,The length of the statement  "				 * But doing it too early means it doesn't have the information necessary to re-highlight and redraw only the desired parts. " is 123.
Long Statement,ICSharpCode.AvalonEdit.Highlighting,DelayLoadedHighlightingDefinition,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Highlighting\HighlightingManager.cs,GetDefinition,The length of the statement  "							throw new InvalidOperationException("Tried to create delay-loaded highlighting definition recursively. Make sure the are no cyclic references between the highlighting definitions."); " is 182.
Long Statement,ICSharpCode.AvalonEdit.Highlighting,DefaultHighlightingManager,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Highlighting\HighlightingManager.cs,RegisterHighlighting,The length of the statement  "//						new System.Runtime.Serialization.Formatters.Binary.BinaryFormatter().Serialize(fs' Xshd.HighlightingLoader.Load(xshd' this)); " is 133.
Long Statement,ICSharpCode.AvalonEdit.Highlighting,HtmlClipboard,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Highlighting\HtmlClipboard.cs,SetHtml,The length of the statement  "			string htmlEnd = "<!--EndFragment-->" + Environment.NewLine + "</BODY>" + Environment.NewLine + "</HTML>" + Environment.NewLine; " is 128.
Long Statement,ICSharpCode.AvalonEdit.Highlighting.Xshd,SaveXshdVisitor,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Highlighting\Xshd\SaveXshdVisitor.cs,WriteRuleSetReference,The length of the statement  "					writer.WriteAttributeString("ruleSet"' ruleSetReference.ReferencedDefinition + "/" + ruleSetReference.ReferencedElement); " is 121.
Long Statement,ICSharpCode.AvalonEdit.Highlighting.Xshd,SaveXshdVisitor,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Highlighting\Xshd\SaveXshdVisitor.cs,WriteColorAttributes,The length of the statement  "				writer.WriteAttributeString("fontWeight"' V2Loader.FontWeightConverter.ConvertToInvariantString(color.FontWeight.Value).ToLowerInvariant()); " is 140.
Long Statement,ICSharpCode.AvalonEdit.Highlighting.Xshd,SaveXshdVisitor,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Highlighting\Xshd\SaveXshdVisitor.cs,WriteColorAttributes,The length of the statement  "				writer.WriteAttributeString("fontStyle"' V2Loader.FontStyleConverter.ConvertToInvariantString(color.FontStyle.Value).ToLowerInvariant()); " is 137.
Long Statement,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,GetColorFromElement,The length of the statement  "			if (!element.HasAttribute("bold") && !element.HasAttribute("italic") && !element.HasAttribute("color") && !element.HasAttribute("bgcolor")) " is 139.
Long Statement,ICSharpCode.AvalonEdit.Highlighting.Xshd,V2Loader,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Highlighting\Xshd\V2Loader.cs,Error,The length of the statement  "				return new HighlightingDefinitionInvalidException(HighlightingLoader.FormatExceptionMessage(message' lineInfo.LineNumber' lineInfo.LinePosition)); " is 146.
Long Statement,ICSharpCode.AvalonEdit.Highlighting.Xshd,TranslateElementVisitor,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Highlighting\Xshd\XmlHighlightingDefinition.cs,GetDefinition,The length of the statement  "					throw Error(position' "Resolving references to other syntax definitions is not possible because the IHighlightingDefinitionReferenceResolver is null."); " is 152.
Long Statement,ICSharpCode.AvalonEdit.Indentation.CSharp,IndentationReformatter,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Indentation\CSharp\IndentationReformatter.cs,Step,The length of the statement  "				if (block.LastWord == "case" || line.StartsWith("case "' StringComparison.Ordinal) || line.StartsWith(block.LastWord + ":"' StringComparison.Ordinal)) " is 150.
Long Statement,ICSharpCode.AvalonEdit.Rendering,BackgroundGeometryBuilder,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\BackgroundGeometryBuilder.cs,ProcessTextLines,The length of the statement  "					// The following special cases are necessary to get rid of empty rectangles at the end of a TextLine if "Show Spaces" is active. " is 128.
Long Statement,ICSharpCode.AvalonEdit.Rendering,BackgroundGeometryBuilder,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\BackgroundGeometryBuilder.cs,ProcessTextLines,The length of the statement  "					// If not excluded once' the same rectangle is calculated (and added) twice (since the offset could be mapped to two visual positions; end/start of line)' if there is no trailing whitespace. " is 190.
Long Statement,ICSharpCode.AvalonEdit.Rendering,BackgroundGeometryBuilder,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\BackgroundGeometryBuilder.cs,ProcessTextLines,The length of the statement  "					// Skip this TextLine segment' if it is at the end of this line and this line is not the last line of the VisualLine and the selection continues and there is no trailing whitespace. " is 181.
Long Statement,ICSharpCode.AvalonEdit.Rendering,BackgroundGeometryBuilder,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\BackgroundGeometryBuilder.cs,ProcessTextLines,The length of the statement  "					if (segmentEndVCInLine == visualEndCol && i < visualLine.TextLines.Count - 1 && segmentEndVC > segmentEndVCInLine && line.TrailingWhitespaceLength == 0) " is 152.
Long Statement,ICSharpCode.AvalonEdit.Rendering,BackgroundGeometryBuilder,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\BackgroundGeometryBuilder.cs,ProcessTextLines,The length of the statement  "					if (segmentStartVCInLine == visualStartCol && i > 0 && segmentStartVC < segmentStartVCInLine && visualLine.TextLines[i - 1].TrailingWhitespaceLength == 0) " is 154.
Long Statement,ICSharpCode.AvalonEdit.Rendering,BackgroundGeometryBuilder,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\BackgroundGeometryBuilder.cs,ProcessTextLines,The length of the statement  "						double left = (segmentStartVC > visualLine.VisualLengthWithEndOfLineMarker ? visualLine.GetTextLineVisualXPosition(lastTextLine' segmentStartVC) : line.Width) - scrollOffset.X; " is 176.
Long Statement,ICSharpCode.AvalonEdit.Rendering,BackgroundGeometryBuilder,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\BackgroundGeometryBuilder.cs,ProcessTextLines,The length of the statement  "						double right = ((segmentEndVC == int.MaxValue || line != lastTextLine) ? Math.Max(((IScrollInfo)textView).ExtentWidth' ((IScrollInfo)textView).ViewportWidth) : visualLine.GetTextLineVisualXPosition(lastTextLine' segmentEndVC)) - scrollOffset.X; " is 244.
Long Statement,ICSharpCode.AvalonEdit.Rendering,DocumentColorizingTransformer,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\DocumentColorizingTransformer.cs,ChangeLinePart,The length of the statement  "				throw new ArgumentOutOfRangeException("startOffset"' startOffset' "Value must be between " + currentDocumentLineStartOffset + " and " + currentDocumentLineEndOffset); " is 166.
Long Statement,ICSharpCode.AvalonEdit.Rendering,DocumentColorizingTransformer,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\DocumentColorizingTransformer.cs,ChangeLinePart,The length of the statement  "				throw new ArgumentOutOfRangeException("endOffset"' endOffset' "Value must be between " + startOffset + " and " + currentDocumentLineEndOffset); " is 143.
Long Statement,ICSharpCode.AvalonEdit.Rendering,MouseHoverLogic,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\MouseHoverLogic.cs,StartHovering,The length of the statement  "			mouseHoverTimer = new DispatcherTimer(SystemParameters.MouseHoverTime' DispatcherPriority.Background' OnMouseHoverTimerElapsed' this.target.Dispatcher); " is 152.
Long Statement,ICSharpCode.AvalonEdit.Rendering,SingleCharacterElementGenerator,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\SingleCharacterElementGenerator.cs,ConstructElement,The length of the statement  "				return new SpaceTextElement(CurrentContext.TextView.cachedElements.GetTextForNonPrintableCharacter("\u00B7"' CurrentContext)); " is 126.
Long Statement,ICSharpCode.AvalonEdit.Rendering,SingleCharacterElementGenerator,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\SingleCharacterElementGenerator.cs,ConstructElement,The length of the statement  "				return new TabTextElement(CurrentContext.TextView.cachedElements.GetTextForNonPrintableCharacter("\u00BB"' CurrentContext)); " is 124.
Long Statement,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,ReceiveWeakEvent,The length of the statement  "				// Unfortunately the "easy" approach (just use DispatcherPriority.Background) here makes the editor twice as slow because " is 121.
Long Statement,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,ReceiveWeakEvent,The length of the statement  "				// When fixing this' make sure performance on the SharpDevelop "type text in C# comment" stress test doesn't get significantly worse. " is 133.
Long Statement,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,UpdateBuiltinElementGeneratorsFromOptions,The length of the statement  "			AddRemoveDefaultElementGeneratorOnDemand(ref singleCharacterElementGenerator' options.ShowBoxForControlCharacters || options.ShowSpaces || options.ShowTabs); " is 157.
Long Statement,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,EnsureVisualLines,The length of the statement  "				throw new InvalidOperationException("The visual line build process is already running! Cannot EnsureVisualLines() during Measure!"); " is 132.
Long Statement,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,BuildVisualLine,The length of the statement  "							throw new InvalidOperationException("Line " + i + " was skipped by a VisualLineElementGenerator' but it is not collapsed."); " is 124.
Long Statement,ICSharpCode.AvalonEdit.Rendering,VisualLine,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLine.cs,ReplaceElement,The length of the statement  "				throw new InvalidOperationException("Old elements have document length " + oldDocumentLength + "' but new elements have length " + newDocumentLength); " is 150.
Long Statement,ICSharpCode.AvalonEdit.Rendering,VisualLine,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLine.cs,GetNextCaretPosition,The length of the statement  "				if (visualColumn > this.VisualLength && !elements[elements.Count-1].HandlesLineBorders && HasImplicitStopAtLineEnd(mode)) { " is 123.
Long Statement,ICSharpCode.AvalonEdit.Rendering,VisualLineElement,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLineElement.cs,SplitHelper,The length of the statement  "				throw new ArgumentOutOfRangeException("splitVisualColumn"' splitVisualColumn' "Value must be between " + (VisualColumn + 1) + " and " + (VisualColumn + VisualLength - 1)); " is 171.
Long Statement,ICSharpCode.AvalonEdit.Rendering,VisualLineElement,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLineElement.cs,SplitHelper,The length of the statement  "				throw new ArgumentOutOfRangeException("splitRelativeTextOffset"' splitRelativeTextOffset' "Value must be between " + (RelativeTextOffset) + " and " + (RelativeTextOffset + DocumentLength)); " is 189.
Long Statement,ICSharpCode.AvalonEdit.Rendering,VisualLineElement,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLineElement.cs,GetNextCaretPosition,The length of the statement  "				else if (visualColumn < stop2 && mode != CaretPositioningMode.WordStart && mode != CaretPositioningMode.WordStartOrSymbol) " is 122.
Long Statement,ICSharpCode.AvalonEdit.Rendering,VisualLineText,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLineText.cs,CreateTextRun,The length of the statement  "			StringSegment text = context.GetText(context.VisualLine.FirstDocumentLine.Offset + RelativeTextOffset + relativeOffset' DocumentLength - relativeOffset); " is 153.
Long Statement,ICSharpCode.AvalonEdit.Rendering,VisualLineText,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLineText.cs,GetPrecedingText,The length of the statement  "			return new TextSpan<CultureSpecificCharacterBufferRange>(range.Length' new CultureSpecificCharacterBufferRange(this.TextRunProperties.CultureInfo' range)); " is 155.
Long Statement,ICSharpCode.AvalonEdit.Rendering,VisualLineText,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLineText.cs,Split,The length of the statement  "				throw new ArgumentOutOfRangeException("splitVisualColumn"' splitVisualColumn' "Value must be between " + (VisualColumn + 1) + " and " + (VisualColumn + VisualLength - 1)); " is 171.
Long Statement,ICSharpCode.AvalonEdit.Rendering,VisualLineText,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLineText.cs,GetNextCaretPosition,The length of the statement  "			int pos = TextUtilities.GetNextCaretPosition(parentVisualLine.Document' textOffset + visualColumn - this.VisualColumn' direction' mode); " is 136.
Long Statement,ICSharpCode.AvalonEdit.Rendering,VisualLineTextSource,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLineTextSource.cs,CreateTextRunForNewLine,The length of the statement  "			return new FormattedTextRun(new FormattedTextElement(TextView.cachedElements.GetTextForNonPrintableCharacter(newlineText' this)' 0)' GlobalTextRunProperties); " is 158.
Long Statement,ICSharpCode.AvalonEdit.Rendering,VisualLineTextSource,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLineTextSource.cs,GetPrecedingText,The length of the statement  "				return new TextSpan<CultureSpecificCharacterBufferRange>(empty.Length' new CultureSpecificCharacterBufferRange(null' empty)); " is 125.
Long Statement,ICSharpCode.AvalonEdit.Search,RegexSearchStrategy,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Search\RegexSearchStrategy.cs,IsWordBorder,The length of the statement  "			return TextUtilities.GetNextCaretPosition(document' offset - 1' LogicalDirection.Forward' CaretPositioningMode.WordBorder) == offset; " is 133.
Long Statement,ICSharpCode.AvalonEdit.Search,SearchPanel,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Search\SearchPanel.cs,UpdateSearch,The length of the statement  "			strategy = SearchStrategyFactory.Create(SearchPattern ?? ""' !MatchCase' WholeWords' UseRegex ? SearchMode.RegEx : SearchMode.Normal); " is 134.
Long Statement,ICSharpCode.AvalonEdit.Utils,CharRope,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Utils\CharRope.cs,InsertText,The length of the statement  "				throw new ArgumentOutOfRangeException("index"' index' "0 <= index <= " + rope.Length.ToString(CultureInfo.InvariantCulture)); " is 125.
Long Statement,ICSharpCode.AvalonEdit.Utils,CompressingTreeList<T>,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Utils\CompressingTreeList.cs,CopyTo,The length of the statement  "				throw new ArgumentOutOfRangeException("arrayIndex"' arrayIndex' "Value must be between 0 and " + (array.Length - this.Count)); " is 126.
Long Statement,ICSharpCode.AvalonEdit.Utils,ExtensionMethods,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Utils\ExtensionMethods.cs,Log,The length of the statement  "				string output = DateTime.Now.ToString("hh:MM:ss") + ": " + string.Format(format' args) + Environment.NewLine + Environment.StackTrace; " is 134.
Long Statement,ICSharpCode.AvalonEdit.Utils,Rope<T>,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Utils\Rope.cs,InsertRange,The length of the statement  "				throw new ArgumentOutOfRangeException("index"' index' "0 <= index <= " + this.Length.ToString(CultureInfo.InvariantCulture)); " is 125.
Long Statement,ICSharpCode.AvalonEdit.Utils,Rope<T>,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Utils\Rope.cs,InsertRange,The length of the statement  "				throw new ArgumentOutOfRangeException("index"' index' "0 <= index <= " + this.Length.ToString(CultureInfo.InvariantCulture)); " is 125.
Long Statement,ICSharpCode.AvalonEdit.Utils,Rope<T>,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Utils\Rope.cs,VerifyRange,The length of the statement  "				throw new ArgumentOutOfRangeException("startIndex"' startIndex' "0 <= startIndex <= " + this.Length.ToString(CultureInfo.InvariantCulture)); " is 140.
Long Statement,ICSharpCode.AvalonEdit.Utils,Rope<T>,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Utils\Rope.cs,VerifyRange,The length of the statement  "				throw new ArgumentOutOfRangeException("length"' length' "0 <= length' startIndex(" + startIndex + ")+length <= " + this.Length.ToString(CultureInfo.InvariantCulture)); " is 167.
Long Statement,ICSharpCode.AvalonEdit.Utils,Rope<T>,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Utils\Rope.cs,VerifyArrayWithRange,The length of the statement  "				throw new ArgumentOutOfRangeException("startIndex"' arrayIndex' "0 <= arrayIndex <= " + array.Length.ToString(CultureInfo.InvariantCulture)); " is 141.
Long Statement,ICSharpCode.AvalonEdit.Utils,Rope<T>,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Utils\Rope.cs,VerifyArrayWithRange,The length of the statement  "				throw new ArgumentOutOfRangeException("count"' count' "0 <= length' arrayIndex(" + arrayIndex + ")+count <= " + array.Length.ToString(CultureInfo.InvariantCulture)); " is 165.
Long Statement,ICSharpCode.AvalonEdit.Utils,RopeNode<T>,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Utils\RopeNode.cs,ToString,The length of the statement  "				return "[Concat length=" + length + "' isShared=" + isShared + "' height=" + height + "' Balance=" + this.Balance + "]"; " is 120.
Long Statement,ICSharpCode.AvalonEdit.Utils,FunctionNode<T>,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Utils\RopeNode.cs,GetContentNode,The length of the statement  "						throw new InvalidOperationException("Trying to load this node recursively; or: a previous call to a rope initializer failed."); " is 127.
Long Statement,ICSharpCode.AvalonEdit.Utils,ThrowUtil,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Utils\ThrowUtil.cs,CheckInRangeInclusive,The length of the statement  "				throw new ArgumentOutOfRangeException(parameterName' val' "Expected: " + lower.ToString(CultureInfo.InvariantCulture) + " <= " + parameterName + " <= " + upper.ToString(CultureInfo.InvariantCulture)); " is 200.
Long Statement,ICSharpCode.AvalonEdit.Xml,AXmlAttribute,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Xml\AXmlAttribute.cs,ToString,The length of the statement  "			return string.Format(CultureInfo.InvariantCulture' "[{0} '{1}{2}{3}']"' base.ToString()' this.Name' this.EqualsSign' this.Value); " is 129.
Long Statement,ICSharpCode.AvalonEdit.Xml,AXmlDocument,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Xml\AXmlDocument.cs,OnObjectInserted,The length of the statement  "				ObjectInserted(this' new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Add' new AXmlObject[] { obj }.ToList()' index)); " is 136.
Long Statement,ICSharpCode.AvalonEdit.Xml,AXmlDocument,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Xml\AXmlDocument.cs,OnObjectRemoved,The length of the statement  "				ObjectRemoved(this' new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Remove' new AXmlObject[] { obj }.ToList()' index)); " is 138.
Long Statement,ICSharpCode.AvalonEdit.Xml,AXmlElement,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Xml\AXmlElement.cs,ToString,The length of the statement  "			return string.Format(CultureInfo.InvariantCulture' "[{0} '{1}' Attr:{2} Chld:{3} Nest:{4}]"' base.ToString()' this.Name' this.HasStartOrEmptyTag ? this.StartTag.Children.Count : 0' this.Children.Count' this.IsProperlyNested ? "Ok" : "Bad"); " is 240.
Long Statement,ICSharpCode.AvalonEdit.Xml,AXmlObject,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Xml\AXmlObject.cs,ToString,The length of the statement  "			return string.Format(CultureInfo.InvariantCulture' "{0}({1}-{2})"' this.GetType().Name.Remove(0' 4)' this.StartOffset' this.EndOffset); " is 135.
Long Statement,ICSharpCode.AvalonEdit.Xml,AXmlObjectCollection<T>,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Xml\AXmlObjectCollection.cs,InsertItemAt,The length of the statement  "				OnCollectionChanged(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Add' new T[] { item }.ToList()' index)); " is 127.
Long Statement,ICSharpCode.AvalonEdit.Xml,AXmlObjectCollection<T>,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Xml\AXmlObjectCollection.cs,RemoveItemAt,The length of the statement  "				OnCollectionChanged(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Remove' new T[] { removed }.ToList()' index)); " is 133.
Long Statement,ICSharpCode.AvalonEdit.Xml,AXmlParser,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Xml\AXmlParser.cs,Parse,The length of the statement  "			Assert(userDocument.GetSelfAndAllChildren().Count() == parsedDocument.GetSelfAndAllChildren().Count()' "Parsed document and updated document have different number of children"); " is 177.
Long Statement,ICSharpCode.AvalonEdit.Xml,AXmlTag,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Xml\AXmlTag.cs,ToString,The length of the statement  "			return string.Format(CultureInfo.InvariantCulture' "[{0} '{1}{2}{3}' Attr:{4}]"' base.ToString()' this.OpeningBracket' this.Name' this.ClosingBracket' this.Children.Count); " is 172.
Long Statement,ICSharpCode.AvalonEdit.Xml,TagMatchingHeuristics,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Xml\TagMatchingHeuristics.cs,ReadDocument,The length of the statement  "			foreach(AXmlTag xmlDeclaration in doc.Children.OfType<AXmlTag>().Where(t => t.IsProcessingInstruction && string.Equals(t.Name' "xml"' StringComparison.OrdinalIgnoreCase))) { " is 173.
Long Statement,ICSharpCode.AvalonEdit.Xml,TagMatchingHeuristics,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Xml\TagMatchingHeuristics.cs,ProcessObject,The length of the statement  "			AXmlParser.DebugAssert(objAsTag != null || objAsElement != null || obj is AXmlText' obj.GetType().Name + " not expected"); " is 122.
Long Statement,ICSharpCode.AvalonEdit.Xml,TagReader,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Xml\TagReader.cs,OnParsed,The length of the statement  "			trackedSegments.AddParsedObject(obj' this.MaxTouchedLocation > this.CurrentLocation ? (int?)this.MaxTouchedLocation : null); " is 124.
Long Statement,ICSharpCode.AvalonEdit.Xml,TagReader,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Xml\TagReader.cs,ReadTag,The length of the statement  "					throw new InternalException(string.Format(CultureInfo.InvariantCulture' "Unknown opening bracket '{0}'"' tag.OpeningBracket)); " is 126.
Long Statement,ICSharpCode.AvalonEdit.Xml,TagReader,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Xml\TagReader.cs,ReadTag,The length of the statement  "				if (tag.ClosingBracket != ">" && tag.ClosingBracket != "/>") OnSyntaxError(tag' brStart' brEnd' "'>' or '/>' expected"); " is 120.
Long Statement,ICSharpCode.AvalonEdit.Xml,TagReader,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Xml\TagReader.cs,ReadTag,The length of the statement  "				throw new InternalException(string.Format(CultureInfo.InvariantCulture' "Unknown opening bracket '{0}'"' tag.OpeningBracket)); " is 126.
Long Statement,ICSharpCode.AvalonEdit.Xml,TagReader,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Xml\TagReader.cs,ReadText,The length of the statement  "					AXmlObject nextFragment = trackedSegments.GetCachedObject<AXmlText>(this.CurrentLocation + maxEntityLength' lookAheadLength - maxEntityLength' t => t.Type == type); " is 164.
Long Statement,ICSharpCode.AvalonEdit.Xml,TagReader,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Xml\TagReader.cs,ReadText,The length of the statement  "						AXmlParser.Log("Parsing only text ({0}-{1}) because later text was already processed"' this.CurrentLocation' fragmentEnd); " is 122.
Long Statement,ICSharpCode.AvalonEdit.Xml,TagReader,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Xml\TagReader.cs,Dereference,The length of the statement  "						if (!int.TryParse(name.Substring(2)' NumberStyles.AllowHexSpecifier' CultureInfo.InvariantCulture.NumberFormat' out num)) { " is 123.
Long Statement,ICSharpCode.AvalonEdit.Xml,TokenReader,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Xml\TokenReader.cs,PrintStringCacheStats,The length of the statement  "			AXmlParser.Log("String cache: Requested {0} ({1} bytes);  Actaully stored {2} ({3} bytes); {4}% stored"' stringCacheRequestedCount' stringCacheRequestedSize' stringCacheStoredCount' stringCacheStoredSize' stringCacheRequestedSize == 0 ? 0 : stringCacheStoredSize * 100 / stringCacheRequestedSize); " is 297.
Long Statement,XamlGeneratedNamespace,GeneratedInternalTypeHelper,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\obj\Debug\GeneratedInternalTypeHelper.g.cs,CreateInstance,The length of the statement  "            return System.Activator.CreateInstance(type' ((System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.NonPublic)  " is 128.
Complex Conditional,ICSharpCode.AvalonEdit.Document,TextUtilities,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,GetNextCaretPosition,The conditional expression  "mode != CaretPositioningMode.Normal  			    && mode != CaretPositioningMode.WordBorder  			    && mode != CaretPositioningMode.WordStart  			    && mode != CaretPositioningMode.WordBorderOrSymbol  			    && mode != CaretPositioningMode.WordStartOrSymbol"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Document,TextUtilities,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,GetNextCaretPosition,The conditional expression  "!((mode == CaretPositioningMode.WordStart || mode == CaretPositioningMode.WordStartOrSymbol)  						      && (charAfter == CharacterClass.Whitespace || charAfter == CharacterClass.LineTerminator))"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Document,TextSegmentCollection<T>,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,FixTreeOnDelete,The conditional expression  "parentNode.color == BLACK  			    && sibling.color == BLACK  			    && GetColor(sibling.left) == BLACK  			    && GetColor(sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Document,TextSegmentCollection<T>,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,FixTreeOnDelete,The conditional expression  "parentNode.color == RED  			    && sibling.color == BLACK  			    && GetColor(sibling.left) == BLACK  			    && GetColor(sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Document,TextSegmentCollection<T>,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,FixTreeOnDelete,The conditional expression  "node == parentNode.left &&  			    sibling.color == BLACK &&  			    GetColor(sibling.left) == RED &&  			    GetColor(sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Document,TextSegmentCollection<T>,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,FixTreeOnDelete,The conditional expression  "node == parentNode.right &&  			         sibling.color == BLACK &&  			         GetColor(sibling.right) == RED &&  			         GetColor(sibling.left) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Document,TextAnchorTree,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Document\TextAnchorTree.cs,FixTreeOnDelete,The conditional expression  "parentNode.color == BLACK  			    && sibling.color == BLACK  			    && GetColor(sibling.left) == BLACK  			    && GetColor(sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Document,TextAnchorTree,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Document\TextAnchorTree.cs,FixTreeOnDelete,The conditional expression  "parentNode.color == RED  			    && sibling.color == BLACK  			    && GetColor(sibling.left) == BLACK  			    && GetColor(sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Document,TextAnchorTree,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Document\TextAnchorTree.cs,FixTreeOnDelete,The conditional expression  "node == parentNode.left &&  			    sibling.color == BLACK &&  			    GetColor(sibling.left) == RED &&  			    GetColor(sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Document,TextAnchorTree,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Document\TextAnchorTree.cs,FixTreeOnDelete,The conditional expression  "node == parentNode.right &&  			         sibling.color == BLACK &&  			         GetColor(sibling.right) == RED &&  			         GetColor(sibling.left) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Document,DocumentLineTree,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Document\DocumentLineTree.cs,FixTreeOnDelete,The conditional expression  "parentNode.color == BLACK  			    && sibling.color == BLACK  			    && GetColor(sibling.left) == BLACK  			    && GetColor(sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Document,DocumentLineTree,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Document\DocumentLineTree.cs,FixTreeOnDelete,The conditional expression  "parentNode.color == RED  			    && sibling.color == BLACK  			    && GetColor(sibling.left) == BLACK  			    && GetColor(sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Document,DocumentLineTree,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Document\DocumentLineTree.cs,FixTreeOnDelete,The conditional expression  "node == parentNode.left &&  			    sibling.color == BLACK &&  			    GetColor(sibling.left) == RED &&  			    GetColor(sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Document,DocumentLineTree,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Document\DocumentLineTree.cs,FixTreeOnDelete,The conditional expression  "node == parentNode.right &&  			         sibling.color == BLACK &&  			         GetColor(sibling.right) == RED &&  			         GetColor(sibling.left) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,textArea_QueryCursor,The conditional expression  "p.X >= 0 && p.Y >= 0 && p.X <= textArea.TextView.ActualWidth && p.Y <= textArea.TextView.ActualHeight"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,textArea_MouseMove,The conditional expression  "mode == SelectionMode.Normal || mode == SelectionMode.WholeWord || mode == SelectionMode.WholeLine || mode == SelectionMode.Rectangular"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,textArea_MouseLeftButtonUp,The conditional expression  "mode == SelectionMode.Normal || mode == SelectionMode.WholeWord || mode == SelectionMode.WholeLine || mode == SelectionMode.Rectangular"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Editing,TextArea,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Editing\TextArea.cs,OnPropertyChanged,The conditional expression  "e.Property == SelectionBrushProperty  			    || e.Property == SelectionBorderProperty  			    || e.Property == SelectionForegroundProperty  			    || e.Property == SelectionCornerRadiusProperty"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Highlighting,DocumentHighlighter,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Highlighting\DocumentHighlighter.cs,Minimum,The conditional expression  "endSpanMatch != null && endSpanMatch.Success && (min == null || endSpanMatch.Index < min.Index)"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,GetColorFromElement,The conditional expression  "!element.HasAttribute("bold") && !element.HasAttribute("italic") && !element.HasAttribute("color") && !element.HasAttribute("bgcolor")"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Indentation.CSharp,IndentationReformatter,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Indentation\CSharp\IndentationReformatter.cs,Step,The conditional expression  "lineComment || blockComment || inString || inChar"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Indentation.CSharp,IndentationReformatter,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Indentation\CSharp\IndentationReformatter.cs,Step,The conditional expression  "!oldBlock.Continuation && oldBlock.OneLineBlock == 0 &&  				    oldBlock.StartLine == block.StartLine &&  				    block.StartLine < doc.LineNumber && lastRealChar != ':'"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Rendering,BackgroundGeometryBuilder,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\BackgroundGeometryBuilder.cs,ProcessTextLines,The conditional expression  "segmentEndVCInLine == visualEndCol && i < visualLine.TextLines.Count - 1 && segmentEndVC > segmentEndVCInLine && line.TrailingWhitespaceLength == 0"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Rendering,BackgroundGeometryBuilder,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\BackgroundGeometryBuilder.cs,ProcessTextLines,The conditional expression  "segmentStartVCInLine == visualStartCol && i > 0 && segmentStartVC < segmentStartVCInLine && visualLine.TextLines[i - 1].TrailingWhitespaceLength == 0"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Rendering,HeightTree,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\HeightTree.cs,FixTreeOnDelete,The conditional expression  "parentNode.color == BLACK  			    && sibling.color == BLACK  			    && GetColor(sibling.left) == BLACK  			    && GetColor(sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Rendering,HeightTree,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\HeightTree.cs,FixTreeOnDelete,The conditional expression  "parentNode.color == RED  			    && sibling.color == BLACK  			    && GetColor(sibling.left) == BLACK  			    && GetColor(sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Rendering,HeightTree,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\HeightTree.cs,FixTreeOnDelete,The conditional expression  "node == parentNode.left &&  			    sibling.color == BLACK &&  			    GetColor(sibling.left) == RED &&  			    GetColor(sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Rendering,HeightTree,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\HeightTree.cs,FixTreeOnDelete,The conditional expression  "node == parentNode.right &&  			         sibling.color == BLACK &&  			         GetColor(sibling.right) == RED &&  			         GetColor(sibling.left) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,MakeVisible,The conditional expression  "rectangle.IsEmpty || visual == null || visual == this || !this.IsAncestorOf(visual)"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,OnPropertyChanged,The conditional expression  "e.Property == Control.ForegroundProperty  			           || e.Property == TextView.NonPrintableCharacterBrushProperty  			           || e.Property == TextView.LinkTextBackgroundBrushProperty  			           || e.Property == TextView.LinkTextForegroundBrushProperty"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,OnPropertyChanged,The conditional expression  "e.Property == Control.FontFamilyProperty  			    || e.Property == Control.FontSizeProperty  			    || e.Property == Control.FontStretchProperty  			    || e.Property == Control.FontStyleProperty  			    || e.Property == Control.FontWeightProperty"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Utils,CompressingTreeList<T>,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Utils\CompressingTreeList.cs,FixTreeOnDelete,The conditional expression  "parentNode.color == BLACK  			    && sibling.color == BLACK  			    && GetColor(sibling.left) == BLACK  			    && GetColor(sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Utils,CompressingTreeList<T>,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Utils\CompressingTreeList.cs,FixTreeOnDelete,The conditional expression  "parentNode.color == RED  			    && sibling.color == BLACK  			    && GetColor(sibling.left) == BLACK  			    && GetColor(sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Utils,CompressingTreeList<T>,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Utils\CompressingTreeList.cs,FixTreeOnDelete,The conditional expression  "node == parentNode.left &&  			    sibling.color == BLACK &&  			    GetColor(sibling.left) == RED &&  			    GetColor(sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Utils,CompressingTreeList<T>,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Utils\CompressingTreeList.cs,FixTreeOnDelete,The conditional expression  "node == parentNode.right &&  			         sibling.color == BLACK &&  			         GetColor(sibling.right) == RED &&  			         GetColor(sibling.left) == BLACK"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Xml,AXmlAttribute,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Xml\AXmlAttribute.cs,UpdateDataFrom,The conditional expression  "this.Name != src.Name ||  				this.EqualsSign != src.EqualsSign ||  				this.QuotedValue != src.QuotedValue ||  				this.Value != src.Value"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Xml,AXmlObject,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Xml\AXmlObject.cs,OnChanging,The conditional expression  "me != null && (me.IsStartOrEmptyTag || me.IsEndTag) && me.Parent is AXmlElement"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Xml,AXmlObject,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Xml\AXmlObject.cs,OnChanged,The conditional expression  "me != null && (me.IsStartOrEmptyTag || me.IsEndTag) && me.Parent is AXmlElement"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Xml,TagMatchingHeuristics,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Xml\TagMatchingHeuristics.cs,Split,The conditional expression  "elem.HasStartOrEmptyTag && elem.StartTag.IsStartTag && !elem.HasEndTag && myIndention != -1"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Xml,TagReader,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Xml\TagReader.cs,ReadAttributeValue,The conditional expression  "TryMoveToNonWhiteSpace() && TryRead("=") &&  					    TryMoveToNonWhiteSpace() && TryPeekAnyOf('"'' '\'')"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Xml,TokenReader,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Xml\TokenReader.cs,TryMoveToNonWhiteSpace,The conditional expression  "((int)c <= 0x20) && (c == ' ' || c == '\t' || c == '\n' || c == '\r')"  is complex.
Complex Conditional,ICSharpCode.AvalonEdit.Xml,TokenReader,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Xml\TokenReader.cs,TryReadName,The conditional expression  "c == ' ' || c == '\n' || c == '\r' || c == '\t' ||  // Reject whitesapce  				    c == '=' || c == '\'' || c == '"'  ||               // Reject attributes  				    c == '<' || c == '>'  || c == '/'  || c == '?'"  is complex.
Virtual Method Call from Constructor,ICSharpCode.AvalonEdit.Snippets,InsertionContext,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Snippets\InsertionContext.cs,InsertionContext,The constructor "InsertionContext" calls a virtual method "GetText".
Empty Catch Block,ICSharpCode.AvalonEdit.Rendering,VisualLineLinkText,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLineLinkText.cs,OnMouseDown,The method has an empty catch block.
Magic Number,ICSharpCode.AvalonEdit,TextEditor,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\TextEditor.cs,ScrollTo,The following statement contains a magic number: const double MinimumScrollPercentage = 0.3;
Magic Number,ICSharpCode.AvalonEdit,TextEditor,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\TextEditor.cs,ScrollTo,The following statement contains a magic number: if (scrollViewer != null && document != null) {  				if (line < 1)  					line = 1;  				if (line > document.LineCount)  					line = document.LineCount;  				  				IScrollInfo scrollInfo = textView;  				if (!scrollInfo.CanHorizontallyScroll) {  					// Word wrap is enabled. Ensure that we have up-to-date info about line height so that we scroll  					// to the correct position.  					// This avoids that the user has to repeat the ScrollTo() call several times when there are very long lines.  					VisualLine vl = textView.GetOrConstructVisualLine(document.GetLineByNumber(line));  					double remainingHeight = scrollViewer.ViewportHeight / 2;  					while (remainingHeight > 0) {  						DocumentLine prevLine = vl.FirstDocumentLine.PreviousLine;  						if (prevLine == null)  							break;  						vl = textView.GetOrConstructVisualLine(prevLine);  						remainingHeight -= vl.Height;  					}  				}  				  				Point p = textArea.TextView.GetVisualPosition(new TextViewPosition(line' Math.Max(1' column))' VisualYPosition.LineMiddle);  				double verticalPos = p.Y - scrollViewer.ViewportHeight / 2;  				if (Math.Abs(verticalPos - scrollViewer.VerticalOffset) > MinimumScrollPercentage * scrollViewer.ViewportHeight) {  					scrollViewer.ScrollToVerticalOffset(Math.Max(0' verticalPos));  				}  				if (column > 0) {  					if (p.X > scrollViewer.ViewportWidth - Caret.MinimumDistanceToViewBorder * 2) {  						double horizontalPos = Math.Max(0' p.X - scrollViewer.ViewportWidth / 2);  						if (Math.Abs(horizontalPos - scrollViewer.HorizontalOffset) > MinimumScrollPercentage * scrollViewer.ViewportWidth) {  							scrollViewer.ScrollToHorizontalOffset(horizontalPos);  						}  					} else {  						scrollViewer.ScrollToHorizontalOffset(0);  					}  				}  			}
Magic Number,ICSharpCode.AvalonEdit,TextEditor,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\TextEditor.cs,ScrollTo,The following statement contains a magic number: if (scrollViewer != null && document != null) {  				if (line < 1)  					line = 1;  				if (line > document.LineCount)  					line = document.LineCount;  				  				IScrollInfo scrollInfo = textView;  				if (!scrollInfo.CanHorizontallyScroll) {  					// Word wrap is enabled. Ensure that we have up-to-date info about line height so that we scroll  					// to the correct position.  					// This avoids that the user has to repeat the ScrollTo() call several times when there are very long lines.  					VisualLine vl = textView.GetOrConstructVisualLine(document.GetLineByNumber(line));  					double remainingHeight = scrollViewer.ViewportHeight / 2;  					while (remainingHeight > 0) {  						DocumentLine prevLine = vl.FirstDocumentLine.PreviousLine;  						if (prevLine == null)  							break;  						vl = textView.GetOrConstructVisualLine(prevLine);  						remainingHeight -= vl.Height;  					}  				}  				  				Point p = textArea.TextView.GetVisualPosition(new TextViewPosition(line' Math.Max(1' column))' VisualYPosition.LineMiddle);  				double verticalPos = p.Y - scrollViewer.ViewportHeight / 2;  				if (Math.Abs(verticalPos - scrollViewer.VerticalOffset) > MinimumScrollPercentage * scrollViewer.ViewportHeight) {  					scrollViewer.ScrollToVerticalOffset(Math.Max(0' verticalPos));  				}  				if (column > 0) {  					if (p.X > scrollViewer.ViewportWidth - Caret.MinimumDistanceToViewBorder * 2) {  						double horizontalPos = Math.Max(0' p.X - scrollViewer.ViewportWidth / 2);  						if (Math.Abs(horizontalPos - scrollViewer.HorizontalOffset) > MinimumScrollPercentage * scrollViewer.ViewportWidth) {  							scrollViewer.ScrollToHorizontalOffset(horizontalPos);  						}  					} else {  						scrollViewer.ScrollToHorizontalOffset(0);  					}  				}  			}
Magic Number,ICSharpCode.AvalonEdit,TextEditor,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\TextEditor.cs,ScrollTo,The following statement contains a magic number: if (scrollViewer != null && document != null) {  				if (line < 1)  					line = 1;  				if (line > document.LineCount)  					line = document.LineCount;  				  				IScrollInfo scrollInfo = textView;  				if (!scrollInfo.CanHorizontallyScroll) {  					// Word wrap is enabled. Ensure that we have up-to-date info about line height so that we scroll  					// to the correct position.  					// This avoids that the user has to repeat the ScrollTo() call several times when there are very long lines.  					VisualLine vl = textView.GetOrConstructVisualLine(document.GetLineByNumber(line));  					double remainingHeight = scrollViewer.ViewportHeight / 2;  					while (remainingHeight > 0) {  						DocumentLine prevLine = vl.FirstDocumentLine.PreviousLine;  						if (prevLine == null)  							break;  						vl = textView.GetOrConstructVisualLine(prevLine);  						remainingHeight -= vl.Height;  					}  				}  				  				Point p = textArea.TextView.GetVisualPosition(new TextViewPosition(line' Math.Max(1' column))' VisualYPosition.LineMiddle);  				double verticalPos = p.Y - scrollViewer.ViewportHeight / 2;  				if (Math.Abs(verticalPos - scrollViewer.VerticalOffset) > MinimumScrollPercentage * scrollViewer.ViewportHeight) {  					scrollViewer.ScrollToVerticalOffset(Math.Max(0' verticalPos));  				}  				if (column > 0) {  					if (p.X > scrollViewer.ViewportWidth - Caret.MinimumDistanceToViewBorder * 2) {  						double horizontalPos = Math.Max(0' p.X - scrollViewer.ViewportWidth / 2);  						if (Math.Abs(horizontalPos - scrollViewer.HorizontalOffset) > MinimumScrollPercentage * scrollViewer.ViewportWidth) {  							scrollViewer.ScrollToHorizontalOffset(horizontalPos);  						}  					} else {  						scrollViewer.ScrollToHorizontalOffset(0);  					}  				}  			}
Magic Number,ICSharpCode.AvalonEdit,TextEditor,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\TextEditor.cs,ScrollTo,The following statement contains a magic number: if (scrollViewer != null && document != null) {  				if (line < 1)  					line = 1;  				if (line > document.LineCount)  					line = document.LineCount;  				  				IScrollInfo scrollInfo = textView;  				if (!scrollInfo.CanHorizontallyScroll) {  					// Word wrap is enabled. Ensure that we have up-to-date info about line height so that we scroll  					// to the correct position.  					// This avoids that the user has to repeat the ScrollTo() call several times when there are very long lines.  					VisualLine vl = textView.GetOrConstructVisualLine(document.GetLineByNumber(line));  					double remainingHeight = scrollViewer.ViewportHeight / 2;  					while (remainingHeight > 0) {  						DocumentLine prevLine = vl.FirstDocumentLine.PreviousLine;  						if (prevLine == null)  							break;  						vl = textView.GetOrConstructVisualLine(prevLine);  						remainingHeight -= vl.Height;  					}  				}  				  				Point p = textArea.TextView.GetVisualPosition(new TextViewPosition(line' Math.Max(1' column))' VisualYPosition.LineMiddle);  				double verticalPos = p.Y - scrollViewer.ViewportHeight / 2;  				if (Math.Abs(verticalPos - scrollViewer.VerticalOffset) > MinimumScrollPercentage * scrollViewer.ViewportHeight) {  					scrollViewer.ScrollToVerticalOffset(Math.Max(0' verticalPos));  				}  				if (column > 0) {  					if (p.X > scrollViewer.ViewportWidth - Caret.MinimumDistanceToViewBorder * 2) {  						double horizontalPos = Math.Max(0' p.X - scrollViewer.ViewportWidth / 2);  						if (Math.Abs(horizontalPos - scrollViewer.HorizontalOffset) > MinimumScrollPercentage * scrollViewer.ViewportWidth) {  							scrollViewer.ScrollToHorizontalOffset(horizontalPos);  						}  					} else {  						scrollViewer.ScrollToHorizontalOffset(0);  					}  				}  			}
Magic Number,ICSharpCode.AvalonEdit,TextViewPosition,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\TextViewPosition.cs,GetHashCode,The following statement contains a magic number: unchecked {  				hashCode += 1000000007 * Line.GetHashCode();  				hashCode += 1000000009 * Column.GetHashCode();  				hashCode += 1000000021 * VisualColumn.GetHashCode();  			}
Magic Number,ICSharpCode.AvalonEdit,TextViewPosition,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\TextViewPosition.cs,GetHashCode,The following statement contains a magic number: unchecked {  				hashCode += 1000000007 * Line.GetHashCode();  				hashCode += 1000000009 * Column.GetHashCode();  				hashCode += 1000000021 * VisualColumn.GetHashCode();  			}
Magic Number,ICSharpCode.AvalonEdit,TextViewPosition,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\TextViewPosition.cs,GetHashCode,The following statement contains a magic number: unchecked {  				hashCode += 1000000007 * Line.GetHashCode();  				hashCode += 1000000009 * Column.GetHashCode();  				hashCode += 1000000021 * VisualColumn.GetHashCode();  			}
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionListBox,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\CompletionListBox.cs,CenterViewOn,The following statement contains a magic number: this.FirstVisibleItem = index - VisibleItemCount / 2;
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,GetMatchQuality,The following statement contains a magic number: if (query == itemText)  				return 8;
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,GetMatchQuality,The following statement contains a magic number: if (string.Equals(itemText' query' StringComparison.InvariantCultureIgnoreCase))  				return 7;
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,GetMatchQuality,The following statement contains a magic number: if (itemText.StartsWith(query' StringComparison.InvariantCulture))  				return 6;
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,GetMatchQuality,The following statement contains a magic number: if (itemText.StartsWith(query' StringComparison.InvariantCultureIgnoreCase))  				return 5;
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,GetMatchQuality,The following statement contains a magic number: if (query.Length <= 2) {  				camelCaseMatch = CamelCaseMatch(itemText' query);  				if (camelCaseMatch == true) return 4;  			}
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,GetMatchQuality,The following statement contains a magic number: if (query.Length <= 2) {  				camelCaseMatch = CamelCaseMatch(itemText' query);  				if (camelCaseMatch == true) return 4;  			}
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,GetMatchQuality,The following statement contains a magic number: if (IsFiltering) {  				if (itemText.IndexOf(query' StringComparison.InvariantCulture) >= 0)  					return 3;  				if (itemText.IndexOf(query' StringComparison.InvariantCultureIgnoreCase) >= 0)  					return 2;  			}
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,GetMatchQuality,The following statement contains a magic number: if (IsFiltering) {  				if (itemText.IndexOf(query' StringComparison.InvariantCulture) >= 0)  					return 3;  				if (itemText.IndexOf(query' StringComparison.InvariantCultureIgnoreCase) >= 0)  					return 2;  			}
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionWindow,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\CompletionWindow.cs,CompletionWindow,The following statement contains a magic number: this.MaxHeight = 300;
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionWindow,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\CompletionWindow.cs,CompletionWindow,The following statement contains a magic number: this.Width = 175;
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionWindow,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\CompletionWindow.cs,CompletionWindow,The following statement contains a magic number: this.MinHeight = 15;
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CompletionWindow,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\CompletionWindow.cs,CompletionWindow,The following statement contains a magic number: this.MinWidth = 30;
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,InsightWindow,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\InsightWindow.cs,OnSourceInitialized,The following statement contains a magic number: MaxWidth = Math.Min(workingArea.Width' Math.Max(1000' workingArea.Width * 0.6));
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,InsightWindow,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\InsightWindow.cs,OnSourceInitialized,The following statement contains a magic number: MaxWidth = Math.Min(workingArea.Width' Math.Max(1000' workingArea.Width * 0.6));
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,OverloadInsightWindow,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\OverloadInsightWindow.cs,OverloadInsightWindow,The following statement contains a magic number: overloadViewer.Margin = new Thickness(2'0'0'0);
Magic Number,ICSharpCode.AvalonEdit.CodeCompletion,CollapseIfSingleOverloadConverter,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\OverloadViewer.cs,Convert,The following statement contains a magic number: return ((int)value < 2) ? Visibility.Collapsed : Visibility.Visible;
Magic Number,ICSharpCode.AvalonEdit.Document,SimpleSegment,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Document\ISegment.cs,GetHashCode,The following statement contains a magic number: unchecked {  				return Offset + 10301 * Length;  			}
Magic Number,ICSharpCode.AvalonEdit.Document,NewLineFinder,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,NextNewLine,The following statement contains a magic number: if (pos >= 0) {  				if (text[pos] == '\r') {  					if (pos + 1 < text.Length && text[pos + 1] == '\n')  						return new SimpleSegment(pos' 2);  				}  				return new SimpleSegment(pos' 1);  			}
Magic Number,ICSharpCode.AvalonEdit.Document,NewLineFinder,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,NextNewLine,The following statement contains a magic number: if (pos >= 0) {  				if (text.GetCharAt(pos) == '\r') {  					if (pos + 1 < textLength && text.GetCharAt(pos + 1) == '\n')  						return new SimpleSegment(pos' 2);  				}  				return new SimpleSegment(pos' 1);  			}
Magic Number,ICSharpCode.AvalonEdit.Document,TextUtilities,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,FindNextNewLine,The following statement contains a magic number: if (s == SimpleSegment.Invalid) {  				newLineType = null;  				return -1;  			} else {  				if (s.Length == 2) {  					newLineType = "\r\n";  				} else if (text.GetCharAt(s.Offset) == '\n') {  					newLineType = "\n";  				} else {  					newLineType = "\r";  				}  				return s.Offset;  			}
Magic Number,ICSharpCode.AvalonEdit.Document,TextUtilities,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,GetControlCharacterName,The following statement contains a magic number: if (num < c0Table.Length)  				return c0Table[num];  			else if (num >= 127 && num <= 159)  				return delAndC1Table[num - 127];  			else  				return num.ToString("x4"' CultureInfo.InvariantCulture);
Magic Number,ICSharpCode.AvalonEdit.Document,TextUtilities,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,GetControlCharacterName,The following statement contains a magic number: if (num < c0Table.Length)  				return c0Table[num];  			else if (num >= 127 && num <= 159)  				return delAndC1Table[num - 127];  			else  				return num.ToString("x4"' CultureInfo.InvariantCulture);
Magic Number,ICSharpCode.AvalonEdit.Document,TextUtilities,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Document\NewLineFinder.cs,GetControlCharacterName,The following statement contains a magic number: if (num < c0Table.Length)  				return c0Table[num];  			else if (num >= 127 && num <= 159)  				return delAndC1Table[num - 127];  			else  				return num.ToString("x4"' CultureInfo.InvariantCulture);
Magic Number,ICSharpCode.AvalonEdit.Document,OffsetChangeMapEntry,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Document\OffsetChangeMap.cs,GetHashCode,The following statement contains a magic number: unchecked {  				return offset + 3559 * (int)insertionLengthWithMovementFlag + 3571 * (int)removalLengthWithDeletionFlag;  			}
Magic Number,ICSharpCode.AvalonEdit.Document,OffsetChangeMapEntry,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Document\OffsetChangeMap.cs,GetHashCode,The following statement contains a magic number: unchecked {  				return offset + 3559 * (int)insertionLengthWithMovementFlag + 3571 * (int)removalLengthWithDeletionFlag;  			}
Magic Number,ICSharpCode.AvalonEdit.Document,TextSegmentCollection<T>,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Document\TextSegmentCollection.cs,AppendTreeToString,The following statement contains a magic number: indent += 2;
Magic Number,ICSharpCode.AvalonEdit.Document,TextAnchorTree,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Document\TextAnchorTree.cs,AppendTreeToString,The following statement contains a magic number: indent += 2;
Magic Number,ICSharpCode.AvalonEdit.Document,TextLocation,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Document\TextLocation.cs,GetHashCode,The following statement contains a magic number: return unchecked (87 * x.GetHashCode() ^ y.GetHashCode());
Magic Number,ICSharpCode.AvalonEdit.Document,LineManager,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Document\LineManager.cs,Remove,The following statement contains a magic number: if (offset > startLineOffset + startLine.Length) {  				Debug.Assert(startLine.DelimiterLength == 2);  				// we are deleting starting in the middle of a delimiter  				  				// remove last delimiter part  				SetLineLength(startLine' startLine.TotalLength - 1);  				// remove remaining text  				Remove(offset' length - 1);  				return;  			}
Magic Number,ICSharpCode.AvalonEdit.Document,LineManager,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Document\LineManager.cs,Insert,The following statement contains a magic number: if (offset > lineOffset + line.Length) {  				Debug.Assert(line.DelimiterLength == 2);  				// we are inserting in the middle of a delimiter  				  				// shorten line  				SetLineLength(line' line.TotalLength - 1);  				// add new line  				line = InsertLineAfter(line' 1);  				line = SetLineLength(line' 1);  			}
Magic Number,ICSharpCode.AvalonEdit.Document,LineManager,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Document\LineManager.cs,SetLineLength,The following statement contains a magic number: if (newTotalLength == 0) {  				line.DelimiterLength = 0;  			} else {  				int lineOffset = line.Offset;  				char lastChar = document.GetCharAt(lineOffset + newTotalLength - 1);  				if (lastChar == '\r') {  					line.DelimiterLength = 1;  				} else if (lastChar == '\n') {  					if (newTotalLength >= 2 && document.GetCharAt(lineOffset + newTotalLength - 2) == '\r') {  						line.DelimiterLength = 2;  					} else if (newTotalLength == 1 && lineOffset > 0 && document.GetCharAt(lineOffset - 1) == '\r') {  						// we need to join this line with the previous line  						DocumentLine previousLine = line.PreviousLine;  						RemoveLine(line);  						return SetLineLength(previousLine' previousLine.TotalLength + 1);  					} else {  						line.DelimiterLength = 1;  					}  				} else {  					line.DelimiterLength = 0;  				}  			}
Magic Number,ICSharpCode.AvalonEdit.Document,LineManager,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Document\LineManager.cs,SetLineLength,The following statement contains a magic number: if (newTotalLength == 0) {  				line.DelimiterLength = 0;  			} else {  				int lineOffset = line.Offset;  				char lastChar = document.GetCharAt(lineOffset + newTotalLength - 1);  				if (lastChar == '\r') {  					line.DelimiterLength = 1;  				} else if (lastChar == '\n') {  					if (newTotalLength >= 2 && document.GetCharAt(lineOffset + newTotalLength - 2) == '\r') {  						line.DelimiterLength = 2;  					} else if (newTotalLength == 1 && lineOffset > 0 && document.GetCharAt(lineOffset - 1) == '\r') {  						// we need to join this line with the previous line  						DocumentLine previousLine = line.PreviousLine;  						RemoveLine(line);  						return SetLineLength(previousLine' previousLine.TotalLength + 1);  					} else {  						line.DelimiterLength = 1;  					}  				} else {  					line.DelimiterLength = 0;  				}  			}
Magic Number,ICSharpCode.AvalonEdit.Document,LineManager,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Document\LineManager.cs,SetLineLength,The following statement contains a magic number: if (newTotalLength == 0) {  				line.DelimiterLength = 0;  			} else {  				int lineOffset = line.Offset;  				char lastChar = document.GetCharAt(lineOffset + newTotalLength - 1);  				if (lastChar == '\r') {  					line.DelimiterLength = 1;  				} else if (lastChar == '\n') {  					if (newTotalLength >= 2 && document.GetCharAt(lineOffset + newTotalLength - 2) == '\r') {  						line.DelimiterLength = 2;  					} else if (newTotalLength == 1 && lineOffset > 0 && document.GetCharAt(lineOffset - 1) == '\r') {  						// we need to join this line with the previous line  						DocumentLine previousLine = line.PreviousLine;  						RemoveLine(line);  						return SetLineLength(previousLine' previousLine.TotalLength + 1);  					} else {  						line.DelimiterLength = 1;  					}  				} else {  					line.DelimiterLength = 0;  				}  			}
Magic Number,ICSharpCode.AvalonEdit.Document,DocumentLineTree,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Document\DocumentLineTree.cs,GetTreeHeight,The following statement contains a magic number: if (size == 0)  				return 0;  			else  				return GetTreeHeight(size / 2) + 1;
Magic Number,ICSharpCode.AvalonEdit.Document,DocumentLineTree,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Document\DocumentLineTree.cs,BuildTree,The following statement contains a magic number: int middle = (start + end) / 2;
Magic Number,ICSharpCode.AvalonEdit.Document,DocumentLineTree,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Document\DocumentLineTree.cs,AppendTreeToString,The following statement contains a magic number: indent += 2;
Magic Number,ICSharpCode.AvalonEdit.Document,TextDocument,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Document\TextDocument.cs,Replace,The following statement contains a magic number: switch (offsetChangeMappingType) {  				case OffsetChangeMappingType.Normal:  					Replace(offset' length' text' null);  					break;  				case OffsetChangeMappingType.KeepAnchorBeforeInsertion:  					Replace(offset' length' text' OffsetChangeMap.FromSingleElement(  						new OffsetChangeMapEntry(offset' length' text.Length' false' true)));  					break;  				case OffsetChangeMappingType.RemoveAndInsert:  					if (length == 0 || text.Length == 0) {  						// only insertion or only removal?  						// OffsetChangeMappingType doesn't matter' just use Normal.  						Replace(offset' length' text' null);  					} else {  						OffsetChangeMap map = new OffsetChangeMap(2);  						map.Add(new OffsetChangeMapEntry(offset' length' 0));  						map.Add(new OffsetChangeMapEntry(offset' 0' text.Length));  						map.Freeze();  						Replace(offset' length' text' map);  					}  					break;  				case OffsetChangeMappingType.CharacterReplace:  					if (length == 0 || text.Length == 0) {  						// only insertion or only removal?  						// OffsetChangeMappingType doesn't matter' just use Normal.  						Replace(offset' length' text' null);  					} else if (text.Length > length) {  						// look at OffsetChangeMappingType.CharacterReplace XML comments on why we need to replace  						// the last character  						OffsetChangeMapEntry entry = new OffsetChangeMapEntry(offset + length - 1' 1' 1 + text.Length - length);  						Replace(offset' length' text' OffsetChangeMap.FromSingleElement(entry));  					} else if (text.Length < length) {  						OffsetChangeMapEntry entry = new OffsetChangeMapEntry(offset + text.Length' length - text.Length' 0' true' false);  						Replace(offset' length' text' OffsetChangeMap.FromSingleElement(entry));  					} else {  						Replace(offset' length' text' OffsetChangeMap.Empty);  					}  					break;  				default:  					throw new ArgumentOutOfRangeException("offsetChangeMappingType"' offsetChangeMappingType' "Invalid enum value");  			}
Magic Number,ICSharpCode.AvalonEdit.Editing,DottedLineMargin,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Editing\DottedLineMargin.cs,Create,The following statement contains a magic number: Line line = new Line {  				X1 = 0' Y1 = 0' X2 = 0' Y2 = 1'  				StrokeDashArray = { 0' 2 }'  				Stretch = Stretch.Fill'  				StrokeThickness = 1'  				StrokeDashCap = PenLineCap.Round'  				Margin = new Thickness(2' 0' 2' 0)'  				Tag = tag  			};
Magic Number,ICSharpCode.AvalonEdit.Editing,DottedLineMargin,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Editing\DottedLineMargin.cs,Create,The following statement contains a magic number: Line line = new Line {  				X1 = 0' Y1 = 0' X2 = 0' Y2 = 1'  				StrokeDashArray = { 0' 2 }'  				Stretch = Stretch.Fill'  				StrokeThickness = 1'  				StrokeDashCap = PenLineCap.Round'  				Margin = new Thickness(2' 0' 2' 0)'  				Tag = tag  			};
Magic Number,ICSharpCode.AvalonEdit.Editing,DottedLineMargin,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Editing\DottedLineMargin.cs,Create,The following statement contains a magic number: Line line = new Line {  				X1 = 0' Y1 = 0' X2 = 0' Y2 = 1'  				StrokeDashArray = { 0' 2 }'  				Stretch = Stretch.Fill'  				StrokeThickness = 1'  				StrokeDashCap = PenLineCap.Round'  				Margin = new Thickness(2' 0' 2' 0)'  				Tag = tag  			};
Magic Number,ICSharpCode.AvalonEdit.Editing,LineNumberMargin,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Editing\LineNumberMargin.cs,OnDocumentLineCountChanged,The following statement contains a magic number: if (newLength < 2)  				newLength = 2;
Magic Number,ICSharpCode.AvalonEdit.Editing,LineNumberMargin,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Editing\LineNumberMargin.cs,OnDocumentLineCountChanged,The following statement contains a magic number: if (newLength < 2)  				newLength = 2;
Magic Number,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,textArea_MouseLeftButtonDown,The following statement contains a magic number: if (!e.Handled && e.ChangedButton == MouseButton.Left) {  				ModifierKeys modifiers = Keyboard.Modifiers;  				bool shift = (modifiers & ModifierKeys.Shift) == ModifierKeys.Shift;  				if (enableTextDragDrop && e.ClickCount == 1 && !shift) {  					int visualColumn;  					int offset = GetOffsetFromMousePosition(e' out visualColumn);  					if (textArea.Selection.Contains(offset)) {  						if (textArea.CaptureMouse()) {  							mode = SelectionMode.PossibleDragStart;  							possibleDragStartMousePos = e.GetPosition(textArea);  						}  						e.Handled = true;  						return;  					}  				}  				  				var oldPosition = textArea.Caret.Position;  				SetCaretOffsetToMousePosition(e);  				  				  				if (!shift) {  					textArea.ClearSelection();  				}  				if (textArea.CaptureMouse()) {  					if ((modifiers & ModifierKeys.Alt) == ModifierKeys.Alt && textArea.Options.EnableRectangularSelection) {  						mode = SelectionMode.Rectangular;  						if (shift && textArea.Selection is RectangleSelection) {  							textArea.Selection = textArea.Selection.StartSelectionOrSetEndpoint(oldPosition' textArea.Caret.Position);  						}  					} else if (e.ClickCount == 1 && ((modifiers & ModifierKeys.Control) == 0)) {  						mode = SelectionMode.Normal;  						if (shift && !(textArea.Selection is RectangleSelection)) {  							textArea.Selection = textArea.Selection.StartSelectionOrSetEndpoint(oldPosition' textArea.Caret.Position);  						}  					} else {  						SimpleSegment startWord;  						if (e.ClickCount == 3) {  							mode = SelectionMode.WholeLine;  							startWord = GetLineAtMousePosition(e);  						} else {  							mode = SelectionMode.WholeWord;  							startWord = GetWordAtMousePosition(e);  						}  						if (startWord == SimpleSegment.Invalid) {  							mode = SelectionMode.None;  							textArea.ReleaseMouseCapture();  							return;  						}  						if (shift && !textArea.Selection.IsEmpty) {  							if (startWord.Offset < textArea.Selection.SurroundingSegment.Offset) {  								textArea.Selection = textArea.Selection.SetEndpoint(new TextViewPosition(textArea.Document.GetLocation(startWord.Offset)));  							} else if (startWord.EndOffset > textArea.Selection.SurroundingSegment.EndOffset) {  								textArea.Selection = textArea.Selection.SetEndpoint(new TextViewPosition(textArea.Document.GetLocation(startWord.EndOffset)));  							}  							this.startWord = new AnchorSegment(textArea.Document' textArea.Selection.SurroundingSegment);  						} else {  							textArea.Selection = Selection.Create(textArea' startWord.Offset' startWord.EndOffset);  							this.startWord = new AnchorSegment(textArea.Document' startWord.Offset' startWord.Length);  						}  					}  				}  			}
Magic Number,ICSharpCode.AvalonEdit.Editing,SelectionMouseHandler,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Editing\SelectionMouseHandler.cs,ExtendSelectionToMouse,The following statement contains a magic number: textArea.Caret.BringCaretToView(5.0);
Magic Number,ICSharpCode.AvalonEdit.Editing,SimpleSelection,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Editing\SimpleSelection.cs,GetHashCode,The following statement contains a magic number: unchecked {  				return startOffset * 27811 + endOffset + textArea.GetHashCode();  			}
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingLineElement,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Folding\FoldingElementGenerator.cs,OnMouseDown,The following statement contains a magic number: if (e.ClickCount == 2 && e.ChangedButton == MouseButton.Left) {  					fs.IsFolded = false;  					e.Handled = true;  				} else {  					base.OnMouseDown(e);  				}
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMargin,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,ArrangeOverride,The following statement contains a magic number: foreach (FoldingMarginMarker m in markers) {  				int visualColumn = m.VisualLine.GetVisualColumn(m.FoldingSection.StartOffset - m.VisualLine.FirstDocumentLine.Offset);  				TextLine textLine = m.VisualLine.GetTextLine(visualColumn);  				double yPos = m.VisualLine.GetTextLineVisualYPosition(textLine' VisualYPosition.TextMiddle) - TextView.VerticalOffset;  				yPos -= m.DesiredSize.Height / 2;  				double xPos = (finalSize.Width - m.DesiredSize.Width) / 2;  				m.Arrange(new Rect(PixelSnapHelpers.Round(new Point(xPos' yPos)' pixelSize)' m.DesiredSize));  			}
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMargin,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,ArrangeOverride,The following statement contains a magic number: foreach (FoldingMarginMarker m in markers) {  				int visualColumn = m.VisualLine.GetVisualColumn(m.FoldingSection.StartOffset - m.VisualLine.FirstDocumentLine.Offset);  				TextLine textLine = m.VisualLine.GetTextLine(visualColumn);  				double yPos = m.VisualLine.GetTextLineVisualYPosition(textLine' VisualYPosition.TextMiddle) - TextView.VerticalOffset;  				yPos -= m.DesiredSize.Height / 2;  				double xPos = (finalSize.Width - m.DesiredSize.Width) / 2;  				m.Arrange(new Rect(PixelSnapHelpers.Round(new Point(xPos' yPos)' pixelSize)' m.DesiredSize));  			}
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMargin,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,DrawFoldLines,The following statement contains a magic number: double markerXPos = PixelSnapHelpers.PixelAlign(RenderSize.Width / 2' pixelSize.Width);
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMargin,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,DrawFoldLines,The following statement contains a magic number: foreach (VisualLine vl in TextView.VisualLines) {  				foreach (TextLine tl in vl.TextLines) {  					if (endMarker[tlNumber] != null) {  						double visualPos = GetVisualPos(vl' tl' pixelSize.Height);  						drawingContext.DrawLine(endMarker[tlNumber]' new Point(markerXPos - pixelSize.Width / 2' visualPos)' new Point(RenderSize.Width' visualPos));  					}  					if (colors[tlNumber + 1] != currentPen) {  						double visualPos = GetVisualPos(vl' tl' pixelSize.Height);  						if (currentPen != null) {  							drawingContext.DrawLine(currentPen' new Point(markerXPos' startY + pixelSize.Height / 2)' new Point(markerXPos' visualPos - pixelSize.Height / 2));  						}  						currentPen = colors[tlNumber + 1];  						startY = visualPos;  					}  					tlNumber++;  				}  			}
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMargin,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,DrawFoldLines,The following statement contains a magic number: foreach (VisualLine vl in TextView.VisualLines) {  				foreach (TextLine tl in vl.TextLines) {  					if (endMarker[tlNumber] != null) {  						double visualPos = GetVisualPos(vl' tl' pixelSize.Height);  						drawingContext.DrawLine(endMarker[tlNumber]' new Point(markerXPos - pixelSize.Width / 2' visualPos)' new Point(RenderSize.Width' visualPos));  					}  					if (colors[tlNumber + 1] != currentPen) {  						double visualPos = GetVisualPos(vl' tl' pixelSize.Height);  						if (currentPen != null) {  							drawingContext.DrawLine(currentPen' new Point(markerXPos' startY + pixelSize.Height / 2)' new Point(markerXPos' visualPos - pixelSize.Height / 2));  						}  						currentPen = colors[tlNumber + 1];  						startY = visualPos;  					}  					tlNumber++;  				}  			}
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMargin,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,DrawFoldLines,The following statement contains a magic number: foreach (VisualLine vl in TextView.VisualLines) {  				foreach (TextLine tl in vl.TextLines) {  					if (endMarker[tlNumber] != null) {  						double visualPos = GetVisualPos(vl' tl' pixelSize.Height);  						drawingContext.DrawLine(endMarker[tlNumber]' new Point(markerXPos - pixelSize.Width / 2' visualPos)' new Point(RenderSize.Width' visualPos));  					}  					if (colors[tlNumber + 1] != currentPen) {  						double visualPos = GetVisualPos(vl' tl' pixelSize.Height);  						if (currentPen != null) {  							drawingContext.DrawLine(currentPen' new Point(markerXPos' startY + pixelSize.Height / 2)' new Point(markerXPos' visualPos - pixelSize.Height / 2));  						}  						currentPen = colors[tlNumber + 1];  						startY = visualPos;  					}  					tlNumber++;  				}  			}
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMargin,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Folding\FoldingMargin.cs,DrawFoldLines,The following statement contains a magic number: if (currentPen != null) {  				drawingContext.DrawLine(currentPen' new Point(markerXPos' startY + pixelSize.Height / 2)' new Point(markerXPos' RenderSize.Height));  			}
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMarginMarker,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Folding\FoldingMarginMarker.cs,OnRender,The following statement contains a magic number: Rect rect = new Rect(pixelSize.Width / 2'  			                     pixelSize.Height / 2'  			                     this.RenderSize.Width - pixelSize.Width'  			                     this.RenderSize.Height - pixelSize.Height);
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMarginMarker,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Folding\FoldingMarginMarker.cs,OnRender,The following statement contains a magic number: Rect rect = new Rect(pixelSize.Width / 2'  			                     pixelSize.Height / 2'  			                     this.RenderSize.Width - pixelSize.Width'  			                     this.RenderSize.Height - pixelSize.Height);
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMarginMarker,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Folding\FoldingMarginMarker.cs,OnRender,The following statement contains a magic number: double middleX = rect.Left + rect.Width / 2;
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMarginMarker,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Folding\FoldingMarginMarker.cs,OnRender,The following statement contains a magic number: double middleY = rect.Top + rect.Height / 2;
Magic Number,ICSharpCode.AvalonEdit.Folding,FoldingMarginMarker,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Folding\FoldingMarginMarker.cs,OnRender,The following statement contains a magic number: double space = PixelSnapHelpers.Round(rect.Width / 8' pixelSize.Width) + pixelSize.Width;
Magic Number,ICSharpCode.AvalonEdit.Folding,XmlFoldingStrategy,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Folding\XmlFoldingStrategy.cs,CreateCommentFold,The following statement contains a magic number: if (comment != null) {  				int firstNewLine = comment.IndexOf('\n');  				if (firstNewLine >= 0) {  					  					// Take off 4 chars to get the actual comment start (takes  					// into account the <!-- chars.  					  					int startOffset = GetOffset(document' reader) - 4;  					int endOffset = startOffset + comment.Length + 7;  					  					string foldText = String.Concat("<!--"' comment.Substring(0' firstNewLine).TrimEnd('\r') ' "-->");  					foldMarkers.Add(new NewFolding(startOffset' endOffset) { Name = foldText } );  				}  			}
Magic Number,ICSharpCode.AvalonEdit.Folding,XmlFoldingStrategy,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Folding\XmlFoldingStrategy.cs,CreateCommentFold,The following statement contains a magic number: if (comment != null) {  				int firstNewLine = comment.IndexOf('\n');  				if (firstNewLine >= 0) {  					  					// Take off 4 chars to get the actual comment start (takes  					// into account the <!-- chars.  					  					int startOffset = GetOffset(document' reader) - 4;  					int endOffset = startOffset + comment.Length + 7;  					  					string foldText = String.Concat("<!--"' comment.Substring(0' firstNewLine).TrimEnd('\r') ' "-->");  					foldMarkers.Add(new NewFolding(startOffset' endOffset) { Name = foldText } );  				}  			}
Magic Number,ICSharpCode.AvalonEdit.Highlighting,HtmlOptions,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Highlighting\HtmlClipboard.cs,HtmlOptions,The following statement contains a magic number: this.TabSize = 4;
Magic Number,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,ParseColor,The following statement contains a magic number: if (c.StartsWith("#"' StringComparison.Ordinal)) {  				int a = 255;  				int offset = 0;  				if (c.Length > 7) {  					offset = 2;  					a = Int32.Parse(c.Substring(1'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				}  				  				int r = Int32.Parse(c.Substring(1 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				int g = Int32.Parse(c.Substring(3 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				int b = Int32.Parse(c.Substring(5 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				return new SimpleHighlightingBrush(Color.FromArgb((byte)a' (byte)r' (byte)g' (byte)b));  			} else if (c.StartsWith("SystemColors."' StringComparison.Ordinal)) {  				return V2Loader.GetSystemColorBrush(null' c);  			} else {  				return new SimpleHighlightingBrush((Color)V2Loader.ColorConverter.ConvertFromInvariantString(c));  			}
Magic Number,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,ParseColor,The following statement contains a magic number: if (c.StartsWith("#"' StringComparison.Ordinal)) {  				int a = 255;  				int offset = 0;  				if (c.Length > 7) {  					offset = 2;  					a = Int32.Parse(c.Substring(1'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				}  				  				int r = Int32.Parse(c.Substring(1 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				int g = Int32.Parse(c.Substring(3 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				int b = Int32.Parse(c.Substring(5 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				return new SimpleHighlightingBrush(Color.FromArgb((byte)a' (byte)r' (byte)g' (byte)b));  			} else if (c.StartsWith("SystemColors."' StringComparison.Ordinal)) {  				return V2Loader.GetSystemColorBrush(null' c);  			} else {  				return new SimpleHighlightingBrush((Color)V2Loader.ColorConverter.ConvertFromInvariantString(c));  			}
Magic Number,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,ParseColor,The following statement contains a magic number: if (c.StartsWith("#"' StringComparison.Ordinal)) {  				int a = 255;  				int offset = 0;  				if (c.Length > 7) {  					offset = 2;  					a = Int32.Parse(c.Substring(1'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				}  				  				int r = Int32.Parse(c.Substring(1 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				int g = Int32.Parse(c.Substring(3 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				int b = Int32.Parse(c.Substring(5 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				return new SimpleHighlightingBrush(Color.FromArgb((byte)a' (byte)r' (byte)g' (byte)b));  			} else if (c.StartsWith("SystemColors."' StringComparison.Ordinal)) {  				return V2Loader.GetSystemColorBrush(null' c);  			} else {  				return new SimpleHighlightingBrush((Color)V2Loader.ColorConverter.ConvertFromInvariantString(c));  			}
Magic Number,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,ParseColor,The following statement contains a magic number: if (c.StartsWith("#"' StringComparison.Ordinal)) {  				int a = 255;  				int offset = 0;  				if (c.Length > 7) {  					offset = 2;  					a = Int32.Parse(c.Substring(1'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				}  				  				int r = Int32.Parse(c.Substring(1 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				int g = Int32.Parse(c.Substring(3 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				int b = Int32.Parse(c.Substring(5 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				return new SimpleHighlightingBrush(Color.FromArgb((byte)a' (byte)r' (byte)g' (byte)b));  			} else if (c.StartsWith("SystemColors."' StringComparison.Ordinal)) {  				return V2Loader.GetSystemColorBrush(null' c);  			} else {  				return new SimpleHighlightingBrush((Color)V2Loader.ColorConverter.ConvertFromInvariantString(c));  			}
Magic Number,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,ParseColor,The following statement contains a magic number: if (c.StartsWith("#"' StringComparison.Ordinal)) {  				int a = 255;  				int offset = 0;  				if (c.Length > 7) {  					offset = 2;  					a = Int32.Parse(c.Substring(1'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				}  				  				int r = Int32.Parse(c.Substring(1 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				int g = Int32.Parse(c.Substring(3 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				int b = Int32.Parse(c.Substring(5 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				return new SimpleHighlightingBrush(Color.FromArgb((byte)a' (byte)r' (byte)g' (byte)b));  			} else if (c.StartsWith("SystemColors."' StringComparison.Ordinal)) {  				return V2Loader.GetSystemColorBrush(null' c);  			} else {  				return new SimpleHighlightingBrush((Color)V2Loader.ColorConverter.ConvertFromInvariantString(c));  			}
Magic Number,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,ParseColor,The following statement contains a magic number: if (c.StartsWith("#"' StringComparison.Ordinal)) {  				int a = 255;  				int offset = 0;  				if (c.Length > 7) {  					offset = 2;  					a = Int32.Parse(c.Substring(1'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				}  				  				int r = Int32.Parse(c.Substring(1 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				int g = Int32.Parse(c.Substring(3 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				int b = Int32.Parse(c.Substring(5 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				return new SimpleHighlightingBrush(Color.FromArgb((byte)a' (byte)r' (byte)g' (byte)b));  			} else if (c.StartsWith("SystemColors."' StringComparison.Ordinal)) {  				return V2Loader.GetSystemColorBrush(null' c);  			} else {  				return new SimpleHighlightingBrush((Color)V2Loader.ColorConverter.ConvertFromInvariantString(c));  			}
Magic Number,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,ParseColor,The following statement contains a magic number: if (c.StartsWith("#"' StringComparison.Ordinal)) {  				int a = 255;  				int offset = 0;  				if (c.Length > 7) {  					offset = 2;  					a = Int32.Parse(c.Substring(1'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				}  				  				int r = Int32.Parse(c.Substring(1 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				int g = Int32.Parse(c.Substring(3 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				int b = Int32.Parse(c.Substring(5 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				return new SimpleHighlightingBrush(Color.FromArgb((byte)a' (byte)r' (byte)g' (byte)b));  			} else if (c.StartsWith("SystemColors."' StringComparison.Ordinal)) {  				return V2Loader.GetSystemColorBrush(null' c);  			} else {  				return new SimpleHighlightingBrush((Color)V2Loader.ColorConverter.ConvertFromInvariantString(c));  			}
Magic Number,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,ParseColor,The following statement contains a magic number: if (c.StartsWith("#"' StringComparison.Ordinal)) {  				int a = 255;  				int offset = 0;  				if (c.Length > 7) {  					offset = 2;  					a = Int32.Parse(c.Substring(1'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				}  				  				int r = Int32.Parse(c.Substring(1 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				int g = Int32.Parse(c.Substring(3 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				int b = Int32.Parse(c.Substring(5 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				return new SimpleHighlightingBrush(Color.FromArgb((byte)a' (byte)r' (byte)g' (byte)b));  			} else if (c.StartsWith("SystemColors."' StringComparison.Ordinal)) {  				return V2Loader.GetSystemColorBrush(null' c);  			} else {  				return new SimpleHighlightingBrush((Color)V2Loader.ColorConverter.ConvertFromInvariantString(c));  			}
Magic Number,ICSharpCode.AvalonEdit.Highlighting.Xshd,V1Loader,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Highlighting\Xshd\V1Loader.cs,ParseColor,The following statement contains a magic number: if (c.StartsWith("#"' StringComparison.Ordinal)) {  				int a = 255;  				int offset = 0;  				if (c.Length > 7) {  					offset = 2;  					a = Int32.Parse(c.Substring(1'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				}  				  				int r = Int32.Parse(c.Substring(1 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				int g = Int32.Parse(c.Substring(3 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				int b = Int32.Parse(c.Substring(5 + offset'2)' NumberStyles.HexNumber' CultureInfo.InvariantCulture);  				return new SimpleHighlightingBrush(Color.FromArgb((byte)a' (byte)r' (byte)g' (byte)b));  			} else if (c.StartsWith("SystemColors."' StringComparison.Ordinal)) {  				return V2Loader.GetSystemColorBrush(null' c);  			} else {  				return new SimpleHighlightingBrush((Color)V2Loader.ColorConverter.ConvertFromInvariantString(c));  			}
Magic Number,ICSharpCode.AvalonEdit.Highlighting.Xshd,V2Loader,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Highlighting\Xshd\V2Loader.cs,GetSystemColorBrush,The following statement contains a magic number: string shortName = name.Substring(13);
Magic Number,ICSharpCode.AvalonEdit.Rendering,FormattedTextElement,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\FormattedTextElement.cs,PrepareText,The following statement contains a magic number: return formatter.FormatLine(  				new SimpleTextSource(text' properties)'  				0'  				32000'  				new VisualLineTextParagraphProperties {  					defaultTextRunProperties = properties'  					textWrapping = TextWrapping.NoWrap'  					tabSize = 40  				}'  				null);
Magic Number,ICSharpCode.AvalonEdit.Rendering,FormattedTextElement,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\FormattedTextElement.cs,PrepareText,The following statement contains a magic number: return formatter.FormatLine(  				new SimpleTextSource(text' properties)'  				0'  				32000'  				new VisualLineTextParagraphProperties {  					defaultTextRunProperties = properties'  					textWrapping = TextWrapping.NoWrap'  					tabSize = 40  				}'  				null);
Magic Number,ICSharpCode.AvalonEdit.Rendering,HeightTree,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\HeightTree.cs,BuildTree,The following statement contains a magic number: int middle = (start + end) / 2;
Magic Number,ICSharpCode.AvalonEdit.Rendering,HeightTree,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\HeightTree.cs,AppendTreeToString,The following statement contains a magic number: indent += 2;
Magic Number,ICSharpCode.AvalonEdit.Rendering,SpecialCharacterTextRun,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\SingleCharacterElementGenerator.cs,SpecialCharacterTextRun,The following statement contains a magic number: darkGrayBrush = new SolidColorBrush(Color.FromArgb(200' 128' 128' 128));
Magic Number,ICSharpCode.AvalonEdit.Rendering,SpecialCharacterTextRun,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\SingleCharacterElementGenerator.cs,SpecialCharacterTextRun,The following statement contains a magic number: darkGrayBrush = new SolidColorBrush(Color.FromArgb(200' 128' 128' 128));
Magic Number,ICSharpCode.AvalonEdit.Rendering,SpecialCharacterTextRun,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\SingleCharacterElementGenerator.cs,SpecialCharacterTextRun,The following statement contains a magic number: darkGrayBrush = new SolidColorBrush(Color.FromArgb(200' 128' 128' 128));
Magic Number,ICSharpCode.AvalonEdit.Rendering,SpecialCharacterTextRun,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\SingleCharacterElementGenerator.cs,SpecialCharacterTextRun,The following statement contains a magic number: darkGrayBrush = new SolidColorBrush(Color.FromArgb(200' 128' 128' 128));
Magic Number,ICSharpCode.AvalonEdit.Rendering,SpecialCharacterTextRun,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\SingleCharacterElementGenerator.cs,Draw,The following statement contains a magic number: Point newOrigin = new Point(origin.X + 1.5' origin.Y);
Magic Number,ICSharpCode.AvalonEdit.Rendering,SpecialCharacterTextRun,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\SingleCharacterElementGenerator.cs,Draw,The following statement contains a magic number: Rect r = new Rect(newOrigin.X - 0.5' newOrigin.Y - metrics.Baseline' metrics.Width + 2' metrics.Height);
Magic Number,ICSharpCode.AvalonEdit.Rendering,SpecialCharacterTextRun,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\SingleCharacterElementGenerator.cs,Draw,The following statement contains a magic number: Rect r = new Rect(newOrigin.X - 0.5' newOrigin.Y - metrics.Baseline' metrics.Width + 2' metrics.Height);
Magic Number,ICSharpCode.AvalonEdit.Rendering,SpecialCharacterTextRun,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\SingleCharacterElementGenerator.cs,Draw,The following statement contains a magic number: drawingContext.DrawRoundedRectangle(darkGrayBrush' null' r' 2.5' 2.5);
Magic Number,ICSharpCode.AvalonEdit.Rendering,SpecialCharacterTextRun,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\SingleCharacterElementGenerator.cs,Draw,The following statement contains a magic number: drawingContext.DrawRoundedRectangle(darkGrayBrush' null' r' 2.5' 2.5);
Magic Number,ICSharpCode.AvalonEdit.Rendering,SpecialCharacterTextRun,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\SingleCharacterElementGenerator.cs,Format,The following statement contains a magic number: return new TextEmbeddedObjectMetrics(metrics.Width + 3'  				                                     metrics.Height' metrics.Baseline);
Magic Number,ICSharpCode.AvalonEdit.Rendering,SpecialCharacterTextRun,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\SingleCharacterElementGenerator.cs,ComputeBoundingBox,The following statement contains a magic number: r.Width += 3;
Magic Number,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,MeasureOverride,The following statement contains a magic number: if (availableSize.Width > 32000)  				availableSize.Width = 32000;
Magic Number,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,MeasureOverride,The following statement contains a magic number: if (availableSize.Width > 32000)  				availableSize.Width = 32000;
Magic Number,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,MeasureOverride,The following statement contains a magic number: if (options.AllowScrollBelowDocument) {  				if (!double.IsInfinity(scrollViewport.Height)) {  					heightTreeHeight = Math.Max(heightTreeHeight' Math.Min(heightTreeHeight - 50' scrollOffset.Y) + scrollViewport.Height);  				}  			}
Magic Number,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,BuildVisualLine,The following statement contains a magic number: while (textOffset <= visualLine.VisualLengthWithEndOfLineMarker) {  				TextLine textLine = formatter.FormatLine(  					textSource'  					textOffset'  					availableSize.Width'  					paragraphProperties'  					lastLineBreak  				);  				textLines.Add(textLine);  				textOffset += textLine.Length;  				  				// exit loop so that we don't do the indentation calculation if there's only a single line  				if (textOffset >= visualLine.VisualLengthWithEndOfLineMarker)  					break;  				  				if (paragraphProperties.firstLineInParagraph) {  					paragraphProperties.firstLineInParagraph = false;  					  					TextEditorOptions options = this.Options;  					double indentation = 0;  					if (options.InheritWordWrapIndentation) {  						// determine indentation for next line:  						int indentVisualColumn = GetIndentationVisualColumn(visualLine);  						if (indentVisualColumn > 0 && indentVisualColumn < textOffset) {  							indentation = textLine.GetDistanceFromCharacterHit(new CharacterHit(indentVisualColumn' 0));  						}  					}  					indentation += options.WordWrapIndentation;  					// apply the calculated indentation unless it's more than half of the text editor size:  					if (indentation > 0 && indentation * 2 < availableSize.Width)  						paragraphProperties.indent = indentation;  				}  				lastLineBreak = textLine.GetTextLineBreak();  			}
Magic Number,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,OnRender,The following statement contains a magic number: foreach (var line in visibleVisualLines) {  				Brush currentBrush = null;  				int startVC = 0;  				int length = 0;  				foreach (var element in line.Elements) {  					if (currentBrush == null || !currentBrush.Equals(element.BackgroundBrush)) {  						if (currentBrush != null) {  							BackgroundGeometryBuilder builder = new BackgroundGeometryBuilder();  							builder.AlignToWholePixels = true;  							builder.CornerRadius = 3;  							foreach (var rect in BackgroundGeometryBuilder.GetRectsFromVisualSegment(this' line' startVC' startVC + length))  								builder.AddRectangle(this' rect);  							Geometry geometry = builder.CreateGeometry();  							if (geometry != null) {  								drawingContext.DrawGeometry(currentBrush' null' geometry);  							}  						}  						startVC = element.VisualColumn;  						length = element.DocumentLength;  						currentBrush = element.BackgroundBrush;  					} else {  						length += element.VisualLength;  					}  				}  				if (currentBrush != null) {  					BackgroundGeometryBuilder builder = new BackgroundGeometryBuilder();  					builder.AlignToWholePixels = true;  					builder.CornerRadius = 3;  					foreach (var rect in BackgroundGeometryBuilder.GetRectsFromVisualSegment(this' line' startVC' startVC + length))  						builder.AddRectangle(this' rect);  					Geometry geometry = builder.CreateGeometry();  					if (geometry != null) {  						drawingContext.DrawGeometry(currentBrush' null' geometry);  					}  				}  			}
Magic Number,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,OnRender,The following statement contains a magic number: foreach (var line in visibleVisualLines) {  				Brush currentBrush = null;  				int startVC = 0;  				int length = 0;  				foreach (var element in line.Elements) {  					if (currentBrush == null || !currentBrush.Equals(element.BackgroundBrush)) {  						if (currentBrush != null) {  							BackgroundGeometryBuilder builder = new BackgroundGeometryBuilder();  							builder.AlignToWholePixels = true;  							builder.CornerRadius = 3;  							foreach (var rect in BackgroundGeometryBuilder.GetRectsFromVisualSegment(this' line' startVC' startVC + length))  								builder.AddRectangle(this' rect);  							Geometry geometry = builder.CreateGeometry();  							if (geometry != null) {  								drawingContext.DrawGeometry(currentBrush' null' geometry);  							}  						}  						startVC = element.VisualColumn;  						length = element.DocumentLength;  						currentBrush = element.BackgroundBrush;  					} else {  						length += element.VisualLength;  					}  				}  				if (currentBrush != null) {  					BackgroundGeometryBuilder builder = new BackgroundGeometryBuilder();  					builder.AlignToWholePixels = true;  					builder.CornerRadius = 3;  					foreach (var rect in BackgroundGeometryBuilder.GetRectsFromVisualSegment(this' line' startVC' startVC + length))  						builder.AddRectangle(this' rect);  					Geometry geometry = builder.CreateGeometry();  					if (geometry != null) {  						drawingContext.DrawGeometry(currentBrush' null' geometry);  					}  				}  			}
Magic Number,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,CalculateDefaultTextMetrics,The following statement contains a magic number: if (formatter != null) {  				var textRunProperties = CreateGlobalTextRunProperties();  				using (var line = formatter.FormatLine(  					new SimpleTextSource("x"' textRunProperties)'  					0' 32000'  					new VisualLineTextParagraphProperties { defaultTextRunProperties = textRunProperties }'  					null))  				{  					wideSpaceWidth = Math.Max(1' line.WidthIncludingTrailingWhitespace);  					defaultBaseline = Math.Max(1' line.Baseline);  					defaultLineHeight = Math.Max(1' line.Height);  				}  			} else {  				wideSpaceWidth = FontSize / 2;  				defaultBaseline = FontSize;  				defaultLineHeight = FontSize + 3;  			}
Magic Number,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,CalculateDefaultTextMetrics,The following statement contains a magic number: if (formatter != null) {  				var textRunProperties = CreateGlobalTextRunProperties();  				using (var line = formatter.FormatLine(  					new SimpleTextSource("x"' textRunProperties)'  					0' 32000'  					new VisualLineTextParagraphProperties { defaultTextRunProperties = textRunProperties }'  					null))  				{  					wideSpaceWidth = Math.Max(1' line.WidthIncludingTrailingWhitespace);  					defaultBaseline = Math.Max(1' line.Baseline);  					defaultLineHeight = Math.Max(1' line.Height);  				}  			} else {  				wideSpaceWidth = FontSize / 2;  				defaultBaseline = FontSize;  				defaultLineHeight = FontSize + 3;  			}
Magic Number,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,CalculateDefaultTextMetrics,The following statement contains a magic number: if (formatter != null) {  				var textRunProperties = CreateGlobalTextRunProperties();  				using (var line = formatter.FormatLine(  					new SimpleTextSource("x"' textRunProperties)'  					0' 32000'  					new VisualLineTextParagraphProperties { defaultTextRunProperties = textRunProperties }'  					null))  				{  					wideSpaceWidth = Math.Max(1' line.WidthIncludingTrailingWhitespace);  					defaultBaseline = Math.Max(1' line.Baseline);  					defaultLineHeight = Math.Max(1' line.Height);  				}  			} else {  				wideSpaceWidth = FontSize / 2;  				defaultBaseline = FontSize;  				defaultLineHeight = FontSize + 3;  			}
Magic Number,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,MakeVisible,The following statement contains a magic number: if (rectangle.Left < visibleRectangle.Left) {  				if (rectangle.Right > visibleRectangle.Right) {  					newScrollOffset.X = rectangle.Left + rectangle.Width / 2;  				} else {  					newScrollOffset.X = rectangle.Left;  				}  			} else if (rectangle.Right > visibleRectangle.Right) {  				newScrollOffset.X = rectangle.Right - scrollViewport.Width;  			}
Magic Number,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,MakeVisible,The following statement contains a magic number: if (rectangle.Top < visibleRectangle.Top) {  				if (rectangle.Bottom > visibleRectangle.Bottom) {  					newScrollOffset.Y = rectangle.Top + rectangle.Height / 2;  				} else {  					newScrollOffset.Y = rectangle.Top;  				}  			} else if (rectangle.Bottom > visibleRectangle.Bottom) {  				newScrollOffset.Y = rectangle.Bottom - scrollViewport.Height;  			}
Magic Number,ICSharpCode.AvalonEdit.Rendering,VisualLine,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLine.cs,GetTextLineVisualYPosition,The following statement contains a magic number: foreach (TextLine tl in TextLines) {  				if (tl == textLine) {  					switch (yPositionMode) {  						case VisualYPosition.LineTop:  							return pos;  						case VisualYPosition.LineMiddle:  							return pos + tl.Height / 2;  						case VisualYPosition.LineBottom:  							return pos + tl.Height;  						case VisualYPosition.TextTop:  							return pos + tl.Baseline - textView.DefaultBaseline;  						case VisualYPosition.TextBottom:  							return pos + tl.Baseline - textView.DefaultBaseline + textView.DefaultLineHeight;  						case VisualYPosition.TextMiddle:  							return pos + tl.Baseline - textView.DefaultBaseline + textView.DefaultLineHeight / 2;  						case VisualYPosition.Baseline:  							return pos + tl.Baseline;  						default:  							throw new ArgumentException("Invalid yPositionMode:" + yPositionMode);  					}  				} else {  					pos += tl.Height;  				}  			}
Magic Number,ICSharpCode.AvalonEdit.Rendering,VisualLine,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLine.cs,GetTextLineVisualYPosition,The following statement contains a magic number: foreach (TextLine tl in TextLines) {  				if (tl == textLine) {  					switch (yPositionMode) {  						case VisualYPosition.LineTop:  							return pos;  						case VisualYPosition.LineMiddle:  							return pos + tl.Height / 2;  						case VisualYPosition.LineBottom:  							return pos + tl.Height;  						case VisualYPosition.TextTop:  							return pos + tl.Baseline - textView.DefaultBaseline;  						case VisualYPosition.TextBottom:  							return pos + tl.Baseline - textView.DefaultBaseline + textView.DefaultLineHeight;  						case VisualYPosition.TextMiddle:  							return pos + tl.Baseline - textView.DefaultBaseline + textView.DefaultLineHeight / 2;  						case VisualYPosition.Baseline:  							return pos + tl.Baseline;  						default:  							throw new ArgumentException("Invalid yPositionMode:" + yPositionMode);  					}  				} else {  					pos += tl.Height;  				}  			}
Magic Number,ICSharpCode.AvalonEdit.Rendering,VisualLine,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLine.cs,GetTextLineByVisualYPosition,The following statement contains a magic number: const double epsilon = 0.0001;
Magic Number,ICSharpCode.AvalonEdit.Rendering,VisualLineTextSource,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\VisualLineTextSource.cs,CreateTextRunForNewLine,The following statement contains a magic number: if (lastDocumentLine.DelimiterLength == 2) {  				newlineText = "¶";  			} else if (lastDocumentLine.DelimiterLength == 1) {  				char newlineChar = Document.GetCharAt(lastDocumentLine.Offset + lastDocumentLine.Length);  				if (newlineChar == '\r')  					newlineText = "\\r";  				else if (newlineChar == '\n')  					newlineText = "\\n";  				else  					newlineText = "?";  			}
Magic Number,ICSharpCode.AvalonEdit.Search,SearchResultBackgroundRenderer,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Search\SearchResultBackgroundRenderer.cs,Draw,The following statement contains a magic number: foreach (SearchResult result in currentResults.FindOverlappingSegments(viewStart' viewEnd - viewStart)) {  				BackgroundGeometryBuilder geoBuilder = new BackgroundGeometryBuilder();  				geoBuilder.AlignToMiddleOfPixels = true;  				geoBuilder.CornerRadius = 3;  				geoBuilder.AddSegment(textView' result);  				Geometry geometry = geoBuilder.CreateGeometry();  				if (geometry != null) {  					drawingContext.DrawGeometry(markerBrush' markerPen' geometry);  				}  			}
Magic Number,ICSharpCode.AvalonEdit.Snippets,Renderer,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Snippets\SnippetReplaceableTextElement.cs,CreateBackgroundBrush,The following statement contains a magic number: b.Opacity = 0.4;
Magic Number,ICSharpCode.AvalonEdit.Utils,CompressingTreeList<T>,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Utils\CompressingTreeList.cs,AppendTreeToString,The following statement contains a magic number: indent += 2;
Magic Number,ICSharpCode.AvalonEdit.Utils,Deque<T>,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Utils\Deque.cs,PushBack,The following statement contains a magic number: if (size == arr.Length)  				SetCapacity(Math.Max(4' arr.Length * 2));
Magic Number,ICSharpCode.AvalonEdit.Utils,Deque<T>,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Utils\Deque.cs,PushBack,The following statement contains a magic number: if (size == arr.Length)  				SetCapacity(Math.Max(4' arr.Length * 2));
Magic Number,ICSharpCode.AvalonEdit.Utils,Deque<T>,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Utils\Deque.cs,PushFront,The following statement contains a magic number: if (size == arr.Length)  				SetCapacity(Math.Max(4' arr.Length * 2));
Magic Number,ICSharpCode.AvalonEdit.Utils,Deque<T>,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Utils\Deque.cs,PushFront,The following statement contains a magic number: if (size == arr.Length)  				SetCapacity(Math.Max(4' arr.Length * 2));
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Utils\FileReader.cs,IsUnicode,The following statement contains a magic number: switch (encoding.CodePage) {  				case 65000: // UTF-7  				case 65001: // UTF-8  				case 1200: // UTF-16 LE  				case 1201: // UTF-16 BE  				case 12000: // UTF-32 LE  				case 12001: // UTF-32 BE  					return true;  				default:  					return false;  			}
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Utils\FileReader.cs,IsUnicode,The following statement contains a magic number: switch (encoding.CodePage) {  				case 65000: // UTF-7  				case 65001: // UTF-8  				case 1200: // UTF-16 LE  				case 1201: // UTF-16 BE  				case 12000: // UTF-32 LE  				case 12001: // UTF-32 BE  					return true;  				default:  					return false;  			}
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Utils\FileReader.cs,IsUnicode,The following statement contains a magic number: switch (encoding.CodePage) {  				case 65000: // UTF-7  				case 65001: // UTF-8  				case 1200: // UTF-16 LE  				case 1201: // UTF-16 BE  				case 12000: // UTF-32 LE  				case 12001: // UTF-32 BE  					return true;  				default:  					return false;  			}
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Utils\FileReader.cs,IsUnicode,The following statement contains a magic number: switch (encoding.CodePage) {  				case 65000: // UTF-7  				case 65001: // UTF-8  				case 1200: // UTF-16 LE  				case 1201: // UTF-16 BE  				case 12000: // UTF-32 LE  				case 12001: // UTF-32 BE  					return true;  				default:  					return false;  			}
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Utils\FileReader.cs,IsUnicode,The following statement contains a magic number: switch (encoding.CodePage) {  				case 65000: // UTF-7  				case 65001: // UTF-8  				case 1200: // UTF-16 LE  				case 1201: // UTF-16 BE  				case 12000: // UTF-32 LE  				case 12001: // UTF-32 BE  					return true;  				default:  					return false;  			}
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Utils\FileReader.cs,IsUnicode,The following statement contains a magic number: switch (encoding.CodePage) {  				case 65000: // UTF-7  				case 65001: // UTF-8  				case 1200: // UTF-16 LE  				case 1201: // UTF-16 BE  				case 12000: // UTF-32 LE  				case 12001: // UTF-32 BE  					return true;  				default:  					return false;  			}
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Utils\FileReader.cs,OpenStream,The following statement contains a magic number: if (stream.Length >= 2) {  				// the autodetection of StreamReader is not capable of detecting the difference  				// between ISO-8859-1 and UTF-8 without BOM.  				int firstByte = stream.ReadByte();  				int secondByte = stream.ReadByte();  				switch ((firstByte << 8) | secondByte) {  					case 0x0000: // either UTF-32 Big Endian or a binary file; use StreamReader  					case 0xfffe: // Unicode BOM (UTF-16 LE or UTF-32 LE)  					case 0xfeff: // UTF-16 BE BOM  					case 0xefbb: // start of UTF-8 BOM  						// StreamReader autodetection works  						stream.Position = 0;  						return new StreamReader(stream);  					default:  						return AutoDetect(stream' (byte)firstByte' (byte)secondByte' defaultEncoding);  				}  			} else {  				if (defaultEncoding != null) {  					return new StreamReader(stream' defaultEncoding);  				} else {  					return new StreamReader(stream);  				}  			}
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Utils\FileReader.cs,OpenStream,The following statement contains a magic number: if (stream.Length >= 2) {  				// the autodetection of StreamReader is not capable of detecting the difference  				// between ISO-8859-1 and UTF-8 without BOM.  				int firstByte = stream.ReadByte();  				int secondByte = stream.ReadByte();  				switch ((firstByte << 8) | secondByte) {  					case 0x0000: // either UTF-32 Big Endian or a binary file; use StreamReader  					case 0xfffe: // Unicode BOM (UTF-16 LE or UTF-32 LE)  					case 0xfeff: // UTF-16 BE BOM  					case 0xefbb: // start of UTF-8 BOM  						// StreamReader autodetection works  						stream.Position = 0;  						return new StreamReader(stream);  					default:  						return AutoDetect(stream' (byte)firstByte' (byte)secondByte' defaultEncoding);  				}  			} else {  				if (defaultEncoding != null) {  					return new StreamReader(stream' defaultEncoding);  				} else {  					return new StreamReader(stream);  				}  			}
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Utils\FileReader.cs,AutoDetect,The following statement contains a magic number: int max = (int)Math.Min(fs.Length' 500000);
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Utils\FileReader.cs,AutoDetect,The following statement contains a magic number: const int UTF8  = 2;
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Utils\FileReader.cs,AutoDetect,The following statement contains a magic number: const int UTF8Sequence = 3;
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Utils\FileReader.cs,AutoDetect,The following statement contains a magic number: for (int i = 0; i < max; i++) {  				if (i == 0) {  					b = firstByte;  				} else if (i == 1) {  					b = secondByte;  				} else {  					b = (byte)fs.ReadByte();  				}  				if (b < 0x80) {  					// normal ASCII character  					if (state == UTF8Sequence) {  						state = Error;  						break;  					}  				} else if (b < 0xc0) {  					// 10xxxxxx : continues UTF8 byte sequence  					if (state == UTF8Sequence) {  						--sequenceLength;  						if (sequenceLength < 0) {  							state = Error;  							break;  						} else if (sequenceLength == 0) {  							state = UTF8;  						}  					} else {  						state = Error;  						break;  					}  				} else if (b >= 0xc2 && b < 0xf5) {  					// beginning of byte sequence  					if (state == UTF8 || state == ASCII) {  						state = UTF8Sequence;  						if (b < 0xe0) {  							sequenceLength = 1; // one more byte following  						} else if (b < 0xf0) {  							sequenceLength = 2; // two more bytes following  						} else {  							sequenceLength = 3; // three more bytes following  						}  					} else {  						state = Error;  						break;  					}  				} else {  					// 0xc0' 0xc1' 0xf5 to 0xff are invalid in UTF-8 (see RFC 3629)  					state = Error;  					break;  				}  			}
Magic Number,ICSharpCode.AvalonEdit.Utils,FileReader,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Utils\FileReader.cs,AutoDetect,The following statement contains a magic number: for (int i = 0; i < max; i++) {  				if (i == 0) {  					b = firstByte;  				} else if (i == 1) {  					b = secondByte;  				} else {  					b = (byte)fs.ReadByte();  				}  				if (b < 0x80) {  					// normal ASCII character  					if (state == UTF8Sequence) {  						state = Error;  						break;  					}  				} else if (b < 0xc0) {  					// 10xxxxxx : continues UTF8 byte sequence  					if (state == UTF8Sequence) {  						--sequenceLength;  						if (sequenceLength < 0) {  							state = Error;  							break;  						} else if (sequenceLength == 0) {  							state = UTF8;  						}  					} else {  						state = Error;  						break;  					}  				} else if (b >= 0xc2 && b < 0xf5) {  					// beginning of byte sequence  					if (state == UTF8 || state == ASCII) {  						state = UTF8Sequence;  						if (b < 0xe0) {  							sequenceLength = 1; // one more byte following  						} else if (b < 0xf0) {  							sequenceLength = 2; // two more bytes following  						} else {  							sequenceLength = 3; // three more bytes following  						}  					} else {  						state = Error;  						break;  					}  				} else {  					// 0xc0' 0xc1' 0xf5 to 0xff are invalid in UTF-8 (see RFC 3629)  					state = Error;  					break;  				}  			}
Magic Number,ICSharpCode.AvalonEdit.Utils,RopeNode<T>,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Utils\RopeNode.cs,CreateNodes,The following statement contains a magic number: if (leafCount == 1) {  				result.contents = new T[NodeSize];  			} else {  				int rightSide = leafCount / 2;  				int leftSide = leafCount - rightSide;  				int leftLength = leftSide * NodeSize;  				result.left = CreateNodes(leftSide' leftLength);  				result.right = CreateNodes(rightSide' totalLength - leftLength);  				result.height = (byte)(1 + Math.Max(result.left.height' result.right.height));  			}
Magic Number,ICSharpCode.AvalonEdit.Utils,RopeNode<T>,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Utils\RopeNode.cs,AppendTreeToString,The following statement contains a magic number: indent += 2;
Magic Number,ICSharpCode.AvalonEdit.Utils,FunctionNode<T>,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Utils\RopeNode.cs,AppendTreeToString,The following statement contains a magic number: indent += 2;
Magic Number,ICSharpCode.AvalonEdit.Utils,PixelSnapHelpers,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Utils\PixelSnapHelpers.cs,PixelAlign,The following statement contains a magic number: return pixelSize * (Math.Round((value / pixelSize) + 0.5) - 0.5);
Magic Number,ICSharpCode.AvalonEdit.Utils,PixelSnapHelpers,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Utils\PixelSnapHelpers.cs,PixelAlign,The following statement contains a magic number: return pixelSize * (Math.Round((value / pixelSize) + 0.5) - 0.5);
Magic Number,ICSharpCode.AvalonEdit.Utils,PixelSnapHelpers,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Utils\PixelSnapHelpers.cs,RoundToOdd,The following statement contains a magic number: return Round(value - pixelSize' pixelSize * 2) + pixelSize;
Magic Number,ICSharpCode.AvalonEdit.Xml,AXmlObject,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Xml\AXmlObject.cs,ToString,The following statement contains a magic number: return string.Format(CultureInfo.InvariantCulture' "{0}({1}-{2})"' this.GetType().Name.Remove(0' 4)' this.StartOffset' this.EndOffset);
Magic Number,ICSharpCode.AvalonEdit.Xml,TagMatchingHeuristics,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Xml\TagMatchingHeuristics.cs,ReadDocument,The following statement contains a magic number: foreach(AXmlTag xmlDeclaration in doc.Children.OfType<AXmlTag>().Where(t => t.IsProcessingInstruction && string.Equals(t.Name' "xml"' StringComparison.OrdinalIgnoreCase))) {  				if (xmlDeclaration.StartOffset != 0)  					TagReader.OnSyntaxError(doc' xmlDeclaration.StartOffset' xmlDeclaration.StartOffset + 5'  					                        "XML declaration must be at the start of document");  			}
Magic Number,ICSharpCode.AvalonEdit.Xml,TagMatchingHeuristics,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Xml\TagMatchingHeuristics.cs,ReadElement,The following statement contains a magic number: if (startTag == StartTagPlaceholder || // Check first in case the start tag is null  			    element.StartTag.IsStartTag)  			{  				while(true) {  					AXmlTag currTag = objStream.Current as AXmlTag; // Peek  					if (currTag == EndTagPlaceholder) {  						TagReader.OnSyntaxError(element' element.LastChild.EndOffset' element.LastChild.EndOffset'  						                        "Expected '</{0}>'"' element.StartTag.Name);  						ReadSingleObject(objStream);  						element.HasEndTag = false;  						element.IsProperlyNested = false;  						break;  					} else if (currTag != null && currTag.IsEndTag) {  						if (element.HasStartOrEmptyTag && currTag.Name != element.StartTag.Name) {  							TagReader.OnSyntaxError(element' currTag.StartOffset + 2' currTag.StartOffset + 2 + currTag.Name.Length'  							                        "Expected '{0}'.  End tag must have same name as start tag."' element.StartTag.Name);  						}  						element.AddChild(ReadSingleObject(objStream));  						element.HasEndTag = true;  						break;  					}  					AXmlObject nested = ReadTextOrElement(objStream);  					  					AXmlElement nestedAsElement = nested as AXmlElement;  					if (nestedAsElement != null) {  						if (!nestedAsElement.IsProperlyNested)  							element.IsProperlyNested = false;  						element.AddChildren(Split(nestedAsElement).ToList());  					} else {  						element.AddChild(nested);  					}  				}  			} else {  				element.HasEndTag = false;  			}
Magic Number,ICSharpCode.AvalonEdit.Xml,TagMatchingHeuristics,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Xml\TagMatchingHeuristics.cs,ReadElement,The following statement contains a magic number: if (startTag == StartTagPlaceholder || // Check first in case the start tag is null  			    element.StartTag.IsStartTag)  			{  				while(true) {  					AXmlTag currTag = objStream.Current as AXmlTag; // Peek  					if (currTag == EndTagPlaceholder) {  						TagReader.OnSyntaxError(element' element.LastChild.EndOffset' element.LastChild.EndOffset'  						                        "Expected '</{0}>'"' element.StartTag.Name);  						ReadSingleObject(objStream);  						element.HasEndTag = false;  						element.IsProperlyNested = false;  						break;  					} else if (currTag != null && currTag.IsEndTag) {  						if (element.HasStartOrEmptyTag && currTag.Name != element.StartTag.Name) {  							TagReader.OnSyntaxError(element' currTag.StartOffset + 2' currTag.StartOffset + 2 + currTag.Name.Length'  							                        "Expected '{0}'.  End tag must have same name as start tag."' element.StartTag.Name);  						}  						element.AddChild(ReadSingleObject(objStream));  						element.HasEndTag = true;  						break;  					}  					AXmlObject nested = ReadTextOrElement(objStream);  					  					AXmlElement nestedAsElement = nested as AXmlElement;  					if (nestedAsElement != null) {  						if (!nestedAsElement.IsProperlyNested)  							element.IsProperlyNested = false;  						element.AddChildren(Split(nestedAsElement).ToList());  					} else {  						element.AddChild(nested);  					}  				}  			} else {  				element.HasEndTag = false;  			}
Magic Number,ICSharpCode.AvalonEdit.Xml,TagMatchingHeuristics,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Xml\TagMatchingHeuristics.cs,GetIndentLevel,The following statement contains a magic number: while(true) {  				if (offset < 0) break;  				char c = input[offset];  				if (c == ' ') {  					level++;  				} else if (c == '\t') {  					level += 4;  				} else if (c == '\r' || c == '\n') {  					break;  				} else {  					return -1;  				}  				offset--;  			}
Magic Number,ICSharpCode.AvalonEdit.Xml,TagReader,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Xml\TagReader.cs,ReadOpeningBracket,The following statement contains a magic number: if (TryRead('<')) {  				if (TryRead('/')) {  					return "</";  				} else if (TryRead('?')) {  					return "<?";  				} else if (TryRead('!')) {  					if (TryRead("--")) {  						return "<!--";  					} else if (TryRead("[CDATA[")) {  						return "<![CDATA[";  					} else {  						foreach(string dtdName in AXmlTag.DtdNames) {  							// the dtdName includes "<!"  							if (TryRead(dtdName.Remove(0' 2))) return dtdName;  						}  						return "<!";  					}  				} else {  					return "<";  				}  			} else {  				throw new InternalException("'<' expected");  			}
Magic Number,ICSharpCode.AvalonEdit.Xml,TagReader,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Xml\TagReader.cs,ReadAttribulte,The following statement contains a magic number: if (TryRead(quoteChar)) {  				startsWithQuote = true;  				int valueStart = this.CurrentLocation;  				TryMoveToAnyOf(quoteChar' '<');  				if (TryRead(quoteChar)) {  					if (!TryPeekAnyOf(' '' '\t'' '\n'' '\r'' '/'' '>'' '?')) {  						if (TryPeekPrevious('='' 2) || (TryPeekPrevious('='' 3) && TryPeekPrevious(' '' 2))) {  							// This actually most likely means that we are in the next attribute value  							GoBack(valueStart);  							ReadAttributeValue(quoteChar);  							if (TryRead(quoteChar)) {  								OnSyntaxError(attr' "White space or end of tag expected");  							} else {  								OnSyntaxError(attr' "Quote {0} expected (or add whitespace after the following one)"' quoteChar);  							}  						} else {  							OnSyntaxError(attr' "White space or end of tag expected");  						}  					}  				} else {  					// '<' or end of file  					GoBack(valueStart);  					ReadAttributeValue(quoteChar);  					OnSyntaxError(attr' "Quote {0} expected"' quoteChar);  				}  			} else {  				startsWithQuote = false;  				int valueStart = this.CurrentLocation;  				ReadAttributeValue(null);  				TryRead('\"');  				TryRead('\'');  				if (valueStart == this.CurrentLocation) {  					OnSyntaxError(attr' "Attribute value expected");  				} else {  					OnSyntaxError(attr' valueStart' this.CurrentLocation' "Attribute value must be quoted");  				}  			}
Magic Number,ICSharpCode.AvalonEdit.Xml,TagReader,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Xml\TagReader.cs,ReadAttribulte,The following statement contains a magic number: if (TryRead(quoteChar)) {  				startsWithQuote = true;  				int valueStart = this.CurrentLocation;  				TryMoveToAnyOf(quoteChar' '<');  				if (TryRead(quoteChar)) {  					if (!TryPeekAnyOf(' '' '\t'' '\n'' '\r'' '/'' '>'' '?')) {  						if (TryPeekPrevious('='' 2) || (TryPeekPrevious('='' 3) && TryPeekPrevious(' '' 2))) {  							// This actually most likely means that we are in the next attribute value  							GoBack(valueStart);  							ReadAttributeValue(quoteChar);  							if (TryRead(quoteChar)) {  								OnSyntaxError(attr' "White space or end of tag expected");  							} else {  								OnSyntaxError(attr' "Quote {0} expected (or add whitespace after the following one)"' quoteChar);  							}  						} else {  							OnSyntaxError(attr' "White space or end of tag expected");  						}  					}  				} else {  					// '<' or end of file  					GoBack(valueStart);  					ReadAttributeValue(quoteChar);  					OnSyntaxError(attr' "Quote {0} expected"' quoteChar);  				}  			} else {  				startsWithQuote = false;  				int valueStart = this.CurrentLocation;  				ReadAttributeValue(null);  				TryRead('\"');  				TryRead('\'');  				if (valueStart == this.CurrentLocation) {  					OnSyntaxError(attr' "Attribute value expected");  				} else {  					OnSyntaxError(attr' valueStart' this.CurrentLocation' "Attribute value must be quoted");  				}  			}
Magic Number,ICSharpCode.AvalonEdit.Xml,TagReader,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Xml\TagReader.cs,ReadAttribulte,The following statement contains a magic number: if (TryRead(quoteChar)) {  				startsWithQuote = true;  				int valueStart = this.CurrentLocation;  				TryMoveToAnyOf(quoteChar' '<');  				if (TryRead(quoteChar)) {  					if (!TryPeekAnyOf(' '' '\t'' '\n'' '\r'' '/'' '>'' '?')) {  						if (TryPeekPrevious('='' 2) || (TryPeekPrevious('='' 3) && TryPeekPrevious(' '' 2))) {  							// This actually most likely means that we are in the next attribute value  							GoBack(valueStart);  							ReadAttributeValue(quoteChar);  							if (TryRead(quoteChar)) {  								OnSyntaxError(attr' "White space or end of tag expected");  							} else {  								OnSyntaxError(attr' "Quote {0} expected (or add whitespace after the following one)"' quoteChar);  							}  						} else {  							OnSyntaxError(attr' "White space or end of tag expected");  						}  					}  				} else {  					// '<' or end of file  					GoBack(valueStart);  					ReadAttributeValue(quoteChar);  					OnSyntaxError(attr' "Quote {0} expected"' quoteChar);  				}  			} else {  				startsWithQuote = false;  				int valueStart = this.CurrentLocation;  				ReadAttributeValue(null);  				TryRead('\"');  				TryRead('\'');  				if (valueStart == this.CurrentLocation) {  					OnSyntaxError(attr' "Attribute value expected");  				} else {  					OnSyntaxError(attr' valueStart' this.CurrentLocation' "Attribute value must be quoted");  				}  			}
Magic Number,ICSharpCode.AvalonEdit.Xml,TagReader,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Xml\TagReader.cs,ReadText,The following statement contains a magic number: while(true) {  				AXmlText text;  				if (TryReadFromCacheOrNew(out text' t => t.Type == type)) {  					// Cached text found  					yield return text;  					continue; // Read next fragment;  the method can handle "no text left"  				}  				text.Type = type;  				  				// Limit the reading to just a few characters  				// (the first character not to be read)  				int fragmentEnd = Math.Min(this.CurrentLocation + maxTextFragmentSize' this.InputLength);  				  				// Look if some futher text has been already processed and align so that  				// we hit that chache point.  It is expensive so it is off for the first run  				if (lookahead) {  					// Note: Must fit entity  					AXmlObject nextFragment = trackedSegments.GetCachedObject<AXmlText>(this.CurrentLocation + maxEntityLength' lookAheadLength - maxEntityLength' t => t.Type == type);  					if (nextFragment != null) {  						fragmentEnd = Math.Min(nextFragment.StartOffset' this.InputLength);  						AXmlParser.Log("Parsing only text ({0}-{1}) because later text was already processed"' this.CurrentLocation' fragmentEnd);  					}  				}  				lookahead = true;  				  				text.StartOffset = this.CurrentLocation;  				int start = this.CurrentLocation;  				  				// Whitespace would be skipped anyway by any operation  				TryMoveToNonWhiteSpace(fragmentEnd);  				int wsEnd = this.CurrentLocation;  				  				// Try move to the terminator given by the context  				if (type == TextType.WhiteSpace) {  					TryMoveToNonWhiteSpace(fragmentEnd);  				} else if (type == TextType.CharacterData) {  					while(true) {  						if (!TryMoveToAnyOf(new char[] {'<'' ']'}' fragmentEnd)) break; // End of fragment  						if (TryPeek('<')) break;  						if (TryPeek(']')) {  							if (TryPeek("]]>")) {  								OnSyntaxError(text' this.CurrentLocation' this.CurrentLocation + 3' "']]>' is not allowed in text");  							}  							TryMoveNext();  							continue;  						}  						throw new Exception("Infinite loop");  					}  				} else 	if (type == TextType.Comment) {  					// Do not report too many errors  					bool errorReported = false;  					while(true) {  						if (!TryMoveTo('-'' fragmentEnd)) break; // End of fragment  						if (TryPeek("-->")) break;  						if (TryPeek("--") && !errorReported) {  							OnSyntaxError(text' this.CurrentLocation' this.CurrentLocation + 2' "'--' is not allowed in comment");  							errorReported = true;  						}  						TryMoveNext();  					}  				} else if (type == TextType.CData) {  					while(true) {  						// We can not use use TryMoveTo("]]>"' fragmentEnd) because it may incorectly accept "]" at the end of fragment  						if (!TryMoveTo(']'' fragmentEnd)) break; // End of fragment  						if (TryPeek("]]>")) break;  						TryMoveNext();  					}  				} else if (type == TextType.ProcessingInstruction) {  					while(true) {  						if (!TryMoveTo('?'' fragmentEnd)) break; // End of fragment  						if (TryPeek("?>")) break;  						TryMoveNext();  					}  				} else if (type == TextType.UnknownBang) {  					TryMoveToAnyOf(new char[] {'<'' '>'}' fragmentEnd);  				} else {  					throw new Exception("Uknown type " + type);  				}  				  				text.ContainsOnlyWhitespace = (wsEnd == this.CurrentLocation);  				  				// Terminal found or real end was reached;  				bool finished = this.CurrentLocation < fragmentEnd || IsEndOfFile();  				  				if (!finished) {  					// We have to continue reading more text fragments  					  					// If there is entity reference' make sure the next segment starts with it to prevent framentation  					int entitySearchStart = Math.Max(start + 1 /* data for us */' this.CurrentLocation - maxEntityLength);  					int entitySearchLength = this.CurrentLocation - entitySearchStart;  					if (entitySearchLength > 0) {  						// Note that LastIndexOf works backward  						int entityIndex = input.LastIndexOf('&'' this.CurrentLocation - 1' entitySearchLength);  						if (entityIndex != -1) {  							GoBack(entityIndex);  						}  					}  				}  				  				text.EscapedValue = GetText(start' this.CurrentLocation);  				if (type == TextType.CharacterData) {  					// Normalize end of line first  					text.Value = Dereference(text' NormalizeEndOfLine(text.EscapedValue)' start);  				} else {  					text.Value = text.EscapedValue;  				}  				text.EndOffset = this.CurrentLocation;  				  				if (text.EscapedValue.Length > 0) {  					OnParsed(text);  					yield return text;  				}  				  				if (finished) {  					yield break;  				}  			}
Magic Number,ICSharpCode.AvalonEdit.Xml,TagReader,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Xml\TagReader.cs,ReadText,The following statement contains a magic number: while(true) {  				AXmlText text;  				if (TryReadFromCacheOrNew(out text' t => t.Type == type)) {  					// Cached text found  					yield return text;  					continue; // Read next fragment;  the method can handle "no text left"  				}  				text.Type = type;  				  				// Limit the reading to just a few characters  				// (the first character not to be read)  				int fragmentEnd = Math.Min(this.CurrentLocation + maxTextFragmentSize' this.InputLength);  				  				// Look if some futher text has been already processed and align so that  				// we hit that chache point.  It is expensive so it is off for the first run  				if (lookahead) {  					// Note: Must fit entity  					AXmlObject nextFragment = trackedSegments.GetCachedObject<AXmlText>(this.CurrentLocation + maxEntityLength' lookAheadLength - maxEntityLength' t => t.Type == type);  					if (nextFragment != null) {  						fragmentEnd = Math.Min(nextFragment.StartOffset' this.InputLength);  						AXmlParser.Log("Parsing only text ({0}-{1}) because later text was already processed"' this.CurrentLocation' fragmentEnd);  					}  				}  				lookahead = true;  				  				text.StartOffset = this.CurrentLocation;  				int start = this.CurrentLocation;  				  				// Whitespace would be skipped anyway by any operation  				TryMoveToNonWhiteSpace(fragmentEnd);  				int wsEnd = this.CurrentLocation;  				  				// Try move to the terminator given by the context  				if (type == TextType.WhiteSpace) {  					TryMoveToNonWhiteSpace(fragmentEnd);  				} else if (type == TextType.CharacterData) {  					while(true) {  						if (!TryMoveToAnyOf(new char[] {'<'' ']'}' fragmentEnd)) break; // End of fragment  						if (TryPeek('<')) break;  						if (TryPeek(']')) {  							if (TryPeek("]]>")) {  								OnSyntaxError(text' this.CurrentLocation' this.CurrentLocation + 3' "']]>' is not allowed in text");  							}  							TryMoveNext();  							continue;  						}  						throw new Exception("Infinite loop");  					}  				} else 	if (type == TextType.Comment) {  					// Do not report too many errors  					bool errorReported = false;  					while(true) {  						if (!TryMoveTo('-'' fragmentEnd)) break; // End of fragment  						if (TryPeek("-->")) break;  						if (TryPeek("--") && !errorReported) {  							OnSyntaxError(text' this.CurrentLocation' this.CurrentLocation + 2' "'--' is not allowed in comment");  							errorReported = true;  						}  						TryMoveNext();  					}  				} else if (type == TextType.CData) {  					while(true) {  						// We can not use use TryMoveTo("]]>"' fragmentEnd) because it may incorectly accept "]" at the end of fragment  						if (!TryMoveTo(']'' fragmentEnd)) break; // End of fragment  						if (TryPeek("]]>")) break;  						TryMoveNext();  					}  				} else if (type == TextType.ProcessingInstruction) {  					while(true) {  						if (!TryMoveTo('?'' fragmentEnd)) break; // End of fragment  						if (TryPeek("?>")) break;  						TryMoveNext();  					}  				} else if (type == TextType.UnknownBang) {  					TryMoveToAnyOf(new char[] {'<'' '>'}' fragmentEnd);  				} else {  					throw new Exception("Uknown type " + type);  				}  				  				text.ContainsOnlyWhitespace = (wsEnd == this.CurrentLocation);  				  				// Terminal found or real end was reached;  				bool finished = this.CurrentLocation < fragmentEnd || IsEndOfFile();  				  				if (!finished) {  					// We have to continue reading more text fragments  					  					// If there is entity reference' make sure the next segment starts with it to prevent framentation  					int entitySearchStart = Math.Max(start + 1 /* data for us */' this.CurrentLocation - maxEntityLength);  					int entitySearchLength = this.CurrentLocation - entitySearchStart;  					if (entitySearchLength > 0) {  						// Note that LastIndexOf works backward  						int entityIndex = input.LastIndexOf('&'' this.CurrentLocation - 1' entitySearchLength);  						if (entityIndex != -1) {  							GoBack(entityIndex);  						}  					}  				}  				  				text.EscapedValue = GetText(start' this.CurrentLocation);  				if (type == TextType.CharacterData) {  					// Normalize end of line first  					text.Value = Dereference(text' NormalizeEndOfLine(text.EscapedValue)' start);  				} else {  					text.Value = text.EscapedValue;  				}  				text.EndOffset = this.CurrentLocation;  				  				if (text.EscapedValue.Length > 0) {  					OnParsed(text);  					yield return text;  				}  				  				if (finished) {  					yield break;  				}  			}
Magic Number,ICSharpCode.AvalonEdit.Xml,TagReader,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Xml\TagReader.cs,Unquote,The following statement contains a magic number: if (first == '"' || first == '\'') {  				if (first == last) {  					// Remove both quotes  					return quoted.Substring(1' quoted.Length - 2);  				} else {  					// Remove first quote  					return quoted.Remove(0' 1);  				}  			} else {  				if (last == '"' || last == '\'') {  					// Remove last quote  					return quoted.Substring(0' quoted.Length - 1);  				} else {  					// Keep whole string  					return quoted;  				}  			}
Magic Number,ICSharpCode.AvalonEdit.Xml,TagReader,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Xml\TagReader.cs,Dereference,The following statement contains a magic number: while(true) {  				// Reached end of input  				if (curr == text.Length) {  					if (sb != null) {  						return sb.ToString();  					} else {  						return text;  					}  				}  				  				// Try to find reference  				int start = text.IndexOf('&'' curr);  				  				// No more references found  				if (start == -1) {  					if (sb != null) {  						sb.Append(text' curr' text.Length - curr); // Add rest  						return sb.ToString();  					} else {  						return text;  					}  				}  				  				// Append text before the enitiy reference  				if (sb == null) sb = new StringBuilder(text.Length);  				sb.Append(text' curr' start - curr);  				curr = start;  				  				// Process the entity  				int errorLoc = textLocation + sb.Length;  				            				// Find entity name  				int end = text.IndexOfAny(new char[] {'&'' ';'}' start + 1' Math.Min(maxEntityLength' text.Length - (start + 1)));  				if (end == -1 || text[end] == '&') {  					// Not found  					OnSyntaxError(owner' errorLoc' errorLoc + 1' "Entity reference must be terminated with ';'");  					// Keep '&'  					sb.Append('&');  					curr++;  					continue;  // Restart and next character location  				}  				string name = text.Substring(start + 1' end - (start + 1));  				  				// Resolve the name  				string replacement;  				if (name.Length == 0) {  					replacement = null;  					OnSyntaxError(owner' errorLoc + 1' errorLoc + 1' "Entity name expected");  				} else if (name == "amp") {  					replacement = "&";  				} else if (name == "lt") {  					replacement = "<";  				} else if (name == "gt") {  					replacement = ">";  				} else if (name == "apos") {  					replacement = "'";  				} else if (name == "quot") {  					replacement = "\"";  				} else if (name.Length > 0 && name[0] == '#') {  					int num;  					if (name.Length > 1 && name[1] == 'x') {  						if (!int.TryParse(name.Substring(2)' NumberStyles.AllowHexSpecifier' CultureInfo.InvariantCulture.NumberFormat' out num)) {  							num = -1;  							OnSyntaxError(owner' errorLoc + 3' errorLoc + 1 + name.Length' "Hexadecimal code of unicode character expected");  						}  					} else {  						if (!int.TryParse(name.Substring(1)' NumberStyles.None' CultureInfo.InvariantCulture.NumberFormat' out num)) {  							num = -1;  							OnSyntaxError(owner' errorLoc + 2' errorLoc + 1 + name.Length' "Numeric code of unicode character expected");  						}  					}  					if (num != -1) {  						try {  							replacement = char.ConvertFromUtf32(num);  						} catch (ArgumentOutOfRangeException) {  							replacement = null;  							OnSyntaxError(owner' errorLoc + 2' errorLoc + 1 + name.Length' "Invalid unicode character U+{0:X} ({0})"' num);  						}  					} else {  						replacement = null;  					}  				} else if (!IsValidName(name)) {  					replacement = null;  					OnSyntaxError(owner' errorLoc + 1' errorLoc + 1' "Invalid entity name");  				} else {  					replacement = null;  					if (parser.UnknownEntityReferenceIsError) {  						OnSyntaxError(owner' errorLoc' errorLoc + 1 + name.Length + 1' "Unknown entity reference '{0}'"' name);  					}  				}  				  				// Append the replacement to output  				if (replacement != null) {  					sb.Append(replacement);  				} else {  					sb.Append('&');  					sb.Append(name);  					sb.Append(';');  				}  				curr = end + 1;  				continue;  			}
Magic Number,ICSharpCode.AvalonEdit.Xml,TagReader,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Xml\TagReader.cs,Dereference,The following statement contains a magic number: while(true) {  				// Reached end of input  				if (curr == text.Length) {  					if (sb != null) {  						return sb.ToString();  					} else {  						return text;  					}  				}  				  				// Try to find reference  				int start = text.IndexOf('&'' curr);  				  				// No more references found  				if (start == -1) {  					if (sb != null) {  						sb.Append(text' curr' text.Length - curr); // Add rest  						return sb.ToString();  					} else {  						return text;  					}  				}  				  				// Append text before the enitiy reference  				if (sb == null) sb = new StringBuilder(text.Length);  				sb.Append(text' curr' start - curr);  				curr = start;  				  				// Process the entity  				int errorLoc = textLocation + sb.Length;  				            				// Find entity name  				int end = text.IndexOfAny(new char[] {'&'' ';'}' start + 1' Math.Min(maxEntityLength' text.Length - (start + 1)));  				if (end == -1 || text[end] == '&') {  					// Not found  					OnSyntaxError(owner' errorLoc' errorLoc + 1' "Entity reference must be terminated with ';'");  					// Keep '&'  					sb.Append('&');  					curr++;  					continue;  // Restart and next character location  				}  				string name = text.Substring(start + 1' end - (start + 1));  				  				// Resolve the name  				string replacement;  				if (name.Length == 0) {  					replacement = null;  					OnSyntaxError(owner' errorLoc + 1' errorLoc + 1' "Entity name expected");  				} else if (name == "amp") {  					replacement = "&";  				} else if (name == "lt") {  					replacement = "<";  				} else if (name == "gt") {  					replacement = ">";  				} else if (name == "apos") {  					replacement = "'";  				} else if (name == "quot") {  					replacement = "\"";  				} else if (name.Length > 0 && name[0] == '#') {  					int num;  					if (name.Length > 1 && name[1] == 'x') {  						if (!int.TryParse(name.Substring(2)' NumberStyles.AllowHexSpecifier' CultureInfo.InvariantCulture.NumberFormat' out num)) {  							num = -1;  							OnSyntaxError(owner' errorLoc + 3' errorLoc + 1 + name.Length' "Hexadecimal code of unicode character expected");  						}  					} else {  						if (!int.TryParse(name.Substring(1)' NumberStyles.None' CultureInfo.InvariantCulture.NumberFormat' out num)) {  							num = -1;  							OnSyntaxError(owner' errorLoc + 2' errorLoc + 1 + name.Length' "Numeric code of unicode character expected");  						}  					}  					if (num != -1) {  						try {  							replacement = char.ConvertFromUtf32(num);  						} catch (ArgumentOutOfRangeException) {  							replacement = null;  							OnSyntaxError(owner' errorLoc + 2' errorLoc + 1 + name.Length' "Invalid unicode character U+{0:X} ({0})"' num);  						}  					} else {  						replacement = null;  					}  				} else if (!IsValidName(name)) {  					replacement = null;  					OnSyntaxError(owner' errorLoc + 1' errorLoc + 1' "Invalid entity name");  				} else {  					replacement = null;  					if (parser.UnknownEntityReferenceIsError) {  						OnSyntaxError(owner' errorLoc' errorLoc + 1 + name.Length + 1' "Unknown entity reference '{0}'"' name);  					}  				}  				  				// Append the replacement to output  				if (replacement != null) {  					sb.Append(replacement);  				} else {  					sb.Append('&');  					sb.Append(name);  					sb.Append(';');  				}  				curr = end + 1;  				continue;  			}
Magic Number,ICSharpCode.AvalonEdit.Xml,TagReader,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Xml\TagReader.cs,Dereference,The following statement contains a magic number: while(true) {  				// Reached end of input  				if (curr == text.Length) {  					if (sb != null) {  						return sb.ToString();  					} else {  						return text;  					}  				}  				  				// Try to find reference  				int start = text.IndexOf('&'' curr);  				  				// No more references found  				if (start == -1) {  					if (sb != null) {  						sb.Append(text' curr' text.Length - curr); // Add rest  						return sb.ToString();  					} else {  						return text;  					}  				}  				  				// Append text before the enitiy reference  				if (sb == null) sb = new StringBuilder(text.Length);  				sb.Append(text' curr' start - curr);  				curr = start;  				  				// Process the entity  				int errorLoc = textLocation + sb.Length;  				            				// Find entity name  				int end = text.IndexOfAny(new char[] {'&'' ';'}' start + 1' Math.Min(maxEntityLength' text.Length - (start + 1)));  				if (end == -1 || text[end] == '&') {  					// Not found  					OnSyntaxError(owner' errorLoc' errorLoc + 1' "Entity reference must be terminated with ';'");  					// Keep '&'  					sb.Append('&');  					curr++;  					continue;  // Restart and next character location  				}  				string name = text.Substring(start + 1' end - (start + 1));  				  				// Resolve the name  				string replacement;  				if (name.Length == 0) {  					replacement = null;  					OnSyntaxError(owner' errorLoc + 1' errorLoc + 1' "Entity name expected");  				} else if (name == "amp") {  					replacement = "&";  				} else if (name == "lt") {  					replacement = "<";  				} else if (name == "gt") {  					replacement = ">";  				} else if (name == "apos") {  					replacement = "'";  				} else if (name == "quot") {  					replacement = "\"";  				} else if (name.Length > 0 && name[0] == '#') {  					int num;  					if (name.Length > 1 && name[1] == 'x') {  						if (!int.TryParse(name.Substring(2)' NumberStyles.AllowHexSpecifier' CultureInfo.InvariantCulture.NumberFormat' out num)) {  							num = -1;  							OnSyntaxError(owner' errorLoc + 3' errorLoc + 1 + name.Length' "Hexadecimal code of unicode character expected");  						}  					} else {  						if (!int.TryParse(name.Substring(1)' NumberStyles.None' CultureInfo.InvariantCulture.NumberFormat' out num)) {  							num = -1;  							OnSyntaxError(owner' errorLoc + 2' errorLoc + 1 + name.Length' "Numeric code of unicode character expected");  						}  					}  					if (num != -1) {  						try {  							replacement = char.ConvertFromUtf32(num);  						} catch (ArgumentOutOfRangeException) {  							replacement = null;  							OnSyntaxError(owner' errorLoc + 2' errorLoc + 1 + name.Length' "Invalid unicode character U+{0:X} ({0})"' num);  						}  					} else {  						replacement = null;  					}  				} else if (!IsValidName(name)) {  					replacement = null;  					OnSyntaxError(owner' errorLoc + 1' errorLoc + 1' "Invalid entity name");  				} else {  					replacement = null;  					if (parser.UnknownEntityReferenceIsError) {  						OnSyntaxError(owner' errorLoc' errorLoc + 1 + name.Length + 1' "Unknown entity reference '{0}'"' name);  					}  				}  				  				// Append the replacement to output  				if (replacement != null) {  					sb.Append(replacement);  				} else {  					sb.Append('&');  					sb.Append(name);  					sb.Append(';');  				}  				curr = end + 1;  				continue;  			}
Magic Number,ICSharpCode.AvalonEdit.Xml,TagReader,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Xml\TagReader.cs,Dereference,The following statement contains a magic number: while(true) {  				// Reached end of input  				if (curr == text.Length) {  					if (sb != null) {  						return sb.ToString();  					} else {  						return text;  					}  				}  				  				// Try to find reference  				int start = text.IndexOf('&'' curr);  				  				// No more references found  				if (start == -1) {  					if (sb != null) {  						sb.Append(text' curr' text.Length - curr); // Add rest  						return sb.ToString();  					} else {  						return text;  					}  				}  				  				// Append text before the enitiy reference  				if (sb == null) sb = new StringBuilder(text.Length);  				sb.Append(text' curr' start - curr);  				curr = start;  				  				// Process the entity  				int errorLoc = textLocation + sb.Length;  				            				// Find entity name  				int end = text.IndexOfAny(new char[] {'&'' ';'}' start + 1' Math.Min(maxEntityLength' text.Length - (start + 1)));  				if (end == -1 || text[end] == '&') {  					// Not found  					OnSyntaxError(owner' errorLoc' errorLoc + 1' "Entity reference must be terminated with ';'");  					// Keep '&'  					sb.Append('&');  					curr++;  					continue;  // Restart and next character location  				}  				string name = text.Substring(start + 1' end - (start + 1));  				  				// Resolve the name  				string replacement;  				if (name.Length == 0) {  					replacement = null;  					OnSyntaxError(owner' errorLoc + 1' errorLoc + 1' "Entity name expected");  				} else if (name == "amp") {  					replacement = "&";  				} else if (name == "lt") {  					replacement = "<";  				} else if (name == "gt") {  					replacement = ">";  				} else if (name == "apos") {  					replacement = "'";  				} else if (name == "quot") {  					replacement = "\"";  				} else if (name.Length > 0 && name[0] == '#') {  					int num;  					if (name.Length > 1 && name[1] == 'x') {  						if (!int.TryParse(name.Substring(2)' NumberStyles.AllowHexSpecifier' CultureInfo.InvariantCulture.NumberFormat' out num)) {  							num = -1;  							OnSyntaxError(owner' errorLoc + 3' errorLoc + 1 + name.Length' "Hexadecimal code of unicode character expected");  						}  					} else {  						if (!int.TryParse(name.Substring(1)' NumberStyles.None' CultureInfo.InvariantCulture.NumberFormat' out num)) {  							num = -1;  							OnSyntaxError(owner' errorLoc + 2' errorLoc + 1 + name.Length' "Numeric code of unicode character expected");  						}  					}  					if (num != -1) {  						try {  							replacement = char.ConvertFromUtf32(num);  						} catch (ArgumentOutOfRangeException) {  							replacement = null;  							OnSyntaxError(owner' errorLoc + 2' errorLoc + 1 + name.Length' "Invalid unicode character U+{0:X} ({0})"' num);  						}  					} else {  						replacement = null;  					}  				} else if (!IsValidName(name)) {  					replacement = null;  					OnSyntaxError(owner' errorLoc + 1' errorLoc + 1' "Invalid entity name");  				} else {  					replacement = null;  					if (parser.UnknownEntityReferenceIsError) {  						OnSyntaxError(owner' errorLoc' errorLoc + 1 + name.Length + 1' "Unknown entity reference '{0}'"' name);  					}  				}  				  				// Append the replacement to output  				if (replacement != null) {  					sb.Append(replacement);  				} else {  					sb.Append('&');  					sb.Append(name);  					sb.Append(';');  				}  				curr = end + 1;  				continue;  			}
Magic Number,ICSharpCode.AvalonEdit.Xml,TokenReader,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Xml\TokenReader.cs,GetCachedString,The following statement contains a magic number: stringCacheRequestedSize += 8 + 2 * cached.Length;
Magic Number,ICSharpCode.AvalonEdit.Xml,TokenReader,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Xml\TokenReader.cs,GetCachedString,The following statement contains a magic number: stringCacheRequestedSize += 8 + 2 * cached.Length;
Magic Number,ICSharpCode.AvalonEdit.Xml,TokenReader,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Xml\TokenReader.cs,GetCachedString,The following statement contains a magic number: if (cached.Length > 32) {  				stringCacheStoredCount += 1;  				stringCacheStoredSize += 8 + 2 * cached.Length;  				return cached;  			}
Magic Number,ICSharpCode.AvalonEdit.Xml,TokenReader,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Xml\TokenReader.cs,GetCachedString,The following statement contains a magic number: if (cached.Length > 32) {  				stringCacheStoredCount += 1;  				stringCacheStoredSize += 8 + 2 * cached.Length;  				return cached;  			}
Magic Number,ICSharpCode.AvalonEdit.Xml,TokenReader,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Xml\TokenReader.cs,GetCachedString,The following statement contains a magic number: if (cached.Length > 32) {  				stringCacheStoredCount += 1;  				stringCacheStoredSize += 8 + 2 * cached.Length;  				return cached;  			}
Magic Number,ICSharpCode.AvalonEdit.Xml,TokenReader,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Xml\TokenReader.cs,GetCachedString,The following statement contains a magic number: if (stringCache.ContainsKey(cached)) {  				// Get the instance from the cache instead  				return stringCache[cached];  			} else {  				// Add to cache  				stringCacheStoredCount += 1;  				stringCacheStoredSize += 8 + 2 * cached.Length;  				stringCache.Add(cached' cached);  				return cached;  			}
Magic Number,ICSharpCode.AvalonEdit.Xml,TokenReader,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Xml\TokenReader.cs,GetCachedString,The following statement contains a magic number: if (stringCache.ContainsKey(cached)) {  				// Get the instance from the cache instead  				return stringCache[cached];  			} else {  				// Add to cache  				stringCacheStoredCount += 1;  				stringCacheStoredSize += 8 + 2 * cached.Length;  				stringCache.Add(cached' cached);  				return cached;  			}
Magic Number,ICSharpCode.AvalonEdit.Xml,TokenReader,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Xml\TokenReader.cs,PrintStringCacheStats,The following statement contains a magic number: AXmlParser.Log("String cache: Requested {0} ({1} bytes);  Actaully stored {2} ({3} bytes); {4}% stored"' stringCacheRequestedCount' stringCacheRequestedSize' stringCacheStoredCount' stringCacheStoredSize' stringCacheRequestedSize == 0 ? 0 : stringCacheStoredSize * 100 / stringCacheRequestedSize);
Missing Default,ICSharpCode.AvalonEdit.CodeCompletion,CompletionList,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\CompletionList.cs,HandleKey,The following switch statement is missing a default case: switch (e.Key) {  				case Key.Down:  					e.Handled = true;  					listBox.SelectIndex(listBox.SelectedIndex + 1);  					break;  				case Key.Up:  					e.Handled = true;  					listBox.SelectIndex(listBox.SelectedIndex - 1);  					break;  				case Key.PageDown:  					e.Handled = true;  					listBox.SelectIndex(listBox.SelectedIndex + listBox.VisibleItemCount);  					break;  				case Key.PageUp:  					e.Handled = true;  					listBox.SelectIndex(listBox.SelectedIndex - listBox.VisibleItemCount);  					break;  				case Key.Home:  					e.Handled = true;  					listBox.SelectIndex(0);  					break;  				case Key.End:  					e.Handled = true;  					listBox.SelectIndex(listBox.Items.Count - 1);  					break;  				case Key.Tab:  				case Key.Enter:  					e.Handled = true;  					RequestInsertion(e);  					break;  			}
Missing Default,ICSharpCode.AvalonEdit.CodeCompletion,OverloadInsightWindow,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\CodeCompletion\OverloadInsightWindow.cs,OnKeyDown,The following switch statement is missing a default case: switch (e.Key) {  					case Key.Up:  						e.Handled = true;  						overloadViewer.ChangeIndex(-1);  						break;  					case Key.Down:  						e.Handled = true;  						overloadViewer.ChangeIndex(+1);  						break;  				}
Missing Default,ICSharpCode.AvalonEdit.Editing,ImeSupport,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Editing\ImeSupport.cs,WndProc,The following switch statement is missing a default case: switch (msg) {  				case ImeNativeWrapper.WM_INPUTLANGCHANGE:  					// Don't mark the message as handled; other windows  					// might want to handle it as well.  					  					// If we have a context' recreate it  					if (hwndSource != null) {  						ClearContext();  						CreateContext();  					}  					break;  				case ImeNativeWrapper.WM_IME_COMPOSITION:  					UpdateCompositionWindow();  					break;  			}
Missing Default,ICSharpCode.AvalonEdit.Folding,XmlFoldingStrategy,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Folding\XmlFoldingStrategy.cs,CreateNewFoldings,The following switch statement is missing a default case: switch (reader.NodeType) {  						case XmlNodeType.Element:  							if (!reader.IsEmptyElement) {  								XmlFoldStart newFoldStart = CreateElementFoldStart(document' reader);  								stack.Push(newFoldStart);  							}  							break;  							  						case XmlNodeType.EndElement:  							XmlFoldStart foldStart = stack.Pop();  							CreateElementFold(document' foldMarkers' reader' foldStart);  							break;  							  						case XmlNodeType.Comment:  							CreateCommentFold(document' foldMarkers' reader);  							break;  					}
Missing Default,ICSharpCode.AvalonEdit.Indentation.CSharp,IndentationReformatter,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Indentation\CSharp\IndentationReformatter.cs,Step,The following switch statement is missing a default case: switch (c) {  					case '/':  						if (blockComment && lastchar == '*')  							blockComment = false;  						if (!inString && !inChar) {  							if (!blockComment && nextchar == '/')  								lineComment = true;  							if (!lineComment && nextchar == '*')  								blockComment = true;  						}  						break;  					case '#':  						if (!(inChar || blockComment || inString))  							lineComment = true;  						break;  					case '"':  						if (!(inChar || lineComment || blockComment)) {  							inString = !inString;  							if (!inString && verbatim) {  								if (nextchar == '"') {  									escape = true; // skip escaped quote  									inString = true;  								} else {  									verbatim = false;  								}  							} else if (inString && lastchar == '@') {  								verbatim = true;  							}  						}  						break;  					case '\'':  						if (!(inString || lineComment || blockComment)) {  							inChar = !inChar;  						}  						break;  					case '\\':  						if ((inString && !verbatim) || inChar)  							escape = true; // skip next character  						break;  				}
Missing Default,ICSharpCode.AvalonEdit.Indentation.CSharp,IndentationReformatter,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Indentation\CSharp\IndentationReformatter.cs,Step,The following switch statement is missing a default case: switch (c) {  					case '{':  						block.ResetOneLineBlock();  						blocks.Push(block);  						block.StartLine = doc.LineNumber;  						if (block.LastWord == "switch") {  							block.Indent(set.IndentString + set.IndentString);  							/* oldBlock refers to the previous line' not the previous block  							 * The block we want is not available anymore because it was never pushed.  							 * } else if (oldBlock.OneLineBlock) {  							// Inside a one-line-block is another statement  							// with a full block: indent the inner full block  							// by one additional level  							block.Indent(set' set.IndentString + set.IndentString);  							block.OuterIndent += set.IndentString;  							// Indent current line if it starts with the '{' character  							if (i == 0) {  								oldBlock.InnerIndent += set.IndentString;  							}*/  						} else {  							block.Indent(set);  						}  						block.Bracket = '{';  						break;  					case '}':  						while (block.Bracket != '{') {  							if (blocks.Count == 0) break;  							block = blocks.Pop();  						}  						if (blocks.Count == 0) break;  						block = blocks.Pop();  						block.Continuation = false;  						block.ResetOneLineBlock();  						break;  					case '(':  					case '[':  						blocks.Push(block);  						if (block.StartLine == doc.LineNumber)  							block.InnerIndent = block.OuterIndent;  						else  							block.StartLine = doc.LineNumber;  						block.Indent(Repeat(set.IndentString' oldBlock.OneLineBlock) +  						             (oldBlock.Continuation ? set.IndentString : "") +  						             (i == line.Length - 1 ? set.IndentString : new String(' '' i + 1)));  						block.Bracket = c;  						break;  					case ')':  						if (blocks.Count == 0) break;  						if (block.Bracket == '(') {  							block = blocks.Pop();  							if (IsSingleStatementKeyword(block.LastWord))  								block.Continuation = false;  						}  						break;  					case ']':  						if (blocks.Count == 0) break;  						if (block.Bracket == '[')  							block = blocks.Pop();  						break;  					case ';':  					case ''':  						block.Continuation = false;  						block.ResetOneLineBlock();  						break;  					case ':':  						if (block.LastWord == "case"   						    || line.StartsWith("case "' StringComparison.Ordinal)   						    || line.StartsWith(block.LastWord + ":"' StringComparison.Ordinal))   						{  							block.Continuation = false;  							block.ResetOneLineBlock();  						}  						break;  				}
Missing Default,ICSharpCode.AvalonEdit.Rendering,TextView,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Rendering\TextView.cs,InsertLayer,The following switch statement is missing a default case: switch (position) {  							case LayerInsertionPosition.Below:  								layers.Insert(i' layer);  								return;  							case LayerInsertionPosition.Above:  								layers.Insert(i + 1' layer);  								return;  							case LayerInsertionPosition.Replace:  								layers[i] = layer;  								return;  						}
Missing Default,ICSharpCode.AvalonEdit.Search,SearchPanel,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Search\SearchPanel.cs,SearchLayerKeyDown,The following switch statement is missing a default case: switch (e.Key) {  				case Key.Enter:  					e.Handled = true;  					messageView.IsOpen = false;  					if ((Keyboard.Modifiers & ModifierKeys.Shift) == ModifierKeys.Shift)  						FindPrevious();  					else  						FindNext();  					if (searchTextBox != null) {  						var error = Validation.GetErrors(searchTextBox).FirstOrDefault();  						if (error != null) {  							messageView.Content = Localization.ErrorText + " " + error.ErrorContent;  							messageView.PlacementTarget = searchTextBox;  							messageView.IsOpen = true;  						}  					}  					break;  				case Key.Escape:  					e.Handled = true;  					Close();  					break;  			}
Missing Default,ICSharpCode.AvalonEdit.Search,SearchStrategyFactory,C:\repos\lightszero_CSLightStudio\CSLightStudio\windows\debugger\avalonEdit\ICSharpCode.AvalonEdit\Search\SearchStrategyFactory.cs,Create,The following switch statement is missing a default case: switch (mode) {  				case SearchMode.Normal:  					searchPattern = Regex.Escape(searchPattern);  					break;  				case SearchMode.Wildcard:  					searchPattern = ConvertWildcardsToRegex(searchPattern);  					break;  			}
