Implementation smell,Namespace,Class,File,Method,Description
Long Method,FrameWork,DataConnection,C:\repos\WarEmu_WarEmu\FrameWork\Database\Connection\DataConnection.cs,CheckOrCreateTable,The method has 222 lines of code.
Long Method,FrameWork,ObjectDatabase,C:\repos\WarEmu_WarEmu\FrameWork\Database\ObjectDatabase.cs,FillLazyObjectRelations,The method has 105 lines of code.
Long Method,FrameWork,Builder,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The method has 103 lines of code.
Long Method,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflate_fast,The method has 115 lines of code.
Long Method,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflate_slow,The method has 147 lines of code.
Long Method,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflate,The method has 169 lines of code.
Long Method,FrameWork,InfBlocks,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The method has 494 lines of code.
Long Method,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,proc,The method has 349 lines of code.
Long Method,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The method has 232 lines of code.
Long Method,FrameWork,Inflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Inflate.cs,inflate,The method has 196 lines of code.
Long Method,FrameWork,InfTree,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfTree.cs,huft_build,The method has 214 lines of code.
Complex Method,FrameWork,ConfigMgr,C:\repos\WarEmu_WarEmu\FrameWork\Config\ConfigMgr.cs,LoadConfigs,Cyclomatic complexity of the method is 12
Complex Method,FrameWork,DataConnection,C:\repos\WarEmu_WarEmu\FrameWork\Database\Connection\DataConnection.cs,CheckOrCreateTable,Cyclomatic complexity of the method is 19
Complex Method,FrameWork,MySQLObjectDatabase,C:\repos\WarEmu_WarEmu\FrameWork\Database\Handler\MysqlObjectDatabase.cs,AddObjectImpl,Cyclomatic complexity of the method is 8
Complex Method,FrameWork,MySQLObjectDatabase,C:\repos\WarEmu_WarEmu\FrameWork\Database\Handler\MysqlObjectDatabase.cs,SaveObjectImpl,Cyclomatic complexity of the method is 9
Complex Method,FrameWork,ObjectDatabase,C:\repos\WarEmu_WarEmu\FrameWork\Database\ObjectDatabase.cs,RegisterDataObject,Cyclomatic complexity of the method is 13
Complex Method,FrameWork,ObjectDatabase,C:\repos\WarEmu_WarEmu\FrameWork\Database\ObjectDatabase.cs,SaveObjectRelations,Cyclomatic complexity of the method is 11
Complex Method,FrameWork,ObjectDatabase,C:\repos\WarEmu_WarEmu\FrameWork\Database\ObjectDatabase.cs,DeleteObjectRelations,Cyclomatic complexity of the method is 12
Complex Method,FrameWork,ObjectDatabase,C:\repos\WarEmu_WarEmu\FrameWork\Database\ObjectDatabase.cs,FillLazyObjectRelations,Cyclomatic complexity of the method is 17
Complex Method,FrameWork,LoaderMgr,C:\repos\WarEmu_WarEmu\FrameWork\Loader\LoaderMgr.cs,Start,Cyclomatic complexity of the method is 8
Complex Method,FrameWork,Log,C:\repos\WarEmu_WarEmu\FrameWork\Logs\Log.cs,Compare,Cyclomatic complexity of the method is 15
Complex Method,FrameWork,BaseClient,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\BaseClient.cs,Crypt,Cyclomatic complexity of the method is 8
Complex Method,FrameWork,Builder,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,Cyclomatic complexity of the method is 13
Complex Method,FrameWork,ClusterInfo,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetClusterListReplyProto.cs,WriteTo,Cyclomatic complexity of the method is 12
Complex Method,FrameWork,RpcObject,C:\repos\WarEmu_WarEmu\FrameWork\Remoting\RpcObject.cs,RegisterHandlers,Cyclomatic complexity of the method is 8
Complex Method,FrameWork,RpcServer,C:\repos\WarEmu_WarEmu\FrameWork\Remoting\RpcServer.cs,Ping,Cyclomatic complexity of the method is 11
Complex Method,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflate_stored,Cyclomatic complexity of the method is 11
Complex Method,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflate_fast,Cyclomatic complexity of the method is 14
Complex Method,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflate_slow,Cyclomatic complexity of the method is 15
Complex Method,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflate,Cyclomatic complexity of the method is 21
Complex Method,FrameWork,InfBlocks,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,inflate_flush,Cyclomatic complexity of the method is 9
Complex Method,FrameWork,InfTree,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfTree.cs,huft_build,Cyclomatic complexity of the method is 25
Complex Method,FrameWork,Tree,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Tree.cs,gen_bitlen,Cyclomatic complexity of the method is 12
Long Parameter List,FrameWork,BindingInfo,C:\repos\WarEmu_WarEmu\FrameWork\Database\ObjectDatabase.cs,BindingInfo,The method has 5 parameters. Parameters: member' primaryKey' hasRelation' readOnly' attrib
Long Parameter List,FrameWork,Log,C:\repos\WarEmu_WarEmu\FrameWork\Logs\Log.cs,Tcp,The method has 5 parameters. Parameters: name' dump' start' len' Force
Long Parameter List,FrameWork,Log,C:\repos\WarEmu_WarEmu\FrameWork\Logs\Log.cs,Dump,The method has 5 parameters. Parameters: name' dump' start' len' Force
Long Parameter List,FrameWork,Utils,C:\repos\WarEmu_WarEmu\FrameWork\Utils\Utils.cs,Decode4Values,The method has 5 parameters. Parameters: Value' P1' P2' P3' P4
Long Parameter List,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflateInit2,The method has 6 parameters. Parameters: strm' level' method' windowBits' memLevel' strategy
Long Parameter List,FrameWork,Config,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Config,The method has 5 parameters. Parameters: good_length' max_lazy' nice_length' max_chain' func
Long Parameter List,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,InfCodes,The method has 7 parameters. Parameters: bl' bd' tl' tl_index' td' td_index' z
Long Parameter List,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,InfCodes,The method has 5 parameters. Parameters: bl' bd' tl' td' z
Long Parameter List,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The method has 8 parameters. Parameters: bl' bd' tl' tl_index' td' td_index' s' z
Long Parameter List,FrameWork,InfTree,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfTree.cs,huft_build,The method has 11 parameters. Parameters: b' bindex' n' s' d' e' t' m' hp' hn' v
Long Parameter List,FrameWork,InfTree,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfTree.cs,inflate_trees_bits,The method has 5 parameters. Parameters: c' bb' tb' hp' z
Long Parameter List,FrameWork,InfTree,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfTree.cs,inflate_trees_dynamic,The method has 9 parameters. Parameters: nl' nd' c' bl' bd' tl' td' hp' z
Long Parameter List,FrameWork,InfTree,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfTree.cs,inflate_trees_fixed,The method has 5 parameters. Parameters: bl' bd' tl' td' z
Long Parameter List,FrameWork,StaticTree,C:\repos\WarEmu_WarEmu\FrameWork\zlib\StaticTree.cs,StaticTree,The method has 5 parameters. Parameters: static_tree' extra_bits' extra_base' elems' max_length
Long Identifier,FrameWork,AuthSessionTokenReplyProto,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,,The length of the parameter internal__static_login_proto_AuthSessionTokenReply__Descriptor is 62.
Long Identifier,FrameWork,AuthSessionTokenReplyProto,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,,The length of the parameter internal__static_login_proto_AuthSessionTokenReply__FieldAccessorTable is 70.
Long Identifier,FrameWork,AuthSessionTokenReply,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,,The length of the parameter _authSessionTokenReplyFieldNames is 32.
Long Identifier,FrameWork,AuthSessionTokenReply,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,,The length of the parameter _authSessionTokenReplyFieldTags is 31.
Long Identifier,FrameWork,AuthSessionTokenReqProto,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReqProto.cs,,The length of the parameter internal__static_login_proto_AuthSessionTokenReq__Descriptor is 60.
Long Identifier,FrameWork,AuthSessionTokenReqProto,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReqProto.cs,,The length of the parameter internal__static_login_proto_AuthSessionTokenReq__FieldAccessorTable is 68.
Long Identifier,FrameWork,AuthSessionTokenReq,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReqProto.cs,,The length of the parameter _authSessionTokenReqFieldNames is 30.
Long Identifier,FrameWork,GetAcctPropListReplyProto,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetAcctPropListReplyProto.cs,,The length of the parameter internal__static_login_proto_GetAcctPropListReply__Descriptor is 61.
Long Identifier,FrameWork,GetAcctPropListReplyProto,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetAcctPropListReplyProto.cs,,The length of the parameter internal__static_login_proto_GetAcctPropListReply__FieldAccessorTable is 69.
Long Identifier,FrameWork,GetAcctPropListReplyProto,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetAcctPropListReplyProto.cs,,The length of the parameter internal__static_login_proto_GetAcctPropListReply_AcctProp__Descriptor is 70.
Long Identifier,FrameWork,GetAcctPropListReplyProto,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetAcctPropListReplyProto.cs,,The length of the parameter internal__static_login_proto_GetAcctPropListReply_AcctProp__FieldAccessorTable is 78.
Long Identifier,FrameWork,GetAcctPropListReply,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetAcctPropListReplyProto.cs,,The length of the parameter _getAcctPropListReplyFieldNames is 31.
Long Identifier,FrameWork,GetAcctPropListReply,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetAcctPropListReplyProto.cs,,The length of the parameter _getAcctPropListReplyFieldTags is 30.
Long Identifier,FrameWork,GetCharSummaryListReplyProto,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetCharSummaryListReplyProto.cs,,The length of the parameter internal__static_login_proto_GetCharSummaryListReply__Descriptor is 64.
Long Identifier,FrameWork,GetCharSummaryListReplyProto,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetCharSummaryListReplyProto.cs,,The length of the parameter internal__static_login_proto_GetCharSummaryListReply__FieldAccessorTable is 72.
Long Identifier,FrameWork,GetCharSummaryListReplyProto,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetCharSummaryListReplyProto.cs,,The length of the parameter internal__static_login_proto_GetCharSummaryListReply_CharSummary__Descriptor is 76.
Long Identifier,FrameWork,GetCharSummaryListReplyProto,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetCharSummaryListReplyProto.cs,,The length of the parameter internal__static_login_proto_GetCharSummaryListReply_CharSummary__FieldAccessorTable is 84.
Long Identifier,FrameWork,GetCharSummaryListReply,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetCharSummaryListReplyProto.cs,,The length of the parameter _getCharSummaryListReplyFieldNames is 34.
Long Identifier,FrameWork,GetCharSummaryListReply,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetCharSummaryListReplyProto.cs,,The length of the parameter _getCharSummaryListReplyFieldTags is 33.
Long Identifier,FrameWork,GetClusterListReplyProto,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetClusterListReplyProto.cs,,The length of the parameter internal__static_login_proto_ServerInfo__Descriptor is 51.
Long Identifier,FrameWork,GetClusterListReplyProto,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetClusterListReplyProto.cs,,The length of the parameter internal__static_login_proto_ServerInfo__FieldAccessorTable is 59.
Long Identifier,FrameWork,GetClusterListReplyProto,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetClusterListReplyProto.cs,,The length of the parameter internal__static_login_proto_ClusterProp__Descriptor is 52.
Long Identifier,FrameWork,GetClusterListReplyProto,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetClusterListReplyProto.cs,,The length of the parameter internal__static_login_proto_ClusterProp__FieldAccessorTable is 60.
Long Identifier,FrameWork,GetClusterListReplyProto,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetClusterListReplyProto.cs,,The length of the parameter internal__static_login_proto_ClusterInfo__Descriptor is 52.
Long Identifier,FrameWork,GetClusterListReplyProto,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetClusterListReplyProto.cs,,The length of the parameter internal__static_login_proto_ClusterInfo__FieldAccessorTable is 60.
Long Identifier,FrameWork,GetClusterListReplyProto,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetClusterListReplyProto.cs,,The length of the parameter internal__static_login_proto_GetClusterListReply__Descriptor is 60.
Long Identifier,FrameWork,GetClusterListReplyProto,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetClusterListReplyProto.cs,,The length of the parameter internal__static_login_proto_GetClusterListReply__FieldAccessorTable is 68.
Long Identifier,FrameWork,GetClusterListReply,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetClusterListReplyProto.cs,,The length of the parameter _getClusterListReplyFieldNames is 30.
Long Identifier,FrameWork,VerifyProtocolReplyProto,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\VerifyProtocolReplyProto.cs,,The length of the parameter internal__static_login_proto_VerifyProtocolReply__Descriptor is 60.
Long Identifier,FrameWork,VerifyProtocolReplyProto,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\VerifyProtocolReplyProto.cs,,The length of the parameter internal__static_login_proto_VerifyProtocolReply__FieldAccessorTable is 68.
Long Identifier,FrameWork,VerifyProtocolReply,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\VerifyProtocolReplyProto.cs,,The length of the parameter _verifyProtocolReplyFieldNames is 30.
Long Identifier,FrameWork,VerifyProtocolReqProto,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\VerifyProtocolReqProto.cs,,The length of the parameter internal__static_login_proto_VerifyProtocolReq__Descriptor is 58.
Long Identifier,FrameWork,VerifyProtocolReqProto,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\VerifyProtocolReqProto.cs,,The length of the parameter internal__static_login_proto_VerifyProtocolReq__FieldAccessorTable is 66.
Long Statement,FrameWork,ConsoleMgr,C:\repos\WarEmu_WarEmu\FrameWork\Console\ConsoleMgr.cs,ExecuteCommand,The length of the statement  "            var consoleHandlerAttribs = (ConsoleHandlerAttribute[])Handler.GetType().GetCustomAttributes(typeof(ConsoleHandlerAttribute)' true); " is 132.
Long Statement,FrameWork,DataConnection,C:\repos\WarEmu_WarEmu\FrameWork\Database\Connection\DataConnection.cs,HandleException,The length of the statement  "                Log.Notice("DataConnection"'string.Format("Socket exception: ({0}) {1}; repeat: {2}"' socketException.ErrorCode' socketException.Message' ret)); " is 144.
Long Statement,FrameWork,DataConnection,C:\repos\WarEmu_WarEmu\FrameWork\Database\Connection\DataConnection.cs,ExecuteSelect,The length of the statement  "                            Log.Notice("DataConnecion"' "SQL Select (" + isolation + ") took " + (Environment.TickCount - start) + "ms!\n" + sqlcommand); " is 125.
Long Statement,FrameWork,DataConnection,C:\repos\WarEmu_WarEmu\FrameWork\Database\Connection\DataConnection.cs,CheckOrCreateTable,The length of the statement  "                            if (reader.GetString(0).ToLower() != (table.TableName + "_ID").ToLower() && !table.Columns.Contains(reader.GetString(0).ToLower())) " is 131.
Long Statement,FrameWork,MySQLObjectDatabase,C:\repos\WarEmu_WarEmu\FrameWork\Database\Handler\MysqlObjectDatabase.cs,SaveObjectImpl,The length of the statement  "                    Log.Error("MysqlObject"' "Modify error : " + dataObject.TableName + " ID=" + dataObject.ObjectId + " --- keyvalue changed? " + sql + " " + Environment.StackTrace); " is 163.
Long Statement,FrameWork,MySQLObjectDatabase,C:\repos\WarEmu_WarEmu\FrameWork\Database\Handler\MysqlObjectDatabase.cs,DeleteObjectImpl,The length of the statement  "                    Log.Error("MysqlObject"' "Delete Object : " + dataObject.TableName + " failed! ID=" + dataObject.ObjectId + " " + Environment.StackTrace); " is 138.
Long Statement,FrameWork,Log,C:\repos\WarEmu_WarEmu\FrameWork\Logs\Log.cs,InitInstance,The length of the statement  "                BackDir += "/" + Config.PreFileName + "." + DateTime.Now.Hour + "h." + DateTime.Now.Minute + "m." + DateTime.Now.Second + "s" + Config.FileName; " is 144.
Long Statement,FrameWork,Builder,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The length of the statement  "            int field_ordinal = global::System.Array.BinarySearch(_authSessionTokenReplyFieldNames' field_name' global::System.StringComparer.Ordinal); " is 139.
Long Statement,FrameWork,Builder,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The length of the statement  "            int field_ordinal = global::System.Array.BinarySearch(_authSessionTokenReqFieldNames' field_name' global::System.StringComparer.Ordinal); " is 137.
Long Statement,FrameWork,Builder,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The length of the statement  "                int field_ordinal = global::System.Array.BinarySearch(_acctPropFieldNames' field_name' global::System.StringComparer.Ordinal); " is 126.
Long Statement,FrameWork,Builder,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The length of the statement  "            int field_ordinal = global::System.Array.BinarySearch(_getAcctPropListReplyFieldNames' field_name' global::System.StringComparer.Ordinal); " is 138.
Long Statement,FrameWork,Builder,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The length of the statement  "              input.ReadMessageArray(tag' field_name' result.propList_' global::FrameWork.GetAcctPropListReply.Types.AcctProp.DefaultInstance' extensionRegistry); " is 148.
Long Statement,FrameWork,Builder,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The length of the statement  "                int field_ordinal = global::System.Array.BinarySearch(_charSummaryFieldNames' field_name' global::System.StringComparer.Ordinal); " is 129.
Long Statement,FrameWork,Builder,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The length of the statement  "            int field_ordinal = global::System.Array.BinarySearch(_getCharSummaryListReplyFieldNames' field_name' global::System.StringComparer.Ordinal); " is 141.
Long Statement,FrameWork,Builder,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The length of the statement  "              input.ReadMessageArray(tag' field_name' result.summaryList_' global::FrameWork.GetCharSummaryListReply.Types.CharSummary.DefaultInstance' extensionRegistry); " is 157.
Long Statement,FrameWork,Builder,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The length of the statement  "            int field_ordinal = global::System.Array.BinarySearch(_serverInfoFieldNames' field_name' global::System.StringComparer.Ordinal); " is 128.
Long Statement,FrameWork,Builder,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The length of the statement  "            int field_ordinal = global::System.Array.BinarySearch(_clusterPropFieldNames' field_name' global::System.StringComparer.Ordinal); " is 129.
Long Statement,FrameWork,Builder,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The length of the statement  "            int field_ordinal = global::System.Array.BinarySearch(_clusterInfoFieldNames' field_name' global::System.StringComparer.Ordinal); " is 129.
Long Statement,FrameWork,Builder,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The length of the statement  "              input.ReadMessageArray(tag' field_name' result.serverList_' global::FrameWork.ServerInfo.DefaultInstance' extensionRegistry); " is 125.
Long Statement,FrameWork,Builder,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The length of the statement  "              input.ReadMessageArray(tag' field_name' result.propertyList_' global::FrameWork.ClusterProp.DefaultInstance' extensionRegistry); " is 128.
Long Statement,FrameWork,Builder,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The length of the statement  "            int field_ordinal = global::System.Array.BinarySearch(_getClusterListReplyFieldNames' field_name' global::System.StringComparer.Ordinal); " is 137.
Long Statement,FrameWork,Builder,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The length of the statement  "              input.ReadMessageArray(tag' field_name' result.clusterList_' global::FrameWork.ClusterInfo.DefaultInstance' extensionRegistry); " is 127.
Long Statement,FrameWork,Builder,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The length of the statement  "            int field_ordinal = global::System.Array.BinarySearch(_verifyProtocolReplyFieldNames' field_name' global::System.StringComparer.Ordinal); " is 137.
Long Statement,FrameWork,Builder,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The length of the statement  "            int field_ordinal = global::System.Array.BinarySearch(_verifyProtocolReqFieldNames' field_name' global::System.StringComparer.Ordinal); " is 135.
Long Statement,FrameWork,TCPManager,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\TCPManager.cs,HandlePacket,The length of the statement  "                PacketHandlerAttribute[] packethandlerattribs = (PacketHandlerAttribute[])packetHandler.GetType().GetCustomAttributes(typeof(PacketHandlerAttribute)' true); " is 156.
Long Statement,FrameWork,TCPManager,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\TCPManager.cs,HandlePacket,The length of the statement  "                        Log.Error("TCPManager"' "Can not handle packet ("+Packet.Opcode.ToString("X8")+")' Invalid client state ("+client.GetIp+")"); " is 125.
Long Statement,FrameWork,RpcClient,C:\repos\WarEmu_WarEmu\FrameWork\Remoting\RpcClient.cs,Connect,The length of the statement  "                Log.Success("RpcClient"' "Connected to : " + ServerIp + ":" + RpcServerPort + "' Listen on : " + Info.Ip + ":" + Info.Port); " is 124.
Long Statement,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,longest_match,The length of the statement  "				if (window[match + best_len] != scan_end || window[match + best_len - 1] != scan_end1 || window[match] != window[scan] || window[++match] != window[scan + 1]) " is 158.
Long Statement,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,longest_match,The length of the statement  "				while (window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match] && scan < strend); " is 318.
Long Statement,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflateInit2,The length of the statement  "			if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED || windowBits < 9 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_HUFFMAN_ONLY) " is 177.
Long Statement,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflate,The length of the statement  "			if (strm.next_out == null || (strm.next_in == null && strm.avail_in != 0) || (status == FINISH_STATE && flush != Z_FINISH)) " is 123.
Long Statement,FrameWork,ZStream,C:\repos\WarEmu_WarEmu\FrameWork\zlib\ZStream.cs,flush_pending,The length of the statement  "			if (dstate.pending_buf.Length <= dstate.pending_out || next_out.Length <= next_out_index || dstate.pending_buf.Length < (dstate.pending_out + len) || next_out.Length < (next_out_index + len)) " is 191.
Long Statement,FrameWork,ZStream,C:\repos\WarEmu_WarEmu\FrameWork\zlib\ZStream.cs,flush_pending,The length of the statement  "				//System.Console.Out.WriteLine(dstate.pending_buf.Length + "' " + dstate.pending_out + "' " + next_out.Length + "' " + next_out_index + "' " + len); " is 148.
Complex Conditional,FrameWork,DataConnection,C:\repos\WarEmu_WarEmu\FrameWork\Database\Connection\DataConnection.cs,CheckOrCreateTable,The conditional expression  "primaryKeys.ContainsKey(table.Columns[i].ColumnName) ||                              table.Columns[i].ExtendedProperties.ContainsKey("INDEX") ||                              table.Columns[i].ExtendedProperties.ContainsKey("VARCHAR") ||                              table.Columns[i].Unique"  is complex.
Complex Conditional,FrameWork,ObjectDatabase,C:\repos\WarEmu_WarEmu\FrameWork\Database\ObjectDatabase.cs,GetBindingInfo,The conditional expression  "attrib.Length > 0 || keyAttrib.Length > 0 || relAttrib.Length > 0 || readonlyAttrib.Length > 0"  is complex.
Complex Conditional,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflate_slow,The conditional expression  "match_length <= 5 && (strategy == Z_FILTERED || (match_length == MIN_MATCH && strstart - match_start > 4096))"  is complex.
Complex Conditional,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,longest_match,The conditional expression  "window[match + best_len] != scan_end || window[match + best_len - 1] != scan_end1 || window[match] != window[scan] || window[++match] != window[scan + 1]"  is complex.
Complex Conditional,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflateInit2,The conditional expression  "memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED || windowBits < 9 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_HUFFMAN_ONLY"  is complex.
Complex Conditional,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflateParams,The conditional expression  "_level < 0 || _level > 9 || _strategy < 0 || _strategy > Z_HUFFMAN_ONLY"  is complex.
Complex Conditional,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflate,The conditional expression  "strm.next_out == null || (strm.next_in == null && strm.avail_in != 0) || (status == FINISH_STATE && flush != Z_FINISH)"  is complex.
Complex Conditional,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflate,The conditional expression  "strm.avail_in != 0 || lookahead != 0 || (flush != Z_NO_FLUSH && status != FINISH_STATE)"  is complex.
Complex Conditional,FrameWork,ZStream,C:\repos\WarEmu_WarEmu\FrameWork\zlib\ZStream.cs,flush_pending,The conditional expression  "dstate.pending_buf.Length <= dstate.pending_out || next_out.Length <= next_out_index || dstate.pending_buf.Length < (dstate.pending_out + len) || next_out.Length < (next_out_index + len)"  is complex.
Virtual Method Call from Constructor,FrameWork,PacketOut,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,PacketOut,The constructor "PacketOut" calls a virtual method "WriteUInt16".
Virtual Method Call from Constructor,FrameWork,PacketOut,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,PacketOut,The constructor "PacketOut" calls a virtual method "WriteUInt16R".
Virtual Method Call from Constructor,FrameWork,PacketOut,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,PacketOut,The constructor "PacketOut" calls a virtual method "WriteUInt16".
Virtual Method Call from Constructor,FrameWork,PacketOut,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,PacketOut,The constructor "PacketOut" calls a virtual method "WriteUInt16R".
Virtual Method Call from Constructor,FrameWork,PacketOut,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,PacketOut,The constructor "PacketOut" calls a virtual method "WriteUInt32".
Virtual Method Call from Constructor,FrameWork,PacketOut,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,PacketOut,The constructor "PacketOut" calls a virtual method "WriteUInt32R".
Virtual Method Call from Constructor,FrameWork,PacketOut,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,PacketOut,The constructor "PacketOut" calls a virtual method "WriteUInt32".
Virtual Method Call from Constructor,FrameWork,PacketOut,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,PacketOut,The constructor "PacketOut" calls a virtual method "WriteUInt32R".
Virtual Method Call from Constructor,FrameWork,PacketOut,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,PacketOut,The constructor "PacketOut" calls a virtual method "WriteUInt64".
Virtual Method Call from Constructor,FrameWork,PacketOut,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,PacketOut,The constructor "PacketOut" calls a virtual method "WriteUInt64R".
Virtual Method Call from Constructor,FrameWork,PacketOut,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,PacketOut,The constructor "PacketOut" calls a virtual method "WriteUInt64".
Virtual Method Call from Constructor,FrameWork,PacketOut,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,PacketOut,The constructor "PacketOut" calls a virtual method "WriteUInt64R".
Empty Catch Block,FrameWork,ConfigMgr,C:\repos\WarEmu_WarEmu\FrameWork\Config\ConfigMgr.cs,LoadConfigs,The method has an empty catch block.
Empty Catch Block,FrameWork,Log,C:\repos\WarEmu_WarEmu\FrameWork\Logs\Log.cs,InitInstance,The method has an empty catch block.
Empty Catch Block,FrameWork,BaseClient,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\BaseClient.cs,CloseConnections,The method has an empty catch block.
Empty Catch Block,FrameWork,BaseClient,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\BaseClient.cs,CloseConnections,The method has an empty catch block.
Empty Catch Block,FrameWork,TCPManager,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\TCPManager.cs,ConnectingThread,The method has an empty catch block.
Empty Catch Block,FrameWork,RpcClient,C:\repos\WarEmu_WarEmu\FrameWork\Remoting\RpcClient.cs,Connect,The method has an empty catch block.
Empty Catch Block,FrameWork,ZOutputStream,C:\repos\WarEmu_WarEmu\FrameWork\zlib\ZOutputStream.cs,finish,The method has an empty catch block.
Empty Catch Block,FrameWork,ZOutputStream,C:\repos\WarEmu_WarEmu\FrameWork\zlib\ZOutputStream.cs,Close,The method has an empty catch block.
Magic Number,FrameWork,ConsoleMgr,C:\repos\WarEmu_WarEmu\FrameWork\Console\ConsoleMgr.cs,GetInt,The following statement contains a magic number: if (args.Count <= 0)                  return -999;
Magic Number,FrameWork,DataElement,C:\repos\WarEmu_WarEmu\FrameWork\Database\Attributes\DataElement.cs,DataElement,The following statement contains a magic number: Decimal = 10;
Magic Number,FrameWork,DataConnection,C:\repos\WarEmu_WarEmu\FrameWork\Database\Connection\DataConnection.cs,GetMySqlConnection,The following statement contains a magic number: if (conn != null)              {                  isNewConnection = false;              }              else              {                  isNewConnection = true;                  long start1 = Environment.TickCount;                  conn = new MySqlConnection(connString);                  conn.Open();                  if (Environment.TickCount - start1 > 1000)                  {                       Log.Notice("DataConnecion"'"Connection time : " + (Environment.TickCount - start1) + "ms");                  }                    Log.Debug("DataConnection"' "New DB Connection");              }
Magic Number,FrameWork,DataConnection,C:\repos\WarEmu_WarEmu\FrameWork\Database\Connection\DataConnection.cs,ExecuteNonQuery,The following statement contains a magic number: if (connType == ConnectionType.DATABASE_MYSQL)              {                 Log.Debug("DataConnection"'"SQL: " + sqlcommand);                    int affected = 0;                  bool repeat = false;                  do                  {                      bool isNewConnection;                      MySqlConnection conn = GetMySqlConnection(out isNewConnection);                      var cmd = new MySqlCommand(sqlcommand' conn);                        try                      {                          System.Threading.Thread.CurrentThread.CurrentCulture = new System.Globalization.CultureInfo("en-US");                          long start = Environment.TickCount;                          affected = cmd.ExecuteNonQuery();                            Log.Debug("DataConnection"' "SQL NonQuery exec time " + (Environment.TickCount - start) + "ms");                                                   if (Environment.TickCount - start > 500)                             Log.Notice("DataConnection"' "SQL NonQuery took " + (Environment.TickCount - start) + "ms!\n" + sqlcommand);                            ReleaseConnection(conn);                            repeat = false;                      }                      catch (Exception e)                      {                          conn.Close();                            if (!HandleException(e) || isNewConnection)                          {                              throw;                          }                          repeat = true;                      }                  } while (repeat);                    return affected;              }
Magic Number,FrameWork,DataConnection,C:\repos\WarEmu_WarEmu\FrameWork\Database\Connection\DataConnection.cs,HandleException,The following statement contains a magic number: if (socketException != null)              {                  // Handle socket exception. Error codes:                  // http://msdn2.microsoft.com/en-us/library/ms740668.aspx                  // 10052 = Network dropped connection on reset.                  // 10053 = Software caused connection abort.                  // 10054 = Connection reset by peer.                  // 10057 = Socket is not connected.                  // 10058 = Cannot send after socket shutdown.                  switch (socketException.ErrorCode)                  {                      case 10052:                      case 10053:                      case 10054:                      case 10057:                      case 10058:                          {                              ret = true;                              break;                          }                  }                    Log.Notice("DataConnection"'string.Format("Socket exception: ({0}) {1}; repeat: {2}"' socketException.ErrorCode' socketException.Message' ret));                }
Magic Number,FrameWork,DataConnection,C:\repos\WarEmu_WarEmu\FrameWork\Database\Connection\DataConnection.cs,HandleException,The following statement contains a magic number: if (socketException != null)              {                  // Handle socket exception. Error codes:                  // http://msdn2.microsoft.com/en-us/library/ms740668.aspx                  // 10052 = Network dropped connection on reset.                  // 10053 = Software caused connection abort.                  // 10054 = Connection reset by peer.                  // 10057 = Socket is not connected.                  // 10058 = Cannot send after socket shutdown.                  switch (socketException.ErrorCode)                  {                      case 10052:                      case 10053:                      case 10054:                      case 10057:                      case 10058:                          {                              ret = true;                              break;                          }                  }                    Log.Notice("DataConnection"'string.Format("Socket exception: ({0}) {1}; repeat: {2}"' socketException.ErrorCode' socketException.Message' ret));                }
Magic Number,FrameWork,DataConnection,C:\repos\WarEmu_WarEmu\FrameWork\Database\Connection\DataConnection.cs,HandleException,The following statement contains a magic number: if (socketException != null)              {                  // Handle socket exception. Error codes:                  // http://msdn2.microsoft.com/en-us/library/ms740668.aspx                  // 10052 = Network dropped connection on reset.                  // 10053 = Software caused connection abort.                  // 10054 = Connection reset by peer.                  // 10057 = Socket is not connected.                  // 10058 = Cannot send after socket shutdown.                  switch (socketException.ErrorCode)                  {                      case 10052:                      case 10053:                      case 10054:                      case 10057:                      case 10058:                          {                              ret = true;                              break;                          }                  }                    Log.Notice("DataConnection"'string.Format("Socket exception: ({0}) {1}; repeat: {2}"' socketException.ErrorCode' socketException.Message' ret));                }
Magic Number,FrameWork,DataConnection,C:\repos\WarEmu_WarEmu\FrameWork\Database\Connection\DataConnection.cs,HandleException,The following statement contains a magic number: if (socketException != null)              {                  // Handle socket exception. Error codes:                  // http://msdn2.microsoft.com/en-us/library/ms740668.aspx                  // 10052 = Network dropped connection on reset.                  // 10053 = Software caused connection abort.                  // 10054 = Connection reset by peer.                  // 10057 = Socket is not connected.                  // 10058 = Cannot send after socket shutdown.                  switch (socketException.ErrorCode)                  {                      case 10052:                      case 10053:                      case 10054:                      case 10057:                      case 10058:                          {                              ret = true;                              break;                          }                  }                    Log.Notice("DataConnection"'string.Format("Socket exception: ({0}) {1}; repeat: {2}"' socketException.ErrorCode' socketException.Message' ret));                }
Magic Number,FrameWork,DataConnection,C:\repos\WarEmu_WarEmu\FrameWork\Database\Connection\DataConnection.cs,HandleException,The following statement contains a magic number: if (socketException != null)              {                  // Handle socket exception. Error codes:                  // http://msdn2.microsoft.com/en-us/library/ms740668.aspx                  // 10052 = Network dropped connection on reset.                  // 10053 = Software caused connection abort.                  // 10054 = Connection reset by peer.                  // 10057 = Socket is not connected.                  // 10058 = Cannot send after socket shutdown.                  switch (socketException.ErrorCode)                  {                      case 10052:                      case 10053:                      case 10054:                      case 10057:                      case 10058:                          {                              ret = true;                              break;                          }                  }                    Log.Notice("DataConnection"'string.Format("Socket exception: ({0}) {1}; repeat: {2}"' socketException.ErrorCode' socketException.Message' ret));                }
Magic Number,FrameWork,DataConnection,C:\repos\WarEmu_WarEmu\FrameWork\Database\Connection\DataConnection.cs,ExecuteSelect,The following statement contains a magic number: if (connType == ConnectionType.DATABASE_MYSQL)              {                 Log.Debug("DataConnecion"'"SQL: " + sqlcommand);                    bool repeat = false;                  MySqlConnection conn = null;                  do                  {                      bool isNewConnection = true;                      try                      {                          conn = GetMySqlConnection(out isNewConnection);                            long start = Environment.TickCount;                            var cmd = new MySqlCommand(sqlcommand' conn);                          MySqlDataReader reader = cmd.ExecuteReader();                          callback(reader);                          reader.Close();                            Log.Debug("DataConnecion"'"SQL Select (" + isolation + ") exec time " + (Environment.TickCount - start) + "ms");                            if (Environment.TickCount - start > 500)                              Log.Notice("DataConnecion"' "SQL Select (" + isolation + ") took " + (Environment.TickCount - start) + "ms!\n" + sqlcommand);                            ReleaseConnection(conn);                            repeat = false;                      }                      catch (Exception e)                      {                          if (conn != null)                          {                              conn.Close();                          }                            if (!HandleException(e) || isNewConnection)                          {                              Log.Error("DataConnecion"' "ExecuteSelect: \"" + sqlcommand + "\"\n" + e.ToString() );                              return;                          }                            repeat = true;                      }                  } while (repeat);                    return;              }
Magic Number,FrameWork,DataConnection,C:\repos\WarEmu_WarEmu\FrameWork\Database\Connection\DataConnection.cs,ExecuteScalar,The following statement contains a magic number: if (connType == ConnectionType.DATABASE_MYSQL)              {                  Log.Debug("DataConnecion"'"SQL: " + sqlcommand);                    object obj = null;                  bool repeat = false;                  MySqlConnection conn = null;                  do                  {                      bool isNewConnection = true;                      try                      {                          conn = GetMySqlConnection(out isNewConnection);                          var cmd = new MySqlCommand(sqlcommand' conn);                            long start = Environment.TickCount;                          obj = cmd.ExecuteScalar();                            ReleaseConnection(conn);                            Log.Debug("DataConnecion"'"SQL Select exec time " + (Environment.TickCount - start) + "ms");                                                    if (Environment.TickCount - start > 500)                              Log.Notice("DataConnecion"' "SQL Select took " + (Environment.TickCount - start) + "ms!\n" + sqlcommand);                            repeat = false;                      }                      catch (Exception e)                      {                          if (conn != null)                          {                              conn.Close();                          }                            if (!HandleException(e) || isNewConnection)                          {                              Log.Error("DataConnecion"' "ExecuteSelect: \"" + sqlcommand + "\"\n" + e.ToString() );                              throw;                          }                            repeat = true;                      }                  } while (repeat);                    return obj;              }
Magic Number,FrameWork,MySQLObjectDatabase,C:\repos\WarEmu_WarEmu\FrameWork\Database\Handler\MysqlObjectDatabase.cs,SelectObjectsImpl,The following statement contains a magic number: var dataObjects = new List<DataObject>(64);
Magic Number,FrameWork,MySQLObjectDatabase,C:\repos\WarEmu_WarEmu\FrameWork\Database\Handler\MysqlObjectDatabase.cs,SelectObjectsImpl,The following statement contains a magic number: var dataObjects = new List<TObject>(64);
Magic Number,FrameWork,LoaderMgr,C:\repos\WarEmu_WarEmu\FrameWork\Loader\LoaderMgr.cs,InitLoad,The following statement contains a magic number: if (MaxThread == 0 || LoaderCount < MaxThread)              {                  new LoaderMgr(Func);                  Thread.Sleep(50);              }              else                  Func.Invoke();
Magic Number,FrameWork,LoaderMgr,C:\repos\WarEmu_WarEmu\FrameWork\Loader\LoaderMgr.cs,Wait,The following statement contains a magic number: while (LoaderCount > 0)                  Thread.Sleep(50);
Magic Number,FrameWork,Log,C:\repos\WarEmu_WarEmu\FrameWork\Logs\Log.cs,Texte,The following statement contains a magic number: lock (_config)              {                  string Texte = "[" + DateTime.Now.ToString("HH:mm:ss") + "] " + name + " : " + message;                    Type isMono = Type.GetType("Mono.Runtime");                  if (isMono == null)                      Console.BufferHeight = Console.WindowWidth - 20;                    Console.ForegroundColor = Color;                  Console.WriteLine(Texte);                  Console.ForegroundColor = ConsoleColor.White;                    if (DumpFile != null && FSDump != null)                  {                      byte[] info = new UTF8Encoding(true).GetBytes(Texte+"\n");                      FSDump.Write(info' 0' info.Length);                      FSDump.Flush();                  }                }
Magic Number,FrameWork,Log,C:\repos\WarEmu_WarEmu\FrameWork\Logs\Log.cs,Compare,The following statement contains a magic number: for (int i = 0; i < Math.Max(First.Length' Second.Length); i += 16)              {                  hex.Append("\n");                    bool LastDiff = false;                  for (int j = 0; j < 16; ++j)                  {                      if (j + i < First.Length)                      {                          if (j + i < Second.Length)                          {                              if (First[j + i] != Second[j + i] && !LastDiff)                              {                                  LastDiff = true;                                  hex.Append("[");                              }                              else if (First[j + i] == Second[j + i] && LastDiff)                              {                                  LastDiff = false;                                  hex.Append("]");                              }                          }                          else if (LastDiff)                          {                              LastDiff = false;                              hex.Append("]");                          }                                                        byte val = First[j + i];                          //hex.Append(" ");                          hex.Append(First[j + i].ToString("X2"));                          if (j == 3 || j == 7 || j == 11)                              hex.Append("");                      }                      else                      {                          hex.Append("  ");                      }                  }                  if (LastDiff)                  {                      LastDiff = false;                      hex.Append("]");                  }                    hex.Append(" || ");                    LastDiff = false;                  for (int j = 0; j < 16; ++j)                  {                      if (j + i < Second.Length)                      {                          if (j + i < First.Length)                          {                              if (First[j + i] != Second[j + i] && !LastDiff)                              {                                  LastDiff = true;                                  hex.Append("[");                              }                              else if (First[j + i] == Second[j + i] && LastDiff)                              {                                  LastDiff = false;                                  hex.Append("]");                              }                          }                          else if (LastDiff)                          {                              LastDiff = false;                              hex.Append("]");                          }                            byte val = Second[j + i];                          //hex.Append(" ");                          hex.Append(Second[j + i].ToString("X2"));                          if (j == 3 || j == 7 || j == 11)                              hex.Append("");                      }                      else                      {                          if (LastDiff)                          {                              LastDiff = false;                              hex.Append("]");                          }                              hex.Append("  ");                      }                  }              }
Magic Number,FrameWork,Log,C:\repos\WarEmu_WarEmu\FrameWork\Logs\Log.cs,Compare,The following statement contains a magic number: for (int i = 0; i < Math.Max(First.Length' Second.Length); i += 16)              {                  hex.Append("\n");                    bool LastDiff = false;                  for (int j = 0; j < 16; ++j)                  {                      if (j + i < First.Length)                      {                          if (j + i < Second.Length)                          {                              if (First[j + i] != Second[j + i] && !LastDiff)                              {                                  LastDiff = true;                                  hex.Append("[");                              }                              else if (First[j + i] == Second[j + i] && LastDiff)                              {                                  LastDiff = false;                                  hex.Append("]");                              }                          }                          else if (LastDiff)                          {                              LastDiff = false;                              hex.Append("]");                          }                                                        byte val = First[j + i];                          //hex.Append(" ");                          hex.Append(First[j + i].ToString("X2"));                          if (j == 3 || j == 7 || j == 11)                              hex.Append("");                      }                      else                      {                          hex.Append("  ");                      }                  }                  if (LastDiff)                  {                      LastDiff = false;                      hex.Append("]");                  }                    hex.Append(" || ");                    LastDiff = false;                  for (int j = 0; j < 16; ++j)                  {                      if (j + i < Second.Length)                      {                          if (j + i < First.Length)                          {                              if (First[j + i] != Second[j + i] && !LastDiff)                              {                                  LastDiff = true;                                  hex.Append("[");                              }                              else if (First[j + i] == Second[j + i] && LastDiff)                              {                                  LastDiff = false;                                  hex.Append("]");                              }                          }                          else if (LastDiff)                          {                              LastDiff = false;                              hex.Append("]");                          }                            byte val = Second[j + i];                          //hex.Append(" ");                          hex.Append(Second[j + i].ToString("X2"));                          if (j == 3 || j == 7 || j == 11)                              hex.Append("");                      }                      else                      {                          if (LastDiff)                          {                              LastDiff = false;                              hex.Append("]");                          }                              hex.Append("  ");                      }                  }              }
Magic Number,FrameWork,Log,C:\repos\WarEmu_WarEmu\FrameWork\Logs\Log.cs,Compare,The following statement contains a magic number: for (int i = 0; i < Math.Max(First.Length' Second.Length); i += 16)              {                  hex.Append("\n");                    bool LastDiff = false;                  for (int j = 0; j < 16; ++j)                  {                      if (j + i < First.Length)                      {                          if (j + i < Second.Length)                          {                              if (First[j + i] != Second[j + i] && !LastDiff)                              {                                  LastDiff = true;                                  hex.Append("[");                              }                              else if (First[j + i] == Second[j + i] && LastDiff)                              {                                  LastDiff = false;                                  hex.Append("]");                              }                          }                          else if (LastDiff)                          {                              LastDiff = false;                              hex.Append("]");                          }                                                        byte val = First[j + i];                          //hex.Append(" ");                          hex.Append(First[j + i].ToString("X2"));                          if (j == 3 || j == 7 || j == 11)                              hex.Append("");                      }                      else                      {                          hex.Append("  ");                      }                  }                  if (LastDiff)                  {                      LastDiff = false;                      hex.Append("]");                  }                    hex.Append(" || ");                    LastDiff = false;                  for (int j = 0; j < 16; ++j)                  {                      if (j + i < Second.Length)                      {                          if (j + i < First.Length)                          {                              if (First[j + i] != Second[j + i] && !LastDiff)                              {                                  LastDiff = true;                                  hex.Append("[");                              }                              else if (First[j + i] == Second[j + i] && LastDiff)                              {                                  LastDiff = false;                                  hex.Append("]");                              }                          }                          else if (LastDiff)                          {                              LastDiff = false;                              hex.Append("]");                          }                            byte val = Second[j + i];                          //hex.Append(" ");                          hex.Append(Second[j + i].ToString("X2"));                          if (j == 3 || j == 7 || j == 11)                              hex.Append("");                      }                      else                      {                          if (LastDiff)                          {                              LastDiff = false;                              hex.Append("]");                          }                              hex.Append("  ");                      }                  }              }
Magic Number,FrameWork,Log,C:\repos\WarEmu_WarEmu\FrameWork\Logs\Log.cs,Compare,The following statement contains a magic number: for (int i = 0; i < Math.Max(First.Length' Second.Length); i += 16)              {                  hex.Append("\n");                    bool LastDiff = false;                  for (int j = 0; j < 16; ++j)                  {                      if (j + i < First.Length)                      {                          if (j + i < Second.Length)                          {                              if (First[j + i] != Second[j + i] && !LastDiff)                              {                                  LastDiff = true;                                  hex.Append("[");                              }                              else if (First[j + i] == Second[j + i] && LastDiff)                              {                                  LastDiff = false;                                  hex.Append("]");                              }                          }                          else if (LastDiff)                          {                              LastDiff = false;                              hex.Append("]");                          }                                                        byte val = First[j + i];                          //hex.Append(" ");                          hex.Append(First[j + i].ToString("X2"));                          if (j == 3 || j == 7 || j == 11)                              hex.Append("");                      }                      else                      {                          hex.Append("  ");                      }                  }                  if (LastDiff)                  {                      LastDiff = false;                      hex.Append("]");                  }                    hex.Append(" || ");                    LastDiff = false;                  for (int j = 0; j < 16; ++j)                  {                      if (j + i < Second.Length)                      {                          if (j + i < First.Length)                          {                              if (First[j + i] != Second[j + i] && !LastDiff)                              {                                  LastDiff = true;                                  hex.Append("[");                              }                              else if (First[j + i] == Second[j + i] && LastDiff)                              {                                  LastDiff = false;                                  hex.Append("]");                              }                          }                          else if (LastDiff)                          {                              LastDiff = false;                              hex.Append("]");                          }                            byte val = Second[j + i];                          //hex.Append(" ");                          hex.Append(Second[j + i].ToString("X2"));                          if (j == 3 || j == 7 || j == 11)                              hex.Append("");                      }                      else                      {                          if (LastDiff)                          {                              LastDiff = false;                              hex.Append("]");                          }                              hex.Append("  ");                      }                  }              }
Magic Number,FrameWork,Log,C:\repos\WarEmu_WarEmu\FrameWork\Logs\Log.cs,Compare,The following statement contains a magic number: for (int i = 0; i < Math.Max(First.Length' Second.Length); i += 16)              {                  hex.Append("\n");                    bool LastDiff = false;                  for (int j = 0; j < 16; ++j)                  {                      if (j + i < First.Length)                      {                          if (j + i < Second.Length)                          {                              if (First[j + i] != Second[j + i] && !LastDiff)                              {                                  LastDiff = true;                                  hex.Append("[");                              }                              else if (First[j + i] == Second[j + i] && LastDiff)                              {                                  LastDiff = false;                                  hex.Append("]");                              }                          }                          else if (LastDiff)                          {                              LastDiff = false;                              hex.Append("]");                          }                                                        byte val = First[j + i];                          //hex.Append(" ");                          hex.Append(First[j + i].ToString("X2"));                          if (j == 3 || j == 7 || j == 11)                              hex.Append("");                      }                      else                      {                          hex.Append("  ");                      }                  }                  if (LastDiff)                  {                      LastDiff = false;                      hex.Append("]");                  }                    hex.Append(" || ");                    LastDiff = false;                  for (int j = 0; j < 16; ++j)                  {                      if (j + i < Second.Length)                      {                          if (j + i < First.Length)                          {                              if (First[j + i] != Second[j + i] && !LastDiff)                              {                                  LastDiff = true;                                  hex.Append("[");                              }                              else if (First[j + i] == Second[j + i] && LastDiff)                              {                                  LastDiff = false;                                  hex.Append("]");                              }                          }                          else if (LastDiff)                          {                              LastDiff = false;                              hex.Append("]");                          }                            byte val = Second[j + i];                          //hex.Append(" ");                          hex.Append(Second[j + i].ToString("X2"));                          if (j == 3 || j == 7 || j == 11)                              hex.Append("");                      }                      else                      {                          if (LastDiff)                          {                              LastDiff = false;                              hex.Append("]");                          }                              hex.Append("  ");                      }                  }              }
Magic Number,FrameWork,Log,C:\repos\WarEmu_WarEmu\FrameWork\Logs\Log.cs,Compare,The following statement contains a magic number: for (int i = 0; i < Math.Max(First.Length' Second.Length); i += 16)              {                  hex.Append("\n");                    bool LastDiff = false;                  for (int j = 0; j < 16; ++j)                  {                      if (j + i < First.Length)                      {                          if (j + i < Second.Length)                          {                              if (First[j + i] != Second[j + i] && !LastDiff)                              {                                  LastDiff = true;                                  hex.Append("[");                              }                              else if (First[j + i] == Second[j + i] && LastDiff)                              {                                  LastDiff = false;                                  hex.Append("]");                              }                          }                          else if (LastDiff)                          {                              LastDiff = false;                              hex.Append("]");                          }                                                        byte val = First[j + i];                          //hex.Append(" ");                          hex.Append(First[j + i].ToString("X2"));                          if (j == 3 || j == 7 || j == 11)                              hex.Append("");                      }                      else                      {                          hex.Append("  ");                      }                  }                  if (LastDiff)                  {                      LastDiff = false;                      hex.Append("]");                  }                    hex.Append(" || ");                    LastDiff = false;                  for (int j = 0; j < 16; ++j)                  {                      if (j + i < Second.Length)                      {                          if (j + i < First.Length)                          {                              if (First[j + i] != Second[j + i] && !LastDiff)                              {                                  LastDiff = true;                                  hex.Append("[");                              }                              else if (First[j + i] == Second[j + i] && LastDiff)                              {                                  LastDiff = false;                                  hex.Append("]");                              }                          }                          else if (LastDiff)                          {                              LastDiff = false;                              hex.Append("]");                          }                            byte val = Second[j + i];                          //hex.Append(" ");                          hex.Append(Second[j + i].ToString("X2"));                          if (j == 3 || j == 7 || j == 11)                              hex.Append("");                      }                      else                      {                          if (LastDiff)                          {                              LastDiff = false;                              hex.Append("]");                          }                              hex.Append("  ");                      }                  }              }
Magic Number,FrameWork,Log,C:\repos\WarEmu_WarEmu\FrameWork\Logs\Log.cs,Compare,The following statement contains a magic number: for (int i = 0; i < Math.Max(First.Length' Second.Length); i += 16)              {                  hex.Append("\n");                    bool LastDiff = false;                  for (int j = 0; j < 16; ++j)                  {                      if (j + i < First.Length)                      {                          if (j + i < Second.Length)                          {                              if (First[j + i] != Second[j + i] && !LastDiff)                              {                                  LastDiff = true;                                  hex.Append("[");                              }                              else if (First[j + i] == Second[j + i] && LastDiff)                              {                                  LastDiff = false;                                  hex.Append("]");                              }                          }                          else if (LastDiff)                          {                              LastDiff = false;                              hex.Append("]");                          }                                                        byte val = First[j + i];                          //hex.Append(" ");                          hex.Append(First[j + i].ToString("X2"));                          if (j == 3 || j == 7 || j == 11)                              hex.Append("");                      }                      else                      {                          hex.Append("  ");                      }                  }                  if (LastDiff)                  {                      LastDiff = false;                      hex.Append("]");                  }                    hex.Append(" || ");                    LastDiff = false;                  for (int j = 0; j < 16; ++j)                  {                      if (j + i < Second.Length)                      {                          if (j + i < First.Length)                          {                              if (First[j + i] != Second[j + i] && !LastDiff)                              {                                  LastDiff = true;                                  hex.Append("[");                              }                              else if (First[j + i] == Second[j + i] && LastDiff)                              {                                  LastDiff = false;                                  hex.Append("]");                              }                          }                          else if (LastDiff)                          {                              LastDiff = false;                              hex.Append("]");                          }                            byte val = Second[j + i];                          //hex.Append(" ");                          hex.Append(Second[j + i].ToString("X2"));                          if (j == 3 || j == 7 || j == 11)                              hex.Append("");                      }                      else                      {                          if (LastDiff)                          {                              LastDiff = false;                              hex.Append("]");                          }                              hex.Append("  ");                      }                  }              }
Magic Number,FrameWork,Log,C:\repos\WarEmu_WarEmu\FrameWork\Logs\Log.cs,Compare,The following statement contains a magic number: for (int i = 0; i < Math.Max(First.Length' Second.Length); i += 16)              {                  hex.Append("\n");                    bool LastDiff = false;                  for (int j = 0; j < 16; ++j)                  {                      if (j + i < First.Length)                      {                          if (j + i < Second.Length)                          {                              if (First[j + i] != Second[j + i] && !LastDiff)                              {                                  LastDiff = true;                                  hex.Append("[");                              }                              else if (First[j + i] == Second[j + i] && LastDiff)                              {                                  LastDiff = false;                                  hex.Append("]");                              }                          }                          else if (LastDiff)                          {                              LastDiff = false;                              hex.Append("]");                          }                                                        byte val = First[j + i];                          //hex.Append(" ");                          hex.Append(First[j + i].ToString("X2"));                          if (j == 3 || j == 7 || j == 11)                              hex.Append("");                      }                      else                      {                          hex.Append("  ");                      }                  }                  if (LastDiff)                  {                      LastDiff = false;                      hex.Append("]");                  }                    hex.Append(" || ");                    LastDiff = false;                  for (int j = 0; j < 16; ++j)                  {                      if (j + i < Second.Length)                      {                          if (j + i < First.Length)                          {                              if (First[j + i] != Second[j + i] && !LastDiff)                              {                                  LastDiff = true;                                  hex.Append("[");                              }                              else if (First[j + i] == Second[j + i] && LastDiff)                              {                                  LastDiff = false;                                  hex.Append("]");                              }                          }                          else if (LastDiff)                          {                              LastDiff = false;                              hex.Append("]");                          }                            byte val = Second[j + i];                          //hex.Append(" ");                          hex.Append(Second[j + i].ToString("X2"));                          if (j == 3 || j == 7 || j == 11)                              hex.Append("");                      }                      else                      {                          if (LastDiff)                          {                              LastDiff = false;                              hex.Append("]");                          }                              hex.Append("  ");                      }                  }              }
Magic Number,FrameWork,Log,C:\repos\WarEmu_WarEmu\FrameWork\Logs\Log.cs,Compare,The following statement contains a magic number: for (int i = 0; i < Math.Max(First.Length' Second.Length); i += 16)              {                  hex.Append("\n");                    bool LastDiff = false;                  for (int j = 0; j < 16; ++j)                  {                      if (j + i < First.Length)                      {                          if (j + i < Second.Length)                          {                              if (First[j + i] != Second[j + i] && !LastDiff)                              {                                  LastDiff = true;                                  hex.Append("[");                              }                              else if (First[j + i] == Second[j + i] && LastDiff)                              {                                  LastDiff = false;                                  hex.Append("]");                              }                          }                          else if (LastDiff)                          {                              LastDiff = false;                              hex.Append("]");                          }                                                        byte val = First[j + i];                          //hex.Append(" ");                          hex.Append(First[j + i].ToString("X2"));                          if (j == 3 || j == 7 || j == 11)                              hex.Append("");                      }                      else                      {                          hex.Append("  ");                      }                  }                  if (LastDiff)                  {                      LastDiff = false;                      hex.Append("]");                  }                    hex.Append(" || ");                    LastDiff = false;                  for (int j = 0; j < 16; ++j)                  {                      if (j + i < Second.Length)                      {                          if (j + i < First.Length)                          {                              if (First[j + i] != Second[j + i] && !LastDiff)                              {                                  LastDiff = true;                                  hex.Append("[");                              }                              else if (First[j + i] == Second[j + i] && LastDiff)                              {                                  LastDiff = false;                                  hex.Append("]");                              }                          }                          else if (LastDiff)                          {                              LastDiff = false;                              hex.Append("]");                          }                            byte val = Second[j + i];                          //hex.Append(" ");                          hex.Append(Second[j + i].ToString("X2"));                          if (j == 3 || j == 7 || j == 11)                              hex.Append("");                      }                      else                      {                          if (LastDiff)                          {                              LastDiff = false;                              hex.Append("]");                          }                              hex.Append("  ");                      }                  }              }
Magic Number,FrameWork,Log,C:\repos\WarEmu_WarEmu\FrameWork\Logs\Log.cs,Hex,The following statement contains a magic number: try              {                  int end = start + len;                  for (int i = start; i < end; i += 16)                  {                      StringBuilder text = new StringBuilder();                      StringBuilder hex = new StringBuilder();                      hex.Append("\n");                        for (int j = 0; j < 16; j++)                      {                          if (j + i < end)                          {                              byte val = dump[j + i];                              hex.Append(" ");                              hex.Append(dump[j + i].ToString("X2"));                              if (j == 3 || j == 7 || j == 11)                                  hex.Append(" ");                              if (val >= 32 && val <= 127)                              {                                  text.Append((char)val);                              }                              else                              {                                  text.Append(".");                              }                          }                          else                          {                              hex.Append("   ");                              text.Append("  ");                          }                      }                      hex.Append("  ");                      hex.Append("//"+text.ToString());                      hexDump.Append(hex.ToString());                  }              }              catch (Exception e)              {                  Log.Error("HexDump"' e.ToString());              }
Magic Number,FrameWork,Log,C:\repos\WarEmu_WarEmu\FrameWork\Logs\Log.cs,Hex,The following statement contains a magic number: try              {                  int end = start + len;                  for (int i = start; i < end; i += 16)                  {                      StringBuilder text = new StringBuilder();                      StringBuilder hex = new StringBuilder();                      hex.Append("\n");                        for (int j = 0; j < 16; j++)                      {                          if (j + i < end)                          {                              byte val = dump[j + i];                              hex.Append(" ");                              hex.Append(dump[j + i].ToString("X2"));                              if (j == 3 || j == 7 || j == 11)                                  hex.Append(" ");                              if (val >= 32 && val <= 127)                              {                                  text.Append((char)val);                              }                              else                              {                                  text.Append(".");                              }                          }                          else                          {                              hex.Append("   ");                              text.Append("  ");                          }                      }                      hex.Append("  ");                      hex.Append("//"+text.ToString());                      hexDump.Append(hex.ToString());                  }              }              catch (Exception e)              {                  Log.Error("HexDump"' e.ToString());              }
Magic Number,FrameWork,Log,C:\repos\WarEmu_WarEmu\FrameWork\Logs\Log.cs,Hex,The following statement contains a magic number: try              {                  int end = start + len;                  for (int i = start; i < end; i += 16)                  {                      StringBuilder text = new StringBuilder();                      StringBuilder hex = new StringBuilder();                      hex.Append("\n");                        for (int j = 0; j < 16; j++)                      {                          if (j + i < end)                          {                              byte val = dump[j + i];                              hex.Append(" ");                              hex.Append(dump[j + i].ToString("X2"));                              if (j == 3 || j == 7 || j == 11)                                  hex.Append(" ");                              if (val >= 32 && val <= 127)                              {                                  text.Append((char)val);                              }                              else                              {                                  text.Append(".");                              }                          }                          else                          {                              hex.Append("   ");                              text.Append("  ");                          }                      }                      hex.Append("  ");                      hex.Append("//"+text.ToString());                      hexDump.Append(hex.ToString());                  }              }              catch (Exception e)              {                  Log.Error("HexDump"' e.ToString());              }
Magic Number,FrameWork,Log,C:\repos\WarEmu_WarEmu\FrameWork\Logs\Log.cs,Hex,The following statement contains a magic number: try              {                  int end = start + len;                  for (int i = start; i < end; i += 16)                  {                      StringBuilder text = new StringBuilder();                      StringBuilder hex = new StringBuilder();                      hex.Append("\n");                        for (int j = 0; j < 16; j++)                      {                          if (j + i < end)                          {                              byte val = dump[j + i];                              hex.Append(" ");                              hex.Append(dump[j + i].ToString("X2"));                              if (j == 3 || j == 7 || j == 11)                                  hex.Append(" ");                              if (val >= 32 && val <= 127)                              {                                  text.Append((char)val);                              }                              else                              {                                  text.Append(".");                              }                          }                          else                          {                              hex.Append("   ");                              text.Append("  ");                          }                      }                      hex.Append("  ");                      hex.Append("//"+text.ToString());                      hexDump.Append(hex.ToString());                  }              }              catch (Exception e)              {                  Log.Error("HexDump"' e.ToString());              }
Magic Number,FrameWork,Log,C:\repos\WarEmu_WarEmu\FrameWork\Logs\Log.cs,Hex,The following statement contains a magic number: try              {                  int end = start + len;                  for (int i = start; i < end; i += 16)                  {                      StringBuilder text = new StringBuilder();                      StringBuilder hex = new StringBuilder();                      hex.Append("\n");                        for (int j = 0; j < 16; j++)                      {                          if (j + i < end)                          {                              byte val = dump[j + i];                              hex.Append(" ");                              hex.Append(dump[j + i].ToString("X2"));                              if (j == 3 || j == 7 || j == 11)                                  hex.Append(" ");                              if (val >= 32 && val <= 127)                              {                                  text.Append((char)val);                              }                              else                              {                                  text.Append(".");                              }                          }                          else                          {                              hex.Append("   ");                              text.Append("  ");                          }                      }                      hex.Append("  ");                      hex.Append("//"+text.ToString());                      hexDump.Append(hex.ToString());                  }              }              catch (Exception e)              {                  Log.Error("HexDump"' e.ToString());              }
Magic Number,FrameWork,Log,C:\repos\WarEmu_WarEmu\FrameWork\Logs\Log.cs,Hex,The following statement contains a magic number: try              {                  int end = start + len;                  for (int i = start; i < end; i += 16)                  {                      StringBuilder text = new StringBuilder();                      StringBuilder hex = new StringBuilder();                      hex.Append("\n");                        for (int j = 0; j < 16; j++)                      {                          if (j + i < end)                          {                              byte val = dump[j + i];                              hex.Append(" ");                              hex.Append(dump[j + i].ToString("X2"));                              if (j == 3 || j == 7 || j == 11)                                  hex.Append(" ");                              if (val >= 32 && val <= 127)                              {                                  text.Append((char)val);                              }                              else                              {                                  text.Append(".");                              }                          }                          else                          {                              hex.Append("   ");                              text.Append("  ");                          }                      }                      hex.Append("  ");                      hex.Append("//"+text.ToString());                      hexDump.Append(hex.ToString());                  }              }              catch (Exception e)              {                  Log.Error("HexDump"' e.ToString());              }
Magic Number,FrameWork,Log,C:\repos\WarEmu_WarEmu\FrameWork\Logs\Log.cs,Hex,The following statement contains a magic number: try              {                  int end = start + len;                  for (int i = start; i < end; i += 16)                  {                      StringBuilder text = new StringBuilder();                      StringBuilder hex = new StringBuilder();                      hex.Append("\n");                        for (int j = 0; j < 16; j++)                      {                          if (j + i < end)                          {                              byte val = dump[j + i];                              hex.Append(" ");                              hex.Append(dump[j + i].ToString("X2"));                              if (j == 3 || j == 7 || j == 11)                                  hex.Append(" ");                              if (val >= 32 && val <= 127)                              {                                  text.Append((char)val);                              }                              else                              {                                  text.Append(".");                              }                          }                          else                          {                              hex.Append("   ");                              text.Append("  ");                          }                      }                      hex.Append("  ");                      hex.Append("//"+text.ToString());                      hexDump.Append(hex.ToString());                  }              }              catch (Exception e)              {                  Log.Error("HexDump"' e.ToString());              }
Magic Number,FrameWork,BaseClient,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\BaseClient.cs,SendTCP,The following statement contains a magic number: if (Socket.Connected)  			{  				try  				{  					lock (m_tcpQueue)  					{  						if (m_sendingTcp)  						{  							m_tcpQueue.Enqueue(buf);  							return;  						}  						  						m_sendingTcp = true;  					}                        if (m_crypts.Count <= 0)                          Log.Tcp("SendTCP"' buf' 0' buf.Length);                      else                          Log.Tcp("Crypted"' buf' 0' buf.Length);    					Buffer.BlockCopy(buf' 0' m_tcpSendBuffer' 0' buf.Length);    					int start = Environment.TickCount;    					Socket.BeginSend(m_tcpSendBuffer' 0' buf.Length' SocketFlags.None' m_asyncTcpCallback' this);    					int took = Environment.TickCount - start;  					if (took > 100)  						Log.Notice("BaseClient"'"SendTCP.BeginSend took "+ took);  				}  				catch (Exception e)  				{  					// assure that no exception is thrown into the upper layers and interrupt game loops!                      Log.Error("BaseClient"' "SendTCP : " + e.ToString());  	    			_srvr.Disconnect(this);  				}  			}
Magic Number,FrameWork,PacketIn,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketIn.cs,GetUint64,The following statement contains a magic number: UInt64 value = (GetUint32() << 24) + (GetUint32());
Magic Number,FrameWork,PacketIn,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketIn.cs,GetUint64R,The following statement contains a magic number: UInt64 value = (GetUint32()) + (GetUint32() << 24);
Magic Number,FrameWork,PacketIn,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketIn.cs,GetInt64,The following statement contains a magic number: byte[] tmp = Read(8);
Magic Number,FrameWork,PacketIn,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketIn.cs,GetInt64R,The following statement contains a magic number: byte[] tmp = Read(8);
Magic Number,FrameWork,PacketIn,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketIn.cs,GetFloat,The following statement contains a magic number: byte[] b = new byte[4];
Magic Number,FrameWork,PacketIn,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketIn.cs,GetFloat,The following statement contains a magic number: b[2] = (byte)ReadByte();
Magic Number,FrameWork,PacketIn,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketIn.cs,GetFloat,The following statement contains a magic number: b[3] = (byte)ReadByte();
Magic Number,FrameWork,PacketIn,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketIn.cs,ReadPs,The following statement contains a magic number: if (Length >= Position + 2)                  return BitConverter.ToChar(new byte[] { GetUint8()' GetUint8() }' 0);
Magic Number,FrameWork,PacketIn,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketIn.cs,DecodeMythicSize,The following statement contains a magic number: while ((mByte & 0x80) == 0x80)              {                  //Log.Debug("readSize"' "mByte = " + mByte);                  mByte ^= 0x80;                  mSize = (mSize | (mByte << (7 * mByteCount)));                    if (Length == Capacity)                      return 0;                      mByte = ReadByte();                  mByteCount++;              }
Magic Number,FrameWork,PacketIn,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketIn.cs,DecodeMythicSize,The following statement contains a magic number: mSize = (mSize | (mByte << (7 * mByteCount)));
Magic Number,FrameWork,PacketIn,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketIn.cs,DecryptMythicRC4,The following statement contains a magic number: try              {                  byte[] Packet = new byte[Length];                  Read(Packet' (int)Position' Packet.Length);                    int x' y' midpoint' pos;                  byte tmp = 0;                    x = y = 0;                    midpoint = Packet.Length / 2;                    for (pos = midpoint; pos < Packet.Length; ++pos)                  {                      x = (x + 1) & 255;                      y = (y + Key[x]) & 255;                        tmp = Key[x];                        Key[x] = Key[y];                      Key[y] = tmp;                        tmp = (byte)(( Key[x] + Key[y] ) & 255);                      Packet[pos] ^= Key[tmp];                      y = (y + Packet[pos]) & 255;                  }                    for (pos = 0; pos < midpoint; ++pos)                  {                      x = (x + 1) & 255;                      y = (y + Key[x]) & 255;                        tmp = Key[x];                        Key[x] = Key[y];                      Key[y] = tmp;                        tmp = (byte)((Key[x] + Key[y]) & 255);                      Packet[pos] ^= Key[tmp];                      y = (y + Packet[pos]) & 255;                   }                    return new PacketIn(Packet'0'Packet.Length);              }              catch(Exception e)              {                  Log.Error("PacketIn"'"DecryptMythicRC4 : Failled !" + e.ToString());              }
Magic Number,FrameWork,PacketIn,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketIn.cs,DecryptMythicRC4,The following statement contains a magic number: try              {                  byte[] Packet = new byte[Length];                  Read(Packet' (int)Position' Packet.Length);                    int x' y' midpoint' pos;                  byte tmp = 0;                    x = y = 0;                    midpoint = Packet.Length / 2;                    for (pos = midpoint; pos < Packet.Length; ++pos)                  {                      x = (x + 1) & 255;                      y = (y + Key[x]) & 255;                        tmp = Key[x];                        Key[x] = Key[y];                      Key[y] = tmp;                        tmp = (byte)(( Key[x] + Key[y] ) & 255);                      Packet[pos] ^= Key[tmp];                      y = (y + Packet[pos]) & 255;                  }                    for (pos = 0; pos < midpoint; ++pos)                  {                      x = (x + 1) & 255;                      y = (y + Key[x]) & 255;                        tmp = Key[x];                        Key[x] = Key[y];                      Key[y] = tmp;                        tmp = (byte)((Key[x] + Key[y]) & 255);                      Packet[pos] ^= Key[tmp];                      y = (y + Packet[pos]) & 255;                   }                    return new PacketIn(Packet'0'Packet.Length);              }              catch(Exception e)              {                  Log.Error("PacketIn"'"DecryptMythicRC4 : Failled !" + e.ToString());              }
Magic Number,FrameWork,PacketIn,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketIn.cs,DecryptMythicRC4,The following statement contains a magic number: try              {                  byte[] Packet = new byte[Length];                  Read(Packet' (int)Position' Packet.Length);                    int x' y' midpoint' pos;                  byte tmp = 0;                    x = y = 0;                    midpoint = Packet.Length / 2;                    for (pos = midpoint; pos < Packet.Length; ++pos)                  {                      x = (x + 1) & 255;                      y = (y + Key[x]) & 255;                        tmp = Key[x];                        Key[x] = Key[y];                      Key[y] = tmp;                        tmp = (byte)(( Key[x] + Key[y] ) & 255);                      Packet[pos] ^= Key[tmp];                      y = (y + Packet[pos]) & 255;                  }                    for (pos = 0; pos < midpoint; ++pos)                  {                      x = (x + 1) & 255;                      y = (y + Key[x]) & 255;                        tmp = Key[x];                        Key[x] = Key[y];                      Key[y] = tmp;                        tmp = (byte)((Key[x] + Key[y]) & 255);                      Packet[pos] ^= Key[tmp];                      y = (y + Packet[pos]) & 255;                   }                    return new PacketIn(Packet'0'Packet.Length);              }              catch(Exception e)              {                  Log.Error("PacketIn"'"DecryptMythicRC4 : Failled !" + e.ToString());              }
Magic Number,FrameWork,PacketIn,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketIn.cs,DecryptMythicRC4,The following statement contains a magic number: try              {                  byte[] Packet = new byte[Length];                  Read(Packet' (int)Position' Packet.Length);                    int x' y' midpoint' pos;                  byte tmp = 0;                    x = y = 0;                    midpoint = Packet.Length / 2;                    for (pos = midpoint; pos < Packet.Length; ++pos)                  {                      x = (x + 1) & 255;                      y = (y + Key[x]) & 255;                        tmp = Key[x];                        Key[x] = Key[y];                      Key[y] = tmp;                        tmp = (byte)(( Key[x] + Key[y] ) & 255);                      Packet[pos] ^= Key[tmp];                      y = (y + Packet[pos]) & 255;                  }                    for (pos = 0; pos < midpoint; ++pos)                  {                      x = (x + 1) & 255;                      y = (y + Key[x]) & 255;                        tmp = Key[x];                        Key[x] = Key[y];                      Key[y] = tmp;                        tmp = (byte)((Key[x] + Key[y]) & 255);                      Packet[pos] ^= Key[tmp];                      y = (y + Packet[pos]) & 255;                   }                    return new PacketIn(Packet'0'Packet.Length);              }              catch(Exception e)              {                  Log.Error("PacketIn"'"DecryptMythicRC4 : Failled !" + e.ToString());              }
Magic Number,FrameWork,PacketIn,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketIn.cs,DecryptMythicRC4,The following statement contains a magic number: try              {                  byte[] Packet = new byte[Length];                  Read(Packet' (int)Position' Packet.Length);                    int x' y' midpoint' pos;                  byte tmp = 0;                    x = y = 0;                    midpoint = Packet.Length / 2;                    for (pos = midpoint; pos < Packet.Length; ++pos)                  {                      x = (x + 1) & 255;                      y = (y + Key[x]) & 255;                        tmp = Key[x];                        Key[x] = Key[y];                      Key[y] = tmp;                        tmp = (byte)(( Key[x] + Key[y] ) & 255);                      Packet[pos] ^= Key[tmp];                      y = (y + Packet[pos]) & 255;                  }                    for (pos = 0; pos < midpoint; ++pos)                  {                      x = (x + 1) & 255;                      y = (y + Key[x]) & 255;                        tmp = Key[x];                        Key[x] = Key[y];                      Key[y] = tmp;                        tmp = (byte)((Key[x] + Key[y]) & 255);                      Packet[pos] ^= Key[tmp];                      y = (y + Packet[pos]) & 255;                   }                    return new PacketIn(Packet'0'Packet.Length);              }              catch(Exception e)              {                  Log.Error("PacketIn"'"DecryptMythicRC4 : Failled !" + e.ToString());              }
Magic Number,FrameWork,PacketIn,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketIn.cs,DecryptMythicRC4,The following statement contains a magic number: try              {                  byte[] Packet = new byte[Length];                  Read(Packet' (int)Position' Packet.Length);                    int x' y' midpoint' pos;                  byte tmp = 0;                    x = y = 0;                    midpoint = Packet.Length / 2;                    for (pos = midpoint; pos < Packet.Length; ++pos)                  {                      x = (x + 1) & 255;                      y = (y + Key[x]) & 255;                        tmp = Key[x];                        Key[x] = Key[y];                      Key[y] = tmp;                        tmp = (byte)(( Key[x] + Key[y] ) & 255);                      Packet[pos] ^= Key[tmp];                      y = (y + Packet[pos]) & 255;                  }                    for (pos = 0; pos < midpoint; ++pos)                  {                      x = (x + 1) & 255;                      y = (y + Key[x]) & 255;                        tmp = Key[x];                        Key[x] = Key[y];                      Key[y] = tmp;                        tmp = (byte)((Key[x] + Key[y]) & 255);                      Packet[pos] ^= Key[tmp];                      y = (y + Packet[pos]) & 255;                   }                    return new PacketIn(Packet'0'Packet.Length);              }              catch(Exception e)              {                  Log.Error("PacketIn"'"DecryptMythicRC4 : Failled !" + e.ToString());              }
Magic Number,FrameWork,PacketIn,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketIn.cs,DecryptMythicRC4,The following statement contains a magic number: try              {                  byte[] Packet = new byte[Length];                  Read(Packet' (int)Position' Packet.Length);                    int x' y' midpoint' pos;                  byte tmp = 0;                    x = y = 0;                    midpoint = Packet.Length / 2;                    for (pos = midpoint; pos < Packet.Length; ++pos)                  {                      x = (x + 1) & 255;                      y = (y + Key[x]) & 255;                        tmp = Key[x];                        Key[x] = Key[y];                      Key[y] = tmp;                        tmp = (byte)(( Key[x] + Key[y] ) & 255);                      Packet[pos] ^= Key[tmp];                      y = (y + Packet[pos]) & 255;                  }                    for (pos = 0; pos < midpoint; ++pos)                  {                      x = (x + 1) & 255;                      y = (y + Key[x]) & 255;                        tmp = Key[x];                        Key[x] = Key[y];                      Key[y] = tmp;                        tmp = (byte)((Key[x] + Key[y]) & 255);                      Packet[pos] ^= Key[tmp];                      y = (y + Packet[pos]) & 255;                   }                    return new PacketIn(Packet'0'Packet.Length);              }              catch(Exception e)              {                  Log.Error("PacketIn"'"DecryptMythicRC4 : Failled !" + e.ToString());              }
Magic Number,FrameWork,PacketIn,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketIn.cs,DecryptMythicRC4,The following statement contains a magic number: try              {                  byte[] Packet = new byte[Length];                  Read(Packet' (int)Position' Packet.Length);                    int x' y' midpoint' pos;                  byte tmp = 0;                    x = y = 0;                    midpoint = Packet.Length / 2;                    for (pos = midpoint; pos < Packet.Length; ++pos)                  {                      x = (x + 1) & 255;                      y = (y + Key[x]) & 255;                        tmp = Key[x];                        Key[x] = Key[y];                      Key[y] = tmp;                        tmp = (byte)(( Key[x] + Key[y] ) & 255);                      Packet[pos] ^= Key[tmp];                      y = (y + Packet[pos]) & 255;                  }                    for (pos = 0; pos < midpoint; ++pos)                  {                      x = (x + 1) & 255;                      y = (y + Key[x]) & 255;                        tmp = Key[x];                        Key[x] = Key[y];                      Key[y] = tmp;                        tmp = (byte)((Key[x] + Key[y]) & 255);                      Packet[pos] ^= Key[tmp];                      y = (y + Packet[pos]) & 255;                   }                    return new PacketIn(Packet'0'Packet.Length);              }              catch(Exception e)              {                  Log.Error("PacketIn"'"DecryptMythicRC4 : Failled !" + e.ToString());              }
Magic Number,FrameWork,PacketIn,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketIn.cs,DecryptMythicRC4,The following statement contains a magic number: try              {                  byte[] Packet = new byte[Length];                  Read(Packet' (int)Position' Packet.Length);                    int x' y' midpoint' pos;                  byte tmp = 0;                    x = y = 0;                    midpoint = Packet.Length / 2;                    for (pos = midpoint; pos < Packet.Length; ++pos)                  {                      x = (x + 1) & 255;                      y = (y + Key[x]) & 255;                        tmp = Key[x];                        Key[x] = Key[y];                      Key[y] = tmp;                        tmp = (byte)(( Key[x] + Key[y] ) & 255);                      Packet[pos] ^= Key[tmp];                      y = (y + Packet[pos]) & 255;                  }                    for (pos = 0; pos < midpoint; ++pos)                  {                      x = (x + 1) & 255;                      y = (y + Key[x]) & 255;                        tmp = Key[x];                        Key[x] = Key[y];                      Key[y] = tmp;                        tmp = (byte)((Key[x] + Key[y]) & 255);                      Packet[pos] ^= Key[tmp];                      y = (y + Packet[pos]) & 255;                   }                    return new PacketIn(Packet'0'Packet.Length);              }              catch(Exception e)              {                  Log.Error("PacketIn"'"DecryptMythicRC4 : Failled !" + e.ToString());              }
Magic Number,FrameWork,PacketIn,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketIn.cs,DecodeGamebryoSize,The following statement contains a magic number: if (Size >= 128)                  Size += ((GetUint8() - 1) * 128) + 2;
Magic Number,FrameWork,PacketIn,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketIn.cs,DecodeGamebryoSize,The following statement contains a magic number: if (Size >= 128)                  Size += ((GetUint8() - 1) * 128) + 2;
Magic Number,FrameWork,PacketIn,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketIn.cs,DecodeGamebryoSize,The following statement contains a magic number: if (Size >= 128)                  Size += ((GetUint8() - 1) * 128) + 2;
Magic Number,FrameWork,PacketOut,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,WriteUInt16,The following statement contains a magic number: WriteByte((byte)(val >> 8));
Magic Number,FrameWork,PacketOut,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,WriteUInt16R,The following statement contains a magic number: WriteByte((byte)(val >> 8));
Magic Number,FrameWork,PacketOut,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,WriteUInt32,The following statement contains a magic number: WriteByte((byte)(val >> 24));
Magic Number,FrameWork,PacketOut,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,WriteUInt32,The following statement contains a magic number: WriteByte((byte)((val >> 16) & 0xff));
Magic Number,FrameWork,PacketOut,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,WriteUInt32,The following statement contains a magic number: WriteByte((byte)((val & 0xffff) >> 8));
Magic Number,FrameWork,PacketOut,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,WriteUInt32R,The following statement contains a magic number: WriteByte((byte)((val & 0xffff) >> 8));
Magic Number,FrameWork,PacketOut,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,WriteUInt32R,The following statement contains a magic number: WriteByte((byte)((val >> 16) & 0xff));
Magic Number,FrameWork,PacketOut,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,WriteUInt32R,The following statement contains a magic number: WriteByte((byte)(val >> 24));
Magic Number,FrameWork,PacketOut,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,WriteUInt64,The following statement contains a magic number: WriteByte((byte)(val >> 56));
Magic Number,FrameWork,PacketOut,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,WriteUInt64,The following statement contains a magic number: WriteByte((byte)((val >> 48) & 0xff));
Magic Number,FrameWork,PacketOut,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,WriteUInt64,The following statement contains a magic number: WriteByte((byte)((val >> 40) & 0xff));
Magic Number,FrameWork,PacketOut,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,WriteUInt64,The following statement contains a magic number: WriteByte((byte)((val >> 32) & 0xff));
Magic Number,FrameWork,PacketOut,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,WriteUInt64,The following statement contains a magic number: WriteByte((byte)((val >> 24) & 0xff));
Magic Number,FrameWork,PacketOut,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,WriteUInt64,The following statement contains a magic number: WriteByte((byte)((val >> 16) & 0xff));
Magic Number,FrameWork,PacketOut,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,WriteUInt64,The following statement contains a magic number: WriteByte((byte)((val >> 8) & 0xff));
Magic Number,FrameWork,PacketOut,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,WriteUInt64R,The following statement contains a magic number: WriteByte((byte)((val >> 8) & 0xff));
Magic Number,FrameWork,PacketOut,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,WriteUInt64R,The following statement contains a magic number: WriteByte((byte)((val >> 16) & 0xff));
Magic Number,FrameWork,PacketOut,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,WriteUInt64R,The following statement contains a magic number: WriteByte((byte)((val >> 24) & 0xff));
Magic Number,FrameWork,PacketOut,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,WriteUInt64R,The following statement contains a magic number: WriteByte((byte)((val >> 32) & 0xff));
Magic Number,FrameWork,PacketOut,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,WriteUInt64R,The following statement contains a magic number: WriteByte((byte)((val >> 40) & 0xff));
Magic Number,FrameWork,PacketOut,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,WriteUInt64R,The following statement contains a magic number: WriteByte((byte)((val >> 48) & 0xff));
Magic Number,FrameWork,PacketOut,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,WriteUInt64R,The following statement contains a magic number: WriteByte((byte)(val >> 56));
Magic Number,FrameWork,PacketOut,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,GetChecksum,The following statement contains a magic number: for (int i = 0; i < Position - 6; ++i)                  val += buf[i + 8];
Magic Number,FrameWork,PacketOut,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,GetChecksum,The following statement contains a magic number: for (int i = 0; i < Position - 6; ++i)                  val += buf[i + 8];
Magic Number,FrameWork,PacketOut,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,WriteHexStringBytes,The following statement contains a magic number: int length = hexString.Length / 2;
Magic Number,FrameWork,PacketOut,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,WriteHexStringBytes,The following statement contains a magic number: if ((hexString.Length % 2) == 0)              {                  for (int i = 0; i < length; i++)                      WriteByte(Convert.ToByte(hexString.Substring(i * 2' 2)' 16));              }              else              {                  WriteByte(0);              }
Magic Number,FrameWork,PacketOut,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,WriteHexStringBytes,The following statement contains a magic number: if ((hexString.Length % 2) == 0)              {                  for (int i = 0; i < length; i++)                      WriteByte(Convert.ToByte(hexString.Substring(i * 2' 2)' 16));              }              else              {                  WriteByte(0);              }
Magic Number,FrameWork,PacketOut,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,WriteHexStringBytes,The following statement contains a magic number: if ((hexString.Length % 2) == 0)              {                  for (int i = 0; i < length; i++)                      WriteByte(Convert.ToByte(hexString.Substring(i * 2' 2)' 16));              }              else              {                  WriteByte(0);              }
Magic Number,FrameWork,PacketOut,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,WriteHexStringBytes,The following statement contains a magic number: if ((hexString.Length % 2) == 0)              {                  for (int i = 0; i < length; i++)                      WriteByte(Convert.ToByte(hexString.Substring(i * 2' 2)' 16));              }              else              {                  WriteByte(0);              }
Magic Number,FrameWork,PacketOut,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,WritePacketString,The following statement contains a magic number: using (StringReader Reader = new StringReader(packet))              {                  string Line;                  while ((Line = Reader.ReadLine()) != null)                  {                      WriteHexStringBytes(Line.Substring(1' Line.IndexOf("|"' 2)-1));                  }              }
Magic Number,FrameWork,PacketOut,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,EncryptMythicRC4,The following statement contains a magic number: try              {                  int x' y' midpoint' pos;                  byte tmp = 0;                    x = y = 0;                    midpoint = Packet.Length / 2;                    for (pos = midpoint; pos < Packet.Length; ++pos)                  {                      x = (x + 1) & 255;                      y = (y + Key[x]) & 255;                        tmp = Key[x];                        Key[x] = Key[y];                      Key[y] = tmp;                        tmp = (byte)((Key[x] + Key[y]) & 255);                       y = (y + Packet[pos]) & 255;                      Packet[pos] ^= Key[tmp];                                       }                    for (pos = 0; pos < midpoint; ++pos)                  {                      x = (x + 1) & 255;                      y = (y + Key[x]) & 255;                        tmp = Key[x];                        Key[x] = Key[y];                      Key[y] = tmp;                        tmp = (byte)((Key[x] + Key[y]) & 255);                      y = (y + Packet[pos]) & 255;                      Packet[pos] ^= Key[tmp];                  }                    return Packet;              }              catch (Exception e)              {                  Log.Error("PacketOut"' "EncryptMythicRC4 : Failled !"+e.ToString());              }
Magic Number,FrameWork,PacketOut,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,EncryptMythicRC4,The following statement contains a magic number: try              {                  int x' y' midpoint' pos;                  byte tmp = 0;                    x = y = 0;                    midpoint = Packet.Length / 2;                    for (pos = midpoint; pos < Packet.Length; ++pos)                  {                      x = (x + 1) & 255;                      y = (y + Key[x]) & 255;                        tmp = Key[x];                        Key[x] = Key[y];                      Key[y] = tmp;                        tmp = (byte)((Key[x] + Key[y]) & 255);                       y = (y + Packet[pos]) & 255;                      Packet[pos] ^= Key[tmp];                                       }                    for (pos = 0; pos < midpoint; ++pos)                  {                      x = (x + 1) & 255;                      y = (y + Key[x]) & 255;                        tmp = Key[x];                        Key[x] = Key[y];                      Key[y] = tmp;                        tmp = (byte)((Key[x] + Key[y]) & 255);                      y = (y + Packet[pos]) & 255;                      Packet[pos] ^= Key[tmp];                  }                    return Packet;              }              catch (Exception e)              {                  Log.Error("PacketOut"' "EncryptMythicRC4 : Failled !"+e.ToString());              }
Magic Number,FrameWork,PacketOut,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,EncryptMythicRC4,The following statement contains a magic number: try              {                  int x' y' midpoint' pos;                  byte tmp = 0;                    x = y = 0;                    midpoint = Packet.Length / 2;                    for (pos = midpoint; pos < Packet.Length; ++pos)                  {                      x = (x + 1) & 255;                      y = (y + Key[x]) & 255;                        tmp = Key[x];                        Key[x] = Key[y];                      Key[y] = tmp;                        tmp = (byte)((Key[x] + Key[y]) & 255);                       y = (y + Packet[pos]) & 255;                      Packet[pos] ^= Key[tmp];                                       }                    for (pos = 0; pos < midpoint; ++pos)                  {                      x = (x + 1) & 255;                      y = (y + Key[x]) & 255;                        tmp = Key[x];                        Key[x] = Key[y];                      Key[y] = tmp;                        tmp = (byte)((Key[x] + Key[y]) & 255);                      y = (y + Packet[pos]) & 255;                      Packet[pos] ^= Key[tmp];                  }                    return Packet;              }              catch (Exception e)              {                  Log.Error("PacketOut"' "EncryptMythicRC4 : Failled !"+e.ToString());              }
Magic Number,FrameWork,PacketOut,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,EncryptMythicRC4,The following statement contains a magic number: try              {                  int x' y' midpoint' pos;                  byte tmp = 0;                    x = y = 0;                    midpoint = Packet.Length / 2;                    for (pos = midpoint; pos < Packet.Length; ++pos)                  {                      x = (x + 1) & 255;                      y = (y + Key[x]) & 255;                        tmp = Key[x];                        Key[x] = Key[y];                      Key[y] = tmp;                        tmp = (byte)((Key[x] + Key[y]) & 255);                       y = (y + Packet[pos]) & 255;                      Packet[pos] ^= Key[tmp];                                       }                    for (pos = 0; pos < midpoint; ++pos)                  {                      x = (x + 1) & 255;                      y = (y + Key[x]) & 255;                        tmp = Key[x];                        Key[x] = Key[y];                      Key[y] = tmp;                        tmp = (byte)((Key[x] + Key[y]) & 255);                      y = (y + Packet[pos]) & 255;                      Packet[pos] ^= Key[tmp];                  }                    return Packet;              }              catch (Exception e)              {                  Log.Error("PacketOut"' "EncryptMythicRC4 : Failled !"+e.ToString());              }
Magic Number,FrameWork,PacketOut,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,EncryptMythicRC4,The following statement contains a magic number: try              {                  int x' y' midpoint' pos;                  byte tmp = 0;                    x = y = 0;                    midpoint = Packet.Length / 2;                    for (pos = midpoint; pos < Packet.Length; ++pos)                  {                      x = (x + 1) & 255;                      y = (y + Key[x]) & 255;                        tmp = Key[x];                        Key[x] = Key[y];                      Key[y] = tmp;                        tmp = (byte)((Key[x] + Key[y]) & 255);                       y = (y + Packet[pos]) & 255;                      Packet[pos] ^= Key[tmp];                                       }                    for (pos = 0; pos < midpoint; ++pos)                  {                      x = (x + 1) & 255;                      y = (y + Key[x]) & 255;                        tmp = Key[x];                        Key[x] = Key[y];                      Key[y] = tmp;                        tmp = (byte)((Key[x] + Key[y]) & 255);                      y = (y + Packet[pos]) & 255;                      Packet[pos] ^= Key[tmp];                  }                    return Packet;              }              catch (Exception e)              {                  Log.Error("PacketOut"' "EncryptMythicRC4 : Failled !"+e.ToString());              }
Magic Number,FrameWork,PacketOut,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,EncryptMythicRC4,The following statement contains a magic number: try              {                  int x' y' midpoint' pos;                  byte tmp = 0;                    x = y = 0;                    midpoint = Packet.Length / 2;                    for (pos = midpoint; pos < Packet.Length; ++pos)                  {                      x = (x + 1) & 255;                      y = (y + Key[x]) & 255;                        tmp = Key[x];                        Key[x] = Key[y];                      Key[y] = tmp;                        tmp = (byte)((Key[x] + Key[y]) & 255);                       y = (y + Packet[pos]) & 255;                      Packet[pos] ^= Key[tmp];                                       }                    for (pos = 0; pos < midpoint; ++pos)                  {                      x = (x + 1) & 255;                      y = (y + Key[x]) & 255;                        tmp = Key[x];                        Key[x] = Key[y];                      Key[y] = tmp;                        tmp = (byte)((Key[x] + Key[y]) & 255);                      y = (y + Packet[pos]) & 255;                      Packet[pos] ^= Key[tmp];                  }                    return Packet;              }              catch (Exception e)              {                  Log.Error("PacketOut"' "EncryptMythicRC4 : Failled !"+e.ToString());              }
Magic Number,FrameWork,PacketOut,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,EncryptMythicRC4,The following statement contains a magic number: try              {                  int x' y' midpoint' pos;                  byte tmp = 0;                    x = y = 0;                    midpoint = Packet.Length / 2;                    for (pos = midpoint; pos < Packet.Length; ++pos)                  {                      x = (x + 1) & 255;                      y = (y + Key[x]) & 255;                        tmp = Key[x];                        Key[x] = Key[y];                      Key[y] = tmp;                        tmp = (byte)((Key[x] + Key[y]) & 255);                       y = (y + Packet[pos]) & 255;                      Packet[pos] ^= Key[tmp];                                       }                    for (pos = 0; pos < midpoint; ++pos)                  {                      x = (x + 1) & 255;                      y = (y + Key[x]) & 255;                        tmp = Key[x];                        Key[x] = Key[y];                      Key[y] = tmp;                        tmp = (byte)((Key[x] + Key[y]) & 255);                      y = (y + Packet[pos]) & 255;                      Packet[pos] ^= Key[tmp];                  }                    return Packet;              }              catch (Exception e)              {                  Log.Error("PacketOut"' "EncryptMythicRC4 : Failled !"+e.ToString());              }
Magic Number,FrameWork,PacketOut,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,EncryptMythicRC4,The following statement contains a magic number: try              {                  int x' y' midpoint' pos;                  byte tmp = 0;                    x = y = 0;                    midpoint = Packet.Length / 2;                    for (pos = midpoint; pos < Packet.Length; ++pos)                  {                      x = (x + 1) & 255;                      y = (y + Key[x]) & 255;                        tmp = Key[x];                        Key[x] = Key[y];                      Key[y] = tmp;                        tmp = (byte)((Key[x] + Key[y]) & 255);                       y = (y + Packet[pos]) & 255;                      Packet[pos] ^= Key[tmp];                                       }                    for (pos = 0; pos < midpoint; ++pos)                  {                      x = (x + 1) & 255;                      y = (y + Key[x]) & 255;                        tmp = Key[x];                        Key[x] = Key[y];                      Key[y] = tmp;                        tmp = (byte)((Key[x] + Key[y]) & 255);                      y = (y + Packet[pos]) & 255;                      Packet[pos] ^= Key[tmp];                  }                    return Packet;              }              catch (Exception e)              {                  Log.Error("PacketOut"' "EncryptMythicRC4 : Failled !"+e.ToString());              }
Magic Number,FrameWork,PacketOut,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,EncryptMythicRC4,The following statement contains a magic number: try              {                  int x' y' midpoint' pos;                  byte tmp = 0;                    x = y = 0;                    midpoint = Packet.Length / 2;                    for (pos = midpoint; pos < Packet.Length; ++pos)                  {                      x = (x + 1) & 255;                      y = (y + Key[x]) & 255;                        tmp = Key[x];                        Key[x] = Key[y];                      Key[y] = tmp;                        tmp = (byte)((Key[x] + Key[y]) & 255);                       y = (y + Packet[pos]) & 255;                      Packet[pos] ^= Key[tmp];                                       }                    for (pos = 0; pos < midpoint; ++pos)                  {                      x = (x + 1) & 255;                      y = (y + Key[x]) & 255;                        tmp = Key[x];                        Key[x] = Key[y];                      Key[y] = tmp;                        tmp = (byte)((Key[x] + Key[y]) & 255);                      y = (y + Packet[pos]) & 255;                      Packet[pos] ^= Key[tmp];                  }                    return Packet;              }              catch (Exception e)              {                  Log.Error("PacketOut"' "EncryptMythicRC4 : Failled !"+e.ToString());              }
Magic Number,FrameWork,PacketOut,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,WriteGamebryoSize,The following statement contains a magic number: if (Total.Length - 1 < 0x80)                  WriteByte((byte)(Total.Length));              else              {                  int Size = Total.Length;                  int Offset = 1;                    while (Size >= (128*2))                  {                      Size -= 128;                      ++Offset;                  }                    WriteByte((byte)Size);                  WriteByte((byte)Offset);              }
Magic Number,FrameWork,PacketOut,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,WriteGamebryoSize,The following statement contains a magic number: if (Total.Length - 1 < 0x80)                  WriteByte((byte)(Total.Length));              else              {                  int Size = Total.Length;                  int Offset = 1;                    while (Size >= (128*2))                  {                      Size -= 128;                      ++Offset;                  }                    WriteByte((byte)Size);                  WriteByte((byte)Offset);              }
Magic Number,FrameWork,PacketOut,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,WriteGamebryoSize,The following statement contains a magic number: if (Total.Length - 1 < 0x80)                  WriteByte((byte)(Total.Length));              else              {                  int Size = Total.Length;                  int Offset = 1;                    while (Size >= (128*2))                  {                      Size -= 128;                      ++Offset;                  }                    WriteByte((byte)Size);                  WriteByte((byte)Offset);              }
Magic Number,FrameWork,Marshal,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Marshal.cs,ConvertToInt32,The following statement contains a magic number: return ConvertToInt32(val[startIndex]' val[startIndex + 1]' val[startIndex + 2]' val[startIndex + 3]);
Magic Number,FrameWork,Marshal,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Marshal.cs,ConvertToInt32,The following statement contains a magic number: return ConvertToInt32(val[startIndex]' val[startIndex + 1]' val[startIndex + 2]' val[startIndex + 3]);
Magic Number,FrameWork,Marshal,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Marshal.cs,ConvertToInt32,The following statement contains a magic number: return ((v1 << 24) | (v2 << 16) | (v3 << 8) | v4);
Magic Number,FrameWork,Marshal,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Marshal.cs,ConvertToInt32,The following statement contains a magic number: return ((v1 << 24) | (v2 << 16) | (v3 << 8) | v4);
Magic Number,FrameWork,Marshal,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Marshal.cs,ConvertToInt32,The following statement contains a magic number: return ((v1 << 24) | (v2 << 16) | (v3 << 8) | v4);
Magic Number,FrameWork,Marshal,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Marshal.cs,ConvertToUInt32,The following statement contains a magic number: return ConvertToUInt32(val[startIndex]' val[startIndex + 1]' val[startIndex + 2]' val[startIndex + 3]);
Magic Number,FrameWork,Marshal,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Marshal.cs,ConvertToUInt32,The following statement contains a magic number: return ConvertToUInt32(val[startIndex]' val[startIndex + 1]' val[startIndex + 2]' val[startIndex + 3]);
Magic Number,FrameWork,Marshal,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Marshal.cs,ConvertToUInt32,The following statement contains a magic number: return (uint) ((v1 << 24) | (v2 << 16) | (v3 << 8) | v4);
Magic Number,FrameWork,Marshal,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Marshal.cs,ConvertToUInt32,The following statement contains a magic number: return (uint) ((v1 << 24) | (v2 << 16) | (v3 << 8) | v4);
Magic Number,FrameWork,Marshal,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Marshal.cs,ConvertToUInt32,The following statement contains a magic number: return (uint) ((v1 << 24) | (v2 << 16) | (v3 << 8) | v4);
Magic Number,FrameWork,Marshal,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Marshal.cs,ConvertToFloat,The following statement contains a magic number: return (float)((v1 << 24) | (v2 << 16) | (v3 << 8) | v4);
Magic Number,FrameWork,Marshal,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Marshal.cs,ConvertToFloat,The following statement contains a magic number: return (float)((v1 << 24) | (v2 << 16) | (v3 << 8) | v4);
Magic Number,FrameWork,Marshal,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Marshal.cs,ConvertToFloat,The following statement contains a magic number: return (float)((v1 << 24) | (v2 << 16) | (v3 << 8) | v4);
Magic Number,FrameWork,Marshal,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Marshal.cs,ConvertToInt16,The following statement contains a magic number: return (short) ((v1 << 8) | v2);
Magic Number,FrameWork,Marshal,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Marshal.cs,ConvertToUInt16,The following statement contains a magic number: return (ushort) (v2 | (v1 << 8));
Magic Number,FrameWork,Builder,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The following statement contains a magic number: while (input.ReadTag(out tag' out field_name)) {            if(tag == 0 && field_name != null) {              int field_ordinal = global::System.Array.BinarySearch(_authSessionTokenReplyFieldNames' field_name' global::System.StringComparer.Ordinal);              if(field_ordinal >= 0)                tag = _authSessionTokenReplyFieldTags[field_ordinal];              else {                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                continue;              }            }            switch (tag) {              case 0: {                throw pb::InvalidProtocolBufferException.InvalidTag();              }              default: {                if (pb::WireFormat.IsEndGroupTag(tag)) {                  if (unknownFields != null) {                    this.UnknownFields = unknownFields.Build();                  }                  return this;                }                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                break;              }              case 8: {                object unknown;                if(input.ReadEnum(ref result.resultCode_' out unknown)) {                  result.hasResultCode = true;                } else if(unknown is int) {                  if (unknownFields == null) {                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                  }                  unknownFields.MergeVarintField(1' (ulong)(int)unknown);                }                break;              }            }          }
Magic Number,FrameWork,Builder,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The following statement contains a magic number: while (input.ReadTag(out tag' out field_name)) {            if(tag == 0 && field_name != null) {              int field_ordinal = global::System.Array.BinarySearch(_authSessionTokenReqFieldNames' field_name' global::System.StringComparer.Ordinal);              if(field_ordinal >= 0)                tag = _authSessionTokenReqFieldTags[field_ordinal];              else {                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                continue;              }            }            switch (tag) {              case 0: {                throw pb::InvalidProtocolBufferException.InvalidTag();              }              default: {                if (pb::WireFormat.IsEndGroupTag(tag)) {                  if (unknownFields != null) {                    this.UnknownFields = unknownFields.Build();                  }                  return this;                }                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                break;              }              case 10: {                result.hasSessionToken = input.ReadBytes(ref result.sessionToken_);                break;              }            }          }
Magic Number,FrameWork,Builder,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The following statement contains a magic number: while (input.ReadTag(out tag' out field_name)) {                if(tag == 0 && field_name != null) {                  int field_ordinal = global::System.Array.BinarySearch(_acctPropFieldNames' field_name' global::System.StringComparer.Ordinal);                  if(field_ordinal >= 0)                    tag = _acctPropFieldTags[field_ordinal];                  else {                    if (unknownFields == null) {                      unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                    }                    ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                    continue;                  }                }                switch (tag) {                  case 0: {                    throw pb::InvalidProtocolBufferException.InvalidTag();                  }                  default: {                    if (pb::WireFormat.IsEndGroupTag(tag)) {                      if (unknownFields != null) {                        this.UnknownFields = unknownFields.Build();                      }                      return this;                    }                    if (unknownFields == null) {                      unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                    }                    ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                    break;                  }                  case 8: {                    result.hasPropertyId = input.ReadUInt32(ref result.propertyId_);                    break;                  }                  case 16: {                    result.hasPropertyValue = input.ReadInt32(ref result.propertyValue_);                    break;                  }                }              }
Magic Number,FrameWork,Builder,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The following statement contains a magic number: while (input.ReadTag(out tag' out field_name)) {                if(tag == 0 && field_name != null) {                  int field_ordinal = global::System.Array.BinarySearch(_acctPropFieldNames' field_name' global::System.StringComparer.Ordinal);                  if(field_ordinal >= 0)                    tag = _acctPropFieldTags[field_ordinal];                  else {                    if (unknownFields == null) {                      unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                    }                    ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                    continue;                  }                }                switch (tag) {                  case 0: {                    throw pb::InvalidProtocolBufferException.InvalidTag();                  }                  default: {                    if (pb::WireFormat.IsEndGroupTag(tag)) {                      if (unknownFields != null) {                        this.UnknownFields = unknownFields.Build();                      }                      return this;                    }                    if (unknownFields == null) {                      unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                    }                    ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                    break;                  }                  case 8: {                    result.hasPropertyId = input.ReadUInt32(ref result.propertyId_);                    break;                  }                  case 16: {                    result.hasPropertyValue = input.ReadInt32(ref result.propertyValue_);                    break;                  }                }              }
Magic Number,FrameWork,Builder,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The following statement contains a magic number: while (input.ReadTag(out tag' out field_name)) {            if(tag == 0 && field_name != null) {              int field_ordinal = global::System.Array.BinarySearch(_getAcctPropListReplyFieldNames' field_name' global::System.StringComparer.Ordinal);              if(field_ordinal >= 0)                tag = _getAcctPropListReplyFieldTags[field_ordinal];              else {                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                continue;              }            }            switch (tag) {              case 0: {                throw pb::InvalidProtocolBufferException.InvalidTag();              }              default: {                if (pb::WireFormat.IsEndGroupTag(tag)) {                  if (unknownFields != null) {                    this.UnknownFields = unknownFields.Build();                  }                  return this;                }                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                break;              }              case 8: {                object unknown;                if(input.ReadEnum(ref result.resultCode_' out unknown)) {                  result.hasResultCode = true;                } else if(unknown is int) {                  if (unknownFields == null) {                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                  }                  unknownFields.MergeVarintField(1' (ulong)(int)unknown);                }                break;              }              case 18: {                input.ReadMessageArray(tag' field_name' result.propList_' global::FrameWork.GetAcctPropListReply.Types.AcctProp.DefaultInstance' extensionRegistry);                break;              }            }          }
Magic Number,FrameWork,Builder,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The following statement contains a magic number: while (input.ReadTag(out tag' out field_name)) {            if(tag == 0 && field_name != null) {              int field_ordinal = global::System.Array.BinarySearch(_getAcctPropListReplyFieldNames' field_name' global::System.StringComparer.Ordinal);              if(field_ordinal >= 0)                tag = _getAcctPropListReplyFieldTags[field_ordinal];              else {                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                continue;              }            }            switch (tag) {              case 0: {                throw pb::InvalidProtocolBufferException.InvalidTag();              }              default: {                if (pb::WireFormat.IsEndGroupTag(tag)) {                  if (unknownFields != null) {                    this.UnknownFields = unknownFields.Build();                  }                  return this;                }                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                break;              }              case 8: {                object unknown;                if(input.ReadEnum(ref result.resultCode_' out unknown)) {                  result.hasResultCode = true;                } else if(unknown is int) {                  if (unknownFields == null) {                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                  }                  unknownFields.MergeVarintField(1' (ulong)(int)unknown);                }                break;              }              case 18: {                input.ReadMessageArray(tag' field_name' result.propList_' global::FrameWork.GetAcctPropListReply.Types.AcctProp.DefaultInstance' extensionRegistry);                break;              }            }          }
Magic Number,FrameWork,Builder,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The following statement contains a magic number: while (input.ReadTag(out tag' out field_name)) {                if(tag == 0 && field_name != null) {                  int field_ordinal = global::System.Array.BinarySearch(_charSummaryFieldNames' field_name' global::System.StringComparer.Ordinal);                  if(field_ordinal >= 0)                    tag = _charSummaryFieldTags[field_ordinal];                  else {                    if (unknownFields == null) {                      unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                    }                    ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                    continue;                  }                }                switch (tag) {                  case 0: {                    throw pb::InvalidProtocolBufferException.InvalidTag();                  }                  default: {                    if (pb::WireFormat.IsEndGroupTag(tag)) {                      if (unknownFields != null) {                        this.UnknownFields = unknownFields.Build();                      }                      return this;                    }                    if (unknownFields == null) {                      unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                    }                    ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                    break;                  }                  case 8: {                    result.hasServerId = input.ReadUInt32(ref result.serverId_);                    break;                  }                  case 16: {                    result.hasCharacterId = input.ReadUInt32(ref result.characterId_);                    break;                  }                  case 24: {                    result.hasLastPlayedTime = input.ReadInt64(ref result.lastPlayedTime_);                    break;                  }                  case 34: {                    result.hasXmlData = input.ReadString(ref result.xmlData_);                    break;                  }                }              }
Magic Number,FrameWork,Builder,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The following statement contains a magic number: while (input.ReadTag(out tag' out field_name)) {                if(tag == 0 && field_name != null) {                  int field_ordinal = global::System.Array.BinarySearch(_charSummaryFieldNames' field_name' global::System.StringComparer.Ordinal);                  if(field_ordinal >= 0)                    tag = _charSummaryFieldTags[field_ordinal];                  else {                    if (unknownFields == null) {                      unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                    }                    ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                    continue;                  }                }                switch (tag) {                  case 0: {                    throw pb::InvalidProtocolBufferException.InvalidTag();                  }                  default: {                    if (pb::WireFormat.IsEndGroupTag(tag)) {                      if (unknownFields != null) {                        this.UnknownFields = unknownFields.Build();                      }                      return this;                    }                    if (unknownFields == null) {                      unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                    }                    ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                    break;                  }                  case 8: {                    result.hasServerId = input.ReadUInt32(ref result.serverId_);                    break;                  }                  case 16: {                    result.hasCharacterId = input.ReadUInt32(ref result.characterId_);                    break;                  }                  case 24: {                    result.hasLastPlayedTime = input.ReadInt64(ref result.lastPlayedTime_);                    break;                  }                  case 34: {                    result.hasXmlData = input.ReadString(ref result.xmlData_);                    break;                  }                }              }
Magic Number,FrameWork,Builder,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The following statement contains a magic number: while (input.ReadTag(out tag' out field_name)) {                if(tag == 0 && field_name != null) {                  int field_ordinal = global::System.Array.BinarySearch(_charSummaryFieldNames' field_name' global::System.StringComparer.Ordinal);                  if(field_ordinal >= 0)                    tag = _charSummaryFieldTags[field_ordinal];                  else {                    if (unknownFields == null) {                      unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                    }                    ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                    continue;                  }                }                switch (tag) {                  case 0: {                    throw pb::InvalidProtocolBufferException.InvalidTag();                  }                  default: {                    if (pb::WireFormat.IsEndGroupTag(tag)) {                      if (unknownFields != null) {                        this.UnknownFields = unknownFields.Build();                      }                      return this;                    }                    if (unknownFields == null) {                      unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                    }                    ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                    break;                  }                  case 8: {                    result.hasServerId = input.ReadUInt32(ref result.serverId_);                    break;                  }                  case 16: {                    result.hasCharacterId = input.ReadUInt32(ref result.characterId_);                    break;                  }                  case 24: {                    result.hasLastPlayedTime = input.ReadInt64(ref result.lastPlayedTime_);                    break;                  }                  case 34: {                    result.hasXmlData = input.ReadString(ref result.xmlData_);                    break;                  }                }              }
Magic Number,FrameWork,Builder,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The following statement contains a magic number: while (input.ReadTag(out tag' out field_name)) {                if(tag == 0 && field_name != null) {                  int field_ordinal = global::System.Array.BinarySearch(_charSummaryFieldNames' field_name' global::System.StringComparer.Ordinal);                  if(field_ordinal >= 0)                    tag = _charSummaryFieldTags[field_ordinal];                  else {                    if (unknownFields == null) {                      unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                    }                    ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                    continue;                  }                }                switch (tag) {                  case 0: {                    throw pb::InvalidProtocolBufferException.InvalidTag();                  }                  default: {                    if (pb::WireFormat.IsEndGroupTag(tag)) {                      if (unknownFields != null) {                        this.UnknownFields = unknownFields.Build();                      }                      return this;                    }                    if (unknownFields == null) {                      unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                    }                    ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                    break;                  }                  case 8: {                    result.hasServerId = input.ReadUInt32(ref result.serverId_);                    break;                  }                  case 16: {                    result.hasCharacterId = input.ReadUInt32(ref result.characterId_);                    break;                  }                  case 24: {                    result.hasLastPlayedTime = input.ReadInt64(ref result.lastPlayedTime_);                    break;                  }                  case 34: {                    result.hasXmlData = input.ReadString(ref result.xmlData_);                    break;                  }                }              }
Magic Number,FrameWork,Builder,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The following statement contains a magic number: while (input.ReadTag(out tag' out field_name)) {            if(tag == 0 && field_name != null) {              int field_ordinal = global::System.Array.BinarySearch(_getCharSummaryListReplyFieldNames' field_name' global::System.StringComparer.Ordinal);              if(field_ordinal >= 0)                tag = _getCharSummaryListReplyFieldTags[field_ordinal];              else {                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                continue;              }            }            switch (tag) {              case 0: {                throw pb::InvalidProtocolBufferException.InvalidTag();              }              default: {                if (pb::WireFormat.IsEndGroupTag(tag)) {                  if (unknownFields != null) {                    this.UnknownFields = unknownFields.Build();                  }                  return this;                }                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                break;              }              case 8: {                object unknown;                if(input.ReadEnum(ref result.resultCode_' out unknown)) {                  result.hasResultCode = true;                } else if(unknown is int) {                  if (unknownFields == null) {                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                  }                  unknownFields.MergeVarintField(1' (ulong)(int)unknown);                }                break;              }              case 18: {                input.ReadMessageArray(tag' field_name' result.summaryList_' global::FrameWork.GetCharSummaryListReply.Types.CharSummary.DefaultInstance' extensionRegistry);                break;              }            }          }
Magic Number,FrameWork,Builder,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The following statement contains a magic number: while (input.ReadTag(out tag' out field_name)) {            if(tag == 0 && field_name != null) {              int field_ordinal = global::System.Array.BinarySearch(_getCharSummaryListReplyFieldNames' field_name' global::System.StringComparer.Ordinal);              if(field_ordinal >= 0)                tag = _getCharSummaryListReplyFieldTags[field_ordinal];              else {                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                continue;              }            }            switch (tag) {              case 0: {                throw pb::InvalidProtocolBufferException.InvalidTag();              }              default: {                if (pb::WireFormat.IsEndGroupTag(tag)) {                  if (unknownFields != null) {                    this.UnknownFields = unknownFields.Build();                  }                  return this;                }                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                break;              }              case 8: {                object unknown;                if(input.ReadEnum(ref result.resultCode_' out unknown)) {                  result.hasResultCode = true;                } else if(unknown is int) {                  if (unknownFields == null) {                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                  }                  unknownFields.MergeVarintField(1' (ulong)(int)unknown);                }                break;              }              case 18: {                input.ReadMessageArray(tag' field_name' result.summaryList_' global::FrameWork.GetCharSummaryListReply.Types.CharSummary.DefaultInstance' extensionRegistry);                break;              }            }          }
Magic Number,FrameWork,Builder,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The following statement contains a magic number: while (input.ReadTag(out tag' out field_name)) {            if(tag == 0 && field_name != null) {              int field_ordinal = global::System.Array.BinarySearch(_serverInfoFieldNames' field_name' global::System.StringComparer.Ordinal);              if(field_ordinal >= 0)                tag = _serverInfoFieldTags[field_ordinal];              else {                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                continue;              }            }            switch (tag) {              case 0: {                throw pb::InvalidProtocolBufferException.InvalidTag();              }              default: {                if (pb::WireFormat.IsEndGroupTag(tag)) {                  if (unknownFields != null) {                    this.UnknownFields = unknownFields.Build();                  }                  return this;                }                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                break;              }              case 8: {                result.hasServerId = input.ReadUInt32(ref result.serverId_);                break;              }              case 18: {                result.hasServerName = input.ReadString(ref result.serverName_);                break;              }            }          }
Magic Number,FrameWork,Builder,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The following statement contains a magic number: while (input.ReadTag(out tag' out field_name)) {            if(tag == 0 && field_name != null) {              int field_ordinal = global::System.Array.BinarySearch(_serverInfoFieldNames' field_name' global::System.StringComparer.Ordinal);              if(field_ordinal >= 0)                tag = _serverInfoFieldTags[field_ordinal];              else {                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                continue;              }            }            switch (tag) {              case 0: {                throw pb::InvalidProtocolBufferException.InvalidTag();              }              default: {                if (pb::WireFormat.IsEndGroupTag(tag)) {                  if (unknownFields != null) {                    this.UnknownFields = unknownFields.Build();                  }                  return this;                }                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                break;              }              case 8: {                result.hasServerId = input.ReadUInt32(ref result.serverId_);                break;              }              case 18: {                result.hasServerName = input.ReadString(ref result.serverName_);                break;              }            }          }
Magic Number,FrameWork,Builder,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The following statement contains a magic number: while (input.ReadTag(out tag' out field_name)) {            if(tag == 0 && field_name != null) {              int field_ordinal = global::System.Array.BinarySearch(_clusterPropFieldNames' field_name' global::System.StringComparer.Ordinal);              if(field_ordinal >= 0)                tag = _clusterPropFieldTags[field_ordinal];              else {                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                continue;              }            }            switch (tag) {              case 0: {                throw pb::InvalidProtocolBufferException.InvalidTag();              }              default: {                if (pb::WireFormat.IsEndGroupTag(tag)) {                  if (unknownFields != null) {                    this.UnknownFields = unknownFields.Build();                  }                  return this;                }                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                break;              }              case 10: {                result.hasPropName = input.ReadString(ref result.propName_);                break;              }              case 18: {                result.hasPropValue = input.ReadString(ref result.propValue_);                break;              }            }          }
Magic Number,FrameWork,Builder,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The following statement contains a magic number: while (input.ReadTag(out tag' out field_name)) {            if(tag == 0 && field_name != null) {              int field_ordinal = global::System.Array.BinarySearch(_clusterPropFieldNames' field_name' global::System.StringComparer.Ordinal);              if(field_ordinal >= 0)                tag = _clusterPropFieldTags[field_ordinal];              else {                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                continue;              }            }            switch (tag) {              case 0: {                throw pb::InvalidProtocolBufferException.InvalidTag();              }              default: {                if (pb::WireFormat.IsEndGroupTag(tag)) {                  if (unknownFields != null) {                    this.UnknownFields = unknownFields.Build();                  }                  return this;                }                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                break;              }              case 10: {                result.hasPropName = input.ReadString(ref result.propName_);                break;              }              case 18: {                result.hasPropValue = input.ReadString(ref result.propValue_);                break;              }            }          }
Magic Number,FrameWork,Builder,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The following statement contains a magic number: while (input.ReadTag(out tag' out field_name)) {            if(tag == 0 && field_name != null) {              int field_ordinal = global::System.Array.BinarySearch(_clusterInfoFieldNames' field_name' global::System.StringComparer.Ordinal);              if(field_ordinal >= 0)                tag = _clusterInfoFieldTags[field_ordinal];              else {                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                continue;              }            }            switch (tag) {              case 0: {                throw pb::InvalidProtocolBufferException.InvalidTag();              }              default: {                if (pb::WireFormat.IsEndGroupTag(tag)) {                  if (unknownFields != null) {                    this.UnknownFields = unknownFields.Build();                  }                  return this;                }                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                break;              }              case 8: {                result.hasClusterId = input.ReadUInt32(ref result.clusterId_);                break;              }              case 18: {                result.hasClusterName = input.ReadString(ref result.clusterName_);                break;              }              case 26: {                result.hasLobbyHost = input.ReadString(ref result.lobbyHost_);                break;              }              case 32: {                result.hasLobbyPort = input.ReadUInt32(ref result.lobbyPort_);                break;              }              case 40: {                result.hasClusterPop = input.ReadUInt32(ref result.clusterPop_);                break;              }              case 48: {                result.hasMaxClusterPop = input.ReadUInt32(ref result.maxClusterPop_);                break;              }              case 56: {                object unknown;                if(input.ReadEnum(ref result.clusterPopStatus_' out unknown)) {                  result.hasClusterPopStatus = true;                } else if(unknown is int) {                  if (unknownFields == null) {                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                  }                  unknownFields.MergeVarintField(7' (ulong)(int)unknown);                }                break;              }              case 64: {                result.hasLanguageId = input.ReadUInt32(ref result.languageId_);                break;              }              case 72: {                object unknown;                if(input.ReadEnum(ref result.clusterStatus_' out unknown)) {                  result.hasClusterStatus = true;                } else if(unknown is int) {                  if (unknownFields == null) {                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                  }                  unknownFields.MergeVarintField(9' (ulong)(int)unknown);                }                break;              }              case 82: {                input.ReadMessageArray(tag' field_name' result.serverList_' global::FrameWork.ServerInfo.DefaultInstance' extensionRegistry);                break;              }              case 90: {                input.ReadMessageArray(tag' field_name' result.propertyList_' global::FrameWork.ClusterProp.DefaultInstance' extensionRegistry);                break;              }            }          }
Magic Number,FrameWork,Builder,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The following statement contains a magic number: while (input.ReadTag(out tag' out field_name)) {            if(tag == 0 && field_name != null) {              int field_ordinal = global::System.Array.BinarySearch(_clusterInfoFieldNames' field_name' global::System.StringComparer.Ordinal);              if(field_ordinal >= 0)                tag = _clusterInfoFieldTags[field_ordinal];              else {                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                continue;              }            }            switch (tag) {              case 0: {                throw pb::InvalidProtocolBufferException.InvalidTag();              }              default: {                if (pb::WireFormat.IsEndGroupTag(tag)) {                  if (unknownFields != null) {                    this.UnknownFields = unknownFields.Build();                  }                  return this;                }                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                break;              }              case 8: {                result.hasClusterId = input.ReadUInt32(ref result.clusterId_);                break;              }              case 18: {                result.hasClusterName = input.ReadString(ref result.clusterName_);                break;              }              case 26: {                result.hasLobbyHost = input.ReadString(ref result.lobbyHost_);                break;              }              case 32: {                result.hasLobbyPort = input.ReadUInt32(ref result.lobbyPort_);                break;              }              case 40: {                result.hasClusterPop = input.ReadUInt32(ref result.clusterPop_);                break;              }              case 48: {                result.hasMaxClusterPop = input.ReadUInt32(ref result.maxClusterPop_);                break;              }              case 56: {                object unknown;                if(input.ReadEnum(ref result.clusterPopStatus_' out unknown)) {                  result.hasClusterPopStatus = true;                } else if(unknown is int) {                  if (unknownFields == null) {                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                  }                  unknownFields.MergeVarintField(7' (ulong)(int)unknown);                }                break;              }              case 64: {                result.hasLanguageId = input.ReadUInt32(ref result.languageId_);                break;              }              case 72: {                object unknown;                if(input.ReadEnum(ref result.clusterStatus_' out unknown)) {                  result.hasClusterStatus = true;                } else if(unknown is int) {                  if (unknownFields == null) {                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                  }                  unknownFields.MergeVarintField(9' (ulong)(int)unknown);                }                break;              }              case 82: {                input.ReadMessageArray(tag' field_name' result.serverList_' global::FrameWork.ServerInfo.DefaultInstance' extensionRegistry);                break;              }              case 90: {                input.ReadMessageArray(tag' field_name' result.propertyList_' global::FrameWork.ClusterProp.DefaultInstance' extensionRegistry);                break;              }            }          }
Magic Number,FrameWork,Builder,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The following statement contains a magic number: while (input.ReadTag(out tag' out field_name)) {            if(tag == 0 && field_name != null) {              int field_ordinal = global::System.Array.BinarySearch(_clusterInfoFieldNames' field_name' global::System.StringComparer.Ordinal);              if(field_ordinal >= 0)                tag = _clusterInfoFieldTags[field_ordinal];              else {                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                continue;              }            }            switch (tag) {              case 0: {                throw pb::InvalidProtocolBufferException.InvalidTag();              }              default: {                if (pb::WireFormat.IsEndGroupTag(tag)) {                  if (unknownFields != null) {                    this.UnknownFields = unknownFields.Build();                  }                  return this;                }                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                break;              }              case 8: {                result.hasClusterId = input.ReadUInt32(ref result.clusterId_);                break;              }              case 18: {                result.hasClusterName = input.ReadString(ref result.clusterName_);                break;              }              case 26: {                result.hasLobbyHost = input.ReadString(ref result.lobbyHost_);                break;              }              case 32: {                result.hasLobbyPort = input.ReadUInt32(ref result.lobbyPort_);                break;              }              case 40: {                result.hasClusterPop = input.ReadUInt32(ref result.clusterPop_);                break;              }              case 48: {                result.hasMaxClusterPop = input.ReadUInt32(ref result.maxClusterPop_);                break;              }              case 56: {                object unknown;                if(input.ReadEnum(ref result.clusterPopStatus_' out unknown)) {                  result.hasClusterPopStatus = true;                } else if(unknown is int) {                  if (unknownFields == null) {                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                  }                  unknownFields.MergeVarintField(7' (ulong)(int)unknown);                }                break;              }              case 64: {                result.hasLanguageId = input.ReadUInt32(ref result.languageId_);                break;              }              case 72: {                object unknown;                if(input.ReadEnum(ref result.clusterStatus_' out unknown)) {                  result.hasClusterStatus = true;                } else if(unknown is int) {                  if (unknownFields == null) {                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                  }                  unknownFields.MergeVarintField(9' (ulong)(int)unknown);                }                break;              }              case 82: {                input.ReadMessageArray(tag' field_name' result.serverList_' global::FrameWork.ServerInfo.DefaultInstance' extensionRegistry);                break;              }              case 90: {                input.ReadMessageArray(tag' field_name' result.propertyList_' global::FrameWork.ClusterProp.DefaultInstance' extensionRegistry);                break;              }            }          }
Magic Number,FrameWork,Builder,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The following statement contains a magic number: while (input.ReadTag(out tag' out field_name)) {            if(tag == 0 && field_name != null) {              int field_ordinal = global::System.Array.BinarySearch(_clusterInfoFieldNames' field_name' global::System.StringComparer.Ordinal);              if(field_ordinal >= 0)                tag = _clusterInfoFieldTags[field_ordinal];              else {                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                continue;              }            }            switch (tag) {              case 0: {                throw pb::InvalidProtocolBufferException.InvalidTag();              }              default: {                if (pb::WireFormat.IsEndGroupTag(tag)) {                  if (unknownFields != null) {                    this.UnknownFields = unknownFields.Build();                  }                  return this;                }                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                break;              }              case 8: {                result.hasClusterId = input.ReadUInt32(ref result.clusterId_);                break;              }              case 18: {                result.hasClusterName = input.ReadString(ref result.clusterName_);                break;              }              case 26: {                result.hasLobbyHost = input.ReadString(ref result.lobbyHost_);                break;              }              case 32: {                result.hasLobbyPort = input.ReadUInt32(ref result.lobbyPort_);                break;              }              case 40: {                result.hasClusterPop = input.ReadUInt32(ref result.clusterPop_);                break;              }              case 48: {                result.hasMaxClusterPop = input.ReadUInt32(ref result.maxClusterPop_);                break;              }              case 56: {                object unknown;                if(input.ReadEnum(ref result.clusterPopStatus_' out unknown)) {                  result.hasClusterPopStatus = true;                } else if(unknown is int) {                  if (unknownFields == null) {                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                  }                  unknownFields.MergeVarintField(7' (ulong)(int)unknown);                }                break;              }              case 64: {                result.hasLanguageId = input.ReadUInt32(ref result.languageId_);                break;              }              case 72: {                object unknown;                if(input.ReadEnum(ref result.clusterStatus_' out unknown)) {                  result.hasClusterStatus = true;                } else if(unknown is int) {                  if (unknownFields == null) {                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                  }                  unknownFields.MergeVarintField(9' (ulong)(int)unknown);                }                break;              }              case 82: {                input.ReadMessageArray(tag' field_name' result.serverList_' global::FrameWork.ServerInfo.DefaultInstance' extensionRegistry);                break;              }              case 90: {                input.ReadMessageArray(tag' field_name' result.propertyList_' global::FrameWork.ClusterProp.DefaultInstance' extensionRegistry);                break;              }            }          }
Magic Number,FrameWork,Builder,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The following statement contains a magic number: while (input.ReadTag(out tag' out field_name)) {            if(tag == 0 && field_name != null) {              int field_ordinal = global::System.Array.BinarySearch(_clusterInfoFieldNames' field_name' global::System.StringComparer.Ordinal);              if(field_ordinal >= 0)                tag = _clusterInfoFieldTags[field_ordinal];              else {                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                continue;              }            }            switch (tag) {              case 0: {                throw pb::InvalidProtocolBufferException.InvalidTag();              }              default: {                if (pb::WireFormat.IsEndGroupTag(tag)) {                  if (unknownFields != null) {                    this.UnknownFields = unknownFields.Build();                  }                  return this;                }                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                break;              }              case 8: {                result.hasClusterId = input.ReadUInt32(ref result.clusterId_);                break;              }              case 18: {                result.hasClusterName = input.ReadString(ref result.clusterName_);                break;              }              case 26: {                result.hasLobbyHost = input.ReadString(ref result.lobbyHost_);                break;              }              case 32: {                result.hasLobbyPort = input.ReadUInt32(ref result.lobbyPort_);                break;              }              case 40: {                result.hasClusterPop = input.ReadUInt32(ref result.clusterPop_);                break;              }              case 48: {                result.hasMaxClusterPop = input.ReadUInt32(ref result.maxClusterPop_);                break;              }              case 56: {                object unknown;                if(input.ReadEnum(ref result.clusterPopStatus_' out unknown)) {                  result.hasClusterPopStatus = true;                } else if(unknown is int) {                  if (unknownFields == null) {                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                  }                  unknownFields.MergeVarintField(7' (ulong)(int)unknown);                }                break;              }              case 64: {                result.hasLanguageId = input.ReadUInt32(ref result.languageId_);                break;              }              case 72: {                object unknown;                if(input.ReadEnum(ref result.clusterStatus_' out unknown)) {                  result.hasClusterStatus = true;                } else if(unknown is int) {                  if (unknownFields == null) {                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                  }                  unknownFields.MergeVarintField(9' (ulong)(int)unknown);                }                break;              }              case 82: {                input.ReadMessageArray(tag' field_name' result.serverList_' global::FrameWork.ServerInfo.DefaultInstance' extensionRegistry);                break;              }              case 90: {                input.ReadMessageArray(tag' field_name' result.propertyList_' global::FrameWork.ClusterProp.DefaultInstance' extensionRegistry);                break;              }            }          }
Magic Number,FrameWork,Builder,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The following statement contains a magic number: while (input.ReadTag(out tag' out field_name)) {            if(tag == 0 && field_name != null) {              int field_ordinal = global::System.Array.BinarySearch(_clusterInfoFieldNames' field_name' global::System.StringComparer.Ordinal);              if(field_ordinal >= 0)                tag = _clusterInfoFieldTags[field_ordinal];              else {                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                continue;              }            }            switch (tag) {              case 0: {                throw pb::InvalidProtocolBufferException.InvalidTag();              }              default: {                if (pb::WireFormat.IsEndGroupTag(tag)) {                  if (unknownFields != null) {                    this.UnknownFields = unknownFields.Build();                  }                  return this;                }                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                break;              }              case 8: {                result.hasClusterId = input.ReadUInt32(ref result.clusterId_);                break;              }              case 18: {                result.hasClusterName = input.ReadString(ref result.clusterName_);                break;              }              case 26: {                result.hasLobbyHost = input.ReadString(ref result.lobbyHost_);                break;              }              case 32: {                result.hasLobbyPort = input.ReadUInt32(ref result.lobbyPort_);                break;              }              case 40: {                result.hasClusterPop = input.ReadUInt32(ref result.clusterPop_);                break;              }              case 48: {                result.hasMaxClusterPop = input.ReadUInt32(ref result.maxClusterPop_);                break;              }              case 56: {                object unknown;                if(input.ReadEnum(ref result.clusterPopStatus_' out unknown)) {                  result.hasClusterPopStatus = true;                } else if(unknown is int) {                  if (unknownFields == null) {                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                  }                  unknownFields.MergeVarintField(7' (ulong)(int)unknown);                }                break;              }              case 64: {                result.hasLanguageId = input.ReadUInt32(ref result.languageId_);                break;              }              case 72: {                object unknown;                if(input.ReadEnum(ref result.clusterStatus_' out unknown)) {                  result.hasClusterStatus = true;                } else if(unknown is int) {                  if (unknownFields == null) {                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                  }                  unknownFields.MergeVarintField(9' (ulong)(int)unknown);                }                break;              }              case 82: {                input.ReadMessageArray(tag' field_name' result.serverList_' global::FrameWork.ServerInfo.DefaultInstance' extensionRegistry);                break;              }              case 90: {                input.ReadMessageArray(tag' field_name' result.propertyList_' global::FrameWork.ClusterProp.DefaultInstance' extensionRegistry);                break;              }            }          }
Magic Number,FrameWork,Builder,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The following statement contains a magic number: while (input.ReadTag(out tag' out field_name)) {            if(tag == 0 && field_name != null) {              int field_ordinal = global::System.Array.BinarySearch(_clusterInfoFieldNames' field_name' global::System.StringComparer.Ordinal);              if(field_ordinal >= 0)                tag = _clusterInfoFieldTags[field_ordinal];              else {                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                continue;              }            }            switch (tag) {              case 0: {                throw pb::InvalidProtocolBufferException.InvalidTag();              }              default: {                if (pb::WireFormat.IsEndGroupTag(tag)) {                  if (unknownFields != null) {                    this.UnknownFields = unknownFields.Build();                  }                  return this;                }                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                break;              }              case 8: {                result.hasClusterId = input.ReadUInt32(ref result.clusterId_);                break;              }              case 18: {                result.hasClusterName = input.ReadString(ref result.clusterName_);                break;              }              case 26: {                result.hasLobbyHost = input.ReadString(ref result.lobbyHost_);                break;              }              case 32: {                result.hasLobbyPort = input.ReadUInt32(ref result.lobbyPort_);                break;              }              case 40: {                result.hasClusterPop = input.ReadUInt32(ref result.clusterPop_);                break;              }              case 48: {                result.hasMaxClusterPop = input.ReadUInt32(ref result.maxClusterPop_);                break;              }              case 56: {                object unknown;                if(input.ReadEnum(ref result.clusterPopStatus_' out unknown)) {                  result.hasClusterPopStatus = true;                } else if(unknown is int) {                  if (unknownFields == null) {                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                  }                  unknownFields.MergeVarintField(7' (ulong)(int)unknown);                }                break;              }              case 64: {                result.hasLanguageId = input.ReadUInt32(ref result.languageId_);                break;              }              case 72: {                object unknown;                if(input.ReadEnum(ref result.clusterStatus_' out unknown)) {                  result.hasClusterStatus = true;                } else if(unknown is int) {                  if (unknownFields == null) {                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                  }                  unknownFields.MergeVarintField(9' (ulong)(int)unknown);                }                break;              }              case 82: {                input.ReadMessageArray(tag' field_name' result.serverList_' global::FrameWork.ServerInfo.DefaultInstance' extensionRegistry);                break;              }              case 90: {                input.ReadMessageArray(tag' field_name' result.propertyList_' global::FrameWork.ClusterProp.DefaultInstance' extensionRegistry);                break;              }            }          }
Magic Number,FrameWork,Builder,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The following statement contains a magic number: while (input.ReadTag(out tag' out field_name)) {            if(tag == 0 && field_name != null) {              int field_ordinal = global::System.Array.BinarySearch(_clusterInfoFieldNames' field_name' global::System.StringComparer.Ordinal);              if(field_ordinal >= 0)                tag = _clusterInfoFieldTags[field_ordinal];              else {                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                continue;              }            }            switch (tag) {              case 0: {                throw pb::InvalidProtocolBufferException.InvalidTag();              }              default: {                if (pb::WireFormat.IsEndGroupTag(tag)) {                  if (unknownFields != null) {                    this.UnknownFields = unknownFields.Build();                  }                  return this;                }                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                break;              }              case 8: {                result.hasClusterId = input.ReadUInt32(ref result.clusterId_);                break;              }              case 18: {                result.hasClusterName = input.ReadString(ref result.clusterName_);                break;              }              case 26: {                result.hasLobbyHost = input.ReadString(ref result.lobbyHost_);                break;              }              case 32: {                result.hasLobbyPort = input.ReadUInt32(ref result.lobbyPort_);                break;              }              case 40: {                result.hasClusterPop = input.ReadUInt32(ref result.clusterPop_);                break;              }              case 48: {                result.hasMaxClusterPop = input.ReadUInt32(ref result.maxClusterPop_);                break;              }              case 56: {                object unknown;                if(input.ReadEnum(ref result.clusterPopStatus_' out unknown)) {                  result.hasClusterPopStatus = true;                } else if(unknown is int) {                  if (unknownFields == null) {                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                  }                  unknownFields.MergeVarintField(7' (ulong)(int)unknown);                }                break;              }              case 64: {                result.hasLanguageId = input.ReadUInt32(ref result.languageId_);                break;              }              case 72: {                object unknown;                if(input.ReadEnum(ref result.clusterStatus_' out unknown)) {                  result.hasClusterStatus = true;                } else if(unknown is int) {                  if (unknownFields == null) {                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                  }                  unknownFields.MergeVarintField(9' (ulong)(int)unknown);                }                break;              }              case 82: {                input.ReadMessageArray(tag' field_name' result.serverList_' global::FrameWork.ServerInfo.DefaultInstance' extensionRegistry);                break;              }              case 90: {                input.ReadMessageArray(tag' field_name' result.propertyList_' global::FrameWork.ClusterProp.DefaultInstance' extensionRegistry);                break;              }            }          }
Magic Number,FrameWork,Builder,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The following statement contains a magic number: while (input.ReadTag(out tag' out field_name)) {            if(tag == 0 && field_name != null) {              int field_ordinal = global::System.Array.BinarySearch(_clusterInfoFieldNames' field_name' global::System.StringComparer.Ordinal);              if(field_ordinal >= 0)                tag = _clusterInfoFieldTags[field_ordinal];              else {                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                continue;              }            }            switch (tag) {              case 0: {                throw pb::InvalidProtocolBufferException.InvalidTag();              }              default: {                if (pb::WireFormat.IsEndGroupTag(tag)) {                  if (unknownFields != null) {                    this.UnknownFields = unknownFields.Build();                  }                  return this;                }                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                break;              }              case 8: {                result.hasClusterId = input.ReadUInt32(ref result.clusterId_);                break;              }              case 18: {                result.hasClusterName = input.ReadString(ref result.clusterName_);                break;              }              case 26: {                result.hasLobbyHost = input.ReadString(ref result.lobbyHost_);                break;              }              case 32: {                result.hasLobbyPort = input.ReadUInt32(ref result.lobbyPort_);                break;              }              case 40: {                result.hasClusterPop = input.ReadUInt32(ref result.clusterPop_);                break;              }              case 48: {                result.hasMaxClusterPop = input.ReadUInt32(ref result.maxClusterPop_);                break;              }              case 56: {                object unknown;                if(input.ReadEnum(ref result.clusterPopStatus_' out unknown)) {                  result.hasClusterPopStatus = true;                } else if(unknown is int) {                  if (unknownFields == null) {                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                  }                  unknownFields.MergeVarintField(7' (ulong)(int)unknown);                }                break;              }              case 64: {                result.hasLanguageId = input.ReadUInt32(ref result.languageId_);                break;              }              case 72: {                object unknown;                if(input.ReadEnum(ref result.clusterStatus_' out unknown)) {                  result.hasClusterStatus = true;                } else if(unknown is int) {                  if (unknownFields == null) {                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                  }                  unknownFields.MergeVarintField(9' (ulong)(int)unknown);                }                break;              }              case 82: {                input.ReadMessageArray(tag' field_name' result.serverList_' global::FrameWork.ServerInfo.DefaultInstance' extensionRegistry);                break;              }              case 90: {                input.ReadMessageArray(tag' field_name' result.propertyList_' global::FrameWork.ClusterProp.DefaultInstance' extensionRegistry);                break;              }            }          }
Magic Number,FrameWork,Builder,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The following statement contains a magic number: while (input.ReadTag(out tag' out field_name)) {            if(tag == 0 && field_name != null) {              int field_ordinal = global::System.Array.BinarySearch(_clusterInfoFieldNames' field_name' global::System.StringComparer.Ordinal);              if(field_ordinal >= 0)                tag = _clusterInfoFieldTags[field_ordinal];              else {                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                continue;              }            }            switch (tag) {              case 0: {                throw pb::InvalidProtocolBufferException.InvalidTag();              }              default: {                if (pb::WireFormat.IsEndGroupTag(tag)) {                  if (unknownFields != null) {                    this.UnknownFields = unknownFields.Build();                  }                  return this;                }                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                break;              }              case 8: {                result.hasClusterId = input.ReadUInt32(ref result.clusterId_);                break;              }              case 18: {                result.hasClusterName = input.ReadString(ref result.clusterName_);                break;              }              case 26: {                result.hasLobbyHost = input.ReadString(ref result.lobbyHost_);                break;              }              case 32: {                result.hasLobbyPort = input.ReadUInt32(ref result.lobbyPort_);                break;              }              case 40: {                result.hasClusterPop = input.ReadUInt32(ref result.clusterPop_);                break;              }              case 48: {                result.hasMaxClusterPop = input.ReadUInt32(ref result.maxClusterPop_);                break;              }              case 56: {                object unknown;                if(input.ReadEnum(ref result.clusterPopStatus_' out unknown)) {                  result.hasClusterPopStatus = true;                } else if(unknown is int) {                  if (unknownFields == null) {                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                  }                  unknownFields.MergeVarintField(7' (ulong)(int)unknown);                }                break;              }              case 64: {                result.hasLanguageId = input.ReadUInt32(ref result.languageId_);                break;              }              case 72: {                object unknown;                if(input.ReadEnum(ref result.clusterStatus_' out unknown)) {                  result.hasClusterStatus = true;                } else if(unknown is int) {                  if (unknownFields == null) {                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                  }                  unknownFields.MergeVarintField(9' (ulong)(int)unknown);                }                break;              }              case 82: {                input.ReadMessageArray(tag' field_name' result.serverList_' global::FrameWork.ServerInfo.DefaultInstance' extensionRegistry);                break;              }              case 90: {                input.ReadMessageArray(tag' field_name' result.propertyList_' global::FrameWork.ClusterProp.DefaultInstance' extensionRegistry);                break;              }            }          }
Magic Number,FrameWork,Builder,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The following statement contains a magic number: while (input.ReadTag(out tag' out field_name)) {            if(tag == 0 && field_name != null) {              int field_ordinal = global::System.Array.BinarySearch(_clusterInfoFieldNames' field_name' global::System.StringComparer.Ordinal);              if(field_ordinal >= 0)                tag = _clusterInfoFieldTags[field_ordinal];              else {                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                continue;              }            }            switch (tag) {              case 0: {                throw pb::InvalidProtocolBufferException.InvalidTag();              }              default: {                if (pb::WireFormat.IsEndGroupTag(tag)) {                  if (unknownFields != null) {                    this.UnknownFields = unknownFields.Build();                  }                  return this;                }                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                break;              }              case 8: {                result.hasClusterId = input.ReadUInt32(ref result.clusterId_);                break;              }              case 18: {                result.hasClusterName = input.ReadString(ref result.clusterName_);                break;              }              case 26: {                result.hasLobbyHost = input.ReadString(ref result.lobbyHost_);                break;              }              case 32: {                result.hasLobbyPort = input.ReadUInt32(ref result.lobbyPort_);                break;              }              case 40: {                result.hasClusterPop = input.ReadUInt32(ref result.clusterPop_);                break;              }              case 48: {                result.hasMaxClusterPop = input.ReadUInt32(ref result.maxClusterPop_);                break;              }              case 56: {                object unknown;                if(input.ReadEnum(ref result.clusterPopStatus_' out unknown)) {                  result.hasClusterPopStatus = true;                } else if(unknown is int) {                  if (unknownFields == null) {                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                  }                  unknownFields.MergeVarintField(7' (ulong)(int)unknown);                }                break;              }              case 64: {                result.hasLanguageId = input.ReadUInt32(ref result.languageId_);                break;              }              case 72: {                object unknown;                if(input.ReadEnum(ref result.clusterStatus_' out unknown)) {                  result.hasClusterStatus = true;                } else if(unknown is int) {                  if (unknownFields == null) {                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                  }                  unknownFields.MergeVarintField(9' (ulong)(int)unknown);                }                break;              }              case 82: {                input.ReadMessageArray(tag' field_name' result.serverList_' global::FrameWork.ServerInfo.DefaultInstance' extensionRegistry);                break;              }              case 90: {                input.ReadMessageArray(tag' field_name' result.propertyList_' global::FrameWork.ClusterProp.DefaultInstance' extensionRegistry);                break;              }            }          }
Magic Number,FrameWork,Builder,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The following statement contains a magic number: while (input.ReadTag(out tag' out field_name)) {            if(tag == 0 && field_name != null) {              int field_ordinal = global::System.Array.BinarySearch(_clusterInfoFieldNames' field_name' global::System.StringComparer.Ordinal);              if(field_ordinal >= 0)                tag = _clusterInfoFieldTags[field_ordinal];              else {                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                continue;              }            }            switch (tag) {              case 0: {                throw pb::InvalidProtocolBufferException.InvalidTag();              }              default: {                if (pb::WireFormat.IsEndGroupTag(tag)) {                  if (unknownFields != null) {                    this.UnknownFields = unknownFields.Build();                  }                  return this;                }                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                break;              }              case 8: {                result.hasClusterId = input.ReadUInt32(ref result.clusterId_);                break;              }              case 18: {                result.hasClusterName = input.ReadString(ref result.clusterName_);                break;              }              case 26: {                result.hasLobbyHost = input.ReadString(ref result.lobbyHost_);                break;              }              case 32: {                result.hasLobbyPort = input.ReadUInt32(ref result.lobbyPort_);                break;              }              case 40: {                result.hasClusterPop = input.ReadUInt32(ref result.clusterPop_);                break;              }              case 48: {                result.hasMaxClusterPop = input.ReadUInt32(ref result.maxClusterPop_);                break;              }              case 56: {                object unknown;                if(input.ReadEnum(ref result.clusterPopStatus_' out unknown)) {                  result.hasClusterPopStatus = true;                } else if(unknown is int) {                  if (unknownFields == null) {                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                  }                  unknownFields.MergeVarintField(7' (ulong)(int)unknown);                }                break;              }              case 64: {                result.hasLanguageId = input.ReadUInt32(ref result.languageId_);                break;              }              case 72: {                object unknown;                if(input.ReadEnum(ref result.clusterStatus_' out unknown)) {                  result.hasClusterStatus = true;                } else if(unknown is int) {                  if (unknownFields == null) {                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                  }                  unknownFields.MergeVarintField(9' (ulong)(int)unknown);                }                break;              }              case 82: {                input.ReadMessageArray(tag' field_name' result.serverList_' global::FrameWork.ServerInfo.DefaultInstance' extensionRegistry);                break;              }              case 90: {                input.ReadMessageArray(tag' field_name' result.propertyList_' global::FrameWork.ClusterProp.DefaultInstance' extensionRegistry);                break;              }            }          }
Magic Number,FrameWork,Builder,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The following statement contains a magic number: while (input.ReadTag(out tag' out field_name)) {            if(tag == 0 && field_name != null) {              int field_ordinal = global::System.Array.BinarySearch(_clusterInfoFieldNames' field_name' global::System.StringComparer.Ordinal);              if(field_ordinal >= 0)                tag = _clusterInfoFieldTags[field_ordinal];              else {                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                continue;              }            }            switch (tag) {              case 0: {                throw pb::InvalidProtocolBufferException.InvalidTag();              }              default: {                if (pb::WireFormat.IsEndGroupTag(tag)) {                  if (unknownFields != null) {                    this.UnknownFields = unknownFields.Build();                  }                  return this;                }                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                break;              }              case 8: {                result.hasClusterId = input.ReadUInt32(ref result.clusterId_);                break;              }              case 18: {                result.hasClusterName = input.ReadString(ref result.clusterName_);                break;              }              case 26: {                result.hasLobbyHost = input.ReadString(ref result.lobbyHost_);                break;              }              case 32: {                result.hasLobbyPort = input.ReadUInt32(ref result.lobbyPort_);                break;              }              case 40: {                result.hasClusterPop = input.ReadUInt32(ref result.clusterPop_);                break;              }              case 48: {                result.hasMaxClusterPop = input.ReadUInt32(ref result.maxClusterPop_);                break;              }              case 56: {                object unknown;                if(input.ReadEnum(ref result.clusterPopStatus_' out unknown)) {                  result.hasClusterPopStatus = true;                } else if(unknown is int) {                  if (unknownFields == null) {                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                  }                  unknownFields.MergeVarintField(7' (ulong)(int)unknown);                }                break;              }              case 64: {                result.hasLanguageId = input.ReadUInt32(ref result.languageId_);                break;              }              case 72: {                object unknown;                if(input.ReadEnum(ref result.clusterStatus_' out unknown)) {                  result.hasClusterStatus = true;                } else if(unknown is int) {                  if (unknownFields == null) {                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                  }                  unknownFields.MergeVarintField(9' (ulong)(int)unknown);                }                break;              }              case 82: {                input.ReadMessageArray(tag' field_name' result.serverList_' global::FrameWork.ServerInfo.DefaultInstance' extensionRegistry);                break;              }              case 90: {                input.ReadMessageArray(tag' field_name' result.propertyList_' global::FrameWork.ClusterProp.DefaultInstance' extensionRegistry);                break;              }            }          }
Magic Number,FrameWork,Builder,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The following statement contains a magic number: while (input.ReadTag(out tag' out field_name)) {            if(tag == 0 && field_name != null) {              int field_ordinal = global::System.Array.BinarySearch(_getClusterListReplyFieldNames' field_name' global::System.StringComparer.Ordinal);              if(field_ordinal >= 0)                tag = _getClusterListReplyFieldTags[field_ordinal];              else {                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                continue;              }            }            switch (tag) {              case 0: {                throw pb::InvalidProtocolBufferException.InvalidTag();              }              default: {                if (pb::WireFormat.IsEndGroupTag(tag)) {                  if (unknownFields != null) {                    this.UnknownFields = unknownFields.Build();                  }                  return this;                }                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                break;              }              case 8: {                object unknown;                if(input.ReadEnum(ref result.resultCode_' out unknown)) {                  result.hasResultCode = true;                } else if(unknown is int) {                  if (unknownFields == null) {                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                  }                  unknownFields.MergeVarintField(1' (ulong)(int)unknown);                }                break;              }              case 18: {                input.ReadMessageArray(tag' field_name' result.clusterList_' global::FrameWork.ClusterInfo.DefaultInstance' extensionRegistry);                break;              }            }          }
Magic Number,FrameWork,Builder,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The following statement contains a magic number: while (input.ReadTag(out tag' out field_name)) {            if(tag == 0 && field_name != null) {              int field_ordinal = global::System.Array.BinarySearch(_getClusterListReplyFieldNames' field_name' global::System.StringComparer.Ordinal);              if(field_ordinal >= 0)                tag = _getClusterListReplyFieldTags[field_ordinal];              else {                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                continue;              }            }            switch (tag) {              case 0: {                throw pb::InvalidProtocolBufferException.InvalidTag();              }              default: {                if (pb::WireFormat.IsEndGroupTag(tag)) {                  if (unknownFields != null) {                    this.UnknownFields = unknownFields.Build();                  }                  return this;                }                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                break;              }              case 8: {                object unknown;                if(input.ReadEnum(ref result.resultCode_' out unknown)) {                  result.hasResultCode = true;                } else if(unknown is int) {                  if (unknownFields == null) {                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                  }                  unknownFields.MergeVarintField(1' (ulong)(int)unknown);                }                break;              }              case 18: {                input.ReadMessageArray(tag' field_name' result.clusterList_' global::FrameWork.ClusterInfo.DefaultInstance' extensionRegistry);                break;              }            }          }
Magic Number,FrameWork,Builder,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The following statement contains a magic number: while (input.ReadTag(out tag' out field_name)) {            if(tag == 0 && field_name != null) {              int field_ordinal = global::System.Array.BinarySearch(_verifyProtocolReplyFieldNames' field_name' global::System.StringComparer.Ordinal);              if(field_ordinal >= 0)                tag = _verifyProtocolReplyFieldTags[field_ordinal];              else {                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                continue;              }            }            switch (tag) {              case 0: {                throw pb::InvalidProtocolBufferException.InvalidTag();              }              default: {                if (pb::WireFormat.IsEndGroupTag(tag)) {                  if (unknownFields != null) {                    this.UnknownFields = unknownFields.Build();                  }                  return this;                }                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                break;              }              case 8: {                object unknown;                if(input.ReadEnum(ref result.resultCode_' out unknown)) {                  result.hasResultCode = true;                } else if(unknown is int) {                  if (unknownFields == null) {                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                  }                  unknownFields.MergeVarintField(1' (ulong)(int)unknown);                }                break;              }              case 18: {                result.hasIv1 = input.ReadBytes(ref result.iv1_);                break;              }              case 26: {                result.hasIv2 = input.ReadBytes(ref result.iv2_);                break;              }            }          }
Magic Number,FrameWork,Builder,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The following statement contains a magic number: while (input.ReadTag(out tag' out field_name)) {            if(tag == 0 && field_name != null) {              int field_ordinal = global::System.Array.BinarySearch(_verifyProtocolReplyFieldNames' field_name' global::System.StringComparer.Ordinal);              if(field_ordinal >= 0)                tag = _verifyProtocolReplyFieldTags[field_ordinal];              else {                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                continue;              }            }            switch (tag) {              case 0: {                throw pb::InvalidProtocolBufferException.InvalidTag();              }              default: {                if (pb::WireFormat.IsEndGroupTag(tag)) {                  if (unknownFields != null) {                    this.UnknownFields = unknownFields.Build();                  }                  return this;                }                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                break;              }              case 8: {                object unknown;                if(input.ReadEnum(ref result.resultCode_' out unknown)) {                  result.hasResultCode = true;                } else if(unknown is int) {                  if (unknownFields == null) {                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                  }                  unknownFields.MergeVarintField(1' (ulong)(int)unknown);                }                break;              }              case 18: {                result.hasIv1 = input.ReadBytes(ref result.iv1_);                break;              }              case 26: {                result.hasIv2 = input.ReadBytes(ref result.iv2_);                break;              }            }          }
Magic Number,FrameWork,Builder,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The following statement contains a magic number: while (input.ReadTag(out tag' out field_name)) {            if(tag == 0 && field_name != null) {              int field_ordinal = global::System.Array.BinarySearch(_verifyProtocolReplyFieldNames' field_name' global::System.StringComparer.Ordinal);              if(field_ordinal >= 0)                tag = _verifyProtocolReplyFieldTags[field_ordinal];              else {                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                continue;              }            }            switch (tag) {              case 0: {                throw pb::InvalidProtocolBufferException.InvalidTag();              }              default: {                if (pb::WireFormat.IsEndGroupTag(tag)) {                  if (unknownFields != null) {                    this.UnknownFields = unknownFields.Build();                  }                  return this;                }                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                break;              }              case 8: {                object unknown;                if(input.ReadEnum(ref result.resultCode_' out unknown)) {                  result.hasResultCode = true;                } else if(unknown is int) {                  if (unknownFields == null) {                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                  }                  unknownFields.MergeVarintField(1' (ulong)(int)unknown);                }                break;              }              case 18: {                result.hasIv1 = input.ReadBytes(ref result.iv1_);                break;              }              case 26: {                result.hasIv2 = input.ReadBytes(ref result.iv2_);                break;              }            }          }
Magic Number,FrameWork,Builder,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The following statement contains a magic number: while (input.ReadTag(out tag' out field_name)) {            if(tag == 0 && field_name != null) {              int field_ordinal = global::System.Array.BinarySearch(_verifyProtocolReqFieldNames' field_name' global::System.StringComparer.Ordinal);              if(field_ordinal >= 0)                tag = _verifyProtocolReqFieldTags[field_ordinal];              else {                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                continue;              }            }            switch (tag) {              case 0: {                throw pb::InvalidProtocolBufferException.InvalidTag();              }              default: {                if (pb::WireFormat.IsEndGroupTag(tag)) {                  if (unknownFields != null) {                    this.UnknownFields = unknownFields.Build();                  }                  return this;                }                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                break;              }              case 8: {                result.hasProtocolVersion = input.ReadUInt32(ref result.protocolVersion_);                break;              }              case 16: {                result.hasProductId = input.ReadUInt32(ref result.productId_);                break;              }              case 26: {                result.hasClientPublicKey = input.ReadBytes(ref result.clientPublicKey_);                break;              }            }          }
Magic Number,FrameWork,Builder,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The following statement contains a magic number: while (input.ReadTag(out tag' out field_name)) {            if(tag == 0 && field_name != null) {              int field_ordinal = global::System.Array.BinarySearch(_verifyProtocolReqFieldNames' field_name' global::System.StringComparer.Ordinal);              if(field_ordinal >= 0)                tag = _verifyProtocolReqFieldTags[field_ordinal];              else {                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                continue;              }            }            switch (tag) {              case 0: {                throw pb::InvalidProtocolBufferException.InvalidTag();              }              default: {                if (pb::WireFormat.IsEndGroupTag(tag)) {                  if (unknownFields != null) {                    this.UnknownFields = unknownFields.Build();                  }                  return this;                }                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                break;              }              case 8: {                result.hasProtocolVersion = input.ReadUInt32(ref result.protocolVersion_);                break;              }              case 16: {                result.hasProductId = input.ReadUInt32(ref result.productId_);                break;              }              case 26: {                result.hasClientPublicKey = input.ReadBytes(ref result.clientPublicKey_);                break;              }            }          }
Magic Number,FrameWork,Builder,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The following statement contains a magic number: while (input.ReadTag(out tag' out field_name)) {            if(tag == 0 && field_name != null) {              int field_ordinal = global::System.Array.BinarySearch(_verifyProtocolReqFieldNames' field_name' global::System.StringComparer.Ordinal);              if(field_ordinal >= 0)                tag = _verifyProtocolReqFieldTags[field_ordinal];              else {                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                continue;              }            }            switch (tag) {              case 0: {                throw pb::InvalidProtocolBufferException.InvalidTag();              }              default: {                if (pb::WireFormat.IsEndGroupTag(tag)) {                  if (unknownFields != null) {                    this.UnknownFields = unknownFields.Build();                  }                  return this;                }                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                break;              }              case 8: {                result.hasProtocolVersion = input.ReadUInt32(ref result.protocolVersion_);                break;              }              case 16: {                result.hasProductId = input.ReadUInt32(ref result.productId_);                break;              }              case 26: {                result.hasClientPublicKey = input.ReadBytes(ref result.clientPublicKey_);                break;              }            }          }
Magic Number,FrameWork,GetAcctPropListReply,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetAcctPropListReplyProto.cs,WriteTo,The following statement contains a magic number: if (propList_.Count > 0) {          output.WriteMessageArray(2' field_names[0]' propList_);        }
Magic Number,FrameWork,AcctProp,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetAcctPropListReplyProto.cs,WriteTo,The following statement contains a magic number: if (hasPropertyValue) {              output.WriteInt32(2' field_names[1]' PropertyValue);            }
Magic Number,FrameWork,GetCharSummaryListReply,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetCharSummaryListReplyProto.cs,WriteTo,The following statement contains a magic number: if (summaryList_.Count > 0) {          output.WriteMessageArray(2' field_names[1]' summaryList_);        }
Magic Number,FrameWork,CharSummary,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetCharSummaryListReplyProto.cs,WriteTo,The following statement contains a magic number: if (hasServerId) {              output.WriteUInt32(1' field_names[2]' ServerId);            }
Magic Number,FrameWork,CharSummary,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetCharSummaryListReplyProto.cs,WriteTo,The following statement contains a magic number: if (hasCharacterId) {              output.WriteUInt32(2' field_names[0]' CharacterId);            }
Magic Number,FrameWork,CharSummary,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetCharSummaryListReplyProto.cs,WriteTo,The following statement contains a magic number: if (hasLastPlayedTime) {              output.WriteInt64(3' field_names[1]' LastPlayedTime);            }
Magic Number,FrameWork,CharSummary,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetCharSummaryListReplyProto.cs,WriteTo,The following statement contains a magic number: if (hasXmlData) {              output.WriteString(4' field_names[3]' XmlData);            }
Magic Number,FrameWork,CharSummary,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetCharSummaryListReplyProto.cs,WriteTo,The following statement contains a magic number: if (hasXmlData) {              output.WriteString(4' field_names[3]' XmlData);            }
Magic Number,FrameWork,GetClusterListReplyProto,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetClusterListReplyProto.cs,GetClusterListReplyProto,The following statement contains a magic number: pbd::FileDescriptor.InternalDescriptorAssigner assigner = delegate(pbd::FileDescriptor root) {          descriptor = root;          internal__static_login_proto_ServerInfo__Descriptor = Descriptor.MessageTypes[0];          internal__static_login_proto_ServerInfo__FieldAccessorTable =               new pb::FieldAccess.FieldAccessorTable<global::FrameWork.ServerInfo' global::FrameWork.ServerInfo.Builder>(internal__static_login_proto_ServerInfo__Descriptor'                  new string[] { "ServerId"' "ServerName"' });          internal__static_login_proto_ClusterProp__Descriptor = Descriptor.MessageTypes[1];          internal__static_login_proto_ClusterProp__FieldAccessorTable =               new pb::FieldAccess.FieldAccessorTable<global::FrameWork.ClusterProp' global::FrameWork.ClusterProp.Builder>(internal__static_login_proto_ClusterProp__Descriptor'                  new string[] { "PropName"' "PropValue"' });          internal__static_login_proto_ClusterInfo__Descriptor = Descriptor.MessageTypes[2];          internal__static_login_proto_ClusterInfo__FieldAccessorTable =               new pb::FieldAccess.FieldAccessorTable<global::FrameWork.ClusterInfo' global::FrameWork.ClusterInfo.Builder>(internal__static_login_proto_ClusterInfo__Descriptor'                  new string[] { "ClusterId"' "ClusterName"' "LobbyHost"' "LobbyPort"' "ClusterPop"' "MaxClusterPop"' "ClusterPopStatus"' "LanguageId"' "ClusterStatus"' "ServerList"' "PropertyList"' });          internal__static_login_proto_GetClusterListReply__Descriptor = Descriptor.MessageTypes[3];          internal__static_login_proto_GetClusterListReply__FieldAccessorTable =               new pb::FieldAccess.FieldAccessorTable<global::FrameWork.GetClusterListReply' global::FrameWork.GetClusterListReply.Builder>(internal__static_login_proto_GetClusterListReply__Descriptor'                  new string[] { "ResultCode"' "ClusterList"' });          pb::ExtensionRegistry registry = pb::ExtensionRegistry.CreateInstance();          RegisterAllExtensions(registry);          global::Google.ProtocolBuffers.DescriptorProtos.CSharpOptions.RegisterAllExtensions(registry);          return registry;        };
Magic Number,FrameWork,GetClusterListReplyProto,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetClusterListReplyProto.cs,GetClusterListReplyProto,The following statement contains a magic number: pbd::FileDescriptor.InternalDescriptorAssigner assigner = delegate(pbd::FileDescriptor root) {          descriptor = root;          internal__static_login_proto_ServerInfo__Descriptor = Descriptor.MessageTypes[0];          internal__static_login_proto_ServerInfo__FieldAccessorTable =               new pb::FieldAccess.FieldAccessorTable<global::FrameWork.ServerInfo' global::FrameWork.ServerInfo.Builder>(internal__static_login_proto_ServerInfo__Descriptor'                  new string[] { "ServerId"' "ServerName"' });          internal__static_login_proto_ClusterProp__Descriptor = Descriptor.MessageTypes[1];          internal__static_login_proto_ClusterProp__FieldAccessorTable =               new pb::FieldAccess.FieldAccessorTable<global::FrameWork.ClusterProp' global::FrameWork.ClusterProp.Builder>(internal__static_login_proto_ClusterProp__Descriptor'                  new string[] { "PropName"' "PropValue"' });          internal__static_login_proto_ClusterInfo__Descriptor = Descriptor.MessageTypes[2];          internal__static_login_proto_ClusterInfo__FieldAccessorTable =               new pb::FieldAccess.FieldAccessorTable<global::FrameWork.ClusterInfo' global::FrameWork.ClusterInfo.Builder>(internal__static_login_proto_ClusterInfo__Descriptor'                  new string[] { "ClusterId"' "ClusterName"' "LobbyHost"' "LobbyPort"' "ClusterPop"' "MaxClusterPop"' "ClusterPopStatus"' "LanguageId"' "ClusterStatus"' "ServerList"' "PropertyList"' });          internal__static_login_proto_GetClusterListReply__Descriptor = Descriptor.MessageTypes[3];          internal__static_login_proto_GetClusterListReply__FieldAccessorTable =               new pb::FieldAccess.FieldAccessorTable<global::FrameWork.GetClusterListReply' global::FrameWork.GetClusterListReply.Builder>(internal__static_login_proto_GetClusterListReply__Descriptor'                  new string[] { "ResultCode"' "ClusterList"' });          pb::ExtensionRegistry registry = pb::ExtensionRegistry.CreateInstance();          RegisterAllExtensions(registry);          global::Google.ProtocolBuffers.DescriptorProtos.CSharpOptions.RegisterAllExtensions(registry);          return registry;        };
Magic Number,FrameWork,ServerInfo,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetClusterListReplyProto.cs,WriteTo,The following statement contains a magic number: if (hasServerName) {          output.WriteString(2' field_names[1]' ServerName);        }
Magic Number,FrameWork,ClusterProp,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetClusterListReplyProto.cs,WriteTo,The following statement contains a magic number: if (hasPropValue) {          output.WriteString(2' field_names[1]' PropValue);        }
Magic Number,FrameWork,ClusterInfo,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetClusterListReplyProto.cs,WriteTo,The following statement contains a magic number: if (hasClusterName) {          output.WriteString(2' field_names[1]' ClusterName);        }
Magic Number,FrameWork,ClusterInfo,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetClusterListReplyProto.cs,WriteTo,The following statement contains a magic number: if (hasLobbyHost) {          output.WriteString(3' field_names[6]' LobbyHost);        }
Magic Number,FrameWork,ClusterInfo,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetClusterListReplyProto.cs,WriteTo,The following statement contains a magic number: if (hasLobbyHost) {          output.WriteString(3' field_names[6]' LobbyHost);        }
Magic Number,FrameWork,ClusterInfo,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetClusterListReplyProto.cs,WriteTo,The following statement contains a magic number: if (hasLobbyPort) {          output.WriteUInt32(4' field_names[7]' LobbyPort);        }
Magic Number,FrameWork,ClusterInfo,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetClusterListReplyProto.cs,WriteTo,The following statement contains a magic number: if (hasLobbyPort) {          output.WriteUInt32(4' field_names[7]' LobbyPort);        }
Magic Number,FrameWork,ClusterInfo,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetClusterListReplyProto.cs,WriteTo,The following statement contains a magic number: if (hasClusterPop) {          output.WriteUInt32(5' field_names[2]' ClusterPop);        }
Magic Number,FrameWork,ClusterInfo,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetClusterListReplyProto.cs,WriteTo,The following statement contains a magic number: if (hasClusterPop) {          output.WriteUInt32(5' field_names[2]' ClusterPop);        }
Magic Number,FrameWork,ClusterInfo,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetClusterListReplyProto.cs,WriteTo,The following statement contains a magic number: if (hasMaxClusterPop) {          output.WriteUInt32(6' field_names[8]' MaxClusterPop);        }
Magic Number,FrameWork,ClusterInfo,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetClusterListReplyProto.cs,WriteTo,The following statement contains a magic number: if (hasMaxClusterPop) {          output.WriteUInt32(6' field_names[8]' MaxClusterPop);        }
Magic Number,FrameWork,ClusterInfo,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetClusterListReplyProto.cs,WriteTo,The following statement contains a magic number: if (hasClusterPopStatus) {          output.WriteEnum(7' field_names[3]' (int) ClusterPopStatus' ClusterPopStatus);        }
Magic Number,FrameWork,ClusterInfo,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetClusterListReplyProto.cs,WriteTo,The following statement contains a magic number: if (hasClusterPopStatus) {          output.WriteEnum(7' field_names[3]' (int) ClusterPopStatus' ClusterPopStatus);        }
Magic Number,FrameWork,ClusterInfo,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetClusterListReplyProto.cs,WriteTo,The following statement contains a magic number: if (hasLanguageId) {          output.WriteUInt32(8' field_names[5]' LanguageId);        }
Magic Number,FrameWork,ClusterInfo,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetClusterListReplyProto.cs,WriteTo,The following statement contains a magic number: if (hasLanguageId) {          output.WriteUInt32(8' field_names[5]' LanguageId);        }
Magic Number,FrameWork,ClusterInfo,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetClusterListReplyProto.cs,WriteTo,The following statement contains a magic number: if (hasClusterStatus) {          output.WriteEnum(9' field_names[4]' (int) ClusterStatus' ClusterStatus);        }
Magic Number,FrameWork,ClusterInfo,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetClusterListReplyProto.cs,WriteTo,The following statement contains a magic number: if (hasClusterStatus) {          output.WriteEnum(9' field_names[4]' (int) ClusterStatus' ClusterStatus);        }
Magic Number,FrameWork,ClusterInfo,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetClusterListReplyProto.cs,WriteTo,The following statement contains a magic number: if (serverList_.Count > 0) {          output.WriteMessageArray(10' field_names[10]' serverList_);        }
Magic Number,FrameWork,ClusterInfo,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetClusterListReplyProto.cs,WriteTo,The following statement contains a magic number: if (serverList_.Count > 0) {          output.WriteMessageArray(10' field_names[10]' serverList_);        }
Magic Number,FrameWork,ClusterInfo,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetClusterListReplyProto.cs,WriteTo,The following statement contains a magic number: if (propertyList_.Count > 0) {          output.WriteMessageArray(11' field_names[9]' propertyList_);        }
Magic Number,FrameWork,ClusterInfo,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetClusterListReplyProto.cs,WriteTo,The following statement contains a magic number: if (propertyList_.Count > 0) {          output.WriteMessageArray(11' field_names[9]' propertyList_);        }
Magic Number,FrameWork,GetClusterListReply,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetClusterListReplyProto.cs,WriteTo,The following statement contains a magic number: if (clusterList_.Count > 0) {          output.WriteMessageArray(2' field_names[0]' clusterList_);        }
Magic Number,FrameWork,VerifyProtocolReply,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\VerifyProtocolReplyProto.cs,WriteTo,The following statement contains a magic number: if (hasResultCode) {          output.WriteEnum(1' field_names[2]' (int) ResultCode' ResultCode);        }
Magic Number,FrameWork,VerifyProtocolReply,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\VerifyProtocolReplyProto.cs,WriteTo,The following statement contains a magic number: if (hasIv1) {          output.WriteBytes(2' field_names[0]' Iv1);        }
Magic Number,FrameWork,VerifyProtocolReply,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\VerifyProtocolReplyProto.cs,WriteTo,The following statement contains a magic number: if (hasIv2) {          output.WriteBytes(3' field_names[1]' Iv2);        }
Magic Number,FrameWork,VerifyProtocolReq,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\VerifyProtocolReqProto.cs,WriteTo,The following statement contains a magic number: if (hasProtocolVersion) {          output.WriteUInt32(1' field_names[2]' ProtocolVersion);        }
Magic Number,FrameWork,VerifyProtocolReq,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\VerifyProtocolReqProto.cs,WriteTo,The following statement contains a magic number: if (hasProductId) {          output.WriteUInt32(2' field_names[1]' ProductId);        }
Magic Number,FrameWork,VerifyProtocolReq,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\VerifyProtocolReqProto.cs,WriteTo,The following statement contains a magic number: if (hasClientPublicKey) {          output.WriteBytes(3' field_names[0]' ClientPublicKey);        }
Magic Number,FrameWork,TCPManager,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\TCPManager.cs,GenerateId,The following statement contains a magic number: for (int i = 10; i < Clients.Length; ++i)              {                  if (Clients[i] == null)                  {                      Client.Id = i;                      Clients[i] = Client;                      break;                  }              }
Magic Number,FrameWork,TCPManager,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\TCPManager.cs,GetTimeStamp,The following statement contains a magic number: return (int)(DateTime.UtcNow - new DateTime(1970' 1' 1)).TotalSeconds;
Magic Number,FrameWork,TCPManager,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\TCPManager.cs,GetTimeStampMS,The following statement contains a magic number: return (long)(DateTime.UtcNow - new DateTime(1970' 1' 1)).TotalMilliseconds;
Magic Number,FrameWork,RpcObject,C:\repos\WarEmu_WarEmu\FrameWork\Remoting\RpcObject.cs,RegisterHandlers,The following statement contains a magic number: List<Type>[] Registered = new List<Type>[2] { new List<Type>()' new List<Type>() };
Magic Number,FrameWork,Utils,C:\repos\WarEmu_WarEmu\FrameWork\Utils\Utils.cs,StringToVector,The following statement contains a magic number: return new Vector3(Value[0]' Value[1]' Value[2]);
Magic Number,FrameWork,Utils,C:\repos\WarEmu_WarEmu\FrameWork\Utils\Utils.cs,StringToPosition,The following statement contains a magic number: float[] Result = new float[3] { 0' 0' 0 };
Magic Number,FrameWork,Utils,C:\repos\WarEmu_WarEmu\FrameWork\Utils\Utils.cs,StringToColor,The following statement contains a magic number: Col.B = float.Parse(Bytes[2]);
Magic Number,FrameWork,Utils,C:\repos\WarEmu_WarEmu\FrameWork\Utils\Utils.cs,StringToColor,The following statement contains a magic number: Col.A = float.Parse(Bytes[3]);
Magic Number,FrameWork,Utils,C:\repos\WarEmu_WarEmu\FrameWork\Utils\Utils.cs,Encode2Values,The following statement contains a magic number: return (long)(P1 << 32 + P2);
Magic Number,FrameWork,Utils,C:\repos\WarEmu_WarEmu\FrameWork\Utils\Utils.cs,Decode2Values,The following statement contains a magic number: P1 = (int)(Value >> 32);
Magic Number,FrameWork,Utils,C:\repos\WarEmu_WarEmu\FrameWork\Utils\Utils.cs,Encode2Values,The following statement contains a magic number: return (int)(P1 << 16 + P2);
Magic Number,FrameWork,Utils,C:\repos\WarEmu_WarEmu\FrameWork\Utils\Utils.cs,Decode2Values,The following statement contains a magic number: P1 = (ushort)(Value >> 16);
Magic Number,FrameWork,Utils,C:\repos\WarEmu_WarEmu\FrameWork\Utils\Utils.cs,Encode2Values,The following statement contains a magic number: return (ushort)((P1 << 8) + P2);
Magic Number,FrameWork,Utils,C:\repos\WarEmu_WarEmu\FrameWork\Utils\Utils.cs,Decode2Values,The following statement contains a magic number: P1 = (byte)(Value >> 8);
Magic Number,FrameWork,Utils,C:\repos\WarEmu_WarEmu\FrameWork\Utils\Utils.cs,Encode4Values,The following statement contains a magic number: return (int)((P1 << 24) + (P2 << 16) + (P3 << 8) + P4);
Magic Number,FrameWork,Utils,C:\repos\WarEmu_WarEmu\FrameWork\Utils\Utils.cs,Encode4Values,The following statement contains a magic number: return (int)((P1 << 24) + (P2 << 16) + (P3 << 8) + P4);
Magic Number,FrameWork,Utils,C:\repos\WarEmu_WarEmu\FrameWork\Utils\Utils.cs,Encode4Values,The following statement contains a magic number: return (int)((P1 << 24) + (P2 << 16) + (P3 << 8) + P4);
Magic Number,FrameWork,Utils,C:\repos\WarEmu_WarEmu\FrameWork\Utils\Utils.cs,Decode4Values,The following statement contains a magic number: P1 = (byte)(Value >> 24);
Magic Number,FrameWork,Utils,C:\repos\WarEmu_WarEmu\FrameWork\Utils\Utils.cs,Decode4Values,The following statement contains a magic number: P2 = (byte)(Value >> 16);
Magic Number,FrameWork,Utils,C:\repos\WarEmu_WarEmu\FrameWork\Utils\Utils.cs,Decode4Values,The following statement contains a magic number: P3 = (byte)(Value >> 8);
Magic Number,FrameWork,Adler32,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Adler32.cs,adler32,The following statement contains a magic number: long s2 = (adler >> 16) & 0xffff;
Magic Number,FrameWork,Adler32,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Adler32.cs,adler32,The following statement contains a magic number: while (len > 0)  			{  				k = len < NMAX?len:NMAX;  				len -= k;  				while (k >= 16)  				{  					s1 += (buf[index++] & 0xff); s2 += s1;  					s1 += (buf[index++] & 0xff); s2 += s1;  					s1 += (buf[index++] & 0xff); s2 += s1;  					s1 += (buf[index++] & 0xff); s2 += s1;  					s1 += (buf[index++] & 0xff); s2 += s1;  					s1 += (buf[index++] & 0xff); s2 += s1;  					s1 += (buf[index++] & 0xff); s2 += s1;  					s1 += (buf[index++] & 0xff); s2 += s1;  					s1 += (buf[index++] & 0xff); s2 += s1;  					s1 += (buf[index++] & 0xff); s2 += s1;  					s1 += (buf[index++] & 0xff); s2 += s1;  					s1 += (buf[index++] & 0xff); s2 += s1;  					s1 += (buf[index++] & 0xff); s2 += s1;  					s1 += (buf[index++] & 0xff); s2 += s1;  					s1 += (buf[index++] & 0xff); s2 += s1;  					s1 += (buf[index++] & 0xff); s2 += s1;  					k -= 16;  				}  				if (k != 0)  				{  					do   					{  						s1 += (buf[index++] & 0xff); s2 += s1;  					}  					while (--k != 0);  				}  				s1 %= BASE;  				s2 %= BASE;  			}
Magic Number,FrameWork,Adler32,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Adler32.cs,adler32,The following statement contains a magic number: while (len > 0)  			{  				k = len < NMAX?len:NMAX;  				len -= k;  				while (k >= 16)  				{  					s1 += (buf[index++] & 0xff); s2 += s1;  					s1 += (buf[index++] & 0xff); s2 += s1;  					s1 += (buf[index++] & 0xff); s2 += s1;  					s1 += (buf[index++] & 0xff); s2 += s1;  					s1 += (buf[index++] & 0xff); s2 += s1;  					s1 += (buf[index++] & 0xff); s2 += s1;  					s1 += (buf[index++] & 0xff); s2 += s1;  					s1 += (buf[index++] & 0xff); s2 += s1;  					s1 += (buf[index++] & 0xff); s2 += s1;  					s1 += (buf[index++] & 0xff); s2 += s1;  					s1 += (buf[index++] & 0xff); s2 += s1;  					s1 += (buf[index++] & 0xff); s2 += s1;  					s1 += (buf[index++] & 0xff); s2 += s1;  					s1 += (buf[index++] & 0xff); s2 += s1;  					s1 += (buf[index++] & 0xff); s2 += s1;  					s1 += (buf[index++] & 0xff); s2 += s1;  					k -= 16;  				}  				if (k != 0)  				{  					do   					{  						s1 += (buf[index++] & 0xff); s2 += s1;  					}  					while (--k != 0);  				}  				s1 %= BASE;  				s2 %= BASE;  			}
Magic Number,FrameWork,Adler32,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Adler32.cs,adler32,The following statement contains a magic number: return (s2 << 16) | s1;
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: dyn_ltree = new short[HEAP_SIZE * 2];
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: dyn_dtree = new short[(2 * D_CODES + 1) * 2];
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: dyn_dtree = new short[(2 * D_CODES + 1) * 2];
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: bl_tree = new short[(2 * BL_CODES + 1) * 2];
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: bl_tree = new short[(2 * BL_CODES + 1) * 2];
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,lm_init,The following statement contains a magic number: window_size = 2 * w_size;
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,tr_init,The following statement contains a magic number: last_eob_len = 8;
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,init_block,The following statement contains a magic number: for (int i = 0; i < L_CODES; i++)  				dyn_ltree[i * 2] = 0;
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,init_block,The following statement contains a magic number: for (int i = 0; i < D_CODES; i++)  				dyn_dtree[i * 2] = 0;
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,init_block,The following statement contains a magic number: for (int i = 0; i < BL_CODES; i++)  				bl_tree[i * 2] = 0;
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,init_block,The following statement contains a magic number: dyn_ltree[END_BLOCK * 2] = 1;
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,smaller,The following statement contains a magic number: return (tree[n * 2] < tree[m * 2] || (tree[n * 2] == tree[m * 2] && depth[n] <= depth[m]));
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,smaller,The following statement contains a magic number: return (tree[n * 2] < tree[m * 2] || (tree[n * 2] == tree[m * 2] && depth[n] <= depth[m]));
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,smaller,The following statement contains a magic number: return (tree[n * 2] < tree[m * 2] || (tree[n * 2] == tree[m * 2] && depth[n] <= depth[m]));
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,smaller,The following statement contains a magic number: return (tree[n * 2] < tree[m * 2] || (tree[n * 2] == tree[m * 2] && depth[n] <= depth[m]));
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: int nextlen = tree[0 * 2 + 1];
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: int max_count = 7;
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: int min_count = 4;
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (nextlen == 0)  			{  				max_count = 138; min_count = 3;  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (nextlen == 0)  			{  				max_count = 138; min_count = 3;  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: tree[(max_code + 1) * 2 + 1] = (short) SupportClass.Identity(0xffff);
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  				else if (count < min_count)  				{  					bl_tree[curlen * 2] = (short) (bl_tree[curlen * 2] + count);  				}  				else if (curlen != 0)  				{  					if (curlen != prevlen)  						bl_tree[curlen * 2]++;  					bl_tree[REP_3_6 * 2]++;  				}  				else if (count <= 10)  				{  					bl_tree[REPZ_3_10 * 2]++;  				}  				else  				{  					bl_tree[REPZ_11_138 * 2]++;  				}  				count = 0; prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138; min_count = 3;  				}  				else if (curlen == nextlen)  				{  					max_count = 6; min_count = 3;  				}  				else  				{  					max_count = 7; min_count = 4;  				}  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  				else if (count < min_count)  				{  					bl_tree[curlen * 2] = (short) (bl_tree[curlen * 2] + count);  				}  				else if (curlen != 0)  				{  					if (curlen != prevlen)  						bl_tree[curlen * 2]++;  					bl_tree[REP_3_6 * 2]++;  				}  				else if (count <= 10)  				{  					bl_tree[REPZ_3_10 * 2]++;  				}  				else  				{  					bl_tree[REPZ_11_138 * 2]++;  				}  				count = 0; prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138; min_count = 3;  				}  				else if (curlen == nextlen)  				{  					max_count = 6; min_count = 3;  				}  				else  				{  					max_count = 7; min_count = 4;  				}  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  				else if (count < min_count)  				{  					bl_tree[curlen * 2] = (short) (bl_tree[curlen * 2] + count);  				}  				else if (curlen != 0)  				{  					if (curlen != prevlen)  						bl_tree[curlen * 2]++;  					bl_tree[REP_3_6 * 2]++;  				}  				else if (count <= 10)  				{  					bl_tree[REPZ_3_10 * 2]++;  				}  				else  				{  					bl_tree[REPZ_11_138 * 2]++;  				}  				count = 0; prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138; min_count = 3;  				}  				else if (curlen == nextlen)  				{  					max_count = 6; min_count = 3;  				}  				else  				{  					max_count = 7; min_count = 4;  				}  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  				else if (count < min_count)  				{  					bl_tree[curlen * 2] = (short) (bl_tree[curlen * 2] + count);  				}  				else if (curlen != 0)  				{  					if (curlen != prevlen)  						bl_tree[curlen * 2]++;  					bl_tree[REP_3_6 * 2]++;  				}  				else if (count <= 10)  				{  					bl_tree[REPZ_3_10 * 2]++;  				}  				else  				{  					bl_tree[REPZ_11_138 * 2]++;  				}  				count = 0; prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138; min_count = 3;  				}  				else if (curlen == nextlen)  				{  					max_count = 6; min_count = 3;  				}  				else  				{  					max_count = 7; min_count = 4;  				}  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  				else if (count < min_count)  				{  					bl_tree[curlen * 2] = (short) (bl_tree[curlen * 2] + count);  				}  				else if (curlen != 0)  				{  					if (curlen != prevlen)  						bl_tree[curlen * 2]++;  					bl_tree[REP_3_6 * 2]++;  				}  				else if (count <= 10)  				{  					bl_tree[REPZ_3_10 * 2]++;  				}  				else  				{  					bl_tree[REPZ_11_138 * 2]++;  				}  				count = 0; prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138; min_count = 3;  				}  				else if (curlen == nextlen)  				{  					max_count = 6; min_count = 3;  				}  				else  				{  					max_count = 7; min_count = 4;  				}  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  				else if (count < min_count)  				{  					bl_tree[curlen * 2] = (short) (bl_tree[curlen * 2] + count);  				}  				else if (curlen != 0)  				{  					if (curlen != prevlen)  						bl_tree[curlen * 2]++;  					bl_tree[REP_3_6 * 2]++;  				}  				else if (count <= 10)  				{  					bl_tree[REPZ_3_10 * 2]++;  				}  				else  				{  					bl_tree[REPZ_11_138 * 2]++;  				}  				count = 0; prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138; min_count = 3;  				}  				else if (curlen == nextlen)  				{  					max_count = 6; min_count = 3;  				}  				else  				{  					max_count = 7; min_count = 4;  				}  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  				else if (count < min_count)  				{  					bl_tree[curlen * 2] = (short) (bl_tree[curlen * 2] + count);  				}  				else if (curlen != 0)  				{  					if (curlen != prevlen)  						bl_tree[curlen * 2]++;  					bl_tree[REP_3_6 * 2]++;  				}  				else if (count <= 10)  				{  					bl_tree[REPZ_3_10 * 2]++;  				}  				else  				{  					bl_tree[REPZ_11_138 * 2]++;  				}  				count = 0; prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138; min_count = 3;  				}  				else if (curlen == nextlen)  				{  					max_count = 6; min_count = 3;  				}  				else  				{  					max_count = 7; min_count = 4;  				}  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  				else if (count < min_count)  				{  					bl_tree[curlen * 2] = (short) (bl_tree[curlen * 2] + count);  				}  				else if (curlen != 0)  				{  					if (curlen != prevlen)  						bl_tree[curlen * 2]++;  					bl_tree[REP_3_6 * 2]++;  				}  				else if (count <= 10)  				{  					bl_tree[REPZ_3_10 * 2]++;  				}  				else  				{  					bl_tree[REPZ_11_138 * 2]++;  				}  				count = 0; prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138; min_count = 3;  				}  				else if (curlen == nextlen)  				{  					max_count = 6; min_count = 3;  				}  				else  				{  					max_count = 7; min_count = 4;  				}  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  				else if (count < min_count)  				{  					bl_tree[curlen * 2] = (short) (bl_tree[curlen * 2] + count);  				}  				else if (curlen != 0)  				{  					if (curlen != prevlen)  						bl_tree[curlen * 2]++;  					bl_tree[REP_3_6 * 2]++;  				}  				else if (count <= 10)  				{  					bl_tree[REPZ_3_10 * 2]++;  				}  				else  				{  					bl_tree[REPZ_11_138 * 2]++;  				}  				count = 0; prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138; min_count = 3;  				}  				else if (curlen == nextlen)  				{  					max_count = 6; min_count = 3;  				}  				else  				{  					max_count = 7; min_count = 4;  				}  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  				else if (count < min_count)  				{  					bl_tree[curlen * 2] = (short) (bl_tree[curlen * 2] + count);  				}  				else if (curlen != 0)  				{  					if (curlen != prevlen)  						bl_tree[curlen * 2]++;  					bl_tree[REP_3_6 * 2]++;  				}  				else if (count <= 10)  				{  					bl_tree[REPZ_3_10 * 2]++;  				}  				else  				{  					bl_tree[REPZ_11_138 * 2]++;  				}  				count = 0; prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138; min_count = 3;  				}  				else if (curlen == nextlen)  				{  					max_count = 6; min_count = 3;  				}  				else  				{  					max_count = 7; min_count = 4;  				}  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  				else if (count < min_count)  				{  					bl_tree[curlen * 2] = (short) (bl_tree[curlen * 2] + count);  				}  				else if (curlen != 0)  				{  					if (curlen != prevlen)  						bl_tree[curlen * 2]++;  					bl_tree[REP_3_6 * 2]++;  				}  				else if (count <= 10)  				{  					bl_tree[REPZ_3_10 * 2]++;  				}  				else  				{  					bl_tree[REPZ_11_138 * 2]++;  				}  				count = 0; prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138; min_count = 3;  				}  				else if (curlen == nextlen)  				{  					max_count = 6; min_count = 3;  				}  				else  				{  					max_count = 7; min_count = 4;  				}  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  				else if (count < min_count)  				{  					bl_tree[curlen * 2] = (short) (bl_tree[curlen * 2] + count);  				}  				else if (curlen != 0)  				{  					if (curlen != prevlen)  						bl_tree[curlen * 2]++;  					bl_tree[REP_3_6 * 2]++;  				}  				else if (count <= 10)  				{  					bl_tree[REPZ_3_10 * 2]++;  				}  				else  				{  					bl_tree[REPZ_11_138 * 2]++;  				}  				count = 0; prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138; min_count = 3;  				}  				else if (curlen == nextlen)  				{  					max_count = 6; min_count = 3;  				}  				else  				{  					max_count = 7; min_count = 4;  				}  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  				else if (count < min_count)  				{  					bl_tree[curlen * 2] = (short) (bl_tree[curlen * 2] + count);  				}  				else if (curlen != 0)  				{  					if (curlen != prevlen)  						bl_tree[curlen * 2]++;  					bl_tree[REP_3_6 * 2]++;  				}  				else if (count <= 10)  				{  					bl_tree[REPZ_3_10 * 2]++;  				}  				else  				{  					bl_tree[REPZ_11_138 * 2]++;  				}  				count = 0; prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138; min_count = 3;  				}  				else if (curlen == nextlen)  				{  					max_count = 6; min_count = 3;  				}  				else  				{  					max_count = 7; min_count = 4;  				}  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  				else if (count < min_count)  				{  					bl_tree[curlen * 2] = (short) (bl_tree[curlen * 2] + count);  				}  				else if (curlen != 0)  				{  					if (curlen != prevlen)  						bl_tree[curlen * 2]++;  					bl_tree[REP_3_6 * 2]++;  				}  				else if (count <= 10)  				{  					bl_tree[REPZ_3_10 * 2]++;  				}  				else  				{  					bl_tree[REPZ_11_138 * 2]++;  				}  				count = 0; prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138; min_count = 3;  				}  				else if (curlen == nextlen)  				{  					max_count = 6; min_count = 3;  				}  				else  				{  					max_count = 7; min_count = 4;  				}  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,build_bl_tree,The following statement contains a magic number: for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--)  			{  				if (bl_tree[Tree.bl_order[max_blindex] * 2 + 1] != 0)  					break;  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,build_bl_tree,The following statement contains a magic number: for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--)  			{  				if (bl_tree[Tree.bl_order[max_blindex] * 2 + 1] != 0)  					break;  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,build_bl_tree,The following statement contains a magic number: opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,build_bl_tree,The following statement contains a magic number: opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,build_bl_tree,The following statement contains a magic number: opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,build_bl_tree,The following statement contains a magic number: opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits(lcodes - 257' 5);
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits(lcodes - 257' 5);
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits(dcodes - 1' 5);
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits(blcodes - 4' 4);
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits(blcodes - 4' 4);
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,send_all_trees,The following statement contains a magic number: for (rank = 0; rank < blcodes; rank++)  			{  				send_bits(bl_tree[Tree.bl_order[rank] * 2 + 1]' 3);  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,send_all_trees,The following statement contains a magic number: for (rank = 0; rank < blcodes; rank++)  			{  				send_bits(bl_tree[Tree.bl_order[rank] * 2 + 1]' 3);  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,send_tree,The following statement contains a magic number: int nextlen = tree[0 * 2 + 1];
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,send_tree,The following statement contains a magic number: int max_count = 7;
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,send_tree,The following statement contains a magic number: int min_count = 4;
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (nextlen == 0)  			{  				max_count = 138; min_count = 3;  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (nextlen == 0)  			{  				max_count = 138; min_count = 3;  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  				else if (count < min_count)  				{  					do   					{  						send_code(curlen' bl_tree);  					}  					while (--count != 0);  				}  				else if (curlen != 0)  				{  					if (curlen != prevlen)  					{  						send_code(curlen' bl_tree); count--;  					}  					send_code(REP_3_6' bl_tree);  					send_bits(count - 3' 2);  				}  				else if (count <= 10)  				{  					send_code(REPZ_3_10' bl_tree);  					send_bits(count - 3' 3);  				}  				else  				{  					send_code(REPZ_11_138' bl_tree);  					send_bits(count - 11' 7);  				}  				count = 0; prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138; min_count = 3;  				}  				else if (curlen == nextlen)  				{  					max_count = 6; min_count = 3;  				}  				else  				{  					max_count = 7; min_count = 4;  				}  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  				else if (count < min_count)  				{  					do   					{  						send_code(curlen' bl_tree);  					}  					while (--count != 0);  				}  				else if (curlen != 0)  				{  					if (curlen != prevlen)  					{  						send_code(curlen' bl_tree); count--;  					}  					send_code(REP_3_6' bl_tree);  					send_bits(count - 3' 2);  				}  				else if (count <= 10)  				{  					send_code(REPZ_3_10' bl_tree);  					send_bits(count - 3' 3);  				}  				else  				{  					send_code(REPZ_11_138' bl_tree);  					send_bits(count - 11' 7);  				}  				count = 0; prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138; min_count = 3;  				}  				else if (curlen == nextlen)  				{  					max_count = 6; min_count = 3;  				}  				else  				{  					max_count = 7; min_count = 4;  				}  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  				else if (count < min_count)  				{  					do   					{  						send_code(curlen' bl_tree);  					}  					while (--count != 0);  				}  				else if (curlen != 0)  				{  					if (curlen != prevlen)  					{  						send_code(curlen' bl_tree); count--;  					}  					send_code(REP_3_6' bl_tree);  					send_bits(count - 3' 2);  				}  				else if (count <= 10)  				{  					send_code(REPZ_3_10' bl_tree);  					send_bits(count - 3' 3);  				}  				else  				{  					send_code(REPZ_11_138' bl_tree);  					send_bits(count - 11' 7);  				}  				count = 0; prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138; min_count = 3;  				}  				else if (curlen == nextlen)  				{  					max_count = 6; min_count = 3;  				}  				else  				{  					max_count = 7; min_count = 4;  				}  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  				else if (count < min_count)  				{  					do   					{  						send_code(curlen' bl_tree);  					}  					while (--count != 0);  				}  				else if (curlen != 0)  				{  					if (curlen != prevlen)  					{  						send_code(curlen' bl_tree); count--;  					}  					send_code(REP_3_6' bl_tree);  					send_bits(count - 3' 2);  				}  				else if (count <= 10)  				{  					send_code(REPZ_3_10' bl_tree);  					send_bits(count - 3' 3);  				}  				else  				{  					send_code(REPZ_11_138' bl_tree);  					send_bits(count - 11' 7);  				}  				count = 0; prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138; min_count = 3;  				}  				else if (curlen == nextlen)  				{  					max_count = 6; min_count = 3;  				}  				else  				{  					max_count = 7; min_count = 4;  				}  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  				else if (count < min_count)  				{  					do   					{  						send_code(curlen' bl_tree);  					}  					while (--count != 0);  				}  				else if (curlen != 0)  				{  					if (curlen != prevlen)  					{  						send_code(curlen' bl_tree); count--;  					}  					send_code(REP_3_6' bl_tree);  					send_bits(count - 3' 2);  				}  				else if (count <= 10)  				{  					send_code(REPZ_3_10' bl_tree);  					send_bits(count - 3' 3);  				}  				else  				{  					send_code(REPZ_11_138' bl_tree);  					send_bits(count - 11' 7);  				}  				count = 0; prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138; min_count = 3;  				}  				else if (curlen == nextlen)  				{  					max_count = 6; min_count = 3;  				}  				else  				{  					max_count = 7; min_count = 4;  				}  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  				else if (count < min_count)  				{  					do   					{  						send_code(curlen' bl_tree);  					}  					while (--count != 0);  				}  				else if (curlen != 0)  				{  					if (curlen != prevlen)  					{  						send_code(curlen' bl_tree); count--;  					}  					send_code(REP_3_6' bl_tree);  					send_bits(count - 3' 2);  				}  				else if (count <= 10)  				{  					send_code(REPZ_3_10' bl_tree);  					send_bits(count - 3' 3);  				}  				else  				{  					send_code(REPZ_11_138' bl_tree);  					send_bits(count - 11' 7);  				}  				count = 0; prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138; min_count = 3;  				}  				else if (curlen == nextlen)  				{  					max_count = 6; min_count = 3;  				}  				else  				{  					max_count = 7; min_count = 4;  				}  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  				else if (count < min_count)  				{  					do   					{  						send_code(curlen' bl_tree);  					}  					while (--count != 0);  				}  				else if (curlen != 0)  				{  					if (curlen != prevlen)  					{  						send_code(curlen' bl_tree); count--;  					}  					send_code(REP_3_6' bl_tree);  					send_bits(count - 3' 2);  				}  				else if (count <= 10)  				{  					send_code(REPZ_3_10' bl_tree);  					send_bits(count - 3' 3);  				}  				else  				{  					send_code(REPZ_11_138' bl_tree);  					send_bits(count - 11' 7);  				}  				count = 0; prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138; min_count = 3;  				}  				else if (curlen == nextlen)  				{  					max_count = 6; min_count = 3;  				}  				else  				{  					max_count = 7; min_count = 4;  				}  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  				else if (count < min_count)  				{  					do   					{  						send_code(curlen' bl_tree);  					}  					while (--count != 0);  				}  				else if (curlen != 0)  				{  					if (curlen != prevlen)  					{  						send_code(curlen' bl_tree); count--;  					}  					send_code(REP_3_6' bl_tree);  					send_bits(count - 3' 2);  				}  				else if (count <= 10)  				{  					send_code(REPZ_3_10' bl_tree);  					send_bits(count - 3' 3);  				}  				else  				{  					send_code(REPZ_11_138' bl_tree);  					send_bits(count - 11' 7);  				}  				count = 0; prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138; min_count = 3;  				}  				else if (curlen == nextlen)  				{  					max_count = 6; min_count = 3;  				}  				else  				{  					max_count = 7; min_count = 4;  				}  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  				else if (count < min_count)  				{  					do   					{  						send_code(curlen' bl_tree);  					}  					while (--count != 0);  				}  				else if (curlen != 0)  				{  					if (curlen != prevlen)  					{  						send_code(curlen' bl_tree); count--;  					}  					send_code(REP_3_6' bl_tree);  					send_bits(count - 3' 2);  				}  				else if (count <= 10)  				{  					send_code(REPZ_3_10' bl_tree);  					send_bits(count - 3' 3);  				}  				else  				{  					send_code(REPZ_11_138' bl_tree);  					send_bits(count - 11' 7);  				}  				count = 0; prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138; min_count = 3;  				}  				else if (curlen == nextlen)  				{  					max_count = 6; min_count = 3;  				}  				else  				{  					max_count = 7; min_count = 4;  				}  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  				else if (count < min_count)  				{  					do   					{  						send_code(curlen' bl_tree);  					}  					while (--count != 0);  				}  				else if (curlen != 0)  				{  					if (curlen != prevlen)  					{  						send_code(curlen' bl_tree); count--;  					}  					send_code(REP_3_6' bl_tree);  					send_bits(count - 3' 2);  				}  				else if (count <= 10)  				{  					send_code(REPZ_3_10' bl_tree);  					send_bits(count - 3' 3);  				}  				else  				{  					send_code(REPZ_11_138' bl_tree);  					send_bits(count - 11' 7);  				}  				count = 0; prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138; min_count = 3;  				}  				else if (curlen == nextlen)  				{  					max_count = 6; min_count = 3;  				}  				else  				{  					max_count = 7; min_count = 4;  				}  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  				else if (count < min_count)  				{  					do   					{  						send_code(curlen' bl_tree);  					}  					while (--count != 0);  				}  				else if (curlen != 0)  				{  					if (curlen != prevlen)  					{  						send_code(curlen' bl_tree); count--;  					}  					send_code(REP_3_6' bl_tree);  					send_bits(count - 3' 2);  				}  				else if (count <= 10)  				{  					send_code(REPZ_3_10' bl_tree);  					send_bits(count - 3' 3);  				}  				else  				{  					send_code(REPZ_11_138' bl_tree);  					send_bits(count - 11' 7);  				}  				count = 0; prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138; min_count = 3;  				}  				else if (curlen == nextlen)  				{  					max_count = 6; min_count = 3;  				}  				else  				{  					max_count = 7; min_count = 4;  				}  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  				else if (count < min_count)  				{  					do   					{  						send_code(curlen' bl_tree);  					}  					while (--count != 0);  				}  				else if (curlen != 0)  				{  					if (curlen != prevlen)  					{  						send_code(curlen' bl_tree); count--;  					}  					send_code(REP_3_6' bl_tree);  					send_bits(count - 3' 2);  				}  				else if (count <= 10)  				{  					send_code(REPZ_3_10' bl_tree);  					send_bits(count - 3' 3);  				}  				else  				{  					send_code(REPZ_11_138' bl_tree);  					send_bits(count - 11' 7);  				}  				count = 0; prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138; min_count = 3;  				}  				else if (curlen == nextlen)  				{  					max_count = 6; min_count = 3;  				}  				else  				{  					max_count = 7; min_count = 4;  				}  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  				else if (count < min_count)  				{  					do   					{  						send_code(curlen' bl_tree);  					}  					while (--count != 0);  				}  				else if (curlen != 0)  				{  					if (curlen != prevlen)  					{  						send_code(curlen' bl_tree); count--;  					}  					send_code(REP_3_6' bl_tree);  					send_bits(count - 3' 2);  				}  				else if (count <= 10)  				{  					send_code(REPZ_3_10' bl_tree);  					send_bits(count - 3' 3);  				}  				else  				{  					send_code(REPZ_11_138' bl_tree);  					send_bits(count - 11' 7);  				}  				count = 0; prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138; min_count = 3;  				}  				else if (curlen == nextlen)  				{  					max_count = 6; min_count = 3;  				}  				else  				{  					max_count = 7; min_count = 4;  				}  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  				else if (count < min_count)  				{  					do   					{  						send_code(curlen' bl_tree);  					}  					while (--count != 0);  				}  				else if (curlen != 0)  				{  					if (curlen != prevlen)  					{  						send_code(curlen' bl_tree); count--;  					}  					send_code(REP_3_6' bl_tree);  					send_bits(count - 3' 2);  				}  				else if (count <= 10)  				{  					send_code(REPZ_3_10' bl_tree);  					send_bits(count - 3' 3);  				}  				else  				{  					send_code(REPZ_11_138' bl_tree);  					send_bits(count - 11' 7);  				}  				count = 0; prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138; min_count = 3;  				}  				else if (curlen == nextlen)  				{  					max_count = 6; min_count = 3;  				}  				else  				{  					max_count = 7; min_count = 4;  				}  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,put_short,The following statement contains a magic number: put_byte((byte) (SupportClass.URShift(w' 8)));
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,putShortMSB,The following statement contains a magic number: put_byte((byte) (b >> 8));
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,send_code,The following statement contains a magic number: send_bits((tree[c * 2] & 0xffff)' (tree[c * 2 + 1] & 0xffff));
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,send_code,The following statement contains a magic number: send_bits((tree[c * 2] & 0xffff)' (tree[c * 2 + 1] & 0xffff));
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,_tr_align,The following statement contains a magic number: send_bits(STATIC_TREES << 1' 3);
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,_tr_align,The following statement contains a magic number: if (1 + last_eob_len + 10 - bi_valid < 9)  			{  				send_bits(STATIC_TREES << 1' 3);  				send_code(END_BLOCK' StaticTree.static_ltree);  				bi_flush();  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,_tr_align,The following statement contains a magic number: if (1 + last_eob_len + 10 - bi_valid < 9)  			{  				send_bits(STATIC_TREES << 1' 3);  				send_code(END_BLOCK' StaticTree.static_ltree);  				bi_flush();  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,_tr_align,The following statement contains a magic number: if (1 + last_eob_len + 10 - bi_valid < 9)  			{  				send_bits(STATIC_TREES << 1' 3);  				send_code(END_BLOCK' StaticTree.static_ltree);  				bi_flush();  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,_tr_align,The following statement contains a magic number: last_eob_len = 7;
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: pending_buf[d_buf + last_lit * 2] = (byte) (SupportClass.URShift(dist' 8));
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: pending_buf[d_buf + last_lit * 2] = (byte) (SupportClass.URShift(dist' 8));
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: pending_buf[d_buf + last_lit * 2 + 1] = (byte) dist;
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: if (dist == 0)  			{  				// lc is the unmatched char  				dyn_ltree[lc * 2]++;  			}  			else  			{  				matches++;  				// Here' lc is the match length - MIN_MATCH  				dist--; // dist = match distance - 1  				dyn_ltree[(Tree._length_code[lc] + LITERALS + 1) * 2]++;  				dyn_dtree[Tree.d_code(dist) * 2]++;  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: if (dist == 0)  			{  				// lc is the unmatched char  				dyn_ltree[lc * 2]++;  			}  			else  			{  				matches++;  				// Here' lc is the match length - MIN_MATCH  				dist--; // dist = match distance - 1  				dyn_ltree[(Tree._length_code[lc] + LITERALS + 1) * 2]++;  				dyn_dtree[Tree.d_code(dist) * 2]++;  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: if (dist == 0)  			{  				// lc is the unmatched char  				dyn_ltree[lc * 2]++;  			}  			else  			{  				matches++;  				// Here' lc is the match length - MIN_MATCH  				dist--; // dist = match distance - 1  				dyn_ltree[(Tree._length_code[lc] + LITERALS + 1) * 2]++;  				dyn_dtree[Tree.d_code(dist) * 2]++;  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: if ((last_lit & 0x1fff) == 0 && level > 2)  			{  				// Compute an upper bound for the compressed length  				int out_length = last_lit * 8;  				int in_length = strstart - block_start;  				int dcode;  				for (dcode = 0; dcode < D_CODES; dcode++)  				{  					out_length = (int) (out_length + (int) dyn_dtree[dcode * 2] * (5L + Tree.extra_dbits[dcode]));  				}  				out_length = SupportClass.URShift(out_length' 3);  				if ((matches < (last_lit / 2)) && out_length < in_length / 2)  					return true;  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: if ((last_lit & 0x1fff) == 0 && level > 2)  			{  				// Compute an upper bound for the compressed length  				int out_length = last_lit * 8;  				int in_length = strstart - block_start;  				int dcode;  				for (dcode = 0; dcode < D_CODES; dcode++)  				{  					out_length = (int) (out_length + (int) dyn_dtree[dcode * 2] * (5L + Tree.extra_dbits[dcode]));  				}  				out_length = SupportClass.URShift(out_length' 3);  				if ((matches < (last_lit / 2)) && out_length < in_length / 2)  					return true;  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: if ((last_lit & 0x1fff) == 0 && level > 2)  			{  				// Compute an upper bound for the compressed length  				int out_length = last_lit * 8;  				int in_length = strstart - block_start;  				int dcode;  				for (dcode = 0; dcode < D_CODES; dcode++)  				{  					out_length = (int) (out_length + (int) dyn_dtree[dcode * 2] * (5L + Tree.extra_dbits[dcode]));  				}  				out_length = SupportClass.URShift(out_length' 3);  				if ((matches < (last_lit / 2)) && out_length < in_length / 2)  					return true;  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: if ((last_lit & 0x1fff) == 0 && level > 2)  			{  				// Compute an upper bound for the compressed length  				int out_length = last_lit * 8;  				int in_length = strstart - block_start;  				int dcode;  				for (dcode = 0; dcode < D_CODES; dcode++)  				{  					out_length = (int) (out_length + (int) dyn_dtree[dcode * 2] * (5L + Tree.extra_dbits[dcode]));  				}  				out_length = SupportClass.URShift(out_length' 3);  				if ((matches < (last_lit / 2)) && out_length < in_length / 2)  					return true;  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: if ((last_lit & 0x1fff) == 0 && level > 2)  			{  				// Compute an upper bound for the compressed length  				int out_length = last_lit * 8;  				int in_length = strstart - block_start;  				int dcode;  				for (dcode = 0; dcode < D_CODES; dcode++)  				{  					out_length = (int) (out_length + (int) dyn_dtree[dcode * 2] * (5L + Tree.extra_dbits[dcode]));  				}  				out_length = SupportClass.URShift(out_length' 3);  				if ((matches < (last_lit / 2)) && out_length < in_length / 2)  					return true;  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: if ((last_lit & 0x1fff) == 0 && level > 2)  			{  				// Compute an upper bound for the compressed length  				int out_length = last_lit * 8;  				int in_length = strstart - block_start;  				int dcode;  				for (dcode = 0; dcode < D_CODES; dcode++)  				{  					out_length = (int) (out_length + (int) dyn_dtree[dcode * 2] * (5L + Tree.extra_dbits[dcode]));  				}  				out_length = SupportClass.URShift(out_length' 3);  				if ((matches < (last_lit / 2)) && out_length < in_length / 2)  					return true;  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,compress_block,The following statement contains a magic number: if (last_lit != 0)  			{  				do   				{  					dist = ((pending_buf[d_buf + lx * 2] << 8) & 0xff00) | (pending_buf[d_buf + lx * 2 + 1] & 0xff);  					lc = (pending_buf[l_buf + lx]) & 0xff; lx++;  					  					if (dist == 0)  					{  						send_code(lc' ltree); // send a literal byte  					}  					else  					{  						// Here' lc is the match length - MIN_MATCH  						code = Tree._length_code[lc];  						  						send_code(code + LITERALS + 1' ltree); // send the length code  						extra = Tree.extra_lbits[code];  						if (extra != 0)  						{  							lc -= Tree.base_length[code];  							send_bits(lc' extra); // send the extra length bits  						}  						dist--; // dist is now the match distance - 1  						code = Tree.d_code(dist);  						  						send_code(code' dtree); // send the distance code  						extra = Tree.extra_dbits[code];  						if (extra != 0)  						{  							dist -= Tree.base_dist[code];  							send_bits(dist' extra); // send the extra distance bits  						}  					} // literal or match pair ?  					  					// Check that the overlay between pending_buf and d_buf+l_buf is ok:  				}  				while (lx < last_lit);  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,compress_block,The following statement contains a magic number: if (last_lit != 0)  			{  				do   				{  					dist = ((pending_buf[d_buf + lx * 2] << 8) & 0xff00) | (pending_buf[d_buf + lx * 2 + 1] & 0xff);  					lc = (pending_buf[l_buf + lx]) & 0xff; lx++;  					  					if (dist == 0)  					{  						send_code(lc' ltree); // send a literal byte  					}  					else  					{  						// Here' lc is the match length - MIN_MATCH  						code = Tree._length_code[lc];  						  						send_code(code + LITERALS + 1' ltree); // send the length code  						extra = Tree.extra_lbits[code];  						if (extra != 0)  						{  							lc -= Tree.base_length[code];  							send_bits(lc' extra); // send the extra length bits  						}  						dist--; // dist is now the match distance - 1  						code = Tree.d_code(dist);  						  						send_code(code' dtree); // send the distance code  						extra = Tree.extra_dbits[code];  						if (extra != 0)  						{  							dist -= Tree.base_dist[code];  							send_bits(dist' extra); // send the extra distance bits  						}  					} // literal or match pair ?  					  					// Check that the overlay between pending_buf and d_buf+l_buf is ok:  				}  				while (lx < last_lit);  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,compress_block,The following statement contains a magic number: if (last_lit != 0)  			{  				do   				{  					dist = ((pending_buf[d_buf + lx * 2] << 8) & 0xff00) | (pending_buf[d_buf + lx * 2 + 1] & 0xff);  					lc = (pending_buf[l_buf + lx]) & 0xff; lx++;  					  					if (dist == 0)  					{  						send_code(lc' ltree); // send a literal byte  					}  					else  					{  						// Here' lc is the match length - MIN_MATCH  						code = Tree._length_code[lc];  						  						send_code(code + LITERALS + 1' ltree); // send the length code  						extra = Tree.extra_lbits[code];  						if (extra != 0)  						{  							lc -= Tree.base_length[code];  							send_bits(lc' extra); // send the extra length bits  						}  						dist--; // dist is now the match distance - 1  						code = Tree.d_code(dist);  						  						send_code(code' dtree); // send the distance code  						extra = Tree.extra_dbits[code];  						if (extra != 0)  						{  							dist -= Tree.base_dist[code];  							send_bits(dist' extra); // send the extra distance bits  						}  					} // literal or match pair ?  					  					// Check that the overlay between pending_buf and d_buf+l_buf is ok:  				}  				while (lx < last_lit);  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,compress_block,The following statement contains a magic number: last_eob_len = ltree[END_BLOCK * 2 + 1];
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,set_data_type,The following statement contains a magic number: while (n < 7)  			{  				bin_freq += dyn_ltree[n * 2]; n++;  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,set_data_type,The following statement contains a magic number: while (n < 7)  			{  				bin_freq += dyn_ltree[n * 2]; n++;  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,set_data_type,The following statement contains a magic number: while (n < 128)  			{  				ascii_freq += dyn_ltree[n * 2]; n++;  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,set_data_type,The following statement contains a magic number: while (n < 128)  			{  				ascii_freq += dyn_ltree[n * 2]; n++;  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,set_data_type,The following statement contains a magic number: while (n < LITERALS)  			{  				bin_freq += dyn_ltree[n * 2]; n++;  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,set_data_type,The following statement contains a magic number: data_type = (byte) (bin_freq > (SupportClass.URShift(ascii_freq' 2))?Z_BINARY:Z_ASCII);
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,bi_flush,The following statement contains a magic number: if (bi_valid == 16)  			{  				put_short(bi_buf);  				bi_buf = 0;  				bi_valid = 0;  			}  			else if (bi_valid >= 8)  			{  				put_byte((byte) bi_buf);  				bi_buf = (short) (SupportClass.URShift(bi_buf' 8));  				bi_valid -= 8;  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,bi_flush,The following statement contains a magic number: if (bi_valid == 16)  			{  				put_short(bi_buf);  				bi_buf = 0;  				bi_valid = 0;  			}  			else if (bi_valid >= 8)  			{  				put_byte((byte) bi_buf);  				bi_buf = (short) (SupportClass.URShift(bi_buf' 8));  				bi_valid -= 8;  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,bi_flush,The following statement contains a magic number: if (bi_valid == 16)  			{  				put_short(bi_buf);  				bi_buf = 0;  				bi_valid = 0;  			}  			else if (bi_valid >= 8)  			{  				put_byte((byte) bi_buf);  				bi_buf = (short) (SupportClass.URShift(bi_buf' 8));  				bi_valid -= 8;  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,bi_flush,The following statement contains a magic number: if (bi_valid == 16)  			{  				put_short(bi_buf);  				bi_buf = 0;  				bi_valid = 0;  			}  			else if (bi_valid >= 8)  			{  				put_byte((byte) bi_buf);  				bi_buf = (short) (SupportClass.URShift(bi_buf' 8));  				bi_valid -= 8;  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,bi_windup,The following statement contains a magic number: if (bi_valid > 8)  			{  				put_short(bi_buf);  			}  			else if (bi_valid > 0)  			{  				put_byte((byte) bi_buf);  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,copy_block,The following statement contains a magic number: last_eob_len = 8;
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflate_stored,The following statement contains a magic number: if (max_block_size > pending_buf_size - 5)  			{  				max_block_size = pending_buf_size - 5;  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflate_stored,The following statement contains a magic number: if (max_block_size > pending_buf_size - 5)  			{  				max_block_size = pending_buf_size - 5;  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,_tr_stored_block,The following statement contains a magic number: send_bits((STORED_BLOCK << 1) + (eof?1:0)' 3);
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (level > 0)  			{  				// Check if the file is ascii or binary  				if (data_type == Z_UNKNOWN)  					set_data_type();  				  				// Construct the literal and distance trees  				l_desc.build_tree(this);  				  				d_desc.build_tree(this);  				  				// At this point' opt_len and static_len are the total bit lengths of  				// the compressed block data' excluding the tree representations.  				  				// Build the bit length tree for the above two trees' and get the index  				// in bl_order of the last bit length code to send.  				max_blindex = build_bl_tree();  				  				// Determine the best encoding. Compute first the block length in bytes  				opt_lenb = SupportClass.URShift((opt_len + 3 + 7)' 3);  				static_lenb = SupportClass.URShift((static_len + 3 + 7)' 3);  				  				if (static_lenb <= opt_lenb)  					opt_lenb = static_lenb;  			}  			else  			{  				opt_lenb = static_lenb = stored_len + 5; // force a stored block  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (level > 0)  			{  				// Check if the file is ascii or binary  				if (data_type == Z_UNKNOWN)  					set_data_type();  				  				// Construct the literal and distance trees  				l_desc.build_tree(this);  				  				d_desc.build_tree(this);  				  				// At this point' opt_len and static_len are the total bit lengths of  				// the compressed block data' excluding the tree representations.  				  				// Build the bit length tree for the above two trees' and get the index  				// in bl_order of the last bit length code to send.  				max_blindex = build_bl_tree();  				  				// Determine the best encoding. Compute first the block length in bytes  				opt_lenb = SupportClass.URShift((opt_len + 3 + 7)' 3);  				static_lenb = SupportClass.URShift((static_len + 3 + 7)' 3);  				  				if (static_lenb <= opt_lenb)  					opt_lenb = static_lenb;  			}  			else  			{  				opt_lenb = static_lenb = stored_len + 5; // force a stored block  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (level > 0)  			{  				// Check if the file is ascii or binary  				if (data_type == Z_UNKNOWN)  					set_data_type();  				  				// Construct the literal and distance trees  				l_desc.build_tree(this);  				  				d_desc.build_tree(this);  				  				// At this point' opt_len and static_len are the total bit lengths of  				// the compressed block data' excluding the tree representations.  				  				// Build the bit length tree for the above two trees' and get the index  				// in bl_order of the last bit length code to send.  				max_blindex = build_bl_tree();  				  				// Determine the best encoding. Compute first the block length in bytes  				opt_lenb = SupportClass.URShift((opt_len + 3 + 7)' 3);  				static_lenb = SupportClass.URShift((static_len + 3 + 7)' 3);  				  				if (static_lenb <= opt_lenb)  					opt_lenb = static_lenb;  			}  			else  			{  				opt_lenb = static_lenb = stored_len + 5; // force a stored block  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (level > 0)  			{  				// Check if the file is ascii or binary  				if (data_type == Z_UNKNOWN)  					set_data_type();  				  				// Construct the literal and distance trees  				l_desc.build_tree(this);  				  				d_desc.build_tree(this);  				  				// At this point' opt_len and static_len are the total bit lengths of  				// the compressed block data' excluding the tree representations.  				  				// Build the bit length tree for the above two trees' and get the index  				// in bl_order of the last bit length code to send.  				max_blindex = build_bl_tree();  				  				// Determine the best encoding. Compute first the block length in bytes  				opt_lenb = SupportClass.URShift((opt_len + 3 + 7)' 3);  				static_lenb = SupportClass.URShift((static_len + 3 + 7)' 3);  				  				if (static_lenb <= opt_lenb)  					opt_lenb = static_lenb;  			}  			else  			{  				opt_lenb = static_lenb = stored_len + 5; // force a stored block  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (level > 0)  			{  				// Check if the file is ascii or binary  				if (data_type == Z_UNKNOWN)  					set_data_type();  				  				// Construct the literal and distance trees  				l_desc.build_tree(this);  				  				d_desc.build_tree(this);  				  				// At this point' opt_len and static_len are the total bit lengths of  				// the compressed block data' excluding the tree representations.  				  				// Build the bit length tree for the above two trees' and get the index  				// in bl_order of the last bit length code to send.  				max_blindex = build_bl_tree();  				  				// Determine the best encoding. Compute first the block length in bytes  				opt_lenb = SupportClass.URShift((opt_len + 3 + 7)' 3);  				static_lenb = SupportClass.URShift((static_len + 3 + 7)' 3);  				  				if (static_lenb <= opt_lenb)  					opt_lenb = static_lenb;  			}  			else  			{  				opt_lenb = static_lenb = stored_len + 5; // force a stored block  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (level > 0)  			{  				// Check if the file is ascii or binary  				if (data_type == Z_UNKNOWN)  					set_data_type();  				  				// Construct the literal and distance trees  				l_desc.build_tree(this);  				  				d_desc.build_tree(this);  				  				// At this point' opt_len and static_len are the total bit lengths of  				// the compressed block data' excluding the tree representations.  				  				// Build the bit length tree for the above two trees' and get the index  				// in bl_order of the last bit length code to send.  				max_blindex = build_bl_tree();  				  				// Determine the best encoding. Compute first the block length in bytes  				opt_lenb = SupportClass.URShift((opt_len + 3 + 7)' 3);  				static_lenb = SupportClass.URShift((static_len + 3 + 7)' 3);  				  				if (static_lenb <= opt_lenb)  					opt_lenb = static_lenb;  			}  			else  			{  				opt_lenb = static_lenb = stored_len + 5; // force a stored block  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (level > 0)  			{  				// Check if the file is ascii or binary  				if (data_type == Z_UNKNOWN)  					set_data_type();  				  				// Construct the literal and distance trees  				l_desc.build_tree(this);  				  				d_desc.build_tree(this);  				  				// At this point' opt_len and static_len are the total bit lengths of  				// the compressed block data' excluding the tree representations.  				  				// Build the bit length tree for the above two trees' and get the index  				// in bl_order of the last bit length code to send.  				max_blindex = build_bl_tree();  				  				// Determine the best encoding. Compute first the block length in bytes  				opt_lenb = SupportClass.URShift((opt_len + 3 + 7)' 3);  				static_lenb = SupportClass.URShift((static_len + 3 + 7)' 3);  				  				if (static_lenb <= opt_lenb)  					opt_lenb = static_lenb;  			}  			else  			{  				opt_lenb = static_lenb = stored_len + 5; // force a stored block  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (stored_len + 4 <= opt_lenb && buf != - 1)  			{  				// 4: two words for the lengths  				// The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.  				// Otherwise we can't have processed more than WSIZE input bytes since  				// the last block flush' because compression would have been  				// Successsful. If LIT_BUFSIZE <= WSIZE' it is never too late to  				// transform a block into a stored block.  				_tr_stored_block(buf' stored_len' eof);  			}  			else if (static_lenb == opt_lenb)  			{  				send_bits((STATIC_TREES << 1) + (eof?1:0)' 3);  				compress_block(StaticTree.static_ltree' StaticTree.static_dtree);  			}  			else  			{  				send_bits((DYN_TREES << 1) + (eof?1:0)' 3);  				send_all_trees(l_desc.max_code + 1' d_desc.max_code + 1' max_blindex + 1);  				compress_block(dyn_ltree' dyn_dtree);  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (stored_len + 4 <= opt_lenb && buf != - 1)  			{  				// 4: two words for the lengths  				// The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.  				// Otherwise we can't have processed more than WSIZE input bytes since  				// the last block flush' because compression would have been  				// Successsful. If LIT_BUFSIZE <= WSIZE' it is never too late to  				// transform a block into a stored block.  				_tr_stored_block(buf' stored_len' eof);  			}  			else if (static_lenb == opt_lenb)  			{  				send_bits((STATIC_TREES << 1) + (eof?1:0)' 3);  				compress_block(StaticTree.static_ltree' StaticTree.static_dtree);  			}  			else  			{  				send_bits((DYN_TREES << 1) + (eof?1:0)' 3);  				send_all_trees(l_desc.max_code + 1' d_desc.max_code + 1' max_blindex + 1);  				compress_block(dyn_ltree' dyn_dtree);  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (stored_len + 4 <= opt_lenb && buf != - 1)  			{  				// 4: two words for the lengths  				// The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.  				// Otherwise we can't have processed more than WSIZE input bytes since  				// the last block flush' because compression would have been  				// Successsful. If LIT_BUFSIZE <= WSIZE' it is never too late to  				// transform a block into a stored block.  				_tr_stored_block(buf' stored_len' eof);  			}  			else if (static_lenb == opt_lenb)  			{  				send_bits((STATIC_TREES << 1) + (eof?1:0)' 3);  				compress_block(StaticTree.static_ltree' StaticTree.static_dtree);  			}  			else  			{  				send_bits((DYN_TREES << 1) + (eof?1:0)' 3);  				send_all_trees(l_desc.max_code + 1' d_desc.max_code + 1' max_blindex + 1);  				compress_block(dyn_ltree' dyn_dtree);  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflate_slow,The following statement contains a magic number: while (true)  			{  				// Make sure that we always have enough lookahead' except  				// at the end of the input file. We need MAX_MATCH bytes  				// for the next match' plus MIN_MATCH bytes to insert the  				// string following the next match.  				  				if (lookahead < MIN_LOOKAHEAD)  				{  					fill_window();  					if (lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH)  					{  						return NeedMore;  					}  					if (lookahead == 0)  						break; // flush the current block  				}  				  				// Insert the string window[strstart .. strstart+2] in the  				// dictionary' and set hash_head to the head of the hash chain:  				  				if (lookahead >= MIN_MATCH)  				{  					ins_h = (((ins_h) << hash_shift) ^ (window[(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;  					//	prev[strstart&w_mask]=hash_head=head[ins_h];  					hash_head = (head[ins_h] & 0xffff);  					prev[strstart & w_mask] = head[ins_h];  					head[ins_h] = (short) strstart;  				}  				  				// Find the longest match' discarding those <= prev_length.  				prev_length = match_length; prev_match = match_start;  				match_length = MIN_MATCH - 1;  				  				if (hash_head != 0 && prev_length < max_lazy_match && ((strstart - hash_head) & 0xffff) <= w_size - MIN_LOOKAHEAD)  				{  					// To simplify the code' we prevent matches with the string  					// of window index 0 (in particular we have to avoid a match  					// of the string with itself at the start of the input file).  					  					if (strategy != Z_HUFFMAN_ONLY)  					{  						match_length = longest_match(hash_head);  					}  					// longest_match() sets match_start  					  					if (match_length <= 5 && (strategy == Z_FILTERED || (match_length == MIN_MATCH && strstart - match_start > 4096)))  					{  						  						// If prev_match is also MIN_MATCH' match_start is garbage  						// but we will ignore the current match anyway.  						match_length = MIN_MATCH - 1;  					}  				}  				  				// If there was a match at the previous step and the current  				// match is not better' output the previous match:  				if (prev_length >= MIN_MATCH && match_length <= prev_length)  				{  					int max_insert = strstart + lookahead - MIN_MATCH;  					// Do not insert strings in hash table beyond this.  					  					//          check_match(strstart-1' prev_match' prev_length);  					  					bflush = _tr_tally(strstart - 1 - prev_match' prev_length - MIN_MATCH);  					  					// Insert in hash table all strings up to the end of the match.  					// strstart-1 and strstart are already inserted. If there is not  					// enough lookahead' the last two strings are not inserted in  					// the hash table.  					lookahead -= (prev_length - 1);  					prev_length -= 2;  					do   					{  						if (++strstart <= max_insert)  						{  							ins_h = (((ins_h) << hash_shift) ^ (window[(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;  							//prev[strstart&w_mask]=hash_head=head[ins_h];  							hash_head = (head[ins_h] & 0xffff);  							prev[strstart & w_mask] = head[ins_h];  							head[ins_h] = (short) strstart;  						}  					}  					while (--prev_length != 0);  					match_available = 0;  					match_length = MIN_MATCH - 1;  					strstart++;  					  					if (bflush)  					{  						flush_block_only(false);  						if (strm.avail_out == 0)  							return NeedMore;  					}  				}  				else if (match_available != 0)  				{  					  					// If there was no match at the previous position' output a  					// single literal. If there was a match but the current match  					// is longer' truncate the previous match to a single literal.  					  					bflush = _tr_tally(0' window[strstart - 1] & 0xff);  					  					if (bflush)  					{  						flush_block_only(false);  					}  					strstart++;  					lookahead--;  					if (strm.avail_out == 0)  						return NeedMore;  				}  				else  				{  					// There is no previous match to compare with' wait for  					// the next step to decide.  					  					match_available = 1;  					strstart++;  					lookahead--;  				}  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflate_slow,The following statement contains a magic number: while (true)  			{  				// Make sure that we always have enough lookahead' except  				// at the end of the input file. We need MAX_MATCH bytes  				// for the next match' plus MIN_MATCH bytes to insert the  				// string following the next match.  				  				if (lookahead < MIN_LOOKAHEAD)  				{  					fill_window();  					if (lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH)  					{  						return NeedMore;  					}  					if (lookahead == 0)  						break; // flush the current block  				}  				  				// Insert the string window[strstart .. strstart+2] in the  				// dictionary' and set hash_head to the head of the hash chain:  				  				if (lookahead >= MIN_MATCH)  				{  					ins_h = (((ins_h) << hash_shift) ^ (window[(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;  					//	prev[strstart&w_mask]=hash_head=head[ins_h];  					hash_head = (head[ins_h] & 0xffff);  					prev[strstart & w_mask] = head[ins_h];  					head[ins_h] = (short) strstart;  				}  				  				// Find the longest match' discarding those <= prev_length.  				prev_length = match_length; prev_match = match_start;  				match_length = MIN_MATCH - 1;  				  				if (hash_head != 0 && prev_length < max_lazy_match && ((strstart - hash_head) & 0xffff) <= w_size - MIN_LOOKAHEAD)  				{  					// To simplify the code' we prevent matches with the string  					// of window index 0 (in particular we have to avoid a match  					// of the string with itself at the start of the input file).  					  					if (strategy != Z_HUFFMAN_ONLY)  					{  						match_length = longest_match(hash_head);  					}  					// longest_match() sets match_start  					  					if (match_length <= 5 && (strategy == Z_FILTERED || (match_length == MIN_MATCH && strstart - match_start > 4096)))  					{  						  						// If prev_match is also MIN_MATCH' match_start is garbage  						// but we will ignore the current match anyway.  						match_length = MIN_MATCH - 1;  					}  				}  				  				// If there was a match at the previous step and the current  				// match is not better' output the previous match:  				if (prev_length >= MIN_MATCH && match_length <= prev_length)  				{  					int max_insert = strstart + lookahead - MIN_MATCH;  					// Do not insert strings in hash table beyond this.  					  					//          check_match(strstart-1' prev_match' prev_length);  					  					bflush = _tr_tally(strstart - 1 - prev_match' prev_length - MIN_MATCH);  					  					// Insert in hash table all strings up to the end of the match.  					// strstart-1 and strstart are already inserted. If there is not  					// enough lookahead' the last two strings are not inserted in  					// the hash table.  					lookahead -= (prev_length - 1);  					prev_length -= 2;  					do   					{  						if (++strstart <= max_insert)  						{  							ins_h = (((ins_h) << hash_shift) ^ (window[(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;  							//prev[strstart&w_mask]=hash_head=head[ins_h];  							hash_head = (head[ins_h] & 0xffff);  							prev[strstart & w_mask] = head[ins_h];  							head[ins_h] = (short) strstart;  						}  					}  					while (--prev_length != 0);  					match_available = 0;  					match_length = MIN_MATCH - 1;  					strstart++;  					  					if (bflush)  					{  						flush_block_only(false);  						if (strm.avail_out == 0)  							return NeedMore;  					}  				}  				else if (match_available != 0)  				{  					  					// If there was no match at the previous position' output a  					// single literal. If there was a match but the current match  					// is longer' truncate the previous match to a single literal.  					  					bflush = _tr_tally(0' window[strstart - 1] & 0xff);  					  					if (bflush)  					{  						flush_block_only(false);  					}  					strstart++;  					lookahead--;  					if (strm.avail_out == 0)  						return NeedMore;  				}  				else  				{  					// There is no previous match to compare with' wait for  					// the next step to decide.  					  					match_available = 1;  					strstart++;  					lookahead--;  				}  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflate_slow,The following statement contains a magic number: while (true)  			{  				// Make sure that we always have enough lookahead' except  				// at the end of the input file. We need MAX_MATCH bytes  				// for the next match' plus MIN_MATCH bytes to insert the  				// string following the next match.  				  				if (lookahead < MIN_LOOKAHEAD)  				{  					fill_window();  					if (lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH)  					{  						return NeedMore;  					}  					if (lookahead == 0)  						break; // flush the current block  				}  				  				// Insert the string window[strstart .. strstart+2] in the  				// dictionary' and set hash_head to the head of the hash chain:  				  				if (lookahead >= MIN_MATCH)  				{  					ins_h = (((ins_h) << hash_shift) ^ (window[(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;  					//	prev[strstart&w_mask]=hash_head=head[ins_h];  					hash_head = (head[ins_h] & 0xffff);  					prev[strstart & w_mask] = head[ins_h];  					head[ins_h] = (short) strstart;  				}  				  				// Find the longest match' discarding those <= prev_length.  				prev_length = match_length; prev_match = match_start;  				match_length = MIN_MATCH - 1;  				  				if (hash_head != 0 && prev_length < max_lazy_match && ((strstart - hash_head) & 0xffff) <= w_size - MIN_LOOKAHEAD)  				{  					// To simplify the code' we prevent matches with the string  					// of window index 0 (in particular we have to avoid a match  					// of the string with itself at the start of the input file).  					  					if (strategy != Z_HUFFMAN_ONLY)  					{  						match_length = longest_match(hash_head);  					}  					// longest_match() sets match_start  					  					if (match_length <= 5 && (strategy == Z_FILTERED || (match_length == MIN_MATCH && strstart - match_start > 4096)))  					{  						  						// If prev_match is also MIN_MATCH' match_start is garbage  						// but we will ignore the current match anyway.  						match_length = MIN_MATCH - 1;  					}  				}  				  				// If there was a match at the previous step and the current  				// match is not better' output the previous match:  				if (prev_length >= MIN_MATCH && match_length <= prev_length)  				{  					int max_insert = strstart + lookahead - MIN_MATCH;  					// Do not insert strings in hash table beyond this.  					  					//          check_match(strstart-1' prev_match' prev_length);  					  					bflush = _tr_tally(strstart - 1 - prev_match' prev_length - MIN_MATCH);  					  					// Insert in hash table all strings up to the end of the match.  					// strstart-1 and strstart are already inserted. If there is not  					// enough lookahead' the last two strings are not inserted in  					// the hash table.  					lookahead -= (prev_length - 1);  					prev_length -= 2;  					do   					{  						if (++strstart <= max_insert)  						{  							ins_h = (((ins_h) << hash_shift) ^ (window[(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;  							//prev[strstart&w_mask]=hash_head=head[ins_h];  							hash_head = (head[ins_h] & 0xffff);  							prev[strstart & w_mask] = head[ins_h];  							head[ins_h] = (short) strstart;  						}  					}  					while (--prev_length != 0);  					match_available = 0;  					match_length = MIN_MATCH - 1;  					strstart++;  					  					if (bflush)  					{  						flush_block_only(false);  						if (strm.avail_out == 0)  							return NeedMore;  					}  				}  				else if (match_available != 0)  				{  					  					// If there was no match at the previous position' output a  					// single literal. If there was a match but the current match  					// is longer' truncate the previous match to a single literal.  					  					bflush = _tr_tally(0' window[strstart - 1] & 0xff);  					  					if (bflush)  					{  						flush_block_only(false);  					}  					strstart++;  					lookahead--;  					if (strm.avail_out == 0)  						return NeedMore;  				}  				else  				{  					// There is no previous match to compare with' wait for  					// the next step to decide.  					  					match_available = 1;  					strstart++;  					lookahead--;  				}  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,longest_match,The following statement contains a magic number: if (prev_length >= good_match)  			{  				chain_length >>= 2;  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,longest_match,The following statement contains a magic number: do   			{  				match = cur_match;  				  				// Skip to next match if the match length cannot increase  				// or if the match length is less than 2:  				if (window[match + best_len] != scan_end || window[match + best_len - 1] != scan_end1 || window[match] != window[scan] || window[++match] != window[scan + 1])  					continue;  				  				// The check at best_len-1 can be removed because it will be made  				// again later. (This heuristic is not always a win.)  				// It is not necessary to compare scan[2] and match[2] since they  				// are always equal when the other bytes match' given that  				// the hash keys are equal and that HASH_BITS >= 8.  				scan += 2; match++;  				  				// We check for insufficient lookahead only every 8th comparison;  				// the 256th check will be made at strstart+258.  				do   				{  				}  				while (window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match] && scan < strend);  				  				len = MAX_MATCH - (int) (strend - scan);  				scan = strend - MAX_MATCH;  				  				if (len > best_len)  				{  					match_start = cur_match;  					best_len = len;  					if (len >= nice_match)  						break;  					scan_end1 = window[scan + best_len - 1];  					scan_end = window[scan + best_len];  				}  			}  			while ((cur_match = (prev[cur_match & wmask] & 0xffff)) > limit && --chain_length != 0);
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflateInit2,The following statement contains a magic number: if (level == Z_DEFAULT_COMPRESSION)  				level = 6;
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflateInit2,The following statement contains a magic number: if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED || windowBits < 9 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_HUFFMAN_ONLY)  			{  				return Z_STREAM_ERROR;  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflateInit2,The following statement contains a magic number: if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED || windowBits < 9 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_HUFFMAN_ONLY)  			{  				return Z_STREAM_ERROR;  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflateInit2,The following statement contains a magic number: if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED || windowBits < 9 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_HUFFMAN_ONLY)  			{  				return Z_STREAM_ERROR;  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflateInit2,The following statement contains a magic number: hash_bits = memLevel + 7;
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflateInit2,The following statement contains a magic number: window = new byte[w_size * 2];
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflateInit2,The following statement contains a magic number: lit_bufsize = 1 << (memLevel + 6);
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflateInit2,The following statement contains a magic number: pending_buf = new byte[lit_bufsize * 4];
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflateInit2,The following statement contains a magic number: pending_buf_size = lit_bufsize * 4;
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflateInit2,The following statement contains a magic number: l_buf = (1 + 2) * lit_bufsize;
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflateParams,The following statement contains a magic number: if (_level == Z_DEFAULT_COMPRESSION)  			{  				_level = 6;  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflateParams,The following statement contains a magic number: if (_level < 0 || _level > 9 || _strategy < 0 || _strategy > Z_HUFFMAN_ONLY)  			{  				return Z_STREAM_ERROR;  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflate,The following statement contains a magic number: if (status == INIT_STATE)  			{  				int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;  				int level_flags = ((level - 1) & 0xff) >> 1;  				  				if (level_flags > 3)  					level_flags = 3;  				header |= (level_flags << 6);  				if (strstart != 0)  					header |= PRESET_DICT;  				header += 31 - (header % 31);  				  				status = BUSY_STATE;  				putShortMSB(header);  				  				  				// Save the adler32 of the preset dictionary:  				if (strstart != 0)  				{  					putShortMSB((int) (SupportClass.URShift(strm.adler' 16)));  					putShortMSB((int) (strm.adler & 0xffff));  				}  				strm.adler = strm._adler.adler32(0' null' 0' 0);  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflate,The following statement contains a magic number: if (status == INIT_STATE)  			{  				int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;  				int level_flags = ((level - 1) & 0xff) >> 1;  				  				if (level_flags > 3)  					level_flags = 3;  				header |= (level_flags << 6);  				if (strstart != 0)  					header |= PRESET_DICT;  				header += 31 - (header % 31);  				  				status = BUSY_STATE;  				putShortMSB(header);  				  				  				// Save the adler32 of the preset dictionary:  				if (strstart != 0)  				{  					putShortMSB((int) (SupportClass.URShift(strm.adler' 16)));  					putShortMSB((int) (strm.adler & 0xffff));  				}  				strm.adler = strm._adler.adler32(0' null' 0' 0);  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflate,The following statement contains a magic number: if (status == INIT_STATE)  			{  				int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;  				int level_flags = ((level - 1) & 0xff) >> 1;  				  				if (level_flags > 3)  					level_flags = 3;  				header |= (level_flags << 6);  				if (strstart != 0)  					header |= PRESET_DICT;  				header += 31 - (header % 31);  				  				status = BUSY_STATE;  				putShortMSB(header);  				  				  				// Save the adler32 of the preset dictionary:  				if (strstart != 0)  				{  					putShortMSB((int) (SupportClass.URShift(strm.adler' 16)));  					putShortMSB((int) (strm.adler & 0xffff));  				}  				strm.adler = strm._adler.adler32(0' null' 0' 0);  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflate,The following statement contains a magic number: if (status == INIT_STATE)  			{  				int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;  				int level_flags = ((level - 1) & 0xff) >> 1;  				  				if (level_flags > 3)  					level_flags = 3;  				header |= (level_flags << 6);  				if (strstart != 0)  					header |= PRESET_DICT;  				header += 31 - (header % 31);  				  				status = BUSY_STATE;  				putShortMSB(header);  				  				  				// Save the adler32 of the preset dictionary:  				if (strstart != 0)  				{  					putShortMSB((int) (SupportClass.URShift(strm.adler' 16)));  					putShortMSB((int) (strm.adler & 0xffff));  				}  				strm.adler = strm._adler.adler32(0' null' 0' 0);  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflate,The following statement contains a magic number: if (status == INIT_STATE)  			{  				int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;  				int level_flags = ((level - 1) & 0xff) >> 1;  				  				if (level_flags > 3)  					level_flags = 3;  				header |= (level_flags << 6);  				if (strstart != 0)  					header |= PRESET_DICT;  				header += 31 - (header % 31);  				  				status = BUSY_STATE;  				putShortMSB(header);  				  				  				// Save the adler32 of the preset dictionary:  				if (strstart != 0)  				{  					putShortMSB((int) (SupportClass.URShift(strm.adler' 16)));  					putShortMSB((int) (strm.adler & 0xffff));  				}  				strm.adler = strm._adler.adler32(0' null' 0' 0);  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflate,The following statement contains a magic number: if (status == INIT_STATE)  			{  				int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;  				int level_flags = ((level - 1) & 0xff) >> 1;  				  				if (level_flags > 3)  					level_flags = 3;  				header |= (level_flags << 6);  				if (strstart != 0)  					header |= PRESET_DICT;  				header += 31 - (header % 31);  				  				status = BUSY_STATE;  				putShortMSB(header);  				  				  				// Save the adler32 of the preset dictionary:  				if (strstart != 0)  				{  					putShortMSB((int) (SupportClass.URShift(strm.adler' 16)));  					putShortMSB((int) (strm.adler & 0xffff));  				}  				strm.adler = strm._adler.adler32(0' null' 0' 0);  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflate,The following statement contains a magic number: if (status == INIT_STATE)  			{  				int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;  				int level_flags = ((level - 1) & 0xff) >> 1;  				  				if (level_flags > 3)  					level_flags = 3;  				header |= (level_flags << 6);  				if (strstart != 0)  					header |= PRESET_DICT;  				header += 31 - (header % 31);  				  				status = BUSY_STATE;  				putShortMSB(header);  				  				  				// Save the adler32 of the preset dictionary:  				if (strstart != 0)  				{  					putShortMSB((int) (SupportClass.URShift(strm.adler' 16)));  					putShortMSB((int) (strm.adler & 0xffff));  				}  				strm.adler = strm._adler.adler32(0' null' 0' 0);  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflate,The following statement contains a magic number: if (status == INIT_STATE)  			{  				int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;  				int level_flags = ((level - 1) & 0xff) >> 1;  				  				if (level_flags > 3)  					level_flags = 3;  				header |= (level_flags << 6);  				if (strstart != 0)  					header |= PRESET_DICT;  				header += 31 - (header % 31);  				  				status = BUSY_STATE;  				putShortMSB(header);  				  				  				// Save the adler32 of the preset dictionary:  				if (strstart != 0)  				{  					putShortMSB((int) (SupportClass.URShift(strm.adler' 16)));  					putShortMSB((int) (strm.adler & 0xffff));  				}  				strm.adler = strm._adler.adler32(0' null' 0' 0);  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflate,The following statement contains a magic number: if (status == INIT_STATE)  			{  				int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;  				int level_flags = ((level - 1) & 0xff) >> 1;  				  				if (level_flags > 3)  					level_flags = 3;  				header |= (level_flags << 6);  				if (strstart != 0)  					header |= PRESET_DICT;  				header += 31 - (header % 31);  				  				status = BUSY_STATE;  				putShortMSB(header);  				  				  				// Save the adler32 of the preset dictionary:  				if (strstart != 0)  				{  					putShortMSB((int) (SupportClass.URShift(strm.adler' 16)));  					putShortMSB((int) (strm.adler & 0xffff));  				}  				strm.adler = strm._adler.adler32(0' null' 0' 0);  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflate,The following statement contains a magic number: putShortMSB((int) (SupportClass.URShift(strm.adler' 16)));
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,FrameWork,Deflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,FrameWork,InfBlocks,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,InfBlocks,The following statement contains a magic number: hufts = new int[MANY * 3];
Magic Number,FrameWork,InfBlocks,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfBlocks,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfBlocks,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfBlocks,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfBlocks,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfBlocks,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfBlocks,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfBlocks,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfBlocks,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfBlocks,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfBlocks,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfBlocks,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfBlocks,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfBlocks,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfBlocks,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfBlocks,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfBlocks,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfBlocks,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfBlocks,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfBlocks,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfBlocks,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfBlocks,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfBlocks,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfBlocks,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfBlocks,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfBlocks,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfBlocks,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfBlocks,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfBlocks,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfBlocks,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfBlocks,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfBlocks,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfBlocks,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfBlocks,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfBlocks,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfBlocks,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfBlocks,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfBlocks,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfBlocks,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfBlocks,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfBlocks,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfBlocks,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfBlocks,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfBlocks,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfBlocks,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfBlocks,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfBlocks,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfBlocks,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfBlocks,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfBlocks,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfBlocks,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfBlocks,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfBlocks,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfBlocks,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfBlocks,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfBlocks,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfBlocks,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' (tree[tindex + 1]));  						k -= (tree[tindex + 1]);  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = (tree[tindex]);  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' (tree[tindex + 1]));  						k -= (tree[tindex + 1]);  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = (tree[tindex]);  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' (tree[tindex + 1]));  						k -= (tree[tindex + 1]);  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = (tree[tindex]);  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' (tree[tindex + 1]));  						k -= (tree[tindex + 1]);  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = (tree[tindex]);  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' (tree[tindex + 1]));  						k -= (tree[tindex + 1]);  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = (tree[tindex]);  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' (tree[tindex + 1]));  						k -= (tree[tindex + 1]);  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = (tree[tindex]);  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' (tree[tindex + 1]));  						k -= (tree[tindex + 1]);  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = (tree[tindex]);  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' (tree[tindex + 1]));  						k -= (tree[tindex + 1]);  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = (tree[tindex]);  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' (tree[tindex + 1]));  						k -= (tree[tindex + 1]);  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = (tree[tindex]);  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' (tree[tindex + 1]));  						k -= (tree[tindex + 1]);  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = (tree[tindex]);  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' (tree[tindex + 1]));  						k -= (tree[tindex + 1]);  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = (tree[tindex]);  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' (tree[tindex + 1]));  						k -= (tree[tindex + 1]);  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = (tree[tindex]);  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' (tree[tindex + 1]));  						k -= (tree[tindex + 1]);  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = (tree[tindex]);  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' (tree[tindex + 1]));  						k -= (tree[tindex + 1]);  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = (tree[tindex]);  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' (tree[tindex + 1]));  						k -= (tree[tindex + 1]);  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = (tree[tindex]);  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' (tree[tindex + 1]));  						k -= (tree[tindex + 1]);  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = (tree[tindex]);  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' (tree[tindex + 1]));  						k -= (tree[tindex + 1]);  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = (tree[tindex]);  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' (tree[tindex + 1]));  						k -= (tree[tindex + 1]);  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = (tree[tindex]);  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' (tree[tindex + 1]));  						k -= (tree[tindex + 1]);  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = (tree[tindex]);  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' (tree[tindex + 1]));  						k -= (tree[tindex + 1]);  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = (tree[tindex]);  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' (tree[tindex + 1]));  						k -= (tree[tindex + 1]);  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = (tree[tindex]);  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' (tree[tindex + 1]));  						k -= (tree[tindex + 1]);  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = (tree[tindex]);  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' (tree[tindex + 1]));  						k -= (tree[tindex + 1]);  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = (tree[tindex]);  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' (tree[tindex + 1]));  						k -= (tree[tindex + 1]);  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = (tree[tindex]);  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}  			}
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + ((int) b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= (e); k -= (e);  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  							else if ((e & 64) == 0)  							{  								t += tp[(tp_index + t) * 3 + 2];  								t += (b & inflate_mask[e]);  								e = tp[(tp_index + t) * 3];  							}  							else  							{  								z.msg = "invalid distance code";  								  								c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								  								return Z_DATA_ERROR;  							}  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += (b & inflate_mask[e]);  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + ((int) b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= (e); k -= (e);  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  							else if ((e & 64) == 0)  							{  								t += tp[(tp_index + t) * 3 + 2];  								t += (b & inflate_mask[e]);  								e = tp[(tp_index + t) * 3];  							}  							else  							{  								z.msg = "invalid distance code";  								  								c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								  								return Z_DATA_ERROR;  							}  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += (b & inflate_mask[e]);  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + ((int) b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= (e); k -= (e);  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  							else if ((e & 64) == 0)  							{  								t += tp[(tp_index + t) * 3 + 2];  								t += (b & inflate_mask[e]);  								e = tp[(tp_index + t) * 3];  							}  							else  							{  								z.msg = "invalid distance code";  								  								c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								  								return Z_DATA_ERROR;  							}  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += (b & inflate_mask[e]);  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + ((int) b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= (e); k -= (e);  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  							else if ((e & 64) == 0)  							{  								t += tp[(tp_index + t) * 3 + 2];  								t += (b & inflate_mask[e]);  								e = tp[(tp_index + t) * 3];  							}  							else  							{  								z.msg = "invalid distance code";  								  								c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								  								return Z_DATA_ERROR;  							}  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += (b & inflate_mask[e]);  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + ((int) b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= (e); k -= (e);  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  							else if ((e & 64) == 0)  							{  								t += tp[(tp_index + t) * 3 + 2];  								t += (b & inflate_mask[e]);  								e = tp[(tp_index + t) * 3];  							}  							else  							{  								z.msg = "invalid distance code";  								  								c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								  								return Z_DATA_ERROR;  							}  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += (b & inflate_mask[e]);  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + ((int) b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= (e); k -= (e);  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  							else if ((e & 64) == 0)  							{  								t += tp[(tp_index + t) * 3 + 2];  								t += (b & inflate_mask[e]);  								e = tp[(tp_index + t) * 3];  							}  							else  							{  								z.msg = "invalid distance code";  								  								c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								  								return Z_DATA_ERROR;  							}  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += (b & inflate_mask[e]);  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + ((int) b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= (e); k -= (e);  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  							else if ((e & 64) == 0)  							{  								t += tp[(tp_index + t) * 3 + 2];  								t += (b & inflate_mask[e]);  								e = tp[(tp_index + t) * 3];  							}  							else  							{  								z.msg = "invalid distance code";  								  								c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								  								return Z_DATA_ERROR;  							}  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += (b & inflate_mask[e]);  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + ((int) b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= (e); k -= (e);  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  							else if ((e & 64) == 0)  							{  								t += tp[(tp_index + t) * 3 + 2];  								t += (b & inflate_mask[e]);  								e = tp[(tp_index + t) * 3];  							}  							else  							{  								z.msg = "invalid distance code";  								  								c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								  								return Z_DATA_ERROR;  							}  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += (b & inflate_mask[e]);  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + ((int) b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= (e); k -= (e);  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  							else if ((e & 64) == 0)  							{  								t += tp[(tp_index + t) * 3 + 2];  								t += (b & inflate_mask[e]);  								e = tp[(tp_index + t) * 3];  							}  							else  							{  								z.msg = "invalid distance code";  								  								c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								  								return Z_DATA_ERROR;  							}  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += (b & inflate_mask[e]);  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + ((int) b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= (e); k -= (e);  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  							else if ((e & 64) == 0)  							{  								t += tp[(tp_index + t) * 3 + 2];  								t += (b & inflate_mask[e]);  								e = tp[(tp_index + t) * 3];  							}  							else  							{  								z.msg = "invalid distance code";  								  								c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								  								return Z_DATA_ERROR;  							}  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += (b & inflate_mask[e]);  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + ((int) b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= (e); k -= (e);  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  							else if ((e & 64) == 0)  							{  								t += tp[(tp_index + t) * 3 + 2];  								t += (b & inflate_mask[e]);  								e = tp[(tp_index + t) * 3];  							}  							else  							{  								z.msg = "invalid distance code";  								  								c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								  								return Z_DATA_ERROR;  							}  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += (b & inflate_mask[e]);  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + ((int) b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= (e); k -= (e);  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  							else if ((e & 64) == 0)  							{  								t += tp[(tp_index + t) * 3 + 2];  								t += (b & inflate_mask[e]);  								e = tp[(tp_index + t) * 3];  							}  							else  							{  								z.msg = "invalid distance code";  								  								c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								  								return Z_DATA_ERROR;  							}  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += (b & inflate_mask[e]);  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + ((int) b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= (e); k -= (e);  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  							else if ((e & 64) == 0)  							{  								t += tp[(tp_index + t) * 3 + 2];  								t += (b & inflate_mask[e]);  								e = tp[(tp_index + t) * 3];  							}  							else  							{  								z.msg = "invalid distance code";  								  								c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								  								return Z_DATA_ERROR;  							}  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += (b & inflate_mask[e]);  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + ((int) b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= (e); k -= (e);  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  							else if ((e & 64) == 0)  							{  								t += tp[(tp_index + t) * 3 + 2];  								t += (b & inflate_mask[e]);  								e = tp[(tp_index + t) * 3];  							}  							else  							{  								z.msg = "invalid distance code";  								  								c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								  								return Z_DATA_ERROR;  							}  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += (b & inflate_mask[e]);  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + ((int) b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= (e); k -= (e);  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  							else if ((e & 64) == 0)  							{  								t += tp[(tp_index + t) * 3 + 2];  								t += (b & inflate_mask[e]);  								e = tp[(tp_index + t) * 3];  							}  							else  							{  								z.msg = "invalid distance code";  								  								c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								  								return Z_DATA_ERROR;  							}  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += (b & inflate_mask[e]);  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + ((int) b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= (e); k -= (e);  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  							else if ((e & 64) == 0)  							{  								t += tp[(tp_index + t) * 3 + 2];  								t += (b & inflate_mask[e]);  								e = tp[(tp_index + t) * 3];  							}  							else  							{  								z.msg = "invalid distance code";  								  								c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								  								return Z_DATA_ERROR;  							}  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += (b & inflate_mask[e]);  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + ((int) b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= (e); k -= (e);  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  							else if ((e & 64) == 0)  							{  								t += tp[(tp_index + t) * 3 + 2];  								t += (b & inflate_mask[e]);  								e = tp[(tp_index + t) * 3];  							}  							else  							{  								z.msg = "invalid distance code";  								  								c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								  								return Z_DATA_ERROR;  							}  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += (b & inflate_mask[e]);  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + ((int) b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= (e); k -= (e);  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  							else if ((e & 64) == 0)  							{  								t += tp[(tp_index + t) * 3 + 2];  								t += (b & inflate_mask[e]);  								e = tp[(tp_index + t) * 3];  							}  							else  							{  								z.msg = "invalid distance code";  								  								c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								  								return Z_DATA_ERROR;  							}  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += (b & inflate_mask[e]);  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + ((int) b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= (e); k -= (e);  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  							else if ((e & 64) == 0)  							{  								t += tp[(tp_index + t) * 3 + 2];  								t += (b & inflate_mask[e]);  								e = tp[(tp_index + t) * 3];  							}  							else  							{  								z.msg = "invalid distance code";  								  								c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								  								return Z_DATA_ERROR;  							}  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += (b & inflate_mask[e]);  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + ((int) b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= (e); k -= (e);  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  							else if ((e & 64) == 0)  							{  								t += tp[(tp_index + t) * 3 + 2];  								t += (b & inflate_mask[e]);  								e = tp[(tp_index + t) * 3];  							}  							else  							{  								z.msg = "invalid distance code";  								  								c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								  								return Z_DATA_ERROR;  							}  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += (b & inflate_mask[e]);  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + ((int) b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= (e); k -= (e);  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  							else if ((e & 64) == 0)  							{  								t += tp[(tp_index + t) * 3 + 2];  								t += (b & inflate_mask[e]);  								e = tp[(tp_index + t) * 3];  							}  							else  							{  								z.msg = "invalid distance code";  								  								c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								  								return Z_DATA_ERROR;  							}  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += (b & inflate_mask[e]);  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + ((int) b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= (e); k -= (e);  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  							else if ((e & 64) == 0)  							{  								t += tp[(tp_index + t) * 3 + 2];  								t += (b & inflate_mask[e]);  								e = tp[(tp_index + t) * 3];  							}  							else  							{  								z.msg = "invalid distance code";  								  								c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								  								return Z_DATA_ERROR;  							}  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += (b & inflate_mask[e]);  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + ((int) b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= (e); k -= (e);  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  							else if ((e & 64) == 0)  							{  								t += tp[(tp_index + t) * 3 + 2];  								t += (b & inflate_mask[e]);  								e = tp[(tp_index + t) * 3];  							}  							else  							{  								z.msg = "invalid distance code";  								  								c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								  								return Z_DATA_ERROR;  							}  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += (b & inflate_mask[e]);  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + ((int) b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= (e); k -= (e);  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  							else if ((e & 64) == 0)  							{  								t += tp[(tp_index + t) * 3 + 2];  								t += (b & inflate_mask[e]);  								e = tp[(tp_index + t) * 3];  							}  							else  							{  								z.msg = "invalid distance code";  								  								c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								  								return Z_DATA_ERROR;  							}  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += (b & inflate_mask[e]);  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + ((int) b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= (e); k -= (e);  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  							else if ((e & 64) == 0)  							{  								t += tp[(tp_index + t) * 3 + 2];  								t += (b & inflate_mask[e]);  								e = tp[(tp_index + t) * 3];  							}  							else  							{  								z.msg = "invalid distance code";  								  								c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								  								return Z_DATA_ERROR;  							}  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += (b & inflate_mask[e]);  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + ((int) b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= (e); k -= (e);  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  							else if ((e & 64) == 0)  							{  								t += tp[(tp_index + t) * 3 + 2];  								t += (b & inflate_mask[e]);  								e = tp[(tp_index + t) * 3];  							}  							else  							{  								z.msg = "invalid distance code";  								  								c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								  								return Z_DATA_ERROR;  							}  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += (b & inflate_mask[e]);  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + ((int) b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= (e); k -= (e);  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  							else if ((e & 64) == 0)  							{  								t += tp[(tp_index + t) * 3 + 2];  								t += (b & inflate_mask[e]);  								e = tp[(tp_index + t) * 3];  							}  							else  							{  								z.msg = "invalid distance code";  								  								c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								  								return Z_DATA_ERROR;  							}  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += (b & inflate_mask[e]);  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + ((int) b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= (e); k -= (e);  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  							else if ((e & 64) == 0)  							{  								t += tp[(tp_index + t) * 3 + 2];  								t += (b & inflate_mask[e]);  								e = tp[(tp_index + t) * 3];  							}  							else  							{  								z.msg = "invalid distance code";  								  								c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								  								return Z_DATA_ERROR;  							}  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += (b & inflate_mask[e]);  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + ((int) b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= (e); k -= (e);  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  							else if ((e & 64) == 0)  							{  								t += tp[(tp_index + t) * 3 + 2];  								t += (b & inflate_mask[e]);  								e = tp[(tp_index + t) * 3];  							}  							else  							{  								z.msg = "invalid distance code";  								  								c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								  								return Z_DATA_ERROR;  							}  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += (b & inflate_mask[e]);  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + ((int) b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= (e); k -= (e);  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  							else if ((e & 64) == 0)  							{  								t += tp[(tp_index + t) * 3 + 2];  								t += (b & inflate_mask[e]);  								e = tp[(tp_index + t) * 3];  							}  							else  							{  								z.msg = "invalid distance code";  								  								c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								  								return Z_DATA_ERROR;  							}  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += (b & inflate_mask[e]);  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + ((int) b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= (e); k -= (e);  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  							else if ((e & 64) == 0)  							{  								t += tp[(tp_index + t) * 3 + 2];  								t += (b & inflate_mask[e]);  								e = tp[(tp_index + t) * 3];  							}  							else  							{  								z.msg = "invalid distance code";  								  								c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								  								return Z_DATA_ERROR;  							}  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += (b & inflate_mask[e]);  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + ((int) b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= (e); k -= (e);  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  							else if ((e & 64) == 0)  							{  								t += tp[(tp_index + t) * 3 + 2];  								t += (b & inflate_mask[e]);  								e = tp[(tp_index + t) * 3];  							}  							else  							{  								z.msg = "invalid distance code";  								  								c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								  								return Z_DATA_ERROR;  							}  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += (b & inflate_mask[e]);  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + ((int) b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= (e); k -= (e);  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  							else if ((e & 64) == 0)  							{  								t += tp[(tp_index + t) * 3 + 2];  								t += (b & inflate_mask[e]);  								e = tp[(tp_index + t) * 3];  							}  							else  							{  								z.msg = "invalid distance code";  								  								c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								  								return Z_DATA_ERROR;  							}  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += (b & inflate_mask[e]);  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + ((int) b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= (e); k -= (e);  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  							else if ((e & 64) == 0)  							{  								t += tp[(tp_index + t) * 3 + 2];  								t += (b & inflate_mask[e]);  								e = tp[(tp_index + t) * 3];  							}  							else  							{  								z.msg = "invalid distance code";  								  								c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								  								return Z_DATA_ERROR;  							}  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += (b & inflate_mask[e]);  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + ((int) b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= (e); k -= (e);  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  							else if ((e & 64) == 0)  							{  								t += tp[(tp_index + t) * 3 + 2];  								t += (b & inflate_mask[e]);  								e = tp[(tp_index + t) * 3];  							}  							else  							{  								z.msg = "invalid distance code";  								  								c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								  								return Z_DATA_ERROR;  							}  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += (b & inflate_mask[e]);  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + ((int) b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= (e); k -= (e);  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  							else if ((e & 64) == 0)  							{  								t += tp[(tp_index + t) * 3 + 2];  								t += (b & inflate_mask[e]);  								e = tp[(tp_index + t) * 3];  							}  							else  							{  								z.msg = "invalid distance code";  								  								c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								  								return Z_DATA_ERROR;  							}  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += (b & inflate_mask[e]);  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + ((int) b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= (e); k -= (e);  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  							else if ((e & 64) == 0)  							{  								t += tp[(tp_index + t) * 3 + 2];  								t += (b & inflate_mask[e]);  								e = tp[(tp_index + t) * 3];  							}  							else  							{  								z.msg = "invalid distance code";  								  								c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								  								return Z_DATA_ERROR;  							}  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += (b & inflate_mask[e]);  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + ((int) b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= (e); k -= (e);  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  							else if ((e & 64) == 0)  							{  								t += tp[(tp_index + t) * 3 + 2];  								t += (b & inflate_mask[e]);  								e = tp[(tp_index + t) * 3];  							}  							else  							{  								z.msg = "invalid distance code";  								  								c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								  								return Z_DATA_ERROR;  							}  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += (b & inflate_mask[e]);  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + ((int) b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= (e); k -= (e);  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  							else if ((e & 64) == 0)  							{  								t += tp[(tp_index + t) * 3 + 2];  								t += (b & inflate_mask[e]);  								e = tp[(tp_index + t) * 3];  							}  							else  							{  								z.msg = "invalid distance code";  								  								c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								  								return Z_DATA_ERROR;  							}  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += (b & inflate_mask[e]);  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + ((int) b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= (e); k -= (e);  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  							else if ((e & 64) == 0)  							{  								t += tp[(tp_index + t) * 3 + 2];  								t += (b & inflate_mask[e]);  								e = tp[(tp_index + t) * 3];  							}  							else  							{  								z.msg = "invalid distance code";  								  								c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								  								return Z_DATA_ERROR;  							}  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += (b & inflate_mask[e]);  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + ((int) b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= (e); k -= (e);  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  							else if ((e & 64) == 0)  							{  								t += tp[(tp_index + t) * 3 + 2];  								t += (b & inflate_mask[e]);  								e = tp[(tp_index + t) * 3];  							}  							else  							{  								z.msg = "invalid distance code";  								  								c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								  								return Z_DATA_ERROR;  							}  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += (b & inflate_mask[e]);  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + ((int) b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= (e); k -= (e);  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  							else if ((e & 64) == 0)  							{  								t += tp[(tp_index + t) * 3 + 2];  								t += (b & inflate_mask[e]);  								e = tp[(tp_index + t) * 3];  							}  							else  							{  								z.msg = "invalid distance code";  								  								c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								  								return Z_DATA_ERROR;  							}  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += (b & inflate_mask[e]);  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + ((int) b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= (e); k -= (e);  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  							else if ((e & 64) == 0)  							{  								t += tp[(tp_index + t) * 3 + 2];  								t += (b & inflate_mask[e]);  								e = tp[(tp_index + t) * 3];  							}  							else  							{  								z.msg = "invalid distance code";  								  								c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								  								return Z_DATA_ERROR;  							}  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += (b & inflate_mask[e]);  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + ((int) b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= (e); k -= (e);  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  							else if ((e & 64) == 0)  							{  								t += tp[(tp_index + t) * 3 + 2];  								t += (b & inflate_mask[e]);  								e = tp[(tp_index + t) * 3];  							}  							else  							{  								z.msg = "invalid distance code";  								  								c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								  								return Z_DATA_ERROR;  							}  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += (b & inflate_mask[e]);  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + ((int) b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= (e); k -= (e);  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  							else if ((e & 64) == 0)  							{  								t += tp[(tp_index + t) * 3 + 2];  								t += (b & inflate_mask[e]);  								e = tp[(tp_index + t) * 3];  							}  							else  							{  								z.msg = "invalid distance code";  								  								c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								  								return Z_DATA_ERROR;  							}  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += (b & inflate_mask[e]);  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + ((int) b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= (e); k -= (e);  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  							else if ((e & 64) == 0)  							{  								t += tp[(tp_index + t) * 3 + 2];  								t += (b & inflate_mask[e]);  								e = tp[(tp_index + t) * 3];  							}  							else  							{  								z.msg = "invalid distance code";  								  								c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								  								return Z_DATA_ERROR;  							}  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += (b & inflate_mask[e]);  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + ((int) b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= (e); k -= (e);  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  							else if ((e & 64) == 0)  							{  								t += tp[(tp_index + t) * 3 + 2];  								t += (b & inflate_mask[e]);  								e = tp[(tp_index + t) * 3];  							}  							else  							{  								z.msg = "invalid distance code";  								  								c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								  								return Z_DATA_ERROR;  							}  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += (b & inflate_mask[e]);  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + ((int) b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= (e); k -= (e);  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  							else if ((e & 64) == 0)  							{  								t += tp[(tp_index + t) * 3 + 2];  								t += (b & inflate_mask[e]);  								e = tp[(tp_index + t) * 3];  							}  							else  							{  								z.msg = "invalid distance code";  								  								c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								  								return Z_DATA_ERROR;  							}  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += (b & inflate_mask[e]);  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + ((int) b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= (e); k -= (e);  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  							else if ((e & 64) == 0)  							{  								t += tp[(tp_index + t) * 3 + 2];  								t += (b & inflate_mask[e]);  								e = tp[(tp_index + t) * 3];  							}  							else  							{  								z.msg = "invalid distance code";  								  								c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								  								return Z_DATA_ERROR;  							}  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += (b & inflate_mask[e]);  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + ((int) b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= (e); k -= (e);  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  							else if ((e & 64) == 0)  							{  								t += tp[(tp_index + t) * 3 + 2];  								t += (b & inflate_mask[e]);  								e = tp[(tp_index + t) * 3];  							}  							else  							{  								z.msg = "invalid distance code";  								  								c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								  								return Z_DATA_ERROR;  							}  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += (b & inflate_mask[e]);  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + ((int) b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= (e); k -= (e);  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  							else if ((e & 64) == 0)  							{  								t += tp[(tp_index + t) * 3 + 2];  								t += (b & inflate_mask[e]);  								e = tp[(tp_index + t) * 3];  							}  							else  							{  								z.msg = "invalid distance code";  								  								c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								  								return Z_DATA_ERROR;  							}  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += (b & inflate_mask[e]);  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < (20))  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + ((int) b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < (15))  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < (e))  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= (e); k -= (e);  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > (q - r))  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > (q - r))  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > (q - r))  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  							else if ((e & 64) == 0)  							{  								t += tp[(tp_index + t) * 3 + 2];  								t += (b & inflate_mask[e]);  								e = tp[(tp_index + t) * 3];  							}  							else  							{  								z.msg = "invalid distance code";  								  								c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								  								return Z_DATA_ERROR;  							}  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += (b & inflate_mask[e]);  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= (tp[(tp_index + t) * 3 + 1]); k -= (tp[(tp_index + t) * 3 + 1]);  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = (k >> 3) < c?k >> 3:c; n += c; p -= c; k -= (c << 3);  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: c = (k >> 3) < c?k >> 3:c;
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: c = (k >> 3) < c?k >> 3:c;
Magic Number,FrameWork,InfCodes,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: k -= (c << 3);
Magic Number,FrameWork,Inflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Inflate.cs,inflateInit,The following statement contains a magic number: if (w < 8 || w > 15)  			{  				inflateEnd(z);  				return Z_STREAM_ERROR;  			}
Magic Number,FrameWork,Inflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Inflate.cs,inflateInit,The following statement contains a magic number: if (w < 8 || w > 15)  			{  				inflateEnd(z);  				return Z_STREAM_ERROR;  			}
Magic Number,FrameWork,Inflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Inflate.cs,inflate,The following statement contains a magic number: while (true)  			{  				//System.out.println("mode: "+z.istate.mode);  				switch (z.istate.mode)  				{  					  					case METHOD:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)  						{  							z.istate.mode = BAD;  							z.msg = "unknown compression method";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						if ((z.istate.method >> 4) + 8 > z.istate.wbits)  						{  							z.istate.mode = BAD;  							z.msg = "invalid window size";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						z.istate.mode = FLAG;  						goto case FLAG;  					  					case FLAG:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						b = (z.next_in[z.next_in_index++]) & 0xff;  						  						if ((((z.istate.method << 8) + b) % 31) != 0)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect header check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						if ((b & PRESET_DICT) == 0)  						{  							z.istate.mode = BLOCKS;  							break;  						}  						z.istate.mode = DICT4;  						goto case DICT4;  					  					case DICT4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = DICT3;  						goto case DICT3;  					  					case DICT3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);  						z.istate.mode = DICT2;  						goto case DICT2;  					  					case DICT2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);  						z.istate.mode = DICT1;  						goto case DICT1;  					  					case DICT1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);  						z.adler = z.istate.need;  						z.istate.mode = DICT0;  						return Z_NEED_DICT;  					  					case DICT0:   						z.istate.mode = BAD;  						z.msg = "need dictionary";  						z.istate.marker = 0; // can try inflateSync  						return Z_STREAM_ERROR;  					  					case BLOCKS:   						  						r = z.istate.blocks.proc(z' r);  						if (r == Z_DATA_ERROR)  						{  							z.istate.mode = BAD;  							z.istate.marker = 0; // can try inflateSync  							break;  						}  						if (r == Z_OK)  						{  							r = f;  						}  						if (r != Z_STREAM_END)  						{  							return r;  						}  						r = f;  						z.istate.blocks.reset(z' z.istate.was);  						if (z.istate.nowrap != 0)  						{  							z.istate.mode = DONE;  							break;  						}  						z.istate.mode = CHECK4;  						goto case CHECK4;  					  					case CHECK4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = CHECK3;  						goto case CHECK3;  					  					case CHECK3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);  						z.istate.mode = CHECK2;  						goto case CHECK2;  					  					case CHECK2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);  						z.istate.mode = CHECK1;  						goto case CHECK1;  					  					case CHECK1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);  						  						if (((int) (z.istate.was[0])) != ((int) (z.istate.need)))  						{  							z.istate.mode = BAD;  							z.msg = "incorrect data check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						z.istate.mode = DONE;  						goto case DONE;  					  					case DONE:   						return Z_STREAM_END;  					  					case BAD:   						return Z_DATA_ERROR;  					  					default:   						return Z_STREAM_ERROR;  					  				}  			}
Magic Number,FrameWork,Inflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Inflate.cs,inflate,The following statement contains a magic number: while (true)  			{  				//System.out.println("mode: "+z.istate.mode);  				switch (z.istate.mode)  				{  					  					case METHOD:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)  						{  							z.istate.mode = BAD;  							z.msg = "unknown compression method";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						if ((z.istate.method >> 4) + 8 > z.istate.wbits)  						{  							z.istate.mode = BAD;  							z.msg = "invalid window size";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						z.istate.mode = FLAG;  						goto case FLAG;  					  					case FLAG:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						b = (z.next_in[z.next_in_index++]) & 0xff;  						  						if ((((z.istate.method << 8) + b) % 31) != 0)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect header check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						if ((b & PRESET_DICT) == 0)  						{  							z.istate.mode = BLOCKS;  							break;  						}  						z.istate.mode = DICT4;  						goto case DICT4;  					  					case DICT4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = DICT3;  						goto case DICT3;  					  					case DICT3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);  						z.istate.mode = DICT2;  						goto case DICT2;  					  					case DICT2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);  						z.istate.mode = DICT1;  						goto case DICT1;  					  					case DICT1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);  						z.adler = z.istate.need;  						z.istate.mode = DICT0;  						return Z_NEED_DICT;  					  					case DICT0:   						z.istate.mode = BAD;  						z.msg = "need dictionary";  						z.istate.marker = 0; // can try inflateSync  						return Z_STREAM_ERROR;  					  					case BLOCKS:   						  						r = z.istate.blocks.proc(z' r);  						if (r == Z_DATA_ERROR)  						{  							z.istate.mode = BAD;  							z.istate.marker = 0; // can try inflateSync  							break;  						}  						if (r == Z_OK)  						{  							r = f;  						}  						if (r != Z_STREAM_END)  						{  							return r;  						}  						r = f;  						z.istate.blocks.reset(z' z.istate.was);  						if (z.istate.nowrap != 0)  						{  							z.istate.mode = DONE;  							break;  						}  						z.istate.mode = CHECK4;  						goto case CHECK4;  					  					case CHECK4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = CHECK3;  						goto case CHECK3;  					  					case CHECK3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);  						z.istate.mode = CHECK2;  						goto case CHECK2;  					  					case CHECK2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);  						z.istate.mode = CHECK1;  						goto case CHECK1;  					  					case CHECK1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);  						  						if (((int) (z.istate.was[0])) != ((int) (z.istate.need)))  						{  							z.istate.mode = BAD;  							z.msg = "incorrect data check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						z.istate.mode = DONE;  						goto case DONE;  					  					case DONE:   						return Z_STREAM_END;  					  					case BAD:   						return Z_DATA_ERROR;  					  					default:   						return Z_STREAM_ERROR;  					  				}  			}
Magic Number,FrameWork,Inflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Inflate.cs,inflate,The following statement contains a magic number: while (true)  			{  				//System.out.println("mode: "+z.istate.mode);  				switch (z.istate.mode)  				{  					  					case METHOD:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)  						{  							z.istate.mode = BAD;  							z.msg = "unknown compression method";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						if ((z.istate.method >> 4) + 8 > z.istate.wbits)  						{  							z.istate.mode = BAD;  							z.msg = "invalid window size";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						z.istate.mode = FLAG;  						goto case FLAG;  					  					case FLAG:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						b = (z.next_in[z.next_in_index++]) & 0xff;  						  						if ((((z.istate.method << 8) + b) % 31) != 0)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect header check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						if ((b & PRESET_DICT) == 0)  						{  							z.istate.mode = BLOCKS;  							break;  						}  						z.istate.mode = DICT4;  						goto case DICT4;  					  					case DICT4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = DICT3;  						goto case DICT3;  					  					case DICT3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);  						z.istate.mode = DICT2;  						goto case DICT2;  					  					case DICT2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);  						z.istate.mode = DICT1;  						goto case DICT1;  					  					case DICT1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);  						z.adler = z.istate.need;  						z.istate.mode = DICT0;  						return Z_NEED_DICT;  					  					case DICT0:   						z.istate.mode = BAD;  						z.msg = "need dictionary";  						z.istate.marker = 0; // can try inflateSync  						return Z_STREAM_ERROR;  					  					case BLOCKS:   						  						r = z.istate.blocks.proc(z' r);  						if (r == Z_DATA_ERROR)  						{  							z.istate.mode = BAD;  							z.istate.marker = 0; // can try inflateSync  							break;  						}  						if (r == Z_OK)  						{  							r = f;  						}  						if (r != Z_STREAM_END)  						{  							return r;  						}  						r = f;  						z.istate.blocks.reset(z' z.istate.was);  						if (z.istate.nowrap != 0)  						{  							z.istate.mode = DONE;  							break;  						}  						z.istate.mode = CHECK4;  						goto case CHECK4;  					  					case CHECK4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = CHECK3;  						goto case CHECK3;  					  					case CHECK3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);  						z.istate.mode = CHECK2;  						goto case CHECK2;  					  					case CHECK2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);  						z.istate.mode = CHECK1;  						goto case CHECK1;  					  					case CHECK1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);  						  						if (((int) (z.istate.was[0])) != ((int) (z.istate.need)))  						{  							z.istate.mode = BAD;  							z.msg = "incorrect data check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						z.istate.mode = DONE;  						goto case DONE;  					  					case DONE:   						return Z_STREAM_END;  					  					case BAD:   						return Z_DATA_ERROR;  					  					default:   						return Z_STREAM_ERROR;  					  				}  			}
Magic Number,FrameWork,Inflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Inflate.cs,inflate,The following statement contains a magic number: while (true)  			{  				//System.out.println("mode: "+z.istate.mode);  				switch (z.istate.mode)  				{  					  					case METHOD:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)  						{  							z.istate.mode = BAD;  							z.msg = "unknown compression method";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						if ((z.istate.method >> 4) + 8 > z.istate.wbits)  						{  							z.istate.mode = BAD;  							z.msg = "invalid window size";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						z.istate.mode = FLAG;  						goto case FLAG;  					  					case FLAG:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						b = (z.next_in[z.next_in_index++]) & 0xff;  						  						if ((((z.istate.method << 8) + b) % 31) != 0)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect header check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						if ((b & PRESET_DICT) == 0)  						{  							z.istate.mode = BLOCKS;  							break;  						}  						z.istate.mode = DICT4;  						goto case DICT4;  					  					case DICT4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = DICT3;  						goto case DICT3;  					  					case DICT3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);  						z.istate.mode = DICT2;  						goto case DICT2;  					  					case DICT2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);  						z.istate.mode = DICT1;  						goto case DICT1;  					  					case DICT1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);  						z.adler = z.istate.need;  						z.istate.mode = DICT0;  						return Z_NEED_DICT;  					  					case DICT0:   						z.istate.mode = BAD;  						z.msg = "need dictionary";  						z.istate.marker = 0; // can try inflateSync  						return Z_STREAM_ERROR;  					  					case BLOCKS:   						  						r = z.istate.blocks.proc(z' r);  						if (r == Z_DATA_ERROR)  						{  							z.istate.mode = BAD;  							z.istate.marker = 0; // can try inflateSync  							break;  						}  						if (r == Z_OK)  						{  							r = f;  						}  						if (r != Z_STREAM_END)  						{  							return r;  						}  						r = f;  						z.istate.blocks.reset(z' z.istate.was);  						if (z.istate.nowrap != 0)  						{  							z.istate.mode = DONE;  							break;  						}  						z.istate.mode = CHECK4;  						goto case CHECK4;  					  					case CHECK4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = CHECK3;  						goto case CHECK3;  					  					case CHECK3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);  						z.istate.mode = CHECK2;  						goto case CHECK2;  					  					case CHECK2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);  						z.istate.mode = CHECK1;  						goto case CHECK1;  					  					case CHECK1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);  						  						if (((int) (z.istate.was[0])) != ((int) (z.istate.need)))  						{  							z.istate.mode = BAD;  							z.msg = "incorrect data check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						z.istate.mode = DONE;  						goto case DONE;  					  					case DONE:   						return Z_STREAM_END;  					  					case BAD:   						return Z_DATA_ERROR;  					  					default:   						return Z_STREAM_ERROR;  					  				}  			}
Magic Number,FrameWork,Inflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Inflate.cs,inflate,The following statement contains a magic number: while (true)  			{  				//System.out.println("mode: "+z.istate.mode);  				switch (z.istate.mode)  				{  					  					case METHOD:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)  						{  							z.istate.mode = BAD;  							z.msg = "unknown compression method";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						if ((z.istate.method >> 4) + 8 > z.istate.wbits)  						{  							z.istate.mode = BAD;  							z.msg = "invalid window size";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						z.istate.mode = FLAG;  						goto case FLAG;  					  					case FLAG:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						b = (z.next_in[z.next_in_index++]) & 0xff;  						  						if ((((z.istate.method << 8) + b) % 31) != 0)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect header check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						if ((b & PRESET_DICT) == 0)  						{  							z.istate.mode = BLOCKS;  							break;  						}  						z.istate.mode = DICT4;  						goto case DICT4;  					  					case DICT4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = DICT3;  						goto case DICT3;  					  					case DICT3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);  						z.istate.mode = DICT2;  						goto case DICT2;  					  					case DICT2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);  						z.istate.mode = DICT1;  						goto case DICT1;  					  					case DICT1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);  						z.adler = z.istate.need;  						z.istate.mode = DICT0;  						return Z_NEED_DICT;  					  					case DICT0:   						z.istate.mode = BAD;  						z.msg = "need dictionary";  						z.istate.marker = 0; // can try inflateSync  						return Z_STREAM_ERROR;  					  					case BLOCKS:   						  						r = z.istate.blocks.proc(z' r);  						if (r == Z_DATA_ERROR)  						{  							z.istate.mode = BAD;  							z.istate.marker = 0; // can try inflateSync  							break;  						}  						if (r == Z_OK)  						{  							r = f;  						}  						if (r != Z_STREAM_END)  						{  							return r;  						}  						r = f;  						z.istate.blocks.reset(z' z.istate.was);  						if (z.istate.nowrap != 0)  						{  							z.istate.mode = DONE;  							break;  						}  						z.istate.mode = CHECK4;  						goto case CHECK4;  					  					case CHECK4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = CHECK3;  						goto case CHECK3;  					  					case CHECK3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);  						z.istate.mode = CHECK2;  						goto case CHECK2;  					  					case CHECK2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);  						z.istate.mode = CHECK1;  						goto case CHECK1;  					  					case CHECK1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);  						  						if (((int) (z.istate.was[0])) != ((int) (z.istate.need)))  						{  							z.istate.mode = BAD;  							z.msg = "incorrect data check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						z.istate.mode = DONE;  						goto case DONE;  					  					case DONE:   						return Z_STREAM_END;  					  					case BAD:   						return Z_DATA_ERROR;  					  					default:   						return Z_STREAM_ERROR;  					  				}  			}
Magic Number,FrameWork,Inflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Inflate.cs,inflate,The following statement contains a magic number: while (true)  			{  				//System.out.println("mode: "+z.istate.mode);  				switch (z.istate.mode)  				{  					  					case METHOD:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)  						{  							z.istate.mode = BAD;  							z.msg = "unknown compression method";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						if ((z.istate.method >> 4) + 8 > z.istate.wbits)  						{  							z.istate.mode = BAD;  							z.msg = "invalid window size";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						z.istate.mode = FLAG;  						goto case FLAG;  					  					case FLAG:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						b = (z.next_in[z.next_in_index++]) & 0xff;  						  						if ((((z.istate.method << 8) + b) % 31) != 0)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect header check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						if ((b & PRESET_DICT) == 0)  						{  							z.istate.mode = BLOCKS;  							break;  						}  						z.istate.mode = DICT4;  						goto case DICT4;  					  					case DICT4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = DICT3;  						goto case DICT3;  					  					case DICT3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);  						z.istate.mode = DICT2;  						goto case DICT2;  					  					case DICT2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);  						z.istate.mode = DICT1;  						goto case DICT1;  					  					case DICT1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);  						z.adler = z.istate.need;  						z.istate.mode = DICT0;  						return Z_NEED_DICT;  					  					case DICT0:   						z.istate.mode = BAD;  						z.msg = "need dictionary";  						z.istate.marker = 0; // can try inflateSync  						return Z_STREAM_ERROR;  					  					case BLOCKS:   						  						r = z.istate.blocks.proc(z' r);  						if (r == Z_DATA_ERROR)  						{  							z.istate.mode = BAD;  							z.istate.marker = 0; // can try inflateSync  							break;  						}  						if (r == Z_OK)  						{  							r = f;  						}  						if (r != Z_STREAM_END)  						{  							return r;  						}  						r = f;  						z.istate.blocks.reset(z' z.istate.was);  						if (z.istate.nowrap != 0)  						{  							z.istate.mode = DONE;  							break;  						}  						z.istate.mode = CHECK4;  						goto case CHECK4;  					  					case CHECK4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = CHECK3;  						goto case CHECK3;  					  					case CHECK3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);  						z.istate.mode = CHECK2;  						goto case CHECK2;  					  					case CHECK2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);  						z.istate.mode = CHECK1;  						goto case CHECK1;  					  					case CHECK1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);  						  						if (((int) (z.istate.was[0])) != ((int) (z.istate.need)))  						{  							z.istate.mode = BAD;  							z.msg = "incorrect data check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						z.istate.mode = DONE;  						goto case DONE;  					  					case DONE:   						return Z_STREAM_END;  					  					case BAD:   						return Z_DATA_ERROR;  					  					default:   						return Z_STREAM_ERROR;  					  				}  			}
Magic Number,FrameWork,Inflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Inflate.cs,inflate,The following statement contains a magic number: while (true)  			{  				//System.out.println("mode: "+z.istate.mode);  				switch (z.istate.mode)  				{  					  					case METHOD:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)  						{  							z.istate.mode = BAD;  							z.msg = "unknown compression method";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						if ((z.istate.method >> 4) + 8 > z.istate.wbits)  						{  							z.istate.mode = BAD;  							z.msg = "invalid window size";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						z.istate.mode = FLAG;  						goto case FLAG;  					  					case FLAG:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						b = (z.next_in[z.next_in_index++]) & 0xff;  						  						if ((((z.istate.method << 8) + b) % 31) != 0)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect header check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						if ((b & PRESET_DICT) == 0)  						{  							z.istate.mode = BLOCKS;  							break;  						}  						z.istate.mode = DICT4;  						goto case DICT4;  					  					case DICT4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = DICT3;  						goto case DICT3;  					  					case DICT3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);  						z.istate.mode = DICT2;  						goto case DICT2;  					  					case DICT2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);  						z.istate.mode = DICT1;  						goto case DICT1;  					  					case DICT1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);  						z.adler = z.istate.need;  						z.istate.mode = DICT0;  						return Z_NEED_DICT;  					  					case DICT0:   						z.istate.mode = BAD;  						z.msg = "need dictionary";  						z.istate.marker = 0; // can try inflateSync  						return Z_STREAM_ERROR;  					  					case BLOCKS:   						  						r = z.istate.blocks.proc(z' r);  						if (r == Z_DATA_ERROR)  						{  							z.istate.mode = BAD;  							z.istate.marker = 0; // can try inflateSync  							break;  						}  						if (r == Z_OK)  						{  							r = f;  						}  						if (r != Z_STREAM_END)  						{  							return r;  						}  						r = f;  						z.istate.blocks.reset(z' z.istate.was);  						if (z.istate.nowrap != 0)  						{  							z.istate.mode = DONE;  							break;  						}  						z.istate.mode = CHECK4;  						goto case CHECK4;  					  					case CHECK4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = CHECK3;  						goto case CHECK3;  					  					case CHECK3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);  						z.istate.mode = CHECK2;  						goto case CHECK2;  					  					case CHECK2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);  						z.istate.mode = CHECK1;  						goto case CHECK1;  					  					case CHECK1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);  						  						if (((int) (z.istate.was[0])) != ((int) (z.istate.need)))  						{  							z.istate.mode = BAD;  							z.msg = "incorrect data check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						z.istate.mode = DONE;  						goto case DONE;  					  					case DONE:   						return Z_STREAM_END;  					  					case BAD:   						return Z_DATA_ERROR;  					  					default:   						return Z_STREAM_ERROR;  					  				}  			}
Magic Number,FrameWork,Inflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Inflate.cs,inflate,The following statement contains a magic number: while (true)  			{  				//System.out.println("mode: "+z.istate.mode);  				switch (z.istate.mode)  				{  					  					case METHOD:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)  						{  							z.istate.mode = BAD;  							z.msg = "unknown compression method";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						if ((z.istate.method >> 4) + 8 > z.istate.wbits)  						{  							z.istate.mode = BAD;  							z.msg = "invalid window size";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						z.istate.mode = FLAG;  						goto case FLAG;  					  					case FLAG:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						b = (z.next_in[z.next_in_index++]) & 0xff;  						  						if ((((z.istate.method << 8) + b) % 31) != 0)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect header check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						if ((b & PRESET_DICT) == 0)  						{  							z.istate.mode = BLOCKS;  							break;  						}  						z.istate.mode = DICT4;  						goto case DICT4;  					  					case DICT4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = DICT3;  						goto case DICT3;  					  					case DICT3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);  						z.istate.mode = DICT2;  						goto case DICT2;  					  					case DICT2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);  						z.istate.mode = DICT1;  						goto case DICT1;  					  					case DICT1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);  						z.adler = z.istate.need;  						z.istate.mode = DICT0;  						return Z_NEED_DICT;  					  					case DICT0:   						z.istate.mode = BAD;  						z.msg = "need dictionary";  						z.istate.marker = 0; // can try inflateSync  						return Z_STREAM_ERROR;  					  					case BLOCKS:   						  						r = z.istate.blocks.proc(z' r);  						if (r == Z_DATA_ERROR)  						{  							z.istate.mode = BAD;  							z.istate.marker = 0; // can try inflateSync  							break;  						}  						if (r == Z_OK)  						{  							r = f;  						}  						if (r != Z_STREAM_END)  						{  							return r;  						}  						r = f;  						z.istate.blocks.reset(z' z.istate.was);  						if (z.istate.nowrap != 0)  						{  							z.istate.mode = DONE;  							break;  						}  						z.istate.mode = CHECK4;  						goto case CHECK4;  					  					case CHECK4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = CHECK3;  						goto case CHECK3;  					  					case CHECK3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);  						z.istate.mode = CHECK2;  						goto case CHECK2;  					  					case CHECK2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);  						z.istate.mode = CHECK1;  						goto case CHECK1;  					  					case CHECK1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);  						  						if (((int) (z.istate.was[0])) != ((int) (z.istate.need)))  						{  							z.istate.mode = BAD;  							z.msg = "incorrect data check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						z.istate.mode = DONE;  						goto case DONE;  					  					case DONE:   						return Z_STREAM_END;  					  					case BAD:   						return Z_DATA_ERROR;  					  					default:   						return Z_STREAM_ERROR;  					  				}  			}
Magic Number,FrameWork,Inflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Inflate.cs,inflate,The following statement contains a magic number: while (true)  			{  				//System.out.println("mode: "+z.istate.mode);  				switch (z.istate.mode)  				{  					  					case METHOD:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)  						{  							z.istate.mode = BAD;  							z.msg = "unknown compression method";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						if ((z.istate.method >> 4) + 8 > z.istate.wbits)  						{  							z.istate.mode = BAD;  							z.msg = "invalid window size";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						z.istate.mode = FLAG;  						goto case FLAG;  					  					case FLAG:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						b = (z.next_in[z.next_in_index++]) & 0xff;  						  						if ((((z.istate.method << 8) + b) % 31) != 0)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect header check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						if ((b & PRESET_DICT) == 0)  						{  							z.istate.mode = BLOCKS;  							break;  						}  						z.istate.mode = DICT4;  						goto case DICT4;  					  					case DICT4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = DICT3;  						goto case DICT3;  					  					case DICT3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);  						z.istate.mode = DICT2;  						goto case DICT2;  					  					case DICT2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);  						z.istate.mode = DICT1;  						goto case DICT1;  					  					case DICT1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);  						z.adler = z.istate.need;  						z.istate.mode = DICT0;  						return Z_NEED_DICT;  					  					case DICT0:   						z.istate.mode = BAD;  						z.msg = "need dictionary";  						z.istate.marker = 0; // can try inflateSync  						return Z_STREAM_ERROR;  					  					case BLOCKS:   						  						r = z.istate.blocks.proc(z' r);  						if (r == Z_DATA_ERROR)  						{  							z.istate.mode = BAD;  							z.istate.marker = 0; // can try inflateSync  							break;  						}  						if (r == Z_OK)  						{  							r = f;  						}  						if (r != Z_STREAM_END)  						{  							return r;  						}  						r = f;  						z.istate.blocks.reset(z' z.istate.was);  						if (z.istate.nowrap != 0)  						{  							z.istate.mode = DONE;  							break;  						}  						z.istate.mode = CHECK4;  						goto case CHECK4;  					  					case CHECK4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = CHECK3;  						goto case CHECK3;  					  					case CHECK3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);  						z.istate.mode = CHECK2;  						goto case CHECK2;  					  					case CHECK2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);  						z.istate.mode = CHECK1;  						goto case CHECK1;  					  					case CHECK1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);  						  						if (((int) (z.istate.was[0])) != ((int) (z.istate.need)))  						{  							z.istate.mode = BAD;  							z.msg = "incorrect data check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						z.istate.mode = DONE;  						goto case DONE;  					  					case DONE:   						return Z_STREAM_END;  					  					case BAD:   						return Z_DATA_ERROR;  					  					default:   						return Z_STREAM_ERROR;  					  				}  			}
Magic Number,FrameWork,Inflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Inflate.cs,inflate,The following statement contains a magic number: while (true)  			{  				//System.out.println("mode: "+z.istate.mode);  				switch (z.istate.mode)  				{  					  					case METHOD:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)  						{  							z.istate.mode = BAD;  							z.msg = "unknown compression method";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						if ((z.istate.method >> 4) + 8 > z.istate.wbits)  						{  							z.istate.mode = BAD;  							z.msg = "invalid window size";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						z.istate.mode = FLAG;  						goto case FLAG;  					  					case FLAG:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						b = (z.next_in[z.next_in_index++]) & 0xff;  						  						if ((((z.istate.method << 8) + b) % 31) != 0)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect header check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						if ((b & PRESET_DICT) == 0)  						{  							z.istate.mode = BLOCKS;  							break;  						}  						z.istate.mode = DICT4;  						goto case DICT4;  					  					case DICT4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = DICT3;  						goto case DICT3;  					  					case DICT3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);  						z.istate.mode = DICT2;  						goto case DICT2;  					  					case DICT2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);  						z.istate.mode = DICT1;  						goto case DICT1;  					  					case DICT1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);  						z.adler = z.istate.need;  						z.istate.mode = DICT0;  						return Z_NEED_DICT;  					  					case DICT0:   						z.istate.mode = BAD;  						z.msg = "need dictionary";  						z.istate.marker = 0; // can try inflateSync  						return Z_STREAM_ERROR;  					  					case BLOCKS:   						  						r = z.istate.blocks.proc(z' r);  						if (r == Z_DATA_ERROR)  						{  							z.istate.mode = BAD;  							z.istate.marker = 0; // can try inflateSync  							break;  						}  						if (r == Z_OK)  						{  							r = f;  						}  						if (r != Z_STREAM_END)  						{  							return r;  						}  						r = f;  						z.istate.blocks.reset(z' z.istate.was);  						if (z.istate.nowrap != 0)  						{  							z.istate.mode = DONE;  							break;  						}  						z.istate.mode = CHECK4;  						goto case CHECK4;  					  					case CHECK4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = CHECK3;  						goto case CHECK3;  					  					case CHECK3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);  						z.istate.mode = CHECK2;  						goto case CHECK2;  					  					case CHECK2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);  						z.istate.mode = CHECK1;  						goto case CHECK1;  					  					case CHECK1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);  						  						if (((int) (z.istate.was[0])) != ((int) (z.istate.need)))  						{  							z.istate.mode = BAD;  							z.msg = "incorrect data check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						z.istate.mode = DONE;  						goto case DONE;  					  					case DONE:   						return Z_STREAM_END;  					  					case BAD:   						return Z_DATA_ERROR;  					  					default:   						return Z_STREAM_ERROR;  					  				}  			}
Magic Number,FrameWork,Inflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Inflate.cs,inflate,The following statement contains a magic number: while (true)  			{  				//System.out.println("mode: "+z.istate.mode);  				switch (z.istate.mode)  				{  					  					case METHOD:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)  						{  							z.istate.mode = BAD;  							z.msg = "unknown compression method";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						if ((z.istate.method >> 4) + 8 > z.istate.wbits)  						{  							z.istate.mode = BAD;  							z.msg = "invalid window size";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						z.istate.mode = FLAG;  						goto case FLAG;  					  					case FLAG:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						b = (z.next_in[z.next_in_index++]) & 0xff;  						  						if ((((z.istate.method << 8) + b) % 31) != 0)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect header check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						if ((b & PRESET_DICT) == 0)  						{  							z.istate.mode = BLOCKS;  							break;  						}  						z.istate.mode = DICT4;  						goto case DICT4;  					  					case DICT4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = DICT3;  						goto case DICT3;  					  					case DICT3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);  						z.istate.mode = DICT2;  						goto case DICT2;  					  					case DICT2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);  						z.istate.mode = DICT1;  						goto case DICT1;  					  					case DICT1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);  						z.adler = z.istate.need;  						z.istate.mode = DICT0;  						return Z_NEED_DICT;  					  					case DICT0:   						z.istate.mode = BAD;  						z.msg = "need dictionary";  						z.istate.marker = 0; // can try inflateSync  						return Z_STREAM_ERROR;  					  					case BLOCKS:   						  						r = z.istate.blocks.proc(z' r);  						if (r == Z_DATA_ERROR)  						{  							z.istate.mode = BAD;  							z.istate.marker = 0; // can try inflateSync  							break;  						}  						if (r == Z_OK)  						{  							r = f;  						}  						if (r != Z_STREAM_END)  						{  							return r;  						}  						r = f;  						z.istate.blocks.reset(z' z.istate.was);  						if (z.istate.nowrap != 0)  						{  							z.istate.mode = DONE;  							break;  						}  						z.istate.mode = CHECK4;  						goto case CHECK4;  					  					case CHECK4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = CHECK3;  						goto case CHECK3;  					  					case CHECK3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);  						z.istate.mode = CHECK2;  						goto case CHECK2;  					  					case CHECK2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);  						z.istate.mode = CHECK1;  						goto case CHECK1;  					  					case CHECK1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);  						  						if (((int) (z.istate.was[0])) != ((int) (z.istate.need)))  						{  							z.istate.mode = BAD;  							z.msg = "incorrect data check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						z.istate.mode = DONE;  						goto case DONE;  					  					case DONE:   						return Z_STREAM_END;  					  					case BAD:   						return Z_DATA_ERROR;  					  					default:   						return Z_STREAM_ERROR;  					  				}  			}
Magic Number,FrameWork,Inflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Inflate.cs,inflate,The following statement contains a magic number: while (true)  			{  				//System.out.println("mode: "+z.istate.mode);  				switch (z.istate.mode)  				{  					  					case METHOD:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)  						{  							z.istate.mode = BAD;  							z.msg = "unknown compression method";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						if ((z.istate.method >> 4) + 8 > z.istate.wbits)  						{  							z.istate.mode = BAD;  							z.msg = "invalid window size";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						z.istate.mode = FLAG;  						goto case FLAG;  					  					case FLAG:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						b = (z.next_in[z.next_in_index++]) & 0xff;  						  						if ((((z.istate.method << 8) + b) % 31) != 0)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect header check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						if ((b & PRESET_DICT) == 0)  						{  							z.istate.mode = BLOCKS;  							break;  						}  						z.istate.mode = DICT4;  						goto case DICT4;  					  					case DICT4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = DICT3;  						goto case DICT3;  					  					case DICT3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);  						z.istate.mode = DICT2;  						goto case DICT2;  					  					case DICT2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);  						z.istate.mode = DICT1;  						goto case DICT1;  					  					case DICT1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);  						z.adler = z.istate.need;  						z.istate.mode = DICT0;  						return Z_NEED_DICT;  					  					case DICT0:   						z.istate.mode = BAD;  						z.msg = "need dictionary";  						z.istate.marker = 0; // can try inflateSync  						return Z_STREAM_ERROR;  					  					case BLOCKS:   						  						r = z.istate.blocks.proc(z' r);  						if (r == Z_DATA_ERROR)  						{  							z.istate.mode = BAD;  							z.istate.marker = 0; // can try inflateSync  							break;  						}  						if (r == Z_OK)  						{  							r = f;  						}  						if (r != Z_STREAM_END)  						{  							return r;  						}  						r = f;  						z.istate.blocks.reset(z' z.istate.was);  						if (z.istate.nowrap != 0)  						{  							z.istate.mode = DONE;  							break;  						}  						z.istate.mode = CHECK4;  						goto case CHECK4;  					  					case CHECK4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = CHECK3;  						goto case CHECK3;  					  					case CHECK3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);  						z.istate.mode = CHECK2;  						goto case CHECK2;  					  					case CHECK2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);  						z.istate.mode = CHECK1;  						goto case CHECK1;  					  					case CHECK1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);  						  						if (((int) (z.istate.was[0])) != ((int) (z.istate.need)))  						{  							z.istate.mode = BAD;  							z.msg = "incorrect data check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						z.istate.mode = DONE;  						goto case DONE;  					  					case DONE:   						return Z_STREAM_END;  					  					case BAD:   						return Z_DATA_ERROR;  					  					default:   						return Z_STREAM_ERROR;  					  				}  			}
Magic Number,FrameWork,Inflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Inflate.cs,inflate,The following statement contains a magic number: while (true)  			{  				//System.out.println("mode: "+z.istate.mode);  				switch (z.istate.mode)  				{  					  					case METHOD:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)  						{  							z.istate.mode = BAD;  							z.msg = "unknown compression method";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						if ((z.istate.method >> 4) + 8 > z.istate.wbits)  						{  							z.istate.mode = BAD;  							z.msg = "invalid window size";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						z.istate.mode = FLAG;  						goto case FLAG;  					  					case FLAG:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						b = (z.next_in[z.next_in_index++]) & 0xff;  						  						if ((((z.istate.method << 8) + b) % 31) != 0)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect header check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						if ((b & PRESET_DICT) == 0)  						{  							z.istate.mode = BLOCKS;  							break;  						}  						z.istate.mode = DICT4;  						goto case DICT4;  					  					case DICT4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = DICT3;  						goto case DICT3;  					  					case DICT3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);  						z.istate.mode = DICT2;  						goto case DICT2;  					  					case DICT2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);  						z.istate.mode = DICT1;  						goto case DICT1;  					  					case DICT1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);  						z.adler = z.istate.need;  						z.istate.mode = DICT0;  						return Z_NEED_DICT;  					  					case DICT0:   						z.istate.mode = BAD;  						z.msg = "need dictionary";  						z.istate.marker = 0; // can try inflateSync  						return Z_STREAM_ERROR;  					  					case BLOCKS:   						  						r = z.istate.blocks.proc(z' r);  						if (r == Z_DATA_ERROR)  						{  							z.istate.mode = BAD;  							z.istate.marker = 0; // can try inflateSync  							break;  						}  						if (r == Z_OK)  						{  							r = f;  						}  						if (r != Z_STREAM_END)  						{  							return r;  						}  						r = f;  						z.istate.blocks.reset(z' z.istate.was);  						if (z.istate.nowrap != 0)  						{  							z.istate.mode = DONE;  							break;  						}  						z.istate.mode = CHECK4;  						goto case CHECK4;  					  					case CHECK4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = CHECK3;  						goto case CHECK3;  					  					case CHECK3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);  						z.istate.mode = CHECK2;  						goto case CHECK2;  					  					case CHECK2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);  						z.istate.mode = CHECK1;  						goto case CHECK1;  					  					case CHECK1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);  						  						if (((int) (z.istate.was[0])) != ((int) (z.istate.need)))  						{  							z.istate.mode = BAD;  							z.msg = "incorrect data check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						z.istate.mode = DONE;  						goto case DONE;  					  					case DONE:   						return Z_STREAM_END;  					  					case BAD:   						return Z_DATA_ERROR;  					  					default:   						return Z_STREAM_ERROR;  					  				}  			}
Magic Number,FrameWork,Inflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Inflate.cs,inflate,The following statement contains a magic number: while (true)  			{  				//System.out.println("mode: "+z.istate.mode);  				switch (z.istate.mode)  				{  					  					case METHOD:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)  						{  							z.istate.mode = BAD;  							z.msg = "unknown compression method";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						if ((z.istate.method >> 4) + 8 > z.istate.wbits)  						{  							z.istate.mode = BAD;  							z.msg = "invalid window size";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						z.istate.mode = FLAG;  						goto case FLAG;  					  					case FLAG:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						b = (z.next_in[z.next_in_index++]) & 0xff;  						  						if ((((z.istate.method << 8) + b) % 31) != 0)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect header check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						if ((b & PRESET_DICT) == 0)  						{  							z.istate.mode = BLOCKS;  							break;  						}  						z.istate.mode = DICT4;  						goto case DICT4;  					  					case DICT4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = DICT3;  						goto case DICT3;  					  					case DICT3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);  						z.istate.mode = DICT2;  						goto case DICT2;  					  					case DICT2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);  						z.istate.mode = DICT1;  						goto case DICT1;  					  					case DICT1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);  						z.adler = z.istate.need;  						z.istate.mode = DICT0;  						return Z_NEED_DICT;  					  					case DICT0:   						z.istate.mode = BAD;  						z.msg = "need dictionary";  						z.istate.marker = 0; // can try inflateSync  						return Z_STREAM_ERROR;  					  					case BLOCKS:   						  						r = z.istate.blocks.proc(z' r);  						if (r == Z_DATA_ERROR)  						{  							z.istate.mode = BAD;  							z.istate.marker = 0; // can try inflateSync  							break;  						}  						if (r == Z_OK)  						{  							r = f;  						}  						if (r != Z_STREAM_END)  						{  							return r;  						}  						r = f;  						z.istate.blocks.reset(z' z.istate.was);  						if (z.istate.nowrap != 0)  						{  							z.istate.mode = DONE;  							break;  						}  						z.istate.mode = CHECK4;  						goto case CHECK4;  					  					case CHECK4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = CHECK3;  						goto case CHECK3;  					  					case CHECK3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);  						z.istate.mode = CHECK2;  						goto case CHECK2;  					  					case CHECK2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);  						z.istate.mode = CHECK1;  						goto case CHECK1;  					  					case CHECK1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);  						  						if (((int) (z.istate.was[0])) != ((int) (z.istate.need)))  						{  							z.istate.mode = BAD;  							z.msg = "incorrect data check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						z.istate.mode = DONE;  						goto case DONE;  					  					case DONE:   						return Z_STREAM_END;  					  					case BAD:   						return Z_DATA_ERROR;  					  					default:   						return Z_STREAM_ERROR;  					  				}  			}
Magic Number,FrameWork,Inflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Inflate.cs,inflateSync,The following statement contains a magic number: while (n != 0 && m < 4)  			{  				if (z.next_in[p] == mark[m])  				{  					m++;  				}  				else if (z.next_in[p] != 0)  				{  					m = 0;  				}  				else  				{  					m = 4 - m;  				}  				p++; n--;  			}
Magic Number,FrameWork,Inflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Inflate.cs,inflateSync,The following statement contains a magic number: while (n != 0 && m < 4)  			{  				if (z.next_in[p] == mark[m])  				{  					m++;  				}  				else if (z.next_in[p] != 0)  				{  					m = 0;  				}  				else  				{  					m = 4 - m;  				}  				p++; n--;  			}
Magic Number,FrameWork,Inflate,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Inflate.cs,inflateSync,The following statement contains a magic number: if (m != 4)  			{  				return Z_DATA_ERROR;  			}
Magic Number,FrameWork,InfTree,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfTree.cs,huft_build,The following statement contains a magic number: int[] r = new int[3];
Magic Number,FrameWork,InfTree,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfTree.cs,huft_build,The following statement contains a magic number: xp = 2;
Magic Number,FrameWork,InfTree,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)  			{  				a = c[k];  				while (a-- != 0)  				{  					// here i is the Huffman code of length k bits for value *p  					// make tables up to required level  					while (k > w + l)  					{  						h++;  						w += l; // previous table always l bits  						// compute minimum size table less than or equal to l bits  						z = g - w;  						z = (z > l)?l:z; // table size upper limit  						if ((f = 1 << (j = k - w)) > a + 1)  						{  							// try a k-w bit table  							// too few codes for k-w bit table  							f -= (a + 1); // deduct codes from patterns left  							xp = k;  							if (j < z)  							{  								while (++j < z)  								{  									// try smaller tables up to z bits  									if ((f <<= 1) <= c[++xp])  										break; // enough codes to use up j bits  									f -= c[xp]; // else deduct codes from patterns  								}  							}  						}  						z = 1 << j; // table entries for j-bit table  						  						// allocate new table  						if (hn[0] + z > MANY)  						// (note: doesn't matter for fixed)  							return Z_DATA_ERROR; // overflow of MANY  						u[h] = q = hn[0]; // DEBUG  						hn[0] += z;  						  						// connect to last table' if there is one  						if (h != 0)  						{  							x[h] = i; // save pattern for backing up  							r[0] = (byte) j; // bits in this table  							r[1] = (byte) l; // bits to dump before this table  							j = SupportClass.URShift(i' (w - l));  							r[2] = (int) (q - u[h - 1] - j); // offset to this table  							Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table  						}  						else  						{  							t[0] = q; // first table is returned result  						}  					}  					  					// set up table entry in r  					r[1] = (byte) (k - w);  					if (p >= n)  					{  						r[0] = 128 + 64; // out of values--invalid code  					}  					else if (v[p] < s)  					{  						r[0] = (byte) (v[p] < 256?0:32 + 64); // 256 is end-of-block  						r[2] = v[p++]; // simple code is just the value  					}  					else  					{  						r[0] = (byte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists  						r[2] = d[v[p++] - s];  					}  					  					// fill code-like entries with r  					f = 1 << (k - w);  					for (j = SupportClass.URShift(i' w); j < z; j += f)  					{  						Array.Copy(r' 0' hp' (q + j) * 3' 3);  					}  					  					// backwards increment the k-bit code i  					for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift(j' 1))  					{  						i ^= j;  					}  					i ^= j;  					  					// backup over finished tables  					mask = (1 << w) - 1; // needed on HP' cc -O bug  					while ((i & mask) != x[h])  					{  						h--; // don't need to update q  						w -= l;  						mask = (1 << w) - 1;  					}  				}  			}
Magic Number,FrameWork,InfTree,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)  			{  				a = c[k];  				while (a-- != 0)  				{  					// here i is the Huffman code of length k bits for value *p  					// make tables up to required level  					while (k > w + l)  					{  						h++;  						w += l; // previous table always l bits  						// compute minimum size table less than or equal to l bits  						z = g - w;  						z = (z > l)?l:z; // table size upper limit  						if ((f = 1 << (j = k - w)) > a + 1)  						{  							// try a k-w bit table  							// too few codes for k-w bit table  							f -= (a + 1); // deduct codes from patterns left  							xp = k;  							if (j < z)  							{  								while (++j < z)  								{  									// try smaller tables up to z bits  									if ((f <<= 1) <= c[++xp])  										break; // enough codes to use up j bits  									f -= c[xp]; // else deduct codes from patterns  								}  							}  						}  						z = 1 << j; // table entries for j-bit table  						  						// allocate new table  						if (hn[0] + z > MANY)  						// (note: doesn't matter for fixed)  							return Z_DATA_ERROR; // overflow of MANY  						u[h] = q = hn[0]; // DEBUG  						hn[0] += z;  						  						// connect to last table' if there is one  						if (h != 0)  						{  							x[h] = i; // save pattern for backing up  							r[0] = (byte) j; // bits in this table  							r[1] = (byte) l; // bits to dump before this table  							j = SupportClass.URShift(i' (w - l));  							r[2] = (int) (q - u[h - 1] - j); // offset to this table  							Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table  						}  						else  						{  							t[0] = q; // first table is returned result  						}  					}  					  					// set up table entry in r  					r[1] = (byte) (k - w);  					if (p >= n)  					{  						r[0] = 128 + 64; // out of values--invalid code  					}  					else if (v[p] < s)  					{  						r[0] = (byte) (v[p] < 256?0:32 + 64); // 256 is end-of-block  						r[2] = v[p++]; // simple code is just the value  					}  					else  					{  						r[0] = (byte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists  						r[2] = d[v[p++] - s];  					}  					  					// fill code-like entries with r  					f = 1 << (k - w);  					for (j = SupportClass.URShift(i' w); j < z; j += f)  					{  						Array.Copy(r' 0' hp' (q + j) * 3' 3);  					}  					  					// backwards increment the k-bit code i  					for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift(j' 1))  					{  						i ^= j;  					}  					i ^= j;  					  					// backup over finished tables  					mask = (1 << w) - 1; // needed on HP' cc -O bug  					while ((i & mask) != x[h])  					{  						h--; // don't need to update q  						w -= l;  						mask = (1 << w) - 1;  					}  				}  			}
Magic Number,FrameWork,InfTree,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)  			{  				a = c[k];  				while (a-- != 0)  				{  					// here i is the Huffman code of length k bits for value *p  					// make tables up to required level  					while (k > w + l)  					{  						h++;  						w += l; // previous table always l bits  						// compute minimum size table less than or equal to l bits  						z = g - w;  						z = (z > l)?l:z; // table size upper limit  						if ((f = 1 << (j = k - w)) > a + 1)  						{  							// try a k-w bit table  							// too few codes for k-w bit table  							f -= (a + 1); // deduct codes from patterns left  							xp = k;  							if (j < z)  							{  								while (++j < z)  								{  									// try smaller tables up to z bits  									if ((f <<= 1) <= c[++xp])  										break; // enough codes to use up j bits  									f -= c[xp]; // else deduct codes from patterns  								}  							}  						}  						z = 1 << j; // table entries for j-bit table  						  						// allocate new table  						if (hn[0] + z > MANY)  						// (note: doesn't matter for fixed)  							return Z_DATA_ERROR; // overflow of MANY  						u[h] = q = hn[0]; // DEBUG  						hn[0] += z;  						  						// connect to last table' if there is one  						if (h != 0)  						{  							x[h] = i; // save pattern for backing up  							r[0] = (byte) j; // bits in this table  							r[1] = (byte) l; // bits to dump before this table  							j = SupportClass.URShift(i' (w - l));  							r[2] = (int) (q - u[h - 1] - j); // offset to this table  							Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table  						}  						else  						{  							t[0] = q; // first table is returned result  						}  					}  					  					// set up table entry in r  					r[1] = (byte) (k - w);  					if (p >= n)  					{  						r[0] = 128 + 64; // out of values--invalid code  					}  					else if (v[p] < s)  					{  						r[0] = (byte) (v[p] < 256?0:32 + 64); // 256 is end-of-block  						r[2] = v[p++]; // simple code is just the value  					}  					else  					{  						r[0] = (byte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists  						r[2] = d[v[p++] - s];  					}  					  					// fill code-like entries with r  					f = 1 << (k - w);  					for (j = SupportClass.URShift(i' w); j < z; j += f)  					{  						Array.Copy(r' 0' hp' (q + j) * 3' 3);  					}  					  					// backwards increment the k-bit code i  					for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift(j' 1))  					{  						i ^= j;  					}  					i ^= j;  					  					// backup over finished tables  					mask = (1 << w) - 1; // needed on HP' cc -O bug  					while ((i & mask) != x[h])  					{  						h--; // don't need to update q  						w -= l;  						mask = (1 << w) - 1;  					}  				}  			}
Magic Number,FrameWork,InfTree,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)  			{  				a = c[k];  				while (a-- != 0)  				{  					// here i is the Huffman code of length k bits for value *p  					// make tables up to required level  					while (k > w + l)  					{  						h++;  						w += l; // previous table always l bits  						// compute minimum size table less than or equal to l bits  						z = g - w;  						z = (z > l)?l:z; // table size upper limit  						if ((f = 1 << (j = k - w)) > a + 1)  						{  							// try a k-w bit table  							// too few codes for k-w bit table  							f -= (a + 1); // deduct codes from patterns left  							xp = k;  							if (j < z)  							{  								while (++j < z)  								{  									// try smaller tables up to z bits  									if ((f <<= 1) <= c[++xp])  										break; // enough codes to use up j bits  									f -= c[xp]; // else deduct codes from patterns  								}  							}  						}  						z = 1 << j; // table entries for j-bit table  						  						// allocate new table  						if (hn[0] + z > MANY)  						// (note: doesn't matter for fixed)  							return Z_DATA_ERROR; // overflow of MANY  						u[h] = q = hn[0]; // DEBUG  						hn[0] += z;  						  						// connect to last table' if there is one  						if (h != 0)  						{  							x[h] = i; // save pattern for backing up  							r[0] = (byte) j; // bits in this table  							r[1] = (byte) l; // bits to dump before this table  							j = SupportClass.URShift(i' (w - l));  							r[2] = (int) (q - u[h - 1] - j); // offset to this table  							Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table  						}  						else  						{  							t[0] = q; // first table is returned result  						}  					}  					  					// set up table entry in r  					r[1] = (byte) (k - w);  					if (p >= n)  					{  						r[0] = 128 + 64; // out of values--invalid code  					}  					else if (v[p] < s)  					{  						r[0] = (byte) (v[p] < 256?0:32 + 64); // 256 is end-of-block  						r[2] = v[p++]; // simple code is just the value  					}  					else  					{  						r[0] = (byte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists  						r[2] = d[v[p++] - s];  					}  					  					// fill code-like entries with r  					f = 1 << (k - w);  					for (j = SupportClass.URShift(i' w); j < z; j += f)  					{  						Array.Copy(r' 0' hp' (q + j) * 3' 3);  					}  					  					// backwards increment the k-bit code i  					for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift(j' 1))  					{  						i ^= j;  					}  					i ^= j;  					  					// backup over finished tables  					mask = (1 << w) - 1; // needed on HP' cc -O bug  					while ((i & mask) != x[h])  					{  						h--; // don't need to update q  						w -= l;  						mask = (1 << w) - 1;  					}  				}  			}
Magic Number,FrameWork,InfTree,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)  			{  				a = c[k];  				while (a-- != 0)  				{  					// here i is the Huffman code of length k bits for value *p  					// make tables up to required level  					while (k > w + l)  					{  						h++;  						w += l; // previous table always l bits  						// compute minimum size table less than or equal to l bits  						z = g - w;  						z = (z > l)?l:z; // table size upper limit  						if ((f = 1 << (j = k - w)) > a + 1)  						{  							// try a k-w bit table  							// too few codes for k-w bit table  							f -= (a + 1); // deduct codes from patterns left  							xp = k;  							if (j < z)  							{  								while (++j < z)  								{  									// try smaller tables up to z bits  									if ((f <<= 1) <= c[++xp])  										break; // enough codes to use up j bits  									f -= c[xp]; // else deduct codes from patterns  								}  							}  						}  						z = 1 << j; // table entries for j-bit table  						  						// allocate new table  						if (hn[0] + z > MANY)  						// (note: doesn't matter for fixed)  							return Z_DATA_ERROR; // overflow of MANY  						u[h] = q = hn[0]; // DEBUG  						hn[0] += z;  						  						// connect to last table' if there is one  						if (h != 0)  						{  							x[h] = i; // save pattern for backing up  							r[0] = (byte) j; // bits in this table  							r[1] = (byte) l; // bits to dump before this table  							j = SupportClass.URShift(i' (w - l));  							r[2] = (int) (q - u[h - 1] - j); // offset to this table  							Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table  						}  						else  						{  							t[0] = q; // first table is returned result  						}  					}  					  					// set up table entry in r  					r[1] = (byte) (k - w);  					if (p >= n)  					{  						r[0] = 128 + 64; // out of values--invalid code  					}  					else if (v[p] < s)  					{  						r[0] = (byte) (v[p] < 256?0:32 + 64); // 256 is end-of-block  						r[2] = v[p++]; // simple code is just the value  					}  					else  					{  						r[0] = (byte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists  						r[2] = d[v[p++] - s];  					}  					  					// fill code-like entries with r  					f = 1 << (k - w);  					for (j = SupportClass.URShift(i' w); j < z; j += f)  					{  						Array.Copy(r' 0' hp' (q + j) * 3' 3);  					}  					  					// backwards increment the k-bit code i  					for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift(j' 1))  					{  						i ^= j;  					}  					i ^= j;  					  					// backup over finished tables  					mask = (1 << w) - 1; // needed on HP' cc -O bug  					while ((i & mask) != x[h])  					{  						h--; // don't need to update q  						w -= l;  						mask = (1 << w) - 1;  					}  				}  			}
Magic Number,FrameWork,InfTree,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)  			{  				a = c[k];  				while (a-- != 0)  				{  					// here i is the Huffman code of length k bits for value *p  					// make tables up to required level  					while (k > w + l)  					{  						h++;  						w += l; // previous table always l bits  						// compute minimum size table less than or equal to l bits  						z = g - w;  						z = (z > l)?l:z; // table size upper limit  						if ((f = 1 << (j = k - w)) > a + 1)  						{  							// try a k-w bit table  							// too few codes for k-w bit table  							f -= (a + 1); // deduct codes from patterns left  							xp = k;  							if (j < z)  							{  								while (++j < z)  								{  									// try smaller tables up to z bits  									if ((f <<= 1) <= c[++xp])  										break; // enough codes to use up j bits  									f -= c[xp]; // else deduct codes from patterns  								}  							}  						}  						z = 1 << j; // table entries for j-bit table  						  						// allocate new table  						if (hn[0] + z > MANY)  						// (note: doesn't matter for fixed)  							return Z_DATA_ERROR; // overflow of MANY  						u[h] = q = hn[0]; // DEBUG  						hn[0] += z;  						  						// connect to last table' if there is one  						if (h != 0)  						{  							x[h] = i; // save pattern for backing up  							r[0] = (byte) j; // bits in this table  							r[1] = (byte) l; // bits to dump before this table  							j = SupportClass.URShift(i' (w - l));  							r[2] = (int) (q - u[h - 1] - j); // offset to this table  							Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table  						}  						else  						{  							t[0] = q; // first table is returned result  						}  					}  					  					// set up table entry in r  					r[1] = (byte) (k - w);  					if (p >= n)  					{  						r[0] = 128 + 64; // out of values--invalid code  					}  					else if (v[p] < s)  					{  						r[0] = (byte) (v[p] < 256?0:32 + 64); // 256 is end-of-block  						r[2] = v[p++]; // simple code is just the value  					}  					else  					{  						r[0] = (byte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists  						r[2] = d[v[p++] - s];  					}  					  					// fill code-like entries with r  					f = 1 << (k - w);  					for (j = SupportClass.URShift(i' w); j < z; j += f)  					{  						Array.Copy(r' 0' hp' (q + j) * 3' 3);  					}  					  					// backwards increment the k-bit code i  					for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift(j' 1))  					{  						i ^= j;  					}  					i ^= j;  					  					// backup over finished tables  					mask = (1 << w) - 1; // needed on HP' cc -O bug  					while ((i & mask) != x[h])  					{  						h--; // don't need to update q  						w -= l;  						mask = (1 << w) - 1;  					}  				}  			}
Magic Number,FrameWork,InfTree,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)  			{  				a = c[k];  				while (a-- != 0)  				{  					// here i is the Huffman code of length k bits for value *p  					// make tables up to required level  					while (k > w + l)  					{  						h++;  						w += l; // previous table always l bits  						// compute minimum size table less than or equal to l bits  						z = g - w;  						z = (z > l)?l:z; // table size upper limit  						if ((f = 1 << (j = k - w)) > a + 1)  						{  							// try a k-w bit table  							// too few codes for k-w bit table  							f -= (a + 1); // deduct codes from patterns left  							xp = k;  							if (j < z)  							{  								while (++j < z)  								{  									// try smaller tables up to z bits  									if ((f <<= 1) <= c[++xp])  										break; // enough codes to use up j bits  									f -= c[xp]; // else deduct codes from patterns  								}  							}  						}  						z = 1 << j; // table entries for j-bit table  						  						// allocate new table  						if (hn[0] + z > MANY)  						// (note: doesn't matter for fixed)  							return Z_DATA_ERROR; // overflow of MANY  						u[h] = q = hn[0]; // DEBUG  						hn[0] += z;  						  						// connect to last table' if there is one  						if (h != 0)  						{  							x[h] = i; // save pattern for backing up  							r[0] = (byte) j; // bits in this table  							r[1] = (byte) l; // bits to dump before this table  							j = SupportClass.URShift(i' (w - l));  							r[2] = (int) (q - u[h - 1] - j); // offset to this table  							Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table  						}  						else  						{  							t[0] = q; // first table is returned result  						}  					}  					  					// set up table entry in r  					r[1] = (byte) (k - w);  					if (p >= n)  					{  						r[0] = 128 + 64; // out of values--invalid code  					}  					else if (v[p] < s)  					{  						r[0] = (byte) (v[p] < 256?0:32 + 64); // 256 is end-of-block  						r[2] = v[p++]; // simple code is just the value  					}  					else  					{  						r[0] = (byte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists  						r[2] = d[v[p++] - s];  					}  					  					// fill code-like entries with r  					f = 1 << (k - w);  					for (j = SupportClass.URShift(i' w); j < z; j += f)  					{  						Array.Copy(r' 0' hp' (q + j) * 3' 3);  					}  					  					// backwards increment the k-bit code i  					for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift(j' 1))  					{  						i ^= j;  					}  					i ^= j;  					  					// backup over finished tables  					mask = (1 << w) - 1; // needed on HP' cc -O bug  					while ((i & mask) != x[h])  					{  						h--; // don't need to update q  						w -= l;  						mask = (1 << w) - 1;  					}  				}  			}
Magic Number,FrameWork,InfTree,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)  			{  				a = c[k];  				while (a-- != 0)  				{  					// here i is the Huffman code of length k bits for value *p  					// make tables up to required level  					while (k > w + l)  					{  						h++;  						w += l; // previous table always l bits  						// compute minimum size table less than or equal to l bits  						z = g - w;  						z = (z > l)?l:z; // table size upper limit  						if ((f = 1 << (j = k - w)) > a + 1)  						{  							// try a k-w bit table  							// too few codes for k-w bit table  							f -= (a + 1); // deduct codes from patterns left  							xp = k;  							if (j < z)  							{  								while (++j < z)  								{  									// try smaller tables up to z bits  									if ((f <<= 1) <= c[++xp])  										break; // enough codes to use up j bits  									f -= c[xp]; // else deduct codes from patterns  								}  							}  						}  						z = 1 << j; // table entries for j-bit table  						  						// allocate new table  						if (hn[0] + z > MANY)  						// (note: doesn't matter for fixed)  							return Z_DATA_ERROR; // overflow of MANY  						u[h] = q = hn[0]; // DEBUG  						hn[0] += z;  						  						// connect to last table' if there is one  						if (h != 0)  						{  							x[h] = i; // save pattern for backing up  							r[0] = (byte) j; // bits in this table  							r[1] = (byte) l; // bits to dump before this table  							j = SupportClass.URShift(i' (w - l));  							r[2] = (int) (q - u[h - 1] - j); // offset to this table  							Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table  						}  						else  						{  							t[0] = q; // first table is returned result  						}  					}  					  					// set up table entry in r  					r[1] = (byte) (k - w);  					if (p >= n)  					{  						r[0] = 128 + 64; // out of values--invalid code  					}  					else if (v[p] < s)  					{  						r[0] = (byte) (v[p] < 256?0:32 + 64); // 256 is end-of-block  						r[2] = v[p++]; // simple code is just the value  					}  					else  					{  						r[0] = (byte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists  						r[2] = d[v[p++] - s];  					}  					  					// fill code-like entries with r  					f = 1 << (k - w);  					for (j = SupportClass.URShift(i' w); j < z; j += f)  					{  						Array.Copy(r' 0' hp' (q + j) * 3' 3);  					}  					  					// backwards increment the k-bit code i  					for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift(j' 1))  					{  						i ^= j;  					}  					i ^= j;  					  					// backup over finished tables  					mask = (1 << w) - 1; // needed on HP' cc -O bug  					while ((i & mask) != x[h])  					{  						h--; // don't need to update q  						w -= l;  						mask = (1 << w) - 1;  					}  				}  			}
Magic Number,FrameWork,InfTree,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)  			{  				a = c[k];  				while (a-- != 0)  				{  					// here i is the Huffman code of length k bits for value *p  					// make tables up to required level  					while (k > w + l)  					{  						h++;  						w += l; // previous table always l bits  						// compute minimum size table less than or equal to l bits  						z = g - w;  						z = (z > l)?l:z; // table size upper limit  						if ((f = 1 << (j = k - w)) > a + 1)  						{  							// try a k-w bit table  							// too few codes for k-w bit table  							f -= (a + 1); // deduct codes from patterns left  							xp = k;  							if (j < z)  							{  								while (++j < z)  								{  									// try smaller tables up to z bits  									if ((f <<= 1) <= c[++xp])  										break; // enough codes to use up j bits  									f -= c[xp]; // else deduct codes from patterns  								}  							}  						}  						z = 1 << j; // table entries for j-bit table  						  						// allocate new table  						if (hn[0] + z > MANY)  						// (note: doesn't matter for fixed)  							return Z_DATA_ERROR; // overflow of MANY  						u[h] = q = hn[0]; // DEBUG  						hn[0] += z;  						  						// connect to last table' if there is one  						if (h != 0)  						{  							x[h] = i; // save pattern for backing up  							r[0] = (byte) j; // bits in this table  							r[1] = (byte) l; // bits to dump before this table  							j = SupportClass.URShift(i' (w - l));  							r[2] = (int) (q - u[h - 1] - j); // offset to this table  							Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table  						}  						else  						{  							t[0] = q; // first table is returned result  						}  					}  					  					// set up table entry in r  					r[1] = (byte) (k - w);  					if (p >= n)  					{  						r[0] = 128 + 64; // out of values--invalid code  					}  					else if (v[p] < s)  					{  						r[0] = (byte) (v[p] < 256?0:32 + 64); // 256 is end-of-block  						r[2] = v[p++]; // simple code is just the value  					}  					else  					{  						r[0] = (byte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists  						r[2] = d[v[p++] - s];  					}  					  					// fill code-like entries with r  					f = 1 << (k - w);  					for (j = SupportClass.URShift(i' w); j < z; j += f)  					{  						Array.Copy(r' 0' hp' (q + j) * 3' 3);  					}  					  					// backwards increment the k-bit code i  					for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift(j' 1))  					{  						i ^= j;  					}  					i ^= j;  					  					// backup over finished tables  					mask = (1 << w) - 1; // needed on HP' cc -O bug  					while ((i & mask) != x[h])  					{  						h--; // don't need to update q  						w -= l;  						mask = (1 << w) - 1;  					}  				}  			}
Magic Number,FrameWork,InfTree,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)  			{  				a = c[k];  				while (a-- != 0)  				{  					// here i is the Huffman code of length k bits for value *p  					// make tables up to required level  					while (k > w + l)  					{  						h++;  						w += l; // previous table always l bits  						// compute minimum size table less than or equal to l bits  						z = g - w;  						z = (z > l)?l:z; // table size upper limit  						if ((f = 1 << (j = k - w)) > a + 1)  						{  							// try a k-w bit table  							// too few codes for k-w bit table  							f -= (a + 1); // deduct codes from patterns left  							xp = k;  							if (j < z)  							{  								while (++j < z)  								{  									// try smaller tables up to z bits  									if ((f <<= 1) <= c[++xp])  										break; // enough codes to use up j bits  									f -= c[xp]; // else deduct codes from patterns  								}  							}  						}  						z = 1 << j; // table entries for j-bit table  						  						// allocate new table  						if (hn[0] + z > MANY)  						// (note: doesn't matter for fixed)  							return Z_DATA_ERROR; // overflow of MANY  						u[h] = q = hn[0]; // DEBUG  						hn[0] += z;  						  						// connect to last table' if there is one  						if (h != 0)  						{  							x[h] = i; // save pattern for backing up  							r[0] = (byte) j; // bits in this table  							r[1] = (byte) l; // bits to dump before this table  							j = SupportClass.URShift(i' (w - l));  							r[2] = (int) (q - u[h - 1] - j); // offset to this table  							Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table  						}  						else  						{  							t[0] = q; // first table is returned result  						}  					}  					  					// set up table entry in r  					r[1] = (byte) (k - w);  					if (p >= n)  					{  						r[0] = 128 + 64; // out of values--invalid code  					}  					else if (v[p] < s)  					{  						r[0] = (byte) (v[p] < 256?0:32 + 64); // 256 is end-of-block  						r[2] = v[p++]; // simple code is just the value  					}  					else  					{  						r[0] = (byte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists  						r[2] = d[v[p++] - s];  					}  					  					// fill code-like entries with r  					f = 1 << (k - w);  					for (j = SupportClass.URShift(i' w); j < z; j += f)  					{  						Array.Copy(r' 0' hp' (q + j) * 3' 3);  					}  					  					// backwards increment the k-bit code i  					for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift(j' 1))  					{  						i ^= j;  					}  					i ^= j;  					  					// backup over finished tables  					mask = (1 << w) - 1; // needed on HP' cc -O bug  					while ((i & mask) != x[h])  					{  						h--; // don't need to update q  						w -= l;  						mask = (1 << w) - 1;  					}  				}  			}
Magic Number,FrameWork,InfTree,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)  			{  				a = c[k];  				while (a-- != 0)  				{  					// here i is the Huffman code of length k bits for value *p  					// make tables up to required level  					while (k > w + l)  					{  						h++;  						w += l; // previous table always l bits  						// compute minimum size table less than or equal to l bits  						z = g - w;  						z = (z > l)?l:z; // table size upper limit  						if ((f = 1 << (j = k - w)) > a + 1)  						{  							// try a k-w bit table  							// too few codes for k-w bit table  							f -= (a + 1); // deduct codes from patterns left  							xp = k;  							if (j < z)  							{  								while (++j < z)  								{  									// try smaller tables up to z bits  									if ((f <<= 1) <= c[++xp])  										break; // enough codes to use up j bits  									f -= c[xp]; // else deduct codes from patterns  								}  							}  						}  						z = 1 << j; // table entries for j-bit table  						  						// allocate new table  						if (hn[0] + z > MANY)  						// (note: doesn't matter for fixed)  							return Z_DATA_ERROR; // overflow of MANY  						u[h] = q = hn[0]; // DEBUG  						hn[0] += z;  						  						// connect to last table' if there is one  						if (h != 0)  						{  							x[h] = i; // save pattern for backing up  							r[0] = (byte) j; // bits in this table  							r[1] = (byte) l; // bits to dump before this table  							j = SupportClass.URShift(i' (w - l));  							r[2] = (int) (q - u[h - 1] - j); // offset to this table  							Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table  						}  						else  						{  							t[0] = q; // first table is returned result  						}  					}  					  					// set up table entry in r  					r[1] = (byte) (k - w);  					if (p >= n)  					{  						r[0] = 128 + 64; // out of values--invalid code  					}  					else if (v[p] < s)  					{  						r[0] = (byte) (v[p] < 256?0:32 + 64); // 256 is end-of-block  						r[2] = v[p++]; // simple code is just the value  					}  					else  					{  						r[0] = (byte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists  						r[2] = d[v[p++] - s];  					}  					  					// fill code-like entries with r  					f = 1 << (k - w);  					for (j = SupportClass.URShift(i' w); j < z; j += f)  					{  						Array.Copy(r' 0' hp' (q + j) * 3' 3);  					}  					  					// backwards increment the k-bit code i  					for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift(j' 1))  					{  						i ^= j;  					}  					i ^= j;  					  					// backup over finished tables  					mask = (1 << w) - 1; // needed on HP' cc -O bug  					while ((i & mask) != x[h])  					{  						h--; // don't need to update q  						w -= l;  						mask = (1 << w) - 1;  					}  				}  			}
Magic Number,FrameWork,InfTree,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)  			{  				a = c[k];  				while (a-- != 0)  				{  					// here i is the Huffman code of length k bits for value *p  					// make tables up to required level  					while (k > w + l)  					{  						h++;  						w += l; // previous table always l bits  						// compute minimum size table less than or equal to l bits  						z = g - w;  						z = (z > l)?l:z; // table size upper limit  						if ((f = 1 << (j = k - w)) > a + 1)  						{  							// try a k-w bit table  							// too few codes for k-w bit table  							f -= (a + 1); // deduct codes from patterns left  							xp = k;  							if (j < z)  							{  								while (++j < z)  								{  									// try smaller tables up to z bits  									if ((f <<= 1) <= c[++xp])  										break; // enough codes to use up j bits  									f -= c[xp]; // else deduct codes from patterns  								}  							}  						}  						z = 1 << j; // table entries for j-bit table  						  						// allocate new table  						if (hn[0] + z > MANY)  						// (note: doesn't matter for fixed)  							return Z_DATA_ERROR; // overflow of MANY  						u[h] = q = hn[0]; // DEBUG  						hn[0] += z;  						  						// connect to last table' if there is one  						if (h != 0)  						{  							x[h] = i; // save pattern for backing up  							r[0] = (byte) j; // bits in this table  							r[1] = (byte) l; // bits to dump before this table  							j = SupportClass.URShift(i' (w - l));  							r[2] = (int) (q - u[h - 1] - j); // offset to this table  							Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table  						}  						else  						{  							t[0] = q; // first table is returned result  						}  					}  					  					// set up table entry in r  					r[1] = (byte) (k - w);  					if (p >= n)  					{  						r[0] = 128 + 64; // out of values--invalid code  					}  					else if (v[p] < s)  					{  						r[0] = (byte) (v[p] < 256?0:32 + 64); // 256 is end-of-block  						r[2] = v[p++]; // simple code is just the value  					}  					else  					{  						r[0] = (byte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists  						r[2] = d[v[p++] - s];  					}  					  					// fill code-like entries with r  					f = 1 << (k - w);  					for (j = SupportClass.URShift(i' w); j < z; j += f)  					{  						Array.Copy(r' 0' hp' (q + j) * 3' 3);  					}  					  					// backwards increment the k-bit code i  					for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift(j' 1))  					{  						i ^= j;  					}  					i ^= j;  					  					// backup over finished tables  					mask = (1 << w) - 1; // needed on HP' cc -O bug  					while ((i & mask) != x[h])  					{  						h--; // don't need to update q  						w -= l;  						mask = (1 << w) - 1;  					}  				}  			}
Magic Number,FrameWork,InfTree,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)  			{  				a = c[k];  				while (a-- != 0)  				{  					// here i is the Huffman code of length k bits for value *p  					// make tables up to required level  					while (k > w + l)  					{  						h++;  						w += l; // previous table always l bits  						// compute minimum size table less than or equal to l bits  						z = g - w;  						z = (z > l)?l:z; // table size upper limit  						if ((f = 1 << (j = k - w)) > a + 1)  						{  							// try a k-w bit table  							// too few codes for k-w bit table  							f -= (a + 1); // deduct codes from patterns left  							xp = k;  							if (j < z)  							{  								while (++j < z)  								{  									// try smaller tables up to z bits  									if ((f <<= 1) <= c[++xp])  										break; // enough codes to use up j bits  									f -= c[xp]; // else deduct codes from patterns  								}  							}  						}  						z = 1 << j; // table entries for j-bit table  						  						// allocate new table  						if (hn[0] + z > MANY)  						// (note: doesn't matter for fixed)  							return Z_DATA_ERROR; // overflow of MANY  						u[h] = q = hn[0]; // DEBUG  						hn[0] += z;  						  						// connect to last table' if there is one  						if (h != 0)  						{  							x[h] = i; // save pattern for backing up  							r[0] = (byte) j; // bits in this table  							r[1] = (byte) l; // bits to dump before this table  							j = SupportClass.URShift(i' (w - l));  							r[2] = (int) (q - u[h - 1] - j); // offset to this table  							Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table  						}  						else  						{  							t[0] = q; // first table is returned result  						}  					}  					  					// set up table entry in r  					r[1] = (byte) (k - w);  					if (p >= n)  					{  						r[0] = 128 + 64; // out of values--invalid code  					}  					else if (v[p] < s)  					{  						r[0] = (byte) (v[p] < 256?0:32 + 64); // 256 is end-of-block  						r[2] = v[p++]; // simple code is just the value  					}  					else  					{  						r[0] = (byte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists  						r[2] = d[v[p++] - s];  					}  					  					// fill code-like entries with r  					f = 1 << (k - w);  					for (j = SupportClass.URShift(i' w); j < z; j += f)  					{  						Array.Copy(r' 0' hp' (q + j) * 3' 3);  					}  					  					// backwards increment the k-bit code i  					for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift(j' 1))  					{  						i ^= j;  					}  					i ^= j;  					  					// backup over finished tables  					mask = (1 << w) - 1; // needed on HP' cc -O bug  					while ((i & mask) != x[h])  					{  						h--; // don't need to update q  						w -= l;  						mask = (1 << w) - 1;  					}  				}  			}
Magic Number,FrameWork,InfTree,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)  			{  				a = c[k];  				while (a-- != 0)  				{  					// here i is the Huffman code of length k bits for value *p  					// make tables up to required level  					while (k > w + l)  					{  						h++;  						w += l; // previous table always l bits  						// compute minimum size table less than or equal to l bits  						z = g - w;  						z = (z > l)?l:z; // table size upper limit  						if ((f = 1 << (j = k - w)) > a + 1)  						{  							// try a k-w bit table  							// too few codes for k-w bit table  							f -= (a + 1); // deduct codes from patterns left  							xp = k;  							if (j < z)  							{  								while (++j < z)  								{  									// try smaller tables up to z bits  									if ((f <<= 1) <= c[++xp])  										break; // enough codes to use up j bits  									f -= c[xp]; // else deduct codes from patterns  								}  							}  						}  						z = 1 << j; // table entries for j-bit table  						  						// allocate new table  						if (hn[0] + z > MANY)  						// (note: doesn't matter for fixed)  							return Z_DATA_ERROR; // overflow of MANY  						u[h] = q = hn[0]; // DEBUG  						hn[0] += z;  						  						// connect to last table' if there is one  						if (h != 0)  						{  							x[h] = i; // save pattern for backing up  							r[0] = (byte) j; // bits in this table  							r[1] = (byte) l; // bits to dump before this table  							j = SupportClass.URShift(i' (w - l));  							r[2] = (int) (q - u[h - 1] - j); // offset to this table  							Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table  						}  						else  						{  							t[0] = q; // first table is returned result  						}  					}  					  					// set up table entry in r  					r[1] = (byte) (k - w);  					if (p >= n)  					{  						r[0] = 128 + 64; // out of values--invalid code  					}  					else if (v[p] < s)  					{  						r[0] = (byte) (v[p] < 256?0:32 + 64); // 256 is end-of-block  						r[2] = v[p++]; // simple code is just the value  					}  					else  					{  						r[0] = (byte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists  						r[2] = d[v[p++] - s];  					}  					  					// fill code-like entries with r  					f = 1 << (k - w);  					for (j = SupportClass.URShift(i' w); j < z; j += f)  					{  						Array.Copy(r' 0' hp' (q + j) * 3' 3);  					}  					  					// backwards increment the k-bit code i  					for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift(j' 1))  					{  						i ^= j;  					}  					i ^= j;  					  					// backup over finished tables  					mask = (1 << w) - 1; // needed on HP' cc -O bug  					while ((i & mask) != x[h])  					{  						h--; // don't need to update q  						w -= l;  						mask = (1 << w) - 1;  					}  				}  			}
Magic Number,FrameWork,InfTree,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfTree.cs,inflate_trees_bits,The following statement contains a magic number: int[] v = new int[19];
Magic Number,FrameWork,InfTree,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfTree.cs,inflate_trees_bits,The following statement contains a magic number: r = huft_build(c' 0' 19' 19' null' null' tb' bb' hp' hn' v);
Magic Number,FrameWork,InfTree,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfTree.cs,inflate_trees_bits,The following statement contains a magic number: r = huft_build(c' 0' 19' 19' null' null' tb' bb' hp' hn' v);
Magic Number,FrameWork,InfTree,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfTree.cs,inflate_trees_dynamic,The following statement contains a magic number: int[] v = new int[288];
Magic Number,FrameWork,InfTree,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfTree.cs,inflate_trees_dynamic,The following statement contains a magic number: r = huft_build(c' 0' nl' 257' cplens' cplext' tl' bl' hp' hn' v);
Magic Number,FrameWork,InfTree,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfTree.cs,inflate_trees_dynamic,The following statement contains a magic number: if (r != Z_OK || (bd[0] == 0 && nl > 257))  			{  				if (r == Z_DATA_ERROR)  				{  					z.msg = "oversubscribed distance tree";  				}  				else if (r == Z_BUF_ERROR)  				{  					z.msg = "incomplete distance tree";  					r = Z_DATA_ERROR;  				}  				else if (r != Z_MEM_ERROR)  				{  					z.msg = "empty distance tree with lengths";  					r = Z_DATA_ERROR;  				}  				return r;  			}
Magic Number,FrameWork,SupportClass,C:\repos\WarEmu_WarEmu\FrameWork\zlib\SupportClass.cs,URShift,The following statement contains a magic number: if ( number >= 0)  				return number >> bits;  			else  				return (number >> bits) + (2 << ~bits);
Magic Number,FrameWork,Tree,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Tree.cs,d_code,The following statement contains a magic number: return ((dist) < 256?_dist_code[dist]:_dist_code[256 + (SupportClass.URShift((dist)' 7))]);
Magic Number,FrameWork,Tree,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Tree.cs,d_code,The following statement contains a magic number: return ((dist) < 256?_dist_code[dist]:_dist_code[256 + (SupportClass.URShift((dist)' 7))]);
Magic Number,FrameWork,Tree,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Tree.cs,d_code,The following statement contains a magic number: return ((dist) < 256?_dist_code[dist]:_dist_code[256 + (SupportClass.URShift((dist)' 7))]);
Magic Number,FrameWork,Tree,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: tree[s.heap[s.heap_max] * 2 + 1] = 0;
Magic Number,FrameWork,Tree,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: for (h = s.heap_max + 1; h < HEAP_SIZE; h++)  			{  				n = s.heap[h];  				bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;  				if (bits > max_length)  				{  					bits = max_length; overflow++;  				}  				tree[n * 2 + 1] = (short) bits;  				// We overwrite tree[n*2+1] which is no longer needed  				  				if (n > max_code)  					continue; // not a leaf node  				  				s.bl_count[bits]++;  				xbits = 0;  				if (n >= base_Renamed)  					xbits = extra[n - base_Renamed];  				f = tree[n * 2];  				s.opt_len += f * (bits + xbits);  				if (stree != null)  					s.static_len += f * (stree[n * 2 + 1] + xbits);  			}
Magic Number,FrameWork,Tree,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: for (h = s.heap_max + 1; h < HEAP_SIZE; h++)  			{  				n = s.heap[h];  				bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;  				if (bits > max_length)  				{  					bits = max_length; overflow++;  				}  				tree[n * 2 + 1] = (short) bits;  				// We overwrite tree[n*2+1] which is no longer needed  				  				if (n > max_code)  					continue; // not a leaf node  				  				s.bl_count[bits]++;  				xbits = 0;  				if (n >= base_Renamed)  					xbits = extra[n - base_Renamed];  				f = tree[n * 2];  				s.opt_len += f * (bits + xbits);  				if (stree != null)  					s.static_len += f * (stree[n * 2 + 1] + xbits);  			}
Magic Number,FrameWork,Tree,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: for (h = s.heap_max + 1; h < HEAP_SIZE; h++)  			{  				n = s.heap[h];  				bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;  				if (bits > max_length)  				{  					bits = max_length; overflow++;  				}  				tree[n * 2 + 1] = (short) bits;  				// We overwrite tree[n*2+1] which is no longer needed  				  				if (n > max_code)  					continue; // not a leaf node  				  				s.bl_count[bits]++;  				xbits = 0;  				if (n >= base_Renamed)  					xbits = extra[n - base_Renamed];  				f = tree[n * 2];  				s.opt_len += f * (bits + xbits);  				if (stree != null)  					s.static_len += f * (stree[n * 2 + 1] + xbits);  			}
Magic Number,FrameWork,Tree,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: for (h = s.heap_max + 1; h < HEAP_SIZE; h++)  			{  				n = s.heap[h];  				bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;  				if (bits > max_length)  				{  					bits = max_length; overflow++;  				}  				tree[n * 2 + 1] = (short) bits;  				// We overwrite tree[n*2+1] which is no longer needed  				  				if (n > max_code)  					continue; // not a leaf node  				  				s.bl_count[bits]++;  				xbits = 0;  				if (n >= base_Renamed)  					xbits = extra[n - base_Renamed];  				f = tree[n * 2];  				s.opt_len += f * (bits + xbits);  				if (stree != null)  					s.static_len += f * (stree[n * 2 + 1] + xbits);  			}
Magic Number,FrameWork,Tree,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: for (h = s.heap_max + 1; h < HEAP_SIZE; h++)  			{  				n = s.heap[h];  				bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;  				if (bits > max_length)  				{  					bits = max_length; overflow++;  				}  				tree[n * 2 + 1] = (short) bits;  				// We overwrite tree[n*2+1] which is no longer needed  				  				if (n > max_code)  					continue; // not a leaf node  				  				s.bl_count[bits]++;  				xbits = 0;  				if (n >= base_Renamed)  					xbits = extra[n - base_Renamed];  				f = tree[n * 2];  				s.opt_len += f * (bits + xbits);  				if (stree != null)  					s.static_len += f * (stree[n * 2 + 1] + xbits);  			}
Magic Number,FrameWork,Tree,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: do   			{  				bits = max_length - 1;  				while (s.bl_count[bits] == 0)  					bits--;  				s.bl_count[bits]--; // move one leaf down the tree  				s.bl_count[bits + 1] = (short) (s.bl_count[bits + 1] + 2); // move one overflow item as its brother  				s.bl_count[max_length]--;  				// The brother of the overflow item also moves one step up'  				// but this does not affect bl_count[max_length]  				overflow -= 2;  			}  			while (overflow > 0);
Magic Number,FrameWork,Tree,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: do   			{  				bits = max_length - 1;  				while (s.bl_count[bits] == 0)  					bits--;  				s.bl_count[bits]--; // move one leaf down the tree  				s.bl_count[bits + 1] = (short) (s.bl_count[bits + 1] + 2); // move one overflow item as its brother  				s.bl_count[max_length]--;  				// The brother of the overflow item also moves one step up'  				// but this does not affect bl_count[max_length]  				overflow -= 2;  			}  			while (overflow > 0);
Magic Number,FrameWork,Tree,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: for (bits = max_length; bits != 0; bits--)  			{  				n = s.bl_count[bits];  				while (n != 0)  				{  					m = s.heap[--h];  					if (m > max_code)  						continue;  					if (tree[m * 2 + 1] != bits)  					{  						s.opt_len = (int) (s.opt_len + ((long) bits - (long) tree[m * 2 + 1]) * (long) tree[m * 2]);  						tree[m * 2 + 1] = (short) bits;  					}  					n--;  				}  			}
Magic Number,FrameWork,Tree,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: for (bits = max_length; bits != 0; bits--)  			{  				n = s.bl_count[bits];  				while (n != 0)  				{  					m = s.heap[--h];  					if (m > max_code)  						continue;  					if (tree[m * 2 + 1] != bits)  					{  						s.opt_len = (int) (s.opt_len + ((long) bits - (long) tree[m * 2 + 1]) * (long) tree[m * 2]);  						tree[m * 2 + 1] = (short) bits;  					}  					n--;  				}  			}
Magic Number,FrameWork,Tree,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: for (bits = max_length; bits != 0; bits--)  			{  				n = s.bl_count[bits];  				while (n != 0)  				{  					m = s.heap[--h];  					if (m > max_code)  						continue;  					if (tree[m * 2 + 1] != bits)  					{  						s.opt_len = (int) (s.opt_len + ((long) bits - (long) tree[m * 2 + 1]) * (long) tree[m * 2]);  						tree[m * 2 + 1] = (short) bits;  					}  					n--;  				}  			}
Magic Number,FrameWork,Tree,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: for (bits = max_length; bits != 0; bits--)  			{  				n = s.bl_count[bits];  				while (n != 0)  				{  					m = s.heap[--h];  					if (m > max_code)  						continue;  					if (tree[m * 2 + 1] != bits)  					{  						s.opt_len = (int) (s.opt_len + ((long) bits - (long) tree[m * 2 + 1]) * (long) tree[m * 2]);  						tree[m * 2 + 1] = (short) bits;  					}  					n--;  				}  			}
Magic Number,FrameWork,Tree,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Tree.cs,build_tree,The following statement contains a magic number: for (n = 0; n < elems; n++)  			{  				if (tree[n * 2] != 0)  				{  					s.heap[++s.heap_len] = max_code = n;  					s.depth[n] = 0;  				}  				else  				{  					tree[n * 2 + 1] = 0;  				}  			}
Magic Number,FrameWork,Tree,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Tree.cs,build_tree,The following statement contains a magic number: for (n = 0; n < elems; n++)  			{  				if (tree[n * 2] != 0)  				{  					s.heap[++s.heap_len] = max_code = n;  					s.depth[n] = 0;  				}  				else  				{  					tree[n * 2 + 1] = 0;  				}  			}
Magic Number,FrameWork,Tree,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Tree.cs,build_tree,The following statement contains a magic number: while (s.heap_len < 2)  			{  				node = s.heap[++s.heap_len] = (max_code < 2?++max_code:0);  				tree[node * 2] = 1;  				s.depth[node] = 0;  				s.opt_len--;  				if (stree != null)  					s.static_len -= stree[node * 2 + 1];  				// node is 0 or 1 so it does not have extra bits  			}
Magic Number,FrameWork,Tree,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Tree.cs,build_tree,The following statement contains a magic number: while (s.heap_len < 2)  			{  				node = s.heap[++s.heap_len] = (max_code < 2?++max_code:0);  				tree[node * 2] = 1;  				s.depth[node] = 0;  				s.opt_len--;  				if (stree != null)  					s.static_len -= stree[node * 2 + 1];  				// node is 0 or 1 so it does not have extra bits  			}
Magic Number,FrameWork,Tree,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Tree.cs,build_tree,The following statement contains a magic number: while (s.heap_len < 2)  			{  				node = s.heap[++s.heap_len] = (max_code < 2?++max_code:0);  				tree[node * 2] = 1;  				s.depth[node] = 0;  				s.opt_len--;  				if (stree != null)  					s.static_len -= stree[node * 2 + 1];  				// node is 0 or 1 so it does not have extra bits  			}
Magic Number,FrameWork,Tree,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Tree.cs,build_tree,The following statement contains a magic number: while (s.heap_len < 2)  			{  				node = s.heap[++s.heap_len] = (max_code < 2?++max_code:0);  				tree[node * 2] = 1;  				s.depth[node] = 0;  				s.opt_len--;  				if (stree != null)  					s.static_len -= stree[node * 2 + 1];  				// node is 0 or 1 so it does not have extra bits  			}
Magic Number,FrameWork,Tree,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Tree.cs,build_tree,The following statement contains a magic number: for (n = s.heap_len / 2; n >= 1; n--)  				s.pqdownheap(tree' n);
Magic Number,FrameWork,Tree,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Tree.cs,build_tree,The following statement contains a magic number: do   			{  				// n = node of least frequency  				n = s.heap[1];  				s.heap[1] = s.heap[s.heap_len--];  				s.pqdownheap(tree' 1);  				m = s.heap[1]; // m = node of next least frequency  				  				s.heap[--s.heap_max] = n; // keep the nodes sorted by frequency  				s.heap[--s.heap_max] = m;  				  				// Create a new node father of n and m  				tree[node * 2] = (short) (tree[n * 2] + tree[m * 2]);  				s.depth[node] = (byte) (System.Math.Max((byte) s.depth[n]' (byte) s.depth[m]) + 1);  				tree[n * 2 + 1] = tree[m * 2 + 1] = (short) node;  				  				// and insert the new node in the heap  				s.heap[1] = node++;  				s.pqdownheap(tree' 1);  			}  			while (s.heap_len >= 2);
Magic Number,FrameWork,Tree,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Tree.cs,build_tree,The following statement contains a magic number: do   			{  				// n = node of least frequency  				n = s.heap[1];  				s.heap[1] = s.heap[s.heap_len--];  				s.pqdownheap(tree' 1);  				m = s.heap[1]; // m = node of next least frequency  				  				s.heap[--s.heap_max] = n; // keep the nodes sorted by frequency  				s.heap[--s.heap_max] = m;  				  				// Create a new node father of n and m  				tree[node * 2] = (short) (tree[n * 2] + tree[m * 2]);  				s.depth[node] = (byte) (System.Math.Max((byte) s.depth[n]' (byte) s.depth[m]) + 1);  				tree[n * 2 + 1] = tree[m * 2 + 1] = (short) node;  				  				// and insert the new node in the heap  				s.heap[1] = node++;  				s.pqdownheap(tree' 1);  			}  			while (s.heap_len >= 2);
Magic Number,FrameWork,Tree,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Tree.cs,build_tree,The following statement contains a magic number: do   			{  				// n = node of least frequency  				n = s.heap[1];  				s.heap[1] = s.heap[s.heap_len--];  				s.pqdownheap(tree' 1);  				m = s.heap[1]; // m = node of next least frequency  				  				s.heap[--s.heap_max] = n; // keep the nodes sorted by frequency  				s.heap[--s.heap_max] = m;  				  				// Create a new node father of n and m  				tree[node * 2] = (short) (tree[n * 2] + tree[m * 2]);  				s.depth[node] = (byte) (System.Math.Max((byte) s.depth[n]' (byte) s.depth[m]) + 1);  				tree[n * 2 + 1] = tree[m * 2 + 1] = (short) node;  				  				// and insert the new node in the heap  				s.heap[1] = node++;  				s.pqdownheap(tree' 1);  			}  			while (s.heap_len >= 2);
Magic Number,FrameWork,Tree,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Tree.cs,build_tree,The following statement contains a magic number: do   			{  				// n = node of least frequency  				n = s.heap[1];  				s.heap[1] = s.heap[s.heap_len--];  				s.pqdownheap(tree' 1);  				m = s.heap[1]; // m = node of next least frequency  				  				s.heap[--s.heap_max] = n; // keep the nodes sorted by frequency  				s.heap[--s.heap_max] = m;  				  				// Create a new node father of n and m  				tree[node * 2] = (short) (tree[n * 2] + tree[m * 2]);  				s.depth[node] = (byte) (System.Math.Max((byte) s.depth[n]' (byte) s.depth[m]) + 1);  				tree[n * 2 + 1] = tree[m * 2 + 1] = (short) node;  				  				// and insert the new node in the heap  				s.heap[1] = node++;  				s.pqdownheap(tree' 1);  			}  			while (s.heap_len >= 2);
Magic Number,FrameWork,Tree,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Tree.cs,build_tree,The following statement contains a magic number: do   			{  				// n = node of least frequency  				n = s.heap[1];  				s.heap[1] = s.heap[s.heap_len--];  				s.pqdownheap(tree' 1);  				m = s.heap[1]; // m = node of next least frequency  				  				s.heap[--s.heap_max] = n; // keep the nodes sorted by frequency  				s.heap[--s.heap_max] = m;  				  				// Create a new node father of n and m  				tree[node * 2] = (short) (tree[n * 2] + tree[m * 2]);  				s.depth[node] = (byte) (System.Math.Max((byte) s.depth[n]' (byte) s.depth[m]) + 1);  				tree[n * 2 + 1] = tree[m * 2 + 1] = (short) node;  				  				// and insert the new node in the heap  				s.heap[1] = node++;  				s.pqdownheap(tree' 1);  			}  			while (s.heap_len >= 2);
Magic Number,FrameWork,Tree,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Tree.cs,build_tree,The following statement contains a magic number: do   			{  				// n = node of least frequency  				n = s.heap[1];  				s.heap[1] = s.heap[s.heap_len--];  				s.pqdownheap(tree' 1);  				m = s.heap[1]; // m = node of next least frequency  				  				s.heap[--s.heap_max] = n; // keep the nodes sorted by frequency  				s.heap[--s.heap_max] = m;  				  				// Create a new node father of n and m  				tree[node * 2] = (short) (tree[n * 2] + tree[m * 2]);  				s.depth[node] = (byte) (System.Math.Max((byte) s.depth[n]' (byte) s.depth[m]) + 1);  				tree[n * 2 + 1] = tree[m * 2 + 1] = (short) node;  				  				// and insert the new node in the heap  				s.heap[1] = node++;  				s.pqdownheap(tree' 1);  			}  			while (s.heap_len >= 2);
Magic Number,FrameWork,Tree,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Tree.cs,gen_codes,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				int len = tree[n * 2 + 1];  				if (len == 0)  					continue;  				// Now reverse the bits  				tree[n * 2] = (short) (bi_reverse(next_code[len]++' len));  			}
Magic Number,FrameWork,Tree,C:\repos\WarEmu_WarEmu\FrameWork\zlib\Tree.cs,gen_codes,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				int len = tree[n * 2 + 1];  				if (len == 0)  					continue;  				// Now reverse the bits  				tree[n * 2] = (short) (bi_reverse(next_code[len]++' len));  			}
Magic Number,FrameWork,ZInputStream,C:\repos\WarEmu_WarEmu\FrameWork\zlib\ZInputStream.cs,skip,The following statement contains a magic number: int len = 512;
Magic Number,ByteOperations,ByteSwap,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,Swap,The following statement contains a magic number: return ((UInt16)(              ((0xFF00 & input) >> 8) |              ((0x00FF & input) << 8)));
Magic Number,ByteOperations,ByteSwap,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,Swap,The following statement contains a magic number: return ((UInt16)(              ((0xFF00 & input) >> 8) |              ((0x00FF & input) << 8)));
Magic Number,ByteOperations,ByteSwap,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,Swap,The following statement contains a magic number: return ((UInt32)(              ((0xFF000000 & input) >> 24) |              ((0x00FF0000 & input) >> 8) |              ((0x0000FF00 & input) << 8) |              ((0x000000FF & input) << 24)));
Magic Number,ByteOperations,ByteSwap,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,Swap,The following statement contains a magic number: return ((UInt32)(              ((0xFF000000 & input) >> 24) |              ((0x00FF0000 & input) >> 8) |              ((0x0000FF00 & input) << 8) |              ((0x000000FF & input) << 24)));
Magic Number,ByteOperations,ByteSwap,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,Swap,The following statement contains a magic number: return ((UInt32)(              ((0xFF000000 & input) >> 24) |              ((0x00FF0000 & input) >> 8) |              ((0x0000FF00 & input) << 8) |              ((0x000000FF & input) << 24)));
Magic Number,ByteOperations,ByteSwap,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,Swap,The following statement contains a magic number: return ((UInt32)(              ((0xFF000000 & input) >> 24) |              ((0x00FF0000 & input) >> 8) |              ((0x0000FF00 & input) << 8) |              ((0x000000FF & input) << 24)));
Magic Number,ByteOperations,ByteSwap,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,Swap,The following statement contains a magic number: byte[] tmpOut = new byte[4];
Magic Number,ByteOperations,ByteSwap,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,Swap,The following statement contains a magic number: tmpOut[0] = tmpIn[3];
Magic Number,ByteOperations,ByteSwap,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,Swap,The following statement contains a magic number: tmpOut[1] = tmpIn[2];
Magic Number,ByteOperations,ByteSwap,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,Swap,The following statement contains a magic number: tmpOut[2] = tmpIn[1];
Magic Number,ByteOperations,ByteSwap,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,Swap,The following statement contains a magic number: tmpOut[3] = tmpIn[0];
Magic Number,ByteOperations,ByteSwap,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,Swap,The following statement contains a magic number: byte[] tmpOut = new byte[8];
Magic Number,ByteOperations,ByteSwap,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,Swap,The following statement contains a magic number: tmpOut[0] = tmpIn[7];
Magic Number,ByteOperations,ByteSwap,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,Swap,The following statement contains a magic number: tmpOut[1] = tmpIn[6];
Magic Number,ByteOperations,ByteSwap,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,Swap,The following statement contains a magic number: tmpOut[2] = tmpIn[5];
Magic Number,ByteOperations,ByteSwap,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,Swap,The following statement contains a magic number: tmpOut[2] = tmpIn[5];
Magic Number,ByteOperations,ByteSwap,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,Swap,The following statement contains a magic number: tmpOut[3] = tmpIn[4];
Magic Number,ByteOperations,ByteSwap,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,Swap,The following statement contains a magic number: tmpOut[3] = tmpIn[4];
Magic Number,ByteOperations,ByteSwap,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,Swap,The following statement contains a magic number: tmpOut[4] = tmpIn[3];
Magic Number,ByteOperations,ByteSwap,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,Swap,The following statement contains a magic number: tmpOut[4] = tmpIn[3];
Magic Number,ByteOperations,ByteSwap,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,Swap,The following statement contains a magic number: tmpOut[5] = tmpIn[2];
Magic Number,ByteOperations,ByteSwap,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,Swap,The following statement contains a magic number: tmpOut[5] = tmpIn[2];
Magic Number,ByteOperations,ByteSwap,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,Swap,The following statement contains a magic number: tmpOut[6] = tmpIn[1];
Magic Number,ByteOperations,ByteSwap,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,Swap,The following statement contains a magic number: tmpOut[7] = tmpIn[0];
Magic Number,ByteOperations,ByteSwap,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,UInt32_To_BE,The following statement contains a magic number: bs[0] = (byte)(n >> 24);
Magic Number,ByteOperations,ByteSwap,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,UInt32_To_BE,The following statement contains a magic number: bs[1] = (byte)(n >> 16);
Magic Number,ByteOperations,ByteSwap,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,UInt32_To_BE,The following statement contains a magic number: bs[2] = (byte)(n >> 8);
Magic Number,ByteOperations,ByteSwap,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,UInt32_To_BE,The following statement contains a magic number: bs[2] = (byte)(n >> 8);
Magic Number,ByteOperations,ByteSwap,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,UInt32_To_BE,The following statement contains a magic number: bs[3] = (byte)(n);
Magic Number,ByteOperations,ByteSwap,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,UInt32_To_BE,The following statement contains a magic number: bs[off] = (byte)(n >> 24);
Magic Number,ByteOperations,ByteSwap,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,UInt32_To_BE,The following statement contains a magic number: bs[++off] = (byte)(n >> 16);
Magic Number,ByteOperations,ByteSwap,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,UInt32_To_BE,The following statement contains a magic number: bs[++off] = (byte)(n >> 8);
Magic Number,ByteOperations,ByteSwap,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,BE_To_UInt32,The following statement contains a magic number: uint n = (uint)bs[0] << 24;
Magic Number,ByteOperations,ByteSwap,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,BE_To_UInt32,The following statement contains a magic number: n |= (uint)bs[1] << 16;
Magic Number,ByteOperations,ByteSwap,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,BE_To_UInt32,The following statement contains a magic number: n |= (uint)bs[2] << 8;
Magic Number,ByteOperations,ByteSwap,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,BE_To_UInt32,The following statement contains a magic number: n |= (uint)bs[2] << 8;
Magic Number,ByteOperations,ByteSwap,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,BE_To_UInt32,The following statement contains a magic number: n |= (uint)bs[3];
Magic Number,ByteOperations,ByteSwap,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,BE_To_UInt32,The following statement contains a magic number: uint n = (uint)bs[off] << 24;
Magic Number,ByteOperations,ByteSwap,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,BE_To_UInt32,The following statement contains a magic number: n |= (uint)bs[++off] << 16;
Magic Number,ByteOperations,ByteSwap,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,BE_To_UInt32,The following statement contains a magic number: n |= (uint)bs[++off] << 8;
Magic Number,ByteOperations,ByteSwap,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,BE_To_UInt64,The following statement contains a magic number: uint lo = BE_To_UInt32(bs' 4);
Magic Number,ByteOperations,ByteSwap,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,BE_To_UInt64,The following statement contains a magic number: return ((ulong)hi << 32) | (ulong)lo;
Magic Number,ByteOperations,ByteSwap,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,BE_To_UInt64,The following statement contains a magic number: uint lo = BE_To_UInt32(bs' off + 4);
Magic Number,ByteOperations,ByteSwap,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,BE_To_UInt64,The following statement contains a magic number: return ((ulong)hi << 32) | (ulong)lo;
Magic Number,ByteOperations,ByteSwap,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,UInt64_To_BE,The following statement contains a magic number: UInt32_To_BE((uint)(n >> 32)' bs);
Magic Number,ByteOperations,ByteSwap,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,UInt64_To_BE,The following statement contains a magic number: UInt32_To_BE((uint)(n)' bs' 4);
Magic Number,ByteOperations,ByteSwap,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,UInt64_To_BE,The following statement contains a magic number: UInt32_To_BE((uint)(n >> 32)' bs' off);
Magic Number,ByteOperations,ByteSwap,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,UInt64_To_BE,The following statement contains a magic number: UInt32_To_BE((uint)(n)' bs' off + 4);
Magic Number,ByteOperations,ByteSwap,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,UInt32_To_LE,The following statement contains a magic number: bs[1] = (byte)(n >> 8);
Magic Number,ByteOperations,ByteSwap,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,UInt32_To_LE,The following statement contains a magic number: bs[2] = (byte)(n >> 16);
Magic Number,ByteOperations,ByteSwap,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,UInt32_To_LE,The following statement contains a magic number: bs[2] = (byte)(n >> 16);
Magic Number,ByteOperations,ByteSwap,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,UInt32_To_LE,The following statement contains a magic number: bs[3] = (byte)(n >> 24);
Magic Number,ByteOperations,ByteSwap,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,UInt32_To_LE,The following statement contains a magic number: bs[3] = (byte)(n >> 24);
Magic Number,ByteOperations,ByteSwap,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,UInt32_To_LE,The following statement contains a magic number: bs[++off] = (byte)(n >> 8);
Magic Number,ByteOperations,ByteSwap,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,UInt32_To_LE,The following statement contains a magic number: bs[++off] = (byte)(n >> 16);
Magic Number,ByteOperations,ByteSwap,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,UInt32_To_LE,The following statement contains a magic number: bs[++off] = (byte)(n >> 24);
Magic Number,ByteOperations,ByteSwap,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,LE_To_UInt32,The following statement contains a magic number: n |= (uint)bs[1] << 8;
Magic Number,ByteOperations,ByteSwap,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,LE_To_UInt32,The following statement contains a magic number: n |= (uint)bs[2] << 16;
Magic Number,ByteOperations,ByteSwap,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,LE_To_UInt32,The following statement contains a magic number: n |= (uint)bs[2] << 16;
Magic Number,ByteOperations,ByteSwap,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,LE_To_UInt32,The following statement contains a magic number: n |= (uint)bs[3] << 24;
Magic Number,ByteOperations,ByteSwap,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,LE_To_UInt32,The following statement contains a magic number: n |= (uint)bs[3] << 24;
Magic Number,ByteOperations,ByteSwap,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,LE_To_UInt32,The following statement contains a magic number: n |= (uint)bs[++off] << 8;
Magic Number,ByteOperations,ByteSwap,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,LE_To_UInt32,The following statement contains a magic number: n |= (uint)bs[++off] << 16;
Magic Number,ByteOperations,ByteSwap,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,LE_To_UInt32,The following statement contains a magic number: n |= (uint)bs[++off] << 24;
Magic Number,ByteOperations,ByteSwap,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,LE_To_UInt64,The following statement contains a magic number: uint hi = LE_To_UInt32(bs' 4);
Magic Number,ByteOperations,ByteSwap,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,LE_To_UInt64,The following statement contains a magic number: return ((ulong)hi << 32) | (ulong)lo;
Magic Number,ByteOperations,ByteSwap,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,LE_To_UInt64,The following statement contains a magic number: uint hi = LE_To_UInt32(bs' off + 4);
Magic Number,ByteOperations,ByteSwap,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,LE_To_UInt64,The following statement contains a magic number: return ((ulong)hi << 32) | (ulong)lo;
Magic Number,ByteOperations,ByteSwap,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,UInt64_To_LE,The following statement contains a magic number: UInt32_To_LE((uint)(n >> 32)' bs' 4);
Magic Number,ByteOperations,ByteSwap,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,UInt64_To_LE,The following statement contains a magic number: UInt32_To_LE((uint)(n >> 32)' bs' 4);
Magic Number,ByteOperations,ByteSwap,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,UInt64_To_LE,The following statement contains a magic number: UInt32_To_LE((uint)(n >> 32)' bs' off + 4);
Magic Number,ByteOperations,ByteSwap,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,UInt64_To_LE,The following statement contains a magic number: UInt32_To_LE((uint)(n >> 32)' bs' off + 4);
Duplicate Code,FrameWork,DataConnection,C:\repos\WarEmu_WarEmu\FrameWork\Database\Connection\DataConnection.cs,SaveDataSet,The method contains a code clone-set at the following line numbers (starting from the method definition): ((44' 65)' (80' 101))
Missing Default,FrameWork,DataConnection,C:\repos\WarEmu_WarEmu\FrameWork\Database\Connection\DataConnection.cs,HandleException,The following switch statement is missing a default case: switch (socketException.ErrorCode)                  {                      case 10052:                      case 10053:                      case 10054:                      case 10057:                      case 10058:                          {                              ret = true;                              break;                          }                  }
Missing Default,FrameWork,DataConnection,C:\repos\WarEmu_WarEmu\FrameWork\Database\Connection\DataConnection.cs,GetDBDateFormat,The following switch statement is missing a default case: switch (connType)              {                  case ConnectionType.DATABASE_MYSQL:                      return "yyyy-MM-dd HH:mm:ss";              }
Missing Default,FrameWork,DataConnection,C:\repos\WarEmu_WarEmu\FrameWork\Database\Connection\DataConnection.cs,LoadDataSet,The following switch statement is missing a default case: switch (connType)              {                  case ConnectionType.DATABASE_MSSQL:                      {                          try                          {                              var conn = new SqlConnection(connString);                              var adapter = new SqlDataAdapter("SELECT * from " + tableName' conn);                                adapter.Fill(dataSet.Tables[tableName]);                          }                          catch (Exception ex)                          {                              throw new DatabaseException("Can not load table "' ex);                          }                            break;                      }                  case ConnectionType.DATABASE_ODBC:                      {                          try                          {                              var conn = new OdbcConnection(connString);                              var adapter = new OdbcDataAdapter("SELECT * from " + tableName' conn);                                adapter.Fill(dataSet.Tables[tableName]);                          }                          catch (Exception ex)                          {                              throw new DatabaseException("Can not load table "' ex);                          }                            break;                      }                  case ConnectionType.DATABASE_OLEDB:                      {                          try                          {                              var conn = new OleDbConnection(connString);                              var adapter = new OleDbDataAdapter("SELECT * from " + tableName' conn);                                adapter.Fill(dataSet.Tables[tableName]);                          }                          catch (Exception ex)                          {                              throw new DatabaseException("Can not load table "' ex);                          }                          break;                      }              }
Missing Default,FrameWork,DataConnection,C:\repos\WarEmu_WarEmu\FrameWork\Database\Connection\DataConnection.cs,SaveDataSet,The following switch statement is missing a default case: switch (connType)              {                  case ConnectionType.DATABASE_MSSQL:                      {                          try                          {                              var conn = new SqlConnection(connString);                              var adapter = new SqlDataAdapter("SELECT * from " + tableName' conn);                              var builder = new SqlCommandBuilder(adapter);                                adapter.DeleteCommand = builder.GetDeleteCommand();                              adapter.UpdateCommand = builder.GetUpdateCommand();                              adapter.InsertCommand = builder.GetInsertCommand();                                lock (dataSet) // lock dataset to prevent changes to it                              {                                  adapter.ContinueUpdateOnError = true;                                  DataSet changes = dataSet.GetChanges();                                  adapter.Update(changes' tableName);                                  PrintDatasetErrors(changes);                                  dataSet.AcceptChanges();                              }                                conn.Close();                          }                          catch (Exception ex)                          {                              throw new DatabaseException("Can not save table " + tableName' ex);                          }                            break;                      }                  case ConnectionType.DATABASE_ODBC:                      {                          try                          {                              var conn = new OdbcConnection(connString);                              var adapter = new OdbcDataAdapter("SELECT * from " + tableName' conn);                              var builder = new OdbcCommandBuilder(adapter);                                adapter.DeleteCommand = builder.GetDeleteCommand();                              adapter.UpdateCommand = builder.GetUpdateCommand();                              adapter.InsertCommand = builder.GetInsertCommand();                                DataSet changes;                              lock (dataSet) // lock dataset to prevent changes to it                              {                                  adapter.ContinueUpdateOnError = true;                                  changes = dataSet.GetChanges();                                  adapter.Update(changes' tableName);                                  dataSet.AcceptChanges();                              }                                PrintDatasetErrors(changes);                                conn.Close();                          }                          catch (Exception ex)                          {                              throw new DatabaseException("Can not save table "' ex);                          }                            break;                      }                  case ConnectionType.DATABASE_MYSQL:                      {                          return;                      }                  case ConnectionType.DATABASE_OLEDB:                      {                          try                          {                              var conn = new OleDbConnection(connString);                              var adapter = new OleDbDataAdapter("SELECT * from " + tableName' conn);                              var builder = new OleDbCommandBuilder(adapter);                                adapter.DeleteCommand = builder.GetDeleteCommand();                              adapter.UpdateCommand = builder.GetUpdateCommand();                              adapter.InsertCommand = builder.GetInsertCommand();                                DataSet changes;                              lock (dataSet) // lock dataset to prevent changes to it                              {                                  adapter.ContinueUpdateOnError = true;                                  changes = dataSet.GetChanges();                                  adapter.Update(changes' tableName);                                  dataSet.AcceptChanges();                              }                                PrintDatasetErrors(changes);                                conn.Close();                          }                          catch (Exception ex)                          {                              throw new DatabaseException("Can not save table"' ex);                          }                          break;                      }              }
Missing Default,FrameWork,PacketOut,C:\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,WritePacketLength,The following switch statement is missing a default case: switch (SizeLen)              {                  case sizeof(byte):                      WriteByte((byte)(size));                      break;                    case sizeof(UInt16):                      if (!SizeReverse) WriteUInt16((UInt16)(size));                      else WriteUInt16R((UInt16)size);                      break;                    case sizeof(UInt32):                      if (!SizeReverse) WriteUInt32((UInt16)(size));                      else WriteUInt32R((UInt16)size);                      break;                    case sizeof(UInt64):                      if (!SizeReverse) WriteUInt32((UInt16)(size));                      else WriteUInt32R((UInt16)size);                      break;              }
Missing Default,FrameWork,InfBlocks,C:\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following switch statement is missing a default case: switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}
